"use strict";
(() => {
  var __defProp = Object.defineProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a2, b2) => (typeof require !== "undefined" ? require : a2)[b2]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __export = (target2, all) => {
    for (var name in all)
      __defProp(target2, name, { get: all[name], enumerable: true });
  };

  // node_modules/post-me/dist/index.esnext.mjs
  var MARKER = "@post-me";
  function createUniqueIdFn() {
    let __id = 0;
    return function() {
      const id = __id;
      __id += 1;
      return id;
    };
  }
  var ConcreteEmitter = class {
    constructor() {
      this._listeners = {};
    }
    /** {@inheritDoc Emitter.addEventListener} */
    addEventListener(eventName, listener) {
      let listeners = this._listeners[eventName];
      if (!listeners) {
        listeners = /* @__PURE__ */ new Set();
        this._listeners[eventName] = listeners;
      }
      listeners.add(listener);
    }
    /** {@inheritDoc Emitter.removeEventListener} */
    removeEventListener(eventName, listener) {
      let listeners = this._listeners[eventName];
      if (!listeners) {
        return;
      }
      listeners.delete(listener);
    }
    /** {@inheritDoc Emitter.once} */
    once(eventName) {
      return new Promise((resolve2) => {
        const listener = (data) => {
          this.removeEventListener(eventName, listener);
          resolve2(data);
        };
        this.addEventListener(eventName, listener);
      });
    }
    /** @internal */
    emit(eventName, data) {
      let listeners = this._listeners[eventName];
      if (!listeners) {
        return;
      }
      listeners.forEach((listener) => {
        listener(data);
      });
    }
    /** @internal */
    removeAllListeners() {
      Object.values(this._listeners).forEach((listeners) => {
        if (listeners) {
          listeners.clear();
        }
      });
    }
  };
  var MessageType;
  (function(MessageType2) {
    MessageType2["HandshakeRequest"] = "handshake-request";
    MessageType2["HandshakeResponse"] = "handshake-response";
    MessageType2["Call"] = "call";
    MessageType2["Response"] = "response";
    MessageType2["Error"] = "error";
    MessageType2["Event"] = "event";
    MessageType2["Callback"] = "callback";
  })(MessageType || (MessageType = {}));
  function createHandshakeResponseMessage(sessionId) {
    return {
      type: MARKER,
      action: MessageType.HandshakeResponse,
      sessionId
    };
  }
  function createCallMessage(sessionId, requestId, methodName, args) {
    return {
      type: MARKER,
      action: MessageType.Call,
      sessionId,
      requestId,
      methodName,
      args
    };
  }
  function createResponsMessage(sessionId, requestId, result2, error) {
    const message = {
      type: MARKER,
      action: MessageType.Response,
      sessionId,
      requestId
    };
    if (result2 !== void 0) {
      message.result = result2;
    }
    if (error !== void 0) {
      message.error = error;
    }
    return message;
  }
  function createCallbackMessage(sessionId, requestId, callbackId, args) {
    return {
      type: MARKER,
      action: MessageType.Callback,
      sessionId,
      requestId,
      callbackId,
      args
    };
  }
  function createEventMessage(sessionId, eventName, payload) {
    return {
      type: MARKER,
      action: MessageType.Event,
      sessionId,
      eventName,
      payload
    };
  }
  function isMessage(m) {
    return m && m.type === MARKER;
  }
  function isHandshakeRequestMessage(m) {
    return isMessage(m) && m.action === MessageType.HandshakeRequest;
  }
  function isCallMessage(m) {
    return isMessage(m) && m.action === MessageType.Call;
  }
  function isResponseMessage(m) {
    return isMessage(m) && m.action === MessageType.Response;
  }
  function isCallbackMessage(m) {
    return isMessage(m) && m.action === MessageType.Callback;
  }
  function isEventMessage(m) {
    return isMessage(m) && m.action === MessageType.Event;
  }
  function makeCallbackEvent(requestId) {
    return `callback_${requestId}`;
  }
  function makeResponseEvent(requestId) {
    return `response_${requestId}`;
  }
  var Dispatcher = class extends ConcreteEmitter {
    constructor(messenger2, sessionId) {
      super();
      this.uniqueId = createUniqueIdFn();
      this.messenger = messenger2;
      this.sessionId = sessionId;
      this.removeMessengerListener = this.messenger.addMessageListener(this.messengerListener.bind(this));
    }
    messengerListener(event) {
      const { data } = event;
      if (!isMessage(data)) {
        return;
      }
      if (this.sessionId !== data.sessionId) {
        return;
      }
      if (isCallMessage(data)) {
        this.emit(MessageType.Call, data);
      } else if (isResponseMessage(data)) {
        this.emit(makeResponseEvent(data.requestId), data);
      } else if (isEventMessage(data)) {
        this.emit(MessageType.Event, data);
      } else if (isCallbackMessage(data)) {
        this.emit(makeCallbackEvent(data.requestId), data);
      }
    }
    callOnRemote(methodName, args, transfer) {
      const requestId = this.uniqueId();
      const callbackEvent = makeCallbackEvent(requestId);
      const responseEvent = makeResponseEvent(requestId);
      const message = createCallMessage(this.sessionId, requestId, methodName, args);
      this.messenger.postMessage(message, transfer);
      return { callbackEvent, responseEvent };
    }
    respondToRemote(requestId, value3, error, transfer) {
      if (error instanceof Error) {
        error = {
          name: error.name,
          message: error.message
        };
      }
      const message = createResponsMessage(this.sessionId, requestId, value3, error);
      this.messenger.postMessage(message, transfer);
    }
    callbackToRemote(requestId, callbackId, args) {
      const message = createCallbackMessage(this.sessionId, requestId, callbackId, args);
      this.messenger.postMessage(message);
    }
    emitToRemote(eventName, payload, transfer) {
      const message = createEventMessage(this.sessionId, eventName, payload);
      this.messenger.postMessage(message, transfer);
    }
    close() {
      this.removeMessengerListener();
      this.removeAllListeners();
    }
  };
  var ChildHandshakeDispatcher = class extends ConcreteEmitter {
    constructor(messenger2) {
      super();
      this.messenger = messenger2;
      this.removeMessengerListener = this.messenger.addMessageListener(this.messengerListener.bind(this));
    }
    messengerListener(event) {
      const { data } = event;
      if (isHandshakeRequestMessage(data)) {
        this.emit(MessageType.HandshakeRequest, data);
      }
    }
    acceptHandshake(sessionId) {
      const message = createHandshakeResponseMessage(sessionId);
      this.messenger.postMessage(message);
    }
    close() {
      this.removeMessengerListener();
      this.removeAllListeners();
    }
  };
  var ProxyType;
  (function(ProxyType2) {
    ProxyType2["Callback"] = "callback";
  })(ProxyType || (ProxyType = {}));
  function createCallbackProxy(callbackId) {
    return {
      type: MARKER,
      proxy: ProxyType.Callback,
      callbackId
    };
  }
  function isCallbackProxy(p) {
    return p && p.type === MARKER && p.proxy === ProxyType.Callback;
  }
  var ConcreteRemoteHandle = class extends ConcreteEmitter {
    constructor(dispatcher) {
      super();
      this._dispatcher = dispatcher;
      this._callTransfer = {};
      this._dispatcher.addEventListener(MessageType.Event, this._handleEvent.bind(this));
    }
    close() {
      this.removeAllListeners();
    }
    setCallTransfer(methodName, transfer) {
      this._callTransfer[methodName] = transfer;
    }
    call(methodName, ...args) {
      return this.customCall(methodName, args);
    }
    customCall(methodName, args, options = {}) {
      return new Promise((resolve2, reject) => {
        const sanitizedArgs = [];
        const callbacks = [];
        let callbackId = 0;
        args.forEach((arg) => {
          if (typeof arg === "function") {
            callbacks.push(arg);
            sanitizedArgs.push(createCallbackProxy(callbackId));
            callbackId += 1;
          } else {
            sanitizedArgs.push(arg);
          }
        });
        const hasCallbacks = callbacks.length > 0;
        let callbackListener = void 0;
        if (hasCallbacks) {
          callbackListener = (data) => {
            const { callbackId: callbackId2, args: args2 } = data;
            callbacks[callbackId2](...args2);
          };
        }
        let transfer = options.transfer;
        if (transfer === void 0 && this._callTransfer[methodName]) {
          transfer = this._callTransfer[methodName](...sanitizedArgs);
        }
        const { callbackEvent, responseEvent } = this._dispatcher.callOnRemote(methodName, sanitizedArgs, transfer);
        if (hasCallbacks) {
          this._dispatcher.addEventListener(callbackEvent, callbackListener);
        }
        this._dispatcher.once(responseEvent).then((response) => {
          if (callbackListener) {
            this._dispatcher.removeEventListener(callbackEvent, callbackListener);
          }
          const { result: result2, error } = response;
          if (error !== void 0) {
            reject(error);
          } else {
            resolve2(result2);
          }
        });
      });
    }
    _handleEvent(data) {
      const { eventName, payload } = data;
      this.emit(eventName, payload);
    }
  };
  var ConcreteLocalHandle = class {
    constructor(dispatcher, localMethods) {
      this._dispatcher = dispatcher;
      this._methods = localMethods;
      this._returnTransfer = {};
      this._emitTransfer = {};
      this._dispatcher.addEventListener(MessageType.Call, this._handleCall.bind(this));
    }
    emit(eventName, payload, options = {}) {
      let transfer = options.transfer;
      if (transfer === void 0 && this._emitTransfer[eventName]) {
        transfer = this._emitTransfer[eventName](payload);
      }
      this._dispatcher.emitToRemote(eventName, payload, transfer);
    }
    setMethods(methods) {
      this._methods = methods;
    }
    setMethod(methodName, method) {
      this._methods[methodName] = method;
    }
    setReturnTransfer(methodName, transfer) {
      this._returnTransfer[methodName] = transfer;
    }
    setEmitTransfer(eventName, transfer) {
      this._emitTransfer[eventName] = transfer;
    }
    _handleCall(data) {
      const { requestId, methodName, args } = data;
      const callMethod = new Promise((resolve2, reject) => {
        const method = this._methods[methodName];
        if (typeof method !== "function") {
          reject(new Error(`The method "${methodName}" has not been implemented.`));
          return;
        }
        const desanitizedArgs = args.map((arg) => {
          if (isCallbackProxy(arg)) {
            const { callbackId } = arg;
            return (...args2) => {
              this._dispatcher.callbackToRemote(requestId, callbackId, args2);
            };
          } else {
            return arg;
          }
        });
        Promise.resolve(this._methods[methodName](...desanitizedArgs)).then(resolve2).catch(reject);
      });
      callMethod.then((result2) => {
        let transfer;
        if (this._returnTransfer[methodName]) {
          transfer = this._returnTransfer[methodName](result2);
        }
        this._dispatcher.respondToRemote(requestId, result2, void 0, transfer);
      }).catch((error) => {
        this._dispatcher.respondToRemote(requestId, void 0, error);
      });
    }
  };
  var ConcreteConnection = class {
    constructor(dispatcher, localMethods) {
      this._dispatcher = dispatcher;
      this._localHandle = new ConcreteLocalHandle(dispatcher, localMethods);
      this._remoteHandle = new ConcreteRemoteHandle(dispatcher);
    }
    close() {
      this._dispatcher.close();
      this.remoteHandle().close();
    }
    localHandle() {
      return this._localHandle;
    }
    remoteHandle() {
      return this._remoteHandle;
    }
  };
  var uniqueSessionId = createUniqueIdFn();
  function ChildHandshake(messenger2, localMethods = {}) {
    return new Promise((resolve2, reject) => {
      const handshakeDispatcher = new ChildHandshakeDispatcher(messenger2);
      handshakeDispatcher.once(MessageType.HandshakeRequest).then((response) => {
        const { sessionId } = response;
        handshakeDispatcher.acceptHandshake(sessionId);
        handshakeDispatcher.close();
        const dispatcher = new Dispatcher(messenger2, sessionId);
        const connection = new ConcreteConnection(dispatcher, localMethods);
        resolve2(connection);
      });
    });
  }
  var BareMessenger = class {
    constructor(postable) {
      this.postMessage = (message, transfer = []) => {
        postable.postMessage(message, transfer);
      };
      this.addMessageListener = (listener) => {
        const outerListener = (event) => {
          listener(event);
        };
        postable.addEventListener("message", outerListener);
        const removeListener = () => {
          postable.removeEventListener("message", outerListener);
        };
        return removeListener;
      };
    }
  };
  var WorkerMessenger = class extends BareMessenger {
    constructor({ worker }) {
      super(worker);
    }
  };

  // src-www/js/libs/pixi-webworker.mjs
  var pixi_webworker_exports = {};
  __export(pixi_webworker_exports, {
    ALPHA_MODES: () => ALPHA_MODES,
    AbstractMultiResource: () => AbstractMultiResource,
    AnimatedSprite: () => AnimatedSprite,
    Application: () => Application,
    ArrayResource: () => ArrayResource,
    Assets: () => Assets,
    AssetsClass: () => AssetsClass,
    Attribute: () => Attribute,
    BLEND_MODES: () => BLEND_MODES,
    BUFFER_BITS: () => BUFFER_BITS,
    BUFFER_TYPE: () => BUFFER_TYPE,
    BackgroundSystem: () => BackgroundSystem,
    BaseImageResource: () => BaseImageResource,
    BasePrepare: () => BasePrepare,
    BaseRenderTexture: () => BaseRenderTexture,
    BaseTexture: () => BaseTexture,
    BatchDrawCall: () => BatchDrawCall,
    BatchGeometry: () => BatchGeometry,
    BatchRenderer: () => BatchRenderer,
    BatchShaderGenerator: () => BatchShaderGenerator,
    BatchSystem: () => BatchSystem,
    BatchTextureArray: () => BatchTextureArray,
    BitmapFont: () => BitmapFont,
    BitmapFontData: () => BitmapFontData,
    BitmapText: () => BitmapText,
    BlobResource: () => BlobResource,
    Bounds: () => Bounds,
    BrowserAdapter: () => BrowserAdapter,
    Buffer: () => Buffer2,
    BufferResource: () => BufferResource,
    BufferSystem: () => BufferSystem,
    CLEAR_MODES: () => CLEAR_MODES,
    COLOR_MASK_BITS: () => COLOR_MASK_BITS,
    Cache: () => Cache,
    CanvasResource: () => CanvasResource,
    Circle: () => Circle,
    CompressedTextureResource: () => CompressedTextureResource,
    Container: () => Container,
    ContextSystem: () => ContextSystem,
    CountLimiter: () => CountLimiter,
    CubeResource: () => CubeResource,
    DEG_TO_RAD: () => DEG_TO_RAD,
    DRAW_MODES: () => DRAW_MODES,
    DisplayObject: () => DisplayObject,
    ENV: () => ENV,
    Ellipse: () => Ellipse,
    ExtensionType: () => ExtensionType,
    Extract: () => Extract,
    FORMATS: () => FORMATS,
    FORMATS_TO_COMPONENTS: () => FORMATS_TO_COMPONENTS,
    FillStyle: () => FillStyle,
    Filter: () => Filter,
    FilterState: () => FilterState,
    FilterSystem: () => FilterSystem,
    Framebuffer: () => Framebuffer,
    FramebufferSystem: () => FramebufferSystem,
    GC_MODES: () => GC_MODES,
    GLFramebuffer: () => GLFramebuffer,
    GLProgram: () => GLProgram,
    GLTexture: () => GLTexture,
    GRAPHICS_CURVES: () => GRAPHICS_CURVES,
    GenerateTextureSystem: () => GenerateTextureSystem,
    Geometry: () => Geometry,
    GeometrySystem: () => GeometrySystem,
    Graphics: () => Graphics,
    GraphicsData: () => GraphicsData,
    GraphicsGeometry: () => GraphicsGeometry,
    IGLUniformData: () => IGLUniformData,
    INSTALLED: () => INSTALLED,
    INTERNAL_FORMATS: () => INTERNAL_FORMATS,
    INTERNAL_FORMAT_TO_BYTES_PER_PIXEL: () => INTERNAL_FORMAT_TO_BYTES_PER_PIXEL,
    ImageBitmapResource: () => ImageBitmapResource,
    ImageResource: () => ImageResource,
    LINE_CAP: () => LINE_CAP,
    LINE_JOIN: () => LINE_JOIN,
    LineStyle: () => LineStyle,
    LoaderParserPriority: () => LoaderParserPriority,
    MASK_TYPES: () => MASK_TYPES,
    MIPMAP_MODES: () => MIPMAP_MODES,
    MSAA_QUALITY: () => MSAA_QUALITY,
    MaskData: () => MaskData,
    MaskSystem: () => MaskSystem,
    Matrix: () => Matrix,
    Mesh: () => Mesh,
    MeshBatchUvs: () => MeshBatchUvs,
    MeshGeometry: () => MeshGeometry,
    MeshMaterial: () => MeshMaterial,
    MultisampleSystem: () => MultisampleSystem,
    NineSlicePlane: () => NineSlicePlane,
    ObjectRenderer: () => ObjectRenderer,
    ObjectRendererSystem: () => ObjectRendererSystem,
    ObservablePoint: () => ObservablePoint,
    PI_2: () => PI_2,
    PRECISION: () => PRECISION,
    ParticleContainer: () => ParticleContainer,
    ParticleRenderer: () => ParticleRenderer,
    PlaneGeometry: () => PlaneGeometry,
    PluginSystem: () => PluginSystem,
    Point: () => Point,
    Polygon: () => Polygon,
    Prepare: () => Prepare,
    Program: () => Program,
    ProjectionSystem: () => ProjectionSystem,
    Quad: () => Quad,
    QuadUv: () => QuadUv,
    RAD_TO_DEG: () => RAD_TO_DEG,
    RENDERER_TYPE: () => RENDERER_TYPE,
    Rectangle: () => Rectangle,
    RenderTexture: () => RenderTexture,
    RenderTexturePool: () => RenderTexturePool,
    RenderTextureSystem: () => RenderTextureSystem,
    Renderer: () => Renderer,
    ResizePlugin: () => ResizePlugin,
    Resource: () => Resource,
    RopeGeometry: () => RopeGeometry,
    RoundedRectangle: () => RoundedRectangle,
    Runner: () => Runner,
    SAMPLER_TYPES: () => SAMPLER_TYPES,
    SCALE_MODES: () => SCALE_MODES,
    SHAPES: () => SHAPES,
    SVGResource: () => SVGResource,
    ScissorSystem: () => ScissorSystem,
    Shader: () => Shader,
    ShaderSystem: () => ShaderSystem,
    SimpleMesh: () => SimpleMesh,
    SimplePlane: () => SimplePlane,
    SimpleRope: () => SimpleRope,
    Sprite: () => Sprite,
    SpriteMaskFilter: () => SpriteMaskFilter,
    Spritesheet: () => Spritesheet,
    StartupSystem: () => StartupSystem,
    State: () => State,
    StateSystem: () => StateSystem,
    StencilSystem: () => StencilSystem,
    SystemManager: () => SystemManager,
    TARGETS: () => TARGETS,
    TEXT_GRADIENT: () => TEXT_GRADIENT,
    TYPES: () => TYPES,
    TYPES_TO_BYTES_PER_COMPONENT: () => TYPES_TO_BYTES_PER_COMPONENT,
    TYPES_TO_BYTES_PER_PIXEL: () => TYPES_TO_BYTES_PER_PIXEL,
    TemporaryDisplayObject: () => TemporaryDisplayObject,
    Text: () => Text$1,
    TextFormat: () => TextFormat,
    TextMetrics: () => TextMetrics,
    TextStyle: () => TextStyle,
    Texture: () => Texture,
    TextureGCSystem: () => TextureGCSystem,
    TextureMatrix: () => TextureMatrix,
    TextureSystem: () => TextureSystem,
    TextureUvs: () => TextureUvs,
    Ticker: () => Ticker,
    TickerPlugin: () => TickerPlugin,
    TilingSprite: () => TilingSprite,
    TilingSpriteRenderer: () => TilingSpriteRenderer,
    TimeLimiter: () => TimeLimiter,
    Transform: () => Transform,
    TransformFeedback: () => TransformFeedback,
    TransformFeedbackSystem: () => TransformFeedbackSystem,
    UPDATE_PRIORITY: () => UPDATE_PRIORITY,
    UniformGroup: () => UniformGroup,
    VERSION: () => VERSION,
    VideoResource: () => VideoResource,
    ViewSystem: () => ViewSystem,
    ViewableBuffer: () => ViewableBuffer,
    WRAP_MODES: () => WRAP_MODES,
    WebWorkerAdapter: () => WebWorkerAdapter,
    XMLFormat: () => XMLFormat,
    XMLStringFormat: () => XMLStringFormat,
    autoDetectFormat: () => autoDetectFormat,
    autoDetectRenderer: () => autoDetectRenderer,
    autoDetectResource: () => autoDetectResource,
    cacheTextureArray: () => cacheTextureArray,
    checkDataUrl: () => checkDataUrl,
    checkExtension: () => checkExtension,
    checkMaxIfStatementsInShader: () => checkMaxIfStatementsInShader,
    convertToList: () => convertToList,
    createStringVariations: () => createStringVariations,
    createTexture: () => createTexture,
    createUBOElements: () => createUBOElements,
    defaultFilterVertex: () => defaultFilterVertex,
    defaultVertex: () => defaultVertex$1,
    detectAvif: () => detectAvif,
    detectCompressedTextures: () => detectCompressedTextures,
    detectDefaults: () => detectDefaults,
    detectWebp: () => detectWebp,
    extensions: () => extensions$1,
    filters: () => filters,
    generateProgram: () => generateProgram,
    generateUniformBufferSync: () => generateUniformBufferSync,
    getFontFamilyName: () => getFontFamilyName,
    getTestContext: () => getTestContext,
    getUBOData: () => getUBOData,
    graphicsUtils: () => graphicsUtils,
    groupD8: () => groupD8,
    isMobile: () => isMobile,
    isSingleItem: () => isSingleItem,
    loadBitmapFont: () => loadBitmapFont,
    loadDDS: () => loadDDS,
    loadImageBitmap: () => loadImageBitmap,
    loadJson: () => loadJson,
    loadKTX: () => loadKTX,
    loadSVG: () => loadSVG,
    loadTextures: () => loadTextures,
    loadTxt: () => loadTxt,
    loadWebFont: () => loadWebFont,
    parseDDS: () => parseDDS,
    parseKTX: () => parseKTX,
    resolveCompressedTextureUrl: () => resolveCompressedTextureUrl,
    resolveTextureUrl: () => resolveTextureUrl,
    settings: () => settings,
    spritesheetAsset: () => spritesheetAsset,
    uniformParsers: () => uniformParsers,
    utils: () => index
  });
  var ENV = /* @__PURE__ */ ((ENV2) => {
    ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
    ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
    ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
    return ENV2;
  })(ENV || {});
  var RENDERER_TYPE = /* @__PURE__ */ ((RENDERER_TYPE2) => {
    RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
    RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
    RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
    return RENDERER_TYPE2;
  })(RENDERER_TYPE || {});
  var BUFFER_BITS = /* @__PURE__ */ ((BUFFER_BITS2) => {
    BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
    BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
    BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
    return BUFFER_BITS2;
  })(BUFFER_BITS || {});
  var BLEND_MODES = /* @__PURE__ */ ((BLEND_MODES2) => {
    BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
    BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
    BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
    BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
    BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
    BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
    BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
    BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
    BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
    BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
    BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
    BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
    BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
    BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
    BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
    BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
    BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
    BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
    BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
    BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
    BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
    BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
    BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
    BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
    BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
    BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
    BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
    BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
    BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
    BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
    BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
    BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
    return BLEND_MODES2;
  })(BLEND_MODES || {});
  var DRAW_MODES = /* @__PURE__ */ ((DRAW_MODES2) => {
    DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
    DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
    DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
    DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
    DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
    DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
    DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
    return DRAW_MODES2;
  })(DRAW_MODES || {});
  var FORMATS = /* @__PURE__ */ ((FORMATS2) => {
    FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
    FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
    FORMATS2[FORMATS2["RG"] = 33319] = "RG";
    FORMATS2[FORMATS2["RED"] = 6403] = "RED";
    FORMATS2[FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
    FORMATS2[FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
    FORMATS2[FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
    FORMATS2[FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
    FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
    FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
    FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
    FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
    FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
    return FORMATS2;
  })(FORMATS || {});
  var TARGETS = /* @__PURE__ */ ((TARGETS2) => {
    TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
    TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
    TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
    TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
    TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
    TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
    TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
    TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
    TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
    return TARGETS2;
  })(TARGETS || {});
  var TYPES = /* @__PURE__ */ ((TYPES2) => {
    TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
    TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
    TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
    TYPES2[TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
    TYPES2[TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
    TYPES2[TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
    TYPES2[TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
    TYPES2[TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
    TYPES2[TYPES2["BYTE"] = 5120] = "BYTE";
    TYPES2[TYPES2["SHORT"] = 5122] = "SHORT";
    TYPES2[TYPES2["INT"] = 5124] = "INT";
    TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
    TYPES2[TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
    TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
    return TYPES2;
  })(TYPES || {});
  var SAMPLER_TYPES = /* @__PURE__ */ ((SAMPLER_TYPES2) => {
    SAMPLER_TYPES2[SAMPLER_TYPES2["FLOAT"] = 0] = "FLOAT";
    SAMPLER_TYPES2[SAMPLER_TYPES2["INT"] = 1] = "INT";
    SAMPLER_TYPES2[SAMPLER_TYPES2["UINT"] = 2] = "UINT";
    return SAMPLER_TYPES2;
  })(SAMPLER_TYPES || {});
  var SCALE_MODES = /* @__PURE__ */ ((SCALE_MODES2) => {
    SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
    SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
    return SCALE_MODES2;
  })(SCALE_MODES || {});
  var WRAP_MODES = /* @__PURE__ */ ((WRAP_MODES2) => {
    WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
    WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
    WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
    return WRAP_MODES2;
  })(WRAP_MODES || {});
  var MIPMAP_MODES = /* @__PURE__ */ ((MIPMAP_MODES2) => {
    MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
    MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
    MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
    MIPMAP_MODES2[MIPMAP_MODES2["ON_MANUAL"] = 3] = "ON_MANUAL";
    return MIPMAP_MODES2;
  })(MIPMAP_MODES || {});
  var ALPHA_MODES = /* @__PURE__ */ ((ALPHA_MODES2) => {
    ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
    ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
    ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
    ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
    ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
    ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
    return ALPHA_MODES2;
  })(ALPHA_MODES || {});
  var CLEAR_MODES = /* @__PURE__ */ ((CLEAR_MODES2) => {
    CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
    CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
    CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
    CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
    CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
    CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
    return CLEAR_MODES2;
  })(CLEAR_MODES || {});
  var GC_MODES = /* @__PURE__ */ ((GC_MODES2) => {
    GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
    GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
    return GC_MODES2;
  })(GC_MODES || {});
  var PRECISION = /* @__PURE__ */ ((PRECISION2) => {
    PRECISION2["LOW"] = "lowp";
    PRECISION2["MEDIUM"] = "mediump";
    PRECISION2["HIGH"] = "highp";
    return PRECISION2;
  })(PRECISION || {});
  var MASK_TYPES = /* @__PURE__ */ ((MASK_TYPES2) => {
    MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
    MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
    MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
    MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
    MASK_TYPES2[MASK_TYPES2["COLOR"] = 4] = "COLOR";
    return MASK_TYPES2;
  })(MASK_TYPES || {});
  var COLOR_MASK_BITS = /* @__PURE__ */ ((COLOR_MASK_BITS2) => {
    COLOR_MASK_BITS2[COLOR_MASK_BITS2["RED"] = 1] = "RED";
    COLOR_MASK_BITS2[COLOR_MASK_BITS2["GREEN"] = 2] = "GREEN";
    COLOR_MASK_BITS2[COLOR_MASK_BITS2["BLUE"] = 4] = "BLUE";
    COLOR_MASK_BITS2[COLOR_MASK_BITS2["ALPHA"] = 8] = "ALPHA";
    return COLOR_MASK_BITS2;
  })(COLOR_MASK_BITS || {});
  var MSAA_QUALITY = /* @__PURE__ */ ((MSAA_QUALITY2) => {
    MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
    MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
    MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
    MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
    return MSAA_QUALITY2;
  })(MSAA_QUALITY || {});
  var BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE2) => {
    BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
    BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
    BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
    return BUFFER_TYPE2;
  })(BUFFER_TYPE || {});
  var BrowserAdapter = {
    createCanvas: (width, height) => {
      const canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      return canvas;
    },
    getWebGLRenderingContext: () => WebGLRenderingContext,
    getNavigator: () => navigator,
    getBaseUrl: () => document.baseURI ?? window.location.href,
    getFontFaceSet: () => document.fonts,
    fetch: (url2, options) => fetch(url2, options),
    parseXML: (xml) => {
      const parser = new DOMParser();
      return parser.parseFromString(xml, "text/xml");
    }
  };
  var appleIphone = /iPhone/i;
  var appleIpod = /iPod/i;
  var appleTablet = /iPad/i;
  var appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
  var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
  var androidTablet = /Android/i;
  var amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
  var amazonTablet = /Silk/i;
  var windowsPhone = /Windows Phone/i;
  var windowsTablet = /\bWindows(?:.+)ARM\b/i;
  var otherBlackBerry = /BlackBerry/i;
  var otherBlackBerry10 = /BB10/i;
  var otherOpera = /Opera Mini/i;
  var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
  var otherFirefox = /Mobile(?:.+)Firefox\b/i;
  var isAppleTabletOnIos13 = function(navigator2) {
    return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && navigator2.maxTouchPoints > 1 && typeof MSStream === "undefined";
  };
  function createMatch(userAgent) {
    return function(regex) {
      return regex.test(userAgent);
    };
  }
  function isMobile$1(param) {
    var nav = {
      userAgent: "",
      platform: "",
      maxTouchPoints: 0
    };
    if (!param && typeof navigator !== "undefined") {
      nav = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        maxTouchPoints: navigator.maxTouchPoints || 0
      };
    } else if (typeof param === "string") {
      nav.userAgent = param;
    } else if (param && param.userAgent) {
      nav = {
        userAgent: param.userAgent,
        platform: param.platform,
        maxTouchPoints: param.maxTouchPoints || 0
      };
    }
    var userAgent = nav.userAgent;
    var tmp = userAgent.split("[FBAN");
    if (typeof tmp[1] !== "undefined") {
      userAgent = tmp[0];
    }
    tmp = userAgent.split("Twitter");
    if (typeof tmp[1] !== "undefined") {
      userAgent = tmp[0];
    }
    var match = createMatch(userAgent);
    var result2 = {
      apple: {
        phone: match(appleIphone) && !match(windowsPhone),
        ipod: match(appleIpod),
        tablet: !match(appleIphone) && (match(appleTablet) || isAppleTabletOnIos13(nav)) && !match(windowsPhone),
        universal: match(appleUniversal),
        device: (match(appleIphone) || match(appleIpod) || match(appleTablet) || match(appleUniversal) || isAppleTabletOnIos13(nav)) && !match(windowsPhone)
      },
      amazon: {
        phone: match(amazonPhone),
        tablet: !match(amazonPhone) && match(amazonTablet),
        device: match(amazonPhone) || match(amazonTablet)
      },
      android: {
        phone: !match(windowsPhone) && match(amazonPhone) || !match(windowsPhone) && match(androidPhone),
        tablet: !match(windowsPhone) && !match(amazonPhone) && !match(androidPhone) && (match(amazonTablet) || match(androidTablet)),
        device: !match(windowsPhone) && (match(amazonPhone) || match(amazonTablet) || match(androidPhone) || match(androidTablet)) || match(/\bokhttp\b/i)
      },
      windows: {
        phone: match(windowsPhone),
        tablet: match(windowsTablet),
        device: match(windowsPhone) || match(windowsTablet)
      },
      other: {
        blackberry: match(otherBlackBerry),
        blackberry10: match(otherBlackBerry10),
        opera: match(otherOpera),
        firefox: match(otherFirefox),
        chrome: match(otherChrome),
        device: match(otherBlackBerry) || match(otherBlackBerry10) || match(otherOpera) || match(otherFirefox) || match(otherChrome)
      },
      any: false,
      phone: false,
      tablet: false
    };
    result2.any = result2.apple.device || result2.android.device || result2.windows.device || result2.other.device;
    result2.phone = result2.apple.phone || result2.android.phone || result2.windows.phone;
    result2.tablet = result2.apple.tablet || result2.android.tablet || result2.windows.tablet;
    return result2;
  }
  var isMobile = isMobile$1(globalThis.navigator);
  function canUploadSameBuffer() {
    return !isMobile.apple.device;
  }
  function maxRecommendedTextures(max) {
    let allowMax = true;
    if (isMobile.tablet || isMobile.phone) {
      if (isMobile.apple.device) {
        const match = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
        if (match) {
          const majorVersion = parseInt(match[1], 10);
          if (majorVersion < 11) {
            allowMax = false;
          }
        }
      }
      if (isMobile.android.device) {
        const match = navigator.userAgent.match(/Android\s([0-9.]*)/);
        if (match) {
          const majorVersion = parseInt(match[1], 10);
          if (majorVersion < 7) {
            allowMax = false;
          }
        }
      }
    }
    return allowMax ? max : 4;
  }
  var settings = {
    ADAPTER: BrowserAdapter,
    MIPMAP_TEXTURES: MIPMAP_MODES.POW2,
    ANISOTROPIC_LEVEL: 0,
    RESOLUTION: 1,
    FILTER_RESOLUTION: 1,
    FILTER_MULTISAMPLE: MSAA_QUALITY.NONE,
    SPRITE_MAX_TEXTURES: maxRecommendedTextures(32),
    SPRITE_BATCH_SIZE: 4096,
    RENDER_OPTIONS: {
      view: null,
      antialias: false,
      autoDensity: false,
      backgroundColor: 0,
      backgroundAlpha: 1,
      premultipliedAlpha: true,
      clearBeforeRender: true,
      preserveDrawingBuffer: false,
      width: 800,
      height: 600,
      legacy: false,
      hello: false
    },
    GC_MODE: GC_MODES.AUTO,
    GC_MAX_IDLE: 60 * 60,
    GC_MAX_CHECK_COUNT: 60 * 10,
    WRAP_MODE: WRAP_MODES.CLAMP,
    SCALE_MODE: SCALE_MODES.LINEAR,
    PRECISION_VERTEX: PRECISION.HIGH,
    PRECISION_FRAGMENT: isMobile.apple.device ? PRECISION.HIGH : PRECISION.MEDIUM,
    CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer(),
    CREATE_IMAGE_BITMAP: false,
    ROUND_PIXELS: false
  };
  settings.PREFER_ENV = ENV.WEBGL2;
  settings.STRICT_TEXTURE_CACHE = false;
  var ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {
    ExtensionType2["Renderer"] = "renderer";
    ExtensionType2["Application"] = "application";
    ExtensionType2["RendererSystem"] = "renderer-webgl-system";
    ExtensionType2["RendererPlugin"] = "renderer-webgl-plugin";
    ExtensionType2["CanvasRendererSystem"] = "renderer-canvas-system";
    ExtensionType2["CanvasRendererPlugin"] = "renderer-canvas-plugin";
    ExtensionType2["Asset"] = "asset";
    ExtensionType2["LoadParser"] = "load-parser";
    ExtensionType2["ResolveParser"] = "resolve-parser";
    ExtensionType2["CacheParser"] = "cache-parser";
    ExtensionType2["DetectionParser"] = "detection-parser";
    return ExtensionType2;
  })(ExtensionType || {});
  var normalizeExtension = (ext) => {
    if (typeof ext === "function" || typeof ext === "object" && ext.extension) {
      if (!ext.extension) {
        throw new Error("Extension class must have an extension object");
      }
      const metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;
      ext = { ...metadata, ref: ext };
    }
    if (typeof ext === "object") {
      ext = { ...ext };
    } else {
      throw new Error("Invalid extension type");
    }
    if (typeof ext.type === "string") {
      ext.type = [ext.type];
    }
    return ext;
  };
  var normalizePriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;
  var extensions$1 = {
    _addHandlers: {},
    _removeHandlers: {},
    _queue: {},
    remove(...extensions2) {
      extensions2.map(normalizeExtension).forEach((ext) => {
        ext.type.forEach((type) => this._removeHandlers[type]?.(ext));
      });
      return this;
    },
    add(...extensions2) {
      extensions2.map(normalizeExtension).forEach((ext) => {
        ext.type.forEach((type) => {
          const handlers = this._addHandlers;
          const queue = this._queue;
          if (!handlers[type]) {
            queue[type] = queue[type] || [];
            queue[type].push(ext);
          } else {
            handlers[type](ext);
          }
        });
      });
      return this;
    },
    handle(type, onAdd, onRemove) {
      const addHandlers = this._addHandlers;
      const removeHandlers = this._removeHandlers;
      if (addHandlers[type] || removeHandlers[type]) {
        throw new Error(`Extension type ${type} already has a handler`);
      }
      addHandlers[type] = onAdd;
      removeHandlers[type] = onRemove;
      const queue = this._queue;
      if (queue[type]) {
        queue[type].forEach((ext) => onAdd(ext));
        delete queue[type];
      }
      return this;
    },
    handleByMap(type, map2) {
      return this.handle(type, (extension) => {
        map2[extension.name] = extension.ref;
      }, (extension) => {
        delete map2[extension.name];
      });
    },
    handleByList(type, list, defaultPriority = -1) {
      return this.handle(type, (extension) => {
        if (list.includes(extension.ref)) {
          return;
        }
        list.push(extension.ref);
        list.sort((a2, b2) => normalizePriority(b2, defaultPriority) - normalizePriority(a2, defaultPriority));
      }, (extension) => {
        const index2 = list.indexOf(extension.ref);
        if (index2 !== -1) {
          list.splice(index2, 1);
        }
      });
    }
  };
  var PI_2 = Math.PI * 2;
  var RAD_TO_DEG = 180 / Math.PI;
  var DEG_TO_RAD = Math.PI / 180;
  var SHAPES = /* @__PURE__ */ ((SHAPES2) => {
    SHAPES2[SHAPES2["POLY"] = 0] = "POLY";
    SHAPES2[SHAPES2["RECT"] = 1] = "RECT";
    SHAPES2[SHAPES2["CIRC"] = 2] = "CIRC";
    SHAPES2[SHAPES2["ELIP"] = 3] = "ELIP";
    SHAPES2[SHAPES2["RREC"] = 4] = "RREC";
    return SHAPES2;
  })(SHAPES || {});
  var Point = class {
    constructor(x = 0, y = 0) {
      this.x = 0;
      this.y = 0;
      this.x = x;
      this.y = y;
    }
    clone() {
      return new Point(this.x, this.y);
    }
    copyFrom(p) {
      this.set(p.x, p.y);
      return this;
    }
    copyTo(p) {
      p.set(this.x, this.y);
      return p;
    }
    equals(p) {
      return p.x === this.x && p.y === this.y;
    }
    set(x = 0, y = x) {
      this.x = x;
      this.y = y;
      return this;
    }
    toString() {
      return `[@pixi/math:Point x=${this.x} y=${this.y}]`;
    }
  };
  var tempPoints$1 = [new Point(), new Point(), new Point(), new Point()];
  var Rectangle = class {
    constructor(x = 0, y = 0, width = 0, height = 0) {
      this.x = Number(x);
      this.y = Number(y);
      this.width = Number(width);
      this.height = Number(height);
      this.type = SHAPES.RECT;
    }
    get left() {
      return this.x;
    }
    get right() {
      return this.x + this.width;
    }
    get top() {
      return this.y;
    }
    get bottom() {
      return this.y + this.height;
    }
    static get EMPTY() {
      return new Rectangle(0, 0, 0, 0);
    }
    clone() {
      return new Rectangle(this.x, this.y, this.width, this.height);
    }
    copyFrom(rectangle) {
      this.x = rectangle.x;
      this.y = rectangle.y;
      this.width = rectangle.width;
      this.height = rectangle.height;
      return this;
    }
    copyTo(rectangle) {
      rectangle.x = this.x;
      rectangle.y = this.y;
      rectangle.width = this.width;
      rectangle.height = this.height;
      return rectangle;
    }
    contains(x, y) {
      if (this.width <= 0 || this.height <= 0) {
        return false;
      }
      if (x >= this.x && x < this.x + this.width) {
        if (y >= this.y && y < this.y + this.height) {
          return true;
        }
      }
      return false;
    }
    intersects(other, transform) {
      if (!transform) {
        const x02 = this.x < other.x ? other.x : this.x;
        const x12 = this.right > other.right ? other.right : this.right;
        if (x12 <= x02) {
          return false;
        }
        const y02 = this.y < other.y ? other.y : this.y;
        const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;
        return y12 > y02;
      }
      const x0 = this.left;
      const x1 = this.right;
      const y0 = this.top;
      const y1 = this.bottom;
      if (x1 <= x0 || y1 <= y0) {
        return false;
      }
      const lt = tempPoints$1[0].set(other.left, other.top);
      const lb = tempPoints$1[1].set(other.left, other.bottom);
      const rt = tempPoints$1[2].set(other.right, other.top);
      const rb = tempPoints$1[3].set(other.right, other.bottom);
      if (rt.x <= lt.x || lb.y <= lt.y) {
        return false;
      }
      const s = Math.sign(transform.a * transform.d - transform.b * transform.c);
      if (s === 0) {
        return false;
      }
      transform.apply(lt, lt);
      transform.apply(lb, lb);
      transform.apply(rt, rt);
      transform.apply(rb, rb);
      if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {
        return false;
      }
      const nx = s * (lb.y - lt.y);
      const ny = s * (lt.x - lb.x);
      const n00 = nx * x0 + ny * y0;
      const n10 = nx * x1 + ny * y0;
      const n01 = nx * x0 + ny * y1;
      const n11 = nx * x1 + ny * y1;
      if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
        return false;
      }
      const mx = s * (lt.y - rt.y);
      const my = s * (rt.x - lt.x);
      const m00 = mx * x0 + my * y0;
      const m10 = mx * x1 + my * y0;
      const m01 = mx * x0 + my * y1;
      const m11 = mx * x1 + my * y1;
      if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
        return false;
      }
      return true;
    }
    pad(paddingX = 0, paddingY = paddingX) {
      this.x -= paddingX;
      this.y -= paddingY;
      this.width += paddingX * 2;
      this.height += paddingY * 2;
      return this;
    }
    fit(rectangle) {
      const x1 = Math.max(this.x, rectangle.x);
      const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
      const y1 = Math.max(this.y, rectangle.y);
      const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
      this.x = x1;
      this.width = Math.max(x2 - x1, 0);
      this.y = y1;
      this.height = Math.max(y2 - y1, 0);
      return this;
    }
    ceil(resolution = 1, eps = 1e-3) {
      const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
      const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
      this.x = Math.floor((this.x + eps) * resolution) / resolution;
      this.y = Math.floor((this.y + eps) * resolution) / resolution;
      this.width = x2 - this.x;
      this.height = y2 - this.y;
      return this;
    }
    enlarge(rectangle) {
      const x1 = Math.min(this.x, rectangle.x);
      const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
      const y1 = Math.min(this.y, rectangle.y);
      const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
      this.x = x1;
      this.width = x2 - x1;
      this.y = y1;
      this.height = y2 - y1;
      return this;
    }
    toString() {
      return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
    }
  };
  var Circle = class {
    constructor(x = 0, y = 0, radius = 0) {
      this.x = x;
      this.y = y;
      this.radius = radius;
      this.type = SHAPES.CIRC;
    }
    clone() {
      return new Circle(this.x, this.y, this.radius);
    }
    contains(x, y) {
      if (this.radius <= 0) {
        return false;
      }
      const r2 = this.radius * this.radius;
      let dx = this.x - x;
      let dy = this.y - y;
      dx *= dx;
      dy *= dy;
      return dx + dy <= r2;
    }
    getBounds() {
      return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
    }
    toString() {
      return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
    }
  };
  var Ellipse = class {
    constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0) {
      this.x = x;
      this.y = y;
      this.width = halfWidth;
      this.height = halfHeight;
      this.type = SHAPES.ELIP;
    }
    clone() {
      return new Ellipse(this.x, this.y, this.width, this.height);
    }
    contains(x, y) {
      if (this.width <= 0 || this.height <= 0) {
        return false;
      }
      let normx = (x - this.x) / this.width;
      let normy = (y - this.y) / this.height;
      normx *= normx;
      normy *= normy;
      return normx + normy <= 1;
    }
    getBounds() {
      return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
    }
    toString() {
      return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
    }
  };
  var Polygon = class {
    constructor(...points) {
      let flat = Array.isArray(points[0]) ? points[0] : points;
      if (typeof flat[0] !== "number") {
        const p = [];
        for (let i = 0, il = flat.length; i < il; i++) {
          p.push(flat[i].x, flat[i].y);
        }
        flat = p;
      }
      this.points = flat;
      this.type = SHAPES.POLY;
      this.closeStroke = true;
    }
    clone() {
      const points = this.points.slice();
      const polygon = new Polygon(points);
      polygon.closeStroke = this.closeStroke;
      return polygon;
    }
    contains(x, y) {
      let inside = false;
      const length = this.points.length / 2;
      for (let i = 0, j = length - 1; i < length; j = i++) {
        const xi = this.points[i * 2];
        const yi = this.points[i * 2 + 1];
        const xj = this.points[j * 2];
        const yj = this.points[j * 2 + 1];
        const intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;
        if (intersect) {
          inside = !inside;
        }
      }
      return inside;
    }
    toString() {
      return `[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
    }
  };
  var RoundedRectangle = class {
    constructor(x = 0, y = 0, width = 0, height = 0, radius = 20) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.radius = radius;
      this.type = SHAPES.RREC;
    }
    clone() {
      return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
    }
    contains(x, y) {
      if (this.width <= 0 || this.height <= 0) {
        return false;
      }
      if (x >= this.x && x <= this.x + this.width) {
        if (y >= this.y && y <= this.y + this.height) {
          const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
          if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius) {
            return true;
          }
          let dx = x - (this.x + radius);
          let dy = y - (this.y + radius);
          const radius2 = radius * radius;
          if (dx * dx + dy * dy <= radius2) {
            return true;
          }
          dx = x - (this.x + this.width - radius);
          if (dx * dx + dy * dy <= radius2) {
            return true;
          }
          dy = y - (this.y + this.height - radius);
          if (dx * dx + dy * dy <= radius2) {
            return true;
          }
          dx = x - (this.x + radius);
          if (dx * dx + dy * dy <= radius2) {
            return true;
          }
        }
      }
      return false;
    }
    toString() {
      return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
    }
  };
  var ObservablePoint = class {
    constructor(cb, scope, x = 0, y = 0) {
      this._x = x;
      this._y = y;
      this.cb = cb;
      this.scope = scope;
    }
    clone(cb = this.cb, scope = this.scope) {
      return new ObservablePoint(cb, scope, this._x, this._y);
    }
    set(x = 0, y = x) {
      if (this._x !== x || this._y !== y) {
        this._x = x;
        this._y = y;
        this.cb.call(this.scope);
      }
      return this;
    }
    copyFrom(p) {
      if (this._x !== p.x || this._y !== p.y) {
        this._x = p.x;
        this._y = p.y;
        this.cb.call(this.scope);
      }
      return this;
    }
    copyTo(p) {
      p.set(this._x, this._y);
      return p;
    }
    equals(p) {
      return p.x === this._x && p.y === this._y;
    }
    toString() {
      return `[@pixi/math:ObservablePoint x=${0} y=${0} scope=${this.scope}]`;
    }
    get x() {
      return this._x;
    }
    set x(value3) {
      if (this._x !== value3) {
        this._x = value3;
        this.cb.call(this.scope);
      }
    }
    get y() {
      return this._y;
    }
    set y(value3) {
      if (this._y !== value3) {
        this._y = value3;
        this.cb.call(this.scope);
      }
    }
  };
  var Matrix = class {
    constructor(a2 = 1, b2 = 0, c = 0, d = 1, tx = 0, ty = 0) {
      this.array = null;
      this.a = a2;
      this.b = b2;
      this.c = c;
      this.d = d;
      this.tx = tx;
      this.ty = ty;
    }
    fromArray(array) {
      this.a = array[0];
      this.b = array[1];
      this.c = array[3];
      this.d = array[4];
      this.tx = array[2];
      this.ty = array[5];
    }
    set(a2, b2, c, d, tx, ty) {
      this.a = a2;
      this.b = b2;
      this.c = c;
      this.d = d;
      this.tx = tx;
      this.ty = ty;
      return this;
    }
    toArray(transpose, out) {
      if (!this.array) {
        this.array = new Float32Array(9);
      }
      const array = out || this.array;
      if (transpose) {
        array[0] = this.a;
        array[1] = this.b;
        array[2] = 0;
        array[3] = this.c;
        array[4] = this.d;
        array[5] = 0;
        array[6] = this.tx;
        array[7] = this.ty;
        array[8] = 1;
      } else {
        array[0] = this.a;
        array[1] = this.c;
        array[2] = this.tx;
        array[3] = this.b;
        array[4] = this.d;
        array[5] = this.ty;
        array[6] = 0;
        array[7] = 0;
        array[8] = 1;
      }
      return array;
    }
    apply(pos, newPos) {
      newPos = newPos || new Point();
      const x = pos.x;
      const y = pos.y;
      newPos.x = this.a * x + this.c * y + this.tx;
      newPos.y = this.b * x + this.d * y + this.ty;
      return newPos;
    }
    applyInverse(pos, newPos) {
      newPos = newPos || new Point();
      const id = 1 / (this.a * this.d + this.c * -this.b);
      const x = pos.x;
      const y = pos.y;
      newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id;
      newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id;
      return newPos;
    }
    translate(x, y) {
      this.tx += x;
      this.ty += y;
      return this;
    }
    scale(x, y) {
      this.a *= x;
      this.d *= y;
      this.c *= x;
      this.b *= y;
      this.tx *= x;
      this.ty *= y;
      return this;
    }
    rotate(angle) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      const a1 = this.a;
      const c1 = this.c;
      const tx1 = this.tx;
      this.a = a1 * cos - this.b * sin;
      this.b = a1 * sin + this.b * cos;
      this.c = c1 * cos - this.d * sin;
      this.d = c1 * sin + this.d * cos;
      this.tx = tx1 * cos - this.ty * sin;
      this.ty = tx1 * sin + this.ty * cos;
      return this;
    }
    append(matrix) {
      const a1 = this.a;
      const b1 = this.b;
      const c1 = this.c;
      const d1 = this.d;
      this.a = matrix.a * a1 + matrix.b * c1;
      this.b = matrix.a * b1 + matrix.b * d1;
      this.c = matrix.c * a1 + matrix.d * c1;
      this.d = matrix.c * b1 + matrix.d * d1;
      this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
      this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
      return this;
    }
    setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
      this.a = Math.cos(rotation + skewY) * scaleX;
      this.b = Math.sin(rotation + skewY) * scaleX;
      this.c = -Math.sin(rotation - skewX) * scaleY;
      this.d = Math.cos(rotation - skewX) * scaleY;
      this.tx = x - (pivotX * this.a + pivotY * this.c);
      this.ty = y - (pivotX * this.b + pivotY * this.d);
      return this;
    }
    prepend(matrix) {
      const tx1 = this.tx;
      if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
        const a1 = this.a;
        const c1 = this.c;
        this.a = a1 * matrix.a + this.b * matrix.c;
        this.b = a1 * matrix.b + this.b * matrix.d;
        this.c = c1 * matrix.a + this.d * matrix.c;
        this.d = c1 * matrix.b + this.d * matrix.d;
      }
      this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
      this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
      return this;
    }
    decompose(transform) {
      const a2 = this.a;
      const b2 = this.b;
      const c = this.c;
      const d = this.d;
      const pivot = transform.pivot;
      const skewX = -Math.atan2(-c, d);
      const skewY = Math.atan2(b2, a2);
      const delta = Math.abs(skewX + skewY);
      if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {
        transform.rotation = skewY;
        transform.skew.x = transform.skew.y = 0;
      } else {
        transform.rotation = 0;
        transform.skew.x = skewX;
        transform.skew.y = skewY;
      }
      transform.scale.x = Math.sqrt(a2 * a2 + b2 * b2);
      transform.scale.y = Math.sqrt(c * c + d * d);
      transform.position.x = this.tx + (pivot.x * a2 + pivot.y * c);
      transform.position.y = this.ty + (pivot.x * b2 + pivot.y * d);
      return transform;
    }
    invert() {
      const a1 = this.a;
      const b1 = this.b;
      const c1 = this.c;
      const d1 = this.d;
      const tx1 = this.tx;
      const n = a1 * d1 - b1 * c1;
      this.a = d1 / n;
      this.b = -b1 / n;
      this.c = -c1 / n;
      this.d = a1 / n;
      this.tx = (c1 * this.ty - d1 * tx1) / n;
      this.ty = -(a1 * this.ty - b1 * tx1) / n;
      return this;
    }
    identity() {
      this.a = 1;
      this.b = 0;
      this.c = 0;
      this.d = 1;
      this.tx = 0;
      this.ty = 0;
      return this;
    }
    clone() {
      const matrix = new Matrix();
      matrix.a = this.a;
      matrix.b = this.b;
      matrix.c = this.c;
      matrix.d = this.d;
      matrix.tx = this.tx;
      matrix.ty = this.ty;
      return matrix;
    }
    copyTo(matrix) {
      matrix.a = this.a;
      matrix.b = this.b;
      matrix.c = this.c;
      matrix.d = this.d;
      matrix.tx = this.tx;
      matrix.ty = this.ty;
      return matrix;
    }
    copyFrom(matrix) {
      this.a = matrix.a;
      this.b = matrix.b;
      this.c = matrix.c;
      this.d = matrix.d;
      this.tx = matrix.tx;
      this.ty = matrix.ty;
      return this;
    }
    toString() {
      return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
    }
    static get IDENTITY() {
      return new Matrix();
    }
    static get TEMP_MATRIX() {
      return new Matrix();
    }
  };
  var ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
  var uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
  var vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
  var vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
  var rotationCayley = [];
  var rotationMatrices = [];
  var signum = Math.sign;
  function init() {
    for (let i = 0; i < 16; i++) {
      const row = [];
      rotationCayley.push(row);
      for (let j = 0; j < 16; j++) {
        const _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);
        const _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);
        const _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);
        const _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);
        for (let k = 0; k < 16; k++) {
          if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {
            row.push(k);
            break;
          }
        }
      }
    }
    for (let i = 0; i < 16; i++) {
      const mat = new Matrix();
      mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);
      rotationMatrices.push(mat);
    }
  }
  init();
  var groupD8 = {
    E: 0,
    SE: 1,
    S: 2,
    SW: 3,
    W: 4,
    NW: 5,
    N: 6,
    NE: 7,
    MIRROR_VERTICAL: 8,
    MAIN_DIAGONAL: 10,
    MIRROR_HORIZONTAL: 12,
    REVERSE_DIAGONAL: 14,
    uX: (ind) => ux[ind],
    uY: (ind) => uy[ind],
    vX: (ind) => vx[ind],
    vY: (ind) => vy[ind],
    inv: (rotation) => {
      if (rotation & 8) {
        return rotation & 15;
      }
      return -rotation & 7;
    },
    add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],
    sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],
    rotate180: (rotation) => rotation ^ 4,
    isVertical: (rotation) => (rotation & 3) === 2,
    byDirection: (dx, dy) => {
      if (Math.abs(dx) * 2 <= Math.abs(dy)) {
        if (dy >= 0) {
          return groupD8.S;
        }
        return groupD8.N;
      } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
        if (dx > 0) {
          return groupD8.E;
        }
        return groupD8.W;
      } else if (dy > 0) {
        if (dx > 0) {
          return groupD8.SE;
        }
        return groupD8.SW;
      } else if (dx > 0) {
        return groupD8.NE;
      }
      return groupD8.NW;
    },
    matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {
      const mat = rotationMatrices[groupD8.inv(rotation)];
      mat.tx = tx;
      mat.ty = ty;
      matrix.append(mat);
    }
  };
  var _Transform = class {
    constructor() {
      this.worldTransform = new Matrix();
      this.localTransform = new Matrix();
      this.position = new ObservablePoint(this.onChange, this, 0, 0);
      this.scale = new ObservablePoint(this.onChange, this, 1, 1);
      this.pivot = new ObservablePoint(this.onChange, this, 0, 0);
      this.skew = new ObservablePoint(this.updateSkew, this, 0, 0);
      this._rotation = 0;
      this._cx = 1;
      this._sx = 0;
      this._cy = 0;
      this._sy = 1;
      this._localID = 0;
      this._currentLocalID = 0;
      this._worldID = 0;
      this._parentID = 0;
    }
    onChange() {
      this._localID++;
    }
    updateSkew() {
      this._cx = Math.cos(this._rotation + this.skew.y);
      this._sx = Math.sin(this._rotation + this.skew.y);
      this._cy = -Math.sin(this._rotation - this.skew.x);
      this._sy = Math.cos(this._rotation - this.skew.x);
      this._localID++;
    }
    toString() {
      return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
    }
    updateLocalTransform() {
      const lt = this.localTransform;
      if (this._localID !== this._currentLocalID) {
        lt.a = this._cx * this.scale.x;
        lt.b = this._sx * this.scale.x;
        lt.c = this._cy * this.scale.y;
        lt.d = this._sy * this.scale.y;
        lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
        lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
        this._currentLocalID = this._localID;
        this._parentID = -1;
      }
    }
    updateTransform(parentTransform) {
      const lt = this.localTransform;
      if (this._localID !== this._currentLocalID) {
        lt.a = this._cx * this.scale.x;
        lt.b = this._sx * this.scale.x;
        lt.c = this._cy * this.scale.y;
        lt.d = this._sy * this.scale.y;
        lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
        lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
        this._currentLocalID = this._localID;
        this._parentID = -1;
      }
      if (this._parentID !== parentTransform._worldID) {
        const pt = parentTransform.worldTransform;
        const wt = this.worldTransform;
        wt.a = lt.a * pt.a + lt.b * pt.c;
        wt.b = lt.a * pt.b + lt.b * pt.d;
        wt.c = lt.c * pt.a + lt.d * pt.c;
        wt.d = lt.c * pt.b + lt.d * pt.d;
        wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
        wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
        this._parentID = parentTransform._worldID;
        this._worldID++;
      }
    }
    setFromMatrix(matrix) {
      matrix.decompose(this);
      this._localID++;
    }
    get rotation() {
      return this._rotation;
    }
    set rotation(value3) {
      if (this._rotation !== value3) {
        this._rotation = value3;
        this.updateSkew();
      }
    }
  };
  var Transform = _Transform;
  Transform.IDENTITY = new _Transform();
  var Runner = class {
    constructor(name) {
      this.items = [];
      this._name = name;
      this._aliasCount = 0;
    }
    emit(a0, a1, a2, a3, a4, a5, a6, a7) {
      if (arguments.length > 8) {
        throw new Error("max arguments reached");
      }
      const { name, items } = this;
      this._aliasCount++;
      for (let i = 0, len = items.length; i < len; i++) {
        items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);
      }
      if (items === this.items) {
        this._aliasCount--;
      }
      return this;
    }
    ensureNonAliasedItems() {
      if (this._aliasCount > 0 && this.items.length > 1) {
        this._aliasCount = 0;
        this.items = this.items.slice(0);
      }
    }
    add(item2) {
      if (item2[this._name]) {
        this.ensureNonAliasedItems();
        this.remove(item2);
        this.items.push(item2);
      }
      return this;
    }
    remove(item2) {
      const index2 = this.items.indexOf(item2);
      if (index2 !== -1) {
        this.ensureNonAliasedItems();
        this.items.splice(index2, 1);
      }
      return this;
    }
    contains(item2) {
      return this.items.includes(item2);
    }
    removeAll() {
      this.ensureNonAliasedItems();
      this.items.length = 0;
      return this;
    }
    destroy() {
      this.removeAll();
      this.items = null;
      this._name = null;
    }
    get empty() {
      return this.items.length === 0;
    }
    get name() {
      return this._name;
    }
  };
  Object.defineProperties(Runner.prototype, {
    dispatch: { value: Runner.prototype.emit },
    run: { value: Runner.prototype.emit }
  });
  settings.TARGET_FPMS = 0.06;
  var UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {
    UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
    UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
    UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
    UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
    return UPDATE_PRIORITY2;
  })(UPDATE_PRIORITY || {});
  var TickerListener = class {
    constructor(fn, context2 = null, priority = 0, once = false) {
      this.next = null;
      this.previous = null;
      this._destroyed = false;
      this.fn = fn;
      this.context = context2;
      this.priority = priority;
      this.once = once;
    }
    match(fn, context2 = null) {
      return this.fn === fn && this.context === context2;
    }
    emit(deltaTime) {
      if (this.fn) {
        if (this.context) {
          this.fn.call(this.context, deltaTime);
        } else {
          this.fn(deltaTime);
        }
      }
      const redirect = this.next;
      if (this.once) {
        this.destroy(true);
      }
      if (this._destroyed) {
        this.next = null;
      }
      return redirect;
    }
    connect(previous) {
      this.previous = previous;
      if (previous.next) {
        previous.next.previous = this;
      }
      this.next = previous.next;
      previous.next = this;
    }
    destroy(hard = false) {
      this._destroyed = true;
      this.fn = null;
      this.context = null;
      if (this.previous) {
        this.previous.next = this.next;
      }
      if (this.next) {
        this.next.previous = this.previous;
      }
      const redirect = this.next;
      this.next = hard ? null : redirect;
      this.previous = null;
      return redirect;
    }
  };
  var Ticker = class {
    constructor() {
      this.autoStart = false;
      this.deltaTime = 1;
      this.lastTime = -1;
      this.speed = 1;
      this.started = false;
      this._requestId = null;
      this._maxElapsedMS = 100;
      this._minElapsedMS = 0;
      this._protected = false;
      this._lastFrame = -1;
      this._head = new TickerListener(null, null, Infinity);
      this.deltaMS = 1 / settings.TARGET_FPMS;
      this.elapsedMS = 1 / settings.TARGET_FPMS;
      this._tick = (time) => {
        this._requestId = null;
        if (this.started) {
          this.update(time);
          if (this.started && this._requestId === null && this._head.next) {
            this._requestId = requestAnimationFrame(this._tick);
          }
        }
      };
    }
    _requestIfNeeded() {
      if (this._requestId === null && this._head.next) {
        this.lastTime = performance.now();
        this._lastFrame = this.lastTime;
        this._requestId = requestAnimationFrame(this._tick);
      }
    }
    _cancelIfNeeded() {
      if (this._requestId !== null) {
        cancelAnimationFrame(this._requestId);
        this._requestId = null;
      }
    }
    _startIfPossible() {
      if (this.started) {
        this._requestIfNeeded();
      } else if (this.autoStart) {
        this.start();
      }
    }
    add(fn, context2, priority = UPDATE_PRIORITY.NORMAL) {
      return this._addListener(new TickerListener(fn, context2, priority));
    }
    addOnce(fn, context2, priority = UPDATE_PRIORITY.NORMAL) {
      return this._addListener(new TickerListener(fn, context2, priority, true));
    }
    _addListener(listener) {
      let current = this._head.next;
      let previous = this._head;
      if (!current) {
        listener.connect(previous);
      } else {
        while (current) {
          if (listener.priority > current.priority) {
            listener.connect(previous);
            break;
          }
          previous = current;
          current = current.next;
        }
        if (!listener.previous) {
          listener.connect(previous);
        }
      }
      this._startIfPossible();
      return this;
    }
    remove(fn, context2) {
      let listener = this._head.next;
      while (listener) {
        if (listener.match(fn, context2)) {
          listener = listener.destroy();
        } else {
          listener = listener.next;
        }
      }
      if (!this._head.next) {
        this._cancelIfNeeded();
      }
      return this;
    }
    get count() {
      if (!this._head) {
        return 0;
      }
      let count = 0;
      let current = this._head;
      while (current = current.next) {
        count++;
      }
      return count;
    }
    start() {
      if (!this.started) {
        this.started = true;
        this._requestIfNeeded();
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this._cancelIfNeeded();
      }
    }
    destroy() {
      if (!this._protected) {
        this.stop();
        let listener = this._head.next;
        while (listener) {
          listener = listener.destroy(true);
        }
        this._head.destroy();
        this._head = null;
      }
    }
    update(currentTime = performance.now()) {
      let elapsedMS;
      if (currentTime > this.lastTime) {
        elapsedMS = this.elapsedMS = currentTime - this.lastTime;
        if (elapsedMS > this._maxElapsedMS) {
          elapsedMS = this._maxElapsedMS;
        }
        elapsedMS *= this.speed;
        if (this._minElapsedMS) {
          const delta = currentTime - this._lastFrame | 0;
          if (delta < this._minElapsedMS) {
            return;
          }
          this._lastFrame = currentTime - delta % this._minElapsedMS;
        }
        this.deltaMS = elapsedMS;
        this.deltaTime = this.deltaMS * settings.TARGET_FPMS;
        const head = this._head;
        let listener = head.next;
        while (listener) {
          listener = listener.emit(this.deltaTime);
        }
        if (!head.next) {
          this._cancelIfNeeded();
        }
      } else {
        this.deltaTime = this.deltaMS = this.elapsedMS = 0;
      }
      this.lastTime = currentTime;
    }
    get FPS() {
      return 1e3 / this.elapsedMS;
    }
    get minFPS() {
      return 1e3 / this._maxElapsedMS;
    }
    set minFPS(fps) {
      const minFPS = Math.min(this.maxFPS, fps);
      const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, settings.TARGET_FPMS);
      this._maxElapsedMS = 1 / minFPMS;
    }
    get maxFPS() {
      if (this._minElapsedMS) {
        return Math.round(1e3 / this._minElapsedMS);
      }
      return 0;
    }
    set maxFPS(fps) {
      if (fps === 0) {
        this._minElapsedMS = 0;
      } else {
        const maxFPS = Math.max(this.minFPS, fps);
        this._minElapsedMS = 1 / (maxFPS / 1e3);
      }
    }
    static get shared() {
      if (!Ticker._shared) {
        const shared = Ticker._shared = new Ticker();
        shared.autoStart = true;
        shared._protected = true;
      }
      return Ticker._shared;
    }
    static get system() {
      if (!Ticker._system) {
        const system = Ticker._system = new Ticker();
        system.autoStart = true;
        system._protected = true;
      }
      return Ticker._system;
    }
  };
  var TickerPlugin = class {
    static init(options) {
      options = Object.assign({
        autoStart: true,
        sharedTicker: false
      }, options);
      Object.defineProperty(this, "ticker", {
        set(ticker) {
          if (this._ticker) {
            this._ticker.remove(this.render, this);
          }
          this._ticker = ticker;
          if (ticker) {
            ticker.add(this.render, this, UPDATE_PRIORITY.LOW);
          }
        },
        get() {
          return this._ticker;
        }
      });
      this.stop = () => {
        this._ticker.stop();
      };
      this.start = () => {
        this._ticker.start();
      };
      this._ticker = null;
      this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();
      if (options.autoStart) {
        this.start();
      }
    }
    static destroy() {
      if (this._ticker) {
        const oldTicker = this._ticker;
        this.ticker = null;
        oldTicker.destroy();
      }
    }
  };
  TickerPlugin.extension = ExtensionType.Application;
  extensions$1.add(TickerPlugin);
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function createCommonjsModule(fn, basedir, module2) {
    return module2 = {
      path: basedir,
      exports: {},
      require: function(path2, base) {
        return commonjsRequire(path2, base === void 0 || base === null ? module2.path : base);
      }
    }, fn(module2, module2.exports), module2.exports;
  }
  function commonjsRequire() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
  }
  var eventemitter3 = createCommonjsModule(function(module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty, prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context2, once) {
      this.fn = fn;
      this.context = context2;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context2, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context2 || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter.prototype.on = function on(event, fn, context2) {
      return addListener(this, event, fn, context2, false);
    };
    EventEmitter.prototype.once = function once(event, fn, context2) {
      return addListener(this, event, fn, context2, true);
    };
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context2, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context2 || listeners.context === context2)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context2 && listeners[i].context !== context2) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    EventEmitter.prefixed = prefix;
    EventEmitter.EventEmitter = EventEmitter;
    if (true) {
      module2.exports = EventEmitter;
    }
  });
  var earcut_1 = earcut;
  var _default = earcut;
  function earcut(data, holeIndices, dim) {
    dim = dim || 2;
    var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev)
      return triangles;
    var minX, minY, maxX, maxY, x, y, invSize;
    if (hasHoles)
      outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];
      for (var i = dim; i < outerLen; i += dim) {
        x = data[i];
        y = data[i + 1];
        if (x < minX)
          minX = x;
        if (y < minY)
          minY = y;
        if (x > maxX)
          maxX = x;
        if (y > maxY)
          maxY = y;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 32767 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
    return triangles;
  }
  function linkedList(data, start, end, dim, clockwise) {
    var i, last;
    if (clockwise === signedArea(data, start, end, dim) > 0) {
      for (i = start; i < end; i += dim)
        last = insertNode(i, data[i], data[i + 1], last);
    } else {
      for (i = end - dim; i >= start; i -= dim)
        last = insertNode(i, data[i], data[i + 1], last);
    }
    if (last && equals(last, last.next)) {
      removeNode(last);
      last = last.next;
    }
    return last;
  }
  function filterPoints(start, end) {
    if (!start)
      return start;
    if (!end)
      end = start;
    var p = start, again;
    do {
      again = false;
      if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
        removeNode(p);
        p = end = p.prev;
        if (p === p.next)
          break;
        again = true;
      } else {
        p = p.next;
      }
    } while (again || p !== end);
    return end;
  }
  function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear)
      return;
    if (!pass && invSize)
      indexCurve(ear, minX, minY, invSize);
    var stop = ear, prev, next;
    while (ear.prev !== ear.next) {
      prev = ear.prev;
      next = ear.next;
      if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
        triangles.push(prev.i / dim | 0);
        triangles.push(ear.i / dim | 0);
        triangles.push(next.i / dim | 0);
        removeNode(ear);
        ear = next.next;
        stop = next.next;
        continue;
      }
      ear = next;
      if (ear === stop) {
        if (!pass) {
          earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
        } else if (pass === 1) {
          ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
          earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
        } else if (pass === 2) {
          splitEarcut(ear, triangles, dim, minX, minY, invSize);
        }
        break;
      }
    }
  }
  function isEar(ear) {
    var a2 = ear.prev, b2 = ear, c = ear.next;
    if (area(a2, b2, c) >= 0)
      return false;
    var ax = a2.x, bx = b2.x, cx = c.x, ay = a2.y, by = b2.y, cy = c.y;
    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    var p = c.next;
    while (p !== a2) {
      if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
        return false;
      p = p.next;
    }
    return true;
  }
  function isEarHashed(ear, minX, minY, invSize) {
    var a2 = ear.prev, b2 = ear, c = ear.next;
    if (area(a2, b2, c) >= 0)
      return false;
    var ax = a2.x, bx = b2.x, cx = c.x, ay = a2.y, by = b2.y, cy = c.y;
    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
    var p = ear.prevZ, n = ear.nextZ;
    while (p && p.z >= minZ && n && n.z <= maxZ) {
      if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a2 && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
        return false;
      p = p.prevZ;
      if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a2 && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
        return false;
      n = n.nextZ;
    }
    while (p && p.z >= minZ) {
      if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a2 && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
        return false;
      p = p.prevZ;
    }
    while (n && n.z <= maxZ) {
      if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a2 && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
        return false;
      n = n.nextZ;
    }
    return true;
  }
  function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
      var a2 = p.prev, b2 = p.next.next;
      if (!equals(a2, b2) && intersects(a2, p, p.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
        triangles.push(a2.i / dim | 0);
        triangles.push(p.i / dim | 0);
        triangles.push(b2.i / dim | 0);
        removeNode(p);
        removeNode(p.next);
        p = start = b2;
      }
      p = p.next;
    } while (p !== start);
    return filterPoints(p);
  }
  function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    var a2 = start;
    do {
      var b2 = a2.next.next;
      while (b2 !== a2.prev) {
        if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
          var c = splitPolygon(a2, b2);
          a2 = filterPoints(a2, a2.next);
          c = filterPoints(c, c.next);
          earcutLinked(a2, triangles, dim, minX, minY, invSize, 0);
          earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
          return;
        }
        b2 = b2.next;
      }
      a2 = a2.next;
    } while (a2 !== start);
  }
  function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [], i, len, start, end, list;
    for (i = 0, len = holeIndices.length; i < len; i++) {
      start = holeIndices[i] * dim;
      end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
      list = linkedList(data, start, end, dim, false);
      if (list === list.next)
        list.steiner = true;
      queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    for (i = 0; i < queue.length; i++) {
      outerNode = eliminateHole(queue[i], outerNode);
    }
    return outerNode;
  }
  function compareX(a2, b2) {
    return a2.x - b2.x;
  }
  function eliminateHole(hole, outerNode) {
    var bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
      return outerNode;
    }
    var bridgeReverse = splitPolygon(bridge, hole);
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
  }
  function findHoleBridge(hole, outerNode) {
    var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
    do {
      if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
        var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
        if (x <= hx && x > qx) {
          qx = x;
          m = p.x < p.next.x ? p : p.next;
          if (x === hx)
            return m;
        }
      }
      p = p.next;
    } while (p !== outerNode);
    if (!m)
      return null;
    var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan2;
    p = m;
    do {
      if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
        tan2 = Math.abs(hy - p.y) / (hx - p.x);
        if (locallyInside(p, hole) && (tan2 < tanMin || tan2 === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
          m = p;
          tanMin = tan2;
        }
      }
      p = p.next;
    } while (p !== stop);
    return m;
  }
  function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
  }
  function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
      if (p.z === 0)
        p.z = zOrder(p.x, p.y, minX, minY, invSize);
      p.prevZ = p.prev;
      p.nextZ = p.next;
      p = p.next;
    } while (p !== start);
    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
  }
  function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
    do {
      p = list;
      list = null;
      tail = null;
      numMerges = 0;
      while (p) {
        numMerges++;
        q = p;
        pSize = 0;
        for (i = 0; i < inSize; i++) {
          pSize++;
          q = q.nextZ;
          if (!q)
            break;
        }
        qSize = inSize;
        while (pSize > 0 || qSize > 0 && q) {
          if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
            e = p;
            p = p.nextZ;
            pSize--;
          } else {
            e = q;
            q = q.nextZ;
            qSize--;
          }
          if (tail)
            tail.nextZ = e;
          else
            list = e;
          e.prevZ = tail;
          tail = e;
        }
        p = q;
      }
      tail.nextZ = null;
      inSize *= 2;
    } while (numMerges > 1);
    return list;
  }
  function zOrder(x, y, minX, minY, invSize) {
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;
    x = (x | x << 8) & 16711935;
    x = (x | x << 4) & 252645135;
    x = (x | x << 2) & 858993459;
    x = (x | x << 1) & 1431655765;
    y = (y | y << 8) & 16711935;
    y = (y | y << 4) & 252645135;
    y = (y | y << 2) & 858993459;
    y = (y | y << 1) & 1431655765;
    return x | y << 1;
  }
  function getLeftmost(start) {
    var p = start, leftmost = start;
    do {
      if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
        leftmost = p;
      p = p.next;
    } while (p !== start);
    return leftmost;
  }
  function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
  }
  function isValidDiagonal(a2, b2) {
    return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && // dones't intersect other edges
    (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && // locally visible
    (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || // does not create opposite-facing sectors
    equals(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0);
  }
  function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
  }
  function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
  }
  function intersects(p1, q1, p2, q2) {
    var o1 = sign$1(area(p1, q1, p2));
    var o2 = sign$1(area(p1, q1, q2));
    var o3 = sign$1(area(p2, q2, p1));
    var o4 = sign$1(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4)
      return true;
    if (o1 === 0 && onSegment(p1, p2, q1))
      return true;
    if (o2 === 0 && onSegment(p1, q2, q1))
      return true;
    if (o3 === 0 && onSegment(p2, p1, q2))
      return true;
    if (o4 === 0 && onSegment(p2, q1, q2))
      return true;
    return false;
  }
  function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
  }
  function sign$1(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
  }
  function intersectsPolygon(a2, b2) {
    var p = a2;
    do {
      if (p.i !== a2.i && p.next.i !== a2.i && p.i !== b2.i && p.next.i !== b2.i && intersects(p, p.next, a2, b2))
        return true;
      p = p.next;
    } while (p !== a2);
    return false;
  }
  function locallyInside(a2, b2) {
    return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
  }
  function middleInside(a2, b2) {
    var p = a2, inside = false, px = (a2.x + b2.x) / 2, py = (a2.y + b2.y) / 2;
    do {
      if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
        inside = !inside;
      p = p.next;
    } while (p !== a2);
    return inside;
  }
  function splitPolygon(a2, b2) {
    var a22 = new Node$1(a2.i, a2.x, a2.y), b22 = new Node$1(b2.i, b2.x, b2.y), an = a2.next, bp = b2.prev;
    a2.next = b2;
    b2.prev = a2;
    a22.next = an;
    an.prev = a22;
    b22.next = a22;
    a22.prev = b22;
    bp.next = b22;
    b22.prev = bp;
    return b22;
  }
  function insertNode(i, x, y, last) {
    var p = new Node$1(i, x, y);
    if (!last) {
      p.prev = p;
      p.next = p;
    } else {
      p.next = last.next;
      p.prev = last;
      last.next.prev = p;
      last.next = p;
    }
    return p;
  }
  function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ)
      p.prevZ.nextZ = p.nextZ;
    if (p.nextZ)
      p.nextZ.prevZ = p.prevZ;
  }
  function Node$1(i, x, y) {
    this.i = i;
    this.x = x;
    this.y = y;
    this.prev = null;
    this.next = null;
    this.z = 0;
    this.prevZ = null;
    this.nextZ = null;
    this.steiner = false;
  }
  earcut.deviation = function(data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
      for (var i = 0, len = holeIndices.length; i < len; i++) {
        var start = holeIndices[i] * dim;
        var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        polygonArea -= Math.abs(signedArea(data, start, end, dim));
      }
    }
    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
      var a2 = triangles[i] * dim;
      var b2 = triangles[i + 1] * dim;
      var c = triangles[i + 2] * dim;
      trianglesArea += Math.abs(
        (data[a2] - data[c]) * (data[b2 + 1] - data[a2 + 1]) - (data[a2] - data[b2]) * (data[c + 1] - data[a2 + 1])
      );
    }
    return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
  };
  function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
      sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
      j = i;
    }
    return sum;
  }
  earcut.flatten = function(data) {
    var dim = data[0][0].length, result2 = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
    for (var i = 0; i < data.length; i++) {
      for (var j = 0; j < data[i].length; j++) {
        for (var d = 0; d < dim; d++)
          result2.vertices.push(data[i][j][d]);
      }
      if (i > 0) {
        holeIndex += data[i - 1].length;
        result2.holes.push(holeIndex);
      }
    }
    return result2;
  };
  earcut_1.default = _default;
  var punycode = createCommonjsModule(function(module2, exports) {
    ;
    (function(root2) {
      var freeExports = exports && !exports.nodeType && exports;
      var freeModule = module2 && !module2.nodeType && module2;
      var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
        root2 = freeGlobal;
      }
      var punycode2, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
      function error(type) {
        throw RangeError(errors[type]);
      }
      function map2(array, fn) {
        var length = array.length;
        var result2 = [];
        while (length--) {
          result2[length] = fn(array[length]);
        }
        return result2;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result2 = "";
        if (parts.length > 1) {
          result2 = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map2(labels, fn).join(".");
        return result2 + encoded;
      }
      function ucs2decode(string) {
        var output = [], counter = 0, length = string.length, value3, extra;
        while (counter < length) {
          value3 = string.charCodeAt(counter++);
          if (value3 >= 55296 && value3 <= 56319 && counter < length) {
            extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value3 & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value3);
              counter--;
            }
          } else {
            output.push(value3);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        return map2(array, function(value3) {
          var output = "";
          if (value3 > 65535) {
            value3 -= 65536;
            output += stringFromCharCode(value3 >>> 10 & 1023 | 55296);
            value3 = 56320 | value3 & 1023;
          }
          output += stringFromCharCode(value3);
          return output;
        }).join("");
      }
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      }
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      function decode2(input) {
        var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index2, oldi, w, k, digit, t, baseMinusT;
        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
          for (oldi = i, w = 1, k = base; ; k += base) {
            if (index2 >= inputLength) {
              error("invalid-input");
            }
            digit = basicToDigit(input.charCodeAt(index2++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error("overflow");
            }
            i += digit * w;
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error("overflow");
            }
            w *= baseMinusT;
          }
          out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error("overflow");
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return ucs2encode(output);
      }
      function encode2(input) {
        var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n = initialN;
        delta = 0;
        bias = initialBias;
        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < 128) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output.length;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          for (m = maxInt, j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < n && ++delta > maxInt) {
              error("overflow");
            }
            if (currentValue == n) {
              for (q = delta, k = base; ; k += base) {
                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t) {
                  break;
                }
                qMinusT = q - t;
                baseMinusT = base - t;
                output.push(
                  stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                );
                q = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      }
      function toUnicode(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode2(string.slice(4).toLowerCase()) : string;
        });
      }
      function toASCII(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode2(string) : string;
        });
      }
      punycode2 = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "1.3.2",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode2,
        "encode": encode2,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      if (false) {
        (void 0)("punycode", function() {
          return punycode2;
        });
      } else if (freeExports && freeModule) {
        if (module2.exports == freeExports) {
          freeModule.exports = punycode2;
        } else {
          for (key in punycode2) {
            punycode2.hasOwnProperty(key) && (freeExports[key] = punycode2[key]);
          }
        }
      } else {
        root2.punycode = punycode2;
      }
    })(commonjsGlobal);
  });
  var util = {
    isString: function(arg) {
      return typeof arg === "string";
    },
    isObject: function(arg) {
      return typeof arg === "object" && arg !== null;
    },
    isNull: function(arg) {
      return arg === null;
    },
    isNullOrUndefined: function(arg) {
      return arg == null;
    }
  };
  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  var decode = function(qs, sep, eq, options) {
    sep = sep || "&";
    eq = eq || "=";
    var obj = {};
    if (typeof qs !== "string" || qs.length === 0) {
      return obj;
    }
    var regexp = /\+/g;
    qs = qs.split(sep);
    var maxKeys = 1e3;
    if (options && typeof options.maxKeys === "number") {
      maxKeys = options.maxKeys;
    }
    var len = qs.length;
    if (maxKeys > 0 && len > maxKeys) {
      len = maxKeys;
    }
    for (var i = 0; i < len; ++i) {
      var x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v2;
      if (idx >= 0) {
        kstr = x.substr(0, idx);
        vstr = x.substr(idx + 1);
      } else {
        kstr = x;
        vstr = "";
      }
      k = decodeURIComponent(kstr);
      v2 = decodeURIComponent(vstr);
      if (!hasOwnProperty(obj, k)) {
        obj[k] = v2;
      } else if (Array.isArray(obj[k])) {
        obj[k].push(v2);
      } else {
        obj[k] = [obj[k], v2];
      }
    }
    return obj;
  };
  var stringifyPrimitive = function(v2) {
    switch (typeof v2) {
      case "string":
        return v2;
      case "boolean":
        return v2 ? "true" : "false";
      case "number":
        return isFinite(v2) ? v2 : "";
      default:
        return "";
    }
  };
  var encode = function(obj, sep, eq, name) {
    sep = sep || "&";
    eq = eq || "=";
    if (obj === null) {
      obj = void 0;
    }
    if (typeof obj === "object") {
      return Object.keys(obj).map(function(k) {
        var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
        if (Array.isArray(obj[k])) {
          return obj[k].map(function(v2) {
            return ks + encodeURIComponent(stringifyPrimitive(v2));
          }).join(sep);
        } else {
          return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
        }
      }).join(sep);
    }
    if (!name)
      return "";
    return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
  };
  var querystring = createCommonjsModule(function(module2, exports) {
    "use strict";
    exports.decode = exports.parse = decode;
    exports.encode = exports.stringify = encode;
  });
  var parse$1 = urlParse;
  var resolve = urlResolve;
  var format = urlFormat;
  function Url() {
    this.protocol = null;
    this.slashes = null;
    this.auth = null;
    this.host = null;
    this.port = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.query = null;
    this.pathname = null;
    this.path = null;
    this.href = null;
  }
  var protocolPattern = /^([a-z0-9.+-]+:)/i;
  var portPattern = /:[0-9]*$/;
  var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
  var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
  var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
  var autoEscape = ["'"].concat(unwise);
  var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
  var hostEndingChars = ["/", "?", "#"];
  var hostnameMaxLen = 255;
  var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
  var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
  var unsafeProtocol = {
    "javascript": true,
    "javascript:": true
  };
  var hostlessProtocol = {
    "javascript": true,
    "javascript:": true
  };
  var slashedProtocol = {
    "http": true,
    "https": true,
    "ftp": true,
    "gopher": true,
    "file": true,
    "http:": true,
    "https:": true,
    "ftp:": true,
    "gopher:": true,
    "file:": true
  };
  function urlParse(url2, parseQueryString, slashesDenoteHost) {
    if (url2 && util.isObject(url2) && url2 instanceof Url)
      return url2;
    var u = new Url();
    u.parse(url2, parseQueryString, slashesDenoteHost);
    return u;
  }
  Url.prototype.parse = function(url2, parseQueryString, slashesDenoteHost) {
    if (!util.isString(url2)) {
      throw new TypeError("Parameter 'url' must be a string, not " + typeof url2);
    }
    var queryIndex = url2.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url2.indexOf("#") ? "?" : "#", uSplit = url2.split(splitter), slashRegex = /\\/g;
    uSplit[0] = uSplit[0].replace(slashRegex, "/");
    url2 = uSplit.join(splitter);
    var rest = url2;
    rest = rest.trim();
    if (!slashesDenoteHost && url2.split("#").length === 1) {
      var simplePath = simplePathPattern.exec(rest);
      if (simplePath) {
        this.path = rest;
        this.href = rest;
        this.pathname = simplePath[1];
        if (simplePath[2]) {
          this.search = simplePath[2];
          if (parseQueryString) {
            this.query = querystring.parse(this.search.substr(1));
          } else {
            this.query = this.search.substr(1);
          }
        } else if (parseQueryString) {
          this.search = "";
          this.query = {};
        }
        return this;
      }
    }
    var proto = protocolPattern.exec(rest);
    if (proto) {
      proto = proto[0];
      var lowerProto = proto.toLowerCase();
      this.protocol = lowerProto;
      rest = rest.substr(proto.length);
    }
    if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
      var slashes = rest.substr(0, 2) === "//";
      if (slashes && !(proto && hostlessProtocol[proto])) {
        rest = rest.substr(2);
        this.slashes = true;
      }
    }
    if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
      var hostEnd = -1;
      for (var i = 0; i < hostEndingChars.length; i++) {
        var hec = rest.indexOf(hostEndingChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
          hostEnd = hec;
      }
      var auth, atSign;
      if (hostEnd === -1) {
        atSign = rest.lastIndexOf("@");
      } else {
        atSign = rest.lastIndexOf("@", hostEnd);
      }
      if (atSign !== -1) {
        auth = rest.slice(0, atSign);
        rest = rest.slice(atSign + 1);
        this.auth = decodeURIComponent(auth);
      }
      hostEnd = -1;
      for (var i = 0; i < nonHostChars.length; i++) {
        var hec = rest.indexOf(nonHostChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
          hostEnd = hec;
      }
      if (hostEnd === -1)
        hostEnd = rest.length;
      this.host = rest.slice(0, hostEnd);
      rest = rest.slice(hostEnd);
      this.parseHost();
      this.hostname = this.hostname || "";
      var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
      if (!ipv6Hostname) {
        var hostparts = this.hostname.split(/\./);
        for (var i = 0, l = hostparts.length; i < l; i++) {
          var part = hostparts[i];
          if (!part)
            continue;
          if (!part.match(hostnamePartPattern)) {
            var newpart = "";
            for (var j = 0, k = part.length; j < k; j++) {
              if (part.charCodeAt(j) > 127) {
                newpart += "x";
              } else {
                newpart += part[j];
              }
            }
            if (!newpart.match(hostnamePartPattern)) {
              var validParts = hostparts.slice(0, i);
              var notHost = hostparts.slice(i + 1);
              var bit = part.match(hostnamePartStart);
              if (bit) {
                validParts.push(bit[1]);
                notHost.unshift(bit[2]);
              }
              if (notHost.length) {
                rest = "/" + notHost.join(".") + rest;
              }
              this.hostname = validParts.join(".");
              break;
            }
          }
        }
      }
      if (this.hostname.length > hostnameMaxLen) {
        this.hostname = "";
      } else {
        this.hostname = this.hostname.toLowerCase();
      }
      if (!ipv6Hostname) {
        this.hostname = punycode.toASCII(this.hostname);
      }
      var p = this.port ? ":" + this.port : "";
      var h = this.hostname || "";
      this.host = h + p;
      this.href += this.host;
      if (ipv6Hostname) {
        this.hostname = this.hostname.substr(1, this.hostname.length - 2);
        if (rest[0] !== "/") {
          rest = "/" + rest;
        }
      }
    }
    if (!unsafeProtocol[lowerProto]) {
      for (var i = 0, l = autoEscape.length; i < l; i++) {
        var ae = autoEscape[i];
        if (rest.indexOf(ae) === -1)
          continue;
        var esc = encodeURIComponent(ae);
        if (esc === ae) {
          esc = escape(ae);
        }
        rest = rest.split(ae).join(esc);
      }
    }
    var hash = rest.indexOf("#");
    if (hash !== -1) {
      this.hash = rest.substr(hash);
      rest = rest.slice(0, hash);
    }
    var qm = rest.indexOf("?");
    if (qm !== -1) {
      this.search = rest.substr(qm);
      this.query = rest.substr(qm + 1);
      if (parseQueryString) {
        this.query = querystring.parse(this.query);
      }
      rest = rest.slice(0, qm);
    } else if (parseQueryString) {
      this.search = "";
      this.query = {};
    }
    if (rest)
      this.pathname = rest;
    if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
      this.pathname = "/";
    }
    if (this.pathname || this.search) {
      var p = this.pathname || "";
      var s = this.search || "";
      this.path = p + s;
    }
    this.href = this.format();
    return this;
  };
  function urlFormat(obj) {
    if (util.isString(obj))
      obj = urlParse(obj);
    if (!(obj instanceof Url))
      return Url.prototype.format.call(obj);
    return obj.format();
  }
  Url.prototype.format = function() {
    var auth = this.auth || "";
    if (auth) {
      auth = encodeURIComponent(auth);
      auth = auth.replace(/%3A/i, ":");
      auth += "@";
    }
    var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
    if (this.host) {
      host = auth + this.host;
    } else if (this.hostname) {
      host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
      if (this.port) {
        host += ":" + this.port;
      }
    }
    if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
      query = querystring.stringify(this.query);
    }
    var search = this.search || query && "?" + query || "";
    if (protocol && protocol.substr(-1) !== ":")
      protocol += ":";
    if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
      host = "//" + (host || "");
      if (pathname && pathname.charAt(0) !== "/")
        pathname = "/" + pathname;
    } else if (!host) {
      host = "";
    }
    if (hash && hash.charAt(0) !== "#")
      hash = "#" + hash;
    if (search && search.charAt(0) !== "?")
      search = "?" + search;
    pathname = pathname.replace(/[?#]/g, function(match) {
      return encodeURIComponent(match);
    });
    search = search.replace("#", "%23");
    return protocol + host + pathname + search + hash;
  };
  function urlResolve(source, relative) {
    return urlParse(source, false, true).resolve(relative);
  }
  Url.prototype.resolve = function(relative) {
    return this.resolveObject(urlParse(relative, false, true)).format();
  };
  Url.prototype.resolveObject = function(relative) {
    if (util.isString(relative)) {
      var rel = new Url();
      rel.parse(relative, false, true);
      relative = rel;
    }
    var result2 = new Url();
    var tkeys = Object.keys(this);
    for (var tk = 0; tk < tkeys.length; tk++) {
      var tkey = tkeys[tk];
      result2[tkey] = this[tkey];
    }
    result2.hash = relative.hash;
    if (relative.href === "") {
      result2.href = result2.format();
      return result2;
    }
    if (relative.slashes && !relative.protocol) {
      var rkeys = Object.keys(relative);
      for (var rk = 0; rk < rkeys.length; rk++) {
        var rkey = rkeys[rk];
        if (rkey !== "protocol")
          result2[rkey] = relative[rkey];
      }
      if (slashedProtocol[result2.protocol] && result2.hostname && !result2.pathname) {
        result2.path = result2.pathname = "/";
      }
      result2.href = result2.format();
      return result2;
    }
    if (relative.protocol && relative.protocol !== result2.protocol) {
      if (!slashedProtocol[relative.protocol]) {
        var keys = Object.keys(relative);
        for (var v2 = 0; v2 < keys.length; v2++) {
          var k = keys[v2];
          result2[k] = relative[k];
        }
        result2.href = result2.format();
        return result2;
      }
      result2.protocol = relative.protocol;
      if (!relative.host && !hostlessProtocol[relative.protocol]) {
        var relPath = (relative.pathname || "").split("/");
        while (relPath.length && !(relative.host = relPath.shift()))
          ;
        if (!relative.host)
          relative.host = "";
        if (!relative.hostname)
          relative.hostname = "";
        if (relPath[0] !== "")
          relPath.unshift("");
        if (relPath.length < 2)
          relPath.unshift("");
        result2.pathname = relPath.join("/");
      } else {
        result2.pathname = relative.pathname;
      }
      result2.search = relative.search;
      result2.query = relative.query;
      result2.host = relative.host || "";
      result2.auth = relative.auth;
      result2.hostname = relative.hostname || relative.host;
      result2.port = relative.port;
      if (result2.pathname || result2.search) {
        var p = result2.pathname || "";
        var s = result2.search || "";
        result2.path = p + s;
      }
      result2.slashes = result2.slashes || relative.slashes;
      result2.href = result2.format();
      return result2;
    }
    var isSourceAbs = result2.pathname && result2.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result2.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result2.pathname && result2.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result2.protocol && !slashedProtocol[result2.protocol];
    if (psychotic) {
      result2.hostname = "";
      result2.port = null;
      if (result2.host) {
        if (srcPath[0] === "")
          srcPath[0] = result2.host;
        else
          srcPath.unshift(result2.host);
      }
      result2.host = "";
      if (relative.protocol) {
        relative.hostname = null;
        relative.port = null;
        if (relative.host) {
          if (relPath[0] === "")
            relPath[0] = relative.host;
          else
            relPath.unshift(relative.host);
        }
        relative.host = null;
      }
      mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
    }
    if (isRelAbs) {
      result2.host = relative.host || relative.host === "" ? relative.host : result2.host;
      result2.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result2.hostname;
      result2.search = relative.search;
      result2.query = relative.query;
      srcPath = relPath;
    } else if (relPath.length) {
      if (!srcPath)
        srcPath = [];
      srcPath.pop();
      srcPath = srcPath.concat(relPath);
      result2.search = relative.search;
      result2.query = relative.query;
    } else if (!util.isNullOrUndefined(relative.search)) {
      if (psychotic) {
        result2.hostname = result2.host = srcPath.shift();
        var authInHost = result2.host && result2.host.indexOf("@") > 0 ? result2.host.split("@") : false;
        if (authInHost) {
          result2.auth = authInHost.shift();
          result2.host = result2.hostname = authInHost.shift();
        }
      }
      result2.search = relative.search;
      result2.query = relative.query;
      if (!util.isNull(result2.pathname) || !util.isNull(result2.search)) {
        result2.path = (result2.pathname ? result2.pathname : "") + (result2.search ? result2.search : "");
      }
      result2.href = result2.format();
      return result2;
    }
    if (!srcPath.length) {
      result2.pathname = null;
      if (result2.search) {
        result2.path = "/" + result2.search;
      } else {
        result2.path = null;
      }
      result2.href = result2.format();
      return result2;
    }
    var last = srcPath.slice(-1)[0];
    var hasTrailingSlash = (result2.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
    var up = 0;
    for (var i = srcPath.length; i >= 0; i--) {
      last = srcPath[i];
      if (last === ".") {
        srcPath.splice(i, 1);
      } else if (last === "..") {
        srcPath.splice(i, 1);
        up++;
      } else if (up) {
        srcPath.splice(i, 1);
        up--;
      }
    }
    if (!mustEndAbs && !removeAllDots) {
      for (; up--; up) {
        srcPath.unshift("..");
      }
    }
    if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
      srcPath.unshift("");
    }
    if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
      srcPath.push("");
    }
    var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
    if (psychotic) {
      result2.hostname = result2.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
      var authInHost = result2.host && result2.host.indexOf("@") > 0 ? result2.host.split("@") : false;
      if (authInHost) {
        result2.auth = authInHost.shift();
        result2.host = result2.hostname = authInHost.shift();
      }
    }
    mustEndAbs = mustEndAbs || result2.host && srcPath.length;
    if (mustEndAbs && !isAbsolute) {
      srcPath.unshift("");
    }
    if (!srcPath.length) {
      result2.pathname = null;
      result2.path = null;
    } else {
      result2.pathname = srcPath.join("/");
    }
    if (!util.isNull(result2.pathname) || !util.isNull(result2.search)) {
      result2.path = (result2.pathname ? result2.pathname : "") + (result2.search ? result2.search : "");
    }
    result2.auth = relative.auth || result2.auth;
    result2.slashes = result2.slashes || relative.slashes;
    result2.href = result2.format();
    return result2;
  };
  Url.prototype.parseHost = function() {
    var host = this.host;
    var port = portPattern.exec(host);
    if (port) {
      port = port[0];
      if (port !== ":") {
        this.port = port.substr(1);
      }
      host = host.substr(0, host.length - port.length);
    }
    if (host)
      this.hostname = host;
  };
  var url = {
    parse: parse$1,
    format,
    resolve
  };
  function assertPath(path2) {
    if (typeof path2 !== "string") {
      throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);
    }
  }
  function removeUrlParams(url2) {
    const re = url2.split("?")[0];
    return re.split("#")[0];
  }
  function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function replaceAll(str, find3, replace) {
    return str.replace(new RegExp(escapeRegExp(find3), "g"), replace);
  }
  function normalizeStringPosix(path2, allowAboveRoot) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for (let i = 0; i <= path2.length; ++i) {
      if (i < path2.length) {
        code = path2.charCodeAt(i);
      } else if (code === 47) {
        break;
      } else {
        code = 47;
      }
      if (code === 47) {
        if (lastSlash === i - 1 || dots === 1) {
        } else if (lastSlash !== i - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              const lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0) {
              res += "/..";
            } else {
              res = "..";
            }
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) {
            res += `/${path2.slice(lastSlash + 1, i)}`;
          } else {
            res = path2.slice(lastSlash + 1, i);
          }
          lastSegmentLength = i - lastSlash - 1;
        }
        lastSlash = i;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  var path = {
    toPosix(path2) {
      return replaceAll(path2, "\\", "/");
    },
    isUrl(path2) {
      return /^https?:/.test(this.toPosix(path2));
    },
    isDataUrl(path2) {
      return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path2);
    },
    hasProtocol(path2) {
      return /^[^/:]+:\//.test(this.toPosix(path2));
    },
    getProtocol(path2) {
      assertPath(path2);
      path2 = this.toPosix(path2);
      let protocol = "";
      const isFile = /^file:\/\/\//.exec(path2);
      const isHttp = /^[^/:]+:\/\//.exec(path2);
      const isWindows = /^[^/:]+:\//.exec(path2);
      if (isFile || isHttp || isWindows) {
        const arr = isFile?.[0] || isHttp?.[0] || isWindows?.[0];
        protocol = arr;
        path2 = path2.slice(arr.length);
      }
      return protocol;
    },
    toAbsolute(url2, customBaseUrl, customRootUrl) {
      if (this.isDataUrl(url2))
        return url2;
      const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? settings.ADAPTER.getBaseUrl()));
      const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));
      assertPath(url2);
      url2 = this.toPosix(url2);
      if (url2.startsWith("/")) {
        return path.join(rootUrl, url2.slice(1));
      }
      const absolutePath = this.isAbsolute(url2) ? url2 : this.join(baseUrl, url2);
      return absolutePath;
    },
    normalize(path2) {
      path2 = this.toPosix(path2);
      assertPath(path2);
      if (path2.length === 0)
        return ".";
      let protocol = "";
      const isAbsolute = path2.startsWith("/");
      if (this.hasProtocol(path2)) {
        protocol = this.rootname(path2);
        path2 = path2.slice(protocol.length);
      }
      const trailingSeparator = path2.endsWith("/");
      path2 = normalizeStringPosix(path2, false);
      if (path2.length > 0 && trailingSeparator)
        path2 += "/";
      if (isAbsolute)
        return `/${path2}`;
      return protocol + path2;
    },
    isAbsolute(path2) {
      assertPath(path2);
      path2 = this.toPosix(path2);
      if (this.hasProtocol(path2))
        return true;
      return path2.startsWith("/");
    },
    join(...segments) {
      if (segments.length === 0) {
        return ".";
      }
      let joined;
      for (let i = 0; i < segments.length; ++i) {
        const arg = segments[i];
        assertPath(arg);
        if (arg.length > 0) {
          if (joined === void 0)
            joined = arg;
          else {
            const prevArg = segments[i - 1] ?? "";
            if (this.extname(prevArg)) {
              joined += `/../${arg}`;
            } else {
              joined += `/${arg}`;
            }
          }
        }
      }
      if (joined === void 0) {
        return ".";
      }
      return this.normalize(joined);
    },
    dirname(path2) {
      assertPath(path2);
      if (path2.length === 0)
        return ".";
      path2 = this.toPosix(path2);
      let code = path2.charCodeAt(0);
      const hasRoot = code === 47;
      let end = -1;
      let matchedSlash = true;
      const proto = this.getProtocol(path2);
      const origpath = path2;
      path2 = path2.slice(proto.length);
      for (let i = path2.length - 1; i >= 1; --i) {
        code = path2.charCodeAt(i);
        if (code === 47) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1)
        return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;
      if (hasRoot && end === 1)
        return "//";
      return proto + path2.slice(0, end);
    },
    rootname(path2) {
      assertPath(path2);
      path2 = this.toPosix(path2);
      let root2 = "";
      if (path2.startsWith("/"))
        root2 = "/";
      else {
        root2 = this.getProtocol(path2);
      }
      if (this.isUrl(path2)) {
        const index2 = path2.indexOf("/", root2.length);
        if (index2 !== -1) {
          root2 = path2.slice(0, index2);
        } else
          root2 = path2;
        if (!root2.endsWith("/"))
          root2 += "/";
      }
      return root2;
    },
    basename(path2, ext) {
      assertPath(path2);
      if (ext)
        assertPath(ext);
      path2 = this.toPosix(path2);
      let start = 0;
      let end = -1;
      let matchedSlash = true;
      let i;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
        if (ext.length === path2.length && ext === path2)
          return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for (i = path2.length - 1; i >= 0; --i) {
          const code = path2.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end)
          end = firstNonSlashEnd;
        else if (end === -1)
          end = path2.length;
        return path2.slice(start, end);
      }
      for (i = path2.length - 1; i >= 0; --i) {
        if (path2.charCodeAt(i) === 47) {
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
      }
      if (end === -1)
        return "";
      return path2.slice(start, end);
    },
    extname(path2) {
      assertPath(path2);
      path2 = this.toPosix(path2);
      let startDot = -1;
      let startPart = 0;
      let end = -1;
      let matchedSlash = true;
      let preDotState = 0;
      for (let i = path2.length - 1; i >= 0; --i) {
        const code = path2.charCodeAt(i);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path2.slice(startDot, end);
    },
    parse(path2) {
      assertPath(path2);
      const ret = { root: "", dir: "", base: "", ext: "", name: "" };
      if (path2.length === 0)
        return ret;
      path2 = this.toPosix(path2);
      let code = path2.charCodeAt(0);
      const isAbsolute = this.isAbsolute(path2);
      let start;
      const protocol = "";
      ret.root = this.rootname(path2);
      if (isAbsolute || this.hasProtocol(path2)) {
        start = 1;
      } else {
        start = 0;
      }
      let startDot = -1;
      let startPart = 0;
      let end = -1;
      let matchedSlash = true;
      let i = path2.length - 1;
      let preDotState = 0;
      for (; i >= start; --i) {
        code = path2.charCodeAt(i);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute)
            ret.base = ret.name = path2.slice(1, end);
          else
            ret.base = ret.name = path2.slice(startPart, end);
        }
      } else {
        if (startPart === 0 && isAbsolute) {
          ret.name = path2.slice(1, startDot);
          ret.base = path2.slice(1, end);
        } else {
          ret.name = path2.slice(startPart, startDot);
          ret.base = path2.slice(startPart, end);
        }
        ret.ext = path2.slice(startDot, end);
      }
      ret.dir = this.dirname(path2);
      if (protocol)
        ret.dir = protocol + ret.dir;
      return ret;
    },
    sep: "/",
    delimiter: ":"
  };
  settings.RETINA_PREFIX = /@([0-9\.]+)x/;
  settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;
  var warnings = {};
  function deprecation(version, message, ignoreDepth = 3) {
    if (warnings[message]) {
      return;
    }
    let stack = new Error().stack;
    if (typeof stack === "undefined") {
      console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
    } else {
      stack = stack.split("\n").splice(ignoreDepth).join("\n");
      if (console.groupCollapsed) {
        console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${message}
Deprecated since v${version}`);
        console.warn(stack);
        console.groupEnd();
      } else {
        console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
        console.warn(stack);
      }
    }
    warnings[message] = true;
  }
  function skipHello() {
    deprecation("7.0.0", "skipHello is deprecated, please use PIXI.settings.RENDER_OPTIONS.hello");
  }
  function sayHello() {
    deprecation("7.0.0", `sayHello is deprecated, please use Renderer's "hello" option`);
  }
  var supported;
  function isWebGLSupported() {
    if (typeof supported === "undefined") {
      supported = function supported2() {
        const contextOptions = {
          stencil: true,
          failIfMajorPerformanceCaveat: settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
        };
        try {
          if (!settings.ADAPTER.getWebGLRenderingContext()) {
            return false;
          }
          const canvas = settings.ADAPTER.createCanvas();
          let gl = canvas.getContext("webgl", contextOptions) || canvas.getContext("experimental-webgl", contextOptions);
          const success = !!(gl && gl.getContextAttributes().stencil);
          if (gl) {
            const loseContext = gl.getExtension("WEBGL_lose_context");
            if (loseContext) {
              loseContext.loseContext();
            }
          }
          gl = null;
          return success;
        } catch (e) {
          return false;
        }
      }();
    }
    return supported;
  }
  var aliceblue = "#f0f8ff";
  var antiquewhite = "#faebd7";
  var aqua = "#00ffff";
  var aquamarine = "#7fffd4";
  var azure = "#f0ffff";
  var beige = "#f5f5dc";
  var bisque = "#ffe4c4";
  var black = "#000000";
  var blanchedalmond = "#ffebcd";
  var blue = "#0000ff";
  var blueviolet = "#8a2be2";
  var brown = "#a52a2a";
  var burlywood = "#deb887";
  var cadetblue = "#5f9ea0";
  var chartreuse = "#7fff00";
  var chocolate = "#d2691e";
  var coral = "#ff7f50";
  var cornflowerblue = "#6495ed";
  var cornsilk = "#fff8dc";
  var crimson = "#dc143c";
  var cyan = "#00ffff";
  var darkblue = "#00008b";
  var darkcyan = "#008b8b";
  var darkgoldenrod = "#b8860b";
  var darkgray = "#a9a9a9";
  var darkgreen = "#006400";
  var darkgrey = "#a9a9a9";
  var darkkhaki = "#bdb76b";
  var darkmagenta = "#8b008b";
  var darkolivegreen = "#556b2f";
  var darkorange = "#ff8c00";
  var darkorchid = "#9932cc";
  var darkred = "#8b0000";
  var darksalmon = "#e9967a";
  var darkseagreen = "#8fbc8f";
  var darkslateblue = "#483d8b";
  var darkslategray = "#2f4f4f";
  var darkslategrey = "#2f4f4f";
  var darkturquoise = "#00ced1";
  var darkviolet = "#9400d3";
  var deeppink = "#ff1493";
  var deepskyblue = "#00bfff";
  var dimgray = "#696969";
  var dimgrey = "#696969";
  var dodgerblue = "#1e90ff";
  var firebrick = "#b22222";
  var floralwhite = "#fffaf0";
  var forestgreen = "#228b22";
  var fuchsia = "#ff00ff";
  var gainsboro = "#dcdcdc";
  var ghostwhite = "#f8f8ff";
  var goldenrod = "#daa520";
  var gold = "#ffd700";
  var gray = "#808080";
  var green = "#008000";
  var greenyellow = "#adff2f";
  var grey = "#808080";
  var honeydew = "#f0fff0";
  var hotpink = "#ff69b4";
  var indianred = "#cd5c5c";
  var indigo = "#4b0082";
  var ivory = "#fffff0";
  var khaki = "#f0e68c";
  var lavenderblush = "#fff0f5";
  var lavender = "#e6e6fa";
  var lawngreen = "#7cfc00";
  var lemonchiffon = "#fffacd";
  var lightblue = "#add8e6";
  var lightcoral = "#f08080";
  var lightcyan = "#e0ffff";
  var lightgoldenrodyellow = "#fafad2";
  var lightgray = "#d3d3d3";
  var lightgreen = "#90ee90";
  var lightgrey = "#d3d3d3";
  var lightpink = "#ffb6c1";
  var lightsalmon = "#ffa07a";
  var lightseagreen = "#20b2aa";
  var lightskyblue = "#87cefa";
  var lightslategray = "#778899";
  var lightslategrey = "#778899";
  var lightsteelblue = "#b0c4de";
  var lightyellow = "#ffffe0";
  var lime = "#00ff00";
  var limegreen = "#32cd32";
  var linen = "#faf0e6";
  var magenta = "#ff00ff";
  var maroon = "#800000";
  var mediumaquamarine = "#66cdaa";
  var mediumblue = "#0000cd";
  var mediumorchid = "#ba55d3";
  var mediumpurple = "#9370db";
  var mediumseagreen = "#3cb371";
  var mediumslateblue = "#7b68ee";
  var mediumspringgreen = "#00fa9a";
  var mediumturquoise = "#48d1cc";
  var mediumvioletred = "#c71585";
  var midnightblue = "#191970";
  var mintcream = "#f5fffa";
  var mistyrose = "#ffe4e1";
  var moccasin = "#ffe4b5";
  var navajowhite = "#ffdead";
  var navy = "#000080";
  var oldlace = "#fdf5e6";
  var olive = "#808000";
  var olivedrab = "#6b8e23";
  var orange = "#ffa500";
  var orangered = "#ff4500";
  var orchid = "#da70d6";
  var palegoldenrod = "#eee8aa";
  var palegreen = "#98fb98";
  var paleturquoise = "#afeeee";
  var palevioletred = "#db7093";
  var papayawhip = "#ffefd5";
  var peachpuff = "#ffdab9";
  var peru = "#cd853f";
  var pink = "#ffc0cb";
  var plum = "#dda0dd";
  var powderblue = "#b0e0e6";
  var purple = "#800080";
  var rebeccapurple = "#663399";
  var red = "#ff0000";
  var rosybrown = "#bc8f8f";
  var royalblue = "#4169e1";
  var saddlebrown = "#8b4513";
  var salmon = "#fa8072";
  var sandybrown = "#f4a460";
  var seagreen = "#2e8b57";
  var seashell = "#fff5ee";
  var sienna = "#a0522d";
  var silver = "#c0c0c0";
  var skyblue = "#87ceeb";
  var slateblue = "#6a5acd";
  var slategray = "#708090";
  var slategrey = "#708090";
  var snow = "#fffafa";
  var springgreen = "#00ff7f";
  var steelblue = "#4682b4";
  var tan = "#d2b48c";
  var teal = "#008080";
  var thistle = "#d8bfd8";
  var tomato = "#ff6347";
  var turquoise = "#40e0d0";
  var violet = "#ee82ee";
  var wheat = "#f5deb3";
  var white = "#ffffff";
  var whitesmoke = "#f5f5f5";
  var yellow = "#ffff00";
  var yellowgreen = "#9acd32";
  var cssColorNames = {
    aliceblue,
    antiquewhite,
    aqua,
    aquamarine,
    azure,
    beige,
    bisque,
    black,
    blanchedalmond,
    blue,
    blueviolet,
    brown,
    burlywood,
    cadetblue,
    chartreuse,
    chocolate,
    coral,
    cornflowerblue,
    cornsilk,
    crimson,
    cyan,
    darkblue,
    darkcyan,
    darkgoldenrod,
    darkgray,
    darkgreen,
    darkgrey,
    darkkhaki,
    darkmagenta,
    darkolivegreen,
    darkorange,
    darkorchid,
    darkred,
    darksalmon,
    darkseagreen,
    darkslateblue,
    darkslategray,
    darkslategrey,
    darkturquoise,
    darkviolet,
    deeppink,
    deepskyblue,
    dimgray,
    dimgrey,
    dodgerblue,
    firebrick,
    floralwhite,
    forestgreen,
    fuchsia,
    gainsboro,
    ghostwhite,
    goldenrod,
    gold,
    gray,
    green,
    greenyellow,
    grey,
    honeydew,
    hotpink,
    indianred,
    indigo,
    ivory,
    khaki,
    lavenderblush,
    lavender,
    lawngreen,
    lemonchiffon,
    lightblue,
    lightcoral,
    lightcyan,
    lightgoldenrodyellow,
    lightgray,
    lightgreen,
    lightgrey,
    lightpink,
    lightsalmon,
    lightseagreen,
    lightskyblue,
    lightslategray,
    lightslategrey,
    lightsteelblue,
    lightyellow,
    lime,
    limegreen,
    linen,
    magenta,
    maroon,
    mediumaquamarine,
    mediumblue,
    mediumorchid,
    mediumpurple,
    mediumseagreen,
    mediumslateblue,
    mediumspringgreen,
    mediumturquoise,
    mediumvioletred,
    midnightblue,
    mintcream,
    mistyrose,
    moccasin,
    navajowhite,
    navy,
    oldlace,
    olive,
    olivedrab,
    orange,
    orangered,
    orchid,
    palegoldenrod,
    palegreen,
    paleturquoise,
    palevioletred,
    papayawhip,
    peachpuff,
    peru,
    pink,
    plum,
    powderblue,
    purple,
    rebeccapurple,
    red,
    rosybrown,
    royalblue,
    saddlebrown,
    salmon,
    sandybrown,
    seagreen,
    seashell,
    sienna,
    silver,
    skyblue,
    slateblue,
    slategray,
    slategrey,
    snow,
    springgreen,
    steelblue,
    tan,
    teal,
    thistle,
    tomato,
    turquoise,
    violet,
    wheat,
    white,
    whitesmoke,
    yellow,
    yellowgreen
  };
  function hex2rgb(hex, out = []) {
    out[0] = (hex >> 16 & 255) / 255;
    out[1] = (hex >> 8 & 255) / 255;
    out[2] = (hex & 255) / 255;
    return out;
  }
  function hex2string(hex) {
    let hexString = hex.toString(16);
    hexString = "000000".substring(0, 6 - hexString.length) + hexString;
    return `#${hexString}`;
  }
  function string2hex(string) {
    if (typeof string === "string") {
      string = cssColorNames[string.toLowerCase()] || string;
      if (string[0] === "#") {
        string = string.slice(1);
      }
      if (string.length === 3) {
        const [r, g, b2] = string;
        string = r + r + g + g + b2 + b2;
      }
    }
    return parseInt(string, 16);
  }
  function rgb2hex(rgb) {
    return (rgb[0] * 255 << 16) + (rgb[1] * 255 << 8) + (rgb[2] * 255 | 0);
  }
  function mapPremultipliedBlendModes() {
    const pm = [];
    const npm = [];
    for (let i = 0; i < 32; i++) {
      pm[i] = i;
      npm[i] = i;
    }
    pm[BLEND_MODES.NORMAL_NPM] = BLEND_MODES.NORMAL;
    pm[BLEND_MODES.ADD_NPM] = BLEND_MODES.ADD;
    pm[BLEND_MODES.SCREEN_NPM] = BLEND_MODES.SCREEN;
    npm[BLEND_MODES.NORMAL] = BLEND_MODES.NORMAL_NPM;
    npm[BLEND_MODES.ADD] = BLEND_MODES.ADD_NPM;
    npm[BLEND_MODES.SCREEN] = BLEND_MODES.SCREEN_NPM;
    const array = [];
    array.push(npm);
    array.push(pm);
    return array;
  }
  var premultiplyBlendMode = mapPremultipliedBlendModes();
  function correctBlendMode(blendMode, premultiplied) {
    return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];
  }
  function premultiplyRgba(rgb, alpha, out, premultiply) {
    out = out || new Float32Array(4);
    if (premultiply || premultiply === void 0) {
      out[0] = rgb[0] * alpha;
      out[1] = rgb[1] * alpha;
      out[2] = rgb[2] * alpha;
    } else {
      out[0] = rgb[0];
      out[1] = rgb[1];
      out[2] = rgb[2];
    }
    out[3] = alpha;
    return out;
  }
  function premultiplyTint(tint, alpha) {
    if (alpha === 1) {
      return (alpha * 255 << 24) + tint;
    }
    if (alpha === 0) {
      return 0;
    }
    let R = tint >> 16 & 255;
    let G = tint >> 8 & 255;
    let B = tint & 255;
    R = R * alpha + 0.5 | 0;
    G = G * alpha + 0.5 | 0;
    B = B * alpha + 0.5 | 0;
    return (alpha * 255 << 24) + (R << 16) + (G << 8) + B;
  }
  function premultiplyTintToRgba(tint, alpha, out, premultiply) {
    out = out || new Float32Array(4);
    out[0] = (tint >> 16 & 255) / 255;
    out[1] = (tint >> 8 & 255) / 255;
    out[2] = (tint & 255) / 255;
    if (premultiply || premultiply === void 0) {
      out[0] *= alpha;
      out[1] *= alpha;
      out[2] *= alpha;
    }
    out[3] = alpha;
    return out;
  }
  function createIndicesForQuads(size, outBuffer = null) {
    const totalIndices = size * 6;
    outBuffer = outBuffer || new Uint16Array(totalIndices);
    if (outBuffer.length !== totalIndices) {
      throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);
    }
    for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4) {
      outBuffer[i + 0] = j + 0;
      outBuffer[i + 1] = j + 1;
      outBuffer[i + 2] = j + 2;
      outBuffer[i + 3] = j + 0;
      outBuffer[i + 4] = j + 2;
      outBuffer[i + 5] = j + 3;
    }
    return outBuffer;
  }
  function getBufferType(array) {
    if (array.BYTES_PER_ELEMENT === 4) {
      if (array instanceof Float32Array) {
        return "Float32Array";
      } else if (array instanceof Uint32Array) {
        return "Uint32Array";
      }
      return "Int32Array";
    } else if (array.BYTES_PER_ELEMENT === 2) {
      if (array instanceof Uint16Array) {
        return "Uint16Array";
      }
    } else if (array.BYTES_PER_ELEMENT === 1) {
      if (array instanceof Uint8Array) {
        return "Uint8Array";
      }
    }
    return null;
  }
  var map$2 = { Float32Array, Uint32Array, Int32Array, Uint8Array };
  function interleaveTypedArrays$1(arrays, sizes) {
    let outSize = 0;
    let stride = 0;
    const views = {};
    for (let i = 0; i < arrays.length; i++) {
      stride += sizes[i];
      outSize += arrays[i].length;
    }
    const buffer = new ArrayBuffer(outSize * 4);
    let out = null;
    let littleOffset = 0;
    for (let i = 0; i < arrays.length; i++) {
      const size = sizes[i];
      const array = arrays[i];
      const type = getBufferType(array);
      if (!views[type]) {
        views[type] = new map$2[type](buffer);
      }
      out = views[type];
      for (let j = 0; j < array.length; j++) {
        const indexStart = (j / size | 0) * stride + littleOffset;
        const index2 = j % size;
        out[indexStart + index2] = array[j];
      }
      littleOffset += size;
    }
    return new Float32Array(buffer);
  }
  function nextPow2(v2) {
    v2 += v2 === 0 ? 1 : 0;
    --v2;
    v2 |= v2 >>> 1;
    v2 |= v2 >>> 2;
    v2 |= v2 >>> 4;
    v2 |= v2 >>> 8;
    v2 |= v2 >>> 16;
    return v2 + 1;
  }
  function isPow2(v2) {
    return !(v2 & v2 - 1) && !!v2;
  }
  function log2(v2) {
    let r = (v2 > 65535 ? 1 : 0) << 4;
    v2 >>>= r;
    let shift = (v2 > 255 ? 1 : 0) << 3;
    v2 >>>= shift;
    r |= shift;
    shift = (v2 > 15 ? 1 : 0) << 2;
    v2 >>>= shift;
    r |= shift;
    shift = (v2 > 3 ? 1 : 0) << 1;
    v2 >>>= shift;
    r |= shift;
    return r | v2 >> 1;
  }
  function removeItems(arr, startIdx, removeCount) {
    const length = arr.length;
    let i;
    if (startIdx >= length || removeCount === 0) {
      return;
    }
    removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
    const len = length - removeCount;
    for (i = startIdx; i < len; ++i) {
      arr[i] = arr[i + removeCount];
    }
    arr.length = len;
  }
  function sign2(n) {
    if (n === 0)
      return 0;
    return n < 0 ? -1 : 1;
  }
  var nextUid = 0;
  function uid() {
    return ++nextUid;
  }
  var ProgramCache = {};
  var TextureCache = /* @__PURE__ */ Object.create(null);
  var BaseTextureCache = /* @__PURE__ */ Object.create(null);
  function destroyTextureCache() {
    let key;
    for (key in TextureCache) {
      TextureCache[key].destroy();
    }
    for (key in BaseTextureCache) {
      BaseTextureCache[key].destroy();
    }
  }
  function clearTextureCache() {
    let key;
    for (key in TextureCache) {
      delete TextureCache[key];
    }
    for (key in BaseTextureCache) {
      delete BaseTextureCache[key];
    }
  }
  var CanvasRenderTarget = class {
    constructor(width, height, resolution) {
      this.canvas = settings.ADAPTER.createCanvas();
      this.context = this.canvas.getContext("2d");
      this.resolution = resolution || settings.RESOLUTION;
      this.resize(width, height);
    }
    clear() {
      this.context.setTransform(1, 0, 0, 1, 0, 0);
      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    resize(desiredWidth, desiredHeight) {
      this.canvas.width = Math.round(desiredWidth * this.resolution);
      this.canvas.height = Math.round(desiredHeight * this.resolution);
    }
    destroy() {
      this.context = null;
      this.canvas = null;
    }
    get width() {
      return this.canvas.width;
    }
    set width(val) {
      this.canvas.width = Math.round(val);
    }
    get height() {
      return this.canvas.height;
    }
    set height(val) {
      this.canvas.height = Math.round(val);
    }
  };
  function checkRow(data, width, y) {
    for (let x = 0, index2 = 4 * y * width; x < width; ++x, index2 += 4) {
      if (data[index2 + 3] !== 0)
        return false;
    }
    return true;
  }
  function checkColumn(data, width, x, top, bottom) {
    const stride = 4 * width;
    for (let y = top, index2 = top * stride + 4 * x; y <= bottom; ++y, index2 += stride) {
      if (data[index2 + 3] !== 0)
        return false;
    }
    return true;
  }
  function trimCanvas(canvas) {
    let { width, height } = canvas;
    const context2 = canvas.getContext("2d", {
      willReadFrequently: true
    });
    const imageData = context2.getImageData(0, 0, width, height);
    const data = imageData.data;
    let top = 0;
    let bottom = height - 1;
    let left = 0;
    let right = width - 1;
    while (top < height && checkRow(data, width, top))
      ++top;
    if (top === height) {
      return { width: 0, height: 0, data: null };
    }
    while (checkRow(data, width, bottom))
      --bottom;
    while (checkColumn(data, width, left, top, bottom))
      ++left;
    while (checkColumn(data, width, right, top, bottom))
      --right;
    width = right - left + 1;
    height = bottom - top + 1;
    return {
      width,
      height,
      data: context2.getImageData(left, top, width, height)
    };
  }
  var DATA_URI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;
  function decomposeDataUri(dataUri) {
    const dataUriMatch = DATA_URI.exec(dataUri);
    if (dataUriMatch) {
      return {
        mediaType: dataUriMatch[1] ? dataUriMatch[1].toLowerCase() : void 0,
        subType: dataUriMatch[2] ? dataUriMatch[2].toLowerCase() : void 0,
        charset: dataUriMatch[3] ? dataUriMatch[3].toLowerCase() : void 0,
        encoding: dataUriMatch[4] ? dataUriMatch[4].toLowerCase() : void 0,
        data: dataUriMatch[5]
      };
    }
    return void 0;
  }
  var tempAnchor;
  function determineCrossOrigin(url$1, loc = globalThis.location) {
    if (url$1.startsWith("data:")) {
      return "";
    }
    loc = loc || globalThis.location;
    if (!tempAnchor) {
      tempAnchor = document.createElement("a");
    }
    tempAnchor.href = url$1;
    const parsedUrl = url.parse(tempAnchor.href);
    const samePort = !parsedUrl.port && loc.port === "" || parsedUrl.port === loc.port;
    if (parsedUrl.hostname !== loc.hostname || !samePort || parsedUrl.protocol !== loc.protocol) {
      return "anonymous";
    }
    return "";
  }
  function getResolutionOfUrl(url2, defaultValue2 = 1) {
    const resolution = settings.RETINA_PREFIX.exec(url2);
    if (resolution) {
      return parseFloat(resolution[1]);
    }
    return defaultValue2;
  }
  var index = {
    __proto__: null,
    isMobile,
    EventEmitter: eventemitter3,
    earcut: earcut_1,
    url,
    path,
    sayHello,
    skipHello,
    isWebGLSupported,
    hex2rgb,
    hex2string,
    rgb2hex,
    string2hex,
    correctBlendMode,
    premultiplyBlendMode,
    premultiplyRgba,
    premultiplyTint,
    premultiplyTintToRgba,
    createIndicesForQuads,
    getBufferType,
    interleaveTypedArrays: interleaveTypedArrays$1,
    isPow2,
    log2,
    nextPow2,
    removeItems,
    sign: sign2,
    uid,
    deprecation,
    BaseTextureCache,
    ProgramCache,
    TextureCache,
    clearTextureCache,
    destroyTextureCache,
    CanvasRenderTarget,
    trimCanvas,
    decomposeDataUri,
    determineCrossOrigin,
    getResolutionOfUrl,
    DATA_URI
  };
  var INSTALLED = [];
  function autoDetectResource(source, options) {
    if (!source) {
      return null;
    }
    let extension = "";
    if (typeof source === "string") {
      const result2 = /\.(\w{3,4})(?:$|\?|#)/i.exec(source);
      if (result2) {
        extension = result2[1].toLowerCase();
      }
    }
    for (let i = INSTALLED.length - 1; i >= 0; --i) {
      const ResourcePlugin = INSTALLED[i];
      if (ResourcePlugin.test && ResourcePlugin.test(source, extension)) {
        return new ResourcePlugin(source, options);
      }
    }
    throw new Error("Unrecognized source type to auto-detect Resource");
  }
  var Resource = class {
    constructor(width = 0, height = 0) {
      this._width = width;
      this._height = height;
      this.destroyed = false;
      this.internal = false;
      this.onResize = new Runner("setRealSize");
      this.onUpdate = new Runner("update");
      this.onError = new Runner("onError");
    }
    bind(baseTexture) {
      this.onResize.add(baseTexture);
      this.onUpdate.add(baseTexture);
      this.onError.add(baseTexture);
      if (this._width || this._height) {
        this.onResize.emit(this._width, this._height);
      }
    }
    unbind(baseTexture) {
      this.onResize.remove(baseTexture);
      this.onUpdate.remove(baseTexture);
      this.onError.remove(baseTexture);
    }
    resize(width, height) {
      if (width !== this._width || height !== this._height) {
        this._width = width;
        this._height = height;
        this.onResize.emit(width, height);
      }
    }
    get valid() {
      return !!this._width && !!this._height;
    }
    update() {
      if (!this.destroyed) {
        this.onUpdate.emit();
      }
    }
    load() {
      return Promise.resolve(this);
    }
    get width() {
      return this._width;
    }
    get height() {
      return this._height;
    }
    style(_renderer, _baseTexture, _glTexture) {
      return false;
    }
    dispose() {
    }
    destroy() {
      if (!this.destroyed) {
        this.destroyed = true;
        this.dispose();
        this.onError.removeAll();
        this.onError = null;
        this.onResize.removeAll();
        this.onResize = null;
        this.onUpdate.removeAll();
        this.onUpdate = null;
      }
    }
    static test(_source, _extension) {
      return false;
    }
  };
  var BufferResource = class extends Resource {
    constructor(source, options) {
      const { width, height } = options || {};
      if (!width || !height) {
        throw new Error("BufferResource width or height invalid");
      }
      super(width, height);
      this.data = source;
    }
    upload(renderer, baseTexture, glTexture) {
      const gl = renderer.gl;
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
      const width = baseTexture.realWidth;
      const height = baseTexture.realHeight;
      if (glTexture.width === width && glTexture.height === height) {
        gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
      } else {
        glTexture.width = width;
        glTexture.height = height;
        gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
      }
      return true;
    }
    dispose() {
      this.data = null;
    }
    static test(source) {
      return source instanceof Float32Array || source instanceof Uint8Array || source instanceof Uint32Array;
    }
  };
  var defaultBufferOptions = {
    scaleMode: SCALE_MODES.NEAREST,
    format: FORMATS.RGBA,
    alphaMode: ALPHA_MODES.NPM
  };
  var _BaseTexture = class extends eventemitter3 {
    constructor(resource = null, options = null) {
      super();
      options = options || {};
      const {
        alphaMode,
        mipmap,
        anisotropicLevel,
        scaleMode,
        width,
        height,
        wrapMode,
        format: format2,
        type,
        target: target2,
        resolution,
        resourceOptions
      } = options;
      if (resource && !(resource instanceof Resource)) {
        resource = autoDetectResource(resource, resourceOptions);
        resource.internal = true;
      }
      this.resolution = resolution || settings.RESOLUTION;
      this.width = Math.round((width || 0) * this.resolution) / this.resolution;
      this.height = Math.round((height || 0) * this.resolution) / this.resolution;
      this._mipmap = mipmap ?? settings.MIPMAP_TEXTURES;
      this.anisotropicLevel = anisotropicLevel ?? settings.ANISOTROPIC_LEVEL;
      this._wrapMode = wrapMode || settings.WRAP_MODE;
      this._scaleMode = scaleMode ?? settings.SCALE_MODE;
      this.format = format2 || FORMATS.RGBA;
      this.type = type || TYPES.UNSIGNED_BYTE;
      this.target = target2 || TARGETS.TEXTURE_2D;
      this.alphaMode = alphaMode ?? ALPHA_MODES.UNPACK;
      this.uid = uid();
      this.touched = 0;
      this.isPowerOfTwo = false;
      this._refreshPOT();
      this._glTextures = {};
      this.dirtyId = 0;
      this.dirtyStyleId = 0;
      this.cacheId = null;
      this.valid = width > 0 && height > 0;
      this.textureCacheIds = [];
      this.destroyed = false;
      this.resource = null;
      this._batchEnabled = 0;
      this._batchLocation = 0;
      this.parentTextureArray = null;
      this.setResource(resource);
    }
    get realWidth() {
      return Math.round(this.width * this.resolution);
    }
    get realHeight() {
      return Math.round(this.height * this.resolution);
    }
    get mipmap() {
      return this._mipmap;
    }
    set mipmap(value3) {
      if (this._mipmap !== value3) {
        this._mipmap = value3;
        this.dirtyStyleId++;
      }
    }
    get scaleMode() {
      return this._scaleMode;
    }
    set scaleMode(value3) {
      if (this._scaleMode !== value3) {
        this._scaleMode = value3;
        this.dirtyStyleId++;
      }
    }
    get wrapMode() {
      return this._wrapMode;
    }
    set wrapMode(value3) {
      if (this._wrapMode !== value3) {
        this._wrapMode = value3;
        this.dirtyStyleId++;
      }
    }
    setStyle(scaleMode, mipmap) {
      let dirty;
      if (scaleMode !== void 0 && scaleMode !== this.scaleMode) {
        this.scaleMode = scaleMode;
        dirty = true;
      }
      if (mipmap !== void 0 && mipmap !== this.mipmap) {
        this.mipmap = mipmap;
        dirty = true;
      }
      if (dirty) {
        this.dirtyStyleId++;
      }
      return this;
    }
    setSize(desiredWidth, desiredHeight, resolution) {
      resolution = resolution || this.resolution;
      return this.setRealSize(desiredWidth * resolution, desiredHeight * resolution, resolution);
    }
    setRealSize(realWidth, realHeight, resolution) {
      this.resolution = resolution || this.resolution;
      this.width = Math.round(realWidth) / this.resolution;
      this.height = Math.round(realHeight) / this.resolution;
      this._refreshPOT();
      this.update();
      return this;
    }
    _refreshPOT() {
      this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);
    }
    setResolution(resolution) {
      const oldResolution = this.resolution;
      if (oldResolution === resolution) {
        return this;
      }
      this.resolution = resolution;
      if (this.valid) {
        this.width = Math.round(this.width * oldResolution) / resolution;
        this.height = Math.round(this.height * oldResolution) / resolution;
        this.emit("update", this);
      }
      this._refreshPOT();
      return this;
    }
    setResource(resource) {
      if (this.resource === resource) {
        return this;
      }
      if (this.resource) {
        throw new Error("Resource can be set only once");
      }
      resource.bind(this);
      this.resource = resource;
      return this;
    }
    update() {
      if (!this.valid) {
        if (this.width > 0 && this.height > 0) {
          this.valid = true;
          this.emit("loaded", this);
          this.emit("update", this);
        }
      } else {
        this.dirtyId++;
        this.dirtyStyleId++;
        this.emit("update", this);
      }
    }
    onError(event) {
      this.emit("error", this, event);
    }
    destroy() {
      if (this.resource) {
        this.resource.unbind(this);
        if (this.resource.internal) {
          this.resource.destroy();
        }
        this.resource = null;
      }
      if (this.cacheId) {
        delete BaseTextureCache[this.cacheId];
        delete TextureCache[this.cacheId];
        this.cacheId = null;
      }
      this.dispose();
      _BaseTexture.removeFromCache(this);
      this.textureCacheIds = null;
      this.destroyed = true;
    }
    dispose() {
      this.emit("dispose", this);
    }
    castToBaseTexture() {
      return this;
    }
    static from(source, options, strict = settings.STRICT_TEXTURE_CACHE) {
      const isFrame = typeof source === "string";
      let cacheId = null;
      if (isFrame) {
        cacheId = source;
      } else {
        if (!source._pixiId) {
          const prefix = options?.pixiIdPrefix || "pixiid";
          source._pixiId = `${prefix}_${uid()}`;
        }
        cacheId = source._pixiId;
      }
      let baseTexture = BaseTextureCache[cacheId];
      if (isFrame && strict && !baseTexture) {
        throw new Error(`The cacheId "${cacheId}" does not exist in BaseTextureCache.`);
      }
      if (!baseTexture) {
        baseTexture = new _BaseTexture(source, options);
        baseTexture.cacheId = cacheId;
        _BaseTexture.addToCache(baseTexture, cacheId);
      }
      return baseTexture;
    }
    static fromBuffer(buffer, width, height, options) {
      buffer = buffer || new Float32Array(width * height * 4);
      const resource = new BufferResource(buffer, { width, height });
      const type = buffer instanceof Float32Array ? TYPES.FLOAT : TYPES.UNSIGNED_BYTE;
      return new _BaseTexture(resource, Object.assign({}, defaultBufferOptions, options || { width, height, type }));
    }
    static addToCache(baseTexture, id) {
      if (id) {
        if (!baseTexture.textureCacheIds.includes(id)) {
          baseTexture.textureCacheIds.push(id);
        }
        if (BaseTextureCache[id] && BaseTextureCache[id] !== baseTexture) {
          console.warn(`BaseTexture added to the cache with an id [${id}] that already had an entry`);
        }
        BaseTextureCache[id] = baseTexture;
      }
    }
    static removeFromCache(baseTexture) {
      if (typeof baseTexture === "string") {
        const baseTextureFromCache = BaseTextureCache[baseTexture];
        if (baseTextureFromCache) {
          const index2 = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
          if (index2 > -1) {
            baseTextureFromCache.textureCacheIds.splice(index2, 1);
          }
          delete BaseTextureCache[baseTexture];
          return baseTextureFromCache;
        }
      } else if (baseTexture?.textureCacheIds) {
        for (let i = 0; i < baseTexture.textureCacheIds.length; ++i) {
          delete BaseTextureCache[baseTexture.textureCacheIds[i]];
        }
        baseTexture.textureCacheIds.length = 0;
        return baseTexture;
      }
      return null;
    }
  };
  var BaseTexture = _BaseTexture;
  BaseTexture._globalBatch = 0;
  var AbstractMultiResource = class extends Resource {
    constructor(length, options) {
      const { width, height } = options || {};
      super(width, height);
      this.items = [];
      this.itemDirtyIds = [];
      for (let i = 0; i < length; i++) {
        const partTexture = new BaseTexture();
        this.items.push(partTexture);
        this.itemDirtyIds.push(-2);
      }
      this.length = length;
      this._load = null;
      this.baseTexture = null;
    }
    initFromArray(resources, options) {
      for (let i = 0; i < this.length; i++) {
        if (!resources[i]) {
          continue;
        }
        if (resources[i].castToBaseTexture) {
          this.addBaseTextureAt(resources[i].castToBaseTexture(), i);
        } else if (resources[i] instanceof Resource) {
          this.addResourceAt(resources[i], i);
        } else {
          this.addResourceAt(autoDetectResource(resources[i], options), i);
        }
      }
    }
    dispose() {
      for (let i = 0, len = this.length; i < len; i++) {
        this.items[i].destroy();
      }
      this.items = null;
      this.itemDirtyIds = null;
      this._load = null;
    }
    addResourceAt(resource, index2) {
      if (!this.items[index2]) {
        throw new Error(`Index ${index2} is out of bounds`);
      }
      if (resource.valid && !this.valid) {
        this.resize(resource.width, resource.height);
      }
      this.items[index2].setResource(resource);
      return this;
    }
    bind(baseTexture) {
      if (this.baseTexture !== null) {
        throw new Error("Only one base texture per TextureArray is allowed");
      }
      super.bind(baseTexture);
      for (let i = 0; i < this.length; i++) {
        this.items[i].parentTextureArray = baseTexture;
        this.items[i].on("update", baseTexture.update, baseTexture);
      }
    }
    unbind(baseTexture) {
      super.unbind(baseTexture);
      for (let i = 0; i < this.length; i++) {
        this.items[i].parentTextureArray = null;
        this.items[i].off("update", baseTexture.update, baseTexture);
      }
    }
    load() {
      if (this._load) {
        return this._load;
      }
      const resources = this.items.map((item2) => item2.resource).filter((item2) => item2);
      const promises = resources.map((item2) => item2.load());
      this._load = Promise.all(promises).then(() => {
        const { realWidth, realHeight } = this.items[0];
        this.resize(realWidth, realHeight);
        return Promise.resolve(this);
      });
      return this._load;
    }
  };
  var ArrayResource = class extends AbstractMultiResource {
    constructor(source, options) {
      const { width, height } = options || {};
      let urls;
      let length;
      if (Array.isArray(source)) {
        urls = source;
        length = source.length;
      } else {
        length = source;
      }
      super(length, { width, height });
      if (urls) {
        this.initFromArray(urls, options);
      }
    }
    addBaseTextureAt(baseTexture, index2) {
      if (baseTexture.resource) {
        this.addResourceAt(baseTexture.resource, index2);
      } else {
        throw new Error("ArrayResource does not support RenderTexture");
      }
      return this;
    }
    bind(baseTexture) {
      super.bind(baseTexture);
      baseTexture.target = TARGETS.TEXTURE_2D_ARRAY;
    }
    upload(renderer, texture, glTexture) {
      const { length, itemDirtyIds, items } = this;
      const { gl } = renderer;
      if (glTexture.dirtyId < 0) {
        gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, glTexture.internalFormat, this._width, this._height, length, 0, texture.format, glTexture.type, null);
      }
      for (let i = 0; i < length; i++) {
        const item2 = items[i];
        if (itemDirtyIds[i] < item2.dirtyId) {
          itemDirtyIds[i] = item2.dirtyId;
          if (item2.valid) {
            gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, i, item2.resource.width, item2.resource.height, 1, texture.format, glTexture.type, item2.resource.source);
          }
        }
      }
      return true;
    }
  };
  var BaseImageResource = class extends Resource {
    constructor(source) {
      const sourceAny = source;
      const width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.width;
      const height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.height;
      super(width, height);
      this.source = source;
      this.noSubImage = false;
    }
    static crossOrigin(element, url2, crossorigin) {
      if (crossorigin === void 0 && !url2.startsWith("data:")) {
        element.crossOrigin = determineCrossOrigin(url2);
      } else if (crossorigin !== false) {
        element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
      }
    }
    upload(renderer, baseTexture, glTexture, source) {
      const gl = renderer.gl;
      const width = baseTexture.realWidth;
      const height = baseTexture.realHeight;
      source = source || this.source;
      if (typeof HTMLImageElement !== "undefined" && source instanceof HTMLImageElement) {
        if (!source.complete || source.naturalWidth === 0) {
          return false;
        }
      } else if (typeof HTMLVideoElement !== "undefined" && source instanceof HTMLVideoElement) {
        if (source.readyState <= 1 && source.buffered.length === 0) {
          return false;
        }
      }
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
      if (!this.noSubImage && baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height) {
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, glTexture.type, source);
      } else {
        glTexture.width = width;
        glTexture.height = height;
        gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.format, glTexture.type, source);
      }
      return true;
    }
    update() {
      if (this.destroyed) {
        return;
      }
      const source = this.source;
      const width = source.naturalWidth || source.videoWidth || source.width;
      const height = source.naturalHeight || source.videoHeight || source.height;
      this.resize(width, height);
      super.update();
    }
    dispose() {
      this.source = null;
    }
  };
  var CanvasResource = class extends BaseImageResource {
    constructor(source) {
      super(source);
    }
    static test(source) {
      const { OffscreenCanvas: OffscreenCanvas2 } = globalThis;
      if (OffscreenCanvas2 && source instanceof OffscreenCanvas2) {
        return true;
      }
      return globalThis.HTMLCanvasElement && source instanceof HTMLCanvasElement;
    }
  };
  var _CubeResource = class extends AbstractMultiResource {
    constructor(source, options) {
      const { width, height, autoLoad, linkBaseTexture } = options || {};
      if (source && source.length !== _CubeResource.SIDES) {
        throw new Error(`Invalid length. Got ${source.length}, expected 6`);
      }
      super(6, { width, height });
      for (let i = 0; i < _CubeResource.SIDES; i++) {
        this.items[i].target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i;
      }
      this.linkBaseTexture = linkBaseTexture !== false;
      if (source) {
        this.initFromArray(source, options);
      }
      if (autoLoad !== false) {
        this.load();
      }
    }
    bind(baseTexture) {
      super.bind(baseTexture);
      baseTexture.target = TARGETS.TEXTURE_CUBE_MAP;
    }
    addBaseTextureAt(baseTexture, index2, linkBaseTexture) {
      if (linkBaseTexture === void 0) {
        linkBaseTexture = this.linkBaseTexture;
      }
      if (!this.items[index2]) {
        throw new Error(`Index ${index2} is out of bounds`);
      }
      if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0) {
        if (baseTexture.resource) {
          this.addResourceAt(baseTexture.resource, index2);
        } else {
          throw new Error(`CubeResource does not support copying of renderTexture.`);
        }
      } else {
        baseTexture.target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index2;
        baseTexture.parentTextureArray = this.baseTexture;
        this.items[index2] = baseTexture;
      }
      if (baseTexture.valid && !this.valid) {
        this.resize(baseTexture.realWidth, baseTexture.realHeight);
      }
      this.items[index2] = baseTexture;
      return this;
    }
    upload(renderer, _baseTexture, glTexture) {
      const dirty = this.itemDirtyIds;
      for (let i = 0; i < _CubeResource.SIDES; i++) {
        const side = this.items[i];
        if (dirty[i] < side.dirtyId || glTexture.dirtyId < _baseTexture.dirtyId) {
          if (side.valid && side.resource) {
            side.resource.upload(renderer, side, glTexture);
            dirty[i] = side.dirtyId;
          } else if (dirty[i] < -1) {
            renderer.gl.texImage2D(side.target, 0, glTexture.internalFormat, _baseTexture.realWidth, _baseTexture.realHeight, 0, _baseTexture.format, glTexture.type, null);
            dirty[i] = -1;
          }
        }
      }
      return true;
    }
    static test(source) {
      return Array.isArray(source) && source.length === _CubeResource.SIDES;
    }
  };
  var CubeResource = _CubeResource;
  CubeResource.SIDES = 6;
  var ImageResource = class extends BaseImageResource {
    constructor(source, options) {
      options = options || {};
      if (typeof source === "string") {
        const imageElement = new Image();
        BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);
        imageElement.src = source;
        source = imageElement;
      }
      super(source);
      if (!source.complete && !!this._width && !!this._height) {
        this._width = 0;
        this._height = 0;
      }
      this.url = source.src;
      this._process = null;
      this.preserveBitmap = false;
      this.createBitmap = (options.createBitmap ?? settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap;
      this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;
      this.bitmap = null;
      this._load = null;
      if (options.autoLoad !== false) {
        this.load();
      }
    }
    load(createBitmap) {
      if (this._load) {
        return this._load;
      }
      if (createBitmap !== void 0) {
        this.createBitmap = createBitmap;
      }
      this._load = new Promise((resolve2, reject) => {
        const source = this.source;
        this.url = source.src;
        const completed = () => {
          if (this.destroyed) {
            return;
          }
          source.onload = null;
          source.onerror = null;
          this.resize(source.width, source.height);
          this._load = null;
          if (this.createBitmap) {
            resolve2(this.process());
          } else {
            resolve2(this);
          }
        };
        if (source.complete && source.src) {
          completed();
        } else {
          source.onload = completed;
          source.onerror = (event) => {
            reject(event);
            this.onError.emit(event);
          };
        }
      });
      return this._load;
    }
    process() {
      const source = this.source;
      if (this._process !== null) {
        return this._process;
      }
      if (this.bitmap !== null || !globalThis.createImageBitmap) {
        return Promise.resolve(this);
      }
      const createImageBitmap2 = globalThis.createImageBitmap;
      const cors = !source.crossOrigin || source.crossOrigin === "anonymous";
      this._process = fetch(source.src, {
        mode: cors ? "cors" : "no-cors"
      }).then((r) => r.blob()).then((blob) => createImageBitmap2(blob, 0, 0, source.width, source.height, {
        premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK ? "premultiply" : "none"
      })).then((bitmap) => {
        if (this.destroyed) {
          return Promise.reject();
        }
        this.bitmap = bitmap;
        this.update();
        this._process = null;
        return Promise.resolve(this);
      });
      return this._process;
    }
    upload(renderer, baseTexture, glTexture) {
      if (typeof this.alphaMode === "number") {
        baseTexture.alphaMode = this.alphaMode;
      }
      if (!this.createBitmap) {
        return super.upload(renderer, baseTexture, glTexture);
      }
      if (!this.bitmap) {
        this.process();
        if (!this.bitmap) {
          return false;
        }
      }
      super.upload(renderer, baseTexture, glTexture, this.bitmap);
      if (!this.preserveBitmap) {
        let flag = true;
        const glTextures = baseTexture._glTextures;
        for (const key in glTextures) {
          const otherTex = glTextures[key];
          if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {
            flag = false;
            break;
          }
        }
        if (flag) {
          if (this.bitmap.close) {
            this.bitmap.close();
          }
          this.bitmap = null;
        }
      }
      return true;
    }
    dispose() {
      this.source.onload = null;
      this.source.onerror = null;
      super.dispose();
      if (this.bitmap) {
        this.bitmap.close();
        this.bitmap = null;
      }
      this._process = null;
      this._load = null;
    }
    static test(source) {
      return typeof HTMLImageElement !== "undefined" && (typeof source === "string" || source instanceof HTMLImageElement);
    }
  };
  var _SVGResource = class extends BaseImageResource {
    constructor(sourceBase64, options) {
      options = options || {};
      super(settings.ADAPTER.createCanvas());
      this._width = 0;
      this._height = 0;
      this.svg = sourceBase64;
      this.scale = options.scale || 1;
      this._overrideWidth = options.width;
      this._overrideHeight = options.height;
      this._resolve = null;
      this._crossorigin = options.crossorigin;
      this._load = null;
      if (options.autoLoad !== false) {
        this.load();
      }
    }
    load() {
      if (this._load) {
        return this._load;
      }
      this._load = new Promise((resolve2) => {
        this._resolve = () => {
          this.resize(this.source.width, this.source.height);
          resolve2(this);
        };
        if (_SVGResource.SVG_XML.test(this.svg.trim())) {
          if (!btoa) {
            throw new Error("Your browser doesn't support base64 conversions.");
          }
          this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`;
        }
        this._loadSvg();
      });
      return this._load;
    }
    _loadSvg() {
      const tempImage = new Image();
      BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin);
      tempImage.src = this.svg;
      tempImage.onerror = (event) => {
        if (!this._resolve) {
          return;
        }
        tempImage.onerror = null;
        this.onError.emit(event);
      };
      tempImage.onload = () => {
        if (!this._resolve) {
          return;
        }
        const svgWidth = tempImage.width;
        const svgHeight = tempImage.height;
        if (!svgWidth || !svgHeight) {
          throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
        }
        let width = svgWidth * this.scale;
        let height = svgHeight * this.scale;
        if (this._overrideWidth || this._overrideHeight) {
          width = this._overrideWidth || this._overrideHeight / svgHeight * svgWidth;
          height = this._overrideHeight || this._overrideWidth / svgWidth * svgHeight;
        }
        width = Math.round(width);
        height = Math.round(height);
        const canvas = this.source;
        canvas.width = width;
        canvas.height = height;
        canvas._pixiId = `canvas_${uid()}`;
        canvas.getContext("2d").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);
        this._resolve();
        this._resolve = null;
      };
    }
    static getSize(svgString) {
      const sizeMatch = _SVGResource.SVG_SIZE.exec(svgString);
      const size = {};
      if (sizeMatch) {
        size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
        size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
      }
      return size;
    }
    dispose() {
      super.dispose();
      this._resolve = null;
      this._crossorigin = null;
    }
    static test(source, extension) {
      return extension === "svg" || typeof source === "string" && source.startsWith("data:image/svg+xml") || typeof source === "string" && _SVGResource.SVG_XML.test(source);
    }
  };
  var SVGResource = _SVGResource;
  SVGResource.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m;
  SVGResource.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
  var _VideoResource = class extends BaseImageResource {
    constructor(source, options) {
      options = options || {};
      if (!(source instanceof HTMLVideoElement)) {
        const videoElement = document.createElement("video");
        videoElement.setAttribute("preload", "auto");
        videoElement.setAttribute("webkit-playsinline", "");
        videoElement.setAttribute("playsinline", "");
        if (typeof source === "string") {
          source = [source];
        }
        const firstSrc = source[0].src || source[0];
        BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);
        for (let i = 0; i < source.length; ++i) {
          const sourceElement = document.createElement("source");
          let { src, mime } = source[i];
          src = src || source[i];
          const baseSrc = src.split("?").shift().toLowerCase();
          const ext = baseSrc.slice(baseSrc.lastIndexOf(".") + 1);
          mime = mime || _VideoResource.MIME_TYPES[ext] || `video/${ext}`;
          sourceElement.src = src;
          sourceElement.type = mime;
          videoElement.appendChild(sourceElement);
        }
        source = videoElement;
      }
      super(source);
      this.noSubImage = true;
      this._autoUpdate = true;
      this._isConnectedToTicker = false;
      this._updateFPS = options.updateFPS || 0;
      this._msToNextUpdate = 0;
      this.autoPlay = options.autoPlay !== false;
      this._load = null;
      this._resolve = null;
      this._onCanPlay = this._onCanPlay.bind(this);
      this._onError = this._onError.bind(this);
      if (options.autoLoad !== false) {
        this.load();
      }
    }
    update(_deltaTime = 0) {
      if (!this.destroyed) {
        const elapsedMS = Ticker.shared.elapsedMS * this.source.playbackRate;
        this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
        if (!this._updateFPS || this._msToNextUpdate <= 0) {
          super.update();
          this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
        }
      }
    }
    load() {
      if (this._load) {
        return this._load;
      }
      const source = this.source;
      if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {
        source.complete = true;
      }
      source.addEventListener("play", this._onPlayStart.bind(this));
      source.addEventListener("pause", this._onPlayStop.bind(this));
      if (!this._isSourceReady()) {
        source.addEventListener("canplay", this._onCanPlay);
        source.addEventListener("canplaythrough", this._onCanPlay);
        source.addEventListener("error", this._onError, true);
      } else {
        this._onCanPlay();
      }
      this._load = new Promise((resolve2) => {
        if (this.valid) {
          resolve2(this);
        } else {
          this._resolve = resolve2;
          source.load();
        }
      });
      return this._load;
    }
    _onError(event) {
      this.source.removeEventListener("error", this._onError, true);
      this.onError.emit(event);
    }
    _isSourcePlaying() {
      const source = this.source;
      return !source.paused && !source.ended && this._isSourceReady();
    }
    _isSourceReady() {
      const source = this.source;
      return source.readyState > 2;
    }
    _onPlayStart() {
      if (!this.valid) {
        this._onCanPlay();
      }
      if (this.autoUpdate && !this._isConnectedToTicker) {
        Ticker.shared.add(this.update, this);
        this._isConnectedToTicker = true;
      }
    }
    _onPlayStop() {
      if (this._isConnectedToTicker) {
        Ticker.shared.remove(this.update, this);
        this._isConnectedToTicker = false;
      }
    }
    _onCanPlay() {
      const source = this.source;
      source.removeEventListener("canplay", this._onCanPlay);
      source.removeEventListener("canplaythrough", this._onCanPlay);
      const valid = this.valid;
      this.resize(source.videoWidth, source.videoHeight);
      if (!valid && this._resolve) {
        this._resolve(this);
        this._resolve = null;
      }
      if (this._isSourcePlaying()) {
        this._onPlayStart();
      } else if (this.autoPlay) {
        source.play();
      }
    }
    dispose() {
      if (this._isConnectedToTicker) {
        Ticker.shared.remove(this.update, this);
        this._isConnectedToTicker = false;
      }
      const source = this.source;
      if (source) {
        source.removeEventListener("error", this._onError, true);
        source.pause();
        source.src = "";
        source.load();
      }
      super.dispose();
    }
    get autoUpdate() {
      return this._autoUpdate;
    }
    set autoUpdate(value3) {
      if (value3 !== this._autoUpdate) {
        this._autoUpdate = value3;
        if (!this._autoUpdate && this._isConnectedToTicker) {
          Ticker.shared.remove(this.update, this);
          this._isConnectedToTicker = false;
        } else if (this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying()) {
          Ticker.shared.add(this.update, this);
          this._isConnectedToTicker = true;
        }
      }
    }
    get updateFPS() {
      return this._updateFPS;
    }
    set updateFPS(value3) {
      if (value3 !== this._updateFPS) {
        this._updateFPS = value3;
      }
    }
    static test(source, extension) {
      return globalThis.HTMLVideoElement && source instanceof HTMLVideoElement || _VideoResource.TYPES.includes(extension);
    }
  };
  var VideoResource = _VideoResource;
  VideoResource.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"];
  VideoResource.MIME_TYPES = {
    ogv: "video/ogg",
    mov: "video/quicktime",
    m4v: "video/mp4"
  };
  var ImageBitmapResource = class extends BaseImageResource {
    constructor(source, options) {
      var __super = (...args) => {
        super(...args);
      };
      options = options || {};
      if (typeof source === "string") {
        __super(ImageBitmapResource.EMPTY);
        this.url = source;
      } else {
        __super(source);
        this.url = null;
      }
      this.crossOrigin = options.crossOrigin ?? true;
      this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;
      this._load = null;
      if (options.autoLoad !== false) {
        this.load();
      }
    }
    load() {
      if (this._load) {
        return this._load;
      }
      this._load = new Promise(async (resolve2, reject) => {
        if (this.url === null) {
          resolve2(this);
          return;
        }
        try {
          const response = await settings.ADAPTER.fetch(this.url, {
            mode: this.crossOrigin ? "cors" : "no-cors"
          });
          if (this.destroyed)
            return;
          const imageBlob = await response.blob();
          if (this.destroyed)
            return;
          const imageBitmap = await createImageBitmap(imageBlob, {
            premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK ? "premultiply" : "none"
          });
          if (this.destroyed)
            return;
          this.source = imageBitmap;
          this.update();
          resolve2(this);
        } catch (e) {
          if (this.destroyed)
            return;
          reject(e);
          this.onError.emit(e);
        }
      });
      return this._load;
    }
    upload(renderer, baseTexture, glTexture) {
      if (!(this.source instanceof ImageBitmap)) {
        this.load();
        return false;
      }
      if (typeof this.alphaMode === "number") {
        baseTexture.alphaMode = this.alphaMode;
      }
      return super.upload(renderer, baseTexture, glTexture);
    }
    dispose() {
      if (this.source instanceof ImageBitmap) {
        this.source.close();
      }
      super.dispose();
      this._load = null;
    }
    static test(source) {
      return !!globalThis.createImageBitmap && typeof ImageBitmap !== "undefined" && (typeof source === "string" || source instanceof ImageBitmap);
    }
    static get EMPTY() {
      ImageBitmapResource._EMPTY = ImageBitmapResource._EMPTY ?? settings.ADAPTER.createCanvas(0, 0);
      return ImageBitmapResource._EMPTY;
    }
  };
  INSTALLED.push(ImageBitmapResource, ImageResource, CanvasResource, VideoResource, SVGResource, BufferResource, CubeResource, ArrayResource);
  var DepthResource = class extends BufferResource {
    upload(renderer, baseTexture, glTexture) {
      const gl = renderer.gl;
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
      const width = baseTexture.realWidth;
      const height = baseTexture.realHeight;
      if (glTexture.width === width && glTexture.height === height) {
        gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
      } else {
        glTexture.width = width;
        glTexture.height = height;
        gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
      }
      return true;
    }
  };
  var Framebuffer = class {
    constructor(width, height) {
      this.width = Math.round(width || 100);
      this.height = Math.round(height || 100);
      this.stencil = false;
      this.depth = false;
      this.dirtyId = 0;
      this.dirtyFormat = 0;
      this.dirtySize = 0;
      this.depthTexture = null;
      this.colorTextures = [];
      this.glFramebuffers = {};
      this.disposeRunner = new Runner("disposeFramebuffer");
      this.multisample = MSAA_QUALITY.NONE;
    }
    get colorTexture() {
      return this.colorTextures[0];
    }
    addColorTexture(index2 = 0, texture) {
      this.colorTextures[index2] = texture || new BaseTexture(null, {
        scaleMode: SCALE_MODES.NEAREST,
        resolution: 1,
        mipmap: MIPMAP_MODES.OFF,
        width: this.width,
        height: this.height
      });
      this.dirtyId++;
      this.dirtyFormat++;
      return this;
    }
    addDepthTexture(texture) {
      this.depthTexture = texture || new BaseTexture(new DepthResource(null, { width: this.width, height: this.height }), {
        scaleMode: SCALE_MODES.NEAREST,
        resolution: 1,
        width: this.width,
        height: this.height,
        mipmap: MIPMAP_MODES.OFF,
        format: FORMATS.DEPTH_COMPONENT,
        type: TYPES.UNSIGNED_SHORT
      });
      this.dirtyId++;
      this.dirtyFormat++;
      return this;
    }
    enableDepth() {
      this.depth = true;
      this.dirtyId++;
      this.dirtyFormat++;
      return this;
    }
    enableStencil() {
      this.stencil = true;
      this.dirtyId++;
      this.dirtyFormat++;
      return this;
    }
    resize(width, height) {
      width = Math.round(width);
      height = Math.round(height);
      if (width === this.width && height === this.height)
        return;
      this.width = width;
      this.height = height;
      this.dirtyId++;
      this.dirtySize++;
      for (let i = 0; i < this.colorTextures.length; i++) {
        const texture = this.colorTextures[i];
        const resolution = texture.resolution;
        texture.setSize(width / resolution, height / resolution);
      }
      if (this.depthTexture) {
        const resolution = this.depthTexture.resolution;
        this.depthTexture.setSize(width / resolution, height / resolution);
      }
    }
    dispose() {
      this.disposeRunner.emit(this, false);
    }
    destroyDepthTexture() {
      if (this.depthTexture) {
        this.depthTexture.destroy();
        this.depthTexture = null;
        ++this.dirtyId;
        ++this.dirtyFormat;
      }
    }
  };
  var BaseRenderTexture = class extends BaseTexture {
    constructor(options = {}) {
      if (typeof options === "number") {
        const width = arguments[0];
        const height = arguments[1];
        const scaleMode = arguments[2];
        const resolution = arguments[3];
        options = { width, height, scaleMode, resolution };
      }
      options.width = options.width || 100;
      options.height = options.height || 100;
      options.multisample ?? (options.multisample = MSAA_QUALITY.NONE);
      super(null, options);
      this.mipmap = MIPMAP_MODES.OFF;
      this.valid = true;
      this.clearColor = [0, 0, 0, 0];
      this.framebuffer = new Framebuffer(this.realWidth, this.realHeight).addColorTexture(0, this);
      this.framebuffer.multisample = options.multisample;
      this.maskStack = [];
      this.filterStack = [{}];
    }
    resize(desiredWidth, desiredHeight) {
      this.framebuffer.resize(desiredWidth * this.resolution, desiredHeight * this.resolution);
      this.setRealSize(this.framebuffer.width, this.framebuffer.height);
    }
    dispose() {
      this.framebuffer.dispose();
      super.dispose();
    }
    destroy() {
      super.destroy();
      this.framebuffer.destroyDepthTexture();
      this.framebuffer = null;
    }
  };
  var TextureUvs = class {
    constructor() {
      this.x0 = 0;
      this.y0 = 0;
      this.x1 = 1;
      this.y1 = 0;
      this.x2 = 1;
      this.y2 = 1;
      this.x3 = 0;
      this.y3 = 1;
      this.uvsFloat32 = new Float32Array(8);
    }
    set(frame, baseFrame, rotate) {
      const tw = baseFrame.width;
      const th = baseFrame.height;
      if (rotate) {
        const w2 = frame.width / 2 / tw;
        const h2 = frame.height / 2 / th;
        const cX = frame.x / tw + w2;
        const cY = frame.y / th + h2;
        rotate = groupD8.add(rotate, groupD8.NW);
        this.x0 = cX + w2 * groupD8.uX(rotate);
        this.y0 = cY + h2 * groupD8.uY(rotate);
        rotate = groupD8.add(rotate, 2);
        this.x1 = cX + w2 * groupD8.uX(rotate);
        this.y1 = cY + h2 * groupD8.uY(rotate);
        rotate = groupD8.add(rotate, 2);
        this.x2 = cX + w2 * groupD8.uX(rotate);
        this.y2 = cY + h2 * groupD8.uY(rotate);
        rotate = groupD8.add(rotate, 2);
        this.x3 = cX + w2 * groupD8.uX(rotate);
        this.y3 = cY + h2 * groupD8.uY(rotate);
      } else {
        this.x0 = frame.x / tw;
        this.y0 = frame.y / th;
        this.x1 = (frame.x + frame.width) / tw;
        this.y1 = frame.y / th;
        this.x2 = (frame.x + frame.width) / tw;
        this.y2 = (frame.y + frame.height) / th;
        this.x3 = frame.x / tw;
        this.y3 = (frame.y + frame.height) / th;
      }
      this.uvsFloat32[0] = this.x0;
      this.uvsFloat32[1] = this.y0;
      this.uvsFloat32[2] = this.x1;
      this.uvsFloat32[3] = this.y1;
      this.uvsFloat32[4] = this.x2;
      this.uvsFloat32[5] = this.y2;
      this.uvsFloat32[6] = this.x3;
      this.uvsFloat32[7] = this.y3;
    }
    toString() {
      return `[@pixi/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`;
    }
  };
  var DEFAULT_UVS = new TextureUvs();
  function removeAllHandlers(tex) {
    tex.destroy = function _emptyDestroy() {
    };
    tex.on = function _emptyOn() {
    };
    tex.once = function _emptyOnce() {
    };
    tex.emit = function _emptyEmit() {
    };
  }
  var Texture = class extends eventemitter3 {
    constructor(baseTexture, frame, orig, trim, rotate, anchor) {
      super();
      this.noFrame = false;
      if (!frame) {
        this.noFrame = true;
        frame = new Rectangle(0, 0, 1, 1);
      }
      if (baseTexture instanceof Texture) {
        baseTexture = baseTexture.baseTexture;
      }
      this.baseTexture = baseTexture;
      this._frame = frame;
      this.trim = trim;
      this.valid = false;
      this._uvs = DEFAULT_UVS;
      this.uvMatrix = null;
      this.orig = orig || frame;
      this._rotate = Number(rotate || 0);
      if (rotate === true) {
        this._rotate = 2;
      } else if (this._rotate % 2 !== 0) {
        throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
      }
      this.defaultAnchor = anchor ? new Point(anchor.x, anchor.y) : new Point(0, 0);
      this._updateID = 0;
      this.textureCacheIds = [];
      if (!baseTexture.valid) {
        baseTexture.once("loaded", this.onBaseTextureUpdated, this);
      } else if (this.noFrame) {
        if (baseTexture.valid) {
          this.onBaseTextureUpdated(baseTexture);
        }
      } else {
        this.frame = frame;
      }
      if (this.noFrame) {
        baseTexture.on("update", this.onBaseTextureUpdated, this);
      }
    }
    update() {
      if (this.baseTexture.resource) {
        this.baseTexture.resource.update();
      }
    }
    onBaseTextureUpdated(baseTexture) {
      if (this.noFrame) {
        if (!this.baseTexture.valid) {
          return;
        }
        this._frame.width = baseTexture.width;
        this._frame.height = baseTexture.height;
        this.valid = true;
        this.updateUvs();
      } else {
        this.frame = this._frame;
      }
      this.emit("update", this);
    }
    destroy(destroyBase) {
      if (this.baseTexture) {
        if (destroyBase) {
          const { resource } = this.baseTexture;
          if (resource?.url && TextureCache[resource.url]) {
            Texture.removeFromCache(resource.url);
          }
          this.baseTexture.destroy();
        }
        this.baseTexture.off("loaded", this.onBaseTextureUpdated, this);
        this.baseTexture.off("update", this.onBaseTextureUpdated, this);
        this.baseTexture = null;
      }
      this._frame = null;
      this._uvs = null;
      this.trim = null;
      this.orig = null;
      this.valid = false;
      Texture.removeFromCache(this);
      this.textureCacheIds = null;
    }
    clone() {
      const clonedFrame = this._frame.clone();
      const clonedOrig = this._frame === this.orig ? clonedFrame : this.orig.clone();
      const clonedTexture = new Texture(this.baseTexture, !this.noFrame && clonedFrame, clonedOrig, this.trim?.clone(), this.rotate, this.defaultAnchor);
      if (this.noFrame) {
        clonedTexture._frame = clonedFrame;
      }
      return clonedTexture;
    }
    updateUvs() {
      if (this._uvs === DEFAULT_UVS) {
        this._uvs = new TextureUvs();
      }
      this._uvs.set(this._frame, this.baseTexture, this.rotate);
      this._updateID++;
    }
    static from(source, options = {}, strict = settings.STRICT_TEXTURE_CACHE) {
      const isFrame = typeof source === "string";
      let cacheId = null;
      if (isFrame) {
        cacheId = source;
      } else if (source instanceof BaseTexture) {
        if (!source.cacheId) {
          const prefix = options?.pixiIdPrefix || "pixiid";
          source.cacheId = `${prefix}-${uid()}`;
          BaseTexture.addToCache(source, source.cacheId);
        }
        cacheId = source.cacheId;
      } else {
        if (!source._pixiId) {
          const prefix = options?.pixiIdPrefix || "pixiid";
          source._pixiId = `${prefix}_${uid()}`;
        }
        cacheId = source._pixiId;
      }
      let texture = TextureCache[cacheId];
      if (isFrame && strict && !texture) {
        throw new Error(`The cacheId "${cacheId}" does not exist in TextureCache.`);
      }
      if (!texture && !(source instanceof BaseTexture)) {
        if (!options.resolution) {
          options.resolution = getResolutionOfUrl(source);
        }
        texture = new Texture(new BaseTexture(source, options));
        texture.baseTexture.cacheId = cacheId;
        BaseTexture.addToCache(texture.baseTexture, cacheId);
        Texture.addToCache(texture, cacheId);
      } else if (!texture && source instanceof BaseTexture) {
        texture = new Texture(source);
        Texture.addToCache(texture, cacheId);
      }
      return texture;
    }
    static fromURL(url2, options) {
      const resourceOptions = Object.assign({ autoLoad: false }, options?.resourceOptions);
      const texture = Texture.from(url2, Object.assign({ resourceOptions }, options), false);
      const resource = texture.baseTexture.resource;
      if (texture.baseTexture.valid) {
        return Promise.resolve(texture);
      }
      return resource.load().then(() => Promise.resolve(texture));
    }
    static fromBuffer(buffer, width, height, options) {
      return new Texture(BaseTexture.fromBuffer(buffer, width, height, options));
    }
    static fromLoader(source, imageUrl, name, options) {
      const baseTexture = new BaseTexture(source, Object.assign({
        scaleMode: settings.SCALE_MODE,
        resolution: getResolutionOfUrl(imageUrl)
      }, options));
      const { resource } = baseTexture;
      if (resource instanceof ImageResource) {
        resource.url = imageUrl;
      }
      const texture = new Texture(baseTexture);
      if (!name) {
        name = imageUrl;
      }
      BaseTexture.addToCache(texture.baseTexture, name);
      Texture.addToCache(texture, name);
      if (name !== imageUrl) {
        BaseTexture.addToCache(texture.baseTexture, imageUrl);
        Texture.addToCache(texture, imageUrl);
      }
      if (texture.baseTexture.valid) {
        return Promise.resolve(texture);
      }
      return new Promise((resolve2) => {
        texture.baseTexture.once("loaded", () => resolve2(texture));
      });
    }
    static addToCache(texture, id) {
      if (id) {
        if (!texture.textureCacheIds.includes(id)) {
          texture.textureCacheIds.push(id);
        }
        if (TextureCache[id] && TextureCache[id] !== texture) {
          console.warn(`Texture added to the cache with an id [${id}] that already had an entry`);
        }
        TextureCache[id] = texture;
      }
    }
    static removeFromCache(texture) {
      if (typeof texture === "string") {
        const textureFromCache = TextureCache[texture];
        if (textureFromCache) {
          const index2 = textureFromCache.textureCacheIds.indexOf(texture);
          if (index2 > -1) {
            textureFromCache.textureCacheIds.splice(index2, 1);
          }
          delete TextureCache[texture];
          return textureFromCache;
        }
      } else if (texture?.textureCacheIds) {
        for (let i = 0; i < texture.textureCacheIds.length; ++i) {
          if (TextureCache[texture.textureCacheIds[i]] === texture) {
            delete TextureCache[texture.textureCacheIds[i]];
          }
        }
        texture.textureCacheIds.length = 0;
        return texture;
      }
      return null;
    }
    get resolution() {
      return this.baseTexture.resolution;
    }
    get frame() {
      return this._frame;
    }
    set frame(frame) {
      this._frame = frame;
      this.noFrame = false;
      const { x, y, width, height } = frame;
      const xNotFit = x + width > this.baseTexture.width;
      const yNotFit = y + height > this.baseTexture.height;
      if (xNotFit || yNotFit) {
        const relationship = xNotFit && yNotFit ? "and" : "or";
        const errorX = `X: ${x} + ${width} = ${x + width} > ${this.baseTexture.width}`;
        const errorY = `Y: ${y} + ${height} = ${y + height} > ${this.baseTexture.height}`;
        throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${errorX} ${relationship} ${errorY}`);
      }
      this.valid = width && height && this.baseTexture.valid;
      if (!this.trim && !this.rotate) {
        this.orig = frame;
      }
      if (this.valid) {
        this.updateUvs();
      }
    }
    get rotate() {
      return this._rotate;
    }
    set rotate(rotate) {
      this._rotate = rotate;
      if (this.valid) {
        this.updateUvs();
      }
    }
    get width() {
      return this.orig.width;
    }
    get height() {
      return this.orig.height;
    }
    castToBaseTexture() {
      return this.baseTexture;
    }
    static get EMPTY() {
      if (!Texture._EMPTY) {
        Texture._EMPTY = new Texture(new BaseTexture());
        removeAllHandlers(Texture._EMPTY);
        removeAllHandlers(Texture._EMPTY.baseTexture);
      }
      return Texture._EMPTY;
    }
    static get WHITE() {
      if (!Texture._WHITE) {
        const canvas = settings.ADAPTER.createCanvas(16, 16);
        const context2 = canvas.getContext("2d");
        canvas.width = 16;
        canvas.height = 16;
        context2.fillStyle = "white";
        context2.fillRect(0, 0, 16, 16);
        Texture._WHITE = new Texture(BaseTexture.from(canvas));
        removeAllHandlers(Texture._WHITE);
        removeAllHandlers(Texture._WHITE.baseTexture);
      }
      return Texture._WHITE;
    }
  };
  var RenderTexture = class extends Texture {
    constructor(baseRenderTexture, frame) {
      super(baseRenderTexture, frame);
      this.valid = true;
      this.filterFrame = null;
      this.filterPoolKey = null;
      this.updateUvs();
    }
    get framebuffer() {
      return this.baseTexture.framebuffer;
    }
    get multisample() {
      return this.framebuffer.multisample;
    }
    set multisample(value3) {
      this.framebuffer.multisample = value3;
    }
    resize(desiredWidth, desiredHeight, resizeBaseTexture = true) {
      const resolution = this.baseTexture.resolution;
      const width = Math.round(desiredWidth * resolution) / resolution;
      const height = Math.round(desiredHeight * resolution) / resolution;
      this.valid = width > 0 && height > 0;
      this._frame.width = this.orig.width = width;
      this._frame.height = this.orig.height = height;
      if (resizeBaseTexture) {
        this.baseTexture.resize(width, height);
      }
      this.updateUvs();
    }
    setResolution(resolution) {
      const { baseTexture } = this;
      if (baseTexture.resolution === resolution) {
        return;
      }
      baseTexture.setResolution(resolution);
      this.resize(baseTexture.width, baseTexture.height, false);
    }
    static create(options) {
      return new RenderTexture(new BaseRenderTexture(options));
    }
  };
  var RenderTexturePool = class {
    constructor(textureOptions) {
      this.texturePool = {};
      this.textureOptions = textureOptions || {};
      this.enableFullScreen = false;
      this._pixelsWidth = 0;
      this._pixelsHeight = 0;
    }
    createTexture(realWidth, realHeight, multisample = MSAA_QUALITY.NONE) {
      const baseRenderTexture = new BaseRenderTexture(Object.assign({
        width: realWidth,
        height: realHeight,
        resolution: 1,
        multisample
      }, this.textureOptions));
      return new RenderTexture(baseRenderTexture);
    }
    getOptimalTexture(minWidth, minHeight, resolution = 1, multisample = MSAA_QUALITY.NONE) {
      let key;
      minWidth = Math.ceil(minWidth * resolution - 1e-6);
      minHeight = Math.ceil(minHeight * resolution - 1e-6);
      if (!this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight) {
        minWidth = nextPow2(minWidth);
        minHeight = nextPow2(minHeight);
        key = ((minWidth & 65535) << 16 | minHeight & 65535) >>> 0;
        if (multisample > 1) {
          key += multisample * 4294967296;
        }
      } else {
        key = multisample > 1 ? -multisample : -1;
      }
      if (!this.texturePool[key]) {
        this.texturePool[key] = [];
      }
      let renderTexture = this.texturePool[key].pop();
      if (!renderTexture) {
        renderTexture = this.createTexture(minWidth, minHeight, multisample);
      }
      renderTexture.filterPoolKey = key;
      renderTexture.setResolution(resolution);
      return renderTexture;
    }
    getFilterTexture(input, resolution, multisample) {
      const filterTexture = this.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY.NONE);
      filterTexture.filterFrame = input.filterFrame;
      return filterTexture;
    }
    returnTexture(renderTexture) {
      const key = renderTexture.filterPoolKey;
      renderTexture.filterFrame = null;
      this.texturePool[key].push(renderTexture);
    }
    returnFilterTexture(renderTexture) {
      this.returnTexture(renderTexture);
    }
    clear(destroyTextures) {
      destroyTextures = destroyTextures !== false;
      if (destroyTextures) {
        for (const i in this.texturePool) {
          const textures = this.texturePool[i];
          if (textures) {
            for (let j = 0; j < textures.length; j++) {
              textures[j].destroy(true);
            }
          }
        }
      }
      this.texturePool = {};
    }
    setScreenSize(size) {
      if (size.width === this._pixelsWidth && size.height === this._pixelsHeight) {
        return;
      }
      this.enableFullScreen = size.width > 0 && size.height > 0;
      for (const i in this.texturePool) {
        if (!(Number(i) < 0)) {
          continue;
        }
        const textures = this.texturePool[i];
        if (textures) {
          for (let j = 0; j < textures.length; j++) {
            textures[j].destroy(true);
          }
        }
        this.texturePool[i] = [];
      }
      this._pixelsWidth = size.width;
      this._pixelsHeight = size.height;
    }
  };
  RenderTexturePool.SCREEN_KEY = -1;
  var Attribute = class {
    constructor(buffer, size = 0, normalized = false, type = TYPES.FLOAT, stride, start, instance) {
      this.buffer = buffer;
      this.size = size;
      this.normalized = normalized;
      this.type = type;
      this.stride = stride;
      this.start = start;
      this.instance = instance;
    }
    destroy() {
      this.buffer = null;
    }
    static from(buffer, size, normalized, type, stride) {
      return new Attribute(buffer, size, normalized, type, stride);
    }
  };
  var UID$4 = 0;
  var Buffer2 = class {
    constructor(data, _static = true, index2 = false) {
      this.data = data || new Float32Array(1);
      this._glBuffers = {};
      this._updateID = 0;
      this.index = index2;
      this.static = _static;
      this.id = UID$4++;
      this.disposeRunner = new Runner("disposeBuffer");
    }
    update(data) {
      if (data instanceof Array) {
        data = new Float32Array(data);
      }
      this.data = data || this.data;
      this._updateID++;
    }
    dispose() {
      this.disposeRunner.emit(this, false);
    }
    destroy() {
      this.dispose();
      this.data = null;
    }
    set index(value3) {
      this.type = value3 ? BUFFER_TYPE.ELEMENT_ARRAY_BUFFER : BUFFER_TYPE.ARRAY_BUFFER;
    }
    get index() {
      return this.type === BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
    }
    static from(data) {
      if (data instanceof Array) {
        data = new Float32Array(data);
      }
      return new Buffer2(data);
    }
  };
  var map$1 = {
    Float32Array,
    Uint32Array,
    Int32Array,
    Uint8Array
  };
  function interleaveTypedArrays(arrays, sizes) {
    let outSize = 0;
    let stride = 0;
    const views = {};
    for (let i = 0; i < arrays.length; i++) {
      stride += sizes[i];
      outSize += arrays[i].length;
    }
    const buffer = new ArrayBuffer(outSize * 4);
    let out = null;
    let littleOffset = 0;
    for (let i = 0; i < arrays.length; i++) {
      const size = sizes[i];
      const array = arrays[i];
      const type = getBufferType(array);
      if (!views[type]) {
        views[type] = new map$1[type](buffer);
      }
      out = views[type];
      for (let j = 0; j < array.length; j++) {
        const indexStart = (j / size | 0) * stride + littleOffset;
        const index2 = j % size;
        out[indexStart + index2] = array[j];
      }
      littleOffset += size;
    }
    return new Float32Array(buffer);
  }
  var byteSizeMap$1 = { 5126: 4, 5123: 2, 5121: 1 };
  var UID$3 = 0;
  var map = {
    Float32Array,
    Uint32Array,
    Int32Array,
    Uint8Array,
    Uint16Array
  };
  var Geometry = class {
    constructor(buffers = [], attributes = {}) {
      this.buffers = buffers;
      this.indexBuffer = null;
      this.attributes = attributes;
      this.glVertexArrayObjects = {};
      this.id = UID$3++;
      this.instanced = false;
      this.instanceCount = 1;
      this.disposeRunner = new Runner("disposeGeometry");
      this.refCount = 0;
    }
    addAttribute(id, buffer, size = 0, normalized = false, type, stride, start, instance = false) {
      if (!buffer) {
        throw new Error("You must pass a buffer when creating an attribute");
      }
      if (!(buffer instanceof Buffer2)) {
        if (buffer instanceof Array) {
          buffer = new Float32Array(buffer);
        }
        buffer = new Buffer2(buffer);
      }
      const ids = id.split("|");
      if (ids.length > 1) {
        for (let i = 0; i < ids.length; i++) {
          this.addAttribute(ids[i], buffer, size, normalized, type);
        }
        return this;
      }
      let bufferIndex = this.buffers.indexOf(buffer);
      if (bufferIndex === -1) {
        this.buffers.push(buffer);
        bufferIndex = this.buffers.length - 1;
      }
      this.attributes[id] = new Attribute(bufferIndex, size, normalized, type, stride, start, instance);
      this.instanced = this.instanced || instance;
      return this;
    }
    getAttribute(id) {
      return this.attributes[id];
    }
    getBuffer(id) {
      return this.buffers[this.getAttribute(id).buffer];
    }
    addIndex(buffer) {
      if (!(buffer instanceof Buffer2)) {
        if (buffer instanceof Array) {
          buffer = new Uint16Array(buffer);
        }
        buffer = new Buffer2(buffer);
      }
      buffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
      this.indexBuffer = buffer;
      if (!this.buffers.includes(buffer)) {
        this.buffers.push(buffer);
      }
      return this;
    }
    getIndex() {
      return this.indexBuffer;
    }
    interleave() {
      if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)
        return this;
      const arrays = [];
      const sizes = [];
      const interleavedBuffer = new Buffer2();
      let i;
      for (i in this.attributes) {
        const attribute = this.attributes[i];
        const buffer = this.buffers[attribute.buffer];
        arrays.push(buffer.data);
        sizes.push(attribute.size * byteSizeMap$1[attribute.type] / 4);
        attribute.buffer = 0;
      }
      interleavedBuffer.data = interleaveTypedArrays(arrays, sizes);
      for (i = 0; i < this.buffers.length; i++) {
        if (this.buffers[i] !== this.indexBuffer) {
          this.buffers[i].destroy();
        }
      }
      this.buffers = [interleavedBuffer];
      if (this.indexBuffer) {
        this.buffers.push(this.indexBuffer);
      }
      return this;
    }
    getSize() {
      for (const i in this.attributes) {
        const attribute = this.attributes[i];
        const buffer = this.buffers[attribute.buffer];
        return buffer.data.length / (attribute.stride / 4 || attribute.size);
      }
      return 0;
    }
    dispose() {
      this.disposeRunner.emit(this, false);
    }
    destroy() {
      this.dispose();
      this.buffers = null;
      this.indexBuffer = null;
      this.attributes = null;
    }
    clone() {
      const geometry = new Geometry();
      for (let i = 0; i < this.buffers.length; i++) {
        geometry.buffers[i] = new Buffer2(this.buffers[i].data.slice(0));
      }
      for (const i in this.attributes) {
        const attrib = this.attributes[i];
        geometry.attributes[i] = new Attribute(attrib.buffer, attrib.size, attrib.normalized, attrib.type, attrib.stride, attrib.start, attrib.instance);
      }
      if (this.indexBuffer) {
        geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];
        geometry.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
      }
      return geometry;
    }
    static merge(geometries) {
      const geometryOut = new Geometry();
      const arrays = [];
      const sizes = [];
      const offsets = [];
      let geometry;
      for (let i = 0; i < geometries.length; i++) {
        geometry = geometries[i];
        for (let j = 0; j < geometry.buffers.length; j++) {
          sizes[j] = sizes[j] || 0;
          sizes[j] += geometry.buffers[j].data.length;
          offsets[j] = 0;
        }
      }
      for (let i = 0; i < geometry.buffers.length; i++) {
        arrays[i] = new map[getBufferType(geometry.buffers[i].data)](sizes[i]);
        geometryOut.buffers[i] = new Buffer2(arrays[i]);
      }
      for (let i = 0; i < geometries.length; i++) {
        geometry = geometries[i];
        for (let j = 0; j < geometry.buffers.length; j++) {
          arrays[j].set(geometry.buffers[j].data, offsets[j]);
          offsets[j] += geometry.buffers[j].data.length;
        }
      }
      geometryOut.attributes = geometry.attributes;
      if (geometry.indexBuffer) {
        geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];
        geometryOut.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
        let offset = 0;
        let stride = 0;
        let offset2 = 0;
        let bufferIndexToCount = 0;
        for (let i = 0; i < geometry.buffers.length; i++) {
          if (geometry.buffers[i] !== geometry.indexBuffer) {
            bufferIndexToCount = i;
            break;
          }
        }
        for (const i in geometry.attributes) {
          const attribute = geometry.attributes[i];
          if ((attribute.buffer | 0) === bufferIndexToCount) {
            stride += attribute.size * byteSizeMap$1[attribute.type] / 4;
          }
        }
        for (let i = 0; i < geometries.length; i++) {
          const indexBufferData = geometries[i].indexBuffer.data;
          for (let j = 0; j < indexBufferData.length; j++) {
            geometryOut.indexBuffer.data[j + offset2] += offset;
          }
          offset += geometries[i].buffers[bufferIndexToCount].data.length / stride;
          offset2 += indexBufferData.length;
        }
      }
      return geometryOut;
    }
  };
  var Quad = class extends Geometry {
    constructor() {
      super();
      this.addAttribute("aVertexPosition", new Float32Array([
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        1
      ])).addIndex([0, 1, 3, 2]);
    }
  };
  var QuadUv = class extends Geometry {
    constructor() {
      super();
      this.vertices = new Float32Array([
        -1,
        -1,
        1,
        -1,
        1,
        1,
        -1,
        1
      ]);
      this.uvs = new Float32Array([
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        1
      ]);
      this.vertexBuffer = new Buffer2(this.vertices);
      this.uvBuffer = new Buffer2(this.uvs);
      this.addAttribute("aVertexPosition", this.vertexBuffer).addAttribute("aTextureCoord", this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);
    }
    map(targetTextureFrame, destinationFrame) {
      let x = 0;
      let y = 0;
      this.uvs[0] = x;
      this.uvs[1] = y;
      this.uvs[2] = x + destinationFrame.width / targetTextureFrame.width;
      this.uvs[3] = y;
      this.uvs[4] = x + destinationFrame.width / targetTextureFrame.width;
      this.uvs[5] = y + destinationFrame.height / targetTextureFrame.height;
      this.uvs[6] = x;
      this.uvs[7] = y + destinationFrame.height / targetTextureFrame.height;
      x = destinationFrame.x;
      y = destinationFrame.y;
      this.vertices[0] = x;
      this.vertices[1] = y;
      this.vertices[2] = x + destinationFrame.width;
      this.vertices[3] = y;
      this.vertices[4] = x + destinationFrame.width;
      this.vertices[5] = y + destinationFrame.height;
      this.vertices[6] = x;
      this.vertices[7] = y + destinationFrame.height;
      this.invalidate();
      return this;
    }
    invalidate() {
      this.vertexBuffer._updateID++;
      this.uvBuffer._updateID++;
      return this;
    }
  };
  var UID$2 = 0;
  var UniformGroup = class {
    constructor(uniforms, isStatic, isUbo) {
      this.group = true;
      this.syncUniforms = {};
      this.dirtyId = 0;
      this.id = UID$2++;
      this.static = !!isStatic;
      this.ubo = !!isUbo;
      if (uniforms instanceof Buffer2) {
        this.buffer = uniforms;
        this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER;
        this.autoManage = false;
        this.ubo = true;
      } else {
        this.uniforms = uniforms;
        if (this.ubo) {
          this.buffer = new Buffer2(new Float32Array(1));
          this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER;
          this.autoManage = true;
        }
      }
    }
    update() {
      this.dirtyId++;
      if (!this.autoManage && this.buffer) {
        this.buffer.update();
      }
    }
    add(name, uniforms, _static) {
      if (!this.ubo) {
        this.uniforms[name] = new UniformGroup(uniforms, _static);
      } else {
        throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
      }
    }
    static from(uniforms, _static, _ubo) {
      return new UniformGroup(uniforms, _static, _ubo);
    }
    static uboFrom(uniforms, _static) {
      return new UniformGroup(uniforms, _static ?? true, true);
    }
  };
  var FilterState = class {
    constructor() {
      this.renderTexture = null;
      this.target = null;
      this.legacy = false;
      this.resolution = 1;
      this.multisample = MSAA_QUALITY.NONE;
      this.sourceFrame = new Rectangle();
      this.destinationFrame = new Rectangle();
      this.bindingSourceFrame = new Rectangle();
      this.bindingDestinationFrame = new Rectangle();
      this.filters = [];
      this.transform = null;
    }
    clear() {
      this.target = null;
      this.filters = null;
      this.renderTexture = null;
    }
  };
  var tempPoints = [new Point(), new Point(), new Point(), new Point()];
  var tempMatrix$2 = new Matrix();
  var FilterSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
      this.defaultFilterStack = [{}];
      this.texturePool = new RenderTexturePool();
      this.statePool = [];
      this.quad = new Quad();
      this.quadUv = new QuadUv();
      this.tempRect = new Rectangle();
      this.activeState = {};
      this.globalUniforms = new UniformGroup({
        outputFrame: new Rectangle(),
        inputSize: new Float32Array(4),
        inputPixel: new Float32Array(4),
        inputClamp: new Float32Array(4),
        resolution: 1,
        filterArea: new Float32Array(4),
        filterClamp: new Float32Array(4)
      }, true);
      this.forceClear = false;
      this.useMaxPadding = false;
    }
    init() {
      this.texturePool.setScreenSize(this.renderer.view);
    }
    push(target2, filters2) {
      const renderer = this.renderer;
      const filterStack = this.defaultFilterStack;
      const state = this.statePool.pop() || new FilterState();
      const renderTextureSystem = this.renderer.renderTexture;
      let resolution = filters2[0].resolution;
      let multisample = filters2[0].multisample;
      let padding = filters2[0].padding;
      let autoFit = filters2[0].autoFit;
      let legacy = filters2[0].legacy ?? true;
      for (let i = 1; i < filters2.length; i++) {
        const filter = filters2[i];
        resolution = Math.min(resolution, filter.resolution);
        multisample = Math.min(multisample, filter.multisample);
        padding = this.useMaxPadding ? Math.max(padding, filter.padding) : padding + filter.padding;
        autoFit = autoFit && filter.autoFit;
        legacy = legacy || (filter.legacy ?? true);
      }
      if (filterStack.length === 1) {
        this.defaultFilterStack[0].renderTexture = renderTextureSystem.current;
      }
      filterStack.push(state);
      state.resolution = resolution;
      state.multisample = multisample;
      state.legacy = legacy;
      state.target = target2;
      state.sourceFrame.copyFrom(target2.filterArea || target2.getBounds(true));
      state.sourceFrame.pad(padding);
      const sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);
      if (renderer.projection.transform) {
        this.transformAABB(tempMatrix$2.copyFrom(renderer.projection.transform).invert(), sourceFrameProjected);
      }
      if (autoFit) {
        state.sourceFrame.fit(sourceFrameProjected);
        if (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0) {
          state.sourceFrame.width = 0;
          state.sourceFrame.height = 0;
        }
      } else if (!state.sourceFrame.intersects(sourceFrameProjected)) {
        state.sourceFrame.width = 0;
        state.sourceFrame.height = 0;
      }
      this.roundFrame(state.sourceFrame, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);
      state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution, multisample);
      state.filters = filters2;
      state.destinationFrame.width = state.renderTexture.width;
      state.destinationFrame.height = state.renderTexture.height;
      const destinationFrame = this.tempRect;
      destinationFrame.x = 0;
      destinationFrame.y = 0;
      destinationFrame.width = state.sourceFrame.width;
      destinationFrame.height = state.sourceFrame.height;
      state.renderTexture.filterFrame = state.sourceFrame;
      state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);
      state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);
      state.transform = renderer.projection.transform;
      renderer.projection.transform = null;
      renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame);
      renderer.framebuffer.clear(0, 0, 0, 0);
    }
    pop() {
      const filterStack = this.defaultFilterStack;
      const state = filterStack.pop();
      const filters2 = state.filters;
      this.activeState = state;
      const globalUniforms = this.globalUniforms.uniforms;
      globalUniforms.outputFrame = state.sourceFrame;
      globalUniforms.resolution = state.resolution;
      const inputSize = globalUniforms.inputSize;
      const inputPixel = globalUniforms.inputPixel;
      const inputClamp = globalUniforms.inputClamp;
      inputSize[0] = state.destinationFrame.width;
      inputSize[1] = state.destinationFrame.height;
      inputSize[2] = 1 / inputSize[0];
      inputSize[3] = 1 / inputSize[1];
      inputPixel[0] = Math.round(inputSize[0] * state.resolution);
      inputPixel[1] = Math.round(inputSize[1] * state.resolution);
      inputPixel[2] = 1 / inputPixel[0];
      inputPixel[3] = 1 / inputPixel[1];
      inputClamp[0] = 0.5 * inputPixel[2];
      inputClamp[1] = 0.5 * inputPixel[3];
      inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2];
      inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3];
      if (state.legacy) {
        const filterArea = globalUniforms.filterArea;
        filterArea[0] = state.destinationFrame.width;
        filterArea[1] = state.destinationFrame.height;
        filterArea[2] = state.sourceFrame.x;
        filterArea[3] = state.sourceFrame.y;
        globalUniforms.filterClamp = globalUniforms.inputClamp;
      }
      this.globalUniforms.update();
      const lastState = filterStack[filterStack.length - 1];
      this.renderer.framebuffer.blit();
      if (filters2.length === 1) {
        filters2[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES.BLEND, state);
        this.returnFilterTexture(state.renderTexture);
      } else {
        let flip = state.renderTexture;
        let flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
        flop.filterFrame = flip.filterFrame;
        let i = 0;
        for (i = 0; i < filters2.length - 1; ++i) {
          if (i === 1 && state.multisample > 1) {
            flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
            flop.filterFrame = flip.filterFrame;
          }
          filters2[i].apply(this, flip, flop, CLEAR_MODES.CLEAR, state);
          const t = flip;
          flip = flop;
          flop = t;
        }
        filters2[i].apply(this, flip, lastState.renderTexture, CLEAR_MODES.BLEND, state);
        if (i > 1 && state.multisample > 1) {
          this.returnFilterTexture(state.renderTexture);
        }
        this.returnFilterTexture(flip);
        this.returnFilterTexture(flop);
      }
      state.clear();
      this.statePool.push(state);
    }
    bindAndClear(filterTexture, clearMode = CLEAR_MODES.CLEAR) {
      const {
        renderTexture: renderTextureSystem,
        state: stateSystem
      } = this.renderer;
      if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
        this.renderer.projection.transform = this.activeState.transform;
      } else {
        this.renderer.projection.transform = null;
      }
      if (filterTexture?.filterFrame) {
        const destinationFrame = this.tempRect;
        destinationFrame.x = 0;
        destinationFrame.y = 0;
        destinationFrame.width = filterTexture.filterFrame.width;
        destinationFrame.height = filterTexture.filterFrame.height;
        renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);
      } else if (filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
        renderTextureSystem.bind(filterTexture);
      } else {
        this.renderer.renderTexture.bind(filterTexture, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
      }
      const autoClear = stateSystem.stateId & 1 || this.forceClear;
      if (clearMode === CLEAR_MODES.CLEAR || clearMode === CLEAR_MODES.BLIT && autoClear) {
        this.renderer.framebuffer.clear(0, 0, 0, 0);
      }
    }
    applyFilter(filter, input, output, clearMode) {
      const renderer = this.renderer;
      renderer.state.set(filter.state);
      this.bindAndClear(output, clearMode);
      filter.uniforms.uSampler = input;
      filter.uniforms.filterGlobals = this.globalUniforms;
      renderer.shader.bind(filter);
      filter.legacy = !!filter.program.attributeData.aTextureCoord;
      if (filter.legacy) {
        this.quadUv.map(input._frame, input.filterFrame);
        renderer.geometry.bind(this.quadUv);
        renderer.geometry.draw(DRAW_MODES.TRIANGLES);
      } else {
        renderer.geometry.bind(this.quad);
        renderer.geometry.draw(DRAW_MODES.TRIANGLE_STRIP);
      }
    }
    calculateSpriteMatrix(outputMatrix, sprite) {
      const { sourceFrame, destinationFrame } = this.activeState;
      const { orig } = sprite._texture;
      const mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0, destinationFrame.height, sourceFrame.x, sourceFrame.y);
      const worldTransform = sprite.worldTransform.copyTo(Matrix.TEMP_MATRIX);
      worldTransform.invert();
      mappedMatrix.prepend(worldTransform);
      mappedMatrix.scale(1 / orig.width, 1 / orig.height);
      mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
      return mappedMatrix;
    }
    destroy() {
      this.renderer = null;
      this.texturePool.clear(false);
    }
    getOptimalFilterTexture(minWidth, minHeight, resolution = 1, multisample = MSAA_QUALITY.NONE) {
      return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);
    }
    getFilterTexture(input, resolution, multisample) {
      if (typeof input === "number") {
        const swap = input;
        input = resolution;
        resolution = swap;
      }
      input = input || this.activeState.renderTexture;
      const filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY.NONE);
      filterTexture.filterFrame = input.filterFrame;
      return filterTexture;
    }
    returnFilterTexture(renderTexture) {
      this.texturePool.returnTexture(renderTexture);
    }
    emptyPool() {
      this.texturePool.clear(true);
    }
    resize() {
      this.texturePool.setScreenSize(this.renderer.view);
    }
    transformAABB(matrix, rect) {
      const lt = tempPoints[0];
      const lb = tempPoints[1];
      const rt = tempPoints[2];
      const rb = tempPoints[3];
      lt.set(rect.left, rect.top);
      lb.set(rect.left, rect.bottom);
      rt.set(rect.right, rect.top);
      rb.set(rect.right, rect.bottom);
      matrix.apply(lt, lt);
      matrix.apply(lb, lb);
      matrix.apply(rt, rt);
      matrix.apply(rb, rb);
      const x0 = Math.min(lt.x, lb.x, rt.x, rb.x);
      const y0 = Math.min(lt.y, lb.y, rt.y, rb.y);
      const x1 = Math.max(lt.x, lb.x, rt.x, rb.x);
      const y1 = Math.max(lt.y, lb.y, rt.y, rb.y);
      rect.x = x0;
      rect.y = y0;
      rect.width = x1 - x0;
      rect.height = y1 - y0;
    }
    roundFrame(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
      if (frame.width <= 0 || frame.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0) {
        return;
      }
      if (transform) {
        const { a: a2, b: b2, c, d } = transform;
        if ((Math.abs(b2) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a2) > 1e-4 || Math.abs(d) > 1e-4)) {
          return;
        }
      }
      transform = transform ? tempMatrix$2.copyFrom(transform) : tempMatrix$2.identity();
      transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
      this.transformAABB(transform, frame);
      frame.ceil(resolution);
      this.transformAABB(transform.invert(), frame);
    }
  };
  FilterSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "filter"
  };
  extensions$1.add(FilterSystem);
  var ObjectRenderer = class {
    constructor(renderer) {
      this.renderer = renderer;
    }
    flush() {
    }
    destroy() {
      this.renderer = null;
    }
    start() {
    }
    stop() {
      this.flush();
    }
    render(_object) {
    }
  };
  var BatchSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
      this.emptyRenderer = new ObjectRenderer(renderer);
      this.currentRenderer = this.emptyRenderer;
    }
    setObjectRenderer(objectRenderer) {
      if (this.currentRenderer === objectRenderer) {
        return;
      }
      this.currentRenderer.stop();
      this.currentRenderer = objectRenderer;
      this.currentRenderer.start();
    }
    flush() {
      this.setObjectRenderer(this.emptyRenderer);
    }
    reset() {
      this.setObjectRenderer(this.emptyRenderer);
    }
    copyBoundTextures(arr, maxTextures) {
      const { boundTextures } = this.renderer.texture;
      for (let i = maxTextures - 1; i >= 0; --i) {
        arr[i] = boundTextures[i] || null;
        if (arr[i]) {
          arr[i]._batchLocation = i;
        }
      }
    }
    boundArray(texArray, boundTextures, batchId, maxTextures) {
      const { elements, ids, count } = texArray;
      let j = 0;
      for (let i = 0; i < count; i++) {
        const tex = elements[i];
        const loc = tex._batchLocation;
        if (loc >= 0 && loc < maxTextures && boundTextures[loc] === tex) {
          ids[i] = loc;
          continue;
        }
        while (j < maxTextures) {
          const bound = boundTextures[j];
          if (bound && bound._batchEnabled === batchId && bound._batchLocation === j) {
            j++;
            continue;
          }
          ids[i] = j;
          tex._batchLocation = j;
          boundTextures[j] = tex;
          break;
        }
      }
    }
    destroy() {
      this.renderer = null;
    }
  };
  BatchSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "batch"
  };
  extensions$1.add(BatchSystem);
  var CONTEXT_UID_COUNTER = 0;
  var ContextSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
      this.webGLVersion = 1;
      this.extensions = {};
      this.supports = {
        uint32Indices: false
      };
      this.handleContextLost = this.handleContextLost.bind(this);
      this.handleContextRestored = this.handleContextRestored.bind(this);
    }
    get isLost() {
      return !this.gl || this.gl.isContextLost();
    }
    contextChange(gl) {
      this.gl = gl;
      this.renderer.gl = gl;
      this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
    }
    init(options) {
      if (options.context) {
        this.initFromContext(options.context);
      } else {
        const alpha = this.renderer.background.alpha < 1;
        const premultipliedAlpha = options.premultipliedAlpha;
        this.preserveDrawingBuffer = options.preserveDrawingBuffer;
        this.useContextAlpha = options.useContextAlpha;
        this.powerPreference = options.powerPreference;
        this.initFromOptions({
          alpha,
          premultipliedAlpha,
          antialias: options.antialias,
          stencil: true,
          preserveDrawingBuffer: options.preserveDrawingBuffer,
          powerPreference: options.powerPreference
        });
      }
    }
    initFromContext(gl) {
      this.gl = gl;
      this.validateContext(gl);
      this.renderer.gl = gl;
      this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
      this.renderer.runners.contextChange.emit(gl);
      const view = this.renderer.view;
      if (view.addEventListener !== void 0) {
        view.addEventListener("webglcontextlost", this.handleContextLost, false);
        view.addEventListener("webglcontextrestored", this.handleContextRestored, false);
      }
    }
    initFromOptions(options) {
      const gl = this.createContext(this.renderer.view, options);
      this.initFromContext(gl);
    }
    createContext(canvas, options) {
      let gl;
      if (settings.PREFER_ENV >= ENV.WEBGL2) {
        gl = canvas.getContext("webgl2", options);
      }
      if (gl) {
        this.webGLVersion = 2;
      } else {
        this.webGLVersion = 1;
        gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);
        if (!gl) {
          throw new Error("This browser does not support WebGL. Try using the canvas renderer");
        }
      }
      this.gl = gl;
      this.getExtensions();
      return this.gl;
    }
    getExtensions() {
      const { gl } = this;
      const common = {
        loseContext: gl.getExtension("WEBGL_lose_context"),
        anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
        floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
        s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
        s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
        etc: gl.getExtension("WEBGL_compressed_texture_etc"),
        etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
        pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
        atc: gl.getExtension("WEBGL_compressed_texture_atc"),
        astc: gl.getExtension("WEBGL_compressed_texture_astc")
      };
      if (this.webGLVersion === 1) {
        Object.assign(this.extensions, common, {
          drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
          depthTexture: gl.getExtension("WEBGL_depth_texture"),
          vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
          uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
          floatTexture: gl.getExtension("OES_texture_float"),
          floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
          textureHalfFloat: gl.getExtension("OES_texture_half_float"),
          textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear")
        });
      } else if (this.webGLVersion === 2) {
        Object.assign(this.extensions, common, {
          colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
        });
      }
    }
    handleContextLost(event) {
      event.preventDefault();
      setTimeout(() => {
        if (this.gl.isContextLost() && this.extensions.loseContext) {
          this.extensions.loseContext.restoreContext();
        }
      }, 0);
    }
    handleContextRestored() {
      this.renderer.runners.contextChange.emit(this.gl);
    }
    destroy() {
      const view = this.renderer.view;
      this.renderer = null;
      if (view.removeEventListener !== void 0) {
        view.removeEventListener("webglcontextlost", this.handleContextLost);
        view.removeEventListener("webglcontextrestored", this.handleContextRestored);
      }
      this.gl.useProgram(null);
      if (this.extensions.loseContext) {
        this.extensions.loseContext.loseContext();
      }
    }
    postrender() {
      if (this.renderer.objectRenderer.renderingToScreen) {
        this.gl.flush();
      }
    }
    validateContext(gl) {
      const attributes = gl.getContextAttributes();
      const isWebGl2 = "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext;
      if (isWebGl2) {
        this.webGLVersion = 2;
      }
      if (attributes && !attributes.stencil) {
        console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
      }
      const hasuint32 = isWebGl2 || !!gl.getExtension("OES_element_index_uint");
      this.supports.uint32Indices = hasuint32;
      if (!hasuint32) {
        console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
      }
    }
  };
  ContextSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "context"
  };
  extensions$1.add(ContextSystem);
  var GLFramebuffer = class {
    constructor(framebuffer) {
      this.framebuffer = framebuffer;
      this.stencil = null;
      this.dirtyId = -1;
      this.dirtyFormat = -1;
      this.dirtySize = -1;
      this.multisample = MSAA_QUALITY.NONE;
      this.msaaBuffer = null;
      this.blitFramebuffer = null;
      this.mipLevel = 0;
    }
  };
  var tempRectangle = new Rectangle();
  var FramebufferSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
      this.managedFramebuffers = [];
      this.unknownFramebuffer = new Framebuffer(10, 10);
      this.msaaSamples = null;
    }
    contextChange() {
      this.disposeAll(true);
      const gl = this.gl = this.renderer.gl;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID;
      this.current = this.unknownFramebuffer;
      this.viewport = new Rectangle();
      this.hasMRT = true;
      this.writeDepthTexture = true;
      if (this.renderer.context.webGLVersion === 1) {
        let nativeDrawBuffersExtension = this.renderer.context.extensions.drawBuffers;
        let nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;
        if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
          nativeDrawBuffersExtension = null;
          nativeDepthTextureExtension = null;
        }
        if (nativeDrawBuffersExtension) {
          gl.drawBuffers = (activeTextures) => nativeDrawBuffersExtension.drawBuffersWEBGL(activeTextures);
        } else {
          this.hasMRT = false;
          gl.drawBuffers = () => {
          };
        }
        if (!nativeDepthTextureExtension) {
          this.writeDepthTexture = false;
        }
      } else {
        this.msaaSamples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.RGBA8, gl.SAMPLES);
      }
    }
    bind(framebuffer, frame, mipLevel = 0) {
      const { gl } = this;
      if (framebuffer) {
        const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);
        if (this.current !== framebuffer) {
          this.current = framebuffer;
          gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);
        }
        if (fbo.mipLevel !== mipLevel) {
          framebuffer.dirtyId++;
          framebuffer.dirtyFormat++;
          fbo.mipLevel = mipLevel;
        }
        if (fbo.dirtyId !== framebuffer.dirtyId) {
          fbo.dirtyId = framebuffer.dirtyId;
          if (fbo.dirtyFormat !== framebuffer.dirtyFormat) {
            fbo.dirtyFormat = framebuffer.dirtyFormat;
            fbo.dirtySize = framebuffer.dirtySize;
            this.updateFramebuffer(framebuffer, mipLevel);
          } else if (fbo.dirtySize !== framebuffer.dirtySize) {
            fbo.dirtySize = framebuffer.dirtySize;
            this.resizeFramebuffer(framebuffer);
          }
        }
        for (let i = 0; i < framebuffer.colorTextures.length; i++) {
          const tex = framebuffer.colorTextures[i];
          this.renderer.texture.unbind(tex.parentTextureArray || tex);
        }
        if (framebuffer.depthTexture) {
          this.renderer.texture.unbind(framebuffer.depthTexture);
        }
        if (frame) {
          const mipWidth = frame.width >> mipLevel;
          const mipHeight = frame.height >> mipLevel;
          const scale = mipWidth / frame.width;
          this.setViewport(frame.x * scale, frame.y * scale, mipWidth, mipHeight);
        } else {
          const mipWidth = framebuffer.width >> mipLevel;
          const mipHeight = framebuffer.height >> mipLevel;
          this.setViewport(0, 0, mipWidth, mipHeight);
        }
      } else {
        if (this.current) {
          this.current = null;
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
        if (frame) {
          this.setViewport(frame.x, frame.y, frame.width, frame.height);
        } else {
          this.setViewport(0, 0, this.renderer.width, this.renderer.height);
        }
      }
    }
    setViewport(x, y, width, height) {
      const v2 = this.viewport;
      x = Math.round(x);
      y = Math.round(y);
      width = Math.round(width);
      height = Math.round(height);
      if (v2.width !== width || v2.height !== height || v2.x !== x || v2.y !== y) {
        v2.x = x;
        v2.y = y;
        v2.width = width;
        v2.height = height;
        this.gl.viewport(x, y, width, height);
      }
    }
    get size() {
      if (this.current) {
        return { x: 0, y: 0, width: this.current.width, height: this.current.height };
      }
      return { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
    }
    clear(r, g, b2, a2, mask = BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH) {
      const { gl } = this;
      gl.clearColor(r, g, b2, a2);
      gl.clear(mask);
    }
    initFramebuffer(framebuffer) {
      const { gl } = this;
      const fbo = new GLFramebuffer(gl.createFramebuffer());
      fbo.multisample = this.detectSamples(framebuffer.multisample);
      framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo;
      this.managedFramebuffers.push(framebuffer);
      framebuffer.disposeRunner.add(this);
      return fbo;
    }
    resizeFramebuffer(framebuffer) {
      const { gl } = this;
      const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
      if (fbo.stencil) {
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
        if (fbo.msaaBuffer) {
          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
        } else {
          gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
        }
      }
      const colorTextures = framebuffer.colorTextures;
      let count = colorTextures.length;
      if (!gl.drawBuffers) {
        count = Math.min(count, 1);
      }
      for (let i = 0; i < count; i++) {
        const texture = colorTextures[i];
        const parentTexture = texture.parentTextureArray || texture;
        this.renderer.texture.bind(parentTexture, 0);
        if (i === 0 && fbo.msaaBuffer) {
          gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, parentTexture._glTextures[this.CONTEXT_UID].internalFormat, framebuffer.width, framebuffer.height);
        }
      }
      if (framebuffer.depthTexture && this.writeDepthTexture) {
        this.renderer.texture.bind(framebuffer.depthTexture, 0);
      }
    }
    updateFramebuffer(framebuffer, mipLevel) {
      const { gl } = this;
      const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
      const colorTextures = framebuffer.colorTextures;
      let count = colorTextures.length;
      if (!gl.drawBuffers) {
        count = Math.min(count, 1);
      }
      if (fbo.multisample > 1 && this.canMultisampleFramebuffer(framebuffer)) {
        fbo.msaaBuffer = fbo.msaaBuffer || gl.createRenderbuffer();
      } else if (fbo.msaaBuffer) {
        gl.deleteRenderbuffer(fbo.msaaBuffer);
        fbo.msaaBuffer = null;
        if (fbo.blitFramebuffer) {
          fbo.blitFramebuffer.dispose();
          fbo.blitFramebuffer = null;
        }
      }
      const activeTextures = [];
      for (let i = 0; i < count; i++) {
        const texture = colorTextures[i];
        const parentTexture = texture.parentTextureArray || texture;
        this.renderer.texture.bind(parentTexture, 0);
        if (i === 0 && fbo.msaaBuffer) {
          gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, parentTexture._glTextures[this.CONTEXT_UID].internalFormat, framebuffer.width, framebuffer.height);
          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, fbo.msaaBuffer);
        } else {
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, texture.target, parentTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
          activeTextures.push(gl.COLOR_ATTACHMENT0 + i);
        }
      }
      if (activeTextures.length > 1) {
        gl.drawBuffers(activeTextures);
      }
      if (framebuffer.depthTexture) {
        const writeDepthTexture = this.writeDepthTexture;
        if (writeDepthTexture) {
          const depthTexture = framebuffer.depthTexture;
          this.renderer.texture.bind(depthTexture, 0);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
        }
      }
      if ((framebuffer.stencil || framebuffer.depth) && !(framebuffer.depthTexture && this.writeDepthTexture)) {
        fbo.stencil = fbo.stencil || gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
        if (fbo.msaaBuffer) {
          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
        } else {
          gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
        }
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, fbo.stencil);
      } else if (fbo.stencil) {
        gl.deleteRenderbuffer(fbo.stencil);
        fbo.stencil = null;
      }
    }
    canMultisampleFramebuffer(framebuffer) {
      return this.renderer.context.webGLVersion !== 1 && framebuffer.colorTextures.length <= 1 && !framebuffer.depthTexture;
    }
    detectSamples(samples) {
      const { msaaSamples } = this;
      let res = MSAA_QUALITY.NONE;
      if (samples <= 1 || msaaSamples === null) {
        return res;
      }
      for (let i = 0; i < msaaSamples.length; i++) {
        if (msaaSamples[i] <= samples) {
          res = msaaSamples[i];
          break;
        }
      }
      if (res === 1) {
        res = MSAA_QUALITY.NONE;
      }
      return res;
    }
    blit(framebuffer, sourcePixels, destPixels) {
      const { current, renderer, gl, CONTEXT_UID } = this;
      if (renderer.context.webGLVersion !== 2) {
        return;
      }
      if (!current) {
        return;
      }
      const fbo = current.glFramebuffers[CONTEXT_UID];
      if (!fbo) {
        return;
      }
      if (!framebuffer) {
        if (!fbo.msaaBuffer) {
          return;
        }
        const colorTexture = current.colorTextures[0];
        if (!colorTexture) {
          return;
        }
        if (!fbo.blitFramebuffer) {
          fbo.blitFramebuffer = new Framebuffer(current.width, current.height);
          fbo.blitFramebuffer.addColorTexture(0, colorTexture);
        }
        framebuffer = fbo.blitFramebuffer;
        if (framebuffer.colorTextures[0] !== colorTexture) {
          framebuffer.colorTextures[0] = colorTexture;
          framebuffer.dirtyId++;
          framebuffer.dirtyFormat++;
        }
        if (framebuffer.width !== current.width || framebuffer.height !== current.height) {
          framebuffer.width = current.width;
          framebuffer.height = current.height;
          framebuffer.dirtyId++;
          framebuffer.dirtySize++;
        }
      }
      if (!sourcePixels) {
        sourcePixels = tempRectangle;
        sourcePixels.width = current.width;
        sourcePixels.height = current.height;
      }
      if (!destPixels) {
        destPixels = sourcePixels;
      }
      const sameSize = sourcePixels.width === destPixels.width && sourcePixels.height === destPixels.height;
      this.bind(framebuffer);
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo.framebuffer);
      gl.blitFramebuffer(sourcePixels.left, sourcePixels.top, sourcePixels.right, sourcePixels.bottom, destPixels.left, destPixels.top, destPixels.right, destPixels.bottom, gl.COLOR_BUFFER_BIT, sameSize ? gl.NEAREST : gl.LINEAR);
    }
    disposeFramebuffer(framebuffer, contextLost) {
      const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
      const gl = this.gl;
      if (!fbo) {
        return;
      }
      delete framebuffer.glFramebuffers[this.CONTEXT_UID];
      const index2 = this.managedFramebuffers.indexOf(framebuffer);
      if (index2 >= 0) {
        this.managedFramebuffers.splice(index2, 1);
      }
      framebuffer.disposeRunner.remove(this);
      if (!contextLost) {
        gl.deleteFramebuffer(fbo.framebuffer);
        if (fbo.msaaBuffer) {
          gl.deleteRenderbuffer(fbo.msaaBuffer);
        }
        if (fbo.stencil) {
          gl.deleteRenderbuffer(fbo.stencil);
        }
      }
      if (fbo.blitFramebuffer) {
        fbo.blitFramebuffer.dispose();
      }
    }
    disposeAll(contextLost) {
      const list = this.managedFramebuffers;
      this.managedFramebuffers = [];
      for (let i = 0; i < list.length; i++) {
        this.disposeFramebuffer(list[i], contextLost);
      }
    }
    forceStencil() {
      const framebuffer = this.current;
      if (!framebuffer) {
        return;
      }
      const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
      if (!fbo || fbo.stencil) {
        return;
      }
      framebuffer.stencil = true;
      const w = framebuffer.width;
      const h = framebuffer.height;
      const gl = this.gl;
      const stencil = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);
      if (fbo.msaaBuffer) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, w, h);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, w, h);
      }
      fbo.stencil = stencil;
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, stencil);
    }
    reset() {
      this.current = this.unknownFramebuffer;
      this.viewport = new Rectangle();
    }
    destroy() {
      this.renderer = null;
    }
  };
  FramebufferSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "framebuffer"
  };
  extensions$1.add(FramebufferSystem);
  var byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
  var GeometrySystem = class {
    constructor(renderer) {
      this.renderer = renderer;
      this._activeGeometry = null;
      this._activeVao = null;
      this.hasVao = true;
      this.hasInstance = true;
      this.canUseUInt32ElementIndex = false;
      this.managedGeometries = {};
    }
    contextChange() {
      this.disposeAll(true);
      const gl = this.gl = this.renderer.gl;
      const context2 = this.renderer.context;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID;
      if (context2.webGLVersion !== 2) {
        let nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;
        if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
          nativeVaoExtension = null;
        }
        if (nativeVaoExtension) {
          gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES();
          gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao);
          gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao);
        } else {
          this.hasVao = false;
          gl.createVertexArray = () => null;
          gl.bindVertexArray = () => null;
          gl.deleteVertexArray = () => null;
        }
      }
      if (context2.webGLVersion !== 2) {
        const instanceExt = gl.getExtension("ANGLE_instanced_arrays");
        if (instanceExt) {
          gl.vertexAttribDivisor = (a2, b2) => instanceExt.vertexAttribDivisorANGLE(a2, b2);
          gl.drawElementsInstanced = (a2, b2, c, d, e) => instanceExt.drawElementsInstancedANGLE(a2, b2, c, d, e);
          gl.drawArraysInstanced = (a2, b2, c, d) => instanceExt.drawArraysInstancedANGLE(a2, b2, c, d);
        } else {
          this.hasInstance = false;
        }
      }
      this.canUseUInt32ElementIndex = context2.webGLVersion === 2 || !!context2.extensions.uint32ElementIndex;
    }
    bind(geometry, shader) {
      shader = shader || this.renderer.shader.shader;
      const { gl } = this;
      let vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
      let incRefCount = false;
      if (!vaos) {
        this.managedGeometries[geometry.id] = geometry;
        geometry.disposeRunner.add(this);
        geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};
        incRefCount = true;
      }
      const vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);
      this._activeGeometry = geometry;
      if (this._activeVao !== vao) {
        this._activeVao = vao;
        if (this.hasVao) {
          gl.bindVertexArray(vao);
        } else {
          this.activateVao(geometry, shader.program);
        }
      }
      this.updateBuffers();
    }
    reset() {
      this.unbind();
    }
    updateBuffers() {
      const geometry = this._activeGeometry;
      const bufferSystem = this.renderer.buffer;
      for (let i = 0; i < geometry.buffers.length; i++) {
        const buffer = geometry.buffers[i];
        bufferSystem.update(buffer);
      }
    }
    checkCompatibility(geometry, program) {
      const geometryAttributes = geometry.attributes;
      const shaderAttributes = program.attributeData;
      for (const j in shaderAttributes) {
        if (!geometryAttributes[j]) {
          throw new Error(`shader and geometry incompatible, geometry missing the "${j}" attribute`);
        }
      }
    }
    getSignature(geometry, program) {
      const attribs = geometry.attributes;
      const shaderAttributes = program.attributeData;
      const strings = ["g", geometry.id];
      for (const i in attribs) {
        if (shaderAttributes[i]) {
          strings.push(i, shaderAttributes[i].location);
        }
      }
      return strings.join("-");
    }
    initGeometryVao(geometry, shader, incRefCount = true) {
      const gl = this.gl;
      const CONTEXT_UID = this.CONTEXT_UID;
      const bufferSystem = this.renderer.buffer;
      const program = shader.program;
      if (!program.glPrograms[CONTEXT_UID]) {
        this.renderer.shader.generateProgram(shader);
      }
      this.checkCompatibility(geometry, program);
      const signature = this.getSignature(geometry, program);
      const vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];
      let vao = vaoObjectHash[signature];
      if (vao) {
        vaoObjectHash[program.id] = vao;
        return vao;
      }
      const buffers = geometry.buffers;
      const attributes = geometry.attributes;
      const tempStride = {};
      const tempStart = {};
      for (const j in buffers) {
        tempStride[j] = 0;
        tempStart[j] = 0;
      }
      for (const j in attributes) {
        if (!attributes[j].size && program.attributeData[j]) {
          attributes[j].size = program.attributeData[j].size;
        } else if (!attributes[j].size) {
          console.warn(`PIXI Geometry attribute '${j}' size cannot be determined (likely the bound shader does not have the attribute)`);
        }
        tempStride[attributes[j].buffer] += attributes[j].size * byteSizeMap[attributes[j].type];
      }
      for (const j in attributes) {
        const attribute = attributes[j];
        const attribSize = attribute.size;
        if (attribute.stride === void 0) {
          if (tempStride[attribute.buffer] === attribSize * byteSizeMap[attribute.type]) {
            attribute.stride = 0;
          } else {
            attribute.stride = tempStride[attribute.buffer];
          }
        }
        if (attribute.start === void 0) {
          attribute.start = tempStart[attribute.buffer];
          tempStart[attribute.buffer] += attribSize * byteSizeMap[attribute.type];
        }
      }
      vao = gl.createVertexArray();
      gl.bindVertexArray(vao);
      for (let i = 0; i < buffers.length; i++) {
        const buffer = buffers[i];
        bufferSystem.bind(buffer);
        if (incRefCount) {
          buffer._glBuffers[CONTEXT_UID].refCount++;
        }
      }
      this.activateVao(geometry, program);
      vaoObjectHash[program.id] = vao;
      vaoObjectHash[signature] = vao;
      gl.bindVertexArray(null);
      bufferSystem.unbind(BUFFER_TYPE.ARRAY_BUFFER);
      return vao;
    }
    disposeGeometry(geometry, contextLost) {
      if (!this.managedGeometries[geometry.id]) {
        return;
      }
      delete this.managedGeometries[geometry.id];
      const vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
      const gl = this.gl;
      const buffers = geometry.buffers;
      const bufferSystem = this.renderer?.buffer;
      geometry.disposeRunner.remove(this);
      if (!vaos) {
        return;
      }
      if (bufferSystem) {
        for (let i = 0; i < buffers.length; i++) {
          const buf = buffers[i]._glBuffers[this.CONTEXT_UID];
          if (buf) {
            buf.refCount--;
            if (buf.refCount === 0 && !contextLost) {
              bufferSystem.dispose(buffers[i], contextLost);
            }
          }
        }
      }
      if (!contextLost) {
        for (const vaoId in vaos) {
          if (vaoId[0] === "g") {
            const vao = vaos[vaoId];
            if (this._activeVao === vao) {
              this.unbind();
            }
            gl.deleteVertexArray(vao);
          }
        }
      }
      delete geometry.glVertexArrayObjects[this.CONTEXT_UID];
    }
    disposeAll(contextLost) {
      const all = Object.keys(this.managedGeometries);
      for (let i = 0; i < all.length; i++) {
        this.disposeGeometry(this.managedGeometries[all[i]], contextLost);
      }
    }
    activateVao(geometry, program) {
      const gl = this.gl;
      const CONTEXT_UID = this.CONTEXT_UID;
      const bufferSystem = this.renderer.buffer;
      const buffers = geometry.buffers;
      const attributes = geometry.attributes;
      if (geometry.indexBuffer) {
        bufferSystem.bind(geometry.indexBuffer);
      }
      let lastBuffer = null;
      for (const j in attributes) {
        const attribute = attributes[j];
        const buffer = buffers[attribute.buffer];
        const glBuffer = buffer._glBuffers[CONTEXT_UID];
        if (program.attributeData[j]) {
          if (lastBuffer !== glBuffer) {
            bufferSystem.bind(buffer);
            lastBuffer = glBuffer;
          }
          const location2 = program.attributeData[j].location;
          gl.enableVertexAttribArray(location2);
          gl.vertexAttribPointer(location2, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);
          if (attribute.instance) {
            if (this.hasInstance) {
              gl.vertexAttribDivisor(location2, 1);
            } else {
              throw new Error("geometry error, GPU Instancing is not supported on this device");
            }
          }
        }
      }
    }
    draw(type, size, start, instanceCount) {
      const { gl } = this;
      const geometry = this._activeGeometry;
      if (geometry.indexBuffer) {
        const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
        const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
        if (byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex) {
          if (geometry.instanced) {
            gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1);
          } else {
            gl.drawElements(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
          }
        } else {
          console.warn("unsupported index buffer type: uint32");
        }
      } else if (geometry.instanced) {
        gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1);
      } else {
        gl.drawArrays(type, start, size || geometry.getSize());
      }
      return this;
    }
    unbind() {
      this.gl.bindVertexArray(null);
      this._activeVao = null;
      this._activeGeometry = null;
    }
    destroy() {
      this.renderer = null;
    }
  };
  GeometrySystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "geometry"
  };
  extensions$1.add(GeometrySystem);
  var MaskData = class {
    constructor(maskObject = null) {
      this.type = MASK_TYPES.NONE;
      this.autoDetect = true;
      this.maskObject = maskObject || null;
      this.pooled = false;
      this.isMaskData = true;
      this.resolution = null;
      this.multisample = settings.FILTER_MULTISAMPLE;
      this.enabled = true;
      this.colorMask = 15;
      this._filters = null;
      this._stencilCounter = 0;
      this._scissorCounter = 0;
      this._scissorRect = null;
      this._scissorRectLocal = null;
      this._colorMask = 15;
      this._target = null;
    }
    get filter() {
      return this._filters ? this._filters[0] : null;
    }
    set filter(value3) {
      if (value3) {
        if (this._filters) {
          this._filters[0] = value3;
        } else {
          this._filters = [value3];
        }
      } else {
        this._filters = null;
      }
    }
    reset() {
      if (this.pooled) {
        this.maskObject = null;
        this.type = MASK_TYPES.NONE;
        this.autoDetect = true;
      }
      this._target = null;
      this._scissorRectLocal = null;
    }
    copyCountersOrReset(maskAbove) {
      if (maskAbove) {
        this._stencilCounter = maskAbove._stencilCounter;
        this._scissorCounter = maskAbove._scissorCounter;
        this._scissorRect = maskAbove._scissorRect;
      } else {
        this._stencilCounter = 0;
        this._scissorCounter = 0;
        this._scissorRect = null;
      }
    }
  };
  function compileShader(gl, type, src) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, src);
    gl.compileShader(shader);
    return shader;
  }
  function logPrettyShaderError(gl, shader) {
    const shaderSrc = gl.getShaderSource(shader).split("\n").map((line, index2) => `${index2}: ${line}`);
    const shaderLog = gl.getShaderInfoLog(shader);
    const splitShader = shaderLog.split("\n");
    const dedupe = {};
    const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((n) => {
      if (n && !dedupe[n]) {
        dedupe[n] = true;
        return true;
      }
      return false;
    });
    const logArgs = [""];
    lineNumbers.forEach((number) => {
      shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;
      logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
    });
    const fragmentSourceToLog = shaderSrc.join("\n");
    logArgs[0] = fragmentSourceToLog;
    console.error(shaderLog);
    console.groupCollapsed("click to view full shader code");
    console.warn(...logArgs);
    console.groupEnd();
  }
  function logProgramError(gl, program, vertexShader, fragmentShader) {
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        logPrettyShaderError(gl, vertexShader);
      }
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        logPrettyShaderError(gl, fragmentShader);
      }
      console.error("PixiJS Error: Could not initialize shader.");
      if (gl.getProgramInfoLog(program) !== "") {
        console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
      }
    }
  }
  function booleanArray(size) {
    const array = new Array(size);
    for (let i = 0; i < array.length; i++) {
      array[i] = false;
    }
    return array;
  }
  function defaultValue(type, size) {
    switch (type) {
      case "float":
        return 0;
      case "vec2":
        return new Float32Array(2 * size);
      case "vec3":
        return new Float32Array(3 * size);
      case "vec4":
        return new Float32Array(4 * size);
      case "int":
      case "uint":
      case "sampler2D":
      case "sampler2DArray":
        return 0;
      case "ivec2":
        return new Int32Array(2 * size);
      case "ivec3":
        return new Int32Array(3 * size);
      case "ivec4":
        return new Int32Array(4 * size);
      case "uvec2":
        return new Uint32Array(2 * size);
      case "uvec3":
        return new Uint32Array(3 * size);
      case "uvec4":
        return new Uint32Array(4 * size);
      case "bool":
        return false;
      case "bvec2":
        return booleanArray(2 * size);
      case "bvec3":
        return booleanArray(3 * size);
      case "bvec4":
        return booleanArray(4 * size);
      case "mat2":
        return new Float32Array([
          1,
          0,
          0,
          1
        ]);
      case "mat3":
        return new Float32Array([
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ]);
      case "mat4":
        return new Float32Array([
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
    }
    return null;
  }
  var unknownContext = {};
  var context = unknownContext;
  function getTestContext() {
    if (context === unknownContext || context?.isContextLost()) {
      const canvas = settings.ADAPTER.createCanvas();
      let gl;
      if (settings.PREFER_ENV >= ENV.WEBGL2) {
        gl = canvas.getContext("webgl2", {});
      }
      if (!gl) {
        gl = canvas.getContext("webgl", {}) || canvas.getContext("experimental-webgl", {});
        if (!gl) {
          gl = null;
        } else {
          gl.getExtension("WEBGL_draw_buffers");
        }
      }
      context = gl;
    }
    return context;
  }
  var maxFragmentPrecision;
  function getMaxFragmentPrecision() {
    if (!maxFragmentPrecision) {
      maxFragmentPrecision = PRECISION.MEDIUM;
      const gl = getTestContext();
      if (gl) {
        if (gl.getShaderPrecisionFormat) {
          const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
          maxFragmentPrecision = shaderFragment.precision ? PRECISION.HIGH : PRECISION.MEDIUM;
        }
      }
    }
    return maxFragmentPrecision;
  }
  function setPrecision(src, requestedPrecision, maxSupportedPrecision) {
    if (src.substring(0, 9) !== "precision") {
      let precision = requestedPrecision;
      if (requestedPrecision === PRECISION.HIGH && maxSupportedPrecision !== PRECISION.HIGH) {
        precision = PRECISION.MEDIUM;
      }
      return `precision ${precision} float;
${src}`;
    } else if (maxSupportedPrecision !== PRECISION.HIGH && src.substring(0, 15) === "precision highp") {
      return src.replace("precision highp", "precision mediump");
    }
    return src;
  }
  var GLSL_TO_SIZE = {
    float: 1,
    vec2: 2,
    vec3: 3,
    vec4: 4,
    int: 1,
    ivec2: 2,
    ivec3: 3,
    ivec4: 4,
    uint: 1,
    uvec2: 2,
    uvec3: 3,
    uvec4: 4,
    bool: 1,
    bvec2: 2,
    bvec3: 3,
    bvec4: 4,
    mat2: 4,
    mat3: 9,
    mat4: 16,
    sampler2D: 1
  };
  function mapSize(type) {
    return GLSL_TO_SIZE[type];
  }
  var GL_TABLE = null;
  var GL_TO_GLSL_TYPES = {
    FLOAT: "float",
    FLOAT_VEC2: "vec2",
    FLOAT_VEC3: "vec3",
    FLOAT_VEC4: "vec4",
    INT: "int",
    INT_VEC2: "ivec2",
    INT_VEC3: "ivec3",
    INT_VEC4: "ivec4",
    UNSIGNED_INT: "uint",
    UNSIGNED_INT_VEC2: "uvec2",
    UNSIGNED_INT_VEC3: "uvec3",
    UNSIGNED_INT_VEC4: "uvec4",
    BOOL: "bool",
    BOOL_VEC2: "bvec2",
    BOOL_VEC3: "bvec3",
    BOOL_VEC4: "bvec4",
    FLOAT_MAT2: "mat2",
    FLOAT_MAT3: "mat3",
    FLOAT_MAT4: "mat4",
    SAMPLER_2D: "sampler2D",
    INT_SAMPLER_2D: "sampler2D",
    UNSIGNED_INT_SAMPLER_2D: "sampler2D",
    SAMPLER_CUBE: "samplerCube",
    INT_SAMPLER_CUBE: "samplerCube",
    UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
    SAMPLER_2D_ARRAY: "sampler2DArray",
    INT_SAMPLER_2D_ARRAY: "sampler2DArray",
    UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
  };
  function mapType(gl, type) {
    if (!GL_TABLE) {
      const typeNames = Object.keys(GL_TO_GLSL_TYPES);
      GL_TABLE = {};
      for (let i = 0; i < typeNames.length; ++i) {
        const tn = typeNames[i];
        GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
      }
    }
    return GL_TABLE[type];
  }
  var uniformParsers = [
    {
      test: (data) => data.type === "float" && data.size === 1 && !data.isArray,
      code: (name) => `
            if(uv["${name}"] !== ud["${name}"].value)
            {
                ud["${name}"].value = uv["${name}"]
                gl.uniform1f(ud["${name}"].location, uv["${name}"])
            }
            `
    },
    {
      test: (data, uniform) => (data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray && (uniform == null || uniform.castToBaseTexture !== void 0),
      code: (name) => `t = syncData.textureCount++;

            renderer.texture.bind(uv["${name}"], t);

            if(ud["${name}"].value !== t)
            {
                ud["${name}"].value = t;
                gl.uniform1i(ud["${name}"].location, t);
; // eslint-disable-line max-len
            }`
    },
    {
      test: (data, uniform) => data.type === "mat3" && data.size === 1 && !data.isArray && uniform.a !== void 0,
      code: (name) => `
            gl.uniformMatrix3fv(ud["${name}"].location, false, uv["${name}"].toArray(true));
            `,
      codeUbo: (name) => `
                var ${name}_matrix = uv.${name}.toArray(true);

                data[offset] = ${name}_matrix[0];
                data[offset+1] = ${name}_matrix[1];
                data[offset+2] = ${name}_matrix[2];

                data[offset + 4] = ${name}_matrix[3];
                data[offset + 5] = ${name}_matrix[4];
                data[offset + 6] = ${name}_matrix[5];

                data[offset + 8] = ${name}_matrix[6];
                data[offset + 9] = ${name}_matrix[7];
                data[offset + 10] = ${name}_matrix[8];
            `
    },
    {
      test: (data, uniform) => data.type === "vec2" && data.size === 1 && !data.isArray && uniform.x !== void 0,
      code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["${name}"].location, v.x, v.y);
                }`,
      codeUbo: (name) => `
                v = uv.${name};

                data[offset] = v.x;
                data[offset+1] = v.y;
            `
    },
    {
      test: (data) => data.type === "vec2" && data.size === 1 && !data.isArray,
      code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["${name}"].location, v[0], v[1]);
                }
            `
    },
    {
      test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.width !== void 0,
      code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["${name}"].location, v.x, v.y, v.width, v.height)
                }`,
      codeUbo: (name) => `
                    v = uv.${name};

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `
    },
    {
      test: (data) => data.type === "vec4" && data.size === 1 && !data.isArray,
      code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["${name}"].location, v[0], v[1], v[2], v[3])
                }`
    }
  ];
  var GLSL_TO_SINGLE_SETTERS_CACHED = {
    float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
    vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
    vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
    vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
    int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
    ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
    ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
    ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
    uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
    uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
    uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
    uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
    bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
    bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
    bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
    bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
    mat2: "gl.uniformMatrix2fv(location, false, v)",
    mat3: "gl.uniformMatrix3fv(location, false, v)",
    mat4: "gl.uniformMatrix4fv(location, false, v)",
    sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
    samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
    sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
  };
  var GLSL_TO_ARRAY_SETTERS = {
    float: `gl.uniform1fv(location, v)`,
    vec2: `gl.uniform2fv(location, v)`,
    vec3: `gl.uniform3fv(location, v)`,
    vec4: "gl.uniform4fv(location, v)",
    mat4: "gl.uniformMatrix4fv(location, false, v)",
    mat3: "gl.uniformMatrix3fv(location, false, v)",
    mat2: "gl.uniformMatrix2fv(location, false, v)",
    int: "gl.uniform1iv(location, v)",
    ivec2: "gl.uniform2iv(location, v)",
    ivec3: "gl.uniform3iv(location, v)",
    ivec4: "gl.uniform4iv(location, v)",
    uint: "gl.uniform1uiv(location, v)",
    uvec2: "gl.uniform2uiv(location, v)",
    uvec3: "gl.uniform3uiv(location, v)",
    uvec4: "gl.uniform4uiv(location, v)",
    bool: "gl.uniform1iv(location, v)",
    bvec2: "gl.uniform2iv(location, v)",
    bvec3: "gl.uniform3iv(location, v)",
    bvec4: "gl.uniform4iv(location, v)",
    sampler2D: "gl.uniform1iv(location, v)",
    samplerCube: "gl.uniform1iv(location, v)",
    sampler2DArray: "gl.uniform1iv(location, v)"
  };
  function generateUniformsSync(group, uniformData) {
    const funcFragments = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
    for (const i in group.uniforms) {
      const data = uniformData[i];
      if (!data) {
        if (group.uniforms[i]?.group) {
          if (group.uniforms[i].ubo) {
            funcFragments.push(`
                        renderer.shader.syncUniformBufferGroup(uv.${i}, '${i}');
                    `);
          } else {
            funcFragments.push(`
                        renderer.shader.syncUniformGroup(uv.${i}, syncData);
                    `);
          }
        }
        continue;
      }
      const uniform = group.uniforms[i];
      let parsed = false;
      for (let j = 0; j < uniformParsers.length; j++) {
        if (uniformParsers[j].test(data, uniform)) {
          funcFragments.push(uniformParsers[j].code(i, uniform));
          parsed = true;
          break;
        }
      }
      if (!parsed) {
        const templateType = data.size === 1 && !data.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS;
        const template = templateType[data.type].replace("location", `ud["${i}"].location`);
        funcFragments.push(`
            cu = ud["${i}"];
            cv = cu.value;
            v = uv["${i}"];
            ${template};`);
      }
    }
    return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
  }
  var fragTemplate$1 = [
    "precision mediump float;",
    "void main(void){",
    "float test = 0.1;",
    "%forloop%",
    "gl_FragColor = vec4(0.0);",
    "}"
  ].join("\n");
  function generateIfTestSrc(maxIfs) {
    let src = "";
    for (let i = 0; i < maxIfs; ++i) {
      if (i > 0) {
        src += "\nelse ";
      }
      if (i < maxIfs - 1) {
        src += `if(test == ${i}.0){}`;
      }
    }
    return src;
  }
  function checkMaxIfStatementsInShader(maxIfs, gl) {
    if (maxIfs === 0) {
      throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
    }
    const shader = gl.createShader(gl.FRAGMENT_SHADER);
    while (true) {
      const fragmentSrc = fragTemplate$1.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
      gl.shaderSource(shader, fragmentSrc);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        maxIfs = maxIfs / 2 | 0;
      } else {
        break;
      }
    }
    return maxIfs;
  }
  var unsafeEval;
  function unsafeEvalSupported() {
    if (typeof unsafeEval === "boolean") {
      return unsafeEval;
    }
    try {
      const func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
      unsafeEval = func({ a: "b" }, "a", "b") === true;
    } catch (e) {
      unsafeEval = false;
    }
    return unsafeEval;
  }
  var defaultFragment$2 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}";
  var defaultVertex$3 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n";
  var UID$1 = 0;
  var nameCache = {};
  var Program = class {
    constructor(vertexSrc, fragmentSrc, name = "pixi-shader", extra = {}) {
      this.extra = {};
      this.id = UID$1++;
      this.vertexSrc = vertexSrc || Program.defaultVertexSrc;
      this.fragmentSrc = fragmentSrc || Program.defaultFragmentSrc;
      this.vertexSrc = this.vertexSrc.trim();
      this.fragmentSrc = this.fragmentSrc.trim();
      this.extra = extra;
      if (this.vertexSrc.substring(0, 8) !== "#version") {
        name = name.replace(/\s+/g, "-");
        if (nameCache[name]) {
          nameCache[name]++;
          name += `-${nameCache[name]}`;
        } else {
          nameCache[name] = 1;
        }
        this.vertexSrc = `#define SHADER_NAME ${name}
${this.vertexSrc}`;
        this.fragmentSrc = `#define SHADER_NAME ${name}
${this.fragmentSrc}`;
        this.vertexSrc = setPrecision(this.vertexSrc, settings.PRECISION_VERTEX, PRECISION.HIGH);
        this.fragmentSrc = setPrecision(this.fragmentSrc, settings.PRECISION_FRAGMENT, getMaxFragmentPrecision());
      }
      this.glPrograms = {};
      this.syncUniforms = null;
    }
    static get defaultVertexSrc() {
      return defaultVertex$3;
    }
    static get defaultFragmentSrc() {
      return defaultFragment$2;
    }
    static from(vertexSrc, fragmentSrc, name) {
      const key = vertexSrc + fragmentSrc;
      let program = ProgramCache[key];
      if (!program) {
        ProgramCache[key] = program = new Program(vertexSrc, fragmentSrc, name);
      }
      return program;
    }
  };
  var Shader = class {
    constructor(program, uniforms) {
      this.uniformBindCount = 0;
      this.program = program;
      if (uniforms) {
        if (uniforms instanceof UniformGroup) {
          this.uniformGroup = uniforms;
        } else {
          this.uniformGroup = new UniformGroup(uniforms);
        }
      } else {
        this.uniformGroup = new UniformGroup({});
      }
      this.disposeRunner = new Runner("disposeShader");
    }
    checkUniformExists(name, group) {
      if (group.uniforms[name]) {
        return true;
      }
      for (const i in group.uniforms) {
        const uniform = group.uniforms[i];
        if (uniform.group) {
          if (this.checkUniformExists(name, uniform)) {
            return true;
          }
        }
      }
      return false;
    }
    destroy() {
      this.uniformGroup = null;
      this.disposeRunner.emit(this);
      this.disposeRunner.destroy();
    }
    get uniforms() {
      return this.uniformGroup.uniforms;
    }
    static from(vertexSrc, fragmentSrc, uniforms) {
      const program = Program.from(vertexSrc, fragmentSrc);
      return new Shader(program, uniforms);
    }
  };
  var BLEND$1 = 0;
  var OFFSET$1 = 1;
  var CULLING$1 = 2;
  var DEPTH_TEST$1 = 3;
  var WINDING$1 = 4;
  var DEPTH_MASK$1 = 5;
  var State = class {
    constructor() {
      this.data = 0;
      this.blendMode = BLEND_MODES.NORMAL;
      this.polygonOffset = 0;
      this.blend = true;
      this.depthMask = true;
    }
    get blend() {
      return !!(this.data & 1 << BLEND$1);
    }
    set blend(value3) {
      if (!!(this.data & 1 << BLEND$1) !== value3) {
        this.data ^= 1 << BLEND$1;
      }
    }
    get offsets() {
      return !!(this.data & 1 << OFFSET$1);
    }
    set offsets(value3) {
      if (!!(this.data & 1 << OFFSET$1) !== value3) {
        this.data ^= 1 << OFFSET$1;
      }
    }
    get culling() {
      return !!(this.data & 1 << CULLING$1);
    }
    set culling(value3) {
      if (!!(this.data & 1 << CULLING$1) !== value3) {
        this.data ^= 1 << CULLING$1;
      }
    }
    get depthTest() {
      return !!(this.data & 1 << DEPTH_TEST$1);
    }
    set depthTest(value3) {
      if (!!(this.data & 1 << DEPTH_TEST$1) !== value3) {
        this.data ^= 1 << DEPTH_TEST$1;
      }
    }
    get depthMask() {
      return !!(this.data & 1 << DEPTH_MASK$1);
    }
    set depthMask(value3) {
      if (!!(this.data & 1 << DEPTH_MASK$1) !== value3) {
        this.data ^= 1 << DEPTH_MASK$1;
      }
    }
    get clockwiseFrontFace() {
      return !!(this.data & 1 << WINDING$1);
    }
    set clockwiseFrontFace(value3) {
      if (!!(this.data & 1 << WINDING$1) !== value3) {
        this.data ^= 1 << WINDING$1;
      }
    }
    get blendMode() {
      return this._blendMode;
    }
    set blendMode(value3) {
      this.blend = value3 !== BLEND_MODES.NONE;
      this._blendMode = value3;
    }
    get polygonOffset() {
      return this._polygonOffset;
    }
    set polygonOffset(value3) {
      this.offsets = !!value3;
      this._polygonOffset = value3;
    }
    toString() {
      return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
    }
    static for2d() {
      const state = new State();
      state.depthTest = false;
      state.blend = true;
      return state;
    }
  };
  var defaultFragment$1 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n";
  var defaultVertex$2 = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
  var Filter = class extends Shader {
    constructor(vertexSrc, fragmentSrc, uniforms) {
      const program = Program.from(vertexSrc || Filter.defaultVertexSrc, fragmentSrc || Filter.defaultFragmentSrc);
      super(program, uniforms);
      this.padding = 0;
      this.resolution = settings.FILTER_RESOLUTION;
      this.multisample = settings.FILTER_MULTISAMPLE;
      this.enabled = true;
      this.autoFit = true;
      this.state = new State();
    }
    apply(filterManager, input, output, clearMode, _currentState) {
      filterManager.applyFilter(this, input, output, clearMode);
    }
    get blendMode() {
      return this.state.blendMode;
    }
    set blendMode(value3) {
      this.state.blendMode = value3;
    }
    get resolution() {
      return this._resolution;
    }
    set resolution(value3) {
      this._resolution = value3;
    }
    static get defaultVertexSrc() {
      return defaultVertex$2;
    }
    static get defaultFragmentSrc() {
      return defaultFragment$1;
    }
  };
  var vertex$4 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n";
  var fragment$7 = "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n";
  var tempMat$1 = new Matrix();
  var TextureMatrix = class {
    constructor(texture, clampMargin) {
      this._texture = texture;
      this.mapCoord = new Matrix();
      this.uClampFrame = new Float32Array(4);
      this.uClampOffset = new Float32Array(2);
      this._textureID = -1;
      this._updateID = 0;
      this.clampOffset = 0;
      this.clampMargin = typeof clampMargin === "undefined" ? 0.5 : clampMargin;
      this.isSimple = false;
    }
    get texture() {
      return this._texture;
    }
    set texture(value3) {
      this._texture = value3;
      this._textureID = -1;
    }
    multiplyUvs(uvs, out) {
      if (out === void 0) {
        out = uvs;
      }
      const mat = this.mapCoord;
      for (let i = 0; i < uvs.length; i += 2) {
        const x = uvs[i];
        const y = uvs[i + 1];
        out[i] = x * mat.a + y * mat.c + mat.tx;
        out[i + 1] = x * mat.b + y * mat.d + mat.ty;
      }
      return out;
    }
    update(forceUpdate) {
      const tex = this._texture;
      if (!tex || !tex.valid) {
        return false;
      }
      if (!forceUpdate && this._textureID === tex._updateID) {
        return false;
      }
      this._textureID = tex._updateID;
      this._updateID++;
      const uvs = tex._uvs;
      this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
      const orig = tex.orig;
      const trim = tex.trim;
      if (trim) {
        tempMat$1.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);
        this.mapCoord.append(tempMat$1);
      }
      const texBase = tex.baseTexture;
      const frame = this.uClampFrame;
      const margin = this.clampMargin / texBase.resolution;
      const offset = this.clampOffset;
      frame[0] = (tex._frame.x + margin + offset) / texBase.width;
      frame[1] = (tex._frame.y + margin + offset) / texBase.height;
      frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;
      frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;
      this.uClampOffset[0] = offset / texBase.realWidth;
      this.uClampOffset[1] = offset / texBase.realHeight;
      this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0;
      return true;
    }
  };
  var SpriteMaskFilter = class extends Filter {
    constructor(vertexSrc, fragmentSrc, uniforms) {
      let sprite = null;
      if (typeof vertexSrc !== "string" && fragmentSrc === void 0 && uniforms === void 0) {
        sprite = vertexSrc;
        vertexSrc = void 0;
        fragmentSrc = void 0;
        uniforms = void 0;
      }
      super(vertexSrc || vertex$4, fragmentSrc || fragment$7, uniforms);
      this.maskSprite = sprite;
      this.maskMatrix = new Matrix();
    }
    get maskSprite() {
      return this._maskSprite;
    }
    set maskSprite(value3) {
      this._maskSprite = value3;
      if (this._maskSprite) {
        this._maskSprite.renderable = false;
      }
    }
    apply(filterManager, input, output, clearMode) {
      const maskSprite = this._maskSprite;
      const tex = maskSprite._texture;
      if (!tex.valid) {
        return;
      }
      if (!tex.uvMatrix) {
        tex.uvMatrix = new TextureMatrix(tex, 0);
      }
      tex.uvMatrix.update();
      this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0 : 1;
      this.uniforms.mask = tex;
      this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.uvMatrix.mapCoord);
      this.uniforms.alpha = maskSprite.worldAlpha;
      this.uniforms.maskClamp = tex.uvMatrix.uClampFrame;
      filterManager.applyFilter(this, input, output, clearMode);
    }
  };
  var MaskSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
      this.enableScissor = true;
      this.alphaMaskPool = [];
      this.maskDataPool = [];
      this.maskStack = [];
      this.alphaMaskIndex = 0;
    }
    setMaskStack(maskStack) {
      this.maskStack = maskStack;
      this.renderer.scissor.setMaskStack(maskStack);
      this.renderer.stencil.setMaskStack(maskStack);
    }
    push(target2, maskDataOrTarget) {
      let maskData = maskDataOrTarget;
      if (!maskData.isMaskData) {
        const d = this.maskDataPool.pop() || new MaskData();
        d.pooled = true;
        d.maskObject = maskDataOrTarget;
        maskData = d;
      }
      const maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
      maskData.copyCountersOrReset(maskAbove);
      maskData._colorMask = maskAbove ? maskAbove._colorMask : 15;
      if (maskData.autoDetect) {
        this.detect(maskData);
      }
      maskData._target = target2;
      if (maskData.type !== MASK_TYPES.SPRITE) {
        this.maskStack.push(maskData);
      }
      if (maskData.enabled) {
        switch (maskData.type) {
          case MASK_TYPES.SCISSOR:
            this.renderer.scissor.push(maskData);
            break;
          case MASK_TYPES.STENCIL:
            this.renderer.stencil.push(maskData);
            break;
          case MASK_TYPES.SPRITE:
            maskData.copyCountersOrReset(null);
            this.pushSpriteMask(maskData);
            break;
          case MASK_TYPES.COLOR:
            this.pushColorMask(maskData);
            break;
          default:
            break;
        }
      }
      if (maskData.type === MASK_TYPES.SPRITE) {
        this.maskStack.push(maskData);
      }
    }
    pop(target2) {
      const maskData = this.maskStack.pop();
      if (!maskData || maskData._target !== target2) {
        return;
      }
      if (maskData.enabled) {
        switch (maskData.type) {
          case MASK_TYPES.SCISSOR:
            this.renderer.scissor.pop(maskData);
            break;
          case MASK_TYPES.STENCIL:
            this.renderer.stencil.pop(maskData.maskObject);
            break;
          case MASK_TYPES.SPRITE:
            this.popSpriteMask(maskData);
            break;
          case MASK_TYPES.COLOR:
            this.popColorMask(maskData);
            break;
          default:
            break;
        }
      }
      maskData.reset();
      if (maskData.pooled) {
        this.maskDataPool.push(maskData);
      }
      if (this.maskStack.length !== 0) {
        const maskCurrent = this.maskStack[this.maskStack.length - 1];
        if (maskCurrent.type === MASK_TYPES.SPRITE && maskCurrent._filters) {
          maskCurrent._filters[0].maskSprite = maskCurrent.maskObject;
        }
      }
    }
    detect(maskData) {
      const maskObject = maskData.maskObject;
      if (!maskObject) {
        maskData.type = MASK_TYPES.COLOR;
      } else if (maskObject.isSprite) {
        maskData.type = MASK_TYPES.SPRITE;
      } else if (this.enableScissor && this.renderer.scissor.testScissor(maskData)) {
        maskData.type = MASK_TYPES.SCISSOR;
      } else {
        maskData.type = MASK_TYPES.STENCIL;
      }
    }
    pushSpriteMask(maskData) {
      const { maskObject } = maskData;
      const target2 = maskData._target;
      let alphaMaskFilter = maskData._filters;
      if (!alphaMaskFilter) {
        alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];
        if (!alphaMaskFilter) {
          alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()];
        }
      }
      const renderer = this.renderer;
      const renderTextureSystem = renderer.renderTexture;
      let resolution;
      let multisample;
      if (renderTextureSystem.current) {
        const renderTexture = renderTextureSystem.current;
        resolution = maskData.resolution || renderTexture.resolution;
        multisample = maskData.multisample ?? renderTexture.multisample;
      } else {
        resolution = maskData.resolution || renderer.resolution;
        multisample = maskData.multisample ?? renderer.multisample;
      }
      alphaMaskFilter[0].resolution = resolution;
      alphaMaskFilter[0].multisample = multisample;
      alphaMaskFilter[0].maskSprite = maskObject;
      const stashFilterArea = target2.filterArea;
      target2.filterArea = maskObject.getBounds(true);
      renderer.filter.push(target2, alphaMaskFilter);
      target2.filterArea = stashFilterArea;
      if (!maskData._filters) {
        this.alphaMaskIndex++;
      }
    }
    popSpriteMask(maskData) {
      this.renderer.filter.pop();
      if (maskData._filters) {
        maskData._filters[0].maskSprite = null;
      } else {
        this.alphaMaskIndex--;
        this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null;
      }
    }
    pushColorMask(maskData) {
      const currColorMask = maskData._colorMask;
      const nextColorMask = maskData._colorMask = currColorMask & maskData.colorMask;
      if (nextColorMask !== currColorMask) {
        this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);
      }
    }
    popColorMask(maskData) {
      const currColorMask = maskData._colorMask;
      const nextColorMask = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
      if (nextColorMask !== currColorMask) {
        this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);
      }
    }
    destroy() {
      this.renderer = null;
    }
  };
  MaskSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "mask"
  };
  extensions$1.add(MaskSystem);
  var AbstractMaskSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
      this.maskStack = [];
      this.glConst = 0;
    }
    getStackLength() {
      return this.maskStack.length;
    }
    setMaskStack(maskStack) {
      const { gl } = this.renderer;
      const curStackLen = this.getStackLength();
      this.maskStack = maskStack;
      const newStackLen = this.getStackLength();
      if (newStackLen !== curStackLen) {
        if (newStackLen === 0) {
          gl.disable(this.glConst);
        } else {
          gl.enable(this.glConst);
          this._useCurrent();
        }
      }
    }
    _useCurrent() {
    }
    destroy() {
      this.renderer = null;
      this.maskStack = null;
    }
  };
  var tempMatrix$1 = new Matrix();
  var rectPool = [];
  var _ScissorSystem = class extends AbstractMaskSystem {
    constructor(renderer) {
      super(renderer);
      this.glConst = settings.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST;
    }
    getStackLength() {
      const maskData = this.maskStack[this.maskStack.length - 1];
      if (maskData) {
        return maskData._scissorCounter;
      }
      return 0;
    }
    calcScissorRect(maskData) {
      if (maskData._scissorRectLocal) {
        return;
      }
      const prevData = maskData._scissorRect;
      const { maskObject } = maskData;
      const { renderer } = this;
      const renderTextureSystem = renderer.renderTexture;
      const rect = maskObject.getBounds(true, rectPool.pop() ?? new Rectangle());
      this.roundFrameToPixels(rect, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);
      if (prevData) {
        rect.fit(prevData);
      }
      maskData._scissorRectLocal = rect;
    }
    static isMatrixRotated(matrix) {
      if (!matrix) {
        return false;
      }
      const { a: a2, b: b2, c, d } = matrix;
      return (Math.abs(b2) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a2) > 1e-4 || Math.abs(d) > 1e-4);
    }
    testScissor(maskData) {
      const { maskObject } = maskData;
      if (!maskObject.isFastRect || !maskObject.isFastRect()) {
        return false;
      }
      if (_ScissorSystem.isMatrixRotated(maskObject.worldTransform)) {
        return false;
      }
      if (_ScissorSystem.isMatrixRotated(this.renderer.projection.transform)) {
        return false;
      }
      this.calcScissorRect(maskData);
      const rect = maskData._scissorRectLocal;
      return rect.width > 0 && rect.height > 0;
    }
    roundFrameToPixels(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
      if (_ScissorSystem.isMatrixRotated(transform)) {
        return;
      }
      transform = transform ? tempMatrix$1.copyFrom(transform) : tempMatrix$1.identity();
      transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
      this.renderer.filter.transformAABB(transform, frame);
      frame.fit(bindingDestinationFrame);
      frame.x = Math.round(frame.x * resolution);
      frame.y = Math.round(frame.y * resolution);
      frame.width = Math.round(frame.width * resolution);
      frame.height = Math.round(frame.height * resolution);
    }
    push(maskData) {
      if (!maskData._scissorRectLocal) {
        this.calcScissorRect(maskData);
      }
      const { gl } = this.renderer;
      if (!maskData._scissorRect) {
        gl.enable(gl.SCISSOR_TEST);
      }
      maskData._scissorCounter++;
      maskData._scissorRect = maskData._scissorRectLocal;
      this._useCurrent();
    }
    pop(maskData) {
      const { gl } = this.renderer;
      if (maskData) {
        rectPool.push(maskData._scissorRectLocal);
      }
      if (this.getStackLength() > 0) {
        this._useCurrent();
      } else {
        gl.disable(gl.SCISSOR_TEST);
      }
    }
    _useCurrent() {
      const rect = this.maskStack[this.maskStack.length - 1]._scissorRect;
      let y;
      if (this.renderer.renderTexture.current) {
        y = rect.y;
      } else {
        y = this.renderer.height - rect.height - rect.y;
      }
      this.renderer.gl.scissor(rect.x, y, rect.width, rect.height);
    }
  };
  var ScissorSystem = _ScissorSystem;
  ScissorSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "scissor"
  };
  extensions$1.add(ScissorSystem);
  var StencilSystem = class extends AbstractMaskSystem {
    constructor(renderer) {
      super(renderer);
      this.glConst = settings.ADAPTER.getWebGLRenderingContext().STENCIL_TEST;
    }
    getStackLength() {
      const maskData = this.maskStack[this.maskStack.length - 1];
      if (maskData) {
        return maskData._stencilCounter;
      }
      return 0;
    }
    push(maskData) {
      const maskObject = maskData.maskObject;
      const { gl } = this.renderer;
      const prevMaskCount = maskData._stencilCounter;
      if (prevMaskCount === 0) {
        this.renderer.framebuffer.forceStencil();
        gl.clearStencil(0);
        gl.clear(gl.STENCIL_BUFFER_BIT);
        gl.enable(gl.STENCIL_TEST);
      }
      maskData._stencilCounter++;
      const colorMask = maskData._colorMask;
      if (colorMask !== 0) {
        maskData._colorMask = 0;
        gl.colorMask(false, false, false, false);
      }
      gl.stencilFunc(gl.EQUAL, prevMaskCount, 4294967295);
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
      maskObject.renderable = true;
      maskObject.render(this.renderer);
      this.renderer.batch.flush();
      maskObject.renderable = false;
      if (colorMask !== 0) {
        maskData._colorMask = colorMask;
        gl.colorMask((colorMask & 1) !== 0, (colorMask & 2) !== 0, (colorMask & 4) !== 0, (colorMask & 8) !== 0);
      }
      this._useCurrent();
    }
    pop(maskObject) {
      const gl = this.renderer.gl;
      if (this.getStackLength() === 0) {
        gl.disable(gl.STENCIL_TEST);
      } else {
        const maskData = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
        const colorMask = maskData ? maskData._colorMask : 15;
        if (colorMask !== 0) {
          maskData._colorMask = 0;
          gl.colorMask(false, false, false, false);
        }
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
        maskObject.renderable = true;
        maskObject.render(this.renderer);
        this.renderer.batch.flush();
        maskObject.renderable = false;
        if (colorMask !== 0) {
          maskData._colorMask = colorMask;
          gl.colorMask((colorMask & 1) !== 0, (colorMask & 2) !== 0, (colorMask & 4) !== 0, (colorMask & 8) !== 0);
        }
        this._useCurrent();
      }
    }
    _useCurrent() {
      const gl = this.renderer.gl;
      gl.stencilFunc(gl.EQUAL, this.getStackLength(), 4294967295);
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    }
  };
  StencilSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "stencil"
  };
  extensions$1.add(StencilSystem);
  var ProjectionSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
      this.destinationFrame = null;
      this.sourceFrame = null;
      this.defaultFrame = null;
      this.projectionMatrix = new Matrix();
      this.transform = null;
    }
    update(destinationFrame, sourceFrame, resolution, root2) {
      this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
      this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;
      this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root2);
      if (this.transform) {
        this.projectionMatrix.append(this.transform);
      }
      const renderer = this.renderer;
      renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix;
      renderer.globalUniforms.update();
      if (renderer.shader.shader) {
        renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);
      }
    }
    calculateProjection(_destinationFrame, sourceFrame, _resolution, root2) {
      const pm = this.projectionMatrix;
      const sign3 = !root2 ? 1 : -1;
      pm.identity();
      pm.a = 1 / sourceFrame.width * 2;
      pm.d = sign3 * (1 / sourceFrame.height * 2);
      pm.tx = -1 - sourceFrame.x * pm.a;
      pm.ty = -sign3 - sourceFrame.y * pm.d;
    }
    setTransform(_matrix) {
    }
    destroy() {
      this.renderer = null;
    }
  };
  ProjectionSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "projection"
  };
  extensions$1.add(ProjectionSystem);
  var tempRect = new Rectangle();
  var tempRect2 = new Rectangle();
  var RenderTextureSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
      this.defaultMaskStack = [];
      this.current = null;
      this.sourceFrame = new Rectangle();
      this.destinationFrame = new Rectangle();
      this.viewportFrame = new Rectangle();
    }
    bind(renderTexture = null, sourceFrame, destinationFrame) {
      const renderer = this.renderer;
      this.current = renderTexture;
      let baseTexture;
      let framebuffer;
      let resolution;
      if (renderTexture) {
        baseTexture = renderTexture.baseTexture;
        resolution = baseTexture.resolution;
        if (!sourceFrame) {
          tempRect.width = renderTexture.frame.width;
          tempRect.height = renderTexture.frame.height;
          sourceFrame = tempRect;
        }
        if (!destinationFrame) {
          tempRect2.x = renderTexture.frame.x;
          tempRect2.y = renderTexture.frame.y;
          tempRect2.width = sourceFrame.width;
          tempRect2.height = sourceFrame.height;
          destinationFrame = tempRect2;
        }
        framebuffer = baseTexture.framebuffer;
      } else {
        resolution = renderer.resolution;
        if (!sourceFrame) {
          tempRect.width = renderer._view.screen.width;
          tempRect.height = renderer._view.screen.height;
          sourceFrame = tempRect;
        }
        if (!destinationFrame) {
          destinationFrame = tempRect;
          destinationFrame.width = sourceFrame.width;
          destinationFrame.height = sourceFrame.height;
        }
      }
      const viewportFrame = this.viewportFrame;
      viewportFrame.x = destinationFrame.x * resolution;
      viewportFrame.y = destinationFrame.y * resolution;
      viewportFrame.width = destinationFrame.width * resolution;
      viewportFrame.height = destinationFrame.height * resolution;
      if (!renderTexture) {
        viewportFrame.y = renderer.view.height - (viewportFrame.y + viewportFrame.height);
      }
      viewportFrame.ceil();
      this.renderer.framebuffer.bind(framebuffer, viewportFrame);
      this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer);
      if (renderTexture) {
        this.renderer.mask.setMaskStack(baseTexture.maskStack);
      } else {
        this.renderer.mask.setMaskStack(this.defaultMaskStack);
      }
      this.sourceFrame.copyFrom(sourceFrame);
      this.destinationFrame.copyFrom(destinationFrame);
    }
    clear(clearColor, mask) {
      if (this.current) {
        clearColor = clearColor || this.current.baseTexture.clearColor;
      } else {
        clearColor = clearColor || this.renderer.background.colorRgba;
      }
      const destinationFrame = this.destinationFrame;
      const baseFrame = this.current ? this.current.baseTexture : this.renderer._view.screen;
      const clearMask = destinationFrame.width !== baseFrame.width || destinationFrame.height !== baseFrame.height;
      if (clearMask) {
        let { x, y, width, height } = this.viewportFrame;
        x = Math.round(x);
        y = Math.round(y);
        width = Math.round(width);
        height = Math.round(height);
        this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);
        this.renderer.gl.scissor(x, y, width, height);
      }
      this.renderer.framebuffer.clear(clearColor[0], clearColor[1], clearColor[2], clearColor[3], mask);
      if (clearMask) {
        this.renderer.scissor.pop();
      }
    }
    resize() {
      this.bind(null);
    }
    reset() {
      this.bind(null);
    }
    destroy() {
      this.renderer = null;
    }
  };
  RenderTextureSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "renderTexture"
  };
  extensions$1.add(RenderTextureSystem);
  function uboUpdate(_ud, _uv, _renderer, _syncData, buffer) {
    _renderer.buffer.update(buffer);
  }
  var UBO_TO_SINGLE_SETTERS = {
    float: `
        data[offset] = v;
    `,
    vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
    vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
    vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
    mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
    mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
    mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
  };
  var GLSL_TO_STD40_SIZE = {
    float: 4,
    vec2: 8,
    vec3: 12,
    vec4: 16,
    int: 4,
    ivec2: 8,
    ivec3: 12,
    ivec4: 16,
    uint: 4,
    uvec2: 8,
    uvec3: 12,
    uvec4: 16,
    bool: 4,
    bvec2: 8,
    bvec3: 12,
    bvec4: 16,
    mat2: 16 * 2,
    mat3: 16 * 3,
    mat4: 16 * 4
  };
  function createUBOElements(uniformData) {
    const uboElements = uniformData.map((data) => ({
      data,
      offset: 0,
      dataLen: 0,
      dirty: 0
    }));
    let size = 0;
    let chunkSize = 0;
    let offset = 0;
    for (let i = 0; i < uboElements.length; i++) {
      const uboElement = uboElements[i];
      size = GLSL_TO_STD40_SIZE[uboElement.data.type];
      if (uboElement.data.size > 1) {
        size = Math.max(size, 16) * uboElement.data.size;
      }
      uboElement.dataLen = size;
      if (chunkSize % size !== 0 && chunkSize < 16) {
        const lineUpValue = chunkSize % size % 16;
        chunkSize += lineUpValue;
        offset += lineUpValue;
      }
      if (chunkSize + size > 16) {
        offset = Math.ceil(offset / 16) * 16;
        uboElement.offset = offset;
        offset += size;
        chunkSize = size;
      } else {
        uboElement.offset = offset;
        chunkSize += size;
        offset += size;
      }
    }
    offset = Math.ceil(offset / 16) * 16;
    return { uboElements, size: offset };
  }
  function getUBOData(uniforms, uniformData) {
    const usedUniformDatas = [];
    for (const i in uniforms) {
      if (uniformData[i]) {
        usedUniformDatas.push(uniformData[i]);
      }
    }
    usedUniformDatas.sort((a2, b2) => a2.index - b2.index);
    return usedUniformDatas;
  }
  function generateUniformBufferSync(group, uniformData) {
    if (!group.autoManage) {
      return { size: 0, syncFunc: uboUpdate };
    }
    const usedUniformDatas = getUBOData(group.uniforms, uniformData);
    const { uboElements, size } = createUBOElements(usedUniformDatas);
    const funcFragments = [`
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `];
    for (let i = 0; i < uboElements.length; i++) {
      const uboElement = uboElements[i];
      const uniform = group.uniforms[uboElement.data.name];
      const name = uboElement.data.name;
      let parsed = false;
      for (let j = 0; j < uniformParsers.length; j++) {
        const uniformParser = uniformParsers[j];
        if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform)) {
          funcFragments.push(`offset = ${uboElement.offset / 4};`, uniformParsers[j].codeUbo(uboElement.data.name, uniform));
          parsed = true;
          break;
        }
      }
      if (!parsed) {
        if (uboElement.data.size > 1) {
          const size2 = mapSize(uboElement.data.type);
          const rowSize = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
          const elementSize = size2 / rowSize;
          const remainder = (4 - elementSize % 4) % 4;
          funcFragments.push(`
                cv = ud.${name}.value;
                v = uv.${name};
                offset = ${uboElement.offset / 4};

                t = 0;

                for(var i=0; i < ${uboElement.data.size * rowSize}; i++)
                {
                    for(var j = 0; j < ${elementSize}; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ${remainder};
                }

                `);
        } else {
          const template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];
          funcFragments.push(`
                cv = ud.${name}.value;
                v = uv.${name};
                offset = ${uboElement.offset / 4};
                ${template};
                `);
        }
      }
    }
    funcFragments.push(`
       renderer.buffer.update(buffer);
    `);
    return {
      size,
      syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", funcFragments.join("\n"))
    };
  }
  var IGLUniformData = class {
  };
  var GLProgram = class {
    constructor(program, uniformData) {
      this.program = program;
      this.uniformData = uniformData;
      this.uniformGroups = {};
      this.uniformDirtyGroups = {};
      this.uniformBufferBindings = {};
    }
    destroy() {
      this.uniformData = null;
      this.uniformGroups = null;
      this.uniformDirtyGroups = null;
      this.uniformBufferBindings = null;
      this.program = null;
    }
  };
  function getAttributeData(program, gl) {
    const attributes = {};
    const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (let i = 0; i < totalAttributes; i++) {
      const attribData = gl.getActiveAttrib(program, i);
      if (attribData.name.startsWith("gl_")) {
        continue;
      }
      const type = mapType(gl, attribData.type);
      const data = {
        type,
        name: attribData.name,
        size: mapSize(type),
        location: gl.getAttribLocation(program, attribData.name)
      };
      attributes[attribData.name] = data;
    }
    return attributes;
  }
  function getUniformData(program, gl) {
    const uniforms = {};
    const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (let i = 0; i < totalUniforms; i++) {
      const uniformData = gl.getActiveUniform(program, i);
      const name = uniformData.name.replace(/\[.*?\]$/, "");
      const isArray = !!uniformData.name.match(/\[.*?\]$/);
      const type = mapType(gl, uniformData.type);
      uniforms[name] = {
        name,
        index: i,
        type,
        size: uniformData.size,
        isArray,
        value: defaultValue(type, uniformData.size)
      };
    }
    return uniforms;
  }
  function generateProgram(gl, program) {
    const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertexSrc);
    const glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragmentSrc);
    const webGLProgram = gl.createProgram();
    gl.attachShader(webGLProgram, glVertShader);
    gl.attachShader(webGLProgram, glFragShader);
    const transformFeedbackVaryings = program.extra?.transformFeedbackVaryings;
    if (transformFeedbackVaryings) {
      if (typeof gl.transformFeedbackVaryings !== "function") {
        console.warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);
      } else {
        gl.transformFeedbackVaryings(webGLProgram, transformFeedbackVaryings.names, transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS);
      }
    }
    gl.linkProgram(webGLProgram);
    if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
      logProgramError(gl, webGLProgram, glVertShader, glFragShader);
    }
    program.attributeData = getAttributeData(webGLProgram, gl);
    program.uniformData = getUniformData(webGLProgram, gl);
    if (!/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertexSrc)) {
      const keys = Object.keys(program.attributeData);
      keys.sort((a2, b2) => a2 > b2 ? 1 : -1);
      for (let i = 0; i < keys.length; i++) {
        program.attributeData[keys[i]].location = i;
        gl.bindAttribLocation(webGLProgram, i, keys[i]);
      }
      gl.linkProgram(webGLProgram);
    }
    gl.deleteShader(glVertShader);
    gl.deleteShader(glFragShader);
    const uniformData = {};
    for (const i in program.uniformData) {
      const data = program.uniformData[i];
      uniformData[i] = {
        location: gl.getUniformLocation(webGLProgram, i),
        value: defaultValue(data.type, data.size)
      };
    }
    const glProgram = new GLProgram(webGLProgram, uniformData);
    return glProgram;
  }
  var UID = 0;
  var defaultSyncData = { textureCount: 0, uboCount: 0 };
  var ShaderSystem = class {
    constructor(renderer) {
      this.destroyed = false;
      this.renderer = renderer;
      this.systemCheck();
      this.gl = null;
      this.shader = null;
      this.program = null;
      this.cache = {};
      this._uboCache = {};
      this.id = UID++;
    }
    systemCheck() {
      if (!unsafeEvalSupported()) {
        throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
      }
    }
    contextChange(gl) {
      this.gl = gl;
      this.reset();
    }
    bind(shader, dontSync) {
      shader.disposeRunner.add(this);
      shader.uniforms.globals = this.renderer.globalUniforms;
      const program = shader.program;
      const glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(shader);
      this.shader = shader;
      if (this.program !== program) {
        this.program = program;
        this.gl.useProgram(glProgram.program);
      }
      if (!dontSync) {
        defaultSyncData.textureCount = 0;
        defaultSyncData.uboCount = 0;
        this.syncUniformGroup(shader.uniformGroup, defaultSyncData);
      }
      return glProgram;
    }
    setUniforms(uniforms) {
      const shader = this.shader.program;
      const glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];
      shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);
    }
    syncUniformGroup(group, syncData) {
      const glProgram = this.getGlProgram();
      if (!group.static || group.dirtyId !== glProgram.uniformDirtyGroups[group.id]) {
        glProgram.uniformDirtyGroups[group.id] = group.dirtyId;
        this.syncUniforms(group, glProgram, syncData);
      }
    }
    syncUniforms(group, glProgram, syncData) {
      const syncFunc = group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group);
      syncFunc(glProgram.uniformData, group.uniforms, this.renderer, syncData);
    }
    createSyncGroups(group) {
      const id = this.getSignature(group, this.shader.program.uniformData, "u");
      if (!this.cache[id]) {
        this.cache[id] = generateUniformsSync(group, this.shader.program.uniformData);
      }
      group.syncUniforms[this.shader.program.id] = this.cache[id];
      return group.syncUniforms[this.shader.program.id];
    }
    syncUniformBufferGroup(group, name) {
      const glProgram = this.getGlProgram();
      if (!group.static || group.dirtyId !== 0 || !glProgram.uniformGroups[group.id]) {
        group.dirtyId = 0;
        const syncFunc = glProgram.uniformGroups[group.id] || this.createSyncBufferGroup(group, glProgram, name);
        group.buffer.update();
        syncFunc(glProgram.uniformData, group.uniforms, this.renderer, defaultSyncData, group.buffer);
      }
      this.renderer.buffer.bindBufferBase(group.buffer, glProgram.uniformBufferBindings[name]);
    }
    createSyncBufferGroup(group, glProgram, name) {
      const { gl } = this.renderer;
      this.renderer.buffer.bind(group.buffer);
      const uniformBlockIndex = this.gl.getUniformBlockIndex(glProgram.program, name);
      glProgram.uniformBufferBindings[name] = this.shader.uniformBindCount;
      gl.uniformBlockBinding(glProgram.program, uniformBlockIndex, this.shader.uniformBindCount);
      this.shader.uniformBindCount++;
      const id = this.getSignature(group, this.shader.program.uniformData, "ubo");
      let uboData = this._uboCache[id];
      if (!uboData) {
        uboData = this._uboCache[id] = generateUniformBufferSync(group, this.shader.program.uniformData);
      }
      if (group.autoManage) {
        const data = new Float32Array(uboData.size / 4);
        group.buffer.update(data);
      }
      glProgram.uniformGroups[group.id] = uboData.syncFunc;
      return glProgram.uniformGroups[group.id];
    }
    getSignature(group, uniformData, preFix) {
      const uniforms = group.uniforms;
      const strings = [`${preFix}-`];
      for (const i in uniforms) {
        strings.push(i);
        if (uniformData[i]) {
          strings.push(uniformData[i].type);
        }
      }
      return strings.join("-");
    }
    getGlProgram() {
      if (this.shader) {
        return this.shader.program.glPrograms[this.renderer.CONTEXT_UID];
      }
      return null;
    }
    generateProgram(shader) {
      const gl = this.gl;
      const program = shader.program;
      const glProgram = generateProgram(gl, program);
      program.glPrograms[this.renderer.CONTEXT_UID] = glProgram;
      return glProgram;
    }
    reset() {
      this.program = null;
      this.shader = null;
    }
    disposeShader(shader) {
      if (this.shader === shader) {
        this.shader = null;
      }
    }
    destroy() {
      this.renderer = null;
      this.destroyed = true;
    }
  };
  ShaderSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "shader"
  };
  extensions$1.add(ShaderSystem);
  function mapWebGLBlendModesToPixi(gl, array = []) {
    array[BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.ADD] = [gl.ONE, gl.ONE];
    array[BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.NONE] = [0, 0];
    array[BLEND_MODES.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
    array[BLEND_MODES.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];
    array[BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];
    array[BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];
    array[BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];
    array[BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];
    array[BLEND_MODES.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];
    return array;
  }
  var BLEND = 0;
  var OFFSET = 1;
  var CULLING = 2;
  var DEPTH_TEST = 3;
  var WINDING = 4;
  var DEPTH_MASK = 5;
  var _StateSystem = class {
    constructor() {
      this.gl = null;
      this.stateId = 0;
      this.polygonOffset = 0;
      this.blendMode = BLEND_MODES.NONE;
      this._blendEq = false;
      this.map = [];
      this.map[BLEND] = this.setBlend;
      this.map[OFFSET] = this.setOffset;
      this.map[CULLING] = this.setCullFace;
      this.map[DEPTH_TEST] = this.setDepthTest;
      this.map[WINDING] = this.setFrontFace;
      this.map[DEPTH_MASK] = this.setDepthMask;
      this.checks = [];
      this.defaultState = new State();
      this.defaultState.blend = true;
    }
    contextChange(gl) {
      this.gl = gl;
      this.blendModes = mapWebGLBlendModesToPixi(gl);
      this.set(this.defaultState);
      this.reset();
    }
    set(state) {
      state = state || this.defaultState;
      if (this.stateId !== state.data) {
        let diff = this.stateId ^ state.data;
        let i = 0;
        while (diff) {
          if (diff & 1) {
            this.map[i].call(this, !!(state.data & 1 << i));
          }
          diff = diff >> 1;
          i++;
        }
        this.stateId = state.data;
      }
      for (let i = 0; i < this.checks.length; i++) {
        this.checks[i](this, state);
      }
    }
    forceState(state) {
      state = state || this.defaultState;
      for (let i = 0; i < this.map.length; i++) {
        this.map[i].call(this, !!(state.data & 1 << i));
      }
      for (let i = 0; i < this.checks.length; i++) {
        this.checks[i](this, state);
      }
      this.stateId = state.data;
    }
    setBlend(value3) {
      this.updateCheck(_StateSystem.checkBlendMode, value3);
      this.gl[value3 ? "enable" : "disable"](this.gl.BLEND);
    }
    setOffset(value3) {
      this.updateCheck(_StateSystem.checkPolygonOffset, value3);
      this.gl[value3 ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
    }
    setDepthTest(value3) {
      this.gl[value3 ? "enable" : "disable"](this.gl.DEPTH_TEST);
    }
    setDepthMask(value3) {
      this.gl.depthMask(value3);
    }
    setCullFace(value3) {
      this.gl[value3 ? "enable" : "disable"](this.gl.CULL_FACE);
    }
    setFrontFace(value3) {
      this.gl.frontFace(this.gl[value3 ? "CW" : "CCW"]);
    }
    setBlendMode(value3) {
      if (value3 === this.blendMode) {
        return;
      }
      this.blendMode = value3;
      const mode = this.blendModes[value3];
      const gl = this.gl;
      if (mode.length === 2) {
        gl.blendFunc(mode[0], mode[1]);
      } else {
        gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
      }
      if (mode.length === 6) {
        this._blendEq = true;
        gl.blendEquationSeparate(mode[4], mode[5]);
      } else if (this._blendEq) {
        this._blendEq = false;
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
      }
    }
    setPolygonOffset(value3, scale) {
      this.gl.polygonOffset(value3, scale);
    }
    reset() {
      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
      this.forceState(this.defaultState);
      this._blendEq = true;
      this.blendMode = -1;
      this.setBlendMode(0);
    }
    updateCheck(func, value3) {
      const index2 = this.checks.indexOf(func);
      if (value3 && index2 === -1) {
        this.checks.push(func);
      } else if (!value3 && index2 !== -1) {
        this.checks.splice(index2, 1);
      }
    }
    static checkBlendMode(system, state) {
      system.setBlendMode(state.blendMode);
    }
    static checkPolygonOffset(system, state) {
      system.setPolygonOffset(1, state.polygonOffset);
    }
    destroy() {
      this.gl = null;
    }
  };
  var StateSystem = _StateSystem;
  StateSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "state"
  };
  extensions$1.add(StateSystem);
  var TextureGCSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
      this.count = 0;
      this.checkCount = 0;
      this.maxIdle = settings.GC_MAX_IDLE;
      this.checkCountMax = settings.GC_MAX_CHECK_COUNT;
      this.mode = settings.GC_MODE;
    }
    postrender() {
      if (!this.renderer.objectRenderer.renderingToScreen) {
        return;
      }
      this.count++;
      if (this.mode === GC_MODES.MANUAL) {
        return;
      }
      this.checkCount++;
      if (this.checkCount > this.checkCountMax) {
        this.checkCount = 0;
        this.run();
      }
    }
    run() {
      const tm = this.renderer.texture;
      const managedTextures = tm.managedTextures;
      let wasRemoved = false;
      for (let i = 0; i < managedTextures.length; i++) {
        const texture = managedTextures[i];
        if (!texture.framebuffer && this.count - texture.touched > this.maxIdle) {
          tm.destroyTexture(texture, true);
          managedTextures[i] = null;
          wasRemoved = true;
        }
      }
      if (wasRemoved) {
        let j = 0;
        for (let i = 0; i < managedTextures.length; i++) {
          if (managedTextures[i] !== null) {
            managedTextures[j++] = managedTextures[i];
          }
        }
        managedTextures.length = j;
      }
    }
    unload(displayObject) {
      const tm = this.renderer.texture;
      const texture = displayObject._texture;
      if (texture && !texture.framebuffer) {
        tm.destroyTexture(texture);
      }
      for (let i = displayObject.children.length - 1; i >= 0; i--) {
        this.unload(displayObject.children[i]);
      }
    }
    destroy() {
      this.renderer = null;
    }
  };
  TextureGCSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "textureGC"
  };
  extensions$1.add(TextureGCSystem);
  function mapTypeAndFormatToInternalFormat(gl) {
    let table;
    if ("WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext) {
      table = {
        [TYPES.UNSIGNED_BYTE]: {
          [FORMATS.RGBA]: gl.RGBA8,
          [FORMATS.RGB]: gl.RGB8,
          [FORMATS.RG]: gl.RG8,
          [FORMATS.RED]: gl.R8,
          [FORMATS.RGBA_INTEGER]: gl.RGBA8UI,
          [FORMATS.RGB_INTEGER]: gl.RGB8UI,
          [FORMATS.RG_INTEGER]: gl.RG8UI,
          [FORMATS.RED_INTEGER]: gl.R8UI,
          [FORMATS.ALPHA]: gl.ALPHA,
          [FORMATS.LUMINANCE]: gl.LUMINANCE,
          [FORMATS.LUMINANCE_ALPHA]: gl.LUMINANCE_ALPHA
        },
        [TYPES.BYTE]: {
          [FORMATS.RGBA]: gl.RGBA8_SNORM,
          [FORMATS.RGB]: gl.RGB8_SNORM,
          [FORMATS.RG]: gl.RG8_SNORM,
          [FORMATS.RED]: gl.R8_SNORM,
          [FORMATS.RGBA_INTEGER]: gl.RGBA8I,
          [FORMATS.RGB_INTEGER]: gl.RGB8I,
          [FORMATS.RG_INTEGER]: gl.RG8I,
          [FORMATS.RED_INTEGER]: gl.R8I
        },
        [TYPES.UNSIGNED_SHORT]: {
          [FORMATS.RGBA_INTEGER]: gl.RGBA16UI,
          [FORMATS.RGB_INTEGER]: gl.RGB16UI,
          [FORMATS.RG_INTEGER]: gl.RG16UI,
          [FORMATS.RED_INTEGER]: gl.R16UI,
          [FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT16
        },
        [TYPES.SHORT]: {
          [FORMATS.RGBA_INTEGER]: gl.RGBA16I,
          [FORMATS.RGB_INTEGER]: gl.RGB16I,
          [FORMATS.RG_INTEGER]: gl.RG16I,
          [FORMATS.RED_INTEGER]: gl.R16I
        },
        [TYPES.UNSIGNED_INT]: {
          [FORMATS.RGBA_INTEGER]: gl.RGBA32UI,
          [FORMATS.RGB_INTEGER]: gl.RGB32UI,
          [FORMATS.RG_INTEGER]: gl.RG32UI,
          [FORMATS.RED_INTEGER]: gl.R32UI,
          [FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT24
        },
        [TYPES.INT]: {
          [FORMATS.RGBA_INTEGER]: gl.RGBA32I,
          [FORMATS.RGB_INTEGER]: gl.RGB32I,
          [FORMATS.RG_INTEGER]: gl.RG32I,
          [FORMATS.RED_INTEGER]: gl.R32I
        },
        [TYPES.FLOAT]: {
          [FORMATS.RGBA]: gl.RGBA32F,
          [FORMATS.RGB]: gl.RGB32F,
          [FORMATS.RG]: gl.RG32F,
          [FORMATS.RED]: gl.R32F,
          [FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT32F
        },
        [TYPES.HALF_FLOAT]: {
          [FORMATS.RGBA]: gl.RGBA16F,
          [FORMATS.RGB]: gl.RGB16F,
          [FORMATS.RG]: gl.RG16F,
          [FORMATS.RED]: gl.R16F
        },
        [TYPES.UNSIGNED_SHORT_5_6_5]: {
          [FORMATS.RGB]: gl.RGB565
        },
        [TYPES.UNSIGNED_SHORT_4_4_4_4]: {
          [FORMATS.RGBA]: gl.RGBA4
        },
        [TYPES.UNSIGNED_SHORT_5_5_5_1]: {
          [FORMATS.RGBA]: gl.RGB5_A1
        },
        [TYPES.UNSIGNED_INT_2_10_10_10_REV]: {
          [FORMATS.RGBA]: gl.RGB10_A2,
          [FORMATS.RGBA_INTEGER]: gl.RGB10_A2UI
        },
        [TYPES.UNSIGNED_INT_10F_11F_11F_REV]: {
          [FORMATS.RGB]: gl.R11F_G11F_B10F
        },
        [TYPES.UNSIGNED_INT_5_9_9_9_REV]: {
          [FORMATS.RGB]: gl.RGB9_E5
        },
        [TYPES.UNSIGNED_INT_24_8]: {
          [FORMATS.DEPTH_STENCIL]: gl.DEPTH24_STENCIL8
        },
        [TYPES.FLOAT_32_UNSIGNED_INT_24_8_REV]: {
          [FORMATS.DEPTH_STENCIL]: gl.DEPTH32F_STENCIL8
        }
      };
    } else {
      table = {
        [TYPES.UNSIGNED_BYTE]: {
          [FORMATS.RGBA]: gl.RGBA,
          [FORMATS.RGB]: gl.RGB,
          [FORMATS.ALPHA]: gl.ALPHA,
          [FORMATS.LUMINANCE]: gl.LUMINANCE,
          [FORMATS.LUMINANCE_ALPHA]: gl.LUMINANCE_ALPHA
        },
        [TYPES.UNSIGNED_SHORT_5_6_5]: {
          [FORMATS.RGB]: gl.RGB
        },
        [TYPES.UNSIGNED_SHORT_4_4_4_4]: {
          [FORMATS.RGBA]: gl.RGBA
        },
        [TYPES.UNSIGNED_SHORT_5_5_5_1]: {
          [FORMATS.RGBA]: gl.RGBA
        }
      };
    }
    return table;
  }
  var GLTexture = class {
    constructor(texture) {
      this.texture = texture;
      this.width = -1;
      this.height = -1;
      this.dirtyId = -1;
      this.dirtyStyleId = -1;
      this.mipmap = false;
      this.wrapMode = 33071;
      this.type = TYPES.UNSIGNED_BYTE;
      this.internalFormat = FORMATS.RGBA;
      this.samplerType = 0;
    }
  };
  var TextureSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
      this.boundTextures = [];
      this.currentLocation = -1;
      this.managedTextures = [];
      this._unknownBoundTextures = false;
      this.unknownTexture = new BaseTexture();
      this.hasIntegerTextures = false;
    }
    contextChange() {
      const gl = this.gl = this.renderer.gl;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID;
      this.webGLVersion = this.renderer.context.webGLVersion;
      this.internalFormats = mapTypeAndFormatToInternalFormat(gl);
      const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
      this.boundTextures.length = maxTextures;
      for (let i = 0; i < maxTextures; i++) {
        this.boundTextures[i] = null;
      }
      this.emptyTextures = {};
      const emptyTexture2D = new GLTexture(gl.createTexture());
      gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));
      this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;
      this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture());
      gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);
      for (let i = 0; i < 6; i++) {
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      }
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      for (let i = 0; i < this.boundTextures.length; i++) {
        this.bind(null, i);
      }
    }
    bind(texture, location2 = 0) {
      const { gl } = this;
      texture = texture?.castToBaseTexture();
      if (texture?.valid && !texture.parentTextureArray) {
        texture.touched = this.renderer.textureGC.count;
        const glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);
        if (this.boundTextures[location2] !== texture) {
          if (this.currentLocation !== location2) {
            this.currentLocation = location2;
            gl.activeTexture(gl.TEXTURE0 + location2);
          }
          gl.bindTexture(texture.target, glTexture.texture);
        }
        if (glTexture.dirtyId !== texture.dirtyId) {
          if (this.currentLocation !== location2) {
            this.currentLocation = location2;
            gl.activeTexture(gl.TEXTURE0 + location2);
          }
          this.updateTexture(texture);
        } else if (glTexture.dirtyStyleId !== texture.dirtyStyleId) {
          this.updateTextureStyle(texture);
        }
        this.boundTextures[location2] = texture;
      } else {
        if (this.currentLocation !== location2) {
          this.currentLocation = location2;
          gl.activeTexture(gl.TEXTURE0 + location2);
        }
        gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);
        this.boundTextures[location2] = null;
      }
    }
    reset() {
      this._unknownBoundTextures = true;
      this.hasIntegerTextures = false;
      this.currentLocation = -1;
      for (let i = 0; i < this.boundTextures.length; i++) {
        this.boundTextures[i] = this.unknownTexture;
      }
    }
    unbind(texture) {
      const { gl, boundTextures } = this;
      if (this._unknownBoundTextures) {
        this._unknownBoundTextures = false;
        for (let i = 0; i < boundTextures.length; i++) {
          if (boundTextures[i] === this.unknownTexture) {
            this.bind(null, i);
          }
        }
      }
      for (let i = 0; i < boundTextures.length; i++) {
        if (boundTextures[i] === texture) {
          if (this.currentLocation !== i) {
            gl.activeTexture(gl.TEXTURE0 + i);
            this.currentLocation = i;
          }
          gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture);
          boundTextures[i] = null;
        }
      }
    }
    ensureSamplerType(maxTextures) {
      const { boundTextures, hasIntegerTextures, CONTEXT_UID } = this;
      if (!hasIntegerTextures) {
        return;
      }
      for (let i = maxTextures - 1; i >= 0; --i) {
        const tex = boundTextures[i];
        if (tex) {
          const glTexture = tex._glTextures[CONTEXT_UID];
          if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT) {
            this.renderer.texture.unbind(tex);
          }
        }
      }
    }
    initTexture(texture) {
      const glTexture = new GLTexture(this.gl.createTexture());
      glTexture.dirtyId = -1;
      texture._glTextures[this.CONTEXT_UID] = glTexture;
      this.managedTextures.push(texture);
      texture.on("dispose", this.destroyTexture, this);
      return glTexture;
    }
    initTextureType(texture, glTexture) {
      glTexture.internalFormat = this.internalFormats[texture.type]?.[texture.format] ?? texture.format;
      if (this.webGLVersion === 2 && texture.type === TYPES.HALF_FLOAT) {
        glTexture.type = this.gl.HALF_FLOAT;
      } else {
        glTexture.type = texture.type;
      }
    }
    updateTexture(texture) {
      const glTexture = texture._glTextures[this.CONTEXT_UID];
      if (!glTexture) {
        return;
      }
      const renderer = this.renderer;
      this.initTextureType(texture, glTexture);
      if (texture.resource?.upload(renderer, texture, glTexture)) {
        if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT) {
          this.hasIntegerTextures = true;
        }
      } else {
        const width = texture.realWidth;
        const height = texture.realHeight;
        const gl = renderer.gl;
        if (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) {
          glTexture.width = width;
          glTexture.height = height;
          gl.texImage2D(texture.target, 0, glTexture.internalFormat, width, height, 0, texture.format, glTexture.type, null);
        }
      }
      if (texture.dirtyStyleId !== glTexture.dirtyStyleId) {
        this.updateTextureStyle(texture);
      }
      glTexture.dirtyId = texture.dirtyId;
    }
    destroyTexture(texture, skipRemove) {
      const { gl } = this;
      texture = texture.castToBaseTexture();
      if (texture._glTextures[this.CONTEXT_UID]) {
        this.unbind(texture);
        gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);
        texture.off("dispose", this.destroyTexture, this);
        delete texture._glTextures[this.CONTEXT_UID];
        if (!skipRemove) {
          const i = this.managedTextures.indexOf(texture);
          if (i !== -1) {
            removeItems(this.managedTextures, i, 1);
          }
        }
      }
    }
    updateTextureStyle(texture) {
      const glTexture = texture._glTextures[this.CONTEXT_UID];
      if (!glTexture) {
        return;
      }
      if ((texture.mipmap === MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo) {
        glTexture.mipmap = false;
      } else {
        glTexture.mipmap = texture.mipmap >= 1;
      }
      if (this.webGLVersion !== 2 && !texture.isPowerOfTwo) {
        glTexture.wrapMode = WRAP_MODES.CLAMP;
      } else {
        glTexture.wrapMode = texture.wrapMode;
      }
      if (texture.resource?.style(this.renderer, texture, glTexture)) {
      } else {
        this.setStyle(texture, glTexture);
      }
      glTexture.dirtyStyleId = texture.dirtyStyleId;
    }
    setStyle(texture, glTexture) {
      const gl = this.gl;
      if (glTexture.mipmap && texture.mipmap !== MIPMAP_MODES.ON_MANUAL) {
        gl.generateMipmap(texture.target);
      }
      gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);
      gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);
      if (glTexture.mipmap) {
        gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
        const anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;
        if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === SCALE_MODES.LINEAR) {
          const level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
          gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
        }
      } else {
        gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
      }
      gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
    }
    destroy() {
      this.renderer = null;
    }
  };
  TextureSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "texture"
  };
  extensions$1.add(TextureSystem);
  var tempTransform = new Transform();
  var GenerateTextureSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
      this._tempMatrix = new Matrix();
    }
    generateTexture(displayObject, options) {
      const { region: manualRegion, ...textureOptions } = options || {};
      const region = manualRegion || displayObject.getLocalBounds(null, true);
      if (region.width === 0)
        region.width = 1;
      if (region.height === 0)
        region.height = 1;
      const renderTexture = RenderTexture.create({
        width: region.width,
        height: region.height,
        ...textureOptions
      });
      this._tempMatrix.tx = -region.x;
      this._tempMatrix.ty = -region.y;
      const transform = displayObject.transform;
      displayObject.transform = tempTransform;
      this.renderer.render(displayObject, {
        renderTexture,
        transform: this._tempMatrix,
        skipUpdateTransform: !!displayObject.parent,
        blit: true
      });
      displayObject.transform = transform;
      return renderTexture;
    }
    destroy() {
    }
  };
  GenerateTextureSystem.extension = {
    type: [
      ExtensionType.RendererSystem,
      ExtensionType.CanvasRendererSystem
    ],
    name: "textureGenerator"
  };
  extensions$1.add(GenerateTextureSystem);
  var BackgroundSystem = class {
    constructor() {
      this.clearBeforeRender = true;
      this._backgroundColor = 0;
      this._backgroundColorRgba = [0, 0, 0, 1];
      this._backgroundColorString = "#000000";
      this.color = this._backgroundColor;
      this.alpha = 1;
    }
    init(options) {
      this.clearBeforeRender = options.clearBeforeRender;
      if (options.color) {
        this.color = typeof options.color === "string" ? string2hex(options.color) : options.color;
      }
      this.alpha = options.alpha;
    }
    get color() {
      return this._backgroundColor;
    }
    set color(value3) {
      this._backgroundColor = value3;
      this._backgroundColorString = hex2string(value3);
      hex2rgb(value3, this._backgroundColorRgba);
    }
    get alpha() {
      return this._backgroundColorRgba[3];
    }
    set alpha(value3) {
      this._backgroundColorRgba[3] = value3;
    }
    get colorRgba() {
      return this._backgroundColorRgba;
    }
    get colorString() {
      return this._backgroundColorString;
    }
    destroy() {
    }
  };
  BackgroundSystem.extension = {
    type: [
      ExtensionType.RendererSystem,
      ExtensionType.CanvasRendererSystem
    ],
    name: "background"
  };
  extensions$1.add(BackgroundSystem);
  var ViewSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
    }
    init(options) {
      this.screen = new Rectangle(0, 0, options.width, options.height);
      this.element = options.view || settings.ADAPTER.createCanvas();
      this.resolution = options.resolution || settings.RESOLUTION;
      this.autoDensity = !!options.autoDensity;
    }
    resizeView(desiredScreenWidth, desiredScreenHeight) {
      this.element.width = Math.round(desiredScreenWidth * this.resolution);
      this.element.height = Math.round(desiredScreenHeight * this.resolution);
      const screenWidth = this.element.width / this.resolution;
      const screenHeight = this.element.height / this.resolution;
      this.screen.width = screenWidth;
      this.screen.height = screenHeight;
      if (this.autoDensity) {
        this.element.style.width = `${screenWidth}px`;
        this.element.style.height = `${screenHeight}px`;
      }
      this.renderer.emit("resize", screenWidth, screenHeight);
      this.renderer.runners.resize.emit(this.screen.width, this.screen.height);
    }
    destroy(removeView) {
      if (removeView) {
        this.element.parentNode?.removeChild(this.element);
      }
      this.renderer = null;
      this.element = null;
      this.screen = null;
    }
  };
  ViewSystem.extension = {
    type: [
      ExtensionType.RendererSystem,
      ExtensionType.CanvasRendererSystem
    ],
    name: "_view"
  };
  extensions$1.add(ViewSystem);
  var PluginSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
      this.plugins = {};
      Object.defineProperties(this.plugins, {
        extract: {
          enumerable: false,
          get() {
            deprecation("7.0.0", "renderer.plugins.extract has moved to renderer.extract");
            return renderer.extract;
          }
        },
        prepare: {
          enumerable: false,
          get() {
            deprecation("7.0.0", "renderer.plugins.prepare has moved to renderer.prepare");
            return renderer.prepare;
          }
        },
        interaction: {
          enumerable: false,
          get() {
            deprecation("7.0.0", "renderer.plugins.interaction has been deprecated, use renderer.events");
            return renderer.events;
          }
        }
      });
    }
    init(staticMap) {
      for (const o in staticMap) {
        this.plugins[o] = new staticMap[o](this.renderer);
      }
    }
    destroy() {
      for (const o in this.plugins) {
        this.plugins[o].destroy();
        this.plugins[o] = null;
      }
    }
  };
  PluginSystem.extension = {
    type: [
      ExtensionType.RendererSystem,
      ExtensionType.CanvasRendererSystem
    ],
    name: "_plugin"
  };
  extensions$1.add(PluginSystem);
  var SystemManager = class extends eventemitter3 {
    constructor() {
      super(...arguments);
      this.runners = {};
      this._systemsHash = {};
    }
    setup(config) {
      this.addRunners(...config.runners);
      const priority = (config.priority ?? []).filter((key) => config.systems[key]);
      const orderByPriority = [
        ...priority,
        ...Object.keys(config.systems).filter((key) => !priority.includes(key))
      ];
      for (const i of orderByPriority) {
        this.addSystem(config.systems[i], i);
      }
    }
    addRunners(...runnerIds) {
      runnerIds.forEach((runnerId) => {
        this.runners[runnerId] = new Runner(runnerId);
      });
    }
    addSystem(ClassRef, name) {
      const system = new ClassRef(this);
      if (this[name]) {
        throw new Error(`Whoops! The name "${name}" is already in use`);
      }
      this[name] = system;
      this._systemsHash[name] = system;
      for (const i in this.runners) {
        this.runners[i].add(system);
      }
      return this;
    }
    emitWithCustomOptions(runner, options) {
      const systemHashKeys = Object.keys(this._systemsHash);
      runner.items.forEach((system) => {
        const systemName = systemHashKeys.find((systemId) => this._systemsHash[systemId] === system);
        system[runner.name](options[systemName]);
      });
    }
    destroy() {
      Object.values(this.runners).forEach((runner) => {
        runner.destroy();
      });
      this._systemsHash = {};
    }
  };
  var StartupSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
    }
    run(options) {
      const renderer = this.renderer;
      renderer.emitWithCustomOptions(renderer.runners.init, options);
      if (options.hello) {
        console.log(`PixiJS ${"7.0.5"} - ${renderer.rendererLogId} - https://pixijs.com`);
      }
      renderer.resize(this.renderer.screen.width, this.renderer.screen.height);
    }
    destroy() {
    }
  };
  StartupSystem.extension = {
    type: [
      ExtensionType.RendererSystem,
      ExtensionType.CanvasRendererSystem
    ],
    name: "startup"
  };
  extensions$1.add(StartupSystem);
  var TransformFeedbackSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
    }
    contextChange() {
      this.gl = this.renderer.gl;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    }
    bind(transformFeedback) {
      const { gl, CONTEXT_UID } = this;
      const glTransformFeedback = transformFeedback._glTransformFeedbacks[CONTEXT_UID] || this.createGLTransformFeedback(transformFeedback);
      gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);
    }
    unbind() {
      const { gl } = this;
      gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
    }
    beginTransformFeedback(drawMode, shader) {
      const { gl, renderer } = this;
      if (shader) {
        renderer.shader.bind(shader);
      }
      gl.beginTransformFeedback(drawMode);
    }
    endTransformFeedback() {
      const { gl } = this;
      gl.endTransformFeedback();
    }
    createGLTransformFeedback(tf) {
      const { gl, renderer, CONTEXT_UID } = this;
      const glTransformFeedback = gl.createTransformFeedback();
      tf._glTransformFeedbacks[CONTEXT_UID] = glTransformFeedback;
      gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);
      for (let i = 0; i < tf.buffers.length; i++) {
        const buffer = tf.buffers[i];
        if (!buffer)
          continue;
        renderer.buffer.update(buffer);
        buffer._glBuffers[CONTEXT_UID].refCount++;
        gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i, buffer._glBuffers[CONTEXT_UID].buffer || null);
      }
      gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
      tf.disposeRunner.add(this);
      return glTransformFeedback;
    }
    disposeTransformFeedback(tf, contextLost) {
      const glTF = tf._glTransformFeedbacks[this.CONTEXT_UID];
      const gl = this.gl;
      tf.disposeRunner.remove(this);
      const bufferSystem = this.renderer.buffer;
      if (bufferSystem) {
        for (let i = 0; i < tf.buffers.length; i++) {
          const buffer = tf.buffers[i];
          if (!buffer)
            continue;
          const buf = buffer._glBuffers[this.CONTEXT_UID];
          if (buf) {
            buf.refCount--;
            if (buf.refCount === 0 && !contextLost) {
              bufferSystem.dispose(buffer, contextLost);
            }
          }
        }
      }
      if (!glTF) {
        return;
      }
      if (!contextLost) {
        gl.deleteTransformFeedback(glTF);
      }
      delete tf._glTransformFeedbacks[this.CONTEXT_UID];
    }
    destroy() {
      this.renderer = null;
    }
  };
  TransformFeedbackSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "transformFeedback"
  };
  extensions$1.add(TransformFeedbackSystem);
  var renderers = [];
  extensions$1.handleByList(ExtensionType.Renderer, renderers);
  function autoDetectRenderer(options) {
    for (const RendererType of renderers) {
      if (RendererType.test(options)) {
        return new RendererType(options);
      }
    }
    throw new Error("Unable to auto-detect a suitable renderer.");
  }
  var $defaultVertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
  var $defaultFilterVertex = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
  var defaultVertex$1 = $defaultVertex;
  var defaultFilterVertex = $defaultFilterVertex;
  var _Renderer = class extends SystemManager {
    constructor(options) {
      super();
      options = Object.assign({}, settings.RENDER_OPTIONS, options);
      this.gl = null;
      this.CONTEXT_UID = 0;
      this.globalUniforms = new UniformGroup({
        projectionMatrix: new Matrix()
      }, true);
      const systemConfig = {
        runners: [
          "init",
          "destroy",
          "contextChange",
          "resolutionChange",
          "reset",
          "update",
          "postrender",
          "prerender",
          "resize"
        ],
        systems: _Renderer.__systems,
        priority: [
          "_view",
          "textureGenerator",
          "background",
          "_plugin",
          "startup",
          "context",
          "state",
          "texture",
          "buffer",
          "geometry",
          "framebuffer",
          "transformFeedback",
          "mask",
          "scissor",
          "stencil",
          "projection",
          "textureGC",
          "filter",
          "renderTexture",
          "batch",
          "objectRenderer",
          "_multisample"
        ]
      };
      this.setup(systemConfig);
      if ("useContextAlpha" in options) {
        deprecation("7.0.0", "options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead");
        options.premultipliedAlpha = options.useContextAlpha && options.useContextAlpha !== "notMultiplied";
        options.backgroundAlpha = options.useContextAlpha === false ? 1 : options.backgroundAlpha;
      }
      const startupOptions = {
        hello: options.hello,
        _plugin: _Renderer.__plugins,
        background: {
          alpha: options.backgroundAlpha,
          color: options.background ?? options.backgroundColor,
          clearBeforeRender: options.clearBeforeRender
        },
        _view: {
          height: options.height,
          width: options.width,
          autoDensity: options.autoDensity,
          resolution: options.resolution,
          view: options.view
        },
        context: {
          antialias: options.antialias,
          context: options.context,
          powerPreference: options.powerPreference,
          premultipliedAlpha: options.premultipliedAlpha,
          preserveDrawingBuffer: options.preserveDrawingBuffer
        }
      };
      this.startup.run(startupOptions);
    }
    static test(options) {
      if (options?.forceCanvas) {
        return false;
      }
      return isWebGLSupported();
    }
    render(displayObject, options) {
      this.objectRenderer.render(displayObject, options);
    }
    resize(desiredScreenWidth, desiredScreenHeight) {
      this._view.resizeView(desiredScreenWidth, desiredScreenHeight);
    }
    reset() {
      this.runners.reset.emit();
      return this;
    }
    clear() {
      this.renderTexture.bind();
      this.renderTexture.clear();
    }
    destroy(removeView = false) {
      this.runners.destroy.items.reverse();
      this.emitWithCustomOptions(this.runners.destroy, {
        _view: removeView
      });
      super.destroy();
    }
    get plugins() {
      return this._plugin.plugins;
    }
    get multisample() {
      return this._multisample.multisample;
    }
    get width() {
      return this._view.element.width;
    }
    get height() {
      return this._view.element.height;
    }
    get resolution() {
      return this._view.resolution;
    }
    set resolution(value3) {
      this._view.resolution = value3;
      this.runners.resolutionChange.emit(value3);
    }
    get autoDensity() {
      return this._view.autoDensity;
    }
    get view() {
      return this._view.element;
    }
    get screen() {
      return this._view.screen;
    }
    get lastObjectRendered() {
      return this.objectRenderer.lastObjectRendered;
    }
    get renderingToScreen() {
      return this.objectRenderer.renderingToScreen;
    }
    get rendererLogId() {
      return `WebGL ${this.context.webGLVersion}`;
    }
    get clearBeforeRender() {
      deprecation("7.0.0", "renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead.");
      return this.background.clearBeforeRender;
    }
    get useContextAlpha() {
      deprecation("7.0.0", "renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead.");
      return this.context.useContextAlpha;
    }
    get preserveDrawingBuffer() {
      deprecation("7.0.0", "renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context");
      return this.context.preserveDrawingBuffer;
    }
    get backgroundColor() {
      deprecation("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead.");
      return this.background.color;
    }
    set backgroundColor(value3) {
      deprecation("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead.");
      this.background.color = value3;
    }
    get backgroundAlpha() {
      deprecation("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead.");
      return this.background.color;
    }
    set backgroundAlpha(value3) {
      deprecation("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead.");
      this.background.alpha = value3;
    }
    get powerPreference() {
      deprecation("7.0.0", "renderer.powerPreference has been deprecated, we can only know this if pixi creates the context");
      return this.context.powerPreference;
    }
    generateTexture(displayObject, options) {
      return this.textureGenerator.generateTexture(displayObject, options);
    }
  };
  var Renderer = _Renderer;
  Renderer.extension = {
    type: ExtensionType.Renderer,
    priority: 1
  };
  Renderer.__plugins = {};
  Renderer.__systems = {};
  extensions$1.handleByMap(ExtensionType.RendererPlugin, Renderer.__plugins);
  extensions$1.handleByMap(ExtensionType.RendererSystem, Renderer.__systems);
  extensions$1.add(Renderer);
  var BatchDrawCall = class {
    constructor() {
      this.texArray = null;
      this.blend = 0;
      this.type = DRAW_MODES.TRIANGLES;
      this.start = 0;
      this.size = 0;
      this.data = null;
    }
  };
  var BatchTextureArray = class {
    constructor() {
      this.elements = [];
      this.ids = [];
      this.count = 0;
    }
    clear() {
      for (let i = 0; i < this.count; i++) {
        this.elements[i] = null;
      }
      this.count = 0;
    }
  };
  var ViewableBuffer = class {
    constructor(sizeOrBuffer) {
      if (typeof sizeOrBuffer === "number") {
        this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
      } else if (sizeOrBuffer instanceof Uint8Array) {
        this.rawBinaryData = sizeOrBuffer.buffer;
      } else {
        this.rawBinaryData = sizeOrBuffer;
      }
      this.uint32View = new Uint32Array(this.rawBinaryData);
      this.float32View = new Float32Array(this.rawBinaryData);
    }
    get int8View() {
      if (!this._int8View) {
        this._int8View = new Int8Array(this.rawBinaryData);
      }
      return this._int8View;
    }
    get uint8View() {
      if (!this._uint8View) {
        this._uint8View = new Uint8Array(this.rawBinaryData);
      }
      return this._uint8View;
    }
    get int16View() {
      if (!this._int16View) {
        this._int16View = new Int16Array(this.rawBinaryData);
      }
      return this._int16View;
    }
    get uint16View() {
      if (!this._uint16View) {
        this._uint16View = new Uint16Array(this.rawBinaryData);
      }
      return this._uint16View;
    }
    get int32View() {
      if (!this._int32View) {
        this._int32View = new Int32Array(this.rawBinaryData);
      }
      return this._int32View;
    }
    view(type) {
      return this[`${type}View`];
    }
    destroy() {
      this.rawBinaryData = null;
      this._int8View = null;
      this._uint8View = null;
      this._int16View = null;
      this._uint16View = null;
      this._int32View = null;
      this.uint32View = null;
      this.float32View = null;
    }
    static sizeOf(type) {
      switch (type) {
        case "int8":
        case "uint8":
          return 1;
        case "int16":
        case "uint16":
          return 2;
        case "int32":
        case "uint32":
        case "float32":
          return 4;
        default:
          throw new Error(`${type} isn't a valid view type`);
      }
    }
  };
  var BatchShaderGenerator = class {
    constructor(vertexSrc, fragTemplate2) {
      this.vertexSrc = vertexSrc;
      this.fragTemplate = fragTemplate2;
      this.programCache = {};
      this.defaultGroupCache = {};
      if (!fragTemplate2.includes("%count%")) {
        throw new Error('Fragment template must contain "%count%".');
      }
      if (!fragTemplate2.includes("%forloop%")) {
        throw new Error('Fragment template must contain "%forloop%".');
      }
    }
    generateShader(maxTextures) {
      if (!this.programCache[maxTextures]) {
        const sampleValues = new Int32Array(maxTextures);
        for (let i = 0; i < maxTextures; i++) {
          sampleValues[i] = i;
        }
        this.defaultGroupCache[maxTextures] = UniformGroup.from({ uSamplers: sampleValues }, true);
        let fragmentSrc = this.fragTemplate;
        fragmentSrc = fragmentSrc.replace(/%count%/gi, `${maxTextures}`);
        fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));
        this.programCache[maxTextures] = new Program(this.vertexSrc, fragmentSrc);
      }
      const uniforms = {
        tint: new Float32Array([1, 1, 1, 1]),
        translationMatrix: new Matrix(),
        default: this.defaultGroupCache[maxTextures]
      };
      return new Shader(this.programCache[maxTextures], uniforms);
    }
    generateSampleSrc(maxTextures) {
      let src = "";
      src += "\n";
      src += "\n";
      for (let i = 0; i < maxTextures; i++) {
        if (i > 0) {
          src += "\nelse ";
        }
        if (i < maxTextures - 1) {
          src += `if(vTextureId < ${i}.5)`;
        }
        src += "\n{";
        src += `
	color = texture2D(uSamplers[${i}], vTextureCoord);`;
        src += "\n}";
      }
      src += "\n";
      src += "\n";
      return src;
    }
  };
  var BatchGeometry = class extends Geometry {
    constructor(_static = false) {
      super();
      this._buffer = new Buffer2(null, _static, false);
      this._indexBuffer = new Buffer2(null, _static, true);
      this.addAttribute("aVertexPosition", this._buffer, 2, false, TYPES.FLOAT).addAttribute("aTextureCoord", this._buffer, 2, false, TYPES.FLOAT).addAttribute("aColor", this._buffer, 4, true, TYPES.UNSIGNED_BYTE).addAttribute("aTextureId", this._buffer, 1, true, TYPES.FLOAT).addIndex(this._indexBuffer);
    }
  };
  var defaultVertex = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n";
  var defaultFragment = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n";
  var _BatchRenderer = class extends ObjectRenderer {
    constructor(renderer) {
      super(renderer);
      this.setShaderGenerator();
      this.geometryClass = BatchGeometry;
      this.vertexSize = 6;
      this.state = State.for2d();
      this.size = settings.SPRITE_BATCH_SIZE * 4;
      this._vertexCount = 0;
      this._indexCount = 0;
      this._bufferedElements = [];
      this._bufferedTextures = [];
      this._bufferSize = 0;
      this._shader = null;
      this._packedGeometries = [];
      this._packedGeometryPoolSize = 2;
      this._flushId = 0;
      this._aBuffers = {};
      this._iBuffers = {};
      this.MAX_TEXTURES = 1;
      this.renderer.on("prerender", this.onPrerender, this);
      renderer.runners.contextChange.add(this);
      this._dcIndex = 0;
      this._aIndex = 0;
      this._iIndex = 0;
      this._attributeBuffer = null;
      this._indexBuffer = null;
      this._tempBoundTextures = [];
    }
    static get defaultVertexSrc() {
      return defaultVertex;
    }
    static get defaultFragmentTemplate() {
      return defaultFragment;
    }
    setShaderGenerator({
      vertex: vertex2 = _BatchRenderer.defaultVertexSrc,
      fragment: fragment2 = _BatchRenderer.defaultFragmentTemplate
    } = {}) {
      this.shaderGenerator = new BatchShaderGenerator(vertex2, fragment2);
    }
    contextChange() {
      const gl = this.renderer.gl;
      if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
        this.MAX_TEXTURES = 1;
      } else {
        this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), settings.SPRITE_MAX_TEXTURES);
        this.MAX_TEXTURES = checkMaxIfStatementsInShader(this.MAX_TEXTURES, gl);
      }
      this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);
      for (let i = 0; i < this._packedGeometryPoolSize; i++) {
        this._packedGeometries[i] = new this.geometryClass();
      }
      this.initFlushBuffers();
    }
    initFlushBuffers() {
      const {
        _drawCallPool,
        _textureArrayPool
      } = _BatchRenderer;
      const MAX_SPRITES = this.size / 4;
      const MAX_TA = Math.floor(MAX_SPRITES / this.MAX_TEXTURES) + 1;
      while (_drawCallPool.length < MAX_SPRITES) {
        _drawCallPool.push(new BatchDrawCall());
      }
      while (_textureArrayPool.length < MAX_TA) {
        _textureArrayPool.push(new BatchTextureArray());
      }
      for (let i = 0; i < this.MAX_TEXTURES; i++) {
        this._tempBoundTextures[i] = null;
      }
    }
    onPrerender() {
      this._flushId = 0;
    }
    render(element) {
      if (!element._texture.valid) {
        return;
      }
      if (this._vertexCount + element.vertexData.length / 2 > this.size) {
        this.flush();
      }
      this._vertexCount += element.vertexData.length / 2;
      this._indexCount += element.indices.length;
      this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;
      this._bufferedElements[this._bufferSize++] = element;
    }
    buildTexturesAndDrawCalls() {
      const {
        _bufferedTextures: textures,
        MAX_TEXTURES
      } = this;
      const textureArrays = _BatchRenderer._textureArrayPool;
      const batch = this.renderer.batch;
      const boundTextures = this._tempBoundTextures;
      const touch = this.renderer.textureGC.count;
      let TICK = ++BaseTexture._globalBatch;
      let countTexArrays = 0;
      let texArray = textureArrays[0];
      let start = 0;
      batch.copyBoundTextures(boundTextures, MAX_TEXTURES);
      for (let i = 0; i < this._bufferSize; ++i) {
        const tex = textures[i];
        textures[i] = null;
        if (tex._batchEnabled === TICK) {
          continue;
        }
        if (texArray.count >= MAX_TEXTURES) {
          batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);
          this.buildDrawCalls(texArray, start, i);
          start = i;
          texArray = textureArrays[++countTexArrays];
          ++TICK;
        }
        tex._batchEnabled = TICK;
        tex.touched = touch;
        texArray.elements[texArray.count++] = tex;
      }
      if (texArray.count > 0) {
        batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);
        this.buildDrawCalls(texArray, start, this._bufferSize);
        ++countTexArrays;
        ++TICK;
      }
      for (let i = 0; i < boundTextures.length; i++) {
        boundTextures[i] = null;
      }
      BaseTexture._globalBatch = TICK;
    }
    buildDrawCalls(texArray, start, finish) {
      const {
        _bufferedElements: elements,
        _attributeBuffer,
        _indexBuffer,
        vertexSize
      } = this;
      const drawCalls = _BatchRenderer._drawCallPool;
      let dcIndex = this._dcIndex;
      let aIndex = this._aIndex;
      let iIndex = this._iIndex;
      let drawCall = drawCalls[dcIndex];
      drawCall.start = this._iIndex;
      drawCall.texArray = texArray;
      for (let i = start; i < finish; ++i) {
        const sprite = elements[i];
        const tex = sprite._texture.baseTexture;
        const spriteBlendMode = premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];
        elements[i] = null;
        if (start < i && drawCall.blend !== spriteBlendMode) {
          drawCall.size = iIndex - drawCall.start;
          start = i;
          drawCall = drawCalls[++dcIndex];
          drawCall.texArray = texArray;
          drawCall.start = iIndex;
        }
        this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);
        aIndex += sprite.vertexData.length / 2 * vertexSize;
        iIndex += sprite.indices.length;
        drawCall.blend = spriteBlendMode;
      }
      if (start < finish) {
        drawCall.size = iIndex - drawCall.start;
        ++dcIndex;
      }
      this._dcIndex = dcIndex;
      this._aIndex = aIndex;
      this._iIndex = iIndex;
    }
    bindAndClearTexArray(texArray) {
      const textureSystem = this.renderer.texture;
      for (let j = 0; j < texArray.count; j++) {
        textureSystem.bind(texArray.elements[j], texArray.ids[j]);
        texArray.elements[j] = null;
      }
      texArray.count = 0;
    }
    updateGeometry() {
      const {
        _packedGeometries: packedGeometries,
        _attributeBuffer: attributeBuffer,
        _indexBuffer: indexBuffer
      } = this;
      if (!settings.CAN_UPLOAD_SAME_BUFFER) {
        if (this._packedGeometryPoolSize <= this._flushId) {
          this._packedGeometryPoolSize++;
          packedGeometries[this._flushId] = new this.geometryClass();
        }
        packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
        packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
        this.renderer.geometry.bind(packedGeometries[this._flushId]);
        this.renderer.geometry.updateBuffers();
        this._flushId++;
      } else {
        packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
        packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
        this.renderer.geometry.updateBuffers();
      }
    }
    drawBatches() {
      const dcCount = this._dcIndex;
      const { gl, state: stateSystem } = this.renderer;
      const drawCalls = _BatchRenderer._drawCallPool;
      let curTexArray = null;
      for (let i = 0; i < dcCount; i++) {
        const { texArray, type, size, start, blend } = drawCalls[i];
        if (curTexArray !== texArray) {
          curTexArray = texArray;
          this.bindAndClearTexArray(texArray);
        }
        this.state.blendMode = blend;
        stateSystem.set(this.state);
        gl.drawElements(type, size, gl.UNSIGNED_SHORT, start * 2);
      }
    }
    flush() {
      if (this._vertexCount === 0) {
        return;
      }
      this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);
      this._indexBuffer = this.getIndexBuffer(this._indexCount);
      this._aIndex = 0;
      this._iIndex = 0;
      this._dcIndex = 0;
      this.buildTexturesAndDrawCalls();
      this.updateGeometry();
      this.drawBatches();
      this._bufferSize = 0;
      this._vertexCount = 0;
      this._indexCount = 0;
    }
    start() {
      this.renderer.state.set(this.state);
      this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES);
      this.renderer.shader.bind(this._shader);
      if (settings.CAN_UPLOAD_SAME_BUFFER) {
        this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
      }
    }
    stop() {
      this.flush();
    }
    destroy() {
      for (let i = 0; i < this._packedGeometryPoolSize; i++) {
        if (this._packedGeometries[i]) {
          this._packedGeometries[i].destroy();
        }
      }
      this.renderer.off("prerender", this.onPrerender, this);
      this._aBuffers = null;
      this._iBuffers = null;
      this._packedGeometries = null;
      this._attributeBuffer = null;
      this._indexBuffer = null;
      if (this._shader) {
        this._shader.destroy();
        this._shader = null;
      }
      super.destroy();
    }
    getAttributeBuffer(size) {
      const roundedP2 = nextPow2(Math.ceil(size / 8));
      const roundedSizeIndex = log2(roundedP2);
      const roundedSize = roundedP2 * 8;
      if (this._aBuffers.length <= roundedSizeIndex) {
        this._iBuffers.length = roundedSizeIndex + 1;
      }
      let buffer = this._aBuffers[roundedSize];
      if (!buffer) {
        this._aBuffers[roundedSize] = buffer = new ViewableBuffer(roundedSize * this.vertexSize * 4);
      }
      return buffer;
    }
    getIndexBuffer(size) {
      const roundedP2 = nextPow2(Math.ceil(size / 12));
      const roundedSizeIndex = log2(roundedP2);
      const roundedSize = roundedP2 * 12;
      if (this._iBuffers.length <= roundedSizeIndex) {
        this._iBuffers.length = roundedSizeIndex + 1;
      }
      let buffer = this._iBuffers[roundedSizeIndex];
      if (!buffer) {
        this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);
      }
      return buffer;
    }
    packInterleavedGeometry(element, attributeBuffer, indexBuffer, aIndex, iIndex) {
      const {
        uint32View,
        float32View
      } = attributeBuffer;
      const packedVertices = aIndex / this.vertexSize;
      const uvs = element.uvs;
      const indicies = element.indices;
      const vertexData = element.vertexData;
      const textureId = element._texture.baseTexture._batchLocation;
      const alpha = Math.min(element.worldAlpha, 1);
      const argb = alpha < 1 && element._texture.baseTexture.alphaMode ? premultiplyTint(element._tintRGB, alpha) : element._tintRGB + (alpha * 255 << 24);
      for (let i = 0; i < vertexData.length; i += 2) {
        float32View[aIndex++] = vertexData[i];
        float32View[aIndex++] = vertexData[i + 1];
        float32View[aIndex++] = uvs[i];
        float32View[aIndex++] = uvs[i + 1];
        uint32View[aIndex++] = argb;
        float32View[aIndex++] = textureId;
      }
      for (let i = 0; i < indicies.length; i++) {
        indexBuffer[iIndex++] = packedVertices + indicies[i];
      }
    }
  };
  var BatchRenderer = _BatchRenderer;
  BatchRenderer.extension = {
    name: "batch",
    type: ExtensionType.RendererPlugin
  };
  BatchRenderer._drawCallPool = [];
  BatchRenderer._textureArrayPool = [];
  extensions$1.add(BatchRenderer);
  var TransformFeedback = class {
    constructor() {
      this._glTransformFeedbacks = {};
      this.buffers = [];
      this.disposeRunner = new Runner("disposeTransformFeedback");
    }
    bindBuffer(index2, buffer) {
      this.buffers[index2] = buffer;
    }
    destroy() {
      this.disposeRunner.emit(this, false);
    }
  };
  var GLBuffer = class {
    constructor(buffer) {
      this.buffer = buffer || null;
      this.updateID = -1;
      this.byteLength = -1;
      this.refCount = 0;
    }
  };
  var BufferSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
      this.managedBuffers = {};
      this.boundBufferBases = {};
    }
    destroy() {
      this.renderer = null;
    }
    contextChange() {
      this.disposeAll(true);
      this.gl = this.renderer.gl;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    }
    bind(buffer) {
      const { gl, CONTEXT_UID } = this;
      const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
      gl.bindBuffer(buffer.type, glBuffer.buffer);
    }
    unbind(type) {
      const { gl } = this;
      gl.bindBuffer(type, null);
    }
    bindBufferBase(buffer, index2) {
      const { gl, CONTEXT_UID } = this;
      if (this.boundBufferBases[index2] !== buffer) {
        const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
        this.boundBufferBases[index2] = buffer;
        gl.bindBufferBase(gl.UNIFORM_BUFFER, index2, glBuffer.buffer);
      }
    }
    bindBufferRange(buffer, index2, offset) {
      const { gl, CONTEXT_UID } = this;
      offset = offset || 0;
      const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
      gl.bindBufferRange(gl.UNIFORM_BUFFER, index2 || 0, glBuffer.buffer, offset * 256, 256);
    }
    update(buffer) {
      const { gl, CONTEXT_UID } = this;
      const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
      if (buffer._updateID === glBuffer.updateID) {
        return;
      }
      glBuffer.updateID = buffer._updateID;
      gl.bindBuffer(buffer.type, glBuffer.buffer);
      if (glBuffer.byteLength >= buffer.data.byteLength) {
        gl.bufferSubData(buffer.type, 0, buffer.data);
      } else {
        const drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
        glBuffer.byteLength = buffer.data.byteLength;
        gl.bufferData(buffer.type, buffer.data, drawType);
      }
    }
    dispose(buffer, contextLost) {
      if (!this.managedBuffers[buffer.id]) {
        return;
      }
      delete this.managedBuffers[buffer.id];
      const glBuffer = buffer._glBuffers[this.CONTEXT_UID];
      const gl = this.gl;
      buffer.disposeRunner.remove(this);
      if (!glBuffer) {
        return;
      }
      if (!contextLost) {
        gl.deleteBuffer(glBuffer.buffer);
      }
      delete buffer._glBuffers[this.CONTEXT_UID];
    }
    disposeAll(contextLost) {
      const all = Object.keys(this.managedBuffers);
      for (let i = 0; i < all.length; i++) {
        this.dispose(this.managedBuffers[all[i]], contextLost);
      }
    }
    createGLBuffer(buffer) {
      const { CONTEXT_UID, gl } = this;
      buffer._glBuffers[CONTEXT_UID] = new GLBuffer(gl.createBuffer());
      this.managedBuffers[buffer.id] = buffer;
      buffer.disposeRunner.add(this);
      return buffer._glBuffers[CONTEXT_UID];
    }
  };
  BufferSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "buffer"
  };
  extensions$1.add(BufferSystem);
  var MultisampleSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
    }
    contextChange(gl) {
      let samples;
      if (this.renderer.context.webGLVersion === 1) {
        const framebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        samples = gl.getParameter(gl.SAMPLES);
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      } else {
        const framebuffer = gl.getParameter(gl.DRAW_FRAMEBUFFER_BINDING);
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
        samples = gl.getParameter(gl.SAMPLES);
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, framebuffer);
      }
      if (samples >= MSAA_QUALITY.HIGH) {
        this.multisample = MSAA_QUALITY.HIGH;
      } else if (samples >= MSAA_QUALITY.MEDIUM) {
        this.multisample = MSAA_QUALITY.MEDIUM;
      } else if (samples >= MSAA_QUALITY.LOW) {
        this.multisample = MSAA_QUALITY.LOW;
      } else {
        this.multisample = MSAA_QUALITY.NONE;
      }
    }
    destroy() {
    }
  };
  MultisampleSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "_multisample"
  };
  extensions$1.add(MultisampleSystem);
  var ObjectRendererSystem = class {
    constructor(renderer) {
      this.renderer = renderer;
    }
    render(displayObject, options) {
      const renderer = this.renderer;
      let renderTexture;
      let clear;
      let transform;
      let skipUpdateTransform;
      if (options) {
        renderTexture = options.renderTexture;
        clear = options.clear;
        transform = options.transform;
        skipUpdateTransform = options.skipUpdateTransform;
      }
      this.renderingToScreen = !renderTexture;
      renderer.runners.prerender.emit();
      renderer.emit("prerender");
      renderer.projection.transform = transform;
      if (renderer.context.isLost) {
        return;
      }
      if (!renderTexture) {
        this.lastObjectRendered = displayObject;
      }
      if (!skipUpdateTransform) {
        const cacheParent = displayObject.enableTempParent();
        displayObject.updateTransform();
        displayObject.disableTempParent(cacheParent);
      }
      renderer.renderTexture.bind(renderTexture);
      renderer.batch.currentRenderer.start();
      if (clear ?? renderer.background.clearBeforeRender) {
        renderer.renderTexture.clear();
      }
      displayObject.render(renderer);
      renderer.batch.currentRenderer.flush();
      if (renderTexture) {
        if (options.blit) {
          renderer.framebuffer.blit();
        }
        renderTexture.baseTexture.update();
      }
      renderer.runners.postrender.emit();
      renderer.projection.transform = null;
      renderer.emit("postrender");
    }
    destroy() {
      this.renderer = null;
      this.lastObjectRendered = null;
    }
  };
  ObjectRendererSystem.extension = {
    type: ExtensionType.RendererSystem,
    name: "objectRenderer"
  };
  extensions$1.add(ObjectRendererSystem);
  var VERSION = "7.0.5";
  var fragment$6 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n";
  var AlphaFilter = class extends Filter {
    constructor(alpha = 1) {
      super(defaultVertex$1, fragment$6, { uAlpha: 1 });
      this.alpha = alpha;
    }
    get alpha() {
      return this.uniforms.uAlpha;
    }
    set alpha(value3) {
      this.uniforms.uAlpha = value3;
    }
  };
  var vertTemplate = `
    attribute vec2 aVertexPosition;

    uniform mat3 projectionMatrix;

    uniform float strength;

    varying vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;

    vec4 filterVertexPosition( void )
    {
        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
    }

    vec2 filterTextureCoord( void )
    {
        return aVertexPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
  function generateBlurVertSource(kernelSize, x) {
    const halfLength = Math.ceil(kernelSize / 2);
    let vertSource = vertTemplate;
    let blurLoop = "";
    let template;
    if (x) {
      template = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);";
    } else {
      template = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
    }
    for (let i = 0; i < kernelSize; i++) {
      let blur = template.replace("%index%", i.toString());
      blur = blur.replace("%sampleIndex%", `${i - (halfLength - 1)}.0`);
      blurLoop += blur;
      blurLoop += "\n";
    }
    vertSource = vertSource.replace("%blur%", blurLoop);
    vertSource = vertSource.replace("%size%", kernelSize.toString());
    return vertSource;
  }
  var GAUSSIAN_VALUES = {
    5: [0.153388, 0.221461, 0.250301],
    7: [0.071303, 0.131514, 0.189879, 0.214607],
    9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
    11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
    13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
    15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
  };
  var fragTemplate = [
    "varying vec2 vBlurTexCoords[%size%];",
    "uniform sampler2D uSampler;",
    "void main(void)",
    "{",
    "    gl_FragColor = vec4(0.0);",
    "    %blur%",
    "}"
  ].join("\n");
  function generateBlurFragSource(kernelSize) {
    const kernel = GAUSSIAN_VALUES[kernelSize];
    const halfLength = kernel.length;
    let fragSource = fragTemplate;
    let blurLoop = "";
    const template = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";
    let value3;
    for (let i = 0; i < kernelSize; i++) {
      let blur = template.replace("%index%", i.toString());
      value3 = i;
      if (i >= halfLength) {
        value3 = kernelSize - i - 1;
      }
      blur = blur.replace("%value%", kernel[value3].toString());
      blurLoop += blur;
      blurLoop += "\n";
    }
    fragSource = fragSource.replace("%blur%", blurLoop);
    fragSource = fragSource.replace("%size%", kernelSize.toString());
    return fragSource;
  }
  var BlurFilterPass = class extends Filter {
    constructor(horizontal, strength = 8, quality = 4, resolution = settings.FILTER_RESOLUTION, kernelSize = 5) {
      const vertSrc = generateBlurVertSource(kernelSize, horizontal);
      const fragSrc = generateBlurFragSource(kernelSize);
      super(vertSrc, fragSrc);
      this.horizontal = horizontal;
      this.resolution = resolution;
      this._quality = 0;
      this.quality = quality;
      this.blur = strength;
    }
    apply(filterManager, input, output, clearMode) {
      if (output) {
        if (this.horizontal) {
          this.uniforms.strength = 1 / output.width * (output.width / input.width);
        } else {
          this.uniforms.strength = 1 / output.height * (output.height / input.height);
        }
      } else {
        if (this.horizontal) {
          this.uniforms.strength = 1 / filterManager.renderer.width * (filterManager.renderer.width / input.width);
        } else {
          this.uniforms.strength = 1 / filterManager.renderer.height * (filterManager.renderer.height / input.height);
        }
      }
      this.uniforms.strength *= this.strength;
      this.uniforms.strength /= this.passes;
      if (this.passes === 1) {
        filterManager.applyFilter(this, input, output, clearMode);
      } else {
        const renderTarget = filterManager.getFilterTexture();
        const renderer = filterManager.renderer;
        let flip = input;
        let flop = renderTarget;
        this.state.blend = false;
        filterManager.applyFilter(this, flip, flop, CLEAR_MODES.CLEAR);
        for (let i = 1; i < this.passes - 1; i++) {
          filterManager.bindAndClear(flip, CLEAR_MODES.BLIT);
          this.uniforms.uSampler = flop;
          const temp2 = flop;
          flop = flip;
          flip = temp2;
          renderer.shader.bind(this);
          renderer.geometry.draw(5);
        }
        this.state.blend = true;
        filterManager.applyFilter(this, flop, output, clearMode);
        filterManager.returnFilterTexture(renderTarget);
      }
    }
    get blur() {
      return this.strength;
    }
    set blur(value3) {
      this.padding = 1 + Math.abs(value3) * 2;
      this.strength = value3;
    }
    get quality() {
      return this._quality;
    }
    set quality(value3) {
      this._quality = value3;
      this.passes = value3;
    }
  };
  var BlurFilter = class extends Filter {
    constructor(strength = 8, quality = 4, resolution = settings.FILTER_RESOLUTION, kernelSize = 5) {
      super();
      this.blurXFilter = new BlurFilterPass(true, strength, quality, resolution, kernelSize);
      this.blurYFilter = new BlurFilterPass(false, strength, quality, resolution, kernelSize);
      this.resolution = resolution;
      this.quality = quality;
      this.blur = strength;
      this.repeatEdgePixels = false;
    }
    apply(filterManager, input, output, clearMode) {
      const xStrength = Math.abs(this.blurXFilter.strength);
      const yStrength = Math.abs(this.blurYFilter.strength);
      if (xStrength && yStrength) {
        const renderTarget = filterManager.getFilterTexture();
        this.blurXFilter.apply(filterManager, input, renderTarget, CLEAR_MODES.CLEAR);
        this.blurYFilter.apply(filterManager, renderTarget, output, clearMode);
        filterManager.returnFilterTexture(renderTarget);
      } else if (yStrength) {
        this.blurYFilter.apply(filterManager, input, output, clearMode);
      } else {
        this.blurXFilter.apply(filterManager, input, output, clearMode);
      }
    }
    updatePadding() {
      if (this._repeatEdgePixels) {
        this.padding = 0;
      } else {
        this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
      }
    }
    get blur() {
      return this.blurXFilter.blur;
    }
    set blur(value3) {
      this.blurXFilter.blur = this.blurYFilter.blur = value3;
      this.updatePadding();
    }
    get quality() {
      return this.blurXFilter.quality;
    }
    set quality(value3) {
      this.blurXFilter.quality = this.blurYFilter.quality = value3;
    }
    get blurX() {
      return this.blurXFilter.blur;
    }
    set blurX(value3) {
      this.blurXFilter.blur = value3;
      this.updatePadding();
    }
    get blurY() {
      return this.blurYFilter.blur;
    }
    set blurY(value3) {
      this.blurYFilter.blur = value3;
      this.updatePadding();
    }
    get blendMode() {
      return this.blurYFilter.blendMode;
    }
    set blendMode(value3) {
      this.blurYFilter.blendMode = value3;
    }
    get repeatEdgePixels() {
      return this._repeatEdgePixels;
    }
    set repeatEdgePixels(value3) {
      this._repeatEdgePixels = value3;
      this.updatePadding();
    }
  };
  var fragment$5 = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n";
  var ColorMatrixFilter = class extends Filter {
    constructor() {
      const uniforms = {
        m: new Float32Array([
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ]),
        uAlpha: 1
      };
      super(defaultFilterVertex, fragment$5, uniforms);
      this.alpha = 1;
    }
    _loadMatrix(matrix, multiply = false) {
      let newMatrix = matrix;
      if (multiply) {
        this._multiply(newMatrix, this.uniforms.m, matrix);
        newMatrix = this._colorMatrix(newMatrix);
      }
      this.uniforms.m = newMatrix;
    }
    _multiply(out, a2, b2) {
      out[0] = a2[0] * b2[0] + a2[1] * b2[5] + a2[2] * b2[10] + a2[3] * b2[15];
      out[1] = a2[0] * b2[1] + a2[1] * b2[6] + a2[2] * b2[11] + a2[3] * b2[16];
      out[2] = a2[0] * b2[2] + a2[1] * b2[7] + a2[2] * b2[12] + a2[3] * b2[17];
      out[3] = a2[0] * b2[3] + a2[1] * b2[8] + a2[2] * b2[13] + a2[3] * b2[18];
      out[4] = a2[0] * b2[4] + a2[1] * b2[9] + a2[2] * b2[14] + a2[3] * b2[19] + a2[4];
      out[5] = a2[5] * b2[0] + a2[6] * b2[5] + a2[7] * b2[10] + a2[8] * b2[15];
      out[6] = a2[5] * b2[1] + a2[6] * b2[6] + a2[7] * b2[11] + a2[8] * b2[16];
      out[7] = a2[5] * b2[2] + a2[6] * b2[7] + a2[7] * b2[12] + a2[8] * b2[17];
      out[8] = a2[5] * b2[3] + a2[6] * b2[8] + a2[7] * b2[13] + a2[8] * b2[18];
      out[9] = a2[5] * b2[4] + a2[6] * b2[9] + a2[7] * b2[14] + a2[8] * b2[19] + a2[9];
      out[10] = a2[10] * b2[0] + a2[11] * b2[5] + a2[12] * b2[10] + a2[13] * b2[15];
      out[11] = a2[10] * b2[1] + a2[11] * b2[6] + a2[12] * b2[11] + a2[13] * b2[16];
      out[12] = a2[10] * b2[2] + a2[11] * b2[7] + a2[12] * b2[12] + a2[13] * b2[17];
      out[13] = a2[10] * b2[3] + a2[11] * b2[8] + a2[12] * b2[13] + a2[13] * b2[18];
      out[14] = a2[10] * b2[4] + a2[11] * b2[9] + a2[12] * b2[14] + a2[13] * b2[19] + a2[14];
      out[15] = a2[15] * b2[0] + a2[16] * b2[5] + a2[17] * b2[10] + a2[18] * b2[15];
      out[16] = a2[15] * b2[1] + a2[16] * b2[6] + a2[17] * b2[11] + a2[18] * b2[16];
      out[17] = a2[15] * b2[2] + a2[16] * b2[7] + a2[17] * b2[12] + a2[18] * b2[17];
      out[18] = a2[15] * b2[3] + a2[16] * b2[8] + a2[17] * b2[13] + a2[18] * b2[18];
      out[19] = a2[15] * b2[4] + a2[16] * b2[9] + a2[17] * b2[14] + a2[18] * b2[19] + a2[19];
      return out;
    }
    _colorMatrix(matrix) {
      const m = new Float32Array(matrix);
      m[4] /= 255;
      m[9] /= 255;
      m[14] /= 255;
      m[19] /= 255;
      return m;
    }
    brightness(b2, multiply) {
      const matrix = [
        b2,
        0,
        0,
        0,
        0,
        0,
        b2,
        0,
        0,
        0,
        0,
        0,
        b2,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    tint(color2, multiply) {
      const r = color2 >> 16 & 255;
      const g = color2 >> 8 & 255;
      const b2 = color2 & 255;
      const matrix = [
        r / 255,
        0,
        0,
        0,
        0,
        0,
        g / 255,
        0,
        0,
        0,
        0,
        0,
        b2 / 255,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    greyscale(scale, multiply) {
      const matrix = [
        scale,
        scale,
        scale,
        0,
        0,
        scale,
        scale,
        scale,
        0,
        0,
        scale,
        scale,
        scale,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    blackAndWhite(multiply) {
      const matrix = [
        0.3,
        0.6,
        0.1,
        0,
        0,
        0.3,
        0.6,
        0.1,
        0,
        0,
        0.3,
        0.6,
        0.1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    hue(rotation, multiply) {
      rotation = (rotation || 0) / 180 * Math.PI;
      const cosR = Math.cos(rotation);
      const sinR = Math.sin(rotation);
      const sqrt = Math.sqrt;
      const w = 1 / 3;
      const sqrW = sqrt(w);
      const a00 = cosR + (1 - cosR) * w;
      const a01 = w * (1 - cosR) - sqrW * sinR;
      const a02 = w * (1 - cosR) + sqrW * sinR;
      const a10 = w * (1 - cosR) + sqrW * sinR;
      const a11 = cosR + w * (1 - cosR);
      const a12 = w * (1 - cosR) - sqrW * sinR;
      const a20 = w * (1 - cosR) - sqrW * sinR;
      const a21 = w * (1 - cosR) + sqrW * sinR;
      const a22 = cosR + w * (1 - cosR);
      const matrix = [
        a00,
        a01,
        a02,
        0,
        0,
        a10,
        a11,
        a12,
        0,
        0,
        a20,
        a21,
        a22,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    contrast(amount, multiply) {
      const v2 = (amount || 0) + 1;
      const o = -0.5 * (v2 - 1);
      const matrix = [
        v2,
        0,
        0,
        0,
        o,
        0,
        v2,
        0,
        0,
        o,
        0,
        0,
        v2,
        0,
        o,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    saturate(amount = 0, multiply) {
      const x = amount * 2 / 3 + 1;
      const y = (x - 1) * -0.5;
      const matrix = [
        x,
        y,
        y,
        0,
        0,
        y,
        x,
        y,
        0,
        0,
        y,
        y,
        x,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    desaturate() {
      this.saturate(-1);
    }
    negative(multiply) {
      const matrix = [
        -1,
        0,
        0,
        1,
        0,
        0,
        -1,
        0,
        1,
        0,
        0,
        0,
        -1,
        1,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    sepia(multiply) {
      const matrix = [
        0.393,
        0.7689999,
        0.18899999,
        0,
        0,
        0.349,
        0.6859999,
        0.16799999,
        0,
        0,
        0.272,
        0.5339999,
        0.13099999,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    technicolor(multiply) {
      const matrix = [
        1.9125277891456083,
        -0.8545344976951645,
        -0.09155508482755585,
        0,
        11.793603434377337,
        -0.3087833385928097,
        1.7658908555458428,
        -0.10601743074722245,
        0,
        -70.35205161461398,
        -0.231103377548616,
        -0.7501899197440212,
        1.847597816108189,
        0,
        30.950940869491138,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    polaroid(multiply) {
      const matrix = [
        1.438,
        -0.062,
        -0.062,
        0,
        0,
        -0.122,
        1.378,
        -0.122,
        0,
        0,
        -0.016,
        -0.016,
        1.483,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    toBGR(multiply) {
      const matrix = [
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    kodachrome(multiply) {
      const matrix = [
        1.1285582396593525,
        -0.3967382283601348,
        -0.03992559172921793,
        0,
        63.72958762196502,
        -0.16404339962244616,
        1.0835251566291304,
        -0.05498805115633132,
        0,
        24.732407896706203,
        -0.16786010706155763,
        -0.5603416277695248,
        1.6014850761964943,
        0,
        35.62982807460946,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    browni(multiply) {
      const matrix = [
        0.5997023498159715,
        0.34553243048391263,
        -0.2708298674538042,
        0,
        47.43192855600873,
        -0.037703249837783157,
        0.8609577587992641,
        0.15059552388459913,
        0,
        -36.96841498319127,
        0.24113635128153335,
        -0.07441037908422492,
        0.44972182064877153,
        0,
        -7.562075277591283,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    vintage(multiply) {
      const matrix = [
        0.6279345635605994,
        0.3202183420819367,
        -0.03965408211312453,
        0,
        9.651285835294123,
        0.02578397704808868,
        0.6441188644374771,
        0.03259127616149294,
        0,
        7.462829176470591,
        0.0466055556782719,
        -0.0851232987247891,
        0.5241648018700465,
        0,
        5.159190588235296,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    colorTone(desaturation, toned, lightColor, darkColor, multiply) {
      desaturation = desaturation || 0.2;
      toned = toned || 0.15;
      lightColor = lightColor || 16770432;
      darkColor = darkColor || 3375104;
      const lR = (lightColor >> 16 & 255) / 255;
      const lG = (lightColor >> 8 & 255) / 255;
      const lB = (lightColor & 255) / 255;
      const dR = (darkColor >> 16 & 255) / 255;
      const dG = (darkColor >> 8 & 255) / 255;
      const dB = (darkColor & 255) / 255;
      const matrix = [
        0.3,
        0.59,
        0.11,
        0,
        0,
        lR,
        lG,
        lB,
        desaturation,
        0,
        dR,
        dG,
        dB,
        toned,
        0,
        lR - dR,
        lG - dG,
        lB - dB,
        0,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    night(intensity, multiply) {
      intensity = intensity || 0.1;
      const matrix = [
        intensity * -2,
        -intensity,
        0,
        0,
        0,
        -intensity,
        0,
        intensity,
        0,
        0,
        0,
        intensity,
        intensity * 2,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    predator(amount, multiply) {
      const matrix = [
        11.224130630493164 * amount,
        -4.794486999511719 * amount,
        -2.8746118545532227 * amount,
        0 * amount,
        0.40342438220977783 * amount,
        -3.6330697536468506 * amount,
        9.193157196044922 * amount,
        -2.951810836791992 * amount,
        0 * amount,
        -1.316135048866272 * amount,
        -3.2184197902679443 * amount,
        -4.2375030517578125 * amount,
        7.476448059082031 * amount,
        0 * amount,
        0.8044459223747253 * amount,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    lsd(multiply) {
      const matrix = [
        2,
        -0.4,
        0.5,
        0,
        0,
        -0.5,
        2,
        -0.4,
        0,
        0,
        -0.4,
        -0.5,
        3,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, multiply);
    }
    reset() {
      const matrix = [
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(matrix, false);
    }
    get matrix() {
      return this.uniforms.m;
    }
    set matrix(value3) {
      this.uniforms.m = value3;
    }
    get alpha() {
      return this.uniforms.uAlpha;
    }
    set alpha(value3) {
      this.uniforms.uAlpha = value3;
    }
  };
  ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;
  var fragment$4 = "varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n";
  var vertex$3 = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n	gl_Position = filterVertexPosition();\n	vTextureCoord = filterTextureCoord();\n	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n";
  var DisplacementFilter = class extends Filter {
    constructor(sprite, scale) {
      const maskMatrix = new Matrix();
      sprite.renderable = false;
      super(vertex$3, fragment$4, {
        mapSampler: sprite._texture,
        filterMatrix: maskMatrix,
        scale: { x: 1, y: 1 },
        rotation: new Float32Array([1, 0, 0, 1])
      });
      this.maskSprite = sprite;
      this.maskMatrix = maskMatrix;
      if (scale === null || scale === void 0) {
        scale = 20;
      }
      this.scale = new Point(scale, scale);
    }
    apply(filterManager, input, output, clearMode) {
      this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);
      this.uniforms.scale.x = this.scale.x;
      this.uniforms.scale.y = this.scale.y;
      const wt = this.maskSprite.worldTransform;
      const lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b);
      const lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);
      if (lenX !== 0 && lenY !== 0) {
        this.uniforms.rotation[0] = wt.a / lenX;
        this.uniforms.rotation[1] = wt.b / lenX;
        this.uniforms.rotation[2] = wt.c / lenY;
        this.uniforms.rotation[3] = wt.d / lenY;
      }
      filterManager.applyFilter(this, input, output, clearMode);
    }
    get map() {
      return this.uniforms.mapSampler;
    }
    set map(value3) {
      this.uniforms.mapSampler = value3;
    }
  };
  var vertex$2 = "\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n";
  var fragment$3 = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`;
  var FXAAFilter = class extends Filter {
    constructor() {
      super(vertex$2, fragment$3);
    }
  };
  var fragment$2 = "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n";
  var NoiseFilter = class extends Filter {
    constructor(noise = 0.5, seed = Math.random()) {
      super(defaultFilterVertex, fragment$2, {
        uNoise: 0,
        uSeed: 0
      });
      this.noise = noise;
      this.seed = seed;
    }
    get noise() {
      return this.uniforms.uNoise;
    }
    set noise(value3) {
      this.uniforms.uNoise = value3;
    }
    get seed() {
      return this.uniforms.uSeed;
    }
    set seed(value3) {
      this.uniforms.uSeed = value3;
    }
  };
  settings.SORTABLE_CHILDREN = false;
  var Bounds = class {
    constructor() {
      this.minX = Infinity;
      this.minY = Infinity;
      this.maxX = -Infinity;
      this.maxY = -Infinity;
      this.rect = null;
      this.updateID = -1;
    }
    isEmpty() {
      return this.minX > this.maxX || this.minY > this.maxY;
    }
    clear() {
      this.minX = Infinity;
      this.minY = Infinity;
      this.maxX = -Infinity;
      this.maxY = -Infinity;
    }
    getRectangle(rect) {
      if (this.minX > this.maxX || this.minY > this.maxY) {
        return Rectangle.EMPTY;
      }
      rect = rect || new Rectangle(0, 0, 1, 1);
      rect.x = this.minX;
      rect.y = this.minY;
      rect.width = this.maxX - this.minX;
      rect.height = this.maxY - this.minY;
      return rect;
    }
    addPoint(point) {
      this.minX = Math.min(this.minX, point.x);
      this.maxX = Math.max(this.maxX, point.x);
      this.minY = Math.min(this.minY, point.y);
      this.maxY = Math.max(this.maxY, point.y);
    }
    addPointMatrix(matrix, point) {
      const { a: a2, b: b2, c, d, tx, ty } = matrix;
      const x = a2 * point.x + c * point.y + tx;
      const y = b2 * point.x + d * point.y + ty;
      this.minX = Math.min(this.minX, x);
      this.maxX = Math.max(this.maxX, x);
      this.minY = Math.min(this.minY, y);
      this.maxY = Math.max(this.maxY, y);
    }
    addQuad(vertices) {
      let minX = this.minX;
      let minY = this.minY;
      let maxX = this.maxX;
      let maxY = this.maxY;
      let x = vertices[0];
      let y = vertices[1];
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
      x = vertices[2];
      y = vertices[3];
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
      x = vertices[4];
      y = vertices[5];
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
      x = vertices[6];
      y = vertices[7];
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    }
    addFrame(transform, x0, y0, x1, y1) {
      this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);
    }
    addFrameMatrix(matrix, x0, y0, x1, y1) {
      const a2 = matrix.a;
      const b2 = matrix.b;
      const c = matrix.c;
      const d = matrix.d;
      const tx = matrix.tx;
      const ty = matrix.ty;
      let minX = this.minX;
      let minY = this.minY;
      let maxX = this.maxX;
      let maxY = this.maxY;
      let x = a2 * x0 + c * y0 + tx;
      let y = b2 * x0 + d * y0 + ty;
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
      x = a2 * x1 + c * y0 + tx;
      y = b2 * x1 + d * y0 + ty;
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
      x = a2 * x0 + c * y1 + tx;
      y = b2 * x0 + d * y1 + ty;
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
      x = a2 * x1 + c * y1 + tx;
      y = b2 * x1 + d * y1 + ty;
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    }
    addVertexData(vertexData, beginOffset, endOffset) {
      let minX = this.minX;
      let minY = this.minY;
      let maxX = this.maxX;
      let maxY = this.maxY;
      for (let i = beginOffset; i < endOffset; i += 2) {
        const x = vertexData[i];
        const y = vertexData[i + 1];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
      }
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    }
    addVertices(transform, vertices, beginOffset, endOffset) {
      this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);
    }
    addVerticesMatrix(matrix, vertices, beginOffset, endOffset, padX = 0, padY = padX) {
      const a2 = matrix.a;
      const b2 = matrix.b;
      const c = matrix.c;
      const d = matrix.d;
      const tx = matrix.tx;
      const ty = matrix.ty;
      let minX = this.minX;
      let minY = this.minY;
      let maxX = this.maxX;
      let maxY = this.maxY;
      for (let i = beginOffset; i < endOffset; i += 2) {
        const rawX = vertices[i];
        const rawY = vertices[i + 1];
        const x = a2 * rawX + c * rawY + tx;
        const y = d * rawY + b2 * rawX + ty;
        minX = Math.min(minX, x - padX);
        maxX = Math.max(maxX, x + padX);
        minY = Math.min(minY, y - padY);
        maxY = Math.max(maxY, y + padY);
      }
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    }
    addBounds(bounds) {
      const minX = this.minX;
      const minY = this.minY;
      const maxX = this.maxX;
      const maxY = this.maxY;
      this.minX = bounds.minX < minX ? bounds.minX : minX;
      this.minY = bounds.minY < minY ? bounds.minY : minY;
      this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;
      this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
    }
    addBoundsMask(bounds, mask) {
      const _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;
      const _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;
      const _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;
      const _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;
      if (_minX <= _maxX && _minY <= _maxY) {
        const minX = this.minX;
        const minY = this.minY;
        const maxX = this.maxX;
        const maxY = this.maxY;
        this.minX = _minX < minX ? _minX : minX;
        this.minY = _minY < minY ? _minY : minY;
        this.maxX = _maxX > maxX ? _maxX : maxX;
        this.maxY = _maxY > maxY ? _maxY : maxY;
      }
    }
    addBoundsMatrix(bounds, matrix) {
      this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
    }
    addBoundsArea(bounds, area2) {
      const _minX = bounds.minX > area2.x ? bounds.minX : area2.x;
      const _minY = bounds.minY > area2.y ? bounds.minY : area2.y;
      const _maxX = bounds.maxX < area2.x + area2.width ? bounds.maxX : area2.x + area2.width;
      const _maxY = bounds.maxY < area2.y + area2.height ? bounds.maxY : area2.y + area2.height;
      if (_minX <= _maxX && _minY <= _maxY) {
        const minX = this.minX;
        const minY = this.minY;
        const maxX = this.maxX;
        const maxY = this.maxY;
        this.minX = _minX < minX ? _minX : minX;
        this.minY = _minY < minY ? _minY : minY;
        this.maxX = _maxX > maxX ? _maxX : maxX;
        this.maxY = _maxY > maxY ? _maxY : maxY;
      }
    }
    pad(paddingX = 0, paddingY = paddingX) {
      if (!this.isEmpty()) {
        this.minX -= paddingX;
        this.maxX += paddingX;
        this.minY -= paddingY;
        this.maxY += paddingY;
      }
    }
    addFramePad(x0, y0, x1, y1, padX, padY) {
      x0 -= padX;
      y0 -= padY;
      x1 += padX;
      y1 += padY;
      this.minX = this.minX < x0 ? this.minX : x0;
      this.maxX = this.maxX > x1 ? this.maxX : x1;
      this.minY = this.minY < y0 ? this.minY : y0;
      this.maxY = this.maxY > y1 ? this.maxY : y1;
    }
  };
  var DisplayObject = class extends eventemitter3 {
    constructor() {
      super();
      this.tempDisplayObjectParent = null;
      this.transform = new Transform();
      this.alpha = 1;
      this.visible = true;
      this.renderable = true;
      this.cullable = false;
      this.cullArea = null;
      this.parent = null;
      this.worldAlpha = 1;
      this._lastSortedIndex = 0;
      this._zIndex = 0;
      this.filterArea = null;
      this.filters = null;
      this._enabledFilters = null;
      this._bounds = new Bounds();
      this._localBounds = null;
      this._boundsID = 0;
      this._boundsRect = null;
      this._localBoundsRect = null;
      this._mask = null;
      this._maskRefCount = 0;
      this._destroyed = false;
      this.isSprite = false;
      this.isMask = false;
    }
    static mixin(source) {
      const keys = Object.keys(source);
      for (let i = 0; i < keys.length; ++i) {
        const propertyName = keys[i];
        Object.defineProperty(DisplayObject.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
      }
    }
    get destroyed() {
      return this._destroyed;
    }
    _recursivePostUpdateTransform() {
      if (this.parent) {
        this.parent._recursivePostUpdateTransform();
        this.transform.updateTransform(this.parent.transform);
      } else {
        this.transform.updateTransform(this._tempDisplayObjectParent.transform);
      }
    }
    updateTransform() {
      this._boundsID++;
      this.transform.updateTransform(this.parent.transform);
      this.worldAlpha = this.alpha * this.parent.worldAlpha;
    }
    getBounds(skipUpdate, rect) {
      if (!skipUpdate) {
        if (!this.parent) {
          this.parent = this._tempDisplayObjectParent;
          this.updateTransform();
          this.parent = null;
        } else {
          this._recursivePostUpdateTransform();
          this.updateTransform();
        }
      }
      if (this._bounds.updateID !== this._boundsID) {
        this.calculateBounds();
        this._bounds.updateID = this._boundsID;
      }
      if (!rect) {
        if (!this._boundsRect) {
          this._boundsRect = new Rectangle();
        }
        rect = this._boundsRect;
      }
      return this._bounds.getRectangle(rect);
    }
    getLocalBounds(rect) {
      if (!rect) {
        if (!this._localBoundsRect) {
          this._localBoundsRect = new Rectangle();
        }
        rect = this._localBoundsRect;
      }
      if (!this._localBounds) {
        this._localBounds = new Bounds();
      }
      const transformRef = this.transform;
      const parentRef = this.parent;
      this.parent = null;
      this.transform = this._tempDisplayObjectParent.transform;
      const worldBounds = this._bounds;
      const worldBoundsID = this._boundsID;
      this._bounds = this._localBounds;
      const bounds = this.getBounds(false, rect);
      this.parent = parentRef;
      this.transform = transformRef;
      this._bounds = worldBounds;
      this._bounds.updateID += this._boundsID - worldBoundsID;
      return bounds;
    }
    toGlobal(position2, point, skipUpdate = false) {
      if (!skipUpdate) {
        this._recursivePostUpdateTransform();
        if (!this.parent) {
          this.parent = this._tempDisplayObjectParent;
          this.displayObjectUpdateTransform();
          this.parent = null;
        } else {
          this.displayObjectUpdateTransform();
        }
      }
      return this.worldTransform.apply(position2, point);
    }
    toLocal(position2, from, point, skipUpdate) {
      if (from) {
        position2 = from.toGlobal(position2, point, skipUpdate);
      }
      if (!skipUpdate) {
        this._recursivePostUpdateTransform();
        if (!this.parent) {
          this.parent = this._tempDisplayObjectParent;
          this.displayObjectUpdateTransform();
          this.parent = null;
        } else {
          this.displayObjectUpdateTransform();
        }
      }
      return this.worldTransform.applyInverse(position2, point);
    }
    setParent(container) {
      if (!container || !container.addChild) {
        throw new Error("setParent: Argument must be a Container");
      }
      container.addChild(this);
      return container;
    }
    removeFromParent() {
      this.parent?.removeChild(this);
    }
    setTransform(x = 0, y = 0, scaleX = 1, scaleY = 1, rotation = 0, skewX = 0, skewY = 0, pivotX = 0, pivotY = 0) {
      this.position.x = x;
      this.position.y = y;
      this.scale.x = !scaleX ? 1 : scaleX;
      this.scale.y = !scaleY ? 1 : scaleY;
      this.rotation = rotation;
      this.skew.x = skewX;
      this.skew.y = skewY;
      this.pivot.x = pivotX;
      this.pivot.y = pivotY;
      return this;
    }
    destroy(_options) {
      this.removeFromParent();
      this._destroyed = true;
      this.transform = null;
      this.parent = null;
      this._bounds = null;
      this.mask = null;
      this.cullArea = null;
      this.filters = null;
      this.filterArea = null;
      this.hitArea = null;
      this.interactive = false;
      this.interactiveChildren = false;
      this.emit("destroyed");
      this.removeAllListeners();
    }
    get _tempDisplayObjectParent() {
      if (this.tempDisplayObjectParent === null) {
        this.tempDisplayObjectParent = new TemporaryDisplayObject();
      }
      return this.tempDisplayObjectParent;
    }
    enableTempParent() {
      const myParent = this.parent;
      this.parent = this._tempDisplayObjectParent;
      return myParent;
    }
    disableTempParent(cacheParent) {
      this.parent = cacheParent;
    }
    get x() {
      return this.position.x;
    }
    set x(value3) {
      this.transform.position.x = value3;
    }
    get y() {
      return this.position.y;
    }
    set y(value3) {
      this.transform.position.y = value3;
    }
    get worldTransform() {
      return this.transform.worldTransform;
    }
    get localTransform() {
      return this.transform.localTransform;
    }
    get position() {
      return this.transform.position;
    }
    set position(value3) {
      this.transform.position.copyFrom(value3);
    }
    get scale() {
      return this.transform.scale;
    }
    set scale(value3) {
      this.transform.scale.copyFrom(value3);
    }
    get pivot() {
      return this.transform.pivot;
    }
    set pivot(value3) {
      this.transform.pivot.copyFrom(value3);
    }
    get skew() {
      return this.transform.skew;
    }
    set skew(value3) {
      this.transform.skew.copyFrom(value3);
    }
    get rotation() {
      return this.transform.rotation;
    }
    set rotation(value3) {
      this.transform.rotation = value3;
    }
    get angle() {
      return this.transform.rotation * RAD_TO_DEG;
    }
    set angle(value3) {
      this.transform.rotation = value3 * DEG_TO_RAD;
    }
    get zIndex() {
      return this._zIndex;
    }
    set zIndex(value3) {
      this._zIndex = value3;
      if (this.parent) {
        this.parent.sortDirty = true;
      }
    }
    get worldVisible() {
      let item2 = this;
      do {
        if (!item2.visible) {
          return false;
        }
        item2 = item2.parent;
      } while (item2);
      return true;
    }
    get mask() {
      return this._mask;
    }
    set mask(value3) {
      if (this._mask === value3) {
        return;
      }
      if (this._mask) {
        const maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;
        if (maskObject) {
          maskObject._maskRefCount--;
          if (maskObject._maskRefCount === 0) {
            maskObject.renderable = true;
            maskObject.isMask = false;
          }
        }
      }
      this._mask = value3;
      if (this._mask) {
        const maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;
        if (maskObject) {
          if (maskObject._maskRefCount === 0) {
            maskObject.renderable = false;
            maskObject.isMask = true;
          }
          maskObject._maskRefCount++;
        }
      }
    }
  };
  var TemporaryDisplayObject = class extends DisplayObject {
    constructor() {
      super(...arguments);
      this.sortDirty = null;
    }
  };
  DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;
  var tempMatrix = new Matrix();
  function sortChildren(a2, b2) {
    if (a2.zIndex === b2.zIndex) {
      return a2._lastSortedIndex - b2._lastSortedIndex;
    }
    return a2.zIndex - b2.zIndex;
  }
  var Container = class extends DisplayObject {
    constructor() {
      super();
      this.children = [];
      this.sortableChildren = settings.SORTABLE_CHILDREN;
      this.sortDirty = false;
    }
    onChildrenChange(_length) {
    }
    addChild(...children) {
      if (children.length > 1) {
        for (let i = 0; i < children.length; i++) {
          this.addChild(children[i]);
        }
      } else {
        const child = children[0];
        if (child.parent) {
          child.parent.removeChild(child);
        }
        child.parent = this;
        this.sortDirty = true;
        child.transform._parentID = -1;
        this.children.push(child);
        this._boundsID++;
        this.onChildrenChange(this.children.length - 1);
        this.emit("childAdded", child, this, this.children.length - 1);
        child.emit("added", this);
      }
      return children[0];
    }
    addChildAt(child, index2) {
      if (index2 < 0 || index2 > this.children.length) {
        throw new Error(`${child}addChildAt: The index ${index2} supplied is out of bounds ${this.children.length}`);
      }
      if (child.parent) {
        child.parent.removeChild(child);
      }
      child.parent = this;
      this.sortDirty = true;
      child.transform._parentID = -1;
      this.children.splice(index2, 0, child);
      this._boundsID++;
      this.onChildrenChange(index2);
      child.emit("added", this);
      this.emit("childAdded", child, this, index2);
      return child;
    }
    swapChildren(child, child2) {
      if (child === child2) {
        return;
      }
      const index1 = this.getChildIndex(child);
      const index2 = this.getChildIndex(child2);
      this.children[index1] = child2;
      this.children[index2] = child;
      this.onChildrenChange(index1 < index2 ? index1 : index2);
    }
    getChildIndex(child) {
      const index2 = this.children.indexOf(child);
      if (index2 === -1) {
        throw new Error("The supplied DisplayObject must be a child of the caller");
      }
      return index2;
    }
    setChildIndex(child, index$1) {
      if (index$1 < 0 || index$1 >= this.children.length) {
        throw new Error(`The index ${index$1} supplied is out of bounds ${this.children.length}`);
      }
      const currentIndex = this.getChildIndex(child);
      removeItems(this.children, currentIndex, 1);
      this.children.splice(index$1, 0, child);
      this.onChildrenChange(index$1);
    }
    getChildAt(index2) {
      if (index2 < 0 || index2 >= this.children.length) {
        throw new Error(`getChildAt: Index (${index2}) does not exist.`);
      }
      return this.children[index2];
    }
    removeChild(...children) {
      if (children.length > 1) {
        for (let i = 0; i < children.length; i++) {
          this.removeChild(children[i]);
        }
      } else {
        const child = children[0];
        const index$1 = this.children.indexOf(child);
        if (index$1 === -1)
          return null;
        child.parent = null;
        child.transform._parentID = -1;
        removeItems(this.children, index$1, 1);
        this._boundsID++;
        this.onChildrenChange(index$1);
        child.emit("removed", this);
        this.emit("childRemoved", child, this, index$1);
      }
      return children[0];
    }
    removeChildAt(index$1) {
      const child = this.getChildAt(index$1);
      child.parent = null;
      child.transform._parentID = -1;
      removeItems(this.children, index$1, 1);
      this._boundsID++;
      this.onChildrenChange(index$1);
      child.emit("removed", this);
      this.emit("childRemoved", child, this, index$1);
      return child;
    }
    removeChildren(beginIndex = 0, endIndex = this.children.length) {
      const begin = beginIndex;
      const end = endIndex;
      const range = end - begin;
      let removed;
      if (range > 0 && range <= end) {
        removed = this.children.splice(begin, range);
        for (let i = 0; i < removed.length; ++i) {
          removed[i].parent = null;
          if (removed[i].transform) {
            removed[i].transform._parentID = -1;
          }
        }
        this._boundsID++;
        this.onChildrenChange(beginIndex);
        for (let i = 0; i < removed.length; ++i) {
          removed[i].emit("removed", this);
          this.emit("childRemoved", removed[i], this, i);
        }
        return removed;
      } else if (range === 0 && this.children.length === 0) {
        return [];
      }
      throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
    }
    sortChildren() {
      let sortRequired = false;
      for (let i = 0, j = this.children.length; i < j; ++i) {
        const child = this.children[i];
        child._lastSortedIndex = i;
        if (!sortRequired && child.zIndex !== 0) {
          sortRequired = true;
        }
      }
      if (sortRequired && this.children.length > 1) {
        this.children.sort(sortChildren);
      }
      this.sortDirty = false;
    }
    updateTransform() {
      if (this.sortableChildren && this.sortDirty) {
        this.sortChildren();
      }
      this._boundsID++;
      this.transform.updateTransform(this.parent.transform);
      this.worldAlpha = this.alpha * this.parent.worldAlpha;
      for (let i = 0, j = this.children.length; i < j; ++i) {
        const child = this.children[i];
        if (child.visible) {
          child.updateTransform();
        }
      }
    }
    calculateBounds() {
      this._bounds.clear();
      this._calculateBounds();
      for (let i = 0; i < this.children.length; i++) {
        const child = this.children[i];
        if (!child.visible || !child.renderable) {
          continue;
        }
        child.calculateBounds();
        if (child._mask) {
          const maskObject = child._mask.isMaskData ? child._mask.maskObject : child._mask;
          if (maskObject) {
            maskObject.calculateBounds();
            this._bounds.addBoundsMask(child._bounds, maskObject._bounds);
          } else {
            this._bounds.addBounds(child._bounds);
          }
        } else if (child.filterArea) {
          this._bounds.addBoundsArea(child._bounds, child.filterArea);
        } else {
          this._bounds.addBounds(child._bounds);
        }
      }
      this._bounds.updateID = this._boundsID;
    }
    getLocalBounds(rect, skipChildrenUpdate = false) {
      const result2 = super.getLocalBounds(rect);
      if (!skipChildrenUpdate) {
        for (let i = 0, j = this.children.length; i < j; ++i) {
          const child = this.children[i];
          if (child.visible) {
            child.updateTransform();
          }
        }
      }
      return result2;
    }
    _calculateBounds() {
    }
    _renderWithCulling(renderer) {
      const sourceFrame = renderer.renderTexture.sourceFrame;
      if (!(sourceFrame.width > 0 && sourceFrame.height > 0)) {
        return;
      }
      let bounds;
      let transform;
      if (this.cullArea) {
        bounds = this.cullArea;
        transform = this.worldTransform;
      } else if (this._render !== Container.prototype._render) {
        bounds = this.getBounds(true);
      }
      const projectionTransform = renderer.projection.transform;
      if (projectionTransform) {
        if (transform) {
          transform = tempMatrix.copyFrom(transform);
          transform.prepend(projectionTransform);
        } else {
          transform = projectionTransform;
        }
      }
      if (bounds && sourceFrame.intersects(bounds, transform)) {
        this._render(renderer);
      } else if (this.cullArea) {
        return;
      }
      for (let i = 0, j = this.children.length; i < j; ++i) {
        const child = this.children[i];
        const childCullable = child.cullable;
        child.cullable = childCullable || !this.cullArea;
        child.render(renderer);
        child.cullable = childCullable;
      }
    }
    render(renderer) {
      if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
        return;
      }
      if (this._mask || this.filters?.length) {
        this.renderAdvanced(renderer);
      } else if (this.cullable) {
        this._renderWithCulling(renderer);
      } else {
        this._render(renderer);
        for (let i = 0, j = this.children.length; i < j; ++i) {
          this.children[i].render(renderer);
        }
      }
    }
    renderAdvanced(renderer) {
      const filters2 = this.filters;
      const mask = this._mask;
      if (filters2) {
        if (!this._enabledFilters) {
          this._enabledFilters = [];
        }
        this._enabledFilters.length = 0;
        for (let i = 0; i < filters2.length; i++) {
          if (filters2[i].enabled) {
            this._enabledFilters.push(filters2[i]);
          }
        }
      }
      const flush = filters2 && this._enabledFilters?.length || mask && (!mask.isMaskData || mask.enabled && (mask.autoDetect || mask.type !== MASK_TYPES.NONE));
      if (flush) {
        renderer.batch.flush();
      }
      if (filters2 && this._enabledFilters?.length) {
        renderer.filter.push(this, this._enabledFilters);
      }
      if (mask) {
        renderer.mask.push(this, this._mask);
      }
      if (this.cullable) {
        this._renderWithCulling(renderer);
      } else {
        this._render(renderer);
        for (let i = 0, j = this.children.length; i < j; ++i) {
          this.children[i].render(renderer);
        }
      }
      if (flush) {
        renderer.batch.flush();
      }
      if (mask) {
        renderer.mask.pop(this);
      }
      if (filters2 && this._enabledFilters?.length) {
        renderer.filter.pop();
      }
    }
    _render(_renderer) {
    }
    destroy(options) {
      super.destroy();
      this.sortDirty = false;
      const destroyChildren = typeof options === "boolean" ? options : options?.children;
      const oldChildren = this.removeChildren(0, this.children.length);
      if (destroyChildren) {
        for (let i = 0; i < oldChildren.length; ++i) {
          oldChildren[i].destroy(options);
        }
      }
    }
    get width() {
      return this.scale.x * this.getLocalBounds().width;
    }
    set width(value3) {
      const width = this.getLocalBounds().width;
      if (width !== 0) {
        this.scale.x = value3 / width;
      } else {
        this.scale.x = 1;
      }
      this._width = value3;
    }
    get height() {
      return this.scale.y * this.getLocalBounds().height;
    }
    set height(value3) {
      const height = this.getLocalBounds().height;
      if (height !== 0) {
        this.scale.y = value3 / height;
      } else {
        this.scale.y = 1;
      }
      this._height = value3;
    }
  };
  Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;
  var tempPoint$2 = new Point();
  var indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
  var Sprite = class extends Container {
    constructor(texture) {
      super();
      this._anchor = new ObservablePoint(this._onAnchorUpdate, this, texture ? texture.defaultAnchor.x : 0, texture ? texture.defaultAnchor.y : 0);
      this._texture = null;
      this._width = 0;
      this._height = 0;
      this._tint = null;
      this._tintRGB = null;
      this.tint = 16777215;
      this.blendMode = BLEND_MODES.NORMAL;
      this._cachedTint = 16777215;
      this.uvs = null;
      this.texture = texture || Texture.EMPTY;
      this.vertexData = new Float32Array(8);
      this.vertexTrimmedData = null;
      this._transformID = -1;
      this._textureID = -1;
      this._transformTrimmedID = -1;
      this._textureTrimmedID = -1;
      this.indices = indices;
      this.pluginName = "batch";
      this.isSprite = true;
      this._roundPixels = settings.ROUND_PIXELS;
    }
    _onTextureUpdate() {
      this._textureID = -1;
      this._textureTrimmedID = -1;
      this._cachedTint = 16777215;
      if (this._width) {
        this.scale.x = sign2(this.scale.x) * this._width / this._texture.orig.width;
      }
      if (this._height) {
        this.scale.y = sign2(this.scale.y) * this._height / this._texture.orig.height;
      }
    }
    _onAnchorUpdate() {
      this._transformID = -1;
      this._transformTrimmedID = -1;
    }
    calculateVertices() {
      const texture = this._texture;
      if (this._transformID === this.transform._worldID && this._textureID === texture._updateID) {
        return;
      }
      if (this._textureID !== texture._updateID) {
        this.uvs = this._texture._uvs.uvsFloat32;
      }
      this._transformID = this.transform._worldID;
      this._textureID = texture._updateID;
      const wt = this.transform.worldTransform;
      const a2 = wt.a;
      const b2 = wt.b;
      const c = wt.c;
      const d = wt.d;
      const tx = wt.tx;
      const ty = wt.ty;
      const vertexData = this.vertexData;
      const trim = texture.trim;
      const orig = texture.orig;
      const anchor = this._anchor;
      let w0 = 0;
      let w1 = 0;
      let h0 = 0;
      let h1 = 0;
      if (trim) {
        w1 = trim.x - anchor._x * orig.width;
        w0 = w1 + trim.width;
        h1 = trim.y - anchor._y * orig.height;
        h0 = h1 + trim.height;
      } else {
        w1 = -anchor._x * orig.width;
        w0 = w1 + orig.width;
        h1 = -anchor._y * orig.height;
        h0 = h1 + orig.height;
      }
      vertexData[0] = a2 * w1 + c * h1 + tx;
      vertexData[1] = d * h1 + b2 * w1 + ty;
      vertexData[2] = a2 * w0 + c * h1 + tx;
      vertexData[3] = d * h1 + b2 * w0 + ty;
      vertexData[4] = a2 * w0 + c * h0 + tx;
      vertexData[5] = d * h0 + b2 * w0 + ty;
      vertexData[6] = a2 * w1 + c * h0 + tx;
      vertexData[7] = d * h0 + b2 * w1 + ty;
      if (this._roundPixels) {
        const resolution = settings.RESOLUTION;
        for (let i = 0; i < vertexData.length; ++i) {
          vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;
        }
      }
    }
    calculateTrimmedVertices() {
      if (!this.vertexTrimmedData) {
        this.vertexTrimmedData = new Float32Array(8);
      } else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {
        return;
      }
      this._transformTrimmedID = this.transform._worldID;
      this._textureTrimmedID = this._texture._updateID;
      const texture = this._texture;
      const vertexData = this.vertexTrimmedData;
      const orig = texture.orig;
      const anchor = this._anchor;
      const wt = this.transform.worldTransform;
      const a2 = wt.a;
      const b2 = wt.b;
      const c = wt.c;
      const d = wt.d;
      const tx = wt.tx;
      const ty = wt.ty;
      const w1 = -anchor._x * orig.width;
      const w0 = w1 + orig.width;
      const h1 = -anchor._y * orig.height;
      const h0 = h1 + orig.height;
      vertexData[0] = a2 * w1 + c * h1 + tx;
      vertexData[1] = d * h1 + b2 * w1 + ty;
      vertexData[2] = a2 * w0 + c * h1 + tx;
      vertexData[3] = d * h1 + b2 * w0 + ty;
      vertexData[4] = a2 * w0 + c * h0 + tx;
      vertexData[5] = d * h0 + b2 * w0 + ty;
      vertexData[6] = a2 * w1 + c * h0 + tx;
      vertexData[7] = d * h0 + b2 * w1 + ty;
    }
    _render(renderer) {
      this.calculateVertices();
      renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
      renderer.plugins[this.pluginName].render(this);
    }
    _calculateBounds() {
      const trim = this._texture.trim;
      const orig = this._texture.orig;
      if (!trim || trim.width === orig.width && trim.height === orig.height) {
        this.calculateVertices();
        this._bounds.addQuad(this.vertexData);
      } else {
        this.calculateTrimmedVertices();
        this._bounds.addQuad(this.vertexTrimmedData);
      }
    }
    getLocalBounds(rect) {
      if (this.children.length === 0) {
        if (!this._localBounds) {
          this._localBounds = new Bounds();
        }
        this._localBounds.minX = this._texture.orig.width * -this._anchor._x;
        this._localBounds.minY = this._texture.orig.height * -this._anchor._y;
        this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x);
        this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y);
        if (!rect) {
          if (!this._localBoundsRect) {
            this._localBoundsRect = new Rectangle();
          }
          rect = this._localBoundsRect;
        }
        return this._localBounds.getRectangle(rect);
      }
      return super.getLocalBounds.call(this, rect);
    }
    containsPoint(point) {
      this.worldTransform.applyInverse(point, tempPoint$2);
      const width = this._texture.orig.width;
      const height = this._texture.orig.height;
      const x1 = -width * this.anchor.x;
      let y1 = 0;
      if (tempPoint$2.x >= x1 && tempPoint$2.x < x1 + width) {
        y1 = -height * this.anchor.y;
        if (tempPoint$2.y >= y1 && tempPoint$2.y < y1 + height) {
          return true;
        }
      }
      return false;
    }
    destroy(options) {
      super.destroy(options);
      this._texture.off("update", this._onTextureUpdate, this);
      this._anchor = null;
      const destroyTexture = typeof options === "boolean" ? options : options?.texture;
      if (destroyTexture) {
        const destroyBaseTexture = typeof options === "boolean" ? options : options?.baseTexture;
        this._texture.destroy(!!destroyBaseTexture);
      }
      this._texture = null;
    }
    static from(source, options) {
      const texture = source instanceof Texture ? source : Texture.from(source, options);
      return new Sprite(texture);
    }
    set roundPixels(value3) {
      if (this._roundPixels !== value3) {
        this._transformID = -1;
      }
      this._roundPixels = value3;
    }
    get roundPixels() {
      return this._roundPixels;
    }
    get width() {
      return Math.abs(this.scale.x) * this._texture.orig.width;
    }
    set width(value3) {
      const s = sign2(this.scale.x) || 1;
      this.scale.x = s * value3 / this._texture.orig.width;
      this._width = value3;
    }
    get height() {
      return Math.abs(this.scale.y) * this._texture.orig.height;
    }
    set height(value3) {
      const s = sign2(this.scale.y) || 1;
      this.scale.y = s * value3 / this._texture.orig.height;
      this._height = value3;
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(value3) {
      this._anchor.copyFrom(value3);
    }
    get tint() {
      return this._tint;
    }
    set tint(value3) {
      this._tint = value3;
      this._tintRGB = (value3 >> 16) + (value3 & 65280) + ((value3 & 255) << 16);
    }
    get texture() {
      return this._texture;
    }
    set texture(value3) {
      if (this._texture === value3) {
        return;
      }
      if (this._texture) {
        this._texture.off("update", this._onTextureUpdate, this);
      }
      this._texture = value3 || Texture.EMPTY;
      this._cachedTint = 16777215;
      this._textureID = -1;
      this._textureTrimmedID = -1;
      if (value3) {
        if (value3.baseTexture.valid) {
          this._onTextureUpdate();
        } else {
          value3.once("update", this._onTextureUpdate, this);
        }
      }
    }
  };
  var _tempMatrix = new Matrix();
  DisplayObject.prototype._cacheAsBitmap = false;
  DisplayObject.prototype._cacheData = null;
  DisplayObject.prototype._cacheAsBitmapResolution = null;
  DisplayObject.prototype._cacheAsBitmapMultisample = null;
  var CacheData = class {
    constructor() {
      this.textureCacheId = null;
      this.originalRender = null;
      this.originalRenderCanvas = null;
      this.originalCalculateBounds = null;
      this.originalGetLocalBounds = null;
      this.originalUpdateTransform = null;
      this.originalDestroy = null;
      this.originalMask = null;
      this.originalFilterArea = null;
      this.originalContainsPoint = null;
      this.sprite = null;
    }
  };
  Object.defineProperties(DisplayObject.prototype, {
    cacheAsBitmapResolution: {
      get() {
        return this._cacheAsBitmapResolution;
      },
      set(resolution) {
        if (resolution === this._cacheAsBitmapResolution) {
          return;
        }
        this._cacheAsBitmapResolution = resolution;
        if (this.cacheAsBitmap) {
          this.cacheAsBitmap = false;
          this.cacheAsBitmap = true;
        }
      }
    },
    cacheAsBitmapMultisample: {
      get() {
        return this._cacheAsBitmapMultisample;
      },
      set(multisample) {
        if (multisample === this._cacheAsBitmapMultisample) {
          return;
        }
        this._cacheAsBitmapMultisample = multisample;
        if (this.cacheAsBitmap) {
          this.cacheAsBitmap = false;
          this.cacheAsBitmap = true;
        }
      }
    },
    cacheAsBitmap: {
      get() {
        return this._cacheAsBitmap;
      },
      set(value3) {
        if (this._cacheAsBitmap === value3) {
          return;
        }
        this._cacheAsBitmap = value3;
        let data;
        if (value3) {
          if (!this._cacheData) {
            this._cacheData = new CacheData();
          }
          data = this._cacheData;
          data.originalRender = this.render;
          data.originalRenderCanvas = this.renderCanvas;
          data.originalUpdateTransform = this.updateTransform;
          data.originalCalculateBounds = this.calculateBounds;
          data.originalGetLocalBounds = this.getLocalBounds;
          data.originalDestroy = this.destroy;
          data.originalContainsPoint = this.containsPoint;
          data.originalMask = this._mask;
          data.originalFilterArea = this.filterArea;
          this.render = this._renderCached;
          this.renderCanvas = this._renderCachedCanvas;
          this.destroy = this._cacheAsBitmapDestroy;
        } else {
          data = this._cacheData;
          if (data.sprite) {
            this._destroyCachedDisplayObject();
          }
          this.render = data.originalRender;
          this.renderCanvas = data.originalRenderCanvas;
          this.calculateBounds = data.originalCalculateBounds;
          this.getLocalBounds = data.originalGetLocalBounds;
          this.destroy = data.originalDestroy;
          this.updateTransform = data.originalUpdateTransform;
          this.containsPoint = data.originalContainsPoint;
          this._mask = data.originalMask;
          this.filterArea = data.originalFilterArea;
        }
      }
    }
  });
  DisplayObject.prototype._renderCached = function _renderCached(renderer) {
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
      return;
    }
    this._initCachedDisplayObject(renderer);
    this._cacheData.sprite.transform._worldID = this.transform._worldID;
    this._cacheData.sprite.worldAlpha = this.worldAlpha;
    this._cacheData.sprite._render(renderer);
  };
  DisplayObject.prototype._initCachedDisplayObject = function _initCachedDisplayObject(renderer) {
    if (this._cacheData?.sprite) {
      return;
    }
    const cacheAlpha = this.alpha;
    this.alpha = 1;
    renderer.batch.flush();
    const bounds = this.getLocalBounds(null, true).clone();
    if (this.filters?.length) {
      const padding = this.filters[0].padding;
      bounds.pad(padding);
    }
    bounds.ceil(settings.RESOLUTION);
    const cachedRenderTexture = renderer.renderTexture.current;
    const cachedSourceFrame = renderer.renderTexture.sourceFrame.clone();
    const cachedDestinationFrame = renderer.renderTexture.destinationFrame.clone();
    const cachedProjectionTransform = renderer.projection.transform;
    const renderTexture = RenderTexture.create({
      width: bounds.width,
      height: bounds.height,
      resolution: this.cacheAsBitmapResolution || renderer.resolution,
      multisample: this.cacheAsBitmapMultisample ?? renderer.multisample
    });
    const textureCacheId = `cacheAsBitmap_${uid()}`;
    this._cacheData.textureCacheId = textureCacheId;
    BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
    Texture.addToCache(renderTexture, textureCacheId);
    const m = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-bounds.x, -bounds.y);
    this.render = this._cacheData.originalRender;
    renderer.render(this, { renderTexture, clear: true, transform: m, skipUpdateTransform: false });
    renderer.framebuffer.blit();
    renderer.projection.transform = cachedProjectionTransform;
    renderer.renderTexture.bind(cachedRenderTexture, cachedSourceFrame, cachedDestinationFrame);
    this.render = this._renderCached;
    this.updateTransform = this.displayObjectUpdateTransform;
    this.calculateBounds = this._calculateCachedBounds;
    this.getLocalBounds = this._getCachedLocalBounds;
    this._mask = null;
    this.filterArea = null;
    this.alpha = cacheAlpha;
    const cachedSprite = new Sprite(renderTexture);
    cachedSprite.transform.worldTransform = this.transform.worldTransform;
    cachedSprite.anchor.x = -(bounds.x / bounds.width);
    cachedSprite.anchor.y = -(bounds.y / bounds.height);
    cachedSprite.alpha = cacheAlpha;
    cachedSprite._bounds = this._bounds;
    this._cacheData.sprite = cachedSprite;
    this.transform._parentID = -1;
    if (!this.parent) {
      this.enableTempParent();
      this.updateTransform();
      this.disableTempParent(null);
    } else {
      this.updateTransform();
    }
    this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
  };
  DisplayObject.prototype._renderCachedCanvas = function _renderCachedCanvas(renderer) {
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
      return;
    }
    this._initCachedDisplayObjectCanvas(renderer);
    this._cacheData.sprite.worldAlpha = this.worldAlpha;
    this._cacheData.sprite._renderCanvas(renderer);
  };
  DisplayObject.prototype._initCachedDisplayObjectCanvas = function _initCachedDisplayObjectCanvas(renderer) {
    if (this._cacheData?.sprite) {
      return;
    }
    const bounds = this.getLocalBounds(null, true);
    const cacheAlpha = this.alpha;
    this.alpha = 1;
    const cachedRenderTarget = renderer.canvasContext.activeContext;
    const cachedProjectionTransform = renderer._projTransform;
    bounds.ceil(settings.RESOLUTION);
    const renderTexture = RenderTexture.create({ width: bounds.width, height: bounds.height });
    const textureCacheId = `cacheAsBitmap_${uid()}`;
    this._cacheData.textureCacheId = textureCacheId;
    BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
    Texture.addToCache(renderTexture, textureCacheId);
    const m = _tempMatrix;
    this.transform.localTransform.copyTo(m);
    m.invert();
    m.tx -= bounds.x;
    m.ty -= bounds.y;
    this.renderCanvas = this._cacheData.originalRenderCanvas;
    renderer.render(this, { renderTexture, clear: true, transform: m, skipUpdateTransform: false });
    renderer.canvasContext.activeContext = cachedRenderTarget;
    renderer._projTransform = cachedProjectionTransform;
    this.renderCanvas = this._renderCachedCanvas;
    this.updateTransform = this.displayObjectUpdateTransform;
    this.calculateBounds = this._calculateCachedBounds;
    this.getLocalBounds = this._getCachedLocalBounds;
    this._mask = null;
    this.filterArea = null;
    this.alpha = cacheAlpha;
    const cachedSprite = new Sprite(renderTexture);
    cachedSprite.transform.worldTransform = this.transform.worldTransform;
    cachedSprite.anchor.x = -(bounds.x / bounds.width);
    cachedSprite.anchor.y = -(bounds.y / bounds.height);
    cachedSprite.alpha = cacheAlpha;
    cachedSprite._bounds = this._bounds;
    this._cacheData.sprite = cachedSprite;
    this.transform._parentID = -1;
    if (!this.parent) {
      this.parent = renderer._tempDisplayObjectParent;
      this.updateTransform();
      this.parent = null;
    } else {
      this.updateTransform();
    }
    this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
  };
  DisplayObject.prototype._calculateCachedBounds = function _calculateCachedBounds() {
    this._bounds.clear();
    this._cacheData.sprite.transform._worldID = this.transform._worldID;
    this._cacheData.sprite._calculateBounds();
    this._bounds.updateID = this._boundsID;
  };
  DisplayObject.prototype._getCachedLocalBounds = function _getCachedLocalBounds() {
    return this._cacheData.sprite.getLocalBounds(null);
  };
  DisplayObject.prototype._destroyCachedDisplayObject = function _destroyCachedDisplayObject() {
    this._cacheData.sprite._texture.destroy(true);
    this._cacheData.sprite = null;
    BaseTexture.removeFromCache(this._cacheData.textureCacheId);
    Texture.removeFromCache(this._cacheData.textureCacheId);
    this._cacheData.textureCacheId = null;
  };
  DisplayObject.prototype._cacheAsBitmapDestroy = function _cacheAsBitmapDestroy(options) {
    this.cacheAsBitmap = false;
    this.destroy(options);
  };
  DisplayObject.prototype.name = null;
  Container.prototype.getChildByName = function getChildByName(name, deep) {
    for (let i = 0, j = this.children.length; i < j; i++) {
      if (this.children[i].name === name) {
        return this.children[i];
      }
    }
    if (deep) {
      for (let i = 0, j = this.children.length; i < j; i++) {
        const child = this.children[i];
        if (!child.getChildByName) {
          continue;
        }
        const target2 = child.getChildByName(name, true);
        if (target2) {
          return target2;
        }
      }
    }
    return null;
  };
  DisplayObject.prototype.getGlobalPosition = function getGlobalPosition(point = new Point(), skipUpdate = false) {
    if (this.parent) {
      this.parent.toGlobal(this.position, point, skipUpdate);
    } else {
      point.x = this.position.x;
      point.y = this.position.y;
    }
    return point;
  };
  var _Application = class {
    constructor(options) {
      this.stage = new Container();
      options = Object.assign({
        forceCanvas: false
      }, options);
      this.renderer = autoDetectRenderer(options);
      _Application._plugins.forEach((plugin) => {
        plugin.init.call(this, options);
      });
    }
    render() {
      this.renderer.render(this.stage);
    }
    get view() {
      return this.renderer.view;
    }
    get screen() {
      return this.renderer.screen;
    }
    destroy(removeView, stageOptions) {
      const plugins = _Application._plugins.slice(0);
      plugins.reverse();
      plugins.forEach((plugin) => {
        plugin.destroy.call(this);
      });
      this.stage.destroy(stageOptions);
      this.stage = null;
      this.renderer.destroy(removeView);
      this.renderer = null;
    }
  };
  var Application = _Application;
  Application._plugins = [];
  extensions$1.handleByList(ExtensionType.Application, Application._plugins);
  var ResizePlugin = class {
    static init(options) {
      Object.defineProperty(this, "resizeTo", {
        set(dom2) {
          globalThis.removeEventListener("resize", this.queueResize);
          this._resizeTo = dom2;
          if (dom2) {
            globalThis.addEventListener("resize", this.queueResize);
            this.resize();
          }
        },
        get() {
          return this._resizeTo;
        }
      });
      this.queueResize = () => {
        if (!this._resizeTo) {
          return;
        }
        this.cancelResize();
        this._resizeId = requestAnimationFrame(() => this.resize());
      };
      this.cancelResize = () => {
        if (this._resizeId) {
          cancelAnimationFrame(this._resizeId);
          this._resizeId = null;
        }
      };
      this.resize = () => {
        if (!this._resizeTo) {
          return;
        }
        this.cancelResize();
        let width;
        let height;
        if (this._resizeTo === globalThis.window) {
          width = globalThis.innerWidth;
          height = globalThis.innerHeight;
        } else {
          const { clientWidth, clientHeight } = this._resizeTo;
          width = clientWidth;
          height = clientHeight;
        }
        this.renderer.resize(width, height);
        this.render();
      };
      this._resizeId = null;
      this._resizeTo = null;
      this.resizeTo = options.resizeTo || null;
    }
    static destroy() {
      globalThis.removeEventListener("resize", this.queueResize);
      this.cancelResize();
      this.cancelResize = null;
      this.queueResize = null;
      this.resizeTo = null;
      this.resize = null;
    }
  };
  ResizePlugin.extension = ExtensionType.Application;
  extensions$1.add(ResizePlugin);
  var BackgroundLoader = class {
    constructor(loader, verbose = false) {
      this._loader = loader;
      this._assetList = [];
      this._isLoading = false;
      this._maxConcurrent = 1;
      this.verbose = verbose;
    }
    add(assetUrls) {
      assetUrls.forEach((a2) => {
        this._assetList.push(a2);
      });
      if (this.verbose)
        console.log("[BackgroundLoader] assets: ", this._assetList);
      if (this._isActive && !this._isLoading) {
        this._next();
      }
    }
    async _next() {
      if (this._assetList.length && this._isActive) {
        this._isLoading = true;
        const toLoad = [];
        const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);
        for (let i = 0; i < toLoadAmount; i++) {
          toLoad.push(this._assetList.pop());
        }
        await this._loader.load(toLoad);
        this._isLoading = false;
        this._next();
      }
    }
    get active() {
      return this._isActive;
    }
    set active(value3) {
      if (this._isActive === value3)
        return;
      this._isActive = value3;
      if (value3 && !this._isLoading) {
        this._next();
      }
    }
  };
  function checkDataUrl(url2, mimes) {
    if (Array.isArray(mimes)) {
      for (const mime of mimes) {
        if (url2.startsWith(`data:${mime}`))
          return true;
      }
      return false;
    }
    return url2.startsWith(`data:${mimes}`);
  }
  function checkExtension(url2, extension) {
    const tempURL = url2.split("?")[0];
    const ext = path.extname(tempURL).toLowerCase();
    if (Array.isArray(extension)) {
      return extension.includes(ext.toLowerCase());
    }
    return ext.toLowerCase() === extension;
  }
  var convertToList = (input, transform) => {
    if (!Array.isArray(input)) {
      input = [input];
    }
    if (!transform) {
      return input;
    }
    return input.map((item2) => {
      if (typeof item2 === "string") {
        return transform(item2);
      }
      return item2;
    });
  };
  function processX(base, ids, depth, result2, tags) {
    const id = ids[depth];
    for (let i = 0; i < id.length; i++) {
      const value3 = id[i];
      if (depth < ids.length - 1) {
        processX(base.replace(result2[depth], value3), ids, depth + 1, result2, tags);
      } else {
        tags.push(base.replace(result2[depth], value3));
      }
    }
  }
  function createStringVariations(string) {
    const regex = /\{(.*?)\}/g;
    const result2 = string.match(regex);
    const tags = [];
    if (result2) {
      const ids = [];
      result2.forEach((vars) => {
        const split2 = vars.substring(1, vars.length - 1).split(",");
        ids.push(split2);
      });
      processX(string, ids, 0, result2, tags);
    } else {
      tags.push(string);
    }
    return tags;
  }
  var isSingleItem = (item2) => !Array.isArray(item2);
  var CacheClass = class {
    constructor() {
      this._parsers = [];
      this._cache = /* @__PURE__ */ new Map();
      this._cacheMap = /* @__PURE__ */ new Map();
    }
    reset() {
      this._cacheMap.clear();
      this._cache.clear();
    }
    has(key) {
      return this._cache.has(key);
    }
    get(key) {
      const result2 = this._cache.get(key);
      if (!result2) {
        console.warn(`[Assets] Asset id ${key} was not found in the Cache`);
      }
      return result2;
    }
    set(key, value3) {
      const keys = convertToList(key);
      let cacheableAssets;
      for (let i = 0; i < this.parsers.length; i++) {
        const parser = this.parsers[i];
        if (parser.test(value3)) {
          cacheableAssets = parser.getCacheableAssets(keys, value3);
          break;
        }
      }
      if (!cacheableAssets) {
        cacheableAssets = {};
        keys.forEach((key2) => {
          cacheableAssets[key2] = value3;
        });
      }
      const cacheKeys = Object.keys(cacheableAssets);
      const cachedAssets = {
        cacheKeys,
        keys
      };
      keys.forEach((key2) => {
        this._cacheMap.set(key2, cachedAssets);
      });
      cacheKeys.forEach((key2) => {
        if (this._cache.has(key2) && this._cache.get(key2) !== value3) {
          console.warn("[Cache] already has key:", key2);
        }
        this._cache.set(key2, cacheableAssets[key2]);
      });
      if (value3 instanceof Texture) {
        const texture = value3;
        keys.forEach((key2) => {
          if (texture.baseTexture !== Texture.EMPTY.baseTexture) {
            BaseTexture.addToCache(texture.baseTexture, key2);
          }
          Texture.addToCache(texture, key2);
        });
      }
    }
    remove(key) {
      this._cacheMap.get(key);
      if (!this._cacheMap.has(key)) {
        console.warn(`[Assets] Asset id ${key} was not found in the Cache`);
        return;
      }
      const cacheMap = this._cacheMap.get(key);
      const cacheKeys = cacheMap.cacheKeys;
      cacheKeys.forEach((key2) => {
        this._cache.delete(key2);
      });
      cacheMap.keys.forEach((key2) => {
        this._cacheMap.delete(key2);
      });
    }
    get parsers() {
      return this._parsers;
    }
  };
  var Cache = new CacheClass();
  var Loader = class {
    constructor() {
      this._parsers = [];
      this.promiseCache = {};
    }
    reset() {
      this.promiseCache = {};
    }
    _getLoadPromiseAndParser(url2, data) {
      const result2 = {
        promise: null,
        parser: null
      };
      result2.promise = (async () => {
        let asset = null;
        for (let i = 0; i < this.parsers.length; i++) {
          const parser = this.parsers[i];
          if (parser.load && parser.test?.(url2, data, this)) {
            asset = await parser.load(url2, data, this);
            result2.parser = parser;
            break;
          }
        }
        if (!result2.parser) {
          console.warn(`[Assets] ${url2} could not be loaded as we don't know how to parse it, ensure the correct parser has being added`);
          return null;
        }
        for (let i = 0; i < this.parsers.length; i++) {
          const parser = this.parsers[i];
          if (parser.parse) {
            if (parser.parse && await parser.testParse?.(asset, data, this)) {
              asset = await parser.parse(asset, data, this) || asset;
              result2.parser = parser;
            }
          }
        }
        return asset;
      })();
      return result2;
    }
    async load(assetsToLoadIn, onProgress) {
      let count = 0;
      const assets = {};
      const singleAsset = isSingleItem(assetsToLoadIn);
      const assetsToLoad = convertToList(assetsToLoadIn, (item2) => ({
        src: item2
      }));
      const total = assetsToLoad.length;
      const promises = assetsToLoad.map(async (asset) => {
        const url2 = path.toAbsolute(asset.src);
        if (!assets[asset.src]) {
          try {
            if (!this.promiseCache[url2]) {
              this.promiseCache[url2] = this._getLoadPromiseAndParser(url2, asset);
            }
            assets[asset.src] = await this.promiseCache[url2].promise;
            if (onProgress)
              onProgress(++count / total);
          } catch (e) {
            delete this.promiseCache[url2];
            delete assets[asset.src];
            throw new Error(`[Loader.load] Failed to load ${url2}.
${e}`);
          }
        }
      });
      await Promise.all(promises);
      return singleAsset ? assets[assetsToLoad[0].src] : assets;
    }
    async unload(assetsToUnloadIn) {
      const assetsToUnload = convertToList(assetsToUnloadIn, (item2) => ({
        src: item2
      }));
      const promises = assetsToUnload.map(async (asset) => {
        const url2 = path.toAbsolute(asset.src);
        const loadPromise = this.promiseCache[url2];
        if (loadPromise) {
          const loadedAsset = await loadPromise.promise;
          loadPromise.parser?.unload?.(loadedAsset, asset, this);
          delete this.promiseCache[url2];
        }
      });
      await Promise.all(promises);
    }
    get parsers() {
      return this._parsers;
    }
  };
  var Resolver = class {
    constructor() {
      this._assetMap = {};
      this._preferredOrder = [];
      this._parsers = [];
      this._resolverHash = {};
      this._bundles = {};
    }
    prefer(...preferOrders) {
      preferOrders.forEach((prefer) => {
        this._preferredOrder.push(prefer);
        if (!prefer.priority) {
          prefer.priority = Object.keys(prefer.params);
        }
      });
      this._resolverHash = {};
    }
    set basePath(basePath) {
      this._basePath = basePath;
    }
    get basePath() {
      return this._basePath;
    }
    set rootPath(rootPath) {
      this._rootPath = rootPath;
    }
    get rootPath() {
      return this._rootPath;
    }
    get parsers() {
      return this._parsers;
    }
    reset() {
      this._preferredOrder = [];
      this._resolverHash = {};
      this._assetMap = {};
      this._rootPath = null;
      this._basePath = null;
      this._manifest = null;
    }
    addManifest(manifest) {
      if (this._manifest) {
        console.warn("[Resolver] Manifest already exists, this will be overwritten");
      }
      this._manifest = manifest;
      manifest.bundles.forEach((bundle) => {
        this.addBundle(bundle.name, bundle.assets);
      });
    }
    addBundle(bundleId, assets) {
      const assetNames = [];
      if (Array.isArray(assets)) {
        assets.forEach((asset) => {
          if (typeof asset.name === "string") {
            assetNames.push(asset.name);
          } else {
            assetNames.push(...asset.name);
          }
          this.add(asset.name, asset.srcs);
        });
      } else {
        Object.keys(assets).forEach((key) => {
          assetNames.push(key);
          this.add(key, assets[key]);
        });
      }
      this._bundles[bundleId] = assetNames;
    }
    add(keysIn, assetsIn, data) {
      const keys = convertToList(keysIn);
      keys.forEach((key) => {
        if (this._assetMap[key]) {
          console.warn(`[Resolver] already has key: ${key} overwriting`);
        }
      });
      if (!Array.isArray(assetsIn)) {
        if (typeof assetsIn === "string") {
          assetsIn = createStringVariations(assetsIn);
        } else {
          assetsIn = [assetsIn];
        }
      }
      const assetMap = assetsIn.map((asset) => {
        let formattedAsset = asset;
        if (typeof asset === "string") {
          let parsed = false;
          for (let i = 0; i < this._parsers.length; i++) {
            const parser = this._parsers[i];
            if (parser.test(asset)) {
              formattedAsset = parser.parse(asset);
              parsed = true;
              break;
            }
          }
          if (!parsed) {
            formattedAsset = {
              src: asset
            };
          }
        }
        if (!formattedAsset.format) {
          formattedAsset.format = formattedAsset.src.split(".").pop();
        }
        if (!formattedAsset.alias) {
          formattedAsset.alias = keys;
        }
        if (this._basePath || this._rootPath) {
          formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);
        }
        formattedAsset.data = formattedAsset.data ?? data;
        return formattedAsset;
      });
      keys.forEach((key) => {
        this._assetMap[key] = assetMap;
      });
    }
    resolveBundle(bundleIds) {
      const singleAsset = isSingleItem(bundleIds);
      bundleIds = convertToList(bundleIds);
      const out = {};
      bundleIds.forEach((bundleId) => {
        const assetNames = this._bundles[bundleId];
        if (assetNames) {
          out[bundleId] = this.resolve(assetNames);
        }
      });
      return singleAsset ? out[bundleIds[0]] : out;
    }
    resolveUrl(key) {
      const result2 = this.resolve(key);
      if (typeof key !== "string") {
        const out = {};
        for (const i in result2) {
          out[i] = result2[i].src;
        }
        return out;
      }
      return result2.src;
    }
    resolve(keys) {
      const singleAsset = isSingleItem(keys);
      keys = convertToList(keys);
      const result2 = {};
      keys.forEach((key) => {
        if (!this._resolverHash[key]) {
          if (this._assetMap[key]) {
            let assets = this._assetMap[key];
            const preferredOrder = this._getPreferredOrder(assets);
            const bestAsset = assets[0];
            preferredOrder?.priority.forEach((priorityKey) => {
              preferredOrder.params[priorityKey].forEach((value3) => {
                const filteredAssets = assets.filter((asset) => {
                  if (asset[priorityKey]) {
                    return asset[priorityKey] === value3;
                  }
                  return false;
                });
                if (filteredAssets.length) {
                  assets = filteredAssets;
                }
              });
            });
            this._resolverHash[key] = assets[0] ?? bestAsset;
          } else {
            let src = key;
            if (this._basePath || this._rootPath) {
              src = path.toAbsolute(src, this._basePath, this._rootPath);
            }
            this._resolverHash[key] = {
              src
            };
          }
        }
        result2[key] = this._resolverHash[key];
      });
      return singleAsset ? result2[keys[0]] : result2;
    }
    _getPreferredOrder(assets) {
      for (let i = 0; i < assets.length; i++) {
        const asset = assets[0];
        const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));
        if (preferred) {
          return preferred;
        }
      }
      return this._preferredOrder[0];
    }
  };
  var AssetsClass = class {
    constructor() {
      this._detections = [];
      this._initialized = false;
      this.resolver = new Resolver();
      this.loader = new Loader();
      this.cache = Cache;
      this._backgroundLoader = new BackgroundLoader(this.loader);
      this._backgroundLoader.active = true;
      this.reset();
    }
    async init(options = {}) {
      if (this._initialized) {
        console.warn("[Assets]AssetManager already initialized, did you load before calling this Asset.init()?");
        return;
      }
      this._initialized = true;
      if (options.basePath) {
        this.resolver.basePath = options.basePath;
      }
      if (options.manifest) {
        let manifest = options.manifest;
        if (typeof manifest === "string") {
          manifest = await this.load(manifest);
        }
        this.resolver.addManifest(manifest);
      }
      const resolutionPref = options.texturePreference?.resolution ?? 1;
      const resolution = typeof resolutionPref === "number" ? [resolutionPref] : resolutionPref;
      let formats2 = [];
      if (options.texturePreference?.format) {
        const formatPref = options.texturePreference?.format;
        formats2 = typeof formatPref === "string" ? [formatPref] : formatPref;
        for (const detection of this._detections) {
          if (!await detection.test()) {
            formats2 = await detection.remove(formats2);
          }
        }
      } else {
        for (const detection of this._detections) {
          if (await detection.test()) {
            formats2 = await detection.add(formats2);
          }
        }
      }
      this.resolver.prefer({
        params: {
          format: formats2,
          resolution
        }
      });
    }
    add(keysIn, assetsIn, data) {
      this.resolver.add(keysIn, assetsIn, data);
    }
    async load(urls, onProgress) {
      if (!this._initialized) {
        await this.init();
      }
      const singleAsset = isSingleItem(urls);
      const urlArray = convertToList(urls).map((url2) => {
        if (typeof url2 !== "string") {
          this.resolver.add(url2.src, url2);
          return url2.src;
        }
        return url2;
      });
      const resolveResults = this.resolver.resolve(urlArray);
      const out = await this._mapLoadToResolve(resolveResults, onProgress);
      return singleAsset ? out[urlArray[0]] : out;
    }
    addBundle(bundleId, assets) {
      this.resolver.addBundle(bundleId, assets);
    }
    async loadBundle(bundleIds, onProgress) {
      if (!this._initialized) {
        await this.init();
      }
      let singleAsset = false;
      if (typeof bundleIds === "string") {
        singleAsset = true;
        bundleIds = [bundleIds];
      }
      const resolveResults = this.resolver.resolveBundle(bundleIds);
      const out = {};
      const keys = Object.keys(resolveResults);
      let count = 0;
      let total = 0;
      const _onProgress = () => {
        onProgress?.(++count / total);
      };
      const promises = keys.map((bundleId) => {
        const resolveResult = resolveResults[bundleId];
        total += Object.keys(resolveResult).length;
        return this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {
          out[bundleId] = resolveResult2;
        });
      });
      await Promise.all(promises);
      return singleAsset ? out[bundleIds[0]] : out;
    }
    async backgroundLoad(urls) {
      if (!this._initialized) {
        await this.init();
      }
      if (typeof urls === "string") {
        urls = [urls];
      }
      const resolveResults = this.resolver.resolve(urls);
      this._backgroundLoader.add(Object.values(resolveResults));
    }
    async backgroundLoadBundle(bundleIds) {
      if (!this._initialized) {
        await this.init();
      }
      if (typeof bundleIds === "string") {
        bundleIds = [bundleIds];
      }
      const resolveResults = this.resolver.resolveBundle(bundleIds);
      Object.values(resolveResults).forEach((resolveResult) => {
        this._backgroundLoader.add(Object.values(resolveResult));
      });
    }
    reset() {
      this.resolver.reset();
      this.loader.reset();
      this.cache.reset();
      this._initialized = false;
    }
    get(keys) {
      if (typeof keys === "string") {
        return Cache.get(keys);
      }
      const assets = {};
      for (let i = 0; i < keys.length; i++) {
        assets[i] = Cache.get(keys[i]);
      }
      return assets;
    }
    async _mapLoadToResolve(resolveResults, onProgress) {
      const resolveArray = Object.values(resolveResults);
      const resolveKeys = Object.keys(resolveResults);
      this._backgroundLoader.active = false;
      const loadedAssets = await this.loader.load(resolveArray, onProgress);
      this._backgroundLoader.active = true;
      const out = {};
      resolveArray.forEach((resolveResult, i) => {
        const asset = loadedAssets[resolveResult.src];
        const keys = [resolveResult.src];
        if (resolveResult.alias) {
          keys.push(...resolveResult.alias);
        }
        out[resolveKeys[i]] = asset;
        Cache.set(keys, asset);
      });
      return out;
    }
    async unload(urls) {
      if (!this._initialized) {
        await this.init();
      }
      const urlArray = convertToList(urls).map((url2) => typeof url2 !== "string" ? url2.src : url2);
      const resolveResults = this.resolver.resolve(urlArray);
      await this._unloadFromResolved(resolveResults);
    }
    async unloadBundle(bundleIds) {
      if (!this._initialized) {
        await this.init();
      }
      bundleIds = convertToList(bundleIds);
      const resolveResults = this.resolver.resolveBundle(bundleIds);
      const promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));
      await Promise.all(promises);
    }
    async _unloadFromResolved(resolveResult) {
      const resolveArray = Object.values(resolveResult);
      resolveArray.forEach((resolveResult2) => {
        Cache.remove(resolveResult2.src);
      });
      await this.loader.unload(resolveArray);
    }
    get detections() {
      return this._detections;
    }
  };
  var Assets = new AssetsClass();
  extensions$1.handleByList(ExtensionType.LoadParser, Assets.loader.parsers).handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(ExtensionType.CacheParser, Assets.cache.parsers).handleByList(ExtensionType.DetectionParser, Assets.detections);
  var assetKeyMap = {
    loader: ExtensionType.LoadParser,
    resolver: ExtensionType.ResolveParser,
    cache: ExtensionType.CacheParser,
    detection: ExtensionType.DetectionParser
  };
  extensions$1.handle(ExtensionType.Asset, (extension) => {
    const ref = extension.ref;
    Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => extensions$1.add(Object.assign(ref[key], { extension: ref[key].extension ?? type })));
  }, (extension) => {
    const ref = extension.ref;
    Object.keys(assetKeyMap).filter((key) => !!ref[key]).forEach((key) => extensions$1.remove(ref[key]));
  });
  var cacheTextureArray = {
    extension: ExtensionType.CacheParser,
    test: (asset) => Array.isArray(asset) && asset.every((t) => t instanceof Texture),
    getCacheableAssets: (keys, asset) => {
      const out = {};
      keys.forEach((key) => {
        asset.forEach((item2, i) => {
          out[key + (i === 0 ? "" : i + 1)] = item2;
        });
      });
      return out;
    }
  };
  extensions$1.add(cacheTextureArray);
  var LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {
    LoaderParserPriority2[LoaderParserPriority2["Low"] = 0] = "Low";
    LoaderParserPriority2[LoaderParserPriority2["Normal"] = 1] = "Normal";
    LoaderParserPriority2[LoaderParserPriority2["High"] = 2] = "High";
    return LoaderParserPriority2;
  })(LoaderParserPriority || {});
  var loadJson = {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.Low
    },
    test(url2) {
      return path.extname(url2).includes(".json");
    },
    async load(url2) {
      const response = await settings.ADAPTER.fetch(url2);
      const json = await response.json();
      return json;
    }
  };
  extensions$1.add(loadJson);
  var loadTxt = {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.Low
    },
    test(url2) {
      return path.extname(url2).includes(".txt");
    },
    async load(url2) {
      const response = await settings.ADAPTER.fetch(url2);
      const txt = await response.text();
      return txt;
    }
  };
  extensions$1.add(loadTxt);
  var validWeights = [
    "normal",
    "bold",
    "100",
    "200",
    "300",
    "400",
    "500",
    "600",
    "700",
    "800",
    "900"
  ];
  var validFontExtensions = [".ttf", ".otf", ".woff", ".woff2"];
  var validFontMIMEs = [
    "font/ttf",
    "font/otf",
    "font/woff",
    "font/woff2"
  ];
  function getFontFamilyName(url2) {
    const ext = path.extname(url2);
    const name = path.basename(url2, ext);
    const nameWithSpaces = name.replace(/(-|_)/g, " ");
    const nameTitleCase = nameWithSpaces.toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
    return nameTitleCase;
  }
  var loadWebFont = {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.Low
    },
    test(url2) {
      return checkDataUrl(url2, validFontMIMEs) || checkExtension(url2, validFontExtensions);
    },
    async load(url2, options) {
      if (!globalThis.navigator.onLine) {
        throw new Error("[loadWebFont] Cannot load font - navigator is offline");
      }
      const fonts = settings.ADAPTER.getFontFaceSet();
      if (fonts) {
        const fontFaces = [];
        const name = options.data?.family ?? getFontFamilyName(url2);
        const weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ["normal"];
        const data = options.data ?? {};
        for (let i = 0; i < weights.length; i++) {
          const weight = weights[i];
          const font = new FontFace(name, `url(${encodeURI(url2)})`, {
            ...data,
            weight
          });
          await font.load();
          fonts.add(font);
          fontFaces.push(font);
        }
        return fontFaces.length === 1 ? fontFaces[0] : fontFaces;
      }
      console.warn("[loadWebFont] FontFace API is not supported. Skipping loading font");
      return null;
    },
    unload(font) {
      (Array.isArray(font) ? font : [font]).forEach((t) => settings.ADAPTER.getFontFaceSet().delete(t));
    }
  };
  extensions$1.add(loadWebFont);
  var UUID = 0;
  var MAX_WORKERS;
  var WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
  var checkImageBitmapCode = {
    id: "checkImageBitmap",
    code: `
    async function checkImageBitmap()
    {
        try
        {
            if (typeof createImageBitmap !== 'function') return false;

            const response = await fetch('${WHITE_PNG}');
            const imageBlob =  await response.blob();
            const imageBitmap = await createImageBitmap(imageBlob);

            return imageBitmap.width === 1 && imageBitmap.height === 1;
        }
        catch (e)
        {
            return false;
        }
    }
    checkImageBitmap().then((result) => { self.postMessage(result); });
    `
  };
  var workerCode = {
    id: "loadImageBitmap",
    code: `
    async function loadImageBitmap(url)
    {
        const response = await fetch(url);

        if (!response.ok)
        {
            throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \`
                + \`\${response.status} \${response.statusText}\`);
        }

        const imageBlob =  await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);

        return imageBitmap;
    }
    self.onmessage = async (event) =>
    {
        try
        {
            const imageBitmap = await loadImageBitmap(event.data.data[0]);

            self.postMessage({
                data: imageBitmap,
                uuid: event.data.uuid,
                id: event.data.id,
            }, [imageBitmap]);
        }
        catch(e)
        {
            self.postMessage({
                error: e,
                uuid: event.data.uuid,
                id: event.data.id,
            });
        }
    };`
  };
  var workerURL;
  var WorkerManagerClass = class {
    constructor() {
      this._initialized = false;
      this._createdWorkers = 0;
      this.workerPool = [];
      this.queue = [];
      this.resolveHash = {};
    }
    isImageBitmapSupported() {
      if (this._isImageBitmapSupported !== void 0)
        return this._isImageBitmapSupported;
      this._isImageBitmapSupported = new Promise((resolve2) => {
        const workerURL2 = URL.createObjectURL(new Blob([checkImageBitmapCode.code], { type: "application/javascript" }));
        const worker = new Worker(workerURL2);
        worker.addEventListener("message", (event) => {
          worker.terminate();
          URL.revokeObjectURL(workerURL2);
          resolve2(event.data);
        });
      });
      return this._isImageBitmapSupported;
    }
    loadImageBitmap(src) {
      return this._run("loadImageBitmap", [src]);
    }
    async _initWorkers() {
      if (this._initialized)
        return;
      this._initialized = true;
    }
    getWorker() {
      if (MAX_WORKERS === void 0) {
        MAX_WORKERS = navigator.hardwareConcurrency || 4;
      }
      let worker = this.workerPool.pop();
      if (!worker && this._createdWorkers < MAX_WORKERS) {
        if (!workerURL) {
          workerURL = URL.createObjectURL(new Blob([workerCode.code], { type: "application/javascript" }));
        }
        this._createdWorkers++;
        worker = new Worker(workerURL);
        worker.addEventListener("message", (event) => {
          this.complete(event.data);
          this.returnWorker(event.target);
          this.next();
        });
      }
      return worker;
    }
    returnWorker(worker) {
      this.workerPool.push(worker);
    }
    complete(data) {
      if (data.error !== void 0) {
        this.resolveHash[data.uuid].reject(data.error);
      } else {
        this.resolveHash[data.uuid].resolve(data.data);
      }
      this.resolveHash[data.uuid] = null;
    }
    async _run(id, args) {
      await this._initWorkers();
      const promise = new Promise((resolve2, reject) => {
        this.queue.push({ id, arguments: args, resolve: resolve2, reject });
      });
      this.next();
      return promise;
    }
    next() {
      if (!this.queue.length)
        return;
      const worker = this.getWorker();
      if (!worker) {
        return;
      }
      const toDo = this.queue.pop();
      const id = toDo.id;
      this.resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };
      worker.postMessage({
        data: toDo.arguments,
        uuid: UUID++,
        id
      });
    }
  };
  var WorkerManager = new WorkerManagerClass();
  function createTexture(base, loader, url2) {
    const texture = new Texture(base);
    texture.baseTexture.on("dispose", () => {
      delete loader.promiseCache[url2];
    });
    return texture;
  }
  var validImageExtensions = [".jpeg", ".jpg", ".png", ".webp", ".avif"];
  var validImageMIMEs = [
    "image/jpeg",
    "image/png",
    "image/webp",
    "image/avif"
  ];
  async function loadImageBitmap(url2) {
    const response = await settings.ADAPTER.fetch(url2);
    if (!response.ok) {
      throw new Error(`[loadImageBitmap] Failed to fetch ${url2}: ${response.status} ${response.statusText}`);
    }
    const imageBlob = await response.blob();
    const imageBitmap = await createImageBitmap(imageBlob);
    return imageBitmap;
  }
  var loadTextures = {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.High
    },
    config: {
      preferWorkers: true
    },
    test(url2) {
      return checkDataUrl(url2, validImageMIMEs) || checkExtension(url2, validImageExtensions);
    },
    async load(url2, asset, loader) {
      let src = null;
      if (globalThis.createImageBitmap) {
        if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported()) {
          src = await WorkerManager.loadImageBitmap(url2);
        } else {
          src = await loadImageBitmap(url2);
        }
      } else {
        src = await new Promise((resolve2) => {
          src = new Image();
          src.crossOrigin = "anonymous";
          src.src = url2;
          if (src.complete) {
            resolve2(src);
          } else {
            src.onload = () => {
              resolve2(src);
            };
          }
        });
      }
      const base = new BaseTexture(src, {
        resolution: getResolutionOfUrl(url2),
        ...asset.data
      });
      base.resource.src = url2;
      return createTexture(base, loader, url2);
    },
    unload(texture) {
      texture.destroy(true);
    }
  };
  extensions$1.add(loadTextures);
  var loadSVG = {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.High
    },
    test(url2) {
      return path.extname(url2).includes(".svg");
    },
    async testParse(data) {
      return SVGResource.test(data);
    },
    async parse(asset, data, loader) {
      const src = new SVGResource(asset, data?.data?.resourceOptions);
      const base = new BaseTexture(src, {
        resolution: getResolutionOfUrl(asset),
        ...data?.data
      });
      base.resource.src = asset;
      const texture = createTexture(base, loader, asset);
      if (!data?.data?.resourceOptions?.autoLoad) {
        await src.load();
      }
      return texture;
    },
    async load(url2, _options) {
      const response = await settings.ADAPTER.fetch(url2);
      return response.text();
    },
    unload: loadTextures.unload
  };
  var resolveTextureUrl = {
    extension: ExtensionType.ResolveParser,
    test: loadTextures.test,
    parse: (value3) => ({
      resolution: parseFloat(settings.RETINA_PREFIX.exec(value3)?.[1] ?? "1"),
      format: value3.split(".").pop(),
      src: value3
    })
  };
  extensions$1.add(resolveTextureUrl);
  var detectAvif = {
    extension: {
      type: ExtensionType.DetectionParser,
      priority: 1
    },
    test: async () => {
      if (!globalThis.createImageBitmap)
        return false;
      const avifData = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=";
      const blob = await settings.ADAPTER.fetch(avifData).then((r) => r.blob());
      return createImageBitmap(blob).then(() => true, () => false);
    },
    add: async (formats2) => [...formats2, "avif"],
    remove: async (formats2) => formats2.filter((f) => f !== "avif")
  };
  extensions$1.add(detectAvif);
  var detectWebp = {
    extension: {
      type: ExtensionType.DetectionParser,
      priority: 0
    },
    test: async () => {
      if (!globalThis.createImageBitmap)
        return false;
      const webpData = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=";
      const blob = await settings.ADAPTER.fetch(webpData).then((r) => r.blob());
      return createImageBitmap(blob).then(() => true, () => false);
    },
    add: async (formats2) => [...formats2, "webp"],
    remove: async (formats2) => formats2.filter((f) => f !== "webp")
  };
  extensions$1.add(detectWebp);
  var imageFormats = ["png", "jpg", "jpeg"];
  var detectDefaults = {
    extension: {
      type: ExtensionType.DetectionParser,
      priority: -1
    },
    test: () => Promise.resolve(true),
    add: async (formats2) => [...formats2, ...imageFormats],
    remove: async (formats2) => formats2.filter((f) => !imageFormats.includes(f))
  };
  extensions$1.add(detectDefaults);
  var INTERNAL_FORMATS = /* @__PURE__ */ ((INTERNAL_FORMATS2) => {
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_ATC_WEBGL"] = 35986] = "COMPRESSED_RGB_ATC_WEBGL";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"] = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"] = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
    INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
    return INTERNAL_FORMATS2;
  })(INTERNAL_FORMATS || {});
  var INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = {
    [
      33776
      /* COMPRESSED_RGB_S3TC_DXT1_EXT */
    ]: 0.5,
    [
      33777
      /* COMPRESSED_RGBA_S3TC_DXT1_EXT */
    ]: 0.5,
    [
      33778
      /* COMPRESSED_RGBA_S3TC_DXT3_EXT */
    ]: 1,
    [
      33779
      /* COMPRESSED_RGBA_S3TC_DXT5_EXT */
    ]: 1,
    [
      35916
      /* COMPRESSED_SRGB_S3TC_DXT1_EXT */
    ]: 0.5,
    [
      35917
      /* COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT */
    ]: 0.5,
    [
      35918
      /* COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT */
    ]: 1,
    [
      35919
      /* COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT */
    ]: 1,
    [
      37488
      /* COMPRESSED_R11_EAC */
    ]: 0.5,
    [
      37489
      /* COMPRESSED_SIGNED_R11_EAC */
    ]: 0.5,
    [
      37490
      /* COMPRESSED_RG11_EAC */
    ]: 1,
    [
      37491
      /* COMPRESSED_SIGNED_RG11_EAC */
    ]: 1,
    [
      37492
      /* COMPRESSED_RGB8_ETC2 */
    ]: 0.5,
    [
      37496
      /* COMPRESSED_RGBA8_ETC2_EAC */
    ]: 1,
    [
      37493
      /* COMPRESSED_SRGB8_ETC2 */
    ]: 0.5,
    [
      37497
      /* COMPRESSED_SRGB8_ALPHA8_ETC2_EAC */
    ]: 1,
    [
      37494
      /* COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 */
    ]: 0.5,
    [
      37495
      /* COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 */
    ]: 0.5,
    [
      35840
      /* COMPRESSED_RGB_PVRTC_4BPPV1_IMG */
    ]: 0.5,
    [
      35842
      /* COMPRESSED_RGBA_PVRTC_4BPPV1_IMG */
    ]: 0.5,
    [
      35841
      /* COMPRESSED_RGB_PVRTC_2BPPV1_IMG */
    ]: 0.25,
    [
      35843
      /* COMPRESSED_RGBA_PVRTC_2BPPV1_IMG */
    ]: 0.25,
    [
      36196
      /* COMPRESSED_RGB_ETC1_WEBGL */
    ]: 0.5,
    [
      35986
      /* COMPRESSED_RGB_ATC_WEBGL */
    ]: 0.5,
    [
      35986
      /* COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL */
    ]: 1,
    [
      34798
      /* COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL */
    ]: 1,
    [
      37808
      /* COMPRESSED_RGBA_ASTC_4x4_KHR */
    ]: 1
  };
  var BlobResource = class extends BufferResource {
    constructor(source, options = { width: 1, height: 1, autoLoad: true }) {
      let origin;
      let data;
      if (typeof source === "string") {
        origin = source;
        data = new Uint8Array();
      } else {
        origin = null;
        data = source;
      }
      super(data, options);
      this.origin = origin;
      this.buffer = data ? new ViewableBuffer(data) : null;
      if (this.origin && options.autoLoad !== false) {
        this.load();
      }
      if (data?.length) {
        this.loaded = true;
        this.onBlobLoaded(this.buffer.rawBinaryData);
      }
    }
    onBlobLoaded(_data) {
    }
    async load() {
      const response = await fetch(this.origin);
      const blob = await response.blob();
      const arrayBuffer = await blob.arrayBuffer();
      this.data = new Uint32Array(arrayBuffer);
      this.buffer = new ViewableBuffer(arrayBuffer);
      this.loaded = true;
      this.onBlobLoaded(arrayBuffer);
      this.update();
      return this;
    }
  };
  var CompressedTextureResource = class extends BlobResource {
    constructor(source, options) {
      super(source, options);
      this.format = options.format;
      this.levels = options.levels || 1;
      this._width = options.width;
      this._height = options.height;
      this._extension = CompressedTextureResource._formatToExtension(this.format);
      if (options.levelBuffers || this.buffer) {
        this._levelBuffers = options.levelBuffers || CompressedTextureResource._createLevelBuffers(source instanceof Uint8Array ? source : this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height);
      }
    }
    upload(renderer, _texture, _glTexture) {
      const gl = renderer.gl;
      const extension = renderer.context.extensions[this._extension];
      if (!extension) {
        throw new Error(`${this._extension} textures are not supported on the current machine`);
      }
      if (!this._levelBuffers) {
        return false;
      }
      for (let i = 0, j = this.levels; i < j; i++) {
        const { levelID, levelWidth, levelHeight, levelBuffer } = this._levelBuffers[i];
        gl.compressedTexImage2D(gl.TEXTURE_2D, levelID, this.format, levelWidth, levelHeight, 0, levelBuffer);
      }
      return true;
    }
    onBlobLoaded() {
      this._levelBuffers = CompressedTextureResource._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height);
    }
    static _formatToExtension(format2) {
      if (format2 >= 33776 && format2 <= 33779) {
        return "s3tc";
      } else if (format2 >= 37488 && format2 <= 37497) {
        return "etc";
      } else if (format2 >= 35840 && format2 <= 35843) {
        return "pvrtc";
      } else if (format2 >= 36196) {
        return "etc1";
      } else if (format2 >= 35986 && format2 <= 34798) {
        return "atc";
      }
      throw new Error("Invalid (compressed) texture format given!");
    }
    static _createLevelBuffers(buffer, format2, levels, blockWidth, blockHeight, imageWidth, imageHeight) {
      const buffers = new Array(levels);
      let offset = buffer.byteOffset;
      let levelWidth = imageWidth;
      let levelHeight = imageHeight;
      let alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);
      let alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);
      let levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format2];
      for (let i = 0; i < levels; i++) {
        buffers[i] = {
          levelID: i,
          levelWidth: levels > 1 ? levelWidth : alignedLevelWidth,
          levelHeight: levels > 1 ? levelHeight : alignedLevelHeight,
          levelBuffer: new Uint8Array(buffer.buffer, offset, levelSize)
        };
        offset += levelSize;
        levelWidth = levelWidth >> 1 || 1;
        levelHeight = levelHeight >> 1 || 1;
        alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);
        alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);
        levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format2];
      }
      return buffers;
    }
  };
  var storedGl;
  var extensions;
  function getCompressedTextureExtensions() {
    extensions = {
      s3tc: storedGl.getExtension("WEBGL_compressed_texture_s3tc"),
      s3tc_sRGB: storedGl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
      etc: storedGl.getExtension("WEBGL_compressed_texture_etc"),
      etc1: storedGl.getExtension("WEBGL_compressed_texture_etc1"),
      pvrtc: storedGl.getExtension("WEBGL_compressed_texture_pvrtc") || storedGl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      atc: storedGl.getExtension("WEBGL_compressed_texture_atc"),
      astc: storedGl.getExtension("WEBGL_compressed_texture_astc")
    };
  }
  var detectCompressedTextures = {
    extension: {
      type: ExtensionType.DetectionParser,
      priority: 2
    },
    test: async () => {
      const canvas = settings.ADAPTER.createCanvas();
      const gl = canvas.getContext("webgl");
      if (!gl) {
        console.warn("WebGL not available for compressed textures.");
        return false;
      }
      storedGl = gl;
      return true;
    },
    add: async (formats2) => {
      if (!extensions)
        getCompressedTextureExtensions();
      const textureFormats = [];
      for (const extensionName in extensions) {
        const extension = extensions[extensionName];
        if (!extension) {
          continue;
        }
        textureFormats.push(extensionName);
      }
      return [...textureFormats, ...formats2];
    },
    remove: async (formats2) => {
      if (!extensions)
        getCompressedTextureExtensions();
      return formats2.filter((f) => !(f in extensions));
    }
  };
  extensions$1.add(detectCompressedTextures);
  var DDS_MAGIC_SIZE = 4;
  var DDS_HEADER_SIZE = 124;
  var DDS_HEADER_PF_SIZE = 32;
  var DDS_HEADER_DX10_SIZE = 20;
  var DDS_MAGIC = 542327876;
  var DDS_FIELDS = {
    SIZE: 1,
    FLAGS: 2,
    HEIGHT: 3,
    WIDTH: 4,
    MIPMAP_COUNT: 7,
    PIXEL_FORMAT: 19
  };
  var DDS_PF_FIELDS = {
    SIZE: 0,
    FLAGS: 1,
    FOURCC: 2,
    RGB_BITCOUNT: 3,
    R_BIT_MASK: 4,
    G_BIT_MASK: 5,
    B_BIT_MASK: 6,
    A_BIT_MASK: 7
  };
  var DDS_DX10_FIELDS = {
    DXGI_FORMAT: 0,
    RESOURCE_DIMENSION: 1,
    MISC_FLAG: 2,
    ARRAY_SIZE: 3,
    MISC_FLAGS2: 4
  };
  var PF_FLAGS = 1;
  var DDPF_ALPHA = 2;
  var DDPF_FOURCC = 4;
  var DDPF_RGB = 64;
  var DDPF_YUV = 512;
  var DDPF_LUMINANCE = 131072;
  var FOURCC_DXT1 = 827611204;
  var FOURCC_DXT3 = 861165636;
  var FOURCC_DXT5 = 894720068;
  var FOURCC_DX10 = 808540228;
  var DDS_RESOURCE_MISC_TEXTURECUBE = 4;
  var FOURCC_TO_FORMAT = {
    [FOURCC_DXT1]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
    [FOURCC_DXT3]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
    [FOURCC_DXT5]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT
  };
  var DXGI_TO_FORMAT = {
    [
      70
      /* DXGI_FORMAT_BC1_TYPELESS */
    ]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
    [
      71
      /* DXGI_FORMAT_BC1_UNORM */
    ]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
    [
      73
      /* DXGI_FORMAT_BC2_TYPELESS */
    ]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
    [
      74
      /* DXGI_FORMAT_BC2_UNORM */
    ]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
    [
      76
      /* DXGI_FORMAT_BC3_TYPELESS */
    ]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
    [
      77
      /* DXGI_FORMAT_BC3_UNORM */
    ]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
    [
      72
      /* DXGI_FORMAT_BC1_UNORM_SRGB */
    ]: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
    [
      75
      /* DXGI_FORMAT_BC2_UNORM_SRGB */
    ]: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
    [
      78
      /* DXGI_FORMAT_BC3_UNORM_SRGB */
    ]: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
  };
  function parseDDS(arrayBuffer) {
    const data = new Uint32Array(arrayBuffer);
    const magicWord = data[0];
    if (magicWord !== DDS_MAGIC) {
      throw new Error("Invalid DDS file magic word");
    }
    const header = new Uint32Array(arrayBuffer, 0, DDS_HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT);
    const height = header[DDS_FIELDS.HEIGHT];
    const width = header[DDS_FIELDS.WIDTH];
    const mipmapCount = header[DDS_FIELDS.MIPMAP_COUNT];
    const pixelFormat = new Uint32Array(arrayBuffer, DDS_FIELDS.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, DDS_HEADER_PF_SIZE / Uint32Array.BYTES_PER_ELEMENT);
    const formatFlags = pixelFormat[PF_FLAGS];
    if (formatFlags & DDPF_FOURCC) {
      const fourCC = pixelFormat[DDS_PF_FIELDS.FOURCC];
      if (fourCC !== FOURCC_DX10) {
        const internalFormat2 = FOURCC_TO_FORMAT[fourCC];
        const dataOffset2 = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;
        const texData = new Uint8Array(arrayBuffer, dataOffset2);
        const resource = new CompressedTextureResource(texData, {
          format: internalFormat2,
          width,
          height,
          levels: mipmapCount
        });
        return [resource];
      }
      const dx10Offset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;
      const dx10Header = new Uint32Array(data.buffer, dx10Offset, DDS_HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT);
      const dxgiFormat = dx10Header[DDS_DX10_FIELDS.DXGI_FORMAT];
      const resourceDimension = dx10Header[DDS_DX10_FIELDS.RESOURCE_DIMENSION];
      const miscFlag = dx10Header[DDS_DX10_FIELDS.MISC_FLAG];
      const arraySize = dx10Header[DDS_DX10_FIELDS.ARRAY_SIZE];
      const internalFormat = DXGI_TO_FORMAT[dxgiFormat];
      if (internalFormat === void 0) {
        throw new Error(`DDSParser cannot parse texture data with DXGI format ${dxgiFormat}`);
      }
      if (miscFlag === DDS_RESOURCE_MISC_TEXTURECUBE) {
        throw new Error("DDSParser does not support cubemap textures");
      }
      if (resourceDimension === 6) {
        throw new Error("DDSParser does not supported 3D texture data");
      }
      const imageBuffers = new Array();
      const dataOffset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE + DDS_HEADER_DX10_SIZE;
      if (arraySize === 1) {
        imageBuffers.push(new Uint8Array(arrayBuffer, dataOffset));
      } else {
        const pixelSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[internalFormat];
        let imageSize = 0;
        let levelWidth = width;
        let levelHeight = height;
        for (let i = 0; i < mipmapCount; i++) {
          const alignedLevelWidth = Math.max(1, levelWidth + 3 & ~3);
          const alignedLevelHeight = Math.max(1, levelHeight + 3 & ~3);
          const levelSize = alignedLevelWidth * alignedLevelHeight * pixelSize;
          imageSize += levelSize;
          levelWidth = levelWidth >>> 1;
          levelHeight = levelHeight >>> 1;
        }
        let imageOffset = dataOffset;
        for (let i = 0; i < arraySize; i++) {
          imageBuffers.push(new Uint8Array(arrayBuffer, imageOffset, imageSize));
          imageOffset += imageSize;
        }
      }
      return imageBuffers.map((buffer) => new CompressedTextureResource(buffer, {
        format: internalFormat,
        width,
        height,
        levels: mipmapCount
      }));
    }
    if (formatFlags & DDPF_RGB) {
      throw new Error("DDSParser does not support uncompressed texture data.");
    }
    if (formatFlags & DDPF_YUV) {
      throw new Error("DDSParser does not supported YUV uncompressed texture data.");
    }
    if (formatFlags & DDPF_LUMINANCE) {
      throw new Error("DDSParser does not support single-channel (lumninance) texture data!");
    }
    if (formatFlags & DDPF_ALPHA) {
      throw new Error("DDSParser does not support single-channel (alpha) texture data!");
    }
    throw new Error("DDSParser failed to load a texture file due to an unknown reason!");
  }
  var FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10];
  var ENDIANNESS = 67305985;
  var KTX_FIELDS = {
    FILE_IDENTIFIER: 0,
    ENDIANNESS: 12,
    GL_TYPE: 16,
    GL_TYPE_SIZE: 20,
    GL_FORMAT: 24,
    GL_INTERNAL_FORMAT: 28,
    GL_BASE_INTERNAL_FORMAT: 32,
    PIXEL_WIDTH: 36,
    PIXEL_HEIGHT: 40,
    PIXEL_DEPTH: 44,
    NUMBER_OF_ARRAY_ELEMENTS: 48,
    NUMBER_OF_FACES: 52,
    NUMBER_OF_MIPMAP_LEVELS: 56,
    BYTES_OF_KEY_VALUE_DATA: 60
  };
  var FILE_HEADER_SIZE = 64;
  var TYPES_TO_BYTES_PER_COMPONENT = {
    [TYPES.UNSIGNED_BYTE]: 1,
    [TYPES.UNSIGNED_SHORT]: 2,
    [TYPES.INT]: 4,
    [TYPES.UNSIGNED_INT]: 4,
    [TYPES.FLOAT]: 4,
    [TYPES.HALF_FLOAT]: 8
  };
  var FORMATS_TO_COMPONENTS = {
    [FORMATS.RGBA]: 4,
    [FORMATS.RGB]: 3,
    [FORMATS.RG]: 2,
    [FORMATS.RED]: 1,
    [FORMATS.LUMINANCE]: 1,
    [FORMATS.LUMINANCE_ALPHA]: 2,
    [FORMATS.ALPHA]: 1
  };
  var TYPES_TO_BYTES_PER_PIXEL = {
    [TYPES.UNSIGNED_SHORT_4_4_4_4]: 2,
    [TYPES.UNSIGNED_SHORT_5_5_5_1]: 2,
    [TYPES.UNSIGNED_SHORT_5_6_5]: 2
  };
  function parseKTX(url2, arrayBuffer, loadKeyValueData = false) {
    const dataView = new DataView(arrayBuffer);
    if (!validate(url2, dataView)) {
      return null;
    }
    const littleEndian = dataView.getUint32(KTX_FIELDS.ENDIANNESS, true) === ENDIANNESS;
    const glType = dataView.getUint32(KTX_FIELDS.GL_TYPE, littleEndian);
    const glFormat = dataView.getUint32(KTX_FIELDS.GL_FORMAT, littleEndian);
    const glInternalFormat = dataView.getUint32(KTX_FIELDS.GL_INTERNAL_FORMAT, littleEndian);
    const pixelWidth = dataView.getUint32(KTX_FIELDS.PIXEL_WIDTH, littleEndian);
    const pixelHeight = dataView.getUint32(KTX_FIELDS.PIXEL_HEIGHT, littleEndian) || 1;
    const pixelDepth = dataView.getUint32(KTX_FIELDS.PIXEL_DEPTH, littleEndian) || 1;
    const numberOfArrayElements = dataView.getUint32(KTX_FIELDS.NUMBER_OF_ARRAY_ELEMENTS, littleEndian) || 1;
    const numberOfFaces = dataView.getUint32(KTX_FIELDS.NUMBER_OF_FACES, littleEndian);
    const numberOfMipmapLevels = dataView.getUint32(KTX_FIELDS.NUMBER_OF_MIPMAP_LEVELS, littleEndian);
    const bytesOfKeyValueData = dataView.getUint32(KTX_FIELDS.BYTES_OF_KEY_VALUE_DATA, littleEndian);
    if (pixelHeight === 0 || pixelDepth !== 1) {
      throw new Error("Only 2D textures are supported");
    }
    if (numberOfFaces !== 1) {
      throw new Error("CubeTextures are not supported by KTXLoader yet!");
    }
    if (numberOfArrayElements !== 1) {
      throw new Error("WebGL does not support array textures");
    }
    const blockWidth = 4;
    const blockHeight = 4;
    const alignedWidth = pixelWidth + 3 & ~3;
    const alignedHeight = pixelHeight + 3 & ~3;
    const imageBuffers = new Array(numberOfArrayElements);
    let imagePixels = pixelWidth * pixelHeight;
    if (glType === 0) {
      imagePixels = alignedWidth * alignedHeight;
    }
    let imagePixelByteSize;
    if (glType !== 0) {
      if (TYPES_TO_BYTES_PER_COMPONENT[glType]) {
        imagePixelByteSize = TYPES_TO_BYTES_PER_COMPONENT[glType] * FORMATS_TO_COMPONENTS[glFormat];
      } else {
        imagePixelByteSize = TYPES_TO_BYTES_PER_PIXEL[glType];
      }
    } else {
      imagePixelByteSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat];
    }
    if (imagePixelByteSize === void 0) {
      throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
    }
    const kvData = loadKeyValueData ? parseKvData(dataView, bytesOfKeyValueData, littleEndian) : null;
    const imageByteSize = imagePixels * imagePixelByteSize;
    let mipByteSize = imageByteSize;
    let mipWidth = pixelWidth;
    let mipHeight = pixelHeight;
    let alignedMipWidth = alignedWidth;
    let alignedMipHeight = alignedHeight;
    let imageOffset = FILE_HEADER_SIZE + bytesOfKeyValueData;
    for (let mipmapLevel = 0; mipmapLevel < numberOfMipmapLevels; mipmapLevel++) {
      const imageSize = dataView.getUint32(imageOffset, littleEndian);
      let elementOffset = imageOffset + 4;
      for (let arrayElement = 0; arrayElement < numberOfArrayElements; arrayElement++) {
        let mips = imageBuffers[arrayElement];
        if (!mips) {
          mips = imageBuffers[arrayElement] = new Array(numberOfMipmapLevels);
        }
        mips[mipmapLevel] = {
          levelID: mipmapLevel,
          levelWidth: numberOfMipmapLevels > 1 || glType !== 0 ? mipWidth : alignedMipWidth,
          levelHeight: numberOfMipmapLevels > 1 || glType !== 0 ? mipHeight : alignedMipHeight,
          levelBuffer: new Uint8Array(arrayBuffer, elementOffset, mipByteSize)
        };
        elementOffset += mipByteSize;
      }
      imageOffset += imageSize + 4;
      imageOffset = imageOffset % 4 !== 0 ? imageOffset + 4 - imageOffset % 4 : imageOffset;
      mipWidth = mipWidth >> 1 || 1;
      mipHeight = mipHeight >> 1 || 1;
      alignedMipWidth = mipWidth + blockWidth - 1 & ~(blockWidth - 1);
      alignedMipHeight = mipHeight + blockHeight - 1 & ~(blockHeight - 1);
      mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;
    }
    if (glType !== 0) {
      return {
        uncompressed: imageBuffers.map((levelBuffers) => {
          let buffer = levelBuffers[0].levelBuffer;
          let convertToInt = false;
          if (glType === TYPES.FLOAT) {
            buffer = new Float32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
          } else if (glType === TYPES.UNSIGNED_INT) {
            convertToInt = true;
            buffer = new Uint32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
          } else if (glType === TYPES.INT) {
            convertToInt = true;
            buffer = new Int32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
          }
          return {
            resource: new BufferResource(buffer, {
              width: levelBuffers[0].levelWidth,
              height: levelBuffers[0].levelHeight
            }),
            type: glType,
            format: convertToInt ? convertFormatToInteger(glFormat) : glFormat
          };
        }),
        kvData
      };
    }
    return {
      compressed: imageBuffers.map((levelBuffers) => new CompressedTextureResource(null, {
        format: glInternalFormat,
        width: pixelWidth,
        height: pixelHeight,
        levels: numberOfMipmapLevels,
        levelBuffers
      })),
      kvData
    };
  }
  function validate(url2, dataView) {
    for (let i = 0; i < FILE_IDENTIFIER.length; i++) {
      if (dataView.getUint8(i) !== FILE_IDENTIFIER[i]) {
        console.error(`${url2} is not a valid *.ktx file!`);
        return false;
      }
    }
    return true;
  }
  function convertFormatToInteger(format2) {
    switch (format2) {
      case FORMATS.RGBA:
        return FORMATS.RGBA_INTEGER;
      case FORMATS.RGB:
        return FORMATS.RGB_INTEGER;
      case FORMATS.RG:
        return FORMATS.RG_INTEGER;
      case FORMATS.RED:
        return FORMATS.RED_INTEGER;
      default:
        return format2;
    }
  }
  function parseKvData(dataView, bytesOfKeyValueData, littleEndian) {
    const kvData = /* @__PURE__ */ new Map();
    let bytesIntoKeyValueData = 0;
    while (bytesIntoKeyValueData < bytesOfKeyValueData) {
      const keyAndValueByteSize = dataView.getUint32(FILE_HEADER_SIZE + bytesIntoKeyValueData, littleEndian);
      const keyAndValueByteOffset = FILE_HEADER_SIZE + bytesIntoKeyValueData + 4;
      const valuePadding = 3 - (keyAndValueByteSize + 3) % 4;
      if (keyAndValueByteSize === 0 || keyAndValueByteSize > bytesOfKeyValueData - bytesIntoKeyValueData) {
        console.error("KTXLoader: keyAndValueByteSize out of bounds");
        break;
      }
      let keyNulByte = 0;
      for (; keyNulByte < keyAndValueByteSize; keyNulByte++) {
        if (dataView.getUint8(keyAndValueByteOffset + keyNulByte) === 0) {
          break;
        }
      }
      if (keyNulByte === -1) {
        console.error("KTXLoader: Failed to find null byte terminating kvData key");
        break;
      }
      const key = new TextDecoder().decode(new Uint8Array(dataView.buffer, keyAndValueByteOffset, keyNulByte));
      const value3 = new DataView(dataView.buffer, keyAndValueByteOffset + keyNulByte + 1, keyAndValueByteSize - keyNulByte - 1);
      kvData.set(key, value3);
      bytesIntoKeyValueData += 4 + keyAndValueByteSize + valuePadding;
    }
    return kvData;
  }
  var loadDDS = {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.High
    },
    test(url2) {
      return checkExtension(url2, ".dds");
    },
    async load(url2, asset, loader) {
      const response = await settings.ADAPTER.fetch(url2);
      const arrayBuffer = await response.arrayBuffer();
      const resources = parseDDS(arrayBuffer);
      const textures = resources.map((resource) => {
        const base = new BaseTexture(resource, {
          mipmap: MIPMAP_MODES.OFF,
          alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
          resolution: getResolutionOfUrl(url2),
          ...asset.data
        });
        return createTexture(base, loader, url2);
      });
      return textures.length === 1 ? textures[0] : textures;
    },
    unload(texture) {
      if (Array.isArray(texture)) {
        texture.forEach((t) => t.destroy(true));
      } else {
        texture.destroy(true);
      }
    }
  };
  extensions$1.add(loadDDS);
  var loadKTX = {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.High
    },
    test(url2) {
      return checkExtension(url2, ".ktx");
    },
    async load(url2, asset, loader) {
      const response = await settings.ADAPTER.fetch(url2);
      const arrayBuffer = await response.arrayBuffer();
      const { compressed, uncompressed, kvData } = parseKTX(url2, arrayBuffer);
      const resources = compressed ?? uncompressed;
      const options = {
        mipmap: MIPMAP_MODES.OFF,
        alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
        resolution: getResolutionOfUrl(url2),
        ...asset.data
      };
      const textures = resources.map((resource) => {
        if (resources === uncompressed) {
          Object.assign(options, {
            type: resource.type,
            format: resource.format
          });
        }
        const base = new BaseTexture(resource, options);
        base.ktxKeyValueData = kvData;
        return createTexture(base, loader, url2);
      });
      return textures.length === 1 ? textures[0] : textures;
    },
    unload(texture) {
      if (Array.isArray(texture)) {
        texture.forEach((t) => t.destroy(true));
      } else {
        texture.destroy(true);
      }
    }
  };
  extensions$1.add(loadKTX);
  var resolveCompressedTextureUrl = {
    extension: ExtensionType.ResolveParser,
    test: (value3) => {
      const temp2 = value3.split("?")[0];
      const extension = temp2.split(".").pop();
      return ["basis", "ktx", "dds"].includes(extension);
    },
    parse: (value3) => {
      const temp2 = value3.split("?")[0];
      const extension = temp2.split(".").pop();
      if (extension === "ktx") {
        const extensions2 = [
          ".s3tc.ktx",
          ".s3tc_sRGB.ktx",
          ".etc.ktx",
          ".etc1.ktx",
          ".pvrt.ktx",
          ".atc.ktx",
          ".astc.ktx"
        ];
        if (extensions2.some((ext) => value3.endsWith(ext))) {
          return {
            resolution: parseFloat(settings.RETINA_PREFIX.exec(value3)?.[1] ?? "1"),
            format: extensions2.find((ext) => value3.endsWith(ext)),
            src: value3
          };
        }
      }
      return {
        resolution: parseFloat(settings.RETINA_PREFIX.exec(value3)?.[1] ?? "1"),
        format: value3.split(".").pop(),
        src: value3
      };
    }
  };
  extensions$1.add(resolveCompressedTextureUrl);
  var TEMP_RECT = new Rectangle();
  var BYTES_PER_PIXEL = 4;
  var _Extract = class {
    constructor(renderer) {
      this.renderer = renderer;
    }
    async image(target2, format2, quality) {
      const image = new Image();
      image.src = await this.base64(target2, format2, quality);
      return image;
    }
    async base64(target2, format2, quality) {
      const canvas = this.canvas(target2);
      if (canvas.toDataURL !== void 0) {
        return canvas.toDataURL(format2, quality);
      }
      if (canvas.convertToBlob !== void 0) {
        const blob = await canvas.convertToBlob({ type: format2, quality });
        return await new Promise((resolve2) => {
          const reader = new FileReader();
          reader.onload = () => resolve2(reader.result);
          reader.readAsDataURL(blob);
        });
      }
      throw new Error("Extract.base64() requires ICanvas.toDataURL or ICanvas.convertToBlob to be implemented");
    }
    canvas(target2, frame) {
      const renderer = this.renderer;
      let resolution;
      let flipY = false;
      let renderTexture;
      let generated = false;
      if (target2) {
        if (target2 instanceof RenderTexture) {
          renderTexture = target2;
        } else {
          renderTexture = this.renderer.generateTexture(target2);
          generated = true;
        }
      }
      if (renderTexture) {
        resolution = renderTexture.baseTexture.resolution;
        frame = frame ?? renderTexture.frame;
        flipY = false;
        renderer.renderTexture.bind(renderTexture);
      } else {
        resolution = renderer.resolution;
        if (!frame) {
          frame = TEMP_RECT;
          frame.width = renderer.width;
          frame.height = renderer.height;
        }
        flipY = true;
        renderer.renderTexture.bind(null);
      }
      const width = Math.round(frame.width * resolution);
      const height = Math.round(frame.height * resolution);
      let canvasBuffer = new CanvasRenderTarget(width, height, 1);
      const webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
      const gl = renderer.gl;
      gl.readPixels(Math.round(frame.x * resolution), Math.round(frame.y * resolution), width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);
      const canvasData = canvasBuffer.context.getImageData(0, 0, width, height);
      _Extract.arrayPostDivide(webglPixels, canvasData.data);
      canvasBuffer.context.putImageData(canvasData, 0, 0);
      if (flipY) {
        const target22 = new CanvasRenderTarget(canvasBuffer.width, canvasBuffer.height, 1);
        target22.context.scale(1, -1);
        target22.context.drawImage(canvasBuffer.canvas, 0, -height);
        canvasBuffer.destroy();
        canvasBuffer = target22;
      }
      if (generated) {
        renderTexture.destroy(true);
      }
      return canvasBuffer.canvas;
    }
    pixels(target2, frame) {
      const renderer = this.renderer;
      let resolution;
      let renderTexture;
      let generated = false;
      if (target2) {
        if (target2 instanceof RenderTexture) {
          renderTexture = target2;
        } else {
          renderTexture = this.renderer.generateTexture(target2);
          generated = true;
        }
      }
      if (renderTexture) {
        resolution = renderTexture.baseTexture.resolution;
        frame = frame ?? renderTexture.frame;
        renderer.renderTexture.bind(renderTexture);
      } else {
        resolution = renderer.resolution;
        if (!frame) {
          frame = TEMP_RECT;
          frame.width = renderer.width;
          frame.height = renderer.height;
        }
        renderer.renderTexture.bind(null);
      }
      const width = Math.round(frame.width * resolution);
      const height = Math.round(frame.height * resolution);
      const webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
      const gl = renderer.gl;
      gl.readPixels(Math.round(frame.x * resolution), Math.round(frame.y * resolution), width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);
      if (generated) {
        renderTexture.destroy(true);
      }
      _Extract.arrayPostDivide(webglPixels, webglPixels);
      return webglPixels;
    }
    destroy() {
      this.renderer = null;
    }
    static arrayPostDivide(pixels, out) {
      for (let i = 0; i < pixels.length; i += 4) {
        const alpha = out[i + 3] = pixels[i + 3];
        if (alpha !== 0) {
          out[i] = Math.round(Math.min(pixels[i] * 255 / alpha, 255));
          out[i + 1] = Math.round(Math.min(pixels[i + 1] * 255 / alpha, 255));
          out[i + 2] = Math.round(Math.min(pixels[i + 2] * 255 / alpha, 255));
        } else {
          out[i] = pixels[i];
          out[i + 1] = pixels[i + 1];
          out[i + 2] = pixels[i + 2];
        }
      }
    }
  };
  var Extract = _Extract;
  Extract.extension = {
    name: "extract",
    type: ExtensionType.RendererSystem
  };
  extensions$1.add(Extract);
  var LINE_JOIN = /* @__PURE__ */ ((LINE_JOIN2) => {
    LINE_JOIN2["MITER"] = "miter";
    LINE_JOIN2["BEVEL"] = "bevel";
    LINE_JOIN2["ROUND"] = "round";
    return LINE_JOIN2;
  })(LINE_JOIN || {});
  var LINE_CAP = /* @__PURE__ */ ((LINE_CAP2) => {
    LINE_CAP2["BUTT"] = "butt";
    LINE_CAP2["ROUND"] = "round";
    LINE_CAP2["SQUARE"] = "square";
    return LINE_CAP2;
  })(LINE_CAP || {});
  var GRAPHICS_CURVES = {
    adaptive: true,
    maxLength: 10,
    minSegments: 8,
    maxSegments: 2048,
    epsilon: 1e-4,
    _segmentsCount(length, defaultSegments = 20) {
      if (!this.adaptive || !length || isNaN(length)) {
        return defaultSegments;
      }
      let result2 = Math.ceil(length / this.maxLength);
      if (result2 < this.minSegments) {
        result2 = this.minSegments;
      } else if (result2 > this.maxSegments) {
        result2 = this.maxSegments;
      }
      return result2;
    }
  };
  var FillStyle = class {
    constructor() {
      this.color = 16777215;
      this.alpha = 1;
      this.texture = Texture.WHITE;
      this.matrix = null;
      this.visible = false;
      this.reset();
    }
    clone() {
      const obj = new FillStyle();
      obj.color = this.color;
      obj.alpha = this.alpha;
      obj.texture = this.texture;
      obj.matrix = this.matrix;
      obj.visible = this.visible;
      return obj;
    }
    reset() {
      this.color = 16777215;
      this.alpha = 1;
      this.texture = Texture.WHITE;
      this.matrix = null;
      this.visible = false;
    }
    destroy() {
      this.texture = null;
      this.matrix = null;
    }
  };
  function fixOrientation(points, hole = false) {
    const m = points.length;
    if (m < 6) {
      return;
    }
    let area2 = 0;
    for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2) {
      const x2 = points[i];
      const y2 = points[i + 1];
      area2 += (x2 - x1) * (y2 + y1);
      x1 = x2;
      y1 = y2;
    }
    if (!hole && area2 > 0 || hole && area2 <= 0) {
      const n = m / 2;
      for (let i = n + n % 2; i < m; i += 2) {
        const i1 = m - i - 2;
        const i2 = m - i - 1;
        const i3 = i;
        const i4 = i + 1;
        [points[i1], points[i3]] = [points[i3], points[i1]];
        [points[i2], points[i4]] = [points[i4], points[i2]];
      }
    }
  }
  var buildPoly = {
    build(graphicsData) {
      graphicsData.points = graphicsData.shape.points.slice();
    },
    triangulate(graphicsData, graphicsGeometry) {
      let points = graphicsData.points;
      const holes = graphicsData.holes;
      const verts = graphicsGeometry.points;
      const indices2 = graphicsGeometry.indices;
      if (points.length >= 6) {
        fixOrientation(points, false);
        const holeArray = [];
        for (let i = 0; i < holes.length; i++) {
          const hole = holes[i];
          fixOrientation(hole.points, true);
          holeArray.push(points.length / 2);
          points = points.concat(hole.points);
        }
        const triangles = earcut_1(points, holeArray, 2);
        if (!triangles) {
          return;
        }
        const vertPos = verts.length / 2;
        for (let i = 0; i < triangles.length; i += 3) {
          indices2.push(triangles[i] + vertPos);
          indices2.push(triangles[i + 1] + vertPos);
          indices2.push(triangles[i + 2] + vertPos);
        }
        for (let i = 0; i < points.length; i++) {
          verts.push(points[i]);
        }
      }
    }
  };
  var buildCircle = {
    build(graphicsData) {
      const points = graphicsData.points;
      let x;
      let y;
      let dx;
      let dy;
      let rx;
      let ry;
      if (graphicsData.type === SHAPES.CIRC) {
        const circle = graphicsData.shape;
        x = circle.x;
        y = circle.y;
        rx = ry = circle.radius;
        dx = dy = 0;
      } else if (graphicsData.type === SHAPES.ELIP) {
        const ellipse = graphicsData.shape;
        x = ellipse.x;
        y = ellipse.y;
        rx = ellipse.width;
        ry = ellipse.height;
        dx = dy = 0;
      } else {
        const roundedRect = graphicsData.shape;
        const halfWidth = roundedRect.width / 2;
        const halfHeight = roundedRect.height / 2;
        x = roundedRect.x + halfWidth;
        y = roundedRect.y + halfHeight;
        rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
        dx = halfWidth - rx;
        dy = halfHeight - ry;
      }
      if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {
        points.length = 0;
        return;
      }
      const n = Math.ceil(2.3 * Math.sqrt(rx + ry));
      const m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
      points.length = m;
      if (m === 0) {
        return;
      }
      if (n === 0) {
        points.length = 8;
        points[0] = points[6] = x + dx;
        points[1] = points[3] = y + dy;
        points[2] = points[4] = x - dx;
        points[5] = points[7] = y - dy;
        return;
      }
      let j1 = 0;
      let j2 = n * 4 + (dx ? 2 : 0) + 2;
      let j3 = j2;
      let j4 = m;
      {
        const x0 = dx + rx;
        const y0 = dy;
        const x1 = x + x0;
        const x2 = x - x0;
        const y1 = y + y0;
        points[j1++] = x1;
        points[j1++] = y1;
        points[--j2] = y1;
        points[--j2] = x2;
        if (dy) {
          const y2 = y - y0;
          points[j3++] = x2;
          points[j3++] = y2;
          points[--j4] = y2;
          points[--j4] = x1;
        }
      }
      for (let i = 1; i < n; i++) {
        const a2 = Math.PI / 2 * (i / n);
        const x0 = dx + Math.cos(a2) * rx;
        const y0 = dy + Math.sin(a2) * ry;
        const x1 = x + x0;
        const x2 = x - x0;
        const y1 = y + y0;
        const y2 = y - y0;
        points[j1++] = x1;
        points[j1++] = y1;
        points[--j2] = y1;
        points[--j2] = x2;
        points[j3++] = x2;
        points[j3++] = y2;
        points[--j4] = y2;
        points[--j4] = x1;
      }
      {
        const x0 = dx;
        const y0 = dy + ry;
        const x1 = x + x0;
        const x2 = x - x0;
        const y1 = y + y0;
        const y2 = y - y0;
        points[j1++] = x1;
        points[j1++] = y1;
        points[--j4] = y2;
        points[--j4] = x1;
        if (dx) {
          points[j1++] = x2;
          points[j1++] = y1;
          points[--j4] = y2;
          points[--j4] = x2;
        }
      }
    },
    triangulate(graphicsData, graphicsGeometry) {
      const points = graphicsData.points;
      const verts = graphicsGeometry.points;
      const indices2 = graphicsGeometry.indices;
      if (points.length === 0) {
        return;
      }
      let vertPos = verts.length / 2;
      const center = vertPos;
      let x;
      let y;
      if (graphicsData.type !== SHAPES.RREC) {
        const circle = graphicsData.shape;
        x = circle.x;
        y = circle.y;
      } else {
        const roundedRect = graphicsData.shape;
        x = roundedRect.x + roundedRect.width / 2;
        y = roundedRect.y + roundedRect.height / 2;
      }
      const matrix = graphicsData.matrix;
      verts.push(graphicsData.matrix ? matrix.a * x + matrix.c * y + matrix.tx : x, graphicsData.matrix ? matrix.b * x + matrix.d * y + matrix.ty : y);
      vertPos++;
      verts.push(points[0], points[1]);
      for (let i = 2; i < points.length; i += 2) {
        verts.push(points[i], points[i + 1]);
        indices2.push(vertPos++, center, vertPos);
      }
      indices2.push(center + 1, center, vertPos);
    }
  };
  var buildRectangle = {
    build(graphicsData) {
      const rectData = graphicsData.shape;
      const x = rectData.x;
      const y = rectData.y;
      const width = rectData.width;
      const height = rectData.height;
      const points = graphicsData.points;
      points.length = 0;
      if (!(width >= 0 && height >= 0)) {
        return;
      }
      points.push(x, y, x + width, y, x + width, y + height, x, y + height);
    },
    triangulate(graphicsData, graphicsGeometry) {
      const points = graphicsData.points;
      const verts = graphicsGeometry.points;
      if (points.length === 0) {
        return;
      }
      const vertPos = verts.length / 2;
      verts.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]);
      graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);
    }
  };
  var buildRoundedRectangle = {
    build(graphicsData) {
      buildCircle.build(graphicsData);
    },
    triangulate(graphicsData, graphicsGeometry) {
      buildCircle.triangulate(graphicsData, graphicsGeometry);
    }
  };
  function square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {
    const ix = x - nx * innerWeight;
    const iy = y - ny * innerWeight;
    const ox = x + nx * outerWeight;
    const oy = y + ny * outerWeight;
    let exx;
    let eyy;
    if (clockwise) {
      exx = ny;
      eyy = -nx;
    } else {
      exx = -ny;
      eyy = nx;
    }
    const eix = ix + exx;
    const eiy = iy + eyy;
    const eox = ox + exx;
    const eoy = oy + eyy;
    verts.push(eix, eiy);
    verts.push(eox, eoy);
    return 2;
  }
  function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
    const cx2p0x = sx - cx;
    const cy2p0y = sy - cy;
    let angle0 = Math.atan2(cx2p0x, cy2p0y);
    let angle1 = Math.atan2(ex - cx, ey - cy);
    if (clockwise && angle0 < angle1) {
      angle0 += Math.PI * 2;
    } else if (!clockwise && angle0 > angle1) {
      angle1 += Math.PI * 2;
    }
    let startAngle = angle0;
    const angleDiff = angle1 - angle0;
    const absAngleDiff = Math.abs(angleDiff);
    const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
    const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
    const angleInc = angleDiff / segCount;
    startAngle += angleInc;
    if (clockwise) {
      verts.push(cx, cy);
      verts.push(sx, sy);
      for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
        verts.push(cx, cy);
        verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
      }
      verts.push(cx, cy);
      verts.push(ex, ey);
    } else {
      verts.push(sx, sy);
      verts.push(cx, cy);
      for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
        verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
        verts.push(cx, cy);
      }
      verts.push(ex, ey);
      verts.push(cx, cy);
    }
    return segCount * 2;
  }
  function buildNonNativeLine(graphicsData, graphicsGeometry) {
    const shape = graphicsData.shape;
    let points = graphicsData.points || shape.points.slice();
    const eps = graphicsGeometry.closePointEps;
    if (points.length === 0) {
      return;
    }
    const style = graphicsData.lineStyle;
    const firstPoint = new Point(points[0], points[1]);
    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);
    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
    if (closedShape) {
      points = points.slice();
      if (closedPath) {
        points.pop();
        points.pop();
        lastPoint.set(points[points.length - 2], points[points.length - 1]);
      }
      const midPointX = (firstPoint.x + lastPoint.x) * 0.5;
      const midPointY = (lastPoint.y + firstPoint.y) * 0.5;
      points.unshift(midPointX, midPointY);
      points.push(midPointX, midPointY);
    }
    const verts = graphicsGeometry.points;
    const length = points.length / 2;
    let indexCount = points.length;
    const indexStart = verts.length / 2;
    const width = style.width / 2;
    const widthSquared = width * width;
    const miterLimitSquared = style.miterLimit * style.miterLimit;
    let x0 = points[0];
    let y0 = points[1];
    let x1 = points[2];
    let y1 = points[3];
    let x2 = 0;
    let y2 = 0;
    let perpx = -(y0 - y1);
    let perpy = x0 - x1;
    let perp1x = 0;
    let perp1y = 0;
    let dist = Math.sqrt(perpx * perpx + perpy * perpy);
    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;
    const ratio = style.alignment;
    const innerWeight = (1 - ratio) * 2;
    const outerWeight = ratio * 2;
    if (!closedShape) {
      if (style.cap === LINE_CAP.ROUND) {
        indexCount += round(x0 - perpx * (innerWeight - outerWeight) * 0.5, y0 - perpy * (innerWeight - outerWeight) * 0.5, x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight, verts, true) + 2;
      } else if (style.cap === LINE_CAP.SQUARE) {
        indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);
      }
    }
    verts.push(x0 - perpx * innerWeight, y0 - perpy * innerWeight);
    verts.push(x0 + perpx * outerWeight, y0 + perpy * outerWeight);
    for (let i = 1; i < length - 1; ++i) {
      x0 = points[(i - 1) * 2];
      y0 = points[(i - 1) * 2 + 1];
      x1 = points[i * 2];
      y1 = points[i * 2 + 1];
      x2 = points[(i + 1) * 2];
      y2 = points[(i + 1) * 2 + 1];
      perpx = -(y0 - y1);
      perpy = x0 - x1;
      dist = Math.sqrt(perpx * perpx + perpy * perpy);
      perpx /= dist;
      perpy /= dist;
      perpx *= width;
      perpy *= width;
      perp1x = -(y1 - y2);
      perp1y = x1 - x2;
      dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
      perp1x /= dist;
      perp1y /= dist;
      perp1x *= width;
      perp1y *= width;
      const dx0 = x1 - x0;
      const dy0 = y0 - y1;
      const dx1 = x1 - x2;
      const dy1 = y2 - y1;
      const dot = dx0 * dx1 + dy0 * dy1;
      const cross = dy0 * dx1 - dy1 * dx0;
      const clockwise = cross < 0;
      if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {
        verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
        verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
        if (dot >= 0) {
          if (style.join === LINE_JOIN.ROUND) {
            indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
          } else {
            indexCount += 2;
          }
          verts.push(x1 - perp1x * outerWeight, y1 - perp1y * outerWeight);
          verts.push(x1 + perp1x * innerWeight, y1 + perp1y * innerWeight);
        }
        continue;
      }
      const c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0);
      const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
      const px = (dx0 * c2 - dx1 * c1) / cross;
      const py = (dy1 * c1 - dy0 * c2) / cross;
      const pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
      const imx = x1 + (px - x1) * innerWeight;
      const imy = y1 + (py - y1) * innerWeight;
      const omx = x1 - (px - x1) * outerWeight;
      const omy = y1 - (py - y1) * outerWeight;
      const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
      const insideWeight = clockwise ? innerWeight : outerWeight;
      const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
      const insideMiterOk = pdist <= smallerInsideDiagonalSq;
      if (insideMiterOk) {
        if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared) {
          if (clockwise) {
            verts.push(imx, imy);
            verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
            verts.push(imx, imy);
            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
            verts.push(omx, omy);
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
            verts.push(omx, omy);
          }
          indexCount += 2;
        } else if (style.join === LINE_JOIN.ROUND) {
          if (clockwise) {
            verts.push(imx, imy);
            verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
            indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;
            verts.push(imx, imy);
            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
            verts.push(omx, omy);
            indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
            verts.push(omx, omy);
          }
        } else {
          verts.push(imx, imy);
          verts.push(omx, omy);
        }
      } else {
        verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
        verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
        if (style.join === LINE_JOIN.ROUND) {
          if (clockwise) {
            indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;
          } else {
            indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;
          }
        } else if (style.join === LINE_JOIN.MITER && pdist / widthSquared <= miterLimitSquared) {
          if (clockwise) {
            verts.push(omx, omy);
            verts.push(omx, omy);
          } else {
            verts.push(imx, imy);
            verts.push(imx, imy);
          }
          indexCount += 2;
        }
        verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
        verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        indexCount += 2;
      }
    }
    x0 = points[(length - 2) * 2];
    y0 = points[(length - 2) * 2 + 1];
    x1 = points[(length - 1) * 2];
    y1 = points[(length - 1) * 2 + 1];
    perpx = -(y0 - y1);
    perpy = x0 - x1;
    dist = Math.sqrt(perpx * perpx + perpy * perpy);
    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;
    verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
    verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
    if (!closedShape) {
      if (style.cap === LINE_CAP.ROUND) {
        indexCount += round(x1 - perpx * (innerWeight - outerWeight) * 0.5, y1 - perpy * (innerWeight - outerWeight) * 0.5, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight, verts, false) + 2;
      } else if (style.cap === LINE_CAP.SQUARE) {
        indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);
      }
    }
    const indices2 = graphicsGeometry.indices;
    const eps2 = GRAPHICS_CURVES.epsilon * GRAPHICS_CURVES.epsilon;
    for (let i = indexStart; i < indexCount + indexStart - 2; ++i) {
      x0 = verts[i * 2];
      y0 = verts[i * 2 + 1];
      x1 = verts[(i + 1) * 2];
      y1 = verts[(i + 1) * 2 + 1];
      x2 = verts[(i + 2) * 2];
      y2 = verts[(i + 2) * 2 + 1];
      if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
        continue;
      }
      indices2.push(i, i + 1, i + 2);
    }
  }
  function buildNativeLine(graphicsData, graphicsGeometry) {
    let i = 0;
    const shape = graphicsData.shape;
    const points = graphicsData.points || shape.points;
    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
    if (points.length === 0)
      return;
    const verts = graphicsGeometry.points;
    const indices2 = graphicsGeometry.indices;
    const length = points.length / 2;
    const startIndex = verts.length / 2;
    let currentIndex = startIndex;
    verts.push(points[0], points[1]);
    for (i = 1; i < length; i++) {
      verts.push(points[i * 2], points[i * 2 + 1]);
      indices2.push(currentIndex, currentIndex + 1);
      currentIndex++;
    }
    if (closedShape) {
      indices2.push(currentIndex, startIndex);
    }
  }
  function buildLine(graphicsData, graphicsGeometry) {
    if (graphicsData.lineStyle.native) {
      buildNativeLine(graphicsData, graphicsGeometry);
    } else {
      buildNonNativeLine(graphicsData, graphicsGeometry);
    }
  }
  var ArcUtils = class {
    static curveTo(x1, y1, x2, y2, radius, points) {
      const fromX = points[points.length - 2];
      const fromY = points[points.length - 1];
      const a1 = fromY - y1;
      const b1 = fromX - x1;
      const a2 = y2 - y1;
      const b2 = x2 - x1;
      const mm = Math.abs(a1 * b2 - b1 * a2);
      if (mm < 1e-8 || radius === 0) {
        if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
          points.push(x1, y1);
        }
        return null;
      }
      const dd = a1 * a1 + b1 * b1;
      const cc = a2 * a2 + b2 * b2;
      const tt = a1 * a2 + b1 * b2;
      const k1 = radius * Math.sqrt(dd) / mm;
      const k2 = radius * Math.sqrt(cc) / mm;
      const j1 = k1 * tt / dd;
      const j2 = k2 * tt / cc;
      const cx = k1 * b2 + k2 * b1;
      const cy = k1 * a2 + k2 * a1;
      const px = b1 * (k2 + j1);
      const py = a1 * (k2 + j1);
      const qx = b2 * (k1 + j2);
      const qy = a2 * (k1 + j2);
      const startAngle = Math.atan2(py - cy, px - cx);
      const endAngle = Math.atan2(qy - cy, qx - cx);
      return {
        cx: cx + x1,
        cy: cy + y1,
        radius,
        startAngle,
        endAngle,
        anticlockwise: b1 * a2 > b2 * a1
      };
    }
    static arc(_startX, _startY, cx, cy, radius, startAngle, endAngle, _anticlockwise, points) {
      const sweep = endAngle - startAngle;
      const n = GRAPHICS_CURVES._segmentsCount(Math.abs(sweep) * radius, Math.ceil(Math.abs(sweep) / PI_2) * 40);
      const theta = sweep / (n * 2);
      const theta2 = theta * 2;
      const cTheta = Math.cos(theta);
      const sTheta = Math.sin(theta);
      const segMinus = n - 1;
      const remainder = segMinus % 1 / segMinus;
      for (let i = 0; i <= segMinus; ++i) {
        const real = i + remainder * i;
        const angle = theta + startAngle + theta2 * real;
        const c = Math.cos(angle);
        const s = -Math.sin(angle);
        points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);
      }
    }
  };
  var BezierUtils = class {
    static curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
      const n = 10;
      let result2 = 0;
      let t = 0;
      let t2 = 0;
      let t3 = 0;
      let nt = 0;
      let nt2 = 0;
      let nt3 = 0;
      let x = 0;
      let y = 0;
      let dx = 0;
      let dy = 0;
      let prevX = fromX;
      let prevY = fromY;
      for (let i = 1; i <= n; ++i) {
        t = i / n;
        t2 = t * t;
        t3 = t2 * t;
        nt = 1 - t;
        nt2 = nt * nt;
        nt3 = nt2 * nt;
        x = nt3 * fromX + 3 * nt2 * t * cpX + 3 * nt * t2 * cpX2 + t3 * toX;
        y = nt3 * fromY + 3 * nt2 * t * cpY + 3 * nt * t2 * cpY2 + t3 * toY;
        dx = prevX - x;
        dy = prevY - y;
        prevX = x;
        prevY = y;
        result2 += Math.sqrt(dx * dx + dy * dy);
      }
      return result2;
    }
    static curveTo(cpX, cpY, cpX2, cpY2, toX, toY, points) {
      const fromX = points[points.length - 2];
      const fromY = points[points.length - 1];
      points.length -= 2;
      const n = GRAPHICS_CURVES._segmentsCount(BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));
      let dt = 0;
      let dt2 = 0;
      let dt3 = 0;
      let t2 = 0;
      let t3 = 0;
      points.push(fromX, fromY);
      for (let i = 1, j = 0; i <= n; ++i) {
        j = i / n;
        dt = 1 - j;
        dt2 = dt * dt;
        dt3 = dt2 * dt;
        t2 = j * j;
        t3 = t2 * j;
        points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
      }
    }
  };
  var QuadraticUtils = class {
    static curveLength(fromX, fromY, cpX, cpY, toX, toY) {
      const ax = fromX - 2 * cpX + toX;
      const ay = fromY - 2 * cpY + toY;
      const bx = 2 * cpX - 2 * fromX;
      const by = 2 * cpY - 2 * fromY;
      const a2 = 4 * (ax * ax + ay * ay);
      const b2 = 4 * (ax * bx + ay * by);
      const c = bx * bx + by * by;
      const s = 2 * Math.sqrt(a2 + b2 + c);
      const a22 = Math.sqrt(a2);
      const a32 = 2 * a2 * a22;
      const c2 = 2 * Math.sqrt(c);
      const ba = b2 / a22;
      return (a32 * s + a22 * b2 * (s - c2) + (4 * c * a2 - b2 * b2) * Math.log((2 * a22 + ba + s) / (ba + c2))) / (4 * a32);
    }
    static curveTo(cpX, cpY, toX, toY, points) {
      const fromX = points[points.length - 2];
      const fromY = points[points.length - 1];
      const n = GRAPHICS_CURVES._segmentsCount(QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY));
      let xa = 0;
      let ya = 0;
      for (let i = 1; i <= n; ++i) {
        const j = i / n;
        xa = fromX + (cpX - fromX) * j;
        ya = fromY + (cpY - fromY) * j;
        points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);
      }
    }
  };
  var BatchPart = class {
    constructor() {
      this.reset();
    }
    begin(style, startIndex, attribStart) {
      this.reset();
      this.style = style;
      this.start = startIndex;
      this.attribStart = attribStart;
    }
    end(endIndex, endAttrib) {
      this.attribSize = endAttrib - this.attribStart;
      this.size = endIndex - this.start;
    }
    reset() {
      this.style = null;
      this.size = 0;
      this.start = 0;
      this.attribStart = 0;
      this.attribSize = 0;
    }
  };
  var FILL_COMMANDS = {
    [SHAPES.POLY]: buildPoly,
    [SHAPES.CIRC]: buildCircle,
    [SHAPES.ELIP]: buildCircle,
    [SHAPES.RECT]: buildRectangle,
    [SHAPES.RREC]: buildRoundedRectangle
  };
  var BATCH_POOL = [];
  var DRAW_CALL_POOL = [];
  var GraphicsData = class {
    constructor(shape, fillStyle = null, lineStyle = null, matrix = null) {
      this.points = [];
      this.holes = [];
      this.shape = shape;
      this.lineStyle = lineStyle;
      this.fillStyle = fillStyle;
      this.matrix = matrix;
      this.type = shape.type;
    }
    clone() {
      return new GraphicsData(this.shape, this.fillStyle, this.lineStyle, this.matrix);
    }
    destroy() {
      this.shape = null;
      this.holes.length = 0;
      this.holes = null;
      this.points.length = 0;
      this.points = null;
      this.lineStyle = null;
      this.fillStyle = null;
    }
  };
  var tmpPoint = new Point();
  var _GraphicsGeometry = class extends BatchGeometry {
    constructor() {
      super();
      this.closePointEps = 1e-4;
      this.boundsPadding = 0;
      this.uvsFloat32 = null;
      this.indicesUint16 = null;
      this.batchable = false;
      this.points = [];
      this.colors = [];
      this.uvs = [];
      this.indices = [];
      this.textureIds = [];
      this.graphicsData = [];
      this.drawCalls = [];
      this.batchDirty = -1;
      this.batches = [];
      this.dirty = 0;
      this.cacheDirty = -1;
      this.clearDirty = 0;
      this.shapeIndex = 0;
      this._bounds = new Bounds();
      this.boundsDirty = -1;
    }
    get bounds() {
      this.updateBatches();
      if (this.boundsDirty !== this.dirty) {
        this.boundsDirty = this.dirty;
        this.calculateBounds();
      }
      return this._bounds;
    }
    invalidate() {
      this.boundsDirty = -1;
      this.dirty++;
      this.batchDirty++;
      this.shapeIndex = 0;
      this.points.length = 0;
      this.colors.length = 0;
      this.uvs.length = 0;
      this.indices.length = 0;
      this.textureIds.length = 0;
      for (let i = 0; i < this.drawCalls.length; i++) {
        this.drawCalls[i].texArray.clear();
        DRAW_CALL_POOL.push(this.drawCalls[i]);
      }
      this.drawCalls.length = 0;
      for (let i = 0; i < this.batches.length; i++) {
        const batchPart = this.batches[i];
        batchPart.reset();
        BATCH_POOL.push(batchPart);
      }
      this.batches.length = 0;
    }
    clear() {
      if (this.graphicsData.length > 0) {
        this.invalidate();
        this.clearDirty++;
        this.graphicsData.length = 0;
      }
      return this;
    }
    drawShape(shape, fillStyle = null, lineStyle = null, matrix = null) {
      const data = new GraphicsData(shape, fillStyle, lineStyle, matrix);
      this.graphicsData.push(data);
      this.dirty++;
      return this;
    }
    drawHole(shape, matrix = null) {
      if (!this.graphicsData.length) {
        return null;
      }
      const data = new GraphicsData(shape, null, null, matrix);
      const lastShape = this.graphicsData[this.graphicsData.length - 1];
      data.lineStyle = lastShape.lineStyle;
      lastShape.holes.push(data);
      this.dirty++;
      return this;
    }
    destroy() {
      super.destroy();
      for (let i = 0; i < this.graphicsData.length; ++i) {
        this.graphicsData[i].destroy();
      }
      this.points.length = 0;
      this.points = null;
      this.colors.length = 0;
      this.colors = null;
      this.uvs.length = 0;
      this.uvs = null;
      this.indices.length = 0;
      this.indices = null;
      this.indexBuffer.destroy();
      this.indexBuffer = null;
      this.graphicsData.length = 0;
      this.graphicsData = null;
      this.drawCalls.length = 0;
      this.drawCalls = null;
      this.batches.length = 0;
      this.batches = null;
      this._bounds = null;
    }
    containsPoint(point) {
      const graphicsData = this.graphicsData;
      for (let i = 0; i < graphicsData.length; ++i) {
        const data = graphicsData[i];
        if (!data.fillStyle.visible) {
          continue;
        }
        if (data.shape) {
          if (data.matrix) {
            data.matrix.applyInverse(point, tmpPoint);
          } else {
            tmpPoint.copyFrom(point);
          }
          if (data.shape.contains(tmpPoint.x, tmpPoint.y)) {
            let hitHole = false;
            if (data.holes) {
              for (let i2 = 0; i2 < data.holes.length; i2++) {
                const hole = data.holes[i2];
                if (hole.shape.contains(tmpPoint.x, tmpPoint.y)) {
                  hitHole = true;
                  break;
                }
              }
            }
            if (!hitHole) {
              return true;
            }
          }
        }
      }
      return false;
    }
    updateBatches() {
      if (!this.graphicsData.length) {
        this.batchable = true;
        return;
      }
      if (!this.validateBatching()) {
        return;
      }
      this.cacheDirty = this.dirty;
      const uvs = this.uvs;
      const graphicsData = this.graphicsData;
      let batchPart = null;
      let currentStyle = null;
      if (this.batches.length > 0) {
        batchPart = this.batches[this.batches.length - 1];
        currentStyle = batchPart.style;
      }
      for (let i = this.shapeIndex; i < graphicsData.length; i++) {
        this.shapeIndex++;
        const data = graphicsData[i];
        const fillStyle = data.fillStyle;
        const lineStyle = data.lineStyle;
        const command2 = FILL_COMMANDS[data.type];
        command2.build(data);
        if (data.matrix) {
          this.transformPoints(data.points, data.matrix);
        }
        if (fillStyle.visible || lineStyle.visible) {
          this.processHoles(data.holes);
        }
        for (let j = 0; j < 2; j++) {
          const style = j === 0 ? fillStyle : lineStyle;
          if (!style.visible)
            continue;
          const nextTexture = style.texture.baseTexture;
          const index22 = this.indices.length;
          const attribIndex = this.points.length / 2;
          nextTexture.wrapMode = WRAP_MODES.REPEAT;
          if (j === 0) {
            this.processFill(data);
          } else {
            this.processLine(data);
          }
          const size = this.points.length / 2 - attribIndex;
          if (size === 0)
            continue;
          if (batchPart && !this._compareStyles(currentStyle, style)) {
            batchPart.end(index22, attribIndex);
            batchPart = null;
          }
          if (!batchPart) {
            batchPart = BATCH_POOL.pop() || new BatchPart();
            batchPart.begin(style, index22, attribIndex);
            this.batches.push(batchPart);
            currentStyle = style;
          }
          this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);
        }
      }
      const index2 = this.indices.length;
      const attrib = this.points.length / 2;
      if (batchPart) {
        batchPart.end(index2, attrib);
      }
      if (this.batches.length === 0) {
        this.batchable = true;
        return;
      }
      const need32 = attrib > 65535;
      if (this.indicesUint16 && this.indices.length === this.indicesUint16.length && need32 === this.indicesUint16.BYTES_PER_ELEMENT > 2) {
        this.indicesUint16.set(this.indices);
      } else {
        this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);
      }
      this.batchable = this.isBatchable();
      if (this.batchable) {
        this.packBatches();
      } else {
        this.buildDrawCalls();
      }
    }
    _compareStyles(styleA, styleB) {
      if (!styleA || !styleB) {
        return false;
      }
      if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {
        return false;
      }
      if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {
        return false;
      }
      if (!!styleA.native !== !!styleB.native) {
        return false;
      }
      return true;
    }
    validateBatching() {
      if (this.dirty === this.cacheDirty || !this.graphicsData.length) {
        return false;
      }
      for (let i = 0, l = this.graphicsData.length; i < l; i++) {
        const data = this.graphicsData[i];
        const fill = data.fillStyle;
        const line = data.lineStyle;
        if (fill && !fill.texture.baseTexture.valid)
          return false;
        if (line && !line.texture.baseTexture.valid)
          return false;
      }
      return true;
    }
    packBatches() {
      this.batchDirty++;
      this.uvsFloat32 = new Float32Array(this.uvs);
      const batches = this.batches;
      for (let i = 0, l = batches.length; i < l; i++) {
        const batch = batches[i];
        for (let j = 0; j < batch.size; j++) {
          const index2 = batch.start + j;
          this.indicesUint16[index2] = this.indicesUint16[index2] - batch.attribStart;
        }
      }
    }
    isBatchable() {
      if (this.points.length > 65535 * 2) {
        return false;
      }
      const batches = this.batches;
      for (let i = 0; i < batches.length; i++) {
        if (batches[i].style.native) {
          return false;
        }
      }
      return this.points.length < _GraphicsGeometry.BATCHABLE_SIZE * 2;
    }
    buildDrawCalls() {
      let TICK = ++BaseTexture._globalBatch;
      for (let i = 0; i < this.drawCalls.length; i++) {
        this.drawCalls[i].texArray.clear();
        DRAW_CALL_POOL.push(this.drawCalls[i]);
      }
      this.drawCalls.length = 0;
      const colors = this.colors;
      const textureIds = this.textureIds;
      let currentGroup = DRAW_CALL_POOL.pop();
      if (!currentGroup) {
        currentGroup = new BatchDrawCall();
        currentGroup.texArray = new BatchTextureArray();
      }
      currentGroup.texArray.count = 0;
      currentGroup.start = 0;
      currentGroup.size = 0;
      currentGroup.type = DRAW_MODES.TRIANGLES;
      let textureCount = 0;
      let currentTexture = null;
      let textureId = 0;
      let native = false;
      let drawMode = DRAW_MODES.TRIANGLES;
      let index2 = 0;
      this.drawCalls.push(currentGroup);
      for (let i = 0; i < this.batches.length; i++) {
        const data = this.batches[i];
        const MAX_TEXTURES = 8;
        const style = data.style;
        const nextTexture = style.texture.baseTexture;
        if (native !== !!style.native) {
          native = !!style.native;
          drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES;
          currentTexture = null;
          textureCount = MAX_TEXTURES;
          TICK++;
        }
        if (currentTexture !== nextTexture) {
          currentTexture = nextTexture;
          if (nextTexture._batchEnabled !== TICK) {
            if (textureCount === MAX_TEXTURES) {
              TICK++;
              textureCount = 0;
              if (currentGroup.size > 0) {
                currentGroup = DRAW_CALL_POOL.pop();
                if (!currentGroup) {
                  currentGroup = new BatchDrawCall();
                  currentGroup.texArray = new BatchTextureArray();
                }
                this.drawCalls.push(currentGroup);
              }
              currentGroup.start = index2;
              currentGroup.size = 0;
              currentGroup.texArray.count = 0;
              currentGroup.type = drawMode;
            }
            nextTexture.touched = 1;
            nextTexture._batchEnabled = TICK;
            nextTexture._batchLocation = textureCount;
            nextTexture.wrapMode = WRAP_MODES.REPEAT;
            currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;
            textureCount++;
          }
        }
        currentGroup.size += data.size;
        index2 += data.size;
        textureId = nextTexture._batchLocation;
        this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);
        this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);
      }
      BaseTexture._globalBatch = TICK;
      this.packAttributes();
    }
    packAttributes() {
      const verts = this.points;
      const uvs = this.uvs;
      const colors = this.colors;
      const textureIds = this.textureIds;
      const glPoints = new ArrayBuffer(verts.length * 3 * 4);
      const f32 = new Float32Array(glPoints);
      const u32 = new Uint32Array(glPoints);
      let p = 0;
      for (let i = 0; i < verts.length / 2; i++) {
        f32[p++] = verts[i * 2];
        f32[p++] = verts[i * 2 + 1];
        f32[p++] = uvs[i * 2];
        f32[p++] = uvs[i * 2 + 1];
        u32[p++] = colors[i];
        f32[p++] = textureIds[i];
      }
      this._buffer.update(glPoints);
      this._indexBuffer.update(this.indicesUint16);
    }
    processFill(data) {
      if (data.holes.length) {
        buildPoly.triangulate(data, this);
      } else {
        const command2 = FILL_COMMANDS[data.type];
        command2.triangulate(data, this);
      }
    }
    processLine(data) {
      buildLine(data, this);
      for (let i = 0; i < data.holes.length; i++) {
        buildLine(data.holes[i], this);
      }
    }
    processHoles(holes) {
      for (let i = 0; i < holes.length; i++) {
        const hole = holes[i];
        const command2 = FILL_COMMANDS[hole.type];
        command2.build(hole);
        if (hole.matrix) {
          this.transformPoints(hole.points, hole.matrix);
        }
      }
    }
    calculateBounds() {
      const bounds = this._bounds;
      bounds.clear();
      bounds.addVertexData(this.points, 0, this.points.length);
      bounds.pad(this.boundsPadding, this.boundsPadding);
    }
    transformPoints(points, matrix) {
      for (let i = 0; i < points.length / 2; i++) {
        const x = points[i * 2];
        const y = points[i * 2 + 1];
        points[i * 2] = matrix.a * x + matrix.c * y + matrix.tx;
        points[i * 2 + 1] = matrix.b * x + matrix.d * y + matrix.ty;
      }
    }
    addColors(colors, color2, alpha, size, offset = 0) {
      const rgb = (color2 >> 16) + (color2 & 65280) + ((color2 & 255) << 16);
      const rgba = premultiplyTint(rgb, alpha);
      colors.length = Math.max(colors.length, offset + size);
      for (let i = 0; i < size; i++) {
        colors[offset + i] = rgba;
      }
    }
    addTextureIds(textureIds, id, size, offset = 0) {
      textureIds.length = Math.max(textureIds.length, offset + size);
      for (let i = 0; i < size; i++) {
        textureIds[offset + i] = id;
      }
    }
    addUvs(verts, uvs, texture, start, size, matrix = null) {
      let index2 = 0;
      const uvsStart = uvs.length;
      const frame = texture.frame;
      while (index2 < size) {
        let x = verts[(start + index2) * 2];
        let y = verts[(start + index2) * 2 + 1];
        if (matrix) {
          const nx = matrix.a * x + matrix.c * y + matrix.tx;
          y = matrix.b * x + matrix.d * y + matrix.ty;
          x = nx;
        }
        index2++;
        uvs.push(x / frame.width, y / frame.height);
      }
      const baseTexture = texture.baseTexture;
      if (frame.width < baseTexture.width || frame.height < baseTexture.height) {
        this.adjustUvs(uvs, texture, uvsStart, size);
      }
    }
    adjustUvs(uvs, texture, start, size) {
      const baseTexture = texture.baseTexture;
      const eps = 1e-6;
      const finish = start + size * 2;
      const frame = texture.frame;
      const scaleX = frame.width / baseTexture.width;
      const scaleY = frame.height / baseTexture.height;
      let offsetX = frame.x / frame.width;
      let offsetY = frame.y / frame.height;
      let minX = Math.floor(uvs[start] + eps);
      let minY = Math.floor(uvs[start + 1] + eps);
      for (let i = start + 2; i < finish; i += 2) {
        minX = Math.min(minX, Math.floor(uvs[i] + eps));
        minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));
      }
      offsetX -= minX;
      offsetY -= minY;
      for (let i = start; i < finish; i += 2) {
        uvs[i] = (uvs[i] + offsetX) * scaleX;
        uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;
      }
    }
  };
  var GraphicsGeometry = _GraphicsGeometry;
  GraphicsGeometry.BATCHABLE_SIZE = 100;
  var LineStyle = class extends FillStyle {
    constructor() {
      super(...arguments);
      this.width = 0;
      this.alignment = 0.5;
      this.native = false;
      this.cap = LINE_CAP.BUTT;
      this.join = LINE_JOIN.MITER;
      this.miterLimit = 10;
    }
    clone() {
      const obj = new LineStyle();
      obj.color = this.color;
      obj.alpha = this.alpha;
      obj.texture = this.texture;
      obj.matrix = this.matrix;
      obj.visible = this.visible;
      obj.width = this.width;
      obj.alignment = this.alignment;
      obj.native = this.native;
      obj.cap = this.cap;
      obj.join = this.join;
      obj.miterLimit = this.miterLimit;
      return obj;
    }
    reset() {
      super.reset();
      this.color = 0;
      this.alignment = 0.5;
      this.width = 0;
      this.native = false;
    }
  };
  var temp = new Float32Array(3);
  var DEFAULT_SHADERS = {};
  var _Graphics = class extends Container {
    constructor(geometry = null) {
      super();
      this.shader = null;
      this.pluginName = "batch";
      this.currentPath = null;
      this.batches = [];
      this.batchTint = -1;
      this.batchDirty = -1;
      this.vertexData = null;
      this._fillStyle = new FillStyle();
      this._lineStyle = new LineStyle();
      this._matrix = null;
      this._holeMode = false;
      this.state = State.for2d();
      this._geometry = geometry || new GraphicsGeometry();
      this._geometry.refCount++;
      this._transformID = -1;
      this.tint = 16777215;
      this.blendMode = BLEND_MODES.NORMAL;
    }
    get geometry() {
      return this._geometry;
    }
    clone() {
      this.finishPoly();
      return new _Graphics(this._geometry);
    }
    set blendMode(value3) {
      this.state.blendMode = value3;
    }
    get blendMode() {
      return this.state.blendMode;
    }
    get tint() {
      return this._tint;
    }
    set tint(value3) {
      this._tint = value3;
    }
    get fill() {
      return this._fillStyle;
    }
    get line() {
      return this._lineStyle;
    }
    lineStyle(options = null, color2 = 0, alpha = 1, alignment = 0.5, native = false) {
      if (typeof options === "number") {
        options = { width: options, color: color2, alpha, alignment, native };
      }
      return this.lineTextureStyle(options);
    }
    lineTextureStyle(options) {
      options = Object.assign({
        width: 0,
        texture: Texture.WHITE,
        color: options?.texture ? 16777215 : 0,
        alpha: 1,
        matrix: null,
        alignment: 0.5,
        native: false,
        cap: LINE_CAP.BUTT,
        join: LINE_JOIN.MITER,
        miterLimit: 10
      }, options);
      if (this.currentPath) {
        this.startPoly();
      }
      const visible = options.width > 0 && options.alpha > 0;
      if (!visible) {
        this._lineStyle.reset();
      } else {
        if (options.matrix) {
          options.matrix = options.matrix.clone();
          options.matrix.invert();
        }
        Object.assign(this._lineStyle, { visible }, options);
      }
      return this;
    }
    startPoly() {
      if (this.currentPath) {
        const points = this.currentPath.points;
        const len = this.currentPath.points.length;
        if (len > 2) {
          this.drawShape(this.currentPath);
          this.currentPath = new Polygon();
          this.currentPath.closeStroke = false;
          this.currentPath.points.push(points[len - 2], points[len - 1]);
        }
      } else {
        this.currentPath = new Polygon();
        this.currentPath.closeStroke = false;
      }
    }
    finishPoly() {
      if (this.currentPath) {
        if (this.currentPath.points.length > 2) {
          this.drawShape(this.currentPath);
          this.currentPath = null;
        } else {
          this.currentPath.points.length = 0;
        }
      }
    }
    moveTo(x, y) {
      this.startPoly();
      this.currentPath.points[0] = x;
      this.currentPath.points[1] = y;
      return this;
    }
    lineTo(x, y) {
      if (!this.currentPath) {
        this.moveTo(0, 0);
      }
      const points = this.currentPath.points;
      const fromX = points[points.length - 2];
      const fromY = points[points.length - 1];
      if (fromX !== x || fromY !== y) {
        points.push(x, y);
      }
      return this;
    }
    _initCurve(x = 0, y = 0) {
      if (this.currentPath) {
        if (this.currentPath.points.length === 0) {
          this.currentPath.points = [x, y];
        }
      } else {
        this.moveTo(x, y);
      }
    }
    quadraticCurveTo(cpX, cpY, toX, toY) {
      this._initCurve();
      const points = this.currentPath.points;
      if (points.length === 0) {
        this.moveTo(0, 0);
      }
      QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);
      return this;
    }
    bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {
      this._initCurve();
      BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);
      return this;
    }
    arcTo(x1, y1, x2, y2, radius) {
      this._initCurve(x1, y1);
      const points = this.currentPath.points;
      const result2 = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);
      if (result2) {
        const { cx, cy, radius: radius2, startAngle, endAngle, anticlockwise } = result2;
        this.arc(cx, cy, radius2, startAngle, endAngle, anticlockwise);
      }
      return this;
    }
    arc(cx, cy, radius, startAngle, endAngle, anticlockwise = false) {
      if (startAngle === endAngle) {
        return this;
      }
      if (!anticlockwise && endAngle <= startAngle) {
        endAngle += PI_2;
      } else if (anticlockwise && startAngle <= endAngle) {
        startAngle += PI_2;
      }
      const sweep = endAngle - startAngle;
      if (sweep === 0) {
        return this;
      }
      const startX = cx + Math.cos(startAngle) * radius;
      const startY = cy + Math.sin(startAngle) * radius;
      const eps = this._geometry.closePointEps;
      let points = this.currentPath ? this.currentPath.points : null;
      if (points) {
        const xDiff = Math.abs(points[points.length - 2] - startX);
        const yDiff = Math.abs(points[points.length - 1] - startY);
        if (xDiff < eps && yDiff < eps) {
        } else {
          points.push(startX, startY);
        }
      } else {
        this.moveTo(startX, startY);
        points = this.currentPath.points;
      }
      ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);
      return this;
    }
    beginFill(color2 = 0, alpha = 1) {
      return this.beginTextureFill({ texture: Texture.WHITE, color: color2, alpha });
    }
    beginTextureFill(options) {
      options = Object.assign({
        texture: Texture.WHITE,
        color: 16777215,
        alpha: 1,
        matrix: null
      }, options);
      if (this.currentPath) {
        this.startPoly();
      }
      const visible = options.alpha > 0;
      if (!visible) {
        this._fillStyle.reset();
      } else {
        if (options.matrix) {
          options.matrix = options.matrix.clone();
          options.matrix.invert();
        }
        Object.assign(this._fillStyle, { visible }, options);
      }
      return this;
    }
    endFill() {
      this.finishPoly();
      this._fillStyle.reset();
      return this;
    }
    drawRect(x, y, width, height) {
      return this.drawShape(new Rectangle(x, y, width, height));
    }
    drawRoundedRect(x, y, width, height, radius) {
      return this.drawShape(new RoundedRectangle(x, y, width, height, radius));
    }
    drawCircle(x, y, radius) {
      return this.drawShape(new Circle(x, y, radius));
    }
    drawEllipse(x, y, width, height) {
      return this.drawShape(new Ellipse(x, y, width, height));
    }
    drawPolygon(...path2) {
      let points;
      let closeStroke = true;
      const poly = path2[0];
      if (poly.points) {
        closeStroke = poly.closeStroke;
        points = poly.points;
      } else if (Array.isArray(path2[0])) {
        points = path2[0];
      } else {
        points = path2;
      }
      const shape = new Polygon(points);
      shape.closeStroke = closeStroke;
      this.drawShape(shape);
      return this;
    }
    drawShape(shape) {
      if (!this._holeMode) {
        this._geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);
      } else {
        this._geometry.drawHole(shape, this._matrix);
      }
      return this;
    }
    clear() {
      this._geometry.clear();
      this._lineStyle.reset();
      this._fillStyle.reset();
      this._boundsID++;
      this._matrix = null;
      this._holeMode = false;
      this.currentPath = null;
      return this;
    }
    isFastRect() {
      const data = this._geometry.graphicsData;
      return data.length === 1 && data[0].shape.type === SHAPES.RECT && !data[0].matrix && !data[0].holes.length && !(data[0].lineStyle.visible && data[0].lineStyle.width);
    }
    _render(renderer) {
      this.finishPoly();
      const geometry = this._geometry;
      geometry.updateBatches();
      if (geometry.batchable) {
        if (this.batchDirty !== geometry.batchDirty) {
          this._populateBatches();
        }
        this._renderBatched(renderer);
      } else {
        renderer.batch.flush();
        this._renderDirect(renderer);
      }
    }
    _populateBatches() {
      const geometry = this._geometry;
      const blendMode = this.blendMode;
      const len = geometry.batches.length;
      this.batchTint = -1;
      this._transformID = -1;
      this.batchDirty = geometry.batchDirty;
      this.batches.length = len;
      this.vertexData = new Float32Array(geometry.points);
      for (let i = 0; i < len; i++) {
        const gI = geometry.batches[i];
        const color2 = gI.style.color;
        const vertexData = new Float32Array(this.vertexData.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
        const uvs = new Float32Array(geometry.uvsFloat32.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
        const indices2 = new Uint16Array(geometry.indicesUint16.buffer, gI.start * 2, gI.size);
        const batch = {
          vertexData,
          blendMode,
          indices: indices2,
          uvs,
          _batchRGB: hex2rgb(color2),
          _tintRGB: color2,
          _texture: gI.style.texture,
          alpha: gI.style.alpha,
          worldAlpha: 1
        };
        this.batches[i] = batch;
      }
    }
    _renderBatched(renderer) {
      if (!this.batches.length) {
        return;
      }
      renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
      this.calculateVertices();
      this.calculateTints();
      for (let i = 0, l = this.batches.length; i < l; i++) {
        const batch = this.batches[i];
        batch.worldAlpha = this.worldAlpha * batch.alpha;
        renderer.plugins[this.pluginName].render(batch);
      }
    }
    _renderDirect(renderer) {
      const shader = this._resolveDirectShader(renderer);
      const geometry = this._geometry;
      const tint = this.tint;
      const worldAlpha = this.worldAlpha;
      const uniforms = shader.uniforms;
      const drawCalls = geometry.drawCalls;
      uniforms.translationMatrix = this.transform.worldTransform;
      uniforms.tint[0] = (tint >> 16 & 255) / 255 * worldAlpha;
      uniforms.tint[1] = (tint >> 8 & 255) / 255 * worldAlpha;
      uniforms.tint[2] = (tint & 255) / 255 * worldAlpha;
      uniforms.tint[3] = worldAlpha;
      renderer.shader.bind(shader);
      renderer.geometry.bind(geometry, shader);
      renderer.state.set(this.state);
      for (let i = 0, l = drawCalls.length; i < l; i++) {
        this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);
      }
    }
    _renderDrawCallDirect(renderer, drawCall) {
      const { texArray, type, size, start } = drawCall;
      const groupTextureCount = texArray.count;
      for (let j = 0; j < groupTextureCount; j++) {
        renderer.texture.bind(texArray.elements[j], j);
      }
      renderer.geometry.draw(type, size, start);
    }
    _resolveDirectShader(renderer) {
      let shader = this.shader;
      const pluginName = this.pluginName;
      if (!shader) {
        if (!DEFAULT_SHADERS[pluginName]) {
          const { MAX_TEXTURES } = renderer.plugins[pluginName];
          const sampleValues = new Int32Array(MAX_TEXTURES);
          for (let i = 0; i < MAX_TEXTURES; i++) {
            sampleValues[i] = i;
          }
          const uniforms = {
            tint: new Float32Array([1, 1, 1, 1]),
            translationMatrix: new Matrix(),
            default: UniformGroup.from({ uSamplers: sampleValues }, true)
          };
          const program = renderer.plugins[pluginName]._shader.program;
          DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);
        }
        shader = DEFAULT_SHADERS[pluginName];
      }
      return shader;
    }
    _calculateBounds() {
      this.finishPoly();
      const geometry = this._geometry;
      if (!geometry.graphicsData.length) {
        return;
      }
      const { minX, minY, maxX, maxY } = geometry.bounds;
      this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
    }
    containsPoint(point) {
      this.worldTransform.applyInverse(point, _Graphics._TEMP_POINT);
      return this._geometry.containsPoint(_Graphics._TEMP_POINT);
    }
    calculateTints() {
      if (this.batchTint !== this.tint) {
        this.batchTint = this.tint;
        const tintRGB = hex2rgb(this.tint, temp);
        for (let i = 0; i < this.batches.length; i++) {
          const batch = this.batches[i];
          const batchTint = batch._batchRGB;
          const r = tintRGB[0] * batchTint[0] * 255;
          const g = tintRGB[1] * batchTint[1] * 255;
          const b2 = tintRGB[2] * batchTint[2] * 255;
          const color2 = (r << 16) + (g << 8) + (b2 | 0);
          batch._tintRGB = (color2 >> 16) + (color2 & 65280) + ((color2 & 255) << 16);
        }
      }
    }
    calculateVertices() {
      const wtID = this.transform._worldID;
      if (this._transformID === wtID) {
        return;
      }
      this._transformID = wtID;
      const wt = this.transform.worldTransform;
      const a2 = wt.a;
      const b2 = wt.b;
      const c = wt.c;
      const d = wt.d;
      const tx = wt.tx;
      const ty = wt.ty;
      const data = this._geometry.points;
      const vertexData = this.vertexData;
      let count = 0;
      for (let i = 0; i < data.length; i += 2) {
        const x = data[i];
        const y = data[i + 1];
        vertexData[count++] = a2 * x + c * y + tx;
        vertexData[count++] = d * y + b2 * x + ty;
      }
    }
    closePath() {
      const currentPath = this.currentPath;
      if (currentPath) {
        currentPath.closeStroke = true;
        this.finishPoly();
      }
      return this;
    }
    setMatrix(matrix) {
      this._matrix = matrix;
      return this;
    }
    beginHole() {
      this.finishPoly();
      this._holeMode = true;
      return this;
    }
    endHole() {
      this.finishPoly();
      this._holeMode = false;
      return this;
    }
    destroy(options) {
      this._geometry.refCount--;
      if (this._geometry.refCount === 0) {
        this._geometry.dispose();
      }
      this._matrix = null;
      this.currentPath = null;
      this._lineStyle.destroy();
      this._lineStyle = null;
      this._fillStyle.destroy();
      this._fillStyle = null;
      this._geometry = null;
      this.shader = null;
      this.vertexData = null;
      this.batches.length = 0;
      this.batches = null;
      super.destroy(options);
    }
  };
  var Graphics = _Graphics;
  Graphics._TEMP_POINT = new Point();
  var graphicsUtils = {
    buildPoly,
    buildCircle,
    buildRectangle,
    buildRoundedRectangle,
    buildLine,
    ArcUtils,
    BezierUtils,
    QuadraticUtils,
    BatchPart,
    FILL_COMMANDS,
    BATCH_POOL,
    DRAW_CALL_POOL
  };
  var MeshBatchUvs = class {
    constructor(uvBuffer, uvMatrix) {
      this.uvBuffer = uvBuffer;
      this.uvMatrix = uvMatrix;
      this.data = null;
      this._bufferUpdateId = -1;
      this._textureUpdateId = -1;
      this._updateID = 0;
    }
    update(forceUpdate) {
      if (!forceUpdate && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID) {
        return;
      }
      this._bufferUpdateId = this.uvBuffer._updateID;
      this._textureUpdateId = this.uvMatrix._updateID;
      const data = this.uvBuffer.data;
      if (!this.data || this.data.length !== data.length) {
        this.data = new Float32Array(data.length);
      }
      this.uvMatrix.multiplyUvs(data, this.data);
      this._updateID++;
    }
  };
  var tempPoint$1 = new Point();
  var tempPolygon = new Polygon();
  var _Mesh = class extends Container {
    constructor(geometry, shader, state, drawMode = DRAW_MODES.TRIANGLES) {
      super();
      this.geometry = geometry;
      this.shader = shader;
      this.state = state || State.for2d();
      this.drawMode = drawMode;
      this.start = 0;
      this.size = 0;
      this.uvs = null;
      this.indices = null;
      this.vertexData = new Float32Array(1);
      this.vertexDirty = -1;
      this._transformID = -1;
      this._roundPixels = settings.ROUND_PIXELS;
      this.batchUvs = null;
    }
    get geometry() {
      return this._geometry;
    }
    set geometry(value3) {
      if (this._geometry === value3) {
        return;
      }
      if (this._geometry) {
        this._geometry.refCount--;
        if (this._geometry.refCount === 0) {
          this._geometry.dispose();
        }
      }
      this._geometry = value3;
      if (this._geometry) {
        this._geometry.refCount++;
      }
      this.vertexDirty = -1;
    }
    get uvBuffer() {
      return this.geometry.buffers[1];
    }
    get verticesBuffer() {
      return this.geometry.buffers[0];
    }
    set material(value3) {
      this.shader = value3;
    }
    get material() {
      return this.shader;
    }
    set blendMode(value3) {
      this.state.blendMode = value3;
    }
    get blendMode() {
      return this.state.blendMode;
    }
    set roundPixels(value3) {
      if (this._roundPixels !== value3) {
        this._transformID = -1;
      }
      this._roundPixels = value3;
    }
    get roundPixels() {
      return this._roundPixels;
    }
    get tint() {
      return "tint" in this.shader ? this.shader.tint : null;
    }
    set tint(value3) {
      this.shader.tint = value3;
    }
    get texture() {
      return "texture" in this.shader ? this.shader.texture : null;
    }
    set texture(value3) {
      this.shader.texture = value3;
    }
    _render(renderer) {
      const vertices = this.geometry.buffers[0].data;
      const shader = this.shader;
      if (shader.batchable && this.drawMode === DRAW_MODES.TRIANGLES && vertices.length < _Mesh.BATCHABLE_SIZE * 2) {
        this._renderToBatch(renderer);
      } else {
        this._renderDefault(renderer);
      }
    }
    _renderDefault(renderer) {
      const shader = this.shader;
      shader.alpha = this.worldAlpha;
      if (shader.update) {
        shader.update();
      }
      renderer.batch.flush();
      shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);
      renderer.shader.bind(shader);
      renderer.state.set(this.state);
      renderer.geometry.bind(this.geometry, shader);
      renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
    }
    _renderToBatch(renderer) {
      const geometry = this.geometry;
      const shader = this.shader;
      if (shader.uvMatrix) {
        shader.uvMatrix.update();
        this.calculateUvs();
      }
      this.calculateVertices();
      this.indices = geometry.indexBuffer.data;
      this._tintRGB = shader._tintRGB;
      this._texture = shader.texture;
      const pluginName = this.material.pluginName;
      renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);
      renderer.plugins[pluginName].render(this);
    }
    calculateVertices() {
      const geometry = this.geometry;
      const verticesBuffer = geometry.buffers[0];
      const vertices = verticesBuffer.data;
      const vertexDirtyId = verticesBuffer._updateID;
      if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID) {
        return;
      }
      this._transformID = this.transform._worldID;
      if (this.vertexData.length !== vertices.length) {
        this.vertexData = new Float32Array(vertices.length);
      }
      const wt = this.transform.worldTransform;
      const a2 = wt.a;
      const b2 = wt.b;
      const c = wt.c;
      const d = wt.d;
      const tx = wt.tx;
      const ty = wt.ty;
      const vertexData = this.vertexData;
      for (let i = 0; i < vertexData.length / 2; i++) {
        const x = vertices[i * 2];
        const y = vertices[i * 2 + 1];
        vertexData[i * 2] = a2 * x + c * y + tx;
        vertexData[i * 2 + 1] = b2 * x + d * y + ty;
      }
      if (this._roundPixels) {
        const resolution = settings.RESOLUTION;
        for (let i = 0; i < vertexData.length; ++i) {
          vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;
        }
      }
      this.vertexDirty = vertexDirtyId;
    }
    calculateUvs() {
      const geomUvs = this.geometry.buffers[1];
      const shader = this.shader;
      if (!shader.uvMatrix.isSimple) {
        if (!this.batchUvs) {
          this.batchUvs = new MeshBatchUvs(geomUvs, shader.uvMatrix);
        }
        this.batchUvs.update();
        this.uvs = this.batchUvs.data;
      } else {
        this.uvs = geomUvs.data;
      }
    }
    _calculateBounds() {
      this.calculateVertices();
      this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
    }
    containsPoint(point) {
      if (!this.getBounds().contains(point.x, point.y)) {
        return false;
      }
      this.worldTransform.applyInverse(point, tempPoint$1);
      const vertices = this.geometry.getBuffer("aVertexPosition").data;
      const points = tempPolygon.points;
      const indices2 = this.geometry.getIndex().data;
      const len = indices2.length;
      const step = this.drawMode === 4 ? 3 : 1;
      for (let i = 0; i + 2 < len; i += step) {
        const ind0 = indices2[i] * 2;
        const ind1 = indices2[i + 1] * 2;
        const ind2 = indices2[i + 2] * 2;
        points[0] = vertices[ind0];
        points[1] = vertices[ind0 + 1];
        points[2] = vertices[ind1];
        points[3] = vertices[ind1 + 1];
        points[4] = vertices[ind2];
        points[5] = vertices[ind2 + 1];
        if (tempPolygon.contains(tempPoint$1.x, tempPoint$1.y)) {
          return true;
        }
      }
      return false;
    }
    destroy(options) {
      super.destroy(options);
      if (this._cachedTexture) {
        this._cachedTexture.destroy();
        this._cachedTexture = null;
      }
      this.geometry = null;
      this.shader = null;
      this.state = null;
      this.uvs = null;
      this.indices = null;
      this.vertexData = null;
    }
  };
  var Mesh = _Mesh;
  Mesh.BATCHABLE_SIZE = 100;
  var fragment$1 = "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n";
  var vertex$1 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n";
  var MeshMaterial = class extends Shader {
    constructor(uSampler, options) {
      const uniforms = {
        uSampler,
        alpha: 1,
        uTextureMatrix: Matrix.IDENTITY,
        uColor: new Float32Array([1, 1, 1, 1])
      };
      options = Object.assign({
        tint: 16777215,
        alpha: 1,
        pluginName: "batch"
      }, options);
      if (options.uniforms) {
        Object.assign(uniforms, options.uniforms);
      }
      super(options.program || Program.from(vertex$1, fragment$1), uniforms);
      this._colorDirty = false;
      this.uvMatrix = new TextureMatrix(uSampler);
      this.batchable = options.program === void 0;
      this.pluginName = options.pluginName;
      this.tint = options.tint;
      this.alpha = options.alpha;
    }
    get texture() {
      return this.uniforms.uSampler;
    }
    set texture(value3) {
      if (this.uniforms.uSampler !== value3) {
        if (!this.uniforms.uSampler.baseTexture.alphaMode !== !value3.baseTexture.alphaMode) {
          this._colorDirty = true;
        }
        this.uniforms.uSampler = value3;
        this.uvMatrix.texture = value3;
      }
    }
    set alpha(value3) {
      if (value3 === this._alpha)
        return;
      this._alpha = value3;
      this._colorDirty = true;
    }
    get alpha() {
      return this._alpha;
    }
    set tint(value3) {
      if (value3 === this._tint)
        return;
      this._tint = value3;
      this._tintRGB = (value3 >> 16) + (value3 & 65280) + ((value3 & 255) << 16);
      this._colorDirty = true;
    }
    get tint() {
      return this._tint;
    }
    update() {
      if (this._colorDirty) {
        this._colorDirty = false;
        const baseTexture = this.texture.baseTexture;
        premultiplyTintToRgba(this._tint, this._alpha, this.uniforms.uColor, baseTexture.alphaMode);
      }
      if (this.uvMatrix.update()) {
        this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;
      }
    }
  };
  var MeshGeometry = class extends Geometry {
    constructor(vertices, uvs, index2) {
      super();
      const verticesBuffer = new Buffer2(vertices);
      const uvsBuffer = new Buffer2(uvs, true);
      const indexBuffer = new Buffer2(index2, true, true);
      this.addAttribute("aVertexPosition", verticesBuffer, 2, false, TYPES.FLOAT).addAttribute("aTextureCoord", uvsBuffer, 2, false, TYPES.FLOAT).addIndex(indexBuffer);
      this._updateId = -1;
    }
    get vertexDirtyId() {
      return this.buffers[0]._updateID;
    }
  };
  var PlaneGeometry = class extends MeshGeometry {
    constructor(width = 100, height = 100, segWidth = 10, segHeight = 10) {
      super();
      this.segWidth = segWidth;
      this.segHeight = segHeight;
      this.width = width;
      this.height = height;
      this.build();
    }
    build() {
      const total = this.segWidth * this.segHeight;
      const verts = [];
      const uvs = [];
      const indices2 = [];
      const segmentsX = this.segWidth - 1;
      const segmentsY = this.segHeight - 1;
      const sizeX = this.width / segmentsX;
      const sizeY = this.height / segmentsY;
      for (let i = 0; i < total; i++) {
        const x = i % this.segWidth;
        const y = i / this.segWidth | 0;
        verts.push(x * sizeX, y * sizeY);
        uvs.push(x / segmentsX, y / segmentsY);
      }
      const totalSub = segmentsX * segmentsY;
      for (let i = 0; i < totalSub; i++) {
        const xpos = i % segmentsX;
        const ypos = i / segmentsX | 0;
        const value3 = ypos * this.segWidth + xpos;
        const value22 = ypos * this.segWidth + xpos + 1;
        const value32 = (ypos + 1) * this.segWidth + xpos;
        const value4 = (ypos + 1) * this.segWidth + xpos + 1;
        indices2.push(value3, value22, value32, value22, value4, value32);
      }
      this.buffers[0].data = new Float32Array(verts);
      this.buffers[1].data = new Float32Array(uvs);
      this.indexBuffer.data = new Uint16Array(indices2);
      this.buffers[0].update();
      this.buffers[1].update();
      this.indexBuffer.update();
    }
  };
  var RopeGeometry = class extends MeshGeometry {
    constructor(width = 200, points, textureScale = 0) {
      super(new Float32Array(points.length * 4), new Float32Array(points.length * 4), new Uint16Array((points.length - 1) * 6));
      this.points = points;
      this._width = width;
      this.textureScale = textureScale;
      this.build();
    }
    get width() {
      return this._width;
    }
    build() {
      const points = this.points;
      if (!points)
        return;
      const vertexBuffer = this.getBuffer("aVertexPosition");
      const uvBuffer = this.getBuffer("aTextureCoord");
      const indexBuffer = this.getIndex();
      if (points.length < 1) {
        return;
      }
      if (vertexBuffer.data.length / 4 !== points.length) {
        vertexBuffer.data = new Float32Array(points.length * 4);
        uvBuffer.data = new Float32Array(points.length * 4);
        indexBuffer.data = new Uint16Array((points.length - 1) * 6);
      }
      const uvs = uvBuffer.data;
      const indices2 = indexBuffer.data;
      uvs[0] = 0;
      uvs[1] = 0;
      uvs[2] = 0;
      uvs[3] = 1;
      let amount = 0;
      let prev = points[0];
      const textureWidth = this._width * this.textureScale;
      const total = points.length;
      for (let i = 0; i < total; i++) {
        const index2 = i * 4;
        if (this.textureScale > 0) {
          const dx = prev.x - points[i].x;
          const dy = prev.y - points[i].y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          prev = points[i];
          amount += distance / textureWidth;
        } else {
          amount = i / (total - 1);
        }
        uvs[index2] = amount;
        uvs[index2 + 1] = 0;
        uvs[index2 + 2] = amount;
        uvs[index2 + 3] = 1;
      }
      let indexCount = 0;
      for (let i = 0; i < total - 1; i++) {
        const index2 = i * 2;
        indices2[indexCount++] = index2;
        indices2[indexCount++] = index2 + 1;
        indices2[indexCount++] = index2 + 2;
        indices2[indexCount++] = index2 + 2;
        indices2[indexCount++] = index2 + 1;
        indices2[indexCount++] = index2 + 3;
      }
      uvBuffer.update();
      indexBuffer.update();
      this.updateVertices();
    }
    updateVertices() {
      const points = this.points;
      if (points.length < 1) {
        return;
      }
      let lastPoint = points[0];
      let nextPoint;
      let perpX = 0;
      let perpY = 0;
      const vertices = this.buffers[0].data;
      const total = points.length;
      for (let i = 0; i < total; i++) {
        const point = points[i];
        const index2 = i * 4;
        if (i < points.length - 1) {
          nextPoint = points[i + 1];
        } else {
          nextPoint = point;
        }
        perpY = -(nextPoint.x - lastPoint.x);
        perpX = nextPoint.y - lastPoint.y;
        let ratio = (1 - i / (total - 1)) * 10;
        if (ratio > 1) {
          ratio = 1;
        }
        const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
        const num = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
        perpX /= perpLength;
        perpY /= perpLength;
        perpX *= num;
        perpY *= num;
        vertices[index2] = point.x + perpX;
        vertices[index2 + 1] = point.y + perpY;
        vertices[index2 + 2] = point.x - perpX;
        vertices[index2 + 3] = point.y - perpY;
        lastPoint = point;
      }
      this.buffers[0].update();
    }
    update() {
      if (this.textureScale > 0) {
        this.build();
      } else {
        this.updateVertices();
      }
    }
  };
  var SimpleRope = class extends Mesh {
    constructor(texture, points, textureScale = 0) {
      const ropeGeometry = new RopeGeometry(texture.height, points, textureScale);
      const meshMaterial = new MeshMaterial(texture);
      if (textureScale > 0) {
        texture.baseTexture.wrapMode = WRAP_MODES.REPEAT;
      }
      super(ropeGeometry, meshMaterial);
      this.autoUpdate = true;
    }
    _render(renderer) {
      const geometry = this.geometry;
      if (this.autoUpdate || geometry._width !== this.shader.texture.height) {
        geometry._width = this.shader.texture.height;
        geometry.update();
      }
      super._render(renderer);
    }
  };
  var SimplePlane = class extends Mesh {
    constructor(texture, verticesX, verticesY) {
      const planeGeometry = new PlaneGeometry(texture.width, texture.height, verticesX, verticesY);
      const meshMaterial = new MeshMaterial(Texture.WHITE);
      super(planeGeometry, meshMaterial);
      this.texture = texture;
      this.autoResize = true;
    }
    textureUpdated() {
      this._textureID = this.shader.texture._updateID;
      const geometry = this.geometry;
      const { width, height } = this.shader.texture;
      if (this.autoResize && (geometry.width !== width || geometry.height !== height)) {
        geometry.width = this.shader.texture.width;
        geometry.height = this.shader.texture.height;
        geometry.build();
      }
    }
    set texture(value3) {
      if (this.shader.texture === value3) {
        return;
      }
      this.shader.texture = value3;
      this._textureID = -1;
      if (value3.baseTexture.valid) {
        this.textureUpdated();
      } else {
        value3.once("update", this.textureUpdated, this);
      }
    }
    get texture() {
      return this.shader.texture;
    }
    _render(renderer) {
      if (this._textureID !== this.shader.texture._updateID) {
        this.textureUpdated();
      }
      super._render(renderer);
    }
    destroy(options) {
      this.shader.texture.off("update", this.textureUpdated, this);
      super.destroy(options);
    }
  };
  var SimpleMesh = class extends Mesh {
    constructor(texture = Texture.EMPTY, vertices, uvs, indices2, drawMode) {
      const geometry = new MeshGeometry(vertices, uvs, indices2);
      geometry.getBuffer("aVertexPosition").static = false;
      const meshMaterial = new MeshMaterial(texture);
      super(geometry, meshMaterial, null, drawMode);
      this.autoUpdate = true;
    }
    get vertices() {
      return this.geometry.getBuffer("aVertexPosition").data;
    }
    set vertices(value3) {
      this.geometry.getBuffer("aVertexPosition").data = value3;
    }
    _render(renderer) {
      if (this.autoUpdate) {
        this.geometry.getBuffer("aVertexPosition").update();
      }
      super._render(renderer);
    }
  };
  var DEFAULT_BORDER_SIZE = 10;
  var NineSlicePlane = class extends SimplePlane {
    constructor(texture, leftWidth = DEFAULT_BORDER_SIZE, topHeight = DEFAULT_BORDER_SIZE, rightWidth = DEFAULT_BORDER_SIZE, bottomHeight = DEFAULT_BORDER_SIZE) {
      super(Texture.WHITE, 4, 4);
      this._origWidth = texture.orig.width;
      this._origHeight = texture.orig.height;
      this._width = this._origWidth;
      this._height = this._origHeight;
      this._leftWidth = leftWidth;
      this._rightWidth = rightWidth;
      this._topHeight = topHeight;
      this._bottomHeight = bottomHeight;
      this.texture = texture;
    }
    textureUpdated() {
      this._textureID = this.shader.texture._updateID;
      this._refresh();
    }
    get vertices() {
      return this.geometry.getBuffer("aVertexPosition").data;
    }
    set vertices(value3) {
      this.geometry.getBuffer("aVertexPosition").data = value3;
    }
    updateHorizontalVertices() {
      const vertices = this.vertices;
      const scale = this._getMinScale();
      vertices[9] = vertices[11] = vertices[13] = vertices[15] = this._topHeight * scale;
      vertices[17] = vertices[19] = vertices[21] = vertices[23] = this._height - this._bottomHeight * scale;
      vertices[25] = vertices[27] = vertices[29] = vertices[31] = this._height;
    }
    updateVerticalVertices() {
      const vertices = this.vertices;
      const scale = this._getMinScale();
      vertices[2] = vertices[10] = vertices[18] = vertices[26] = this._leftWidth * scale;
      vertices[4] = vertices[12] = vertices[20] = vertices[28] = this._width - this._rightWidth * scale;
      vertices[6] = vertices[14] = vertices[22] = vertices[30] = this._width;
    }
    _getMinScale() {
      const w = this._leftWidth + this._rightWidth;
      const scaleW = this._width > w ? 1 : this._width / w;
      const h = this._topHeight + this._bottomHeight;
      const scaleH = this._height > h ? 1 : this._height / h;
      const scale = Math.min(scaleW, scaleH);
      return scale;
    }
    get width() {
      return this._width;
    }
    set width(value3) {
      this._width = value3;
      this._refresh();
    }
    get height() {
      return this._height;
    }
    set height(value3) {
      this._height = value3;
      this._refresh();
    }
    get leftWidth() {
      return this._leftWidth;
    }
    set leftWidth(value3) {
      this._leftWidth = value3;
      this._refresh();
    }
    get rightWidth() {
      return this._rightWidth;
    }
    set rightWidth(value3) {
      this._rightWidth = value3;
      this._refresh();
    }
    get topHeight() {
      return this._topHeight;
    }
    set topHeight(value3) {
      this._topHeight = value3;
      this._refresh();
    }
    get bottomHeight() {
      return this._bottomHeight;
    }
    set bottomHeight(value3) {
      this._bottomHeight = value3;
      this._refresh();
    }
    _refresh() {
      const texture = this.texture;
      const uvs = this.geometry.buffers[1].data;
      this._origWidth = texture.orig.width;
      this._origHeight = texture.orig.height;
      const _uvw = 1 / this._origWidth;
      const _uvh = 1 / this._origHeight;
      uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
      uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
      uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
      uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
      uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
      uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
      uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
      uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
      this.updateHorizontalVertices();
      this.updateVerticalVertices();
      this.geometry.buffers[0].update();
      this.geometry.buffers[1].update();
    }
  };
  var ParticleContainer = class extends Container {
    constructor(maxSize = 1500, properties, batchSize = 16384, autoResize = false) {
      super();
      const maxBatchSize = 16384;
      if (batchSize > maxBatchSize) {
        batchSize = maxBatchSize;
      }
      this._properties = [false, true, false, false, false];
      this._maxSize = maxSize;
      this._batchSize = batchSize;
      this._buffers = null;
      this._bufferUpdateIDs = [];
      this._updateID = 0;
      this.interactiveChildren = false;
      this.blendMode = BLEND_MODES.NORMAL;
      this.autoResize = autoResize;
      this.roundPixels = true;
      this.baseTexture = null;
      this.setProperties(properties);
      this._tint = 0;
      this.tintRgb = new Float32Array(4);
      this.tint = 16777215;
    }
    setProperties(properties) {
      if (properties) {
        this._properties[0] = "vertices" in properties || "scale" in properties ? !!properties.vertices || !!properties.scale : this._properties[0];
        this._properties[1] = "position" in properties ? !!properties.position : this._properties[1];
        this._properties[2] = "rotation" in properties ? !!properties.rotation : this._properties[2];
        this._properties[3] = "uvs" in properties ? !!properties.uvs : this._properties[3];
        this._properties[4] = "tint" in properties || "alpha" in properties ? !!properties.tint || !!properties.alpha : this._properties[4];
      }
    }
    updateTransform() {
      this.displayObjectUpdateTransform();
    }
    get tint() {
      return this._tint;
    }
    set tint(value3) {
      this._tint = value3;
      hex2rgb(value3, this.tintRgb);
    }
    render(renderer) {
      if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {
        return;
      }
      if (!this.baseTexture) {
        this.baseTexture = this.children[0]._texture.baseTexture;
        if (!this.baseTexture.valid) {
          this.baseTexture.once("update", () => this.onChildrenChange(0));
        }
      }
      renderer.batch.setObjectRenderer(renderer.plugins.particle);
      renderer.plugins.particle.render(this);
    }
    onChildrenChange(smallestChildIndex) {
      const bufferIndex = Math.floor(smallestChildIndex / this._batchSize);
      while (this._bufferUpdateIDs.length < bufferIndex) {
        this._bufferUpdateIDs.push(0);
      }
      this._bufferUpdateIDs[bufferIndex] = ++this._updateID;
    }
    dispose() {
      if (this._buffers) {
        for (let i = 0; i < this._buffers.length; ++i) {
          this._buffers[i].destroy();
        }
        this._buffers = null;
      }
    }
    destroy(options) {
      super.destroy(options);
      this.dispose();
      this._properties = null;
      this._buffers = null;
      this._bufferUpdateIDs = null;
    }
  };
  var ParticleBuffer = class {
    constructor(properties, dynamicPropertyFlags, size) {
      this.geometry = new Geometry();
      this.indexBuffer = null;
      this.size = size;
      this.dynamicProperties = [];
      this.staticProperties = [];
      for (let i = 0; i < properties.length; ++i) {
        let property = properties[i];
        property = {
          attributeName: property.attributeName,
          size: property.size,
          uploadFunction: property.uploadFunction,
          type: property.type || TYPES.FLOAT,
          offset: property.offset
        };
        if (dynamicPropertyFlags[i]) {
          this.dynamicProperties.push(property);
        } else {
          this.staticProperties.push(property);
        }
      }
      this.staticStride = 0;
      this.staticBuffer = null;
      this.staticData = null;
      this.staticDataUint32 = null;
      this.dynamicStride = 0;
      this.dynamicBuffer = null;
      this.dynamicData = null;
      this.dynamicDataUint32 = null;
      this._updateID = 0;
      this.initBuffers();
    }
    initBuffers() {
      const geometry = this.geometry;
      let dynamicOffset = 0;
      this.indexBuffer = new Buffer2(createIndicesForQuads(this.size), true, true);
      geometry.addIndex(this.indexBuffer);
      this.dynamicStride = 0;
      for (let i = 0; i < this.dynamicProperties.length; ++i) {
        const property = this.dynamicProperties[i];
        property.offset = dynamicOffset;
        dynamicOffset += property.size;
        this.dynamicStride += property.size;
      }
      const dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
      this.dynamicData = new Float32Array(dynBuffer);
      this.dynamicDataUint32 = new Uint32Array(dynBuffer);
      this.dynamicBuffer = new Buffer2(this.dynamicData, false, false);
      let staticOffset = 0;
      this.staticStride = 0;
      for (let i = 0; i < this.staticProperties.length; ++i) {
        const property = this.staticProperties[i];
        property.offset = staticOffset;
        staticOffset += property.size;
        this.staticStride += property.size;
      }
      const statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
      this.staticData = new Float32Array(statBuffer);
      this.staticDataUint32 = new Uint32Array(statBuffer);
      this.staticBuffer = new Buffer2(this.staticData, true, false);
      for (let i = 0; i < this.dynamicProperties.length; ++i) {
        const property = this.dynamicProperties[i];
        geometry.addAttribute(property.attributeName, this.dynamicBuffer, 0, property.type === TYPES.UNSIGNED_BYTE, property.type, this.dynamicStride * 4, property.offset * 4);
      }
      for (let i = 0; i < this.staticProperties.length; ++i) {
        const property = this.staticProperties[i];
        geometry.addAttribute(property.attributeName, this.staticBuffer, 0, property.type === TYPES.UNSIGNED_BYTE, property.type, this.staticStride * 4, property.offset * 4);
      }
    }
    uploadDynamic(children, startIndex, amount) {
      for (let i = 0; i < this.dynamicProperties.length; i++) {
        const property = this.dynamicProperties[i];
        property.uploadFunction(children, startIndex, amount, property.type === TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, property.offset);
      }
      this.dynamicBuffer._updateID++;
    }
    uploadStatic(children, startIndex, amount) {
      for (let i = 0; i < this.staticProperties.length; i++) {
        const property = this.staticProperties[i];
        property.uploadFunction(children, startIndex, amount, property.type === TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, property.offset);
      }
      this.staticBuffer._updateID++;
    }
    destroy() {
      this.indexBuffer = null;
      this.dynamicProperties = null;
      this.dynamicBuffer = null;
      this.dynamicData = null;
      this.dynamicDataUint32 = null;
      this.staticProperties = null;
      this.staticBuffer = null;
      this.staticData = null;
      this.staticDataUint32 = null;
      this.geometry.destroy();
    }
  };
  var fragment = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}";
  var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n";
  var ParticleRenderer = class extends ObjectRenderer {
    constructor(renderer) {
      super(renderer);
      this.shader = null;
      this.properties = null;
      this.tempMatrix = new Matrix();
      this.properties = [
        {
          attributeName: "aVertexPosition",
          size: 2,
          uploadFunction: this.uploadVertices,
          offset: 0
        },
        {
          attributeName: "aPositionCoord",
          size: 2,
          uploadFunction: this.uploadPosition,
          offset: 0
        },
        {
          attributeName: "aRotation",
          size: 1,
          uploadFunction: this.uploadRotation,
          offset: 0
        },
        {
          attributeName: "aTextureCoord",
          size: 2,
          uploadFunction: this.uploadUvs,
          offset: 0
        },
        {
          attributeName: "aColor",
          size: 1,
          type: TYPES.UNSIGNED_BYTE,
          uploadFunction: this.uploadTint,
          offset: 0
        }
      ];
      this.shader = Shader.from(vertex, fragment, {});
      this.state = State.for2d();
    }
    render(container) {
      const children = container.children;
      const maxSize = container._maxSize;
      const batchSize = container._batchSize;
      const renderer = this.renderer;
      let totalChildren = children.length;
      if (totalChildren === 0) {
        return;
      } else if (totalChildren > maxSize && !container.autoResize) {
        totalChildren = maxSize;
      }
      let buffers = container._buffers;
      if (!buffers) {
        buffers = container._buffers = this.generateBuffers(container);
      }
      const baseTexture = children[0]._texture.baseTexture;
      const premultiplied = baseTexture.alphaMode > 0;
      this.state.blendMode = correctBlendMode(container.blendMode, premultiplied);
      renderer.state.set(this.state);
      const gl = renderer.gl;
      const m = container.worldTransform.copyTo(this.tempMatrix);
      m.prepend(renderer.globalUniforms.uniforms.projectionMatrix);
      this.shader.uniforms.translationMatrix = m.toArray(true);
      this.shader.uniforms.uColor = premultiplyRgba(container.tintRgb, container.worldAlpha, this.shader.uniforms.uColor, premultiplied);
      this.shader.uniforms.uSampler = baseTexture;
      this.renderer.shader.bind(this.shader);
      let updateStatic = false;
      for (let i = 0, j = 0; i < totalChildren; i += batchSize, j += 1) {
        let amount = totalChildren - i;
        if (amount > batchSize) {
          amount = batchSize;
        }
        if (j >= buffers.length) {
          buffers.push(this._generateOneMoreBuffer(container));
        }
        const buffer = buffers[j];
        buffer.uploadDynamic(children, i, amount);
        const bid = container._bufferUpdateIDs[j] || 0;
        updateStatic = updateStatic || buffer._updateID < bid;
        if (updateStatic) {
          buffer._updateID = container._updateID;
          buffer.uploadStatic(children, i, amount);
        }
        renderer.geometry.bind(buffer.geometry);
        gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);
      }
    }
    generateBuffers(container) {
      const buffers = [];
      const size = container._maxSize;
      const batchSize = container._batchSize;
      const dynamicPropertyFlags = container._properties;
      for (let i = 0; i < size; i += batchSize) {
        buffers.push(new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));
      }
      return buffers;
    }
    _generateOneMoreBuffer(container) {
      const batchSize = container._batchSize;
      const dynamicPropertyFlags = container._properties;
      return new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);
    }
    uploadVertices(children, startIndex, amount, array, stride, offset) {
      let w0 = 0;
      let w1 = 0;
      let h0 = 0;
      let h1 = 0;
      for (let i = 0; i < amount; ++i) {
        const sprite = children[startIndex + i];
        const texture = sprite._texture;
        const sx = sprite.scale.x;
        const sy = sprite.scale.y;
        const trim = texture.trim;
        const orig = texture.orig;
        if (trim) {
          w1 = trim.x - sprite.anchor.x * orig.width;
          w0 = w1 + trim.width;
          h1 = trim.y - sprite.anchor.y * orig.height;
          h0 = h1 + trim.height;
        } else {
          w0 = orig.width * (1 - sprite.anchor.x);
          w1 = orig.width * -sprite.anchor.x;
          h0 = orig.height * (1 - sprite.anchor.y);
          h1 = orig.height * -sprite.anchor.y;
        }
        array[offset] = w1 * sx;
        array[offset + 1] = h1 * sy;
        array[offset + stride] = w0 * sx;
        array[offset + stride + 1] = h1 * sy;
        array[offset + stride * 2] = w0 * sx;
        array[offset + stride * 2 + 1] = h0 * sy;
        array[offset + stride * 3] = w1 * sx;
        array[offset + stride * 3 + 1] = h0 * sy;
        offset += stride * 4;
      }
    }
    uploadPosition(children, startIndex, amount, array, stride, offset) {
      for (let i = 0; i < amount; i++) {
        const spritePosition = children[startIndex + i].position;
        array[offset] = spritePosition.x;
        array[offset + 1] = spritePosition.y;
        array[offset + stride] = spritePosition.x;
        array[offset + stride + 1] = spritePosition.y;
        array[offset + stride * 2] = spritePosition.x;
        array[offset + stride * 2 + 1] = spritePosition.y;
        array[offset + stride * 3] = spritePosition.x;
        array[offset + stride * 3 + 1] = spritePosition.y;
        offset += stride * 4;
      }
    }
    uploadRotation(children, startIndex, amount, array, stride, offset) {
      for (let i = 0; i < amount; i++) {
        const spriteRotation = children[startIndex + i].rotation;
        array[offset] = spriteRotation;
        array[offset + stride] = spriteRotation;
        array[offset + stride * 2] = spriteRotation;
        array[offset + stride * 3] = spriteRotation;
        offset += stride * 4;
      }
    }
    uploadUvs(children, startIndex, amount, array, stride, offset) {
      for (let i = 0; i < amount; ++i) {
        const textureUvs = children[startIndex + i]._texture._uvs;
        if (textureUvs) {
          array[offset] = textureUvs.x0;
          array[offset + 1] = textureUvs.y0;
          array[offset + stride] = textureUvs.x1;
          array[offset + stride + 1] = textureUvs.y1;
          array[offset + stride * 2] = textureUvs.x2;
          array[offset + stride * 2 + 1] = textureUvs.y2;
          array[offset + stride * 3] = textureUvs.x3;
          array[offset + stride * 3 + 1] = textureUvs.y3;
          offset += stride * 4;
        } else {
          array[offset] = 0;
          array[offset + 1] = 0;
          array[offset + stride] = 0;
          array[offset + stride + 1] = 0;
          array[offset + stride * 2] = 0;
          array[offset + stride * 2 + 1] = 0;
          array[offset + stride * 3] = 0;
          array[offset + stride * 3 + 1] = 0;
          offset += stride * 4;
        }
      }
    }
    uploadTint(children, startIndex, amount, array, stride, offset) {
      for (let i = 0; i < amount; ++i) {
        const sprite = children[startIndex + i];
        const premultiplied = sprite._texture.baseTexture.alphaMode > 0;
        const alpha = sprite.alpha;
        const argb = alpha < 1 && premultiplied ? premultiplyTint(sprite._tintRGB, alpha) : sprite._tintRGB + (alpha * 255 << 24);
        array[offset] = argb;
        array[offset + stride] = argb;
        array[offset + stride * 2] = argb;
        array[offset + stride * 3] = argb;
        offset += stride * 4;
      }
    }
    destroy() {
      super.destroy();
      if (this.shader) {
        this.shader.destroy();
        this.shader = null;
      }
      this.tempMatrix = null;
    }
  };
  ParticleRenderer.extension = {
    name: "particle",
    type: ExtensionType.RendererPlugin
  };
  extensions$1.add(ParticleRenderer);
  settings.UPLOADS_PER_FRAME = 4;
  var TEXT_GRADIENT = /* @__PURE__ */ ((TEXT_GRADIENT2) => {
    TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_VERTICAL"] = 0] = "LINEAR_VERTICAL";
    TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_HORIZONTAL"] = 1] = "LINEAR_HORIZONTAL";
    return TEXT_GRADIENT2;
  })(TEXT_GRADIENT || {});
  var defaultStyle = {
    align: "left",
    breakWords: false,
    dropShadow: false,
    dropShadowAlpha: 1,
    dropShadowAngle: Math.PI / 6,
    dropShadowBlur: 0,
    dropShadowColor: "black",
    dropShadowDistance: 5,
    fill: "black",
    fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,
    fillGradientStops: [],
    fontFamily: "Arial",
    fontSize: 26,
    fontStyle: "normal",
    fontVariant: "normal",
    fontWeight: "normal",
    letterSpacing: 0,
    lineHeight: 0,
    lineJoin: "miter",
    miterLimit: 10,
    padding: 0,
    stroke: "black",
    strokeThickness: 0,
    textBaseline: "alphabetic",
    trim: false,
    whiteSpace: "pre",
    wordWrap: false,
    wordWrapWidth: 100,
    leading: 0
  };
  var genericFontFamilies = [
    "serif",
    "sans-serif",
    "monospace",
    "cursive",
    "fantasy",
    "system-ui"
  ];
  var TextStyle = class {
    constructor(style) {
      this.styleID = 0;
      this.reset();
      deepCopyProperties(this, style, style);
    }
    clone() {
      const clonedProperties = {};
      deepCopyProperties(clonedProperties, this, defaultStyle);
      return new TextStyle(clonedProperties);
    }
    reset() {
      deepCopyProperties(this, defaultStyle, defaultStyle);
    }
    get align() {
      return this._align;
    }
    set align(align) {
      if (this._align !== align) {
        this._align = align;
        this.styleID++;
      }
    }
    get breakWords() {
      return this._breakWords;
    }
    set breakWords(breakWords) {
      if (this._breakWords !== breakWords) {
        this._breakWords = breakWords;
        this.styleID++;
      }
    }
    get dropShadow() {
      return this._dropShadow;
    }
    set dropShadow(dropShadow) {
      if (this._dropShadow !== dropShadow) {
        this._dropShadow = dropShadow;
        this.styleID++;
      }
    }
    get dropShadowAlpha() {
      return this._dropShadowAlpha;
    }
    set dropShadowAlpha(dropShadowAlpha) {
      if (this._dropShadowAlpha !== dropShadowAlpha) {
        this._dropShadowAlpha = dropShadowAlpha;
        this.styleID++;
      }
    }
    get dropShadowAngle() {
      return this._dropShadowAngle;
    }
    set dropShadowAngle(dropShadowAngle) {
      if (this._dropShadowAngle !== dropShadowAngle) {
        this._dropShadowAngle = dropShadowAngle;
        this.styleID++;
      }
    }
    get dropShadowBlur() {
      return this._dropShadowBlur;
    }
    set dropShadowBlur(dropShadowBlur) {
      if (this._dropShadowBlur !== dropShadowBlur) {
        this._dropShadowBlur = dropShadowBlur;
        this.styleID++;
      }
    }
    get dropShadowColor() {
      return this._dropShadowColor;
    }
    set dropShadowColor(dropShadowColor) {
      const outputColor = getColor(dropShadowColor);
      if (this._dropShadowColor !== outputColor) {
        this._dropShadowColor = outputColor;
        this.styleID++;
      }
    }
    get dropShadowDistance() {
      return this._dropShadowDistance;
    }
    set dropShadowDistance(dropShadowDistance) {
      if (this._dropShadowDistance !== dropShadowDistance) {
        this._dropShadowDistance = dropShadowDistance;
        this.styleID++;
      }
    }
    get fill() {
      return this._fill;
    }
    set fill(fill) {
      const outputColor = getColor(fill);
      if (this._fill !== outputColor) {
        this._fill = outputColor;
        this.styleID++;
      }
    }
    get fillGradientType() {
      return this._fillGradientType;
    }
    set fillGradientType(fillGradientType) {
      if (this._fillGradientType !== fillGradientType) {
        this._fillGradientType = fillGradientType;
        this.styleID++;
      }
    }
    get fillGradientStops() {
      return this._fillGradientStops;
    }
    set fillGradientStops(fillGradientStops) {
      if (!areArraysEqual(this._fillGradientStops, fillGradientStops)) {
        this._fillGradientStops = fillGradientStops;
        this.styleID++;
      }
    }
    get fontFamily() {
      return this._fontFamily;
    }
    set fontFamily(fontFamily) {
      if (this.fontFamily !== fontFamily) {
        this._fontFamily = fontFamily;
        this.styleID++;
      }
    }
    get fontSize() {
      return this._fontSize;
    }
    set fontSize(fontSize) {
      if (this._fontSize !== fontSize) {
        this._fontSize = fontSize;
        this.styleID++;
      }
    }
    get fontStyle() {
      return this._fontStyle;
    }
    set fontStyle(fontStyle) {
      if (this._fontStyle !== fontStyle) {
        this._fontStyle = fontStyle;
        this.styleID++;
      }
    }
    get fontVariant() {
      return this._fontVariant;
    }
    set fontVariant(fontVariant) {
      if (this._fontVariant !== fontVariant) {
        this._fontVariant = fontVariant;
        this.styleID++;
      }
    }
    get fontWeight() {
      return this._fontWeight;
    }
    set fontWeight(fontWeight) {
      if (this._fontWeight !== fontWeight) {
        this._fontWeight = fontWeight;
        this.styleID++;
      }
    }
    get letterSpacing() {
      return this._letterSpacing;
    }
    set letterSpacing(letterSpacing) {
      if (this._letterSpacing !== letterSpacing) {
        this._letterSpacing = letterSpacing;
        this.styleID++;
      }
    }
    get lineHeight() {
      return this._lineHeight;
    }
    set lineHeight(lineHeight) {
      if (this._lineHeight !== lineHeight) {
        this._lineHeight = lineHeight;
        this.styleID++;
      }
    }
    get leading() {
      return this._leading;
    }
    set leading(leading) {
      if (this._leading !== leading) {
        this._leading = leading;
        this.styleID++;
      }
    }
    get lineJoin() {
      return this._lineJoin;
    }
    set lineJoin(lineJoin) {
      if (this._lineJoin !== lineJoin) {
        this._lineJoin = lineJoin;
        this.styleID++;
      }
    }
    get miterLimit() {
      return this._miterLimit;
    }
    set miterLimit(miterLimit) {
      if (this._miterLimit !== miterLimit) {
        this._miterLimit = miterLimit;
        this.styleID++;
      }
    }
    get padding() {
      return this._padding;
    }
    set padding(padding) {
      if (this._padding !== padding) {
        this._padding = padding;
        this.styleID++;
      }
    }
    get stroke() {
      return this._stroke;
    }
    set stroke(stroke) {
      const outputColor = getColor(stroke);
      if (this._stroke !== outputColor) {
        this._stroke = outputColor;
        this.styleID++;
      }
    }
    get strokeThickness() {
      return this._strokeThickness;
    }
    set strokeThickness(strokeThickness) {
      if (this._strokeThickness !== strokeThickness) {
        this._strokeThickness = strokeThickness;
        this.styleID++;
      }
    }
    get textBaseline() {
      return this._textBaseline;
    }
    set textBaseline(textBaseline) {
      if (this._textBaseline !== textBaseline) {
        this._textBaseline = textBaseline;
        this.styleID++;
      }
    }
    get trim() {
      return this._trim;
    }
    set trim(trim) {
      if (this._trim !== trim) {
        this._trim = trim;
        this.styleID++;
      }
    }
    get whiteSpace() {
      return this._whiteSpace;
    }
    set whiteSpace(whiteSpace) {
      if (this._whiteSpace !== whiteSpace) {
        this._whiteSpace = whiteSpace;
        this.styleID++;
      }
    }
    get wordWrap() {
      return this._wordWrap;
    }
    set wordWrap(wordWrap) {
      if (this._wordWrap !== wordWrap) {
        this._wordWrap = wordWrap;
        this.styleID++;
      }
    }
    get wordWrapWidth() {
      return this._wordWrapWidth;
    }
    set wordWrapWidth(wordWrapWidth) {
      if (this._wordWrapWidth !== wordWrapWidth) {
        this._wordWrapWidth = wordWrapWidth;
        this.styleID++;
      }
    }
    toFontString() {
      const fontSizeString = typeof this.fontSize === "number" ? `${this.fontSize}px` : this.fontSize;
      let fontFamilies = this.fontFamily;
      if (!Array.isArray(this.fontFamily)) {
        fontFamilies = this.fontFamily.split(",");
      }
      for (let i = fontFamilies.length - 1; i >= 0; i--) {
        let fontFamily = fontFamilies[i].trim();
        if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {
          fontFamily = `"${fontFamily}"`;
        }
        fontFamilies[i] = fontFamily;
      }
      return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;
    }
  };
  function getSingleColor(color2) {
    if (typeof color2 === "number") {
      return hex2string(color2);
    } else if (typeof color2 === "string") {
      if (color2.startsWith("0x")) {
        color2 = color2.replace("0x", "#");
      }
    }
    return color2;
  }
  function getColor(color2) {
    if (!Array.isArray(color2)) {
      return getSingleColor(color2);
    } else {
      for (let i = 0; i < color2.length; ++i) {
        color2[i] = getSingleColor(color2[i]);
      }
      return color2;
    }
  }
  function areArraysEqual(array1, array2) {
    if (!Array.isArray(array1) || !Array.isArray(array2)) {
      return false;
    }
    if (array1.length !== array2.length) {
      return false;
    }
    for (let i = 0; i < array1.length; ++i) {
      if (array1[i] !== array2[i]) {
        return false;
      }
    }
    return true;
  }
  function deepCopyProperties(target2, source, propertyObj) {
    for (const prop in propertyObj) {
      if (Array.isArray(source[prop])) {
        target2[prop] = source[prop].slice();
      } else {
        target2[prop] = source[prop];
      }
    }
  }
  var contextSettings = {
    willReadFrequently: true
  };
  var TextMetrics = class {
    constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
      this.text = text;
      this.style = style;
      this.width = width;
      this.height = height;
      this.lines = lines;
      this.lineWidths = lineWidths;
      this.lineHeight = lineHeight;
      this.maxLineWidth = maxLineWidth;
      this.fontProperties = fontProperties;
    }
    static measureText(text, style, wordWrap, canvas = TextMetrics._canvas) {
      wordWrap = wordWrap === void 0 || wordWrap === null ? style.wordWrap : wordWrap;
      const font = style.toFontString();
      const fontProperties = TextMetrics.measureFont(font);
      if (fontProperties.fontSize === 0) {
        fontProperties.fontSize = style.fontSize;
        fontProperties.ascent = style.fontSize;
      }
      const context2 = canvas.getContext("2d", contextSettings);
      context2.font = font;
      const outputText = wordWrap ? TextMetrics.wordWrap(text, style, canvas) : text;
      const lines = outputText.split(/(?:\r\n|\r|\n)/);
      const lineWidths = new Array(lines.length);
      let maxLineWidth = 0;
      for (let i = 0; i < lines.length; i++) {
        const lineWidth = context2.measureText(lines[i]).width + (lines[i].length - 1) * style.letterSpacing;
        lineWidths[i] = lineWidth;
        maxLineWidth = Math.max(maxLineWidth, lineWidth);
      }
      let width = maxLineWidth + style.strokeThickness;
      if (style.dropShadow) {
        width += style.dropShadowDistance;
      }
      const lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;
      let height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness * 2) + (lines.length - 1) * (lineHeight + style.leading);
      if (style.dropShadow) {
        height += style.dropShadowDistance;
      }
      return new TextMetrics(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);
    }
    static wordWrap(text, style, canvas = TextMetrics._canvas) {
      const context2 = canvas.getContext("2d", contextSettings);
      let width = 0;
      let line = "";
      let lines = "";
      const cache = /* @__PURE__ */ Object.create(null);
      const { letterSpacing, whiteSpace } = style;
      const collapseSpaces = TextMetrics.collapseSpaces(whiteSpace);
      const collapseNewlines = TextMetrics.collapseNewlines(whiteSpace);
      let canPrependSpaces = !collapseSpaces;
      const wordWrapWidth = style.wordWrapWidth + letterSpacing;
      const tokens = TextMetrics.tokenize(text);
      for (let i = 0; i < tokens.length; i++) {
        let token = tokens[i];
        if (TextMetrics.isNewline(token)) {
          if (!collapseNewlines) {
            lines += TextMetrics.addLine(line);
            canPrependSpaces = !collapseSpaces;
            line = "";
            width = 0;
            continue;
          }
          token = " ";
        }
        if (collapseSpaces) {
          const currIsBreakingSpace = TextMetrics.isBreakingSpace(token);
          const lastIsBreakingSpace = TextMetrics.isBreakingSpace(line[line.length - 1]);
          if (currIsBreakingSpace && lastIsBreakingSpace) {
            continue;
          }
        }
        const tokenWidth = TextMetrics.getFromCache(token, letterSpacing, cache, context2);
        if (tokenWidth > wordWrapWidth) {
          if (line !== "") {
            lines += TextMetrics.addLine(line);
            line = "";
            width = 0;
          }
          if (TextMetrics.canBreakWords(token, style.breakWords)) {
            const characters = TextMetrics.wordWrapSplit(token);
            for (let j = 0; j < characters.length; j++) {
              let char = characters[j];
              let k = 1;
              while (characters[j + k]) {
                const nextChar = characters[j + k];
                const lastChar = char[char.length - 1];
                if (!TextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {
                  char += nextChar;
                } else {
                  break;
                }
                k++;
              }
              j += char.length - 1;
              const characterWidth = TextMetrics.getFromCache(char, letterSpacing, cache, context2);
              if (characterWidth + width > wordWrapWidth) {
                lines += TextMetrics.addLine(line);
                canPrependSpaces = false;
                line = "";
                width = 0;
              }
              line += char;
              width += characterWidth;
            }
          } else {
            if (line.length > 0) {
              lines += TextMetrics.addLine(line);
              line = "";
              width = 0;
            }
            const isLastToken = i === tokens.length - 1;
            lines += TextMetrics.addLine(token, !isLastToken);
            canPrependSpaces = false;
            line = "";
            width = 0;
          }
        } else {
          if (tokenWidth + width > wordWrapWidth) {
            canPrependSpaces = false;
            lines += TextMetrics.addLine(line);
            line = "";
            width = 0;
          }
          if (line.length > 0 || !TextMetrics.isBreakingSpace(token) || canPrependSpaces) {
            line += token;
            width += tokenWidth;
          }
        }
      }
      lines += TextMetrics.addLine(line, false);
      return lines;
    }
    static addLine(line, newLine = true) {
      line = TextMetrics.trimRight(line);
      line = newLine ? `${line}
` : line;
      return line;
    }
    static getFromCache(key, letterSpacing, cache, context2) {
      let width = cache[key];
      if (typeof width !== "number") {
        const spacing = key.length * letterSpacing;
        width = context2.measureText(key).width + spacing;
        cache[key] = width;
      }
      return width;
    }
    static collapseSpaces(whiteSpace) {
      return whiteSpace === "normal" || whiteSpace === "pre-line";
    }
    static collapseNewlines(whiteSpace) {
      return whiteSpace === "normal";
    }
    static trimRight(text) {
      if (typeof text !== "string") {
        return "";
      }
      for (let i = text.length - 1; i >= 0; i--) {
        const char = text[i];
        if (!TextMetrics.isBreakingSpace(char)) {
          break;
        }
        text = text.slice(0, -1);
      }
      return text;
    }
    static isNewline(char) {
      if (typeof char !== "string") {
        return false;
      }
      return TextMetrics._newlines.includes(char.charCodeAt(0));
    }
    static isBreakingSpace(char, _nextChar) {
      if (typeof char !== "string") {
        return false;
      }
      return TextMetrics._breakingSpaces.includes(char.charCodeAt(0));
    }
    static tokenize(text) {
      const tokens = [];
      let token = "";
      if (typeof text !== "string") {
        return tokens;
      }
      for (let i = 0; i < text.length; i++) {
        const char = text[i];
        const nextChar = text[i + 1];
        if (TextMetrics.isBreakingSpace(char, nextChar) || TextMetrics.isNewline(char)) {
          if (token !== "") {
            tokens.push(token);
            token = "";
          }
          tokens.push(char);
          continue;
        }
        token += char;
      }
      if (token !== "") {
        tokens.push(token);
      }
      return tokens;
    }
    static canBreakWords(_token, breakWords) {
      return breakWords;
    }
    static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {
      return true;
    }
    static wordWrapSplit(token) {
      return token.split("");
    }
    static measureFont(font) {
      if (TextMetrics._fonts[font]) {
        return TextMetrics._fonts[font];
      }
      const properties = {
        ascent: 0,
        descent: 0,
        fontSize: 0
      };
      const canvas = TextMetrics._canvas;
      const context2 = TextMetrics._context;
      context2.font = font;
      const metricsString = TextMetrics.METRICS_STRING + TextMetrics.BASELINE_SYMBOL;
      const width = Math.ceil(context2.measureText(metricsString).width);
      let baseline = Math.ceil(context2.measureText(TextMetrics.BASELINE_SYMBOL).width);
      const height = Math.ceil(TextMetrics.HEIGHT_MULTIPLIER * baseline);
      baseline = baseline * TextMetrics.BASELINE_MULTIPLIER | 0;
      canvas.width = width;
      canvas.height = height;
      context2.fillStyle = "#f00";
      context2.fillRect(0, 0, width, height);
      context2.font = font;
      context2.textBaseline = "alphabetic";
      context2.fillStyle = "#000";
      context2.fillText(metricsString, 0, baseline);
      const imagedata = context2.getImageData(0, 0, width, height).data;
      const pixels = imagedata.length;
      const line = width * 4;
      let i = 0;
      let idx = 0;
      let stop = false;
      for (i = 0; i < baseline; ++i) {
        for (let j = 0; j < line; j += 4) {
          if (imagedata[idx + j] !== 255) {
            stop = true;
            break;
          }
        }
        if (!stop) {
          idx += line;
        } else {
          break;
        }
      }
      properties.ascent = baseline - i;
      idx = pixels - line;
      stop = false;
      for (i = height; i > baseline; --i) {
        for (let j = 0; j < line; j += 4) {
          if (imagedata[idx + j] !== 255) {
            stop = true;
            break;
          }
        }
        if (!stop) {
          idx -= line;
        } else {
          break;
        }
      }
      properties.descent = i - baseline;
      properties.fontSize = properties.ascent + properties.descent;
      TextMetrics._fonts[font] = properties;
      return properties;
    }
    static clearMetrics(font = "") {
      if (font) {
        delete TextMetrics._fonts[font];
      } else {
        TextMetrics._fonts = {};
      }
    }
    static get _canvas() {
      if (!TextMetrics.__canvas) {
        let canvas;
        try {
          const c = new OffscreenCanvas(0, 0);
          const context2 = c.getContext("2d", contextSettings);
          if (context2?.measureText) {
            TextMetrics.__canvas = c;
            return c;
          }
          canvas = settings.ADAPTER.createCanvas();
        } catch (ex) {
          canvas = settings.ADAPTER.createCanvas();
        }
        canvas.width = canvas.height = 10;
        TextMetrics.__canvas = canvas;
      }
      return TextMetrics.__canvas;
    }
    static get _context() {
      if (!TextMetrics.__context) {
        TextMetrics.__context = TextMetrics._canvas.getContext("2d", contextSettings);
      }
      return TextMetrics.__context;
    }
  };
  TextMetrics._fonts = {};
  TextMetrics.METRICS_STRING = "|\xC9q\xC5";
  TextMetrics.BASELINE_SYMBOL = "M";
  TextMetrics.BASELINE_MULTIPLIER = 1.4;
  TextMetrics.HEIGHT_MULTIPLIER = 2;
  TextMetrics._newlines = [
    10,
    13
  ];
  TextMetrics._breakingSpaces = [
    9,
    32,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8200,
    8201,
    8202,
    8287,
    12288
  ];
  var defaultDestroyOptions = {
    texture: true,
    children: false,
    baseTexture: true
  };
  var _Text = class extends Sprite {
    constructor(text, style, canvas) {
      let ownCanvas = false;
      if (!canvas) {
        canvas = settings.ADAPTER.createCanvas();
        ownCanvas = true;
      }
      canvas.width = 3;
      canvas.height = 3;
      const texture = Texture.from(canvas);
      texture.orig = new Rectangle();
      texture.trim = new Rectangle();
      super(texture);
      this._ownCanvas = ownCanvas;
      this.canvas = canvas;
      this.context = canvas.getContext("2d", {
        willReadFrequently: true
      });
      this._resolution = settings.RESOLUTION;
      this._autoResolution = true;
      this._text = null;
      this._style = null;
      this._styleListener = null;
      this._font = "";
      this.text = text;
      this.style = style;
      this.localStyleID = -1;
    }
    updateText(respectDirty) {
      const style = this._style;
      if (this.localStyleID !== style.styleID) {
        this.dirty = true;
        this.localStyleID = style.styleID;
      }
      if (!this.dirty && respectDirty) {
        return;
      }
      this._font = this._style.toFontString();
      const context2 = this.context;
      const measured = TextMetrics.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas);
      const width = measured.width;
      const height = measured.height;
      const lines = measured.lines;
      const lineHeight = measured.lineHeight;
      const lineWidths = measured.lineWidths;
      const maxLineWidth = measured.maxLineWidth;
      const fontProperties = measured.fontProperties;
      this.canvas.width = Math.ceil(Math.ceil(Math.max(1, width) + style.padding * 2) * this._resolution);
      this.canvas.height = Math.ceil(Math.ceil(Math.max(1, height) + style.padding * 2) * this._resolution);
      context2.scale(this._resolution, this._resolution);
      context2.clearRect(0, 0, this.canvas.width, this.canvas.height);
      context2.font = this._font;
      context2.lineWidth = style.strokeThickness;
      context2.textBaseline = style.textBaseline;
      context2.lineJoin = style.lineJoin;
      context2.miterLimit = style.miterLimit;
      let linePositionX;
      let linePositionY;
      const passesCount = style.dropShadow ? 2 : 1;
      for (let i = 0; i < passesCount; ++i) {
        const isShadowPass = style.dropShadow && i === 0;
        const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;
        const dsOffsetShadow = dsOffsetText * this._resolution;
        if (isShadowPass) {
          context2.fillStyle = "black";
          context2.strokeStyle = "black";
          const dropShadowColor = style.dropShadowColor;
          const rgb = hex2rgb(typeof dropShadowColor === "number" ? dropShadowColor : string2hex(dropShadowColor));
          const dropShadowBlur = style.dropShadowBlur * this._resolution;
          const dropShadowDistance = style.dropShadowDistance * this._resolution;
          context2.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${style.dropShadowAlpha})`;
          context2.shadowBlur = dropShadowBlur;
          context2.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
          context2.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance + dsOffsetShadow;
        } else {
          context2.fillStyle = this._generateFillStyle(style, lines, measured);
          context2.strokeStyle = style.stroke;
          context2.shadowColor = "black";
          context2.shadowBlur = 0;
          context2.shadowOffsetX = 0;
          context2.shadowOffsetY = 0;
        }
        let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
        if (lineHeight - fontProperties.fontSize < 0) {
          linePositionYShift = 0;
        }
        for (let i2 = 0; i2 < lines.length; i2++) {
          linePositionX = style.strokeThickness / 2;
          linePositionY = style.strokeThickness / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift;
          if (style.align === "right") {
            linePositionX += maxLineWidth - lineWidths[i2];
          } else if (style.align === "center") {
            linePositionX += (maxLineWidth - lineWidths[i2]) / 2;
          }
          if (style.stroke && style.strokeThickness) {
            this.drawLetterSpacing(lines[i2], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText, true);
          }
          if (style.fill) {
            this.drawLetterSpacing(lines[i2], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText);
          }
        }
      }
      this.updateTexture();
    }
    drawLetterSpacing(text, x, y, isStroke = false) {
      const style = this._style;
      const letterSpacing = style.letterSpacing;
      const supportLetterSpacing = _Text.experimentalLetterSpacing && ("letterSpacing" in CanvasRenderingContext2D.prototype || "textLetterSpacing" in CanvasRenderingContext2D.prototype);
      if (letterSpacing === 0 || supportLetterSpacing) {
        if (supportLetterSpacing) {
          this.context.letterSpacing = letterSpacing;
          this.context.textLetterSpacing = letterSpacing;
        }
        if (isStroke) {
          this.context.strokeText(text, x, y);
        } else {
          this.context.fillText(text, x, y);
        }
        return;
      }
      let currentPosition = x;
      const stringArray = Array.from ? Array.from(text) : text.split("");
      let previousWidth = this.context.measureText(text).width;
      let currentWidth = 0;
      for (let i = 0; i < stringArray.length; ++i) {
        const currentChar = stringArray[i];
        if (isStroke) {
          this.context.strokeText(currentChar, currentPosition, y);
        } else {
          this.context.fillText(currentChar, currentPosition, y);
        }
        let textStr = "";
        for (let j = i + 1; j < stringArray.length; ++j) {
          textStr += stringArray[j];
        }
        currentWidth = this.context.measureText(textStr).width;
        currentPosition += previousWidth - currentWidth + letterSpacing;
        previousWidth = currentWidth;
      }
    }
    updateTexture() {
      const canvas = this.canvas;
      if (this._style.trim) {
        const trimmed = trimCanvas(canvas);
        if (trimmed.data) {
          canvas.width = trimmed.width;
          canvas.height = trimmed.height;
          this.context.putImageData(trimmed.data, 0, 0);
        }
      }
      const texture = this._texture;
      const style = this._style;
      const padding = style.trim ? 0 : style.padding;
      const baseTexture = texture.baseTexture;
      texture.trim.width = texture._frame.width = canvas.width / this._resolution;
      texture.trim.height = texture._frame.height = canvas.height / this._resolution;
      texture.trim.x = -padding;
      texture.trim.y = -padding;
      texture.orig.width = texture._frame.width - padding * 2;
      texture.orig.height = texture._frame.height - padding * 2;
      this._onTextureUpdate();
      baseTexture.setRealSize(canvas.width, canvas.height, this._resolution);
      texture.updateUvs();
      this.dirty = false;
    }
    _render(renderer) {
      if (this._autoResolution && this._resolution !== renderer.resolution) {
        this._resolution = renderer.resolution;
        this.dirty = true;
      }
      this.updateText(true);
      super._render(renderer);
    }
    updateTransform() {
      this.updateText(true);
      super.updateTransform();
    }
    getBounds(skipUpdate, rect) {
      this.updateText(true);
      if (this._textureID === -1) {
        skipUpdate = false;
      }
      return super.getBounds(skipUpdate, rect);
    }
    getLocalBounds(rect) {
      this.updateText(true);
      return super.getLocalBounds.call(this, rect);
    }
    _calculateBounds() {
      this.calculateVertices();
      this._bounds.addQuad(this.vertexData);
    }
    _generateFillStyle(style, lines, metrics) {
      const fillStyle = style.fill;
      if (!Array.isArray(fillStyle)) {
        return fillStyle;
      } else if (fillStyle.length === 1) {
        return fillStyle[0];
      }
      let gradient;
      const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
      const padding = style.padding || 0;
      const width = this.canvas.width / this._resolution - dropShadowCorrection - padding * 2;
      const height = this.canvas.height / this._resolution - dropShadowCorrection - padding * 2;
      const fill = fillStyle.slice();
      const fillGradientStops = style.fillGradientStops.slice();
      if (!fillGradientStops.length) {
        const lengthPlus1 = fill.length + 1;
        for (let i = 1; i < lengthPlus1; ++i) {
          fillGradientStops.push(i / lengthPlus1);
        }
      }
      fill.unshift(fillStyle[0]);
      fillGradientStops.unshift(0);
      fill.push(fillStyle[fillStyle.length - 1]);
      fillGradientStops.push(1);
      if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
        gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);
        const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
        for (let i = 0; i < lines.length; i++) {
          const lastLineBottom = metrics.lineHeight * (i - 1) + textHeight;
          const thisLineTop = metrics.lineHeight * i;
          let thisLineGradientStart = thisLineTop;
          if (i > 0 && lastLineBottom > thisLineTop) {
            thisLineGradientStart = (thisLineTop + lastLineBottom) / 2;
          }
          const thisLineBottom = thisLineTop + textHeight;
          const nextLineTop = metrics.lineHeight * (i + 1);
          let thisLineGradientEnd = thisLineBottom;
          if (i + 1 < lines.length && nextLineTop < thisLineBottom) {
            thisLineGradientEnd = (thisLineBottom + nextLineTop) / 2;
          }
          const gradStopLineHeight = (thisLineGradientEnd - thisLineGradientStart) / height;
          for (let j = 0; j < fill.length; j++) {
            let lineStop = 0;
            if (typeof fillGradientStops[j] === "number") {
              lineStop = fillGradientStops[j];
            } else {
              lineStop = j / fill.length;
            }
            let globalStop = Math.min(1, Math.max(0, thisLineGradientStart / height + lineStop * gradStopLineHeight));
            globalStop = Number(globalStop.toFixed(5));
            gradient.addColorStop(globalStop, fill[j]);
          }
        }
      } else {
        gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);
        const totalIterations = fill.length + 1;
        let currentIteration = 1;
        for (let i = 0; i < fill.length; i++) {
          let stop;
          if (typeof fillGradientStops[i] === "number") {
            stop = fillGradientStops[i];
          } else {
            stop = currentIteration / totalIterations;
          }
          gradient.addColorStop(stop, fill[i]);
          currentIteration++;
        }
      }
      return gradient;
    }
    destroy(options) {
      if (typeof options === "boolean") {
        options = { children: options };
      }
      options = Object.assign({}, defaultDestroyOptions, options);
      super.destroy(options);
      if (this._ownCanvas) {
        this.canvas.height = this.canvas.width = 0;
      }
      this.context = null;
      this.canvas = null;
      this._style = null;
    }
    get width() {
      this.updateText(true);
      return Math.abs(this.scale.x) * this._texture.orig.width;
    }
    set width(value3) {
      this.updateText(true);
      const s = sign2(this.scale.x) || 1;
      this.scale.x = s * value3 / this._texture.orig.width;
      this._width = value3;
    }
    get height() {
      this.updateText(true);
      return Math.abs(this.scale.y) * this._texture.orig.height;
    }
    set height(value3) {
      this.updateText(true);
      const s = sign2(this.scale.y) || 1;
      this.scale.y = s * value3 / this._texture.orig.height;
      this._height = value3;
    }
    get style() {
      return this._style;
    }
    set style(style) {
      style = style || {};
      if (style instanceof TextStyle) {
        this._style = style;
      } else {
        this._style = new TextStyle(style);
      }
      this.localStyleID = -1;
      this.dirty = true;
    }
    get text() {
      return this._text;
    }
    set text(text) {
      text = String(text === null || text === void 0 ? "" : text);
      if (this._text === text) {
        return;
      }
      this._text = text;
      this.dirty = true;
    }
    get resolution() {
      return this._resolution;
    }
    set resolution(value3) {
      this._autoResolution = false;
      if (this._resolution === value3) {
        return;
      }
      this._resolution = value3;
      this.dirty = true;
    }
  };
  var Text$1 = _Text;
  Text$1.experimentalLetterSpacing = false;
  var CountLimiter = class {
    constructor(maxItemsPerFrame) {
      this.maxItemsPerFrame = maxItemsPerFrame;
      this.itemsLeft = 0;
    }
    beginFrame() {
      this.itemsLeft = this.maxItemsPerFrame;
    }
    allowedToUpload() {
      return this.itemsLeft-- > 0;
    }
  };
  function findMultipleBaseTextures(item2, queue) {
    let result2 = false;
    if (item2?._textures?.length) {
      for (let i = 0; i < item2._textures.length; i++) {
        if (item2._textures[i] instanceof Texture) {
          const baseTexture = item2._textures[i].baseTexture;
          if (!queue.includes(baseTexture)) {
            queue.push(baseTexture);
            result2 = true;
          }
        }
      }
    }
    return result2;
  }
  function findBaseTexture(item2, queue) {
    if (item2.baseTexture instanceof BaseTexture) {
      const texture = item2.baseTexture;
      if (!queue.includes(texture)) {
        queue.push(texture);
      }
      return true;
    }
    return false;
  }
  function findTexture(item2, queue) {
    if (item2._texture && item2._texture instanceof Texture) {
      const texture = item2._texture.baseTexture;
      if (!queue.includes(texture)) {
        queue.push(texture);
      }
      return true;
    }
    return false;
  }
  function drawText(_helper, item2) {
    if (item2 instanceof Text$1) {
      item2.updateText(true);
      return true;
    }
    return false;
  }
  function calculateTextStyle(_helper, item2) {
    if (item2 instanceof TextStyle) {
      const font = item2.toFontString();
      TextMetrics.measureFont(font);
      return true;
    }
    return false;
  }
  function findText(item2, queue) {
    if (item2 instanceof Text$1) {
      if (!queue.includes(item2.style)) {
        queue.push(item2.style);
      }
      if (!queue.includes(item2)) {
        queue.push(item2);
      }
      const texture = item2._texture.baseTexture;
      if (!queue.includes(texture)) {
        queue.push(texture);
      }
      return true;
    }
    return false;
  }
  function findTextStyle(item2, queue) {
    if (item2 instanceof TextStyle) {
      if (!queue.includes(item2)) {
        queue.push(item2);
      }
      return true;
    }
    return false;
  }
  var BasePrepare = class {
    constructor(renderer) {
      this.limiter = new CountLimiter(settings.UPLOADS_PER_FRAME);
      this.renderer = renderer;
      this.uploadHookHelper = null;
      this.queue = [];
      this.addHooks = [];
      this.uploadHooks = [];
      this.completes = [];
      this.ticking = false;
      this.delayedTick = () => {
        if (!this.queue) {
          return;
        }
        this.prepareItems();
      };
      this.registerFindHook(findText);
      this.registerFindHook(findTextStyle);
      this.registerFindHook(findMultipleBaseTextures);
      this.registerFindHook(findBaseTexture);
      this.registerFindHook(findTexture);
      this.registerUploadHook(drawText);
      this.registerUploadHook(calculateTextStyle);
    }
    upload(item2) {
      return new Promise((resolve2) => {
        if (item2) {
          this.add(item2);
        }
        if (this.queue.length) {
          this.completes.push(resolve2);
          if (!this.ticking) {
            this.ticking = true;
            Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);
          }
        } else {
          resolve2();
        }
      });
    }
    tick() {
      setTimeout(this.delayedTick, 0);
    }
    prepareItems() {
      this.limiter.beginFrame();
      while (this.queue.length && this.limiter.allowedToUpload()) {
        const item2 = this.queue[0];
        let uploaded = false;
        if (item2 && !item2._destroyed) {
          for (let i = 0, len = this.uploadHooks.length; i < len; i++) {
            if (this.uploadHooks[i](this.uploadHookHelper, item2)) {
              this.queue.shift();
              uploaded = true;
              break;
            }
          }
        }
        if (!uploaded) {
          this.queue.shift();
        }
      }
      if (!this.queue.length) {
        this.ticking = false;
        const completes = this.completes.slice(0);
        this.completes.length = 0;
        for (let i = 0, len = completes.length; i < len; i++) {
          completes[i]();
        }
      } else {
        Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);
      }
    }
    registerFindHook(addHook) {
      if (addHook) {
        this.addHooks.push(addHook);
      }
      return this;
    }
    registerUploadHook(uploadHook) {
      if (uploadHook) {
        this.uploadHooks.push(uploadHook);
      }
      return this;
    }
    add(item2) {
      for (let i = 0, len = this.addHooks.length; i < len; i++) {
        if (this.addHooks[i](item2, this.queue)) {
          break;
        }
      }
      if (item2 instanceof Container) {
        for (let i = item2.children.length - 1; i >= 0; i--) {
          this.add(item2.children[i]);
        }
      }
      return this;
    }
    destroy() {
      if (this.ticking) {
        Ticker.system.remove(this.tick, this);
      }
      this.ticking = false;
      this.addHooks = null;
      this.uploadHooks = null;
      this.renderer = null;
      this.completes = null;
      this.queue = null;
      this.limiter = null;
      this.uploadHookHelper = null;
    }
  };
  function uploadBaseTextures(renderer, item2) {
    if (item2 instanceof BaseTexture) {
      if (!item2._glTextures[renderer.CONTEXT_UID]) {
        renderer.texture.bind(item2);
      }
      return true;
    }
    return false;
  }
  function uploadGraphics(renderer, item2) {
    if (!(item2 instanceof Graphics)) {
      return false;
    }
    const { geometry } = item2;
    item2.finishPoly();
    geometry.updateBatches();
    const { batches } = geometry;
    for (let i = 0; i < batches.length; i++) {
      const { texture } = batches[i].style;
      if (texture) {
        uploadBaseTextures(renderer, texture.baseTexture);
      }
    }
    if (!geometry.batchable) {
      renderer.geometry.bind(geometry, item2._resolveDirectShader(renderer));
    }
    return true;
  }
  function findGraphics(item2, queue) {
    if (item2 instanceof Graphics) {
      queue.push(item2);
      return true;
    }
    return false;
  }
  var Prepare = class extends BasePrepare {
    constructor(renderer) {
      super(renderer);
      this.uploadHookHelper = this.renderer;
      this.registerFindHook(findGraphics);
      this.registerUploadHook(uploadBaseTextures);
      this.registerUploadHook(uploadGraphics);
    }
  };
  Prepare.extension = {
    name: "prepare",
    type: ExtensionType.RendererSystem
  };
  extensions$1.add(Prepare);
  var TimeLimiter = class {
    constructor(maxMilliseconds) {
      this.maxMilliseconds = maxMilliseconds;
      this.frameStart = 0;
    }
    beginFrame() {
      this.frameStart = Date.now();
    }
    allowedToUpload() {
      return Date.now() - this.frameStart < this.maxMilliseconds;
    }
  };
  var _Spritesheet = class {
    constructor(texture, data, resolutionFilename = null) {
      this.linkedSheets = [];
      this._texture = texture instanceof Texture ? texture : null;
      this.baseTexture = texture instanceof BaseTexture ? texture : this._texture.baseTexture;
      this.textures = {};
      this.animations = {};
      this.data = data;
      const resource = this.baseTexture.resource;
      this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null));
      this._frames = this.data.frames;
      this._frameKeys = Object.keys(this._frames);
      this._batchIndex = 0;
      this._callback = null;
    }
    _updateResolution(resolutionFilename = null) {
      const { scale } = this.data.meta;
      let resolution = getResolutionOfUrl(resolutionFilename, null);
      if (resolution === null) {
        resolution = parseFloat(scale ?? "1");
      }
      if (resolution !== 1) {
        this.baseTexture.setResolution(resolution);
      }
      return resolution;
    }
    parse() {
      return new Promise((resolve2) => {
        this._callback = resolve2;
        this._batchIndex = 0;
        if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {
          this._processFrames(0);
          this._processAnimations();
          this._parseComplete();
        } else {
          this._nextBatch();
        }
      });
    }
    _processFrames(initialFrameIndex) {
      let frameIndex = initialFrameIndex;
      const maxFrames = _Spritesheet.BATCH_SIZE;
      while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
        const i = this._frameKeys[frameIndex];
        const data = this._frames[i];
        const rect = data.frame;
        if (rect) {
          let frame = null;
          let trim = null;
          const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
          const orig = new Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);
          if (data.rotated) {
            frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);
          } else {
            frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
          }
          if (data.trimmed !== false && data.spriteSourceSize) {
            trim = new Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
          }
          this.textures[i] = new Texture(this.baseTexture, frame, orig, trim, data.rotated ? 2 : 0, data.anchor);
          Texture.addToCache(this.textures[i], i);
        }
        frameIndex++;
      }
    }
    _processAnimations() {
      const animations = this.data.animations || {};
      for (const animName in animations) {
        this.animations[animName] = [];
        for (let i = 0; i < animations[animName].length; i++) {
          const frameName = animations[animName][i];
          this.animations[animName].push(this.textures[frameName]);
        }
      }
    }
    _parseComplete() {
      const callback = this._callback;
      this._callback = null;
      this._batchIndex = 0;
      callback.call(this, this.textures);
    }
    _nextBatch() {
      this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);
      this._batchIndex++;
      setTimeout(() => {
        if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {
          this._nextBatch();
        } else {
          this._processAnimations();
          this._parseComplete();
        }
      }, 0);
    }
    destroy(destroyBase = false) {
      for (const i in this.textures) {
        this.textures[i].destroy();
      }
      this._frames = null;
      this._frameKeys = null;
      this.data = null;
      this.textures = null;
      if (destroyBase) {
        this._texture?.destroy();
        this.baseTexture.destroy();
      }
      this._texture = null;
      this.baseTexture = null;
      this.linkedSheets = [];
    }
  };
  var Spritesheet = _Spritesheet;
  Spritesheet.BATCH_SIZE = 1e3;
  var validImages = ["jpg", "png", "jpeg", "avif", "webp"];
  function getCacheableAssets(keys, asset, ignoreMultiPack) {
    const out = {};
    keys.forEach((key) => {
      out[key] = asset;
    });
    Object.keys(asset.textures).forEach((key) => {
      out[key] = asset.textures[key];
    });
    if (!ignoreMultiPack) {
      const basePath = path.dirname(keys[0]);
      asset.linkedSheets.forEach((item2, i) => {
        const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item2, true);
        Object.assign(out, out2);
      });
    }
    return out;
  }
  var spritesheetAsset = {
    extension: ExtensionType.Asset,
    cache: {
      test: (asset) => asset instanceof Spritesheet,
      getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)
    },
    resolver: {
      test: (value3) => {
        const tempURL = value3.split("?")[0];
        const split2 = tempURL.split(".");
        const extension = split2.pop();
        const format2 = split2.pop();
        return extension === "json" && validImages.includes(format2);
      },
      parse: (value3) => {
        const split2 = value3.split(".");
        return {
          resolution: parseFloat(settings.RETINA_PREFIX.exec(value3)?.[1] ?? "1"),
          format: split2[split2.length - 2],
          src: value3
        };
      }
    },
    loader: {
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.Normal
      },
      async testParse(asset, options) {
        return path.extname(options.src).includes(".json") && !!asset.frames;
      },
      async parse(asset, options, loader) {
        let basePath = path.dirname(options.src);
        if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
          basePath += "/";
        }
        const imagePath = basePath + asset.meta.image;
        const assets = await loader.load([imagePath]);
        const texture = assets[imagePath];
        const spritesheet = new Spritesheet(texture.baseTexture, asset, options.src);
        await spritesheet.parse();
        const multiPacks = asset?.meta?.related_multi_packs;
        if (Array.isArray(multiPacks)) {
          const promises = [];
          for (const item2 of multiPacks) {
            if (typeof item2 !== "string") {
              continue;
            }
            const itemUrl = basePath + item2;
            if (options.data?.ignoreMultiPack) {
              continue;
            }
            promises.push(loader.load({
              src: itemUrl,
              data: {
                ignoreMultiPack: true
              }
            }));
          }
          const res = await Promise.all(promises);
          spritesheet.linkedSheets = res;
          res.forEach((item2) => {
            item2.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item2));
          });
        }
        return spritesheet;
      },
      unload(spritesheet) {
        spritesheet.destroy(true);
      }
    }
  };
  extensions$1.add(spritesheetAsset);
  var AnimatedSprite = class extends Sprite {
    constructor(textures, autoUpdate = true) {
      super(textures[0] instanceof Texture ? textures[0] : textures[0].texture);
      this._textures = null;
      this._durations = null;
      this._autoUpdate = autoUpdate;
      this._isConnectedToTicker = false;
      this.animationSpeed = 1;
      this.loop = true;
      this.updateAnchor = false;
      this.onComplete = null;
      this.onFrameChange = null;
      this.onLoop = null;
      this._currentTime = 0;
      this._playing = false;
      this._previousFrame = null;
      this.textures = textures;
    }
    stop() {
      if (!this._playing) {
        return;
      }
      this._playing = false;
      if (this._autoUpdate && this._isConnectedToTicker) {
        Ticker.shared.remove(this.update, this);
        this._isConnectedToTicker = false;
      }
    }
    play() {
      if (this._playing) {
        return;
      }
      this._playing = true;
      if (this._autoUpdate && !this._isConnectedToTicker) {
        Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);
        this._isConnectedToTicker = true;
      }
    }
    gotoAndStop(frameNumber) {
      this.stop();
      this.currentFrame = frameNumber;
    }
    gotoAndPlay(frameNumber) {
      this.currentFrame = frameNumber;
      this.play();
    }
    update(deltaTime) {
      if (!this._playing) {
        return;
      }
      const elapsed = this.animationSpeed * deltaTime;
      const previousFrame = this.currentFrame;
      if (this._durations !== null) {
        let lag = this._currentTime % 1 * this._durations[this.currentFrame];
        lag += elapsed / 60 * 1e3;
        while (lag < 0) {
          this._currentTime--;
          lag += this._durations[this.currentFrame];
        }
        const sign3 = Math.sign(this.animationSpeed * deltaTime);
        this._currentTime = Math.floor(this._currentTime);
        while (lag >= this._durations[this.currentFrame]) {
          lag -= this._durations[this.currentFrame] * sign3;
          this._currentTime += sign3;
        }
        this._currentTime += lag / this._durations[this.currentFrame];
      } else {
        this._currentTime += elapsed;
      }
      if (this._currentTime < 0 && !this.loop) {
        this.gotoAndStop(0);
        if (this.onComplete) {
          this.onComplete();
        }
      } else if (this._currentTime >= this._textures.length && !this.loop) {
        this.gotoAndStop(this._textures.length - 1);
        if (this.onComplete) {
          this.onComplete();
        }
      } else if (previousFrame !== this.currentFrame) {
        if (this.loop && this.onLoop) {
          if (this.animationSpeed > 0 && this.currentFrame < previousFrame) {
            this.onLoop();
          } else if (this.animationSpeed < 0 && this.currentFrame > previousFrame) {
            this.onLoop();
          }
        }
        this.updateTexture();
      }
    }
    updateTexture() {
      const currentFrame = this.currentFrame;
      if (this._previousFrame === currentFrame) {
        return;
      }
      this._previousFrame = currentFrame;
      this._texture = this._textures[currentFrame];
      this._textureID = -1;
      this._textureTrimmedID = -1;
      this._cachedTint = 16777215;
      this.uvs = this._texture._uvs.uvsFloat32;
      if (this.updateAnchor) {
        this._anchor.copyFrom(this._texture.defaultAnchor);
      }
      if (this.onFrameChange) {
        this.onFrameChange(this.currentFrame);
      }
    }
    destroy(options) {
      this.stop();
      super.destroy(options);
      this.onComplete = null;
      this.onFrameChange = null;
      this.onLoop = null;
    }
    static fromFrames(frames) {
      const textures = [];
      for (let i = 0; i < frames.length; ++i) {
        textures.push(Texture.from(frames[i]));
      }
      return new AnimatedSprite(textures);
    }
    static fromImages(images) {
      const textures = [];
      for (let i = 0; i < images.length; ++i) {
        textures.push(Texture.from(images[i]));
      }
      return new AnimatedSprite(textures);
    }
    get totalFrames() {
      return this._textures.length;
    }
    get textures() {
      return this._textures;
    }
    set textures(value3) {
      if (value3[0] instanceof Texture) {
        this._textures = value3;
        this._durations = null;
      } else {
        this._textures = [];
        this._durations = [];
        for (let i = 0; i < value3.length; i++) {
          this._textures.push(value3[i].texture);
          this._durations.push(value3[i].time);
        }
      }
      this._previousFrame = null;
      this.gotoAndStop(0);
      this.updateTexture();
    }
    get currentFrame() {
      let currentFrame = Math.floor(this._currentTime) % this._textures.length;
      if (currentFrame < 0) {
        currentFrame += this._textures.length;
      }
      return currentFrame;
    }
    set currentFrame(value3) {
      if (value3 < 0 || value3 > this.totalFrames - 1) {
        throw new Error(`[AnimatedSprite]: Invalid frame index value ${value3}, expected to be between 0 and totalFrames ${this.totalFrames}.`);
      }
      const previousFrame = this.currentFrame;
      this._currentTime = value3;
      if (previousFrame !== this.currentFrame) {
        this.updateTexture();
      }
    }
    get playing() {
      return this._playing;
    }
    get autoUpdate() {
      return this._autoUpdate;
    }
    set autoUpdate(value3) {
      if (value3 !== this._autoUpdate) {
        this._autoUpdate = value3;
        if (!this._autoUpdate && this._isConnectedToTicker) {
          Ticker.shared.remove(this.update, this);
          this._isConnectedToTicker = false;
        } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {
          Ticker.shared.add(this.update, this);
          this._isConnectedToTicker = true;
        }
      }
    }
  };
  var tempPoint = new Point();
  var TilingSprite = class extends Sprite {
    constructor(texture, width = 100, height = 100) {
      super(texture);
      this.tileTransform = new Transform();
      this._width = width;
      this._height = height;
      this.uvMatrix = this.texture.uvMatrix || new TextureMatrix(texture);
      this.pluginName = "tilingSprite";
      this.uvRespectAnchor = false;
    }
    get clampMargin() {
      return this.uvMatrix.clampMargin;
    }
    set clampMargin(value3) {
      this.uvMatrix.clampMargin = value3;
      this.uvMatrix.update(true);
    }
    get tileScale() {
      return this.tileTransform.scale;
    }
    set tileScale(value3) {
      this.tileTransform.scale.copyFrom(value3);
    }
    get tilePosition() {
      return this.tileTransform.position;
    }
    set tilePosition(value3) {
      this.tileTransform.position.copyFrom(value3);
    }
    _onTextureUpdate() {
      if (this.uvMatrix) {
        this.uvMatrix.texture = this._texture;
      }
      this._cachedTint = 16777215;
    }
    _render(renderer) {
      const texture = this._texture;
      if (!texture || !texture.valid) {
        return;
      }
      this.tileTransform.updateLocalTransform();
      this.uvMatrix.update();
      renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
      renderer.plugins[this.pluginName].render(this);
    }
    _calculateBounds() {
      const minX = this._width * -this._anchor._x;
      const minY = this._height * -this._anchor._y;
      const maxX = this._width * (1 - this._anchor._x);
      const maxY = this._height * (1 - this._anchor._y);
      this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
    }
    getLocalBounds(rect) {
      if (this.children.length === 0) {
        this._bounds.minX = this._width * -this._anchor._x;
        this._bounds.minY = this._height * -this._anchor._y;
        this._bounds.maxX = this._width * (1 - this._anchor._x);
        this._bounds.maxY = this._height * (1 - this._anchor._y);
        if (!rect) {
          if (!this._localBoundsRect) {
            this._localBoundsRect = new Rectangle();
          }
          rect = this._localBoundsRect;
        }
        return this._bounds.getRectangle(rect);
      }
      return super.getLocalBounds.call(this, rect);
    }
    containsPoint(point) {
      this.worldTransform.applyInverse(point, tempPoint);
      const width = this._width;
      const height = this._height;
      const x1 = -width * this.anchor._x;
      if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {
        const y1 = -height * this.anchor._y;
        if (tempPoint.y >= y1 && tempPoint.y < y1 + height) {
          return true;
        }
      }
      return false;
    }
    destroy(options) {
      super.destroy(options);
      this.tileTransform = null;
      this.uvMatrix = null;
    }
    static from(source, options) {
      const texture = source instanceof Texture ? source : Texture.from(source, options);
      return new TilingSprite(texture, options.width, options.height);
    }
    get width() {
      return this._width;
    }
    set width(value3) {
      this._width = value3;
    }
    get height() {
      return this._height;
    }
    set height(value3) {
      this._height = value3;
    }
  };
  var fragmentSimpleSrc = "#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n";
  var gl1VertexSrc = "#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";
  var gl1FragmentSrc = "#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n";
  var gl2VertexSrc = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";
  var gl2FragmentSrc = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n";
  var tempMat = new Matrix();
  var TilingSpriteRenderer = class extends ObjectRenderer {
    constructor(renderer) {
      super(renderer);
      renderer.runners.contextChange.add(this);
      this.quad = new QuadUv();
      this.state = State.for2d();
    }
    contextChange() {
      const renderer = this.renderer;
      const uniforms = { globals: renderer.globalUniforms };
      this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, uniforms);
      this.shader = renderer.context.webGLVersion > 1 ? Shader.from(gl2VertexSrc, gl2FragmentSrc, uniforms) : Shader.from(gl1VertexSrc, gl1FragmentSrc, uniforms);
    }
    render(ts) {
      const renderer = this.renderer;
      const quad = this.quad;
      let vertices = quad.vertices;
      vertices[0] = vertices[6] = ts._width * -ts.anchor.x;
      vertices[1] = vertices[3] = ts._height * -ts.anchor.y;
      vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x);
      vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y);
      const anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0;
      const anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;
      vertices = quad.uvs;
      vertices[0] = vertices[6] = -anchorX;
      vertices[1] = vertices[3] = -anchorY;
      vertices[2] = vertices[4] = 1 - anchorX;
      vertices[5] = vertices[7] = 1 - anchorY;
      quad.invalidate();
      const tex = ts._texture;
      const baseTex = tex.baseTexture;
      const premultiplied = baseTex.alphaMode > 0;
      const lt = ts.tileTransform.localTransform;
      const uv = ts.uvMatrix;
      let isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;
      if (isSimple) {
        if (!baseTex._glTextures[renderer.CONTEXT_UID]) {
          if (baseTex.wrapMode === WRAP_MODES.CLAMP) {
            baseTex.wrapMode = WRAP_MODES.REPEAT;
          }
        } else {
          isSimple = baseTex.wrapMode !== WRAP_MODES.CLAMP;
        }
      }
      const shader = isSimple ? this.simpleShader : this.shader;
      const w = tex.width;
      const h = tex.height;
      const W = ts._width;
      const H = ts._height;
      tempMat.set(lt.a * w / W, lt.b * w / H, lt.c * h / W, lt.d * h / H, lt.tx / W, lt.ty / H);
      tempMat.invert();
      if (isSimple) {
        tempMat.prepend(uv.mapCoord);
      } else {
        shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);
        shader.uniforms.uClampFrame = uv.uClampFrame;
        shader.uniforms.uClampOffset = uv.uClampOffset;
      }
      shader.uniforms.uTransform = tempMat.toArray(true);
      shader.uniforms.uColor = premultiplyTintToRgba(ts.tint, ts.worldAlpha, shader.uniforms.uColor, premultiplied);
      shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);
      shader.uniforms.uSampler = tex;
      renderer.shader.bind(shader);
      renderer.geometry.bind(quad);
      this.state.blendMode = correctBlendMode(ts.blendMode, premultiplied);
      renderer.state.set(this.state);
      renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
    }
  };
  TilingSpriteRenderer.extension = {
    name: "tilingSprite",
    type: ExtensionType.RendererPlugin
  };
  extensions$1.add(TilingSpriteRenderer);
  var BitmapFontData = class {
    constructor() {
      this.info = [];
      this.common = [];
      this.page = [];
      this.char = [];
      this.kerning = [];
      this.distanceField = [];
    }
  };
  var TextFormat = class {
    static test(data) {
      return typeof data === "string" && data.startsWith("info face=");
    }
    static parse(txt) {
      const items = txt.match(/^[a-z]+\s+.+$/gm);
      const rawData = {
        info: [],
        common: [],
        page: [],
        char: [],
        chars: [],
        kerning: [],
        kernings: [],
        distanceField: []
      };
      for (const i in items) {
        const name = items[i].match(/^[a-z]+/gm)[0];
        const attributeList = items[i].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
        const itemData = {};
        for (const i2 in attributeList) {
          const split2 = attributeList[i2].split("=");
          const key = split2[0];
          const strValue = split2[1].replace(/"/gm, "");
          const floatValue = parseFloat(strValue);
          const value3 = isNaN(floatValue) ? strValue : floatValue;
          itemData[key] = value3;
        }
        rawData[name].push(itemData);
      }
      const font = new BitmapFontData();
      rawData.info.forEach((info) => font.info.push({
        face: info.face,
        size: parseInt(info.size, 10)
      }));
      rawData.common.forEach((common) => font.common.push({
        lineHeight: parseInt(common.lineHeight, 10)
      }));
      rawData.page.forEach((page) => font.page.push({
        id: parseInt(page.id, 10),
        file: page.file
      }));
      rawData.char.forEach((char) => font.char.push({
        id: parseInt(char.id, 10),
        page: parseInt(char.page, 10),
        x: parseInt(char.x, 10),
        y: parseInt(char.y, 10),
        width: parseInt(char.width, 10),
        height: parseInt(char.height, 10),
        xoffset: parseInt(char.xoffset, 10),
        yoffset: parseInt(char.yoffset, 10),
        xadvance: parseInt(char.xadvance, 10)
      }));
      rawData.kerning.forEach((kerning) => font.kerning.push({
        first: parseInt(kerning.first, 10),
        second: parseInt(kerning.second, 10),
        amount: parseInt(kerning.amount, 10)
      }));
      rawData.distanceField.forEach((df) => font.distanceField.push({
        distanceRange: parseInt(df.distanceRange, 10),
        fieldType: df.fieldType
      }));
      return font;
    }
  };
  var XMLFormat = class {
    static test(data) {
      const xml = data;
      return "getElementsByTagName" in xml && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;
    }
    static parse(xml) {
      const data = new BitmapFontData();
      const info = xml.getElementsByTagName("info");
      const common = xml.getElementsByTagName("common");
      const page = xml.getElementsByTagName("page");
      const char = xml.getElementsByTagName("char");
      const kerning = xml.getElementsByTagName("kerning");
      const distanceField = xml.getElementsByTagName("distanceField");
      for (let i = 0; i < info.length; i++) {
        data.info.push({
          face: info[i].getAttribute("face"),
          size: parseInt(info[i].getAttribute("size"), 10)
        });
      }
      for (let i = 0; i < common.length; i++) {
        data.common.push({
          lineHeight: parseInt(common[i].getAttribute("lineHeight"), 10)
        });
      }
      for (let i = 0; i < page.length; i++) {
        data.page.push({
          id: parseInt(page[i].getAttribute("id"), 10) || 0,
          file: page[i].getAttribute("file")
        });
      }
      for (let i = 0; i < char.length; i++) {
        const letter = char[i];
        data.char.push({
          id: parseInt(letter.getAttribute("id"), 10),
          page: parseInt(letter.getAttribute("page"), 10) || 0,
          x: parseInt(letter.getAttribute("x"), 10),
          y: parseInt(letter.getAttribute("y"), 10),
          width: parseInt(letter.getAttribute("width"), 10),
          height: parseInt(letter.getAttribute("height"), 10),
          xoffset: parseInt(letter.getAttribute("xoffset"), 10),
          yoffset: parseInt(letter.getAttribute("yoffset"), 10),
          xadvance: parseInt(letter.getAttribute("xadvance"), 10)
        });
      }
      for (let i = 0; i < kerning.length; i++) {
        data.kerning.push({
          first: parseInt(kerning[i].getAttribute("first"), 10),
          second: parseInt(kerning[i].getAttribute("second"), 10),
          amount: parseInt(kerning[i].getAttribute("amount"), 10)
        });
      }
      for (let i = 0; i < distanceField.length; i++) {
        data.distanceField.push({
          fieldType: distanceField[i].getAttribute("fieldType"),
          distanceRange: parseInt(distanceField[i].getAttribute("distanceRange"), 10)
        });
      }
      return data;
    }
  };
  var XMLStringFormat = class {
    static test(data) {
      if (typeof data === "string" && data.includes("<font>")) {
        return XMLFormat.test(settings.ADAPTER.parseXML(data));
      }
      return false;
    }
    static parse(xmlTxt) {
      return XMLFormat.parse(settings.ADAPTER.parseXML(xmlTxt));
    }
  };
  var formats = [
    TextFormat,
    XMLFormat,
    XMLStringFormat
  ];
  function autoDetectFormat(data) {
    for (let i = 0; i < formats.length; i++) {
      if (formats[i].test(data)) {
        return formats[i];
      }
    }
    return null;
  }
  function generateFillStyle(canvas, context2, style, resolution, lines, metrics) {
    const fillStyle = style.fill;
    if (!Array.isArray(fillStyle)) {
      return fillStyle;
    } else if (fillStyle.length === 1) {
      return fillStyle[0];
    }
    let gradient;
    const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
    const padding = style.padding || 0;
    const width = canvas.width / resolution - dropShadowCorrection - padding * 2;
    const height = canvas.height / resolution - dropShadowCorrection - padding * 2;
    const fill = fillStyle.slice();
    const fillGradientStops = style.fillGradientStops.slice();
    if (!fillGradientStops.length) {
      const lengthPlus1 = fill.length + 1;
      for (let i = 1; i < lengthPlus1; ++i) {
        fillGradientStops.push(i / lengthPlus1);
      }
    }
    fill.unshift(fillStyle[0]);
    fillGradientStops.unshift(0);
    fill.push(fillStyle[fillStyle.length - 1]);
    fillGradientStops.push(1);
    if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
      gradient = context2.createLinearGradient(width / 2, padding, width / 2, height + padding);
      let lastIterationStop = 0;
      const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
      const gradStopLineHeight = textHeight / height;
      for (let i = 0; i < lines.length; i++) {
        const thisLineTop = metrics.lineHeight * i;
        for (let j = 0; j < fill.length; j++) {
          let lineStop = 0;
          if (typeof fillGradientStops[j] === "number") {
            lineStop = fillGradientStops[j];
          } else {
            lineStop = j / fill.length;
          }
          const globalStop = thisLineTop / height + lineStop * gradStopLineHeight;
          let clampedStop = Math.max(lastIterationStop, globalStop);
          clampedStop = Math.min(clampedStop, 1);
          gradient.addColorStop(clampedStop, fill[j]);
          lastIterationStop = clampedStop;
        }
      }
    } else {
      gradient = context2.createLinearGradient(padding, height / 2, width + padding, height / 2);
      const totalIterations = fill.length + 1;
      let currentIteration = 1;
      for (let i = 0; i < fill.length; i++) {
        let stop;
        if (typeof fillGradientStops[i] === "number") {
          stop = fillGradientStops[i];
        } else {
          stop = currentIteration / totalIterations;
        }
        gradient.addColorStop(stop, fill[i]);
        currentIteration++;
      }
    }
    return gradient;
  }
  function drawGlyph(canvas, context2, metrics, x, y, resolution, style) {
    const char = metrics.text;
    const fontProperties = metrics.fontProperties;
    context2.translate(x, y);
    context2.scale(resolution, resolution);
    const tx = style.strokeThickness / 2;
    const ty = -(style.strokeThickness / 2);
    context2.font = style.toFontString();
    context2.lineWidth = style.strokeThickness;
    context2.textBaseline = style.textBaseline;
    context2.lineJoin = style.lineJoin;
    context2.miterLimit = style.miterLimit;
    context2.fillStyle = generateFillStyle(canvas, context2, style, resolution, [char], metrics);
    context2.strokeStyle = style.stroke;
    if (style.dropShadow) {
      const dropShadowColor = style.dropShadowColor;
      const rgb = hex2rgb(typeof dropShadowColor === "number" ? dropShadowColor : string2hex(dropShadowColor));
      const dropShadowBlur = style.dropShadowBlur * resolution;
      const dropShadowDistance = style.dropShadowDistance * resolution;
      context2.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${style.dropShadowAlpha})`;
      context2.shadowBlur = dropShadowBlur;
      context2.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
      context2.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance;
    } else {
      context2.shadowColor = "black";
      context2.shadowBlur = 0;
      context2.shadowOffsetX = 0;
      context2.shadowOffsetY = 0;
    }
    if (style.stroke && style.strokeThickness) {
      context2.strokeText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
    }
    if (style.fill) {
      context2.fillText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
    }
    context2.setTransform(1, 0, 0, 1, 0, 0);
    context2.fillStyle = "rgba(0, 0, 0, 0)";
  }
  function splitTextToCharacters(text) {
    return Array.from ? Array.from(text) : text.split("");
  }
  function resolveCharacters(chars) {
    if (typeof chars === "string") {
      chars = [chars];
    }
    const result2 = [];
    for (let i = 0, j = chars.length; i < j; i++) {
      const item2 = chars[i];
      if (Array.isArray(item2)) {
        if (item2.length !== 2) {
          throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item2.length}.`);
        }
        const startCode = item2[0].charCodeAt(0);
        const endCode = item2[1].charCodeAt(0);
        if (endCode < startCode) {
          throw new Error("[BitmapFont]: Invalid character range.");
        }
        for (let i2 = startCode, j2 = endCode; i2 <= j2; i2++) {
          result2.push(String.fromCharCode(i2));
        }
      } else {
        result2.push(...splitTextToCharacters(item2));
      }
    }
    if (result2.length === 0) {
      throw new Error("[BitmapFont]: Empty set when resolving characters.");
    }
    return result2;
  }
  function extractCharCode(str) {
    return str.codePointAt ? str.codePointAt(0) : str.charCodeAt(0);
  }
  var _BitmapFont = class {
    constructor(data, textures, ownsTextures) {
      const [info] = data.info;
      const [common] = data.common;
      const [page] = data.page;
      const [distanceField] = data.distanceField;
      const res = getResolutionOfUrl(page.file);
      const pageTextures = {};
      this._ownsTextures = ownsTextures;
      this.font = info.face;
      this.size = info.size;
      this.lineHeight = common.lineHeight / res;
      this.chars = {};
      this.pageTextures = pageTextures;
      for (let i = 0; i < data.page.length; i++) {
        const { id, file } = data.page[i];
        pageTextures[id] = textures instanceof Array ? textures[i] : textures[file];
        if (distanceField?.fieldType && distanceField.fieldType !== "none") {
          pageTextures[id].baseTexture.alphaMode = ALPHA_MODES.NO_PREMULTIPLIED_ALPHA;
          pageTextures[id].baseTexture.mipmap = MIPMAP_MODES.OFF;
        }
      }
      for (let i = 0; i < data.char.length; i++) {
        const { id, page: page2 } = data.char[i];
        let { x, y, width, height, xoffset, yoffset, xadvance } = data.char[i];
        x /= res;
        y /= res;
        width /= res;
        height /= res;
        xoffset /= res;
        yoffset /= res;
        xadvance /= res;
        const rect = new Rectangle(x + pageTextures[page2].frame.x / res, y + pageTextures[page2].frame.y / res, width, height);
        this.chars[id] = {
          xOffset: xoffset,
          yOffset: yoffset,
          xAdvance: xadvance,
          kerning: {},
          texture: new Texture(pageTextures[page2].baseTexture, rect),
          page: page2
        };
      }
      for (let i = 0; i < data.kerning.length; i++) {
        let { first, second, amount } = data.kerning[i];
        first /= res;
        second /= res;
        amount /= res;
        if (this.chars[second]) {
          this.chars[second].kerning[first] = amount;
        }
      }
      this.distanceFieldRange = distanceField?.distanceRange;
      this.distanceFieldType = distanceField?.fieldType?.toLowerCase() ?? "none";
    }
    destroy() {
      for (const id in this.chars) {
        this.chars[id].texture.destroy();
        this.chars[id].texture = null;
      }
      for (const id in this.pageTextures) {
        if (this._ownsTextures) {
          this.pageTextures[id].destroy(true);
        }
        this.pageTextures[id] = null;
      }
      this.chars = null;
      this.pageTextures = null;
    }
    static install(data, textures, ownsTextures) {
      let fontData;
      if (data instanceof BitmapFontData) {
        fontData = data;
      } else {
        const format2 = autoDetectFormat(data);
        if (!format2) {
          throw new Error("Unrecognized data format for font.");
        }
        fontData = format2.parse(data);
      }
      if (textures instanceof Texture) {
        textures = [textures];
      }
      const font = new _BitmapFont(fontData, textures, ownsTextures);
      _BitmapFont.available[font.font] = font;
      return font;
    }
    static uninstall(name) {
      const font = _BitmapFont.available[name];
      if (!font) {
        throw new Error(`No font found named '${name}'`);
      }
      font.destroy();
      delete _BitmapFont.available[name];
    }
    static from(name, textStyle, options) {
      if (!name) {
        throw new Error("[BitmapFont] Property `name` is required.");
      }
      const {
        chars,
        padding,
        resolution,
        textureWidth,
        textureHeight,
        ...baseOptions
      } = Object.assign({}, _BitmapFont.defaultOptions, options);
      const charsList = resolveCharacters(chars);
      const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);
      const lineWidth = textureWidth;
      const fontData = new BitmapFontData();
      fontData.info[0] = {
        face: style.fontFamily,
        size: style.fontSize
      };
      fontData.common[0] = {
        lineHeight: style.fontSize
      };
      let positionX = 0;
      let positionY = 0;
      let canvas;
      let context2;
      let baseTexture;
      let maxCharHeight = 0;
      const baseTextures = [];
      const textures = [];
      for (let i = 0; i < charsList.length; i++) {
        if (!canvas) {
          canvas = settings.ADAPTER.createCanvas();
          canvas.width = textureWidth;
          canvas.height = textureHeight;
          context2 = canvas.getContext("2d");
          baseTexture = new BaseTexture(canvas, { resolution, ...baseOptions });
          baseTextures.push(baseTexture);
          textures.push(new Texture(baseTexture));
          fontData.page.push({
            id: textures.length - 1,
            file: ""
          });
        }
        const character2 = charsList[i];
        const metrics = TextMetrics.measureText(character2, style, false, canvas);
        const width = metrics.width;
        const height = Math.ceil(metrics.height);
        const textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width);
        if (positionY >= textureHeight - height * resolution) {
          if (positionY === 0) {
            throw new Error(`[BitmapFont] textureHeight ${textureHeight}px is too small (fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character2}')`);
          }
          --i;
          canvas = null;
          context2 = null;
          baseTexture = null;
          positionY = 0;
          positionX = 0;
          maxCharHeight = 0;
          continue;
        }
        maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight);
        if (textureGlyphWidth * resolution + positionX >= lineWidth) {
          if (positionX === 0) {
            throw new Error(`[BitmapFont] textureWidth ${textureWidth}px is too small (fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character2}')`);
          }
          --i;
          positionY += maxCharHeight * resolution;
          positionY = Math.ceil(positionY);
          positionX = 0;
          maxCharHeight = 0;
          continue;
        }
        drawGlyph(canvas, context2, metrics, positionX, positionY, resolution, style);
        const id = extractCharCode(metrics.text);
        fontData.char.push({
          id,
          page: textures.length - 1,
          x: positionX / resolution,
          y: positionY / resolution,
          width: textureGlyphWidth,
          height,
          xoffset: 0,
          yoffset: 0,
          xadvance: Math.ceil(width - (style.dropShadow ? style.dropShadowDistance : 0) - (style.stroke ? style.strokeThickness : 0))
        });
        positionX += (textureGlyphWidth + 2 * padding) * resolution;
        positionX = Math.ceil(positionX);
      }
      for (let i = 0, len = charsList.length; i < len; i++) {
        const first = charsList[i];
        for (let j = 0; j < len; j++) {
          const second = charsList[j];
          const c1 = context2.measureText(first).width;
          const c2 = context2.measureText(second).width;
          const total = context2.measureText(first + second).width;
          const amount = total - (c1 + c2);
          if (amount) {
            fontData.kerning.push({
              first: extractCharCode(first),
              second: extractCharCode(second),
              amount
            });
          }
        }
      }
      const font = new _BitmapFont(fontData, textures, true);
      if (_BitmapFont.available[name] !== void 0) {
        _BitmapFont.uninstall(name);
      }
      _BitmapFont.available[name] = font;
      return font;
    }
  };
  var BitmapFont = _BitmapFont;
  BitmapFont.ALPHA = [["a", "z"], ["A", "Z"], " "];
  BitmapFont.NUMERIC = [["0", "9"]];
  BitmapFont.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
  BitmapFont.ASCII = [[" ", "~"]];
  BitmapFont.defaultOptions = {
    resolution: 1,
    textureWidth: 512,
    textureHeight: 512,
    padding: 4,
    chars: _BitmapFont.ALPHANUMERIC
  };
  BitmapFont.available = {};
  var msdfFrag = "// Pixi texture info\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\n// Tint\r\nuniform vec4 uColor;\r\n\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r\nuniform float uFWidth;\r\n\r\nvoid main(void) {\r\n\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\r\n\r\n  // MSDF\r\n  float median = texColor.r + texColor.g + texColor.b -\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\r\n                  max(texColor.r, max(texColor.g, texColor.b));\r\n  // SDF\r\n  median = min(median, texColor.a);\r\n\r\n  float screenPxDistance = uFWidth * (median - 0.5);\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r\n  if (median < 0.01) {\r\n    alpha = 0.0;\r\n  } else if (median > 0.99) {\r\n    alpha = 1.0;\r\n  }\r\n\r\n  // NPM Textures, NPM outputs\r\n  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\r\n\r\n}\r\n";
  var msdfVert = "// Mesh material default fragment\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n";
  var pageMeshDataDefaultPageMeshData = [];
  var pageMeshDataMSDFPageMeshData = [];
  var charRenderDataPool = [];
  var _BitmapText = class extends Container {
    constructor(text, style = {}) {
      super();
      this._tint = 16777215;
      const { align, tint, maxWidth, letterSpacing, fontName, fontSize } = Object.assign({}, _BitmapText.styleDefaults, style);
      if (!BitmapFont.available[fontName]) {
        throw new Error(`Missing BitmapFont "${fontName}"`);
      }
      this._activePagesMeshData = [];
      this._textWidth = 0;
      this._textHeight = 0;
      this._align = align;
      this._tint = tint;
      this._font = void 0;
      this._fontName = fontName;
      this._fontSize = fontSize;
      this.text = text;
      this._maxWidth = maxWidth;
      this._maxLineHeight = 0;
      this._letterSpacing = letterSpacing;
      this._anchor = new ObservablePoint(() => {
        this.dirty = true;
      }, this, 0, 0);
      this._roundPixels = settings.ROUND_PIXELS;
      this.dirty = true;
      this._resolution = settings.RESOLUTION;
      this._autoResolution = true;
      this._textureCache = {};
    }
    updateText() {
      const data = BitmapFont.available[this._fontName];
      const fontSize = this.fontSize;
      const scale = fontSize / data.size;
      const pos = new Point();
      const chars = [];
      const lineWidths = [];
      const lineSpaces = [];
      const text = this._text.replace(/(?:\r\n|\r)/g, "\n") || " ";
      const charsInput = splitTextToCharacters(text);
      const maxWidth = this._maxWidth * data.size / fontSize;
      const pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
      let prevCharCode = null;
      let lastLineWidth = 0;
      let maxLineWidth = 0;
      let line = 0;
      let lastBreakPos = -1;
      let lastBreakWidth = 0;
      let spacesRemoved = 0;
      let maxLineHeight = 0;
      let spaceCount = 0;
      for (let i = 0; i < charsInput.length; i++) {
        const char = charsInput[i];
        const charCode = extractCharCode(char);
        if (/(?:\s)/.test(char)) {
          lastBreakPos = i;
          lastBreakWidth = lastLineWidth;
          spaceCount++;
        }
        if (char === "\r" || char === "\n") {
          lineWidths.push(lastLineWidth);
          lineSpaces.push(-1);
          maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
          ++line;
          ++spacesRemoved;
          pos.x = 0;
          pos.y += data.lineHeight;
          prevCharCode = null;
          spaceCount = 0;
          continue;
        }
        const charData = data.chars[charCode];
        if (!charData) {
          continue;
        }
        if (prevCharCode && charData.kerning[prevCharCode]) {
          pos.x += charData.kerning[prevCharCode];
        }
        const charRenderData = charRenderDataPool.pop() || {
          texture: Texture.EMPTY,
          line: 0,
          charCode: 0,
          prevSpaces: 0,
          position: new Point()
        };
        charRenderData.texture = charData.texture;
        charRenderData.line = line;
        charRenderData.charCode = charCode;
        charRenderData.position.x = pos.x + charData.xOffset + this._letterSpacing / 2;
        charRenderData.position.y = pos.y + charData.yOffset;
        charRenderData.prevSpaces = spaceCount;
        chars.push(charRenderData);
        lastLineWidth = charRenderData.position.x + Math.max(charData.xAdvance - charData.xOffset, charData.texture.orig.width);
        pos.x += charData.xAdvance + this._letterSpacing;
        maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height);
        prevCharCode = charCode;
        if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {
          ++spacesRemoved;
          removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);
          i = lastBreakPos;
          lastBreakPos = -1;
          lineWidths.push(lastBreakWidth);
          lineSpaces.push(chars.length > 0 ? chars[chars.length - 1].prevSpaces : 0);
          maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);
          line++;
          pos.x = 0;
          pos.y += data.lineHeight;
          prevCharCode = null;
          spaceCount = 0;
        }
      }
      const lastChar = charsInput[charsInput.length - 1];
      if (lastChar !== "\r" && lastChar !== "\n") {
        if (/(?:\s)/.test(lastChar)) {
          lastLineWidth = lastBreakWidth;
        }
        lineWidths.push(lastLineWidth);
        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
        lineSpaces.push(-1);
      }
      const lineAlignOffsets = [];
      for (let i = 0; i <= line; i++) {
        let alignOffset = 0;
        if (this._align === "right") {
          alignOffset = maxLineWidth - lineWidths[i];
        } else if (this._align === "center") {
          alignOffset = (maxLineWidth - lineWidths[i]) / 2;
        } else if (this._align === "justify") {
          alignOffset = lineSpaces[i] < 0 ? 0 : (maxLineWidth - lineWidths[i]) / lineSpaces[i];
        }
        lineAlignOffsets.push(alignOffset);
      }
      const lenChars = chars.length;
      const pagesMeshData = {};
      const newPagesMeshData = [];
      const activePagesMeshData = this._activePagesMeshData;
      pageMeshDataPool.push(...activePagesMeshData);
      for (let i = 0; i < lenChars; i++) {
        const texture = chars[i].texture;
        const baseTextureUid = texture.baseTexture.uid;
        if (!pagesMeshData[baseTextureUid]) {
          let pageMeshData = pageMeshDataPool.pop();
          if (!pageMeshData) {
            const geometry = new MeshGeometry();
            let material;
            let meshBlendMode;
            if (data.distanceFieldType === "none") {
              material = new MeshMaterial(Texture.EMPTY);
              meshBlendMode = BLEND_MODES.NORMAL;
            } else {
              material = new MeshMaterial(Texture.EMPTY, { program: Program.from(msdfVert, msdfFrag), uniforms: { uFWidth: 0 } });
              meshBlendMode = BLEND_MODES.NORMAL_NPM;
            }
            const mesh = new Mesh(geometry, material);
            mesh.blendMode = meshBlendMode;
            pageMeshData = {
              index: 0,
              indexCount: 0,
              vertexCount: 0,
              uvsCount: 0,
              total: 0,
              mesh,
              vertices: null,
              uvs: null,
              indices: null
            };
          }
          pageMeshData.index = 0;
          pageMeshData.indexCount = 0;
          pageMeshData.vertexCount = 0;
          pageMeshData.uvsCount = 0;
          pageMeshData.total = 0;
          const { _textureCache } = this;
          _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new Texture(texture.baseTexture);
          pageMeshData.mesh.texture = _textureCache[baseTextureUid];
          pageMeshData.mesh.tint = this._tint;
          newPagesMeshData.push(pageMeshData);
          pagesMeshData[baseTextureUid] = pageMeshData;
        }
        pagesMeshData[baseTextureUid].total++;
      }
      for (let i = 0; i < activePagesMeshData.length; i++) {
        if (!newPagesMeshData.includes(activePagesMeshData[i])) {
          this.removeChild(activePagesMeshData[i].mesh);
        }
      }
      for (let i = 0; i < newPagesMeshData.length; i++) {
        if (newPagesMeshData[i].mesh.parent !== this) {
          this.addChild(newPagesMeshData[i].mesh);
        }
      }
      this._activePagesMeshData = newPagesMeshData;
      for (const i in pagesMeshData) {
        const pageMeshData = pagesMeshData[i];
        const total = pageMeshData.total;
        if (!(pageMeshData.indices?.length > 6 * total) || pageMeshData.vertices.length < Mesh.BATCHABLE_SIZE * 2) {
          pageMeshData.vertices = new Float32Array(4 * 2 * total);
          pageMeshData.uvs = new Float32Array(4 * 2 * total);
          pageMeshData.indices = new Uint16Array(6 * total);
        } else {
          const total2 = pageMeshData.total;
          const vertices = pageMeshData.vertices;
          for (let i2 = total2 * 4 * 2; i2 < vertices.length; i2++) {
            vertices[i2] = 0;
          }
        }
        pageMeshData.mesh.size = 6 * total;
      }
      for (let i = 0; i < lenChars; i++) {
        const char = chars[i];
        let offset = char.position.x + lineAlignOffsets[char.line] * (this._align === "justify" ? char.prevSpaces : 1);
        if (this._roundPixels) {
          offset = Math.round(offset);
        }
        const xPos = offset * scale;
        const yPos = char.position.y * scale;
        const texture = char.texture;
        const pageMesh = pagesMeshData[texture.baseTexture.uid];
        const textureFrame = texture.frame;
        const textureUvs = texture._uvs;
        const index2 = pageMesh.index++;
        pageMesh.indices[index2 * 6 + 0] = 0 + index2 * 4;
        pageMesh.indices[index2 * 6 + 1] = 1 + index2 * 4;
        pageMesh.indices[index2 * 6 + 2] = 2 + index2 * 4;
        pageMesh.indices[index2 * 6 + 3] = 0 + index2 * 4;
        pageMesh.indices[index2 * 6 + 4] = 2 + index2 * 4;
        pageMesh.indices[index2 * 6 + 5] = 3 + index2 * 4;
        pageMesh.vertices[index2 * 8 + 0] = xPos;
        pageMesh.vertices[index2 * 8 + 1] = yPos;
        pageMesh.vertices[index2 * 8 + 2] = xPos + textureFrame.width * scale;
        pageMesh.vertices[index2 * 8 + 3] = yPos;
        pageMesh.vertices[index2 * 8 + 4] = xPos + textureFrame.width * scale;
        pageMesh.vertices[index2 * 8 + 5] = yPos + textureFrame.height * scale;
        pageMesh.vertices[index2 * 8 + 6] = xPos;
        pageMesh.vertices[index2 * 8 + 7] = yPos + textureFrame.height * scale;
        pageMesh.uvs[index2 * 8 + 0] = textureUvs.x0;
        pageMesh.uvs[index2 * 8 + 1] = textureUvs.y0;
        pageMesh.uvs[index2 * 8 + 2] = textureUvs.x1;
        pageMesh.uvs[index2 * 8 + 3] = textureUvs.y1;
        pageMesh.uvs[index2 * 8 + 4] = textureUvs.x2;
        pageMesh.uvs[index2 * 8 + 5] = textureUvs.y2;
        pageMesh.uvs[index2 * 8 + 6] = textureUvs.x3;
        pageMesh.uvs[index2 * 8 + 7] = textureUvs.y3;
      }
      this._textWidth = maxLineWidth * scale;
      this._textHeight = (pos.y + data.lineHeight) * scale;
      for (const i in pagesMeshData) {
        const pageMeshData = pagesMeshData[i];
        if (this.anchor.x !== 0 || this.anchor.y !== 0) {
          let vertexCount = 0;
          const anchorOffsetX = this._textWidth * this.anchor.x;
          const anchorOffsetY = this._textHeight * this.anchor.y;
          for (let i2 = 0; i2 < pageMeshData.total; i2++) {
            pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
            pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
            pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
            pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
            pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
            pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
            pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
            pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          }
        }
        this._maxLineHeight = maxLineHeight * scale;
        const vertexBuffer = pageMeshData.mesh.geometry.getBuffer("aVertexPosition");
        const textureBuffer = pageMeshData.mesh.geometry.getBuffer("aTextureCoord");
        const indexBuffer = pageMeshData.mesh.geometry.getIndex();
        vertexBuffer.data = pageMeshData.vertices;
        textureBuffer.data = pageMeshData.uvs;
        indexBuffer.data = pageMeshData.indices;
        vertexBuffer.update();
        textureBuffer.update();
        indexBuffer.update();
      }
      for (let i = 0; i < chars.length; i++) {
        charRenderDataPool.push(chars[i]);
      }
      this._font = data;
      this.dirty = false;
    }
    updateTransform() {
      this.validate();
      this.containerUpdateTransform();
    }
    _render(renderer) {
      if (this._autoResolution && this._resolution !== renderer.resolution) {
        this._resolution = renderer.resolution;
        this.dirty = true;
      }
      const { distanceFieldRange, distanceFieldType, size } = BitmapFont.available[this._fontName];
      if (distanceFieldType !== "none") {
        const { a: a2, b: b2, c, d } = this.worldTransform;
        const dx = Math.sqrt(a2 * a2 + b2 * b2);
        const dy = Math.sqrt(c * c + d * d);
        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;
        const fontScale = this.fontSize / size;
        const resolution = renderer._view.resolution;
        for (const mesh of this._activePagesMeshData) {
          mesh.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * resolution;
        }
      }
      super._render(renderer);
    }
    getLocalBounds() {
      this.validate();
      return super.getLocalBounds();
    }
    validate() {
      const font = BitmapFont.available[this._fontName];
      if (!font) {
        throw new Error(`Missing BitmapFont "${this._fontName}"`);
      }
      if (this._font !== font) {
        this.dirty = true;
      }
      if (this.dirty) {
        this.updateText();
      }
    }
    get tint() {
      return this._tint;
    }
    set tint(value3) {
      if (this._tint === value3)
        return;
      this._tint = value3;
      for (let i = 0; i < this._activePagesMeshData.length; i++) {
        this._activePagesMeshData[i].mesh.tint = value3;
      }
    }
    get align() {
      return this._align;
    }
    set align(value3) {
      if (this._align !== value3) {
        this._align = value3;
        this.dirty = true;
      }
    }
    get fontName() {
      return this._fontName;
    }
    set fontName(value3) {
      if (!BitmapFont.available[value3]) {
        throw new Error(`Missing BitmapFont "${value3}"`);
      }
      if (this._fontName !== value3) {
        this._fontName = value3;
        this.dirty = true;
      }
    }
    get fontSize() {
      return this._fontSize ?? BitmapFont.available[this._fontName].size;
    }
    set fontSize(value3) {
      if (this._fontSize !== value3) {
        this._fontSize = value3;
        this.dirty = true;
      }
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(value3) {
      if (typeof value3 === "number") {
        this._anchor.set(value3);
      } else {
        this._anchor.copyFrom(value3);
      }
    }
    get text() {
      return this._text;
    }
    set text(text) {
      text = String(text === null || text === void 0 ? "" : text);
      if (this._text === text) {
        return;
      }
      this._text = text;
      this.dirty = true;
    }
    get maxWidth() {
      return this._maxWidth;
    }
    set maxWidth(value3) {
      if (this._maxWidth === value3) {
        return;
      }
      this._maxWidth = value3;
      this.dirty = true;
    }
    get maxLineHeight() {
      this.validate();
      return this._maxLineHeight;
    }
    get textWidth() {
      this.validate();
      return this._textWidth;
    }
    get letterSpacing() {
      return this._letterSpacing;
    }
    set letterSpacing(value3) {
      if (this._letterSpacing !== value3) {
        this._letterSpacing = value3;
        this.dirty = true;
      }
    }
    get roundPixels() {
      return this._roundPixels;
    }
    set roundPixels(value3) {
      if (value3 !== this._roundPixels) {
        this._roundPixels = value3;
        this.dirty = true;
      }
    }
    get textHeight() {
      this.validate();
      return this._textHeight;
    }
    get resolution() {
      return this._resolution;
    }
    set resolution(value3) {
      this._autoResolution = false;
      if (this._resolution === value3) {
        return;
      }
      this._resolution = value3;
      this.dirty = true;
    }
    destroy(options) {
      const { _textureCache } = this;
      const data = BitmapFont.available[this._fontName];
      const pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
      pageMeshDataPool.push(...this._activePagesMeshData);
      for (const pageMeshData of this._activePagesMeshData) {
        this.removeChild(pageMeshData.mesh);
      }
      this._activePagesMeshData = [];
      pageMeshDataPool.filter((page) => _textureCache[page.mesh.texture.baseTexture.uid]).forEach((page) => {
        page.mesh.texture = Texture.EMPTY;
      });
      for (const id in _textureCache) {
        const texture = _textureCache[id];
        texture.destroy();
        delete _textureCache[id];
      }
      this._font = null;
      this._textureCache = null;
      super.destroy(options);
    }
  };
  var BitmapText = _BitmapText;
  BitmapText.styleDefaults = {
    align: "left",
    tint: 16777215,
    maxWidth: 0,
    letterSpacing: 0
  };
  var validExtensions = [".xml", ".fnt"];
  var loadBitmapFont = {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.Normal
    },
    test(url2) {
      return validExtensions.includes(path.extname(url2));
    },
    async testParse(data) {
      return TextFormat.test(data) || XMLStringFormat.test(data);
    },
    async parse(asset, data, loader) {
      const fontData = TextFormat.test(asset) ? TextFormat.parse(asset) : XMLStringFormat.parse(asset);
      const { src } = data;
      const { page: pages } = fontData;
      const textureUrls = [];
      for (let i = 0; i < pages.length; ++i) {
        const pageFile = pages[i].file;
        const imagePath = path.join(path.dirname(src), pageFile);
        textureUrls.push(imagePath);
      }
      const loadedTextures = await loader.load(textureUrls);
      const textures = textureUrls.map((url2) => loadedTextures[url2]);
      return BitmapFont.install(fontData, textures, true);
    },
    async load(url2, _options) {
      const response = await settings.ADAPTER.fetch(url2);
      return response.text();
    },
    unload(bitmapFont) {
      bitmapFont.destroy();
    }
  };
  extensions$1.add(loadBitmapFont);
  function find$1(list, predicate, ac) {
    if (ac === void 0) {
      ac = Array.prototype;
    }
    if (list && typeof ac.find === "function") {
      return ac.find.call(list, predicate);
    }
    for (var i = 0; i < list.length; i++) {
      if (Object.prototype.hasOwnProperty.call(list, i)) {
        var item2 = list[i];
        if (predicate.call(void 0, item2, i, list)) {
          return item2;
        }
      }
    }
  }
  function freeze(object, oc) {
    if (oc === void 0) {
      oc = Object;
    }
    return oc && typeof oc.freeze === "function" ? oc.freeze(object) : object;
  }
  function assign(target2, source) {
    if (target2 === null || typeof target2 !== "object") {
      throw new TypeError("target is not an object");
    }
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target2[key] = source[key];
      }
    }
    return target2;
  }
  var MIME_TYPE = freeze({
    /**
     * `text/html`, the only mime type that triggers treating an XML document as HTML.
     *
     * @see DOMParser.SupportedType.isHTML
     * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/HTML Wikipedia
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
     */
    HTML: "text/html",
    /**
     * Helper method to check a mime type if it indicates an HTML document
     *
     * @param {string} [value]
     * @returns {boolean}
     *
     * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/HTML Wikipedia
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
    isHTML: function(value3) {
      return value3 === MIME_TYPE.HTML;
    },
    /**
     * `application/xml`, the standard mime type for XML documents.
     *
     * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
     * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
     * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
     */
    XML_APPLICATION: "application/xml",
    /**
     * `text/html`, an alias for `application/xml`.
     *
     * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
     * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
     */
    XML_TEXT: "text/xml",
    /**
     * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
     * but is parsed as an XML document.
     *
     * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
     * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
     */
    XML_XHTML_APPLICATION: "application/xhtml+xml",
    /**
     * `image/svg+xml`,
     *
     * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
     * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
     * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
     */
    XML_SVG_IMAGE: "image/svg+xml"
  });
  var NAMESPACE$3 = freeze({
    /**
     * The XHTML namespace.
     *
     * @see http://www.w3.org/1999/xhtml
     */
    HTML: "http://www.w3.org/1999/xhtml",
    /**
     * Checks if `uri` equals `NAMESPACE.HTML`.
     *
     * @param {string} [uri]
     *
     * @see NAMESPACE.HTML
     */
    isHTML: function(uri) {
      return uri === NAMESPACE$3.HTML;
    },
    /**
     * The SVG namespace.
     *
     * @see http://www.w3.org/2000/svg
     */
    SVG: "http://www.w3.org/2000/svg",
    /**
     * The `xml:` namespace.
     *
     * @see http://www.w3.org/XML/1998/namespace
     */
    XML: "http://www.w3.org/XML/1998/namespace",
    /**
     * The `xmlns:` namespace
     *
     * @see https://www.w3.org/2000/xmlns/
     */
    XMLNS: "http://www.w3.org/2000/xmlns/"
  });
  var assign_1 = assign;
  var find_1 = find$1;
  var freeze_1 = freeze;
  var MIME_TYPE_1 = MIME_TYPE;
  var NAMESPACE_1 = NAMESPACE$3;
  var conventions = {
    assign: assign_1,
    find: find_1,
    freeze: freeze_1,
    MIME_TYPE: MIME_TYPE_1,
    NAMESPACE: NAMESPACE_1
  };
  var find = conventions.find;
  var NAMESPACE$2 = conventions.NAMESPACE;
  function notEmptyString(input) {
    return input !== "";
  }
  function splitOnASCIIWhitespace(input) {
    return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
  }
  function orderedSetReducer(current, element) {
    if (!current.hasOwnProperty(element)) {
      current[element] = true;
    }
    return current;
  }
  function toOrderedSet(input) {
    if (!input)
      return [];
    var list = splitOnASCIIWhitespace(input);
    return Object.keys(list.reduce(orderedSetReducer, {}));
  }
  function arrayIncludes(list) {
    return function(element) {
      return list && list.indexOf(element) !== -1;
    };
  }
  function copy(src, dest) {
    for (var p in src) {
      if (Object.prototype.hasOwnProperty.call(src, p)) {
        dest[p] = src[p];
      }
    }
  }
  function _extends(Class, Super) {
    var pt = Class.prototype;
    if (!(pt instanceof Super)) {
      let t = function() {
      };
      ;
      t.prototype = Super.prototype;
      t = new t();
      copy(pt, t);
      Class.prototype = pt = t;
    }
    if (pt.constructor != Class) {
      if (typeof Class != "function") {
        console.error("unknown Class:" + Class);
      }
      pt.constructor = Class;
    }
  }
  var NodeType = {};
  var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
  var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
  var TEXT_NODE = NodeType.TEXT_NODE = 3;
  var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
  var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
  var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
  var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
  var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
  var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
  var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
  var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
  var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
  var ExceptionCode = {};
  var ExceptionMessage = {};
  var INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
  var DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
  var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
  var WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
  var INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
  var NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
  var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
  var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
  var NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
  var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
  var INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
  var SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
  var INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
  var NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
  var INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
  function DOMException(code, message) {
    if (message instanceof Error) {
      var error = message;
    } else {
      error = this;
      Error.call(this, ExceptionMessage[code]);
      this.message = ExceptionMessage[code];
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, DOMException);
    }
    error.code = code;
    if (message)
      this.message = this.message + ": " + message;
    return error;
  }
  DOMException.prototype = Error.prototype;
  copy(ExceptionCode, DOMException);
  function NodeList() {
  }
  NodeList.prototype = {
    /**
     * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
     * @standard level1
     */
    length: 0,
    /**
     * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
     * @standard level1
     * @param index  unsigned long
     *   Index into the collection.
     * @return Node
     * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
     */
    item: function(index2) {
      return this[index2] || null;
    },
    toString: function(isHTML, nodeFilter) {
      for (var buf = [], i = 0; i < this.length; i++) {
        serializeToString(this[i], buf, isHTML, nodeFilter);
      }
      return buf.join("");
    },
    /**
     * @private
     * @param {function (Node):boolean} predicate
     * @returns {Node[]}
     */
    filter: function(predicate) {
      return Array.prototype.filter.call(this, predicate);
    },
    /**
     * @private
     * @param {Node} item
     * @returns {number}
     */
    indexOf: function(item2) {
      return Array.prototype.indexOf.call(this, item2);
    }
  };
  function LiveNodeList(node, refresh) {
    this._node = node;
    this._refresh = refresh;
    _updateLiveList(this);
  }
  function _updateLiveList(list) {
    var inc = list._node._inc || list._node.ownerDocument._inc;
    if (list._inc != inc) {
      var ls = list._refresh(list._node);
      __set__(list, "length", ls.length);
      copy(ls, list);
      list._inc = inc;
    }
  }
  LiveNodeList.prototype.item = function(i) {
    _updateLiveList(this);
    return this[i];
  };
  _extends(LiveNodeList, NodeList);
  function NamedNodeMap() {
  }
  function _findNodeIndex(list, node) {
    var i = list.length;
    while (i--) {
      if (list[i] === node) {
        return i;
      }
    }
  }
  function _addNamedNode(el, list, newAttr, oldAttr) {
    if (oldAttr) {
      list[_findNodeIndex(list, oldAttr)] = newAttr;
    } else {
      list[list.length++] = newAttr;
    }
    if (el) {
      newAttr.ownerElement = el;
      var doc = el.ownerDocument;
      if (doc) {
        oldAttr && _onRemoveAttribute(doc, el, oldAttr);
        _onAddAttribute(doc, el, newAttr);
      }
    }
  }
  function _removeNamedNode(el, list, attr) {
    var i = _findNodeIndex(list, attr);
    if (i >= 0) {
      var lastIndex = list.length - 1;
      while (i < lastIndex) {
        list[i] = list[++i];
      }
      list.length = lastIndex;
      if (el) {
        var doc = el.ownerDocument;
        if (doc) {
          _onRemoveAttribute(doc, el, attr);
          attr.ownerElement = null;
        }
      }
    } else {
      throw new DOMException(NOT_FOUND_ERR, new Error(el.tagName + "@" + attr));
    }
  }
  NamedNodeMap.prototype = {
    length: 0,
    item: NodeList.prototype.item,
    getNamedItem: function(key) {
      var i = this.length;
      while (i--) {
        var attr = this[i];
        if (attr.nodeName == key) {
          return attr;
        }
      }
    },
    setNamedItem: function(attr) {
      var el = attr.ownerElement;
      if (el && el != this._ownerElement) {
        throw new DOMException(INUSE_ATTRIBUTE_ERR);
      }
      var oldAttr = this.getNamedItem(attr.nodeName);
      _addNamedNode(this._ownerElement, this, attr, oldAttr);
      return oldAttr;
    },
    /* returns Node */
    setNamedItemNS: function(attr) {
      var el = attr.ownerElement, oldAttr;
      if (el && el != this._ownerElement) {
        throw new DOMException(INUSE_ATTRIBUTE_ERR);
      }
      oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
      _addNamedNode(this._ownerElement, this, attr, oldAttr);
      return oldAttr;
    },
    /* returns Node */
    removeNamedItem: function(key) {
      var attr = this.getNamedItem(key);
      _removeNamedNode(this._ownerElement, this, attr);
      return attr;
    },
    // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
    //for level2
    removeNamedItemNS: function(namespaceURI, localName) {
      var attr = this.getNamedItemNS(namespaceURI, localName);
      _removeNamedNode(this._ownerElement, this, attr);
      return attr;
    },
    getNamedItemNS: function(namespaceURI, localName) {
      var i = this.length;
      while (i--) {
        var node = this[i];
        if (node.localName == localName && node.namespaceURI == namespaceURI) {
          return node;
        }
      }
      return null;
    }
  };
  function DOMImplementation$2() {
  }
  DOMImplementation$2.prototype = {
    /**
     * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
     * The different implementations fairly diverged in what kind of features were reported.
     * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
     *
     * @deprecated It is deprecated and modern browsers return true in all cases.
     *
     * @param {string} feature
     * @param {string} [version]
     * @returns {boolean} always true
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
     * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
     */
    hasFeature: function(feature, version) {
      return true;
    },
    /**
     * Creates an XML Document object of the specified type with its document element.
     *
     * __It behaves slightly different from the description in the living standard__:
     * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
     * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
     * - this implementation is not validating names or qualified names
     *   (when parsing XML strings, the SAX parser takes care of that)
     *
     * @param {string|null} namespaceURI
     * @param {string} qualifiedName
     * @param {DocumentType=null} doctype
     * @returns {Document}
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
     *
     * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
     * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
     * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
     */
    createDocument: function(namespaceURI, qualifiedName, doctype) {
      var doc = new Document();
      doc.implementation = this;
      doc.childNodes = new NodeList();
      doc.doctype = doctype || null;
      if (doctype) {
        doc.appendChild(doctype);
      }
      if (qualifiedName) {
        var root2 = doc.createElementNS(namespaceURI, qualifiedName);
        doc.appendChild(root2);
      }
      return doc;
    },
    /**
     * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
     *
     * __This behavior is slightly different from the in the specs__:
     * - this implementation is not validating names or qualified names
     *   (when parsing XML strings, the SAX parser takes care of that)
     *
     * @param {string} qualifiedName
     * @param {string} [publicId]
     * @param {string} [systemId]
     * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
     * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
     *
     * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
     * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
     * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
     */
    createDocumentType: function(qualifiedName, publicId, systemId) {
      var node = new DocumentType();
      node.name = qualifiedName;
      node.nodeName = qualifiedName;
      node.publicId = publicId || "";
      node.systemId = systemId || "";
      return node;
    }
  };
  function Node() {
  }
  Node.prototype = {
    firstChild: null,
    lastChild: null,
    previousSibling: null,
    nextSibling: null,
    attributes: null,
    parentNode: null,
    childNodes: null,
    ownerDocument: null,
    nodeValue: null,
    namespaceURI: null,
    prefix: null,
    localName: null,
    // Modified in DOM Level 2:
    insertBefore: function(newChild, refChild) {
      return _insertBefore(this, newChild, refChild);
    },
    replaceChild: function(newChild, oldChild) {
      _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
      if (oldChild) {
        this.removeChild(oldChild);
      }
    },
    removeChild: function(oldChild) {
      return _removeChild(this, oldChild);
    },
    appendChild: function(newChild) {
      return this.insertBefore(newChild, null);
    },
    hasChildNodes: function() {
      return this.firstChild != null;
    },
    cloneNode: function(deep) {
      return cloneNode(this.ownerDocument || this, this, deep);
    },
    // Modified in DOM Level 2:
    normalize: function() {
      var child = this.firstChild;
      while (child) {
        var next = child.nextSibling;
        if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
          this.removeChild(next);
          child.appendData(next.data);
        } else {
          child.normalize();
          child = next;
        }
      }
    },
    // Introduced in DOM Level 2:
    isSupported: function(feature, version) {
      return this.ownerDocument.implementation.hasFeature(feature, version);
    },
    // Introduced in DOM Level 2:
    hasAttributes: function() {
      return this.attributes.length > 0;
    },
    /**
     * Look up the prefix associated to the given namespace URI, starting from this node.
     * **The default namespace declarations are ignored by this method.**
     * See Namespace Prefix Lookup for details on the algorithm used by this method.
     *
     * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
     *
     * @param {string | null} namespaceURI
     * @returns {string | null}
     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
     * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
     * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
     * @see https://github.com/xmldom/xmldom/issues/322
     */
    lookupPrefix: function(namespaceURI) {
      var el = this;
      while (el) {
        var map2 = el._nsMap;
        if (map2) {
          for (var n in map2) {
            if (Object.prototype.hasOwnProperty.call(map2, n) && map2[n] === namespaceURI) {
              return n;
            }
          }
        }
        el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
      }
      return null;
    },
    // Introduced in DOM Level 3:
    lookupNamespaceURI: function(prefix) {
      var el = this;
      while (el) {
        var map2 = el._nsMap;
        if (map2) {
          if (Object.prototype.hasOwnProperty.call(map2, prefix)) {
            return map2[prefix];
          }
        }
        el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
      }
      return null;
    },
    // Introduced in DOM Level 3:
    isDefaultNamespace: function(namespaceURI) {
      var prefix = this.lookupPrefix(namespaceURI);
      return prefix == null;
    }
  };
  function _xmlEncoder(c) {
    return c == "<" && "&lt;" || c == ">" && "&gt;" || c == "&" && "&amp;" || c == '"' && "&quot;" || "&#" + c.charCodeAt() + ";";
  }
  copy(NodeType, Node);
  copy(NodeType, Node.prototype);
  function _visitNode(node, callback) {
    if (callback(node)) {
      return true;
    }
    if (node = node.firstChild) {
      do {
        if (_visitNode(node, callback)) {
          return true;
        }
      } while (node = node.nextSibling);
    }
  }
  function Document() {
    this.ownerDocument = this;
  }
  function _onAddAttribute(doc, el, newAttr) {
    doc && doc._inc++;
    var ns = newAttr.namespaceURI;
    if (ns === NAMESPACE$2.XMLNS) {
      el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
    }
  }
  function _onRemoveAttribute(doc, el, newAttr, remove) {
    doc && doc._inc++;
    var ns = newAttr.namespaceURI;
    if (ns === NAMESPACE$2.XMLNS) {
      delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
    }
  }
  function _onUpdateChild(doc, el, newChild) {
    if (doc && doc._inc) {
      doc._inc++;
      var cs = el.childNodes;
      if (newChild) {
        cs[cs.length++] = newChild;
      } else {
        var child = el.firstChild;
        var i = 0;
        while (child) {
          cs[i++] = child;
          child = child.nextSibling;
        }
        cs.length = i;
        delete cs[cs.length];
      }
    }
  }
  function _removeChild(parentNode, child) {
    var previous = child.previousSibling;
    var next = child.nextSibling;
    if (previous) {
      previous.nextSibling = next;
    } else {
      parentNode.firstChild = next;
    }
    if (next) {
      next.previousSibling = previous;
    } else {
      parentNode.lastChild = previous;
    }
    child.parentNode = null;
    child.previousSibling = null;
    child.nextSibling = null;
    _onUpdateChild(parentNode.ownerDocument, parentNode);
    return child;
  }
  function hasValidParentNodeType(node) {
    return node && (node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE);
  }
  function hasInsertableNodeType(node) {
    return node && (isElementNode(node) || isTextNode(node) || isDocTypeNode(node) || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.COMMENT_NODE || node.nodeType === Node.PROCESSING_INSTRUCTION_NODE);
  }
  function isDocTypeNode(node) {
    return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;
  }
  function isElementNode(node) {
    return node && node.nodeType === Node.ELEMENT_NODE;
  }
  function isTextNode(node) {
    return node && node.nodeType === Node.TEXT_NODE;
  }
  function isElementInsertionPossible(doc, child) {
    var parentChildNodes = doc.childNodes || [];
    if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
      return false;
    }
    var docTypeNode = find(parentChildNodes, isDocTypeNode);
    return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
  }
  function isElementReplacementPossible(doc, child) {
    var parentChildNodes = doc.childNodes || [];
    function hasElementChildThatIsNotChild(node) {
      return isElementNode(node) && node !== child;
    }
    if (find(parentChildNodes, hasElementChildThatIsNotChild)) {
      return false;
    }
    var docTypeNode = find(parentChildNodes, isDocTypeNode);
    return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
  }
  function assertPreInsertionValidity1to5(parent, node, child) {
    if (!hasValidParentNodeType(parent)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + parent.nodeType);
    }
    if (child && child.parentNode !== parent) {
      throw new DOMException(NOT_FOUND_ERR, "child not in parent");
    }
    if (
      // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
      !hasInsertableNodeType(node) || // 5. If either `node` is a Text node and `parent` is a document,
      // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
      // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
      // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
      isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE
    ) {
      throw new DOMException(
        HIERARCHY_REQUEST_ERR,
        "Unexpected node type " + node.nodeType + " for parent node type " + parent.nodeType
      );
    }
  }
  function assertPreInsertionValidityInDocument(parent, node, child) {
    var parentChildNodes = parent.childNodes || [];
    var nodeChildNodes = node.childNodes || [];
    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      var nodeChildElements = nodeChildNodes.filter(isElementNode);
      if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
      }
      if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
      }
    }
    if (isElementNode(node)) {
      if (!isElementInsertionPossible(parent, child)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
      }
    }
    if (isDocTypeNode(node)) {
      if (find(parentChildNodes, isDocTypeNode)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
      }
      var parentElementChild = find(parentChildNodes, isElementNode);
      if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
      }
      if (!child && parentElementChild) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
      }
    }
  }
  function assertPreReplacementValidityInDocument(parent, node, child) {
    var parentChildNodes = parent.childNodes || [];
    var nodeChildNodes = node.childNodes || [];
    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      var nodeChildElements = nodeChildNodes.filter(isElementNode);
      if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
      }
      if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
      }
    }
    if (isElementNode(node)) {
      if (!isElementReplacementPossible(parent, child)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
      }
    }
    if (isDocTypeNode(node)) {
      let hasDoctypeChildThatIsNotChild = function(node2) {
        return isDocTypeNode(node2) && node2 !== child;
      };
      if (find(parentChildNodes, hasDoctypeChildThatIsNotChild)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
      }
      var parentElementChild = find(parentChildNodes, isElementNode);
      if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
      }
    }
  }
  function _insertBefore(parent, node, child, _inDocumentAssertion) {
    assertPreInsertionValidity1to5(parent, node, child);
    if (parent.nodeType === Node.DOCUMENT_NODE) {
      (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
    }
    var cp = node.parentNode;
    if (cp) {
      cp.removeChild(node);
    }
    if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
      var newFirst = node.firstChild;
      if (newFirst == null) {
        return node;
      }
      var newLast = node.lastChild;
    } else {
      newFirst = newLast = node;
    }
    var pre = child ? child.previousSibling : parent.lastChild;
    newFirst.previousSibling = pre;
    newLast.nextSibling = child;
    if (pre) {
      pre.nextSibling = newFirst;
    } else {
      parent.firstChild = newFirst;
    }
    if (child == null) {
      parent.lastChild = newLast;
    } else {
      child.previousSibling = newLast;
    }
    do {
      newFirst.parentNode = parent;
    } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
    _onUpdateChild(parent.ownerDocument || parent, parent);
    if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
      node.firstChild = node.lastChild = null;
    }
    return node;
  }
  function _appendSingleChild(parentNode, newChild) {
    if (newChild.parentNode) {
      newChild.parentNode.removeChild(newChild);
    }
    newChild.parentNode = parentNode;
    newChild.previousSibling = parentNode.lastChild;
    newChild.nextSibling = null;
    if (newChild.previousSibling) {
      newChild.previousSibling.nextSibling = newChild;
    } else {
      parentNode.firstChild = newChild;
    }
    parentNode.lastChild = newChild;
    _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
    return newChild;
  }
  Document.prototype = {
    //implementation : null,
    nodeName: "#document",
    nodeType: DOCUMENT_NODE,
    /**
     * The DocumentType node of the document.
     *
     * @readonly
     * @type DocumentType
     */
    doctype: null,
    documentElement: null,
    _inc: 1,
    insertBefore: function(newChild, refChild) {
      if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
        var child = newChild.firstChild;
        while (child) {
          var next = child.nextSibling;
          this.insertBefore(child, refChild);
          child = next;
        }
        return newChild;
      }
      _insertBefore(this, newChild, refChild);
      newChild.ownerDocument = this;
      if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
        this.documentElement = newChild;
      }
      return newChild;
    },
    removeChild: function(oldChild) {
      if (this.documentElement == oldChild) {
        this.documentElement = null;
      }
      return _removeChild(this, oldChild);
    },
    replaceChild: function(newChild, oldChild) {
      _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
      newChild.ownerDocument = this;
      if (oldChild) {
        this.removeChild(oldChild);
      }
      if (isElementNode(newChild)) {
        this.documentElement = newChild;
      }
    },
    // Introduced in DOM Level 2:
    importNode: function(importedNode, deep) {
      return importNode(this, importedNode, deep);
    },
    // Introduced in DOM Level 2:
    getElementById: function(id) {
      var rtv = null;
      _visitNode(this.documentElement, function(node) {
        if (node.nodeType == ELEMENT_NODE) {
          if (node.getAttribute("id") == id) {
            rtv = node;
            return true;
          }
        }
      });
      return rtv;
    },
    /**
     * The `getElementsByClassName` method of `Document` interface returns an array-like object
     * of all child elements which have **all** of the given class name(s).
     *
     * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
     *
     *
     * Warning: This is a live LiveNodeList.
     * Changes in the DOM will reflect in the array as the changes occur.
     * If an element selected by this array no longer qualifies for the selector,
     * it will automatically be removed. Be aware of this for iteration purposes.
     *
     * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
     * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
     */
    getElementsByClassName: function(classNames) {
      var classNamesSet = toOrderedSet(classNames);
      return new LiveNodeList(this, function(base) {
        var ls = [];
        if (classNamesSet.length > 0) {
          _visitNode(base.documentElement, function(node) {
            if (node !== base && node.nodeType === ELEMENT_NODE) {
              var nodeClassNames = node.getAttribute("class");
              if (nodeClassNames) {
                var matches = classNames === nodeClassNames;
                if (!matches) {
                  var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                  matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                }
                if (matches) {
                  ls.push(node);
                }
              }
            }
          });
        }
        return ls;
      });
    },
    //document factory method:
    createElement: function(tagName) {
      var node = new Element2();
      node.ownerDocument = this;
      node.nodeName = tagName;
      node.tagName = tagName;
      node.localName = tagName;
      node.childNodes = new NodeList();
      var attrs = node.attributes = new NamedNodeMap();
      attrs._ownerElement = node;
      return node;
    },
    createDocumentFragment: function() {
      var node = new DocumentFragment();
      node.ownerDocument = this;
      node.childNodes = new NodeList();
      return node;
    },
    createTextNode: function(data) {
      var node = new Text();
      node.ownerDocument = this;
      node.appendData(data);
      return node;
    },
    createComment: function(data) {
      var node = new Comment();
      node.ownerDocument = this;
      node.appendData(data);
      return node;
    },
    createCDATASection: function(data) {
      var node = new CDATASection();
      node.ownerDocument = this;
      node.appendData(data);
      return node;
    },
    createProcessingInstruction: function(target2, data) {
      var node = new ProcessingInstruction();
      node.ownerDocument = this;
      node.tagName = node.target = target2;
      node.nodeValue = node.data = data;
      return node;
    },
    createAttribute: function(name) {
      var node = new Attr();
      node.ownerDocument = this;
      node.name = name;
      node.nodeName = name;
      node.localName = name;
      node.specified = true;
      return node;
    },
    createEntityReference: function(name) {
      var node = new EntityReference();
      node.ownerDocument = this;
      node.nodeName = name;
      return node;
    },
    // Introduced in DOM Level 2:
    createElementNS: function(namespaceURI, qualifiedName) {
      var node = new Element2();
      var pl = qualifiedName.split(":");
      var attrs = node.attributes = new NamedNodeMap();
      node.childNodes = new NodeList();
      node.ownerDocument = this;
      node.nodeName = qualifiedName;
      node.tagName = qualifiedName;
      node.namespaceURI = namespaceURI;
      if (pl.length == 2) {
        node.prefix = pl[0];
        node.localName = pl[1];
      } else {
        node.localName = qualifiedName;
      }
      attrs._ownerElement = node;
      return node;
    },
    // Introduced in DOM Level 2:
    createAttributeNS: function(namespaceURI, qualifiedName) {
      var node = new Attr();
      var pl = qualifiedName.split(":");
      node.ownerDocument = this;
      node.nodeName = qualifiedName;
      node.name = qualifiedName;
      node.namespaceURI = namespaceURI;
      node.specified = true;
      if (pl.length == 2) {
        node.prefix = pl[0];
        node.localName = pl[1];
      } else {
        node.localName = qualifiedName;
      }
      return node;
    }
  };
  _extends(Document, Node);
  function Element2() {
    this._nsMap = {};
  }
  Element2.prototype = {
    nodeType: ELEMENT_NODE,
    hasAttribute: function(name) {
      return this.getAttributeNode(name) != null;
    },
    getAttribute: function(name) {
      var attr = this.getAttributeNode(name);
      return attr && attr.value || "";
    },
    getAttributeNode: function(name) {
      return this.attributes.getNamedItem(name);
    },
    setAttribute: function(name, value3) {
      var attr = this.ownerDocument.createAttribute(name);
      attr.value = attr.nodeValue = "" + value3;
      this.setAttributeNode(attr);
    },
    removeAttribute: function(name) {
      var attr = this.getAttributeNode(name);
      attr && this.removeAttributeNode(attr);
    },
    //four real opeartion method
    appendChild: function(newChild) {
      if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
        return this.insertBefore(newChild, null);
      } else {
        return _appendSingleChild(this, newChild);
      }
    },
    setAttributeNode: function(newAttr) {
      return this.attributes.setNamedItem(newAttr);
    },
    setAttributeNodeNS: function(newAttr) {
      return this.attributes.setNamedItemNS(newAttr);
    },
    removeAttributeNode: function(oldAttr) {
      return this.attributes.removeNamedItem(oldAttr.nodeName);
    },
    //get real attribute name,and remove it by removeAttributeNode
    removeAttributeNS: function(namespaceURI, localName) {
      var old = this.getAttributeNodeNS(namespaceURI, localName);
      old && this.removeAttributeNode(old);
    },
    hasAttributeNS: function(namespaceURI, localName) {
      return this.getAttributeNodeNS(namespaceURI, localName) != null;
    },
    getAttributeNS: function(namespaceURI, localName) {
      var attr = this.getAttributeNodeNS(namespaceURI, localName);
      return attr && attr.value || "";
    },
    setAttributeNS: function(namespaceURI, qualifiedName, value3) {
      var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
      attr.value = attr.nodeValue = "" + value3;
      this.setAttributeNode(attr);
    },
    getAttributeNodeNS: function(namespaceURI, localName) {
      return this.attributes.getNamedItemNS(namespaceURI, localName);
    },
    getElementsByTagName: function(tagName) {
      return new LiveNodeList(this, function(base) {
        var ls = [];
        _visitNode(base, function(node) {
          if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === "*" || node.tagName == tagName)) {
            ls.push(node);
          }
        });
        return ls;
      });
    },
    getElementsByTagNameNS: function(namespaceURI, localName) {
      return new LiveNodeList(this, function(base) {
        var ls = [];
        _visitNode(base, function(node) {
          if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) {
            ls.push(node);
          }
        });
        return ls;
      });
    }
  };
  Document.prototype.getElementsByTagName = Element2.prototype.getElementsByTagName;
  Document.prototype.getElementsByTagNameNS = Element2.prototype.getElementsByTagNameNS;
  _extends(Element2, Node);
  function Attr() {
  }
  Attr.prototype.nodeType = ATTRIBUTE_NODE;
  _extends(Attr, Node);
  function CharacterData() {
  }
  CharacterData.prototype = {
    data: "",
    substringData: function(offset, count) {
      return this.data.substring(offset, offset + count);
    },
    appendData: function(text) {
      text = this.data + text;
      this.nodeValue = this.data = text;
      this.length = text.length;
    },
    insertData: function(offset, text) {
      this.replaceData(offset, 0, text);
    },
    appendChild: function(newChild) {
      throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
    },
    deleteData: function(offset, count) {
      this.replaceData(offset, count, "");
    },
    replaceData: function(offset, count, text) {
      var start = this.data.substring(0, offset);
      var end = this.data.substring(offset + count);
      text = start + text + end;
      this.nodeValue = this.data = text;
      this.length = text.length;
    }
  };
  _extends(CharacterData, Node);
  function Text() {
  }
  Text.prototype = {
    nodeName: "#text",
    nodeType: TEXT_NODE,
    splitText: function(offset) {
      var text = this.data;
      var newText = text.substring(offset);
      text = text.substring(0, offset);
      this.data = this.nodeValue = text;
      this.length = text.length;
      var newNode = this.ownerDocument.createTextNode(newText);
      if (this.parentNode) {
        this.parentNode.insertBefore(newNode, this.nextSibling);
      }
      return newNode;
    }
  };
  _extends(Text, CharacterData);
  function Comment() {
  }
  Comment.prototype = {
    nodeName: "#comment",
    nodeType: COMMENT_NODE
  };
  _extends(Comment, CharacterData);
  function CDATASection() {
  }
  CDATASection.prototype = {
    nodeName: "#cdata-section",
    nodeType: CDATA_SECTION_NODE
  };
  _extends(CDATASection, CharacterData);
  function DocumentType() {
  }
  DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
  _extends(DocumentType, Node);
  function Notation() {
  }
  Notation.prototype.nodeType = NOTATION_NODE;
  _extends(Notation, Node);
  function Entity() {
  }
  Entity.prototype.nodeType = ENTITY_NODE;
  _extends(Entity, Node);
  function EntityReference() {
  }
  EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
  _extends(EntityReference, Node);
  function DocumentFragment() {
  }
  DocumentFragment.prototype.nodeName = "#document-fragment";
  DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
  _extends(DocumentFragment, Node);
  function ProcessingInstruction() {
  }
  ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
  _extends(ProcessingInstruction, Node);
  function XMLSerializer$1() {
  }
  XMLSerializer$1.prototype.serializeToString = function(node, isHtml, nodeFilter) {
    return nodeSerializeToString.call(node, isHtml, nodeFilter);
  };
  Node.prototype.toString = nodeSerializeToString;
  function nodeSerializeToString(isHtml, nodeFilter) {
    var buf = [];
    var refNode = this.nodeType == 9 && this.documentElement || this;
    var prefix = refNode.prefix;
    var uri = refNode.namespaceURI;
    if (uri && prefix == null) {
      var prefix = refNode.lookupPrefix(uri);
      if (prefix == null) {
        var visibleNamespaces = [
          { namespace: uri, prefix: null }
          //{namespace:uri,prefix:''}
        ];
      }
    }
    serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
    return buf.join("");
  }
  function needNamespaceDefine(node, isHTML, visibleNamespaces) {
    var prefix = node.prefix || "";
    var uri = node.namespaceURI;
    if (!uri) {
      return false;
    }
    if (prefix === "xml" && uri === NAMESPACE$2.XML || uri === NAMESPACE$2.XMLNS) {
      return false;
    }
    var i = visibleNamespaces.length;
    while (i--) {
      var ns = visibleNamespaces[i];
      if (ns.prefix === prefix) {
        return ns.namespace !== uri;
      }
    }
    return true;
  }
  function addSerializedAttribute(buf, qualifiedName, value3) {
    buf.push(" ", qualifiedName, '="', value3.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
  }
  function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
    if (!visibleNamespaces) {
      visibleNamespaces = [];
    }
    if (nodeFilter) {
      node = nodeFilter(node);
      if (node) {
        if (typeof node == "string") {
          buf.push(node);
          return;
        }
      } else {
        return;
      }
    }
    switch (node.nodeType) {
      case ELEMENT_NODE:
        var attrs = node.attributes;
        var len = attrs.length;
        var child = node.firstChild;
        var nodeName = node.tagName;
        isHTML = NAMESPACE$2.isHTML(node.namespaceURI) || isHTML;
        var prefixedNodeName = nodeName;
        if (!isHTML && !node.prefix && node.namespaceURI) {
          var defaultNS;
          for (var ai = 0; ai < attrs.length; ai++) {
            if (attrs.item(ai).name === "xmlns") {
              defaultNS = attrs.item(ai).value;
              break;
            }
          }
          if (!defaultNS) {
            for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
              var namespace = visibleNamespaces[nsi];
              if (namespace.prefix === "" && namespace.namespace === node.namespaceURI) {
                defaultNS = namespace.namespace;
                break;
              }
            }
          }
          if (defaultNS !== node.namespaceURI) {
            for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
              var namespace = visibleNamespaces[nsi];
              if (namespace.namespace === node.namespaceURI) {
                if (namespace.prefix) {
                  prefixedNodeName = namespace.prefix + ":" + nodeName;
                }
                break;
              }
            }
          }
        }
        buf.push("<", prefixedNodeName);
        for (var i = 0; i < len; i++) {
          var attr = attrs.item(i);
          if (attr.prefix == "xmlns") {
            visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
          } else if (attr.nodeName == "xmlns") {
            visibleNamespaces.push({ prefix: "", namespace: attr.value });
          }
        }
        for (var i = 0; i < len; i++) {
          var attr = attrs.item(i);
          if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
            var prefix = attr.prefix || "";
            var uri = attr.namespaceURI;
            addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
            visibleNamespaces.push({ prefix, namespace: uri });
          }
          serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
        }
        if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
          var prefix = node.prefix || "";
          var uri = node.namespaceURI;
          addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
          visibleNamespaces.push({ prefix, namespace: uri });
        }
        if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
          buf.push(">");
          if (isHTML && /^script$/i.test(nodeName)) {
            while (child) {
              if (child.data) {
                buf.push(child.data);
              } else {
                serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
              }
              child = child.nextSibling;
            }
          } else {
            while (child) {
              serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
              child = child.nextSibling;
            }
          }
          buf.push("</", prefixedNodeName, ">");
        } else {
          buf.push("/>");
        }
        return;
      case DOCUMENT_NODE:
      case DOCUMENT_FRAGMENT_NODE:
        var child = node.firstChild;
        while (child) {
          serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
          child = child.nextSibling;
        }
        return;
      case ATTRIBUTE_NODE:
        return addSerializedAttribute(buf, node.name, node.value);
      case TEXT_NODE:
        return buf.push(
          node.data.replace(/[<&>]/g, _xmlEncoder)
        );
      case CDATA_SECTION_NODE:
        return buf.push("<![CDATA[", node.data, "]]>");
      case COMMENT_NODE:
        return buf.push("<!--", node.data, "-->");
      case DOCUMENT_TYPE_NODE:
        var pubid = node.publicId;
        var sysid = node.systemId;
        buf.push("<!DOCTYPE ", node.name);
        if (pubid) {
          buf.push(" PUBLIC ", pubid);
          if (sysid && sysid != ".") {
            buf.push(" ", sysid);
          }
          buf.push(">");
        } else if (sysid && sysid != ".") {
          buf.push(" SYSTEM ", sysid, ">");
        } else {
          var sub = node.internalSubset;
          if (sub) {
            buf.push(" [", sub, "]");
          }
          buf.push(">");
        }
        return;
      case PROCESSING_INSTRUCTION_NODE:
        return buf.push("<?", node.target, " ", node.data, "?>");
      case ENTITY_REFERENCE_NODE:
        return buf.push("&", node.nodeName, ";");
      default:
        buf.push("??", node.nodeName);
    }
  }
  function importNode(doc, node, deep) {
    var node2;
    switch (node.nodeType) {
      case ELEMENT_NODE:
        node2 = node.cloneNode(false);
        node2.ownerDocument = doc;
      case DOCUMENT_FRAGMENT_NODE:
        break;
      case ATTRIBUTE_NODE:
        deep = true;
        break;
    }
    if (!node2) {
      node2 = node.cloneNode(false);
    }
    node2.ownerDocument = doc;
    node2.parentNode = null;
    if (deep) {
      var child = node.firstChild;
      while (child) {
        node2.appendChild(importNode(doc, child, deep));
        child = child.nextSibling;
      }
    }
    return node2;
  }
  function cloneNode(doc, node, deep) {
    var node2 = new node.constructor();
    for (var n in node) {
      if (Object.prototype.hasOwnProperty.call(node, n)) {
        var v2 = node[n];
        if (typeof v2 != "object") {
          if (v2 != node2[n]) {
            node2[n] = v2;
          }
        }
      }
    }
    if (node.childNodes) {
      node2.childNodes = new NodeList();
    }
    node2.ownerDocument = doc;
    switch (node2.nodeType) {
      case ELEMENT_NODE:
        var attrs = node.attributes;
        var attrs2 = node2.attributes = new NamedNodeMap();
        var len = attrs.length;
        attrs2._ownerElement = node2;
        for (var i = 0; i < len; i++) {
          node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));
        }
        break;
        ;
      case ATTRIBUTE_NODE:
        deep = true;
    }
    if (deep) {
      var child = node.firstChild;
      while (child) {
        node2.appendChild(cloneNode(doc, child, deep));
        child = child.nextSibling;
      }
    }
    return node2;
  }
  function __set__(object, key, value3) {
    object[key] = value3;
  }
  try {
    if (Object.defineProperty) {
      let getTextContent = function(node) {
        switch (node.nodeType) {
          case ELEMENT_NODE:
          case DOCUMENT_FRAGMENT_NODE:
            var buf = [];
            node = node.firstChild;
            while (node) {
              if (node.nodeType !== 7 && node.nodeType !== 8) {
                buf.push(getTextContent(node));
              }
              node = node.nextSibling;
            }
            return buf.join("");
          default:
            return node.nodeValue;
        }
      };
      Object.defineProperty(LiveNodeList.prototype, "length", {
        get: function() {
          _updateLiveList(this);
          return this.$$length;
        }
      });
      Object.defineProperty(Node.prototype, "textContent", {
        get: function() {
          return getTextContent(this);
        },
        set: function(data) {
          switch (this.nodeType) {
            case ELEMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE:
              while (this.firstChild) {
                this.removeChild(this.firstChild);
              }
              if (data || String(data)) {
                this.appendChild(this.ownerDocument.createTextNode(data));
              }
              break;
            default:
              this.data = data;
              this.value = data;
              this.nodeValue = data;
          }
        }
      });
      __set__ = function(object, key, value3) {
        object["$$" + key] = value3;
      };
    }
  } catch (e) {
  }
  var DocumentType_1 = DocumentType;
  var DOMException_1 = DOMException;
  var DOMImplementation_1 = DOMImplementation$2;
  var Element_1 = Element2;
  var Node_1 = Node;
  var NodeList_1 = NodeList;
  var XMLSerializer_1 = XMLSerializer$1;
  var dom = {
    DocumentType: DocumentType_1,
    DOMException: DOMException_1,
    DOMImplementation: DOMImplementation_1,
    Element: Element_1,
    Node: Node_1,
    NodeList: NodeList_1,
    XMLSerializer: XMLSerializer_1
  };
  var entities = createCommonjsModule(function(module2, exports) {
    var freeze2 = conventions.freeze;
    exports.XML_ENTITIES = freeze2({ amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' });
    exports.HTML_ENTITIES = freeze2({
      lt: "<",
      gt: ">",
      amp: "&",
      quot: '"',
      apos: "'",
      Agrave: "\xC0",
      Aacute: "\xC1",
      Acirc: "\xC2",
      Atilde: "\xC3",
      Auml: "\xC4",
      Aring: "\xC5",
      AElig: "\xC6",
      Ccedil: "\xC7",
      Egrave: "\xC8",
      Eacute: "\xC9",
      Ecirc: "\xCA",
      Euml: "\xCB",
      Igrave: "\xCC",
      Iacute: "\xCD",
      Icirc: "\xCE",
      Iuml: "\xCF",
      ETH: "\xD0",
      Ntilde: "\xD1",
      Ograve: "\xD2",
      Oacute: "\xD3",
      Ocirc: "\xD4",
      Otilde: "\xD5",
      Ouml: "\xD6",
      Oslash: "\xD8",
      Ugrave: "\xD9",
      Uacute: "\xDA",
      Ucirc: "\xDB",
      Uuml: "\xDC",
      Yacute: "\xDD",
      THORN: "\xDE",
      szlig: "\xDF",
      agrave: "\xE0",
      aacute: "\xE1",
      acirc: "\xE2",
      atilde: "\xE3",
      auml: "\xE4",
      aring: "\xE5",
      aelig: "\xE6",
      ccedil: "\xE7",
      egrave: "\xE8",
      eacute: "\xE9",
      ecirc: "\xEA",
      euml: "\xEB",
      igrave: "\xEC",
      iacute: "\xED",
      icirc: "\xEE",
      iuml: "\xEF",
      eth: "\xF0",
      ntilde: "\xF1",
      ograve: "\xF2",
      oacute: "\xF3",
      ocirc: "\xF4",
      otilde: "\xF5",
      ouml: "\xF6",
      oslash: "\xF8",
      ugrave: "\xF9",
      uacute: "\xFA",
      ucirc: "\xFB",
      uuml: "\xFC",
      yacute: "\xFD",
      thorn: "\xFE",
      yuml: "\xFF",
      nbsp: "\xA0",
      iexcl: "\xA1",
      cent: "\xA2",
      pound: "\xA3",
      curren: "\xA4",
      yen: "\xA5",
      brvbar: "\xA6",
      sect: "\xA7",
      uml: "\xA8",
      copy: "\xA9",
      ordf: "\xAA",
      laquo: "\xAB",
      not: "\xAC",
      shy: "\xAD\xAD",
      reg: "\xAE",
      macr: "\xAF",
      deg: "\xB0",
      plusmn: "\xB1",
      sup2: "\xB2",
      sup3: "\xB3",
      acute: "\xB4",
      micro: "\xB5",
      para: "\xB6",
      middot: "\xB7",
      cedil: "\xB8",
      sup1: "\xB9",
      ordm: "\xBA",
      raquo: "\xBB",
      frac14: "\xBC",
      frac12: "\xBD",
      frac34: "\xBE",
      iquest: "\xBF",
      times: "\xD7",
      divide: "\xF7",
      forall: "\u2200",
      part: "\u2202",
      exist: "\u2203",
      empty: "\u2205",
      nabla: "\u2207",
      isin: "\u2208",
      notin: "\u2209",
      ni: "\u220B",
      prod: "\u220F",
      sum: "\u2211",
      minus: "\u2212",
      lowast: "\u2217",
      radic: "\u221A",
      prop: "\u221D",
      infin: "\u221E",
      ang: "\u2220",
      and: "\u2227",
      or: "\u2228",
      cap: "\u2229",
      cup: "\u222A",
      "int": "\u222B",
      there4: "\u2234",
      sim: "\u223C",
      cong: "\u2245",
      asymp: "\u2248",
      ne: "\u2260",
      equiv: "\u2261",
      le: "\u2264",
      ge: "\u2265",
      sub: "\u2282",
      sup: "\u2283",
      nsub: "\u2284",
      sube: "\u2286",
      supe: "\u2287",
      oplus: "\u2295",
      otimes: "\u2297",
      perp: "\u22A5",
      sdot: "\u22C5",
      Alpha: "\u0391",
      Beta: "\u0392",
      Gamma: "\u0393",
      Delta: "\u0394",
      Epsilon: "\u0395",
      Zeta: "\u0396",
      Eta: "\u0397",
      Theta: "\u0398",
      Iota: "\u0399",
      Kappa: "\u039A",
      Lambda: "\u039B",
      Mu: "\u039C",
      Nu: "\u039D",
      Xi: "\u039E",
      Omicron: "\u039F",
      Pi: "\u03A0",
      Rho: "\u03A1",
      Sigma: "\u03A3",
      Tau: "\u03A4",
      Upsilon: "\u03A5",
      Phi: "\u03A6",
      Chi: "\u03A7",
      Psi: "\u03A8",
      Omega: "\u03A9",
      alpha: "\u03B1",
      beta: "\u03B2",
      gamma: "\u03B3",
      delta: "\u03B4",
      epsilon: "\u03B5",
      zeta: "\u03B6",
      eta: "\u03B7",
      theta: "\u03B8",
      iota: "\u03B9",
      kappa: "\u03BA",
      lambda: "\u03BB",
      mu: "\u03BC",
      nu: "\u03BD",
      xi: "\u03BE",
      omicron: "\u03BF",
      pi: "\u03C0",
      rho: "\u03C1",
      sigmaf: "\u03C2",
      sigma: "\u03C3",
      tau: "\u03C4",
      upsilon: "\u03C5",
      phi: "\u03C6",
      chi: "\u03C7",
      psi: "\u03C8",
      omega: "\u03C9",
      thetasym: "\u03D1",
      upsih: "\u03D2",
      piv: "\u03D6",
      OElig: "\u0152",
      oelig: "\u0153",
      Scaron: "\u0160",
      scaron: "\u0161",
      Yuml: "\u0178",
      fnof: "\u0192",
      circ: "\u02C6",
      tilde: "\u02DC",
      ensp: "\u2002",
      emsp: "\u2003",
      thinsp: "\u2009",
      zwnj: "\u200C",
      zwj: "\u200D",
      lrm: "\u200E",
      rlm: "\u200F",
      ndash: "\u2013",
      mdash: "\u2014",
      lsquo: "\u2018",
      rsquo: "\u2019",
      sbquo: "\u201A",
      ldquo: "\u201C",
      rdquo: "\u201D",
      bdquo: "\u201E",
      dagger: "\u2020",
      Dagger: "\u2021",
      bull: "\u2022",
      hellip: "\u2026",
      permil: "\u2030",
      prime: "\u2032",
      Prime: "\u2033",
      lsaquo: "\u2039",
      rsaquo: "\u203A",
      oline: "\u203E",
      euro: "\u20AC",
      trade: "\u2122",
      larr: "\u2190",
      uarr: "\u2191",
      rarr: "\u2192",
      darr: "\u2193",
      harr: "\u2194",
      crarr: "\u21B5",
      lceil: "\u2308",
      rceil: "\u2309",
      lfloor: "\u230A",
      rfloor: "\u230B",
      loz: "\u25CA",
      spades: "\u2660",
      clubs: "\u2663",
      hearts: "\u2665",
      diams: "\u2666"
    });
    exports.entityMap = exports.HTML_ENTITIES;
  });
  var NAMESPACE$1 = conventions.NAMESPACE;
  var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
  var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
  var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
  var S_TAG = 0;
  var S_ATTR = 1;
  var S_ATTR_SPACE = 2;
  var S_EQ = 3;
  var S_ATTR_NOQUOT_VALUE = 4;
  var S_ATTR_END = 5;
  var S_TAG_SPACE = 6;
  var S_TAG_CLOSE = 7;
  function ParseError$1(message, locator) {
    this.message = message;
    this.locator = locator;
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, ParseError$1);
  }
  ParseError$1.prototype = new Error();
  ParseError$1.prototype.name = ParseError$1.name;
  function XMLReader$1() {
  }
  XMLReader$1.prototype = {
    parse: function(source, defaultNSMap, entityMap) {
      var domBuilder = this.domBuilder;
      domBuilder.startDocument();
      _copy(defaultNSMap, defaultNSMap = {});
      parse(
        source,
        defaultNSMap,
        entityMap,
        domBuilder,
        this.errorHandler
      );
      domBuilder.endDocument();
    }
  };
  function parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
    function fixedFromCharCode(code) {
      if (code > 65535) {
        code -= 65536;
        var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
        return String.fromCharCode(surrogate1, surrogate2);
      } else {
        return String.fromCharCode(code);
      }
    }
    function entityReplacer(a3) {
      var k = a3.slice(1, -1);
      if (Object.hasOwnProperty.call(entityMap, k)) {
        return entityMap[k];
      } else if (k.charAt(0) === "#") {
        return fixedFromCharCode(parseInt(k.substr(1).replace("x", "0x")));
      } else {
        errorHandler.error("entity not found:" + a3);
        return a3;
      }
    }
    function appendText(end2) {
      if (end2 > start) {
        var xt = source.substring(start, end2).replace(/&#?\w+;/g, entityReplacer);
        locator && position2(start);
        domBuilder.characters(xt, 0, end2 - start);
        start = end2;
      }
    }
    function position2(p, m) {
      while (p >= lineEnd && (m = linePattern.exec(source))) {
        lineStart = m.index;
        lineEnd = lineStart + m[0].length;
        locator.lineNumber++;
      }
      locator.columnNumber = p - lineStart + 1;
    }
    var lineStart = 0;
    var lineEnd = 0;
    var linePattern = /.*(?:\r\n?|\n)|.*$/g;
    var locator = domBuilder.locator;
    var parseStack = [{ currentNSMap: defaultNSMapCopy }];
    var closeMap = {};
    var start = 0;
    while (true) {
      try {
        var tagStart = source.indexOf("<", start);
        if (tagStart < 0) {
          if (!source.substr(start).match(/^\s*$/)) {
            var doc = domBuilder.doc;
            var text = doc.createTextNode(source.substr(start));
            doc.appendChild(text);
            domBuilder.currentElement = text;
          }
          return;
        }
        if (tagStart > start) {
          appendText(tagStart);
        }
        switch (source.charAt(tagStart + 1)) {
          case "/":
            var end = source.indexOf(">", tagStart + 3);
            var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, "");
            var config = parseStack.pop();
            if (end < 0) {
              tagName = source.substring(tagStart + 2).replace(/[\s<].*/, "");
              errorHandler.error("end tag name: " + tagName + " is not complete:" + config.tagName);
              end = tagStart + 1 + tagName.length;
            } else if (tagName.match(/\s</)) {
              tagName = tagName.replace(/[\s<].*/, "");
              errorHandler.error("end tag name: " + tagName + " maybe not complete");
              end = tagStart + 1 + tagName.length;
            }
            var localNSMap = config.localNSMap;
            var endMatch = config.tagName == tagName;
            var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();
            if (endIgnoreCaseMach) {
              domBuilder.endElement(config.uri, config.localName, tagName);
              if (localNSMap) {
                for (var prefix in localNSMap) {
                  if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                    domBuilder.endPrefixMapping(prefix);
                  }
                }
              }
              if (!endMatch) {
                errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config.tagName);
              }
            } else {
              parseStack.push(config);
            }
            end++;
            break;
          case "?":
            locator && position2(tagStart);
            end = parseInstruction(source, tagStart, domBuilder);
            break;
          case "!":
            locator && position2(tagStart);
            end = parseDCC(source, tagStart, domBuilder, errorHandler);
            break;
          default:
            locator && position2(tagStart);
            var el = new ElementAttributes();
            var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
            var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);
            var len = el.length;
            if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {
              el.closed = true;
              if (!entityMap.nbsp) {
                errorHandler.warning("unclosed xml attribute");
              }
            }
            if (locator && len) {
              var locator2 = copyLocator(locator, {});
              for (var i = 0; i < len; i++) {
                var a2 = el[i];
                position2(a2.offset);
                a2.locator = copyLocator(locator, {});
              }
              domBuilder.locator = locator2;
              if (appendElement$1(el, domBuilder, currentNSMap)) {
                parseStack.push(el);
              }
              domBuilder.locator = locator;
            } else {
              if (appendElement$1(el, domBuilder, currentNSMap)) {
                parseStack.push(el);
              }
            }
            if (NAMESPACE$1.isHTML(el.uri) && !el.closed) {
              end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);
            } else {
              end++;
            }
        }
      } catch (e) {
        if (e instanceof ParseError$1) {
          throw e;
        }
        errorHandler.error("element parse error: " + e);
        end = -1;
      }
      if (end > start) {
        start = end;
      } else {
        appendText(Math.max(tagStart, start) + 1);
      }
    }
  }
  function copyLocator(f, t) {
    t.lineNumber = f.lineNumber;
    t.columnNumber = f.columnNumber;
    return t;
  }
  function parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler) {
    function addAttribute(qname, value4, startIndex) {
      if (el.attributeNames.hasOwnProperty(qname)) {
        errorHandler.fatalError("Attribute " + qname + " redefined");
      }
      el.addValue(
        qname,
        // @see https://www.w3.org/TR/xml/#AVNormalize
        // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
        // - recursive replacement of (DTD) entity references
        // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
        value4.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, entityReplacer),
        startIndex
      );
    }
    var attrName;
    var value3;
    var p = ++start;
    var s = S_TAG;
    while (true) {
      var c = source.charAt(p);
      switch (c) {
        case "=":
          if (s === S_ATTR) {
            attrName = source.slice(start, p);
            s = S_EQ;
          } else if (s === S_ATTR_SPACE) {
            s = S_EQ;
          } else {
            throw new Error("attribute equal must after attrName");
          }
          break;
        case "'":
        case '"':
          if (s === S_EQ || s === S_ATTR) {
            if (s === S_ATTR) {
              errorHandler.warning('attribute value must after "="');
              attrName = source.slice(start, p);
            }
            start = p + 1;
            p = source.indexOf(c, start);
            if (p > 0) {
              value3 = source.slice(start, p);
              addAttribute(attrName, value3, start - 1);
              s = S_ATTR_END;
            } else {
              throw new Error("attribute value no end '" + c + "' match");
            }
          } else if (s == S_ATTR_NOQUOT_VALUE) {
            value3 = source.slice(start, p);
            addAttribute(attrName, value3, start);
            errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ")!!");
            start = p + 1;
            s = S_ATTR_END;
          } else {
            throw new Error('attribute value must after "="');
          }
          break;
        case "/":
          switch (s) {
            case S_TAG:
              el.setTagName(source.slice(start, p));
            case S_ATTR_END:
            case S_TAG_SPACE:
            case S_TAG_CLOSE:
              s = S_TAG_CLOSE;
              el.closed = true;
            case S_ATTR_NOQUOT_VALUE:
            case S_ATTR:
            case S_ATTR_SPACE:
              break;
            default:
              throw new Error("attribute invalid close char('/')");
          }
          break;
        case "":
          errorHandler.error("unexpected end of input");
          if (s == S_TAG) {
            el.setTagName(source.slice(start, p));
          }
          return p;
        case ">":
          switch (s) {
            case S_TAG:
              el.setTagName(source.slice(start, p));
            case S_ATTR_END:
            case S_TAG_SPACE:
            case S_TAG_CLOSE:
              break;
            case S_ATTR_NOQUOT_VALUE:
            case S_ATTR:
              value3 = source.slice(start, p);
              if (value3.slice(-1) === "/") {
                el.closed = true;
                value3 = value3.slice(0, -1);
              }
            case S_ATTR_SPACE:
              if (s === S_ATTR_SPACE) {
                value3 = attrName;
              }
              if (s == S_ATTR_NOQUOT_VALUE) {
                errorHandler.warning('attribute "' + value3 + '" missed quot(")!');
                addAttribute(attrName, value3, start);
              } else {
                if (!NAMESPACE$1.isHTML(currentNSMap[""]) || !value3.match(/^(?:disabled|checked|selected)$/i)) {
                  errorHandler.warning('attribute "' + value3 + '" missed value!! "' + value3 + '" instead!!');
                }
                addAttribute(value3, value3, start);
              }
              break;
            case S_EQ:
              throw new Error("attribute value missed!!");
          }
          return p;
        case "\x80":
          c = " ";
        default:
          if (c <= " ") {
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start, p));
                s = S_TAG_SPACE;
                break;
              case S_ATTR:
                attrName = source.slice(start, p);
                s = S_ATTR_SPACE;
                break;
              case S_ATTR_NOQUOT_VALUE:
                var value3 = source.slice(start, p);
                errorHandler.warning('attribute "' + value3 + '" missed quot(")!!');
                addAttribute(attrName, value3, start);
              case S_ATTR_END:
                s = S_TAG_SPACE;
                break;
            }
          } else {
            switch (s) {
              case S_ATTR_SPACE:
                var tagName = el.tagName;
                if (!NAMESPACE$1.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                  errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                }
                addAttribute(attrName, attrName, start);
                start = p;
                s = S_ATTR;
                break;
              case S_ATTR_END:
                errorHandler.warning('attribute space is required"' + attrName + '"!!');
              case S_TAG_SPACE:
                s = S_ATTR;
                start = p;
                break;
              case S_EQ:
                s = S_ATTR_NOQUOT_VALUE;
                start = p;
                break;
              case S_TAG_CLOSE:
                throw new Error("elements closed character '/' and '>' must be connected to");
            }
          }
      }
      p++;
    }
  }
  function appendElement$1(el, domBuilder, currentNSMap) {
    var tagName = el.tagName;
    var localNSMap = null;
    var i = el.length;
    while (i--) {
      var a2 = el[i];
      var qName = a2.qName;
      var value3 = a2.value;
      var nsp = qName.indexOf(":");
      if (nsp > 0) {
        var prefix = a2.prefix = qName.slice(0, nsp);
        var localName = qName.slice(nsp + 1);
        var nsPrefix = prefix === "xmlns" && localName;
      } else {
        localName = qName;
        prefix = null;
        nsPrefix = qName === "xmlns" && "";
      }
      a2.localName = localName;
      if (nsPrefix !== false) {
        if (localNSMap == null) {
          localNSMap = {};
          _copy(currentNSMap, currentNSMap = {});
        }
        currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value3;
        a2.uri = NAMESPACE$1.XMLNS;
        domBuilder.startPrefixMapping(nsPrefix, value3);
      }
    }
    var i = el.length;
    while (i--) {
      a2 = el[i];
      var prefix = a2.prefix;
      if (prefix) {
        if (prefix === "xml") {
          a2.uri = NAMESPACE$1.XML;
        }
        if (prefix !== "xmlns") {
          a2.uri = currentNSMap[prefix || ""];
        }
      }
    }
    var nsp = tagName.indexOf(":");
    if (nsp > 0) {
      prefix = el.prefix = tagName.slice(0, nsp);
      localName = el.localName = tagName.slice(nsp + 1);
    } else {
      prefix = null;
      localName = el.localName = tagName;
    }
    var ns = el.uri = currentNSMap[prefix || ""];
    domBuilder.startElement(ns, localName, tagName, el);
    if (el.closed) {
      domBuilder.endElement(ns, localName, tagName);
      if (localNSMap) {
        for (prefix in localNSMap) {
          if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
            domBuilder.endPrefixMapping(prefix);
          }
        }
      }
    } else {
      el.currentNSMap = currentNSMap;
      el.localNSMap = localNSMap;
      return true;
    }
  }
  function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
    if (/^(?:script|textarea)$/i.test(tagName)) {
      var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
      var text = source.substring(elStartEnd + 1, elEndStart);
      if (/[&<]/.test(text)) {
        if (/^script$/i.test(tagName)) {
          domBuilder.characters(text, 0, text.length);
          return elEndStart;
        }
        text = text.replace(/&#?\w+;/g, entityReplacer);
        domBuilder.characters(text, 0, text.length);
        return elEndStart;
      }
    }
    return elStartEnd + 1;
  }
  function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
    var pos = closeMap[tagName];
    if (pos == null) {
      pos = source.lastIndexOf("</" + tagName + ">");
      if (pos < elStartEnd) {
        pos = source.lastIndexOf("</" + tagName);
      }
      closeMap[tagName] = pos;
    }
    return pos < elStartEnd;
  }
  function _copy(source, target2) {
    for (var n in source) {
      if (Object.prototype.hasOwnProperty.call(source, n)) {
        target2[n] = source[n];
      }
    }
  }
  function parseDCC(source, start, domBuilder, errorHandler) {
    var next = source.charAt(start + 2);
    switch (next) {
      case "-":
        if (source.charAt(start + 3) === "-") {
          var end = source.indexOf("-->", start + 4);
          if (end > start) {
            domBuilder.comment(source, start + 4, end - start - 4);
            return end + 3;
          } else {
            errorHandler.error("Unclosed comment");
            return -1;
          }
        } else {
          return -1;
        }
      default:
        if (source.substr(start + 3, 6) == "CDATA[") {
          var end = source.indexOf("]]>", start + 9);
          domBuilder.startCDATA();
          domBuilder.characters(source, start + 9, end - start - 9);
          domBuilder.endCDATA();
          return end + 3;
        }
        var matchs = split(source, start);
        var len = matchs.length;
        if (len > 1 && /!doctype/i.test(matchs[0][0])) {
          var name = matchs[1][0];
          var pubid = false;
          var sysid = false;
          if (len > 3) {
            if (/^public$/i.test(matchs[2][0])) {
              pubid = matchs[3][0];
              sysid = len > 4 && matchs[4][0];
            } else if (/^system$/i.test(matchs[2][0])) {
              sysid = matchs[3][0];
            }
          }
          var lastMatch = matchs[len - 1];
          domBuilder.startDTD(name, pubid, sysid);
          domBuilder.endDTD();
          return lastMatch.index + lastMatch[0].length;
        }
    }
    return -1;
  }
  function parseInstruction(source, start, domBuilder) {
    var end = source.indexOf("?>", start);
    if (end) {
      var match = source.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
      if (match) {
        var len = match[0].length;
        domBuilder.processingInstruction(match[1], match[2]);
        return end + 2;
      } else {
        return -1;
      }
    }
    return -1;
  }
  function ElementAttributes() {
    this.attributeNames = {};
  }
  ElementAttributes.prototype = {
    setTagName: function(tagName) {
      if (!tagNamePattern.test(tagName)) {
        throw new Error("invalid tagName:" + tagName);
      }
      this.tagName = tagName;
    },
    addValue: function(qName, value3, offset) {
      if (!tagNamePattern.test(qName)) {
        throw new Error("invalid attribute:" + qName);
      }
      this.attributeNames[qName] = this.length;
      this[this.length++] = { qName, value: value3, offset };
    },
    length: 0,
    getLocalName: function(i) {
      return this[i].localName;
    },
    getLocator: function(i) {
      return this[i].locator;
    },
    getQName: function(i) {
      return this[i].qName;
    },
    getURI: function(i) {
      return this[i].uri;
    },
    getValue: function(i) {
      return this[i].value;
    }
    //	,getIndex:function(uri, localName)){
    //		if(localName){
    //
    //		}else{
    //			var qName = uri
    //		}
    //	},
    //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
    //	getType:function(uri,localName){}
    //	getType:function(i){},
  };
  function split(source, start) {
    var match;
    var buf = [];
    var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
    reg.lastIndex = start;
    reg.exec(source);
    while (match = reg.exec(source)) {
      buf.push(match);
      if (match[1])
        return buf;
    }
  }
  var XMLReader_1 = XMLReader$1;
  var ParseError_1 = ParseError$1;
  var sax = {
    XMLReader: XMLReader_1,
    ParseError: ParseError_1
  };
  var DOMImplementation$1 = dom.DOMImplementation;
  var NAMESPACE = conventions.NAMESPACE;
  var ParseError = sax.ParseError;
  var XMLReader = sax.XMLReader;
  function normalizeLineEndings(input) {
    return input.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028]/g, "\n");
  }
  function DOMParser$2(options) {
    this.options = options || { locator: {} };
  }
  DOMParser$2.prototype.parseFromString = function(source, mimeType) {
    var options = this.options;
    var sax2 = new XMLReader();
    var domBuilder = options.domBuilder || new DOMHandler();
    var errorHandler = options.errorHandler;
    var locator = options.locator;
    var defaultNSMap = options.xmlns || {};
    var isHTML = /\/x?html?$/.test(mimeType);
    var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
    if (locator) {
      domBuilder.setDocumentLocator(locator);
    }
    sax2.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
    sax2.domBuilder = options.domBuilder || domBuilder;
    if (isHTML) {
      defaultNSMap[""] = NAMESPACE.HTML;
    }
    defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
    var normalize = options.normalizeLineEndings || normalizeLineEndings;
    if (source && typeof source === "string") {
      sax2.parse(
        normalize(source),
        defaultNSMap,
        entityMap
      );
    } else {
      sax2.errorHandler.error("invalid doc source");
    }
    return domBuilder.doc;
  };
  function buildErrorHandler(errorImpl, domBuilder, locator) {
    if (!errorImpl) {
      if (domBuilder instanceof DOMHandler) {
        return domBuilder;
      }
      errorImpl = domBuilder;
    }
    var errorHandler = {};
    var isCallback = errorImpl instanceof Function;
    locator = locator || {};
    function build(key) {
      var fn = errorImpl[key];
      if (!fn && isCallback) {
        fn = errorImpl.length == 2 ? function(msg) {
          errorImpl(key, msg);
        } : errorImpl;
      }
      errorHandler[key] = fn && function(msg) {
        fn("[xmldom " + key + "]	" + msg + _locator(locator));
      } || function() {
      };
    }
    build("warning");
    build("error");
    build("fatalError");
    return errorHandler;
  }
  function DOMHandler() {
    this.cdata = false;
  }
  function position(locator, node) {
    node.lineNumber = locator.lineNumber;
    node.columnNumber = locator.columnNumber;
  }
  DOMHandler.prototype = {
    startDocument: function() {
      this.doc = new DOMImplementation$1().createDocument(null, null, null);
      if (this.locator) {
        this.doc.documentURI = this.locator.systemId;
      }
    },
    startElement: function(namespaceURI, localName, qName, attrs) {
      var doc = this.doc;
      var el = doc.createElementNS(namespaceURI, qName || localName);
      var len = attrs.length;
      appendElement(this, el);
      this.currentElement = el;
      this.locator && position(this.locator, el);
      for (var i = 0; i < len; i++) {
        var namespaceURI = attrs.getURI(i);
        var value3 = attrs.getValue(i);
        var qName = attrs.getQName(i);
        var attr = doc.createAttributeNS(namespaceURI, qName);
        this.locator && position(attrs.getLocator(i), attr);
        attr.value = attr.nodeValue = value3;
        el.setAttributeNode(attr);
      }
    },
    endElement: function(namespaceURI, localName, qName) {
      var current = this.currentElement;
      var tagName = current.tagName;
      this.currentElement = current.parentNode;
    },
    startPrefixMapping: function(prefix, uri) {
    },
    endPrefixMapping: function(prefix) {
    },
    processingInstruction: function(target2, data) {
      var ins = this.doc.createProcessingInstruction(target2, data);
      this.locator && position(this.locator, ins);
      appendElement(this, ins);
    },
    ignorableWhitespace: function(ch, start, length) {
    },
    characters: function(chars, start, length) {
      chars = _toString.apply(this, arguments);
      if (chars) {
        if (this.cdata) {
          var charNode = this.doc.createCDATASection(chars);
        } else {
          var charNode = this.doc.createTextNode(chars);
        }
        if (this.currentElement) {
          this.currentElement.appendChild(charNode);
        } else if (/^\s*$/.test(chars)) {
          this.doc.appendChild(charNode);
        }
        this.locator && position(this.locator, charNode);
      }
    },
    skippedEntity: function(name) {
    },
    endDocument: function() {
      this.doc.normalize();
    },
    setDocumentLocator: function(locator) {
      if (this.locator = locator) {
        locator.lineNumber = 0;
      }
    },
    //LexicalHandler
    comment: function(chars, start, length) {
      chars = _toString.apply(this, arguments);
      var comm = this.doc.createComment(chars);
      this.locator && position(this.locator, comm);
      appendElement(this, comm);
    },
    startCDATA: function() {
      this.cdata = true;
    },
    endCDATA: function() {
      this.cdata = false;
    },
    startDTD: function(name, publicId, systemId) {
      var impl = this.doc.implementation;
      if (impl && impl.createDocumentType) {
        var dt = impl.createDocumentType(name, publicId, systemId);
        this.locator && position(this.locator, dt);
        appendElement(this, dt);
        this.doc.doctype = dt;
      }
    },
    /**
     * @see org.xml.sax.ErrorHandler
     * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
     */
    warning: function(error) {
      console.warn("[xmldom warning]	" + error, _locator(this.locator));
    },
    error: function(error) {
      console.error("[xmldom error]	" + error, _locator(this.locator));
    },
    fatalError: function(error) {
      throw new ParseError(error, this.locator);
    }
  };
  function _locator(l) {
    if (l) {
      return "\n@" + (l.systemId || "") + "#[line:" + l.lineNumber + ",col:" + l.columnNumber + "]";
    }
  }
  function _toString(chars, start, length) {
    if (typeof chars == "string") {
      return chars.substr(start, length);
    } else {
      if (chars.length >= start + length || start) {
        return new java.lang.String(chars, start, length) + "";
      }
      return chars;
    }
  }
  "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
    DOMHandler.prototype[key] = function() {
      return null;
    };
  });
  function appendElement(hander, node) {
    if (!hander.currentElement) {
      hander.doc.appendChild(node);
    } else {
      hander.currentElement.appendChild(node);
    }
  }
  var __DOMHandler = DOMHandler;
  var normalizeLineEndings_1 = normalizeLineEndings;
  var DOMParser_1 = DOMParser$2;
  var domParser = {
    __DOMHandler,
    normalizeLineEndings: normalizeLineEndings_1,
    DOMParser: DOMParser_1
  };
  var DOMImplementation = dom.DOMImplementation;
  var XMLSerializer = dom.XMLSerializer;
  var DOMParser$1 = domParser.DOMParser;
  var WebWorkerAdapter = {
    createCanvas: (width, height) => new OffscreenCanvas(width | 0, height | 0),
    getWebGLRenderingContext: () => WebGLRenderingContext,
    getNavigator: () => navigator,
    getBaseUrl: () => globalThis.location.href,
    getFontFaceSet: () => globalThis.fonts,
    fetch: (url2, options) => fetch(url2, options),
    parseXML: (xml) => {
      const parser = new DOMParser$1();
      return parser.parseFromString(xml, "text/xml");
    }
  };
  settings.ADAPTER = WebWorkerAdapter;
  var filters = {
    AlphaFilter,
    BlurFilter,
    BlurFilterPass,
    ColorMatrixFilter,
    DisplacementFilter,
    FXAAFilter,
    NoiseFilter
  };

  // node_modules/request-animation-frame-polyfill/dist/index.esm.min.js
  var uId = 1;
  var root = "object" == typeof self && self.self == self ? self : "object" == typeof global && global.global == global ? global : {};
  var nowOffset = Date.now();
  var reservedCBs = {};
  var lastTime = Date.now();
  var polyfillRaf = (e) => {
    if ("function" != typeof e)
      throw new TypeError(e + " is not a function");
    const o = Date.now(), t = o - lastTime, n = t > 16 ? 0 : 16 - t, r = uId++;
    return reservedCBs[r] = e, Object.keys(reservedCBs).length > 1 || setTimeout(() => {
      lastTime = o;
      const e2 = reservedCBs;
      reservedCBs = {}, Object.keys(e2).forEach((o2) => e2[o2](root.performance && "function" == typeof root.performance.now ? root.performance.now() : Date.now() - nowOffset));
    }, n), r;
  };
  var polyfillCaf = (e) => {
    delete reservedCBs[e];
  };
  var vendorPrefixes = ["", "webkit", "moz", "ms", "o"];
  var getRequestAnimationFrame = (e) => "string" != typeof e ? polyfillRaf : "" === e ? root.requestAnimationFrame : root[e + "RequestAnimationFrame"];
  var getCancelAnimationFrame = (e) => "string" != typeof e ? polyfillCaf : "" === e ? root.cancelAnimationFrame : root[e + "CancelAnimationFrame"] || root[e + "CancelRequestAnimationFrame"];
  var find2 = (e, o) => {
    let t = 0;
    for (; void 0 !== e[t]; ) {
      if (o(e[t]))
        return e[t];
      t += 1;
    }
  };
  var vp = find2(vendorPrefixes, (e) => !!getRequestAnimationFrame(e));
  var raf = getRequestAnimationFrame(vp);
  var caf = getCancelAnimationFrame(vp);
  root.requestAnimationFrame = raf, root.cancelAnimationFrame = caf, "undefined" != typeof module && module.exports && (module.exports = { requestAnimationFrame: raf, cancelAnimationFrame: caf });

  // src-www/js/rpg_core/JsExtensions.js
  Number.prototype.clamp = function(min, max) {
    return Math.min(Math.max(this, min), max);
  };
  Number.prototype.mod = function(n) {
    return (this % n + n) % n;
  };
  String.prototype.format = function() {
    const args = arguments;
    return this.replace(/%([0-9]+)/g, (s, n) => args[Number(n) - 1]);
  };
  String.prototype.padZero = function(length) {
    let s = this;
    while (s.length < length) {
      s = `0${s}`;
    }
    return s;
  };
  Number.prototype.padZero = function(length) {
    return String(this).padZero(length);
  };
  Object.defineProperties(Array.prototype, {
    /**
     * Checks whether the two arrays are same.
     *
     * @method Array.prototype.equals
     * @param {Array} array The array to compare to
     * @return {Boolean} True if the two arrays are same
     */
    equals: {
      enumerable: false,
      value(array) {
        if (!array || this.length !== array.length) {
          return false;
        }
        for (let i = 0; i < this.length; i++) {
          if (this[i] instanceof Array && array[i] instanceof Array) {
            if (!this[i].equals(array[i])) {
              return false;
            }
          } else if (this[i] !== array[i]) {
            return false;
          }
        }
        return true;
      }
    },
    /**
     * Makes a shallow copy of the array.
     *
     * @method Array.prototype.clone
     * @return {Array} A shallow copy of the array
     */
    clone: {
      enumerable: false,
      value() {
        return this.slice(0);
      }
    },
    /**
     * Checks whether the array contains a given element.
     *
     * @method Array.prototype.contains
     * @param {Any} element The element to search for
     * @return {Boolean} True if the array contains a given element
     */
    contains: {
      enumerable: false,
      value(element) {
        return this.includes(element);
      }
    }
  });
  String.prototype.contains = function(string) {
    return this.includes(string);
  };
  Math.randomInt = (max) => Math.floor(max * Math.random());
  if (typeof self.requestAnimationFrame !== "function") {
    self.requestAnimationFrame = raf;
  }
  if (typeof self.cancelAnimationFrame !== "function") {
    self.cancelAnimationFrame = caf;
  }

  // src-www/js/rpg_core/CacheEntry.js
  var CacheEntry = class {
    constructor(cache, key, item2) {
      this.cache = cache;
      this.key = key;
      this.item = item2;
      this.cached = false;
      this.touchTicks = 0;
      this.touchSeconds = 0;
      this.ttlTicks = 0;
      this.ttlSeconds = 0;
      this.freedByTTL = false;
    }
    /**
     * frees the resource
     */
    free(byTTL) {
      this.freedByTTL = byTTL || false;
      if (this.cached) {
        this.cached = false;
        delete this.cache._inner[this.key];
      }
    }
    /**
     * Allocates the resource
     * @returns {CacheEntry}
     */
    allocate() {
      if (!this.cached) {
        this.cache._inner[this.key] = this;
        this.cached = true;
      }
      this.touch();
      return this;
    }
    /**
     * Sets the time to live
     * @param {number} ticks TTL in ticks, 0 if not set
     * @param {number} time TTL in seconds, 0 if not set
     * @returns {CacheEntry}
     */
    setTimeToLive(ticks, seconds) {
      this.ttlTicks = ticks || 0;
      this.ttlSeconds = seconds || 0;
      return this;
    }
    isStillAlive() {
      const cache = this.cache;
      return (this.ttlTicks == 0 || this.touchTicks + this.ttlTicks < cache.updateTicks) && (this.ttlSeconds == 0 || this.touchSeconds + this.ttlSeconds < cache.updateSeconds);
    }
    /**
     * makes sure that resource wont freed by Time To Live
     * if resource was already freed by TTL, put it in cache again
     */
    touch() {
      const cache = this.cache;
      if (this.cached) {
        this.touchTicks = cache.updateTicks;
        this.touchSeconds = cache.updateSeconds;
      } else if (this.freedByTTL) {
        this.freedByTTL = false;
        if (!cache._inner[this.key]) {
          cache._inner[this.key] = this;
        }
      }
    }
  };
  var CacheEntry_default = CacheEntry;

  // src-www/js/rpg_core/CacheMap.js
  var CacheMap = class {
    constructor(manager) {
      this.manager = manager;
      this._inner = {};
      this._lastRemovedEntries = {};
      this.updateTicks = 0;
      this.lastCheckTTL = 0;
      this.delayCheckTTL = 100;
      this.updateSeconds = Date.now();
    }
    /**
     * checks ttl of all elements and removes dead ones
     */
    checkTTL() {
      const cache = this._inner;
      let temp2 = this._lastRemovedEntries;
      if (!temp2) {
        temp2 = [];
        this._lastRemovedEntries = temp2;
      }
      for (let key in cache) {
        const entry = cache[key];
        if (!entry.isStillAlive()) {
          temp2.push(entry);
        }
      }
      for (let i = 0; i < temp2.length; i++) {
        temp2[i].free(true);
      }
      temp2.length = 0;
    }
    /**
     * cache item
     * @param key url of cache element
     * @returns {*|null}
     */
    getItem(key) {
      const entry = this._inner[key];
      if (entry) {
        return entry.item;
      }
      return null;
    }
    clear() {
      const keys = Object.keys(this._inner);
      for (let i = 0; i < keys.length; i++) {
        this._inner[keys[i]].free();
      }
    }
    setItem(key, item2) {
      return new CacheEntry_default(this, key, item2).allocate();
    }
    update(ticks, delta) {
      this.updateTicks += ticks;
      this.updateSeconds += delta;
      if (this.updateSeconds >= this.delayCheckTTL + this.lastCheckTTL) {
        this.lastCheckTTL = this.updateSeconds;
        this.checkTTL();
      }
    }
  };
  var CacheMap_default = CacheMap;

  // src-www/js/rpg_core/ImageCache.js
  var ImageCache = class {
    constructor(...args) {
      this.initialize(...args);
    }
    initialize() {
      this._items = {};
    }
    add(key, value3) {
      this._items[key] = {
        bitmap: value3,
        touch: Date.now(),
        key
      };
      this._truncateCache();
    }
    get(key) {
      if (this._items[key]) {
        const item2 = this._items[key];
        item2.touch = Date.now();
        return item2.bitmap;
      }
      return null;
    }
    reserve(key, value3, reservationId) {
      if (!this._items[key]) {
        this._items[key] = {
          bitmap: value3,
          touch: Date.now(),
          key
        };
      }
      this._items[key].reservationId = reservationId;
    }
    releaseReservation(reservationId) {
      const items = this._items;
      Object.keys(items).map((key) => items[key]).forEach((item2) => {
        if (item2.reservationId === reservationId) {
          delete item2.reservationId;
        }
      });
    }
    _truncateCache() {
      const items = this._items;
      let sizeLeft = ImageCache.limit;
      Object.keys(items).map((key) => items[key]).sort((a2, b2) => a2.touch - b2.touch).forEach((item2) => {
        if (sizeLeft > 0 || this._mustBeHeld(item2)) {
          const bitmap = item2.bitmap;
          sizeLeft -= bitmap.width * bitmap.height;
        } else {
          delete items[item2.key];
        }
      });
    }
    _mustBeHeld({ bitmap, reservationId }) {
      if (bitmap.isRequestOnly())
        return false;
      if (reservationId)
        return true;
      if (!bitmap.isReady())
        return true;
      return false;
    }
    isReady() {
      return !Object.keys(this._items).some(
        (key) => !this._items[key].bitmap.isRequestOnly() && !this._items[key].bitmap.isReady()
      );
    }
    getErrorBitmap() {
      const items = this._items;
      let bitmap = null;
      if (Object.keys(items).some((key) => {
        if (items[key].bitmap.isError()) {
          bitmap = items[key].bitmap;
          return true;
        }
        return false;
      })) {
        return bitmap;
      }
      return null;
    }
  };
  ImageCache.limit = 10 * 1e3 * 1e3;
  var ImageCache_default = ImageCache;

  // src-www/js/rpg_core/RequestQueue.js
  var RequestQueue = class {
    constructor(...args) {
      this.initialize(...args);
    }
    initialize() {
      this._queue = [];
    }
    enqueue(key, value3) {
      this._queue.push({
        key,
        value: value3
      });
    }
    update() {
      if (this._queue.length === 0)
        return;
      const top = this._queue[0];
      if (top.value.isRequestReady()) {
        this._queue.shift();
        if (this._queue.length !== 0) {
          this._queue[0].value.startRequest();
        }
      } else {
        top.value.startRequest();
      }
    }
    raisePriority(key) {
      for (let n = 0; n < this._queue.length; n++) {
        const item2 = this._queue[n];
        if (item2.key === key) {
          this._queue.splice(n, 1);
          this._queue.unshift(item2);
          break;
        }
      }
    }
    clear() {
      this._queue.splice(0);
    }
  };
  var RequestQueue_default = RequestQueue;

  // src-www/js/rpg_core/Utils.js
  var Utils = class {
    constructor() {
      throw new Error("This is a static class");
    }
    /**
     * Checks whether the option is in the query string.
     *
     * @static
     * @method isOptionValid
     * @param {String} name The option name
     * @return {Boolean} True if the option is in the query string
     */
    static isOptionValid(name) {
      if (location.search.slice(1).split("&").contains(name)) {
        return true;
      }
      if (typeof nw !== "undefined" && nw.App.argv.length > 0 && nw.App.argv[0].split("&").contains(name)) {
        return true;
      }
      return false;
    }
    /**
     * Checks whether the platform is NW.js.
     *
     * @static
     * @method isNwjs
     * @return {Boolean} True if the platform is NW.js
     */
    static isNwjs() {
      if (typeof Utils._nwjs === "boolean") {
        return Utils._nwjs;
      }
      const result2 = typeof __require === "function" && typeof process === "object";
      Utils._nwjs = result2;
      return result2;
    }
    /**
     * Checks whether the platform is Tauri.
     *
     * @static
     * @method isTauri
     * @return {Boolean} True if the platform is Tauri
     */
    static isTauri() {
      return !!window.__TAURI__;
    }
    /**
     * Checks whether refresh rate > 60hz.
     *
     * @static
     * @method isHighFps
     * @return {Boolean} True if refresh rate >= 66hz
     */
    static isHighFps() {
      if (Utils._fpsChecked) {
        return Utils._highFps;
      } else {
        return Utils.getFps() >= 66;
      }
    }
    /**
     * Returns estimated monitor refresh rate.
     *
     * @static
     * @method getFps
     * @return {Number} Refresh rate
     * @credit Adapted from Adam Sassano on Stack Overflow
     * @license CC BY-SA 4.0
     */
    static getFps() {
      if (Utils._fpsChecked || Utils._fpsIsBusyCounting) {
        return Utils._fps;
      } else {
        let previousTimestamp = 0;
        let count = 0;
        let rate = 0;
        const rafLoop = (timestamp) => {
          if (count <= 180) {
            count++;
            let interval = timestamp - previousTimestamp;
            rate += 1e3 / interval;
            previousTimestamp = timestamp;
            requestAnimationFrame(rafLoop);
          } else {
            if (Utils._fps !== Infinity) {
              Utils._fps = rate / count;
              if (Utils._fps >= 66) {
                Utils._highFps = true;
              }
            }
            Utils._fpsChecked = true;
            Utils._fpsIsBusyCounting = false;
          }
        };
        requestAnimationFrame((timestamp) => {
          previousTimestamp = timestamp;
          requestAnimationFrame(rafLoop);
        });
        Utils._fpsIsBusyCounting = true;
        return Utils._fps;
      }
    }
    /**
     * Checks whether the platform is a mobile device.
     *
     * @static
     * @method isMobileDevice
     * @return {Boolean} True if the platform is a mobile device
     */
    static isMobileDevice() {
      if (typeof Utils._mobileDevice === "boolean") {
        return Utils._mobileDevice;
      }
      const r = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i;
      const result2 = !!navigator.userAgent.match(r);
      Utils._mobileDevice = result2;
      return result2;
    }
    /**
     * Checks whether the browser is Mobile Safari.
     *
     * @static
     * @method isMobileSafari
     * @return {Boolean} True if the browser is Mobile Safari
     */
    static isMobileSafari() {
      if (typeof Utils._mobileSafari === "boolean") {
        return Utils._mobileSafari;
      }
      const agent = navigator.userAgent;
      const result2 = !!(agent.match(/iPhone|iPad|iPod/) && agent.match(/AppleWebKit/) && !agent.match("CriOS"));
      Utils._mobileSafari = result2;
      return result2;
    }
    /**
     * Checks whether the browser is Android Chrome.
     *
     * @static
     * @method isAndroidChrome
     * @return {Boolean} True if the browser is Android Chrome
     */
    static isAndroidChrome() {
      if (typeof Utils._androidChrome === "boolean") {
        return Utils._androidChrome;
      }
      const agent = navigator.userAgent;
      const result2 = !!(agent.match(/Android/) && agent.match(/Chrome/));
      Utils._androidChrome = result2;
      return result2;
    }
    /**
     * Checks whether the browser can read files in the game folder.
     *
     * @static
     * @method canReadGameFiles
     * @return {Boolean} True if the browser can read files in the game folder
     */
    static canReadGameFiles() {
      if (Utils.isWorker()) {
        console.log("Utils.canReadGameFiles is not supported on worker.");
        return true;
      }
      const scripts = document.getElementsByTagName("script");
      const lastScript = scripts[scripts.length - 1];
      const xhr = new XMLHttpRequest();
      try {
        xhr.open("GET", lastScript.src);
        xhr.overrideMimeType("text/javascript");
        xhr.send();
        return true;
      } catch (e) {
        return false;
      }
    }
    /**
     * Makes a CSS color string from RGB values.
     *
     * @static
     * @method rgbToCssColor
     * @param {Number} r The red value in the range (0, 255)
     * @param {Number} g The green value in the range (0, 255)
     * @param {Number} b The blue value in the range (0, 255)
     * @return {String} CSS color string
     */
    static rgbToCssColor(r, g, b2) {
      r = Math.round(r);
      g = Math.round(g);
      b2 = Math.round(b2);
      return `rgb(${r},${g},${b2})`;
    }
    static generateRuntimeId() {
      return Utils._id++;
    }
    /**
     * Test this browser support passive event feature
     *
     * @static
     * @method isSupportPassiveEvent
     * @return {Boolean} this browser support passive event or not
     */
    static isSupportPassiveEvent() {
      if (typeof Utils._supportPassiveEvent === "boolean") {
        return Utils._supportPassiveEvent;
      }
      let passive = false;
      const options = Object.defineProperty({}, "passive", {
        get() {
          passive = true;
        }
      });
      window.addEventListener("test", null, options);
      Utils._supportPassiveEvent = passive;
      return passive;
    }
    static isWorker() {
      return typeof importScripts === "function";
    }
    /**
     * Load a script regardless of environment
     *
     * @static
     * @method loadScript
     * @return {null || <script> DOMNode}
     */
    static loadScript(path2, module2) {
      if (this.isWorker()) {
        importScripts(path2);
        return null;
      } else {
        const script2 = document.createElement("script");
        script2.type = module2 ? "module" : "text/javascript";
        script2.src = path2;
        script2.async = false;
        document.body.appendChild(script2);
        return script2;
      }
    }
    /**
     * Returns a function that fires at the specified threshold
     *
     * @static
     * @method getThrottledFunction
     * @return {Function}
     */
    static getThrottledFunction(fn, threshold, scope) {
      let last;
      let deferTimer;
      return function() {
        const context2 = scope || this;
        const now = +/* @__PURE__ */ new Date();
        const args = arguments;
        if (last && now < last + threshold) {
          clearTimeout(deferTimer);
          deferTimer = setTimeout(() => {
            last = now;
            fn.apply(context2, args);
          }, threshold + last - now);
        } else {
          last = now;
          fn.apply(context2, args);
        }
      };
    }
  };
  Utils.RPGMAKER_NAME = "MV";
  Utils.RPGMAKER_VERSION = "1.6.1";
  Utils.RPGMAKER_ENGINE = "community-1.4";
  Utils._nwjs = null;
  Utils._highFps = false;
  Utils._fps = 60;
  Utils._fpsIsBusyCounting = false;
  Utils._fpsChecked = false;
  Utils._mobileDevice = null;
  Utils._mobileSafari = null;
  Utils._androidChrome = null;
  Utils._id = 1;
  Utils._supportPassiveEvent = null;
  var Utils_default = Utils;

  // src-www/js/rpg_core/WebAudio.js
  var WebAudio = class {
    constructor(...args) {
      this.initialize(...args);
    }
    initialize(url2) {
      if (Utils_default.isWorker()) {
        console.log("WebAudio is not supported on worker.");
        return true;
      }
      if (!WebAudio._initialized) {
        WebAudio.initialize();
      }
      this.clear();
      if (!WebAudio._standAlone) {
        this._loader = ResourceHandler_default.createLoader(
          url2,
          this._load.bind(this, url2),
          () => {
            this._hasError = true;
          }
        );
      }
      this._load(url2);
      this._url = url2;
    }
    /**
     * Initializes the audio system.
     *
     * @static
     * @method initialize
     * @param {Boolean} noAudio Flag for the no-audio mode
     * @return {Boolean} True if the audio system is available
     */
    static initialize(noAudio) {
      if (!this._initialized) {
        if (!noAudio) {
          this._createContext();
          this._detectCodecs();
          this._createMasterGainNode();
          this._setupEventHandlers();
        }
        this._initialized = true;
      }
      return !!this._context;
    }
    /**
     * Checks whether the browser can play ogg files.
     *
     * @static
     * @method canPlayOgg
     * @return {Boolean} True if the browser can play ogg files
     */
    static canPlayOgg() {
      if (!this._initialized) {
        this.initialize();
      }
      return !!this._canPlayOgg;
    }
    /**
     * Checks whether the browser can play m4a files.
     *
     * @static
     * @method canPlayM4a
     * @return {Boolean} True if the browser can play m4a files
     */
    static canPlayM4a() {
      if (!this._initialized) {
        this.initialize();
      }
      return !!this._canPlayM4a;
    }
    /**
     * Sets the master volume of the all audio.
     *
     * @static
     * @method setMasterVolume
     * @param {Number} value Master volume (min: 0, max: 1)
     */
    static setMasterVolume(value3) {
      this._masterVolume = value3;
      if (this._masterGainNode) {
        this._masterGainNode.gain.setValueAtTime(
          this._masterVolume,
          this._context.currentTime
        );
      }
    }
    /**
     * @static
     * @method _createContext
     * @private
     */
    static _createContext() {
      try {
        if (typeof AudioContext !== "undefined") {
          this._context = new AudioContext();
        } else if (typeof webkitAudioContext !== "undefined") {
          this._context = new webkitAudioContext();
        }
      } catch (e) {
        this._context = null;
      }
    }
    /**
     * @static
     * @method _detectCodecs
     * @private
     */
    static _detectCodecs() {
      if (Utils_default.isWorker()) {
        console.log("WebAudio._detectCodecs is not supported on worker.");
        this._canPlayOgg = false;
        this._canPlayM4a = false;
        return;
      }
      const audio = document.createElement("audio");
      if (audio.canPlayType) {
        this._canPlayOgg = audio.canPlayType('audio/ogg; codecs="vorbis"');
        this._canPlayM4a = audio.canPlayType("audio/mp4");
      }
    }
    /**
     * @static
     * @method _createMasterGainNode
     * @private
     */
    static _createMasterGainNode() {
      const context2 = WebAudio._context;
      if (context2) {
        this._masterGainNode = context2.createGain();
        this._masterGainNode.gain.setValueAtTime(
          this._masterVolume,
          context2.currentTime
        );
        this._masterGainNode.connect(context2.destination);
      }
    }
    /**
     * @static
     * @method _setupEventHandlers
     * @private
     */
    static _setupEventHandlers() {
      const resumeHandler = () => {
        const context2 = WebAudio._context;
        if (context2 && context2.state === "suspended" && typeof context2.resume === "function") {
          context2.resume().then(() => {
            WebAudio._onTouchStart();
          });
        } else {
          WebAudio._onTouchStart();
        }
      };
      document.addEventListener("keydown", resumeHandler);
      document.addEventListener("mousedown", resumeHandler);
      document.addEventListener("touchend", resumeHandler);
      document.addEventListener("touchstart", this._onTouchStart.bind(this));
      document.addEventListener(
        "visibilitychange",
        this._onVisibilityChange.bind(this)
      );
    }
    /**
     * @static
     * @method _onTouchStart
     * @private
     */
    static _onTouchStart() {
      const context2 = WebAudio._context;
      if (context2 && !this._unlocked) {
        const node = context2.createBufferSource();
        node.start(0);
        this._unlocked = true;
      }
    }
    /**
     * @static
     * @method _onVisibilityChange
     * @private
     */
    static _onVisibilityChange(payload) {
      if (payload.visibilityState === "hidden") {
        this._onHide();
      } else {
        this._onShow();
      }
    }
    /**
     * @static
     * @method _onHide
     * @private
     */
    static _onHide() {
      if (this._shouldMuteOnHide()) {
        this._fadeOut(1);
      }
    }
    /**
     * @static
     * @method _onShow
     * @private
     */
    static _onShow() {
      if (this._shouldMuteOnHide()) {
        this._fadeIn(1);
      }
    }
    /**
     * @static
     * @method _fadeIn
     * @param {Number} duration
     * @private
     */
    static _fadeIn(duration) {
      if (this._masterGainNode) {
        const gain = this._masterGainNode.gain;
        const currentTime = WebAudio._context.currentTime;
        gain.setValueAtTime(0, currentTime);
        gain.linearRampToValueAtTime(this._masterVolume, currentTime + duration);
      }
    }
    /**
     * @static
     * @method _fadeOut
     * @param {Number} duration
     * @private
     */
    static _fadeOut(duration) {
      if (this._masterGainNode) {
        const gain = this._masterGainNode.gain;
        const currentTime = WebAudio._context.currentTime;
        gain.setValueAtTime(this._masterVolume, currentTime);
        gain.linearRampToValueAtTime(0, currentTime + duration);
      }
    }
    /**
     * Clears the audio data.
     *
     * @method clear
     */
    clear() {
      this.stop();
      this._buffer = null;
      this._sourceNode = null;
      this._gainNode = null;
      this._pannerNode = null;
      this._totalTime = 0;
      this._sampleRate = 0;
      this._loopStart = 0;
      this._loopLength = 0;
      this._startTime = 0;
      this._volume = 1;
      this._pitch = 1;
      this._pan = 0;
      this._endTimer = null;
      this._loadListeners = [];
      this._stopListeners = [];
      this._hasError = false;
      this._autoPlay = false;
    }
    /**
     * [read-only] The url of the audio file.
     *
     * @property url
     * @type String
     */
    get url() {
      return this._url;
    }
    /**
     * The volume of the audio.
     *
     * @property volume
     * @type Number
     */
    get volume() {
      return this._volume;
    }
    set volume(value3) {
      this._volume = value3;
      if (this._gainNode) {
        this._gainNode.gain.setValueAtTime(
          this._volume,
          WebAudio._context.currentTime
        );
      }
    }
    /**
     * The pitch of the audio.
     *
     * @property pitch
     * @type Number
     */
    get pitch() {
      return this._pitch;
    }
    set pitch(value3) {
      if (this._pitch !== value3) {
        this._pitch = value3;
        if (this.isPlaying()) {
          this.play(this._sourceNode.loop, 0);
        }
      }
    }
    /**
     * The pan of the audio.
     *
     * @property pan
     * @type Number
     */
    get pan() {
      return this._pan;
    }
    set pan(value3) {
      this._pan = value3;
      this._updatePanner();
    }
    /**
     * Checks whether the audio data is ready to play.
     *
     * @method isReady
     * @return {Boolean} True if the audio data is ready to play
     */
    isReady() {
      return !!this._buffer;
    }
    /**
     * Checks whether a loading error has occurred.
     *
     * @method isError
     * @return {Boolean} True if a loading error has occurred
     */
    isError() {
      return this._hasError;
    }
    /**
     * Checks whether the audio is playing.
     *
     * @method isPlaying
     * @return {Boolean} True if the audio is playing
     */
    isPlaying() {
      return !!this._sourceNode;
    }
    /**
     * Plays the audio.
     *
     * @method play
     * @param {Boolean} loop Whether the audio data play in a loop
     * @param {Number} offset The start position to play in seconds
     */
    play(loop, offset) {
      if (this.isReady()) {
        offset = offset || 0;
        this._startPlaying(loop, offset);
      } else if (WebAudio._context) {
        this._autoPlay = true;
        this.addLoadListener(() => {
          if (this._autoPlay) {
            this.play(loop, offset);
          }
        });
      }
    }
    /**
     * Stops the audio.
     *
     * @method stop
     */
    stop() {
      this._autoPlay = false;
      this._removeEndTimer();
      this._removeNodes();
      if (this._stopListeners) {
        while (this._stopListeners.length > 0) {
          const listner = this._stopListeners.shift();
          listner();
        }
      }
    }
    /**
     * Performs the audio fade-in.
     *
     * @method fadeIn
     * @param {Number} duration Fade-in time in seconds
     */
    fadeIn(duration) {
      if (this.isReady()) {
        if (this._gainNode) {
          const gain = this._gainNode.gain;
          const currentTime = WebAudio._context.currentTime;
          gain.setValueAtTime(0, currentTime);
          gain.linearRampToValueAtTime(this._volume, currentTime + duration);
        }
      } else if (this._autoPlay) {
        this.addLoadListener(() => {
          this.fadeIn(duration);
        });
      }
    }
    /**
     * Performs the audio fade-out.
     *
     * @method fadeOut
     * @param {Number} duration Fade-out time in seconds
     */
    fadeOut(duration) {
      if (this._gainNode) {
        const gain = this._gainNode.gain;
        const currentTime = WebAudio._context.currentTime;
        gain.setValueAtTime(this._volume, currentTime);
        gain.linearRampToValueAtTime(0, currentTime + duration);
      }
      this._autoPlay = false;
    }
    /**
     * Gets the seek position of the audio.
     *
     * @method seek
     */
    seek() {
      if (WebAudio._context) {
        let pos = (WebAudio._context.currentTime - this._startTime) * this._pitch;
        if (this._loopLength > 0) {
          while (pos >= this._loopStart + this._loopLength) {
            pos -= this._loopLength;
          }
        }
        return pos;
      } else {
        return 0;
      }
    }
    /**
     * Add a callback function that will be called when the audio data is loaded.
     *
     * @method addLoadListener
     * @param {Function} listner The callback function
     */
    addLoadListener(listner) {
      if (Utils_default.isWorker()) {
        console.log("WebAudio.addLoadListener unsupported on worker.");
        return;
      }
      this._loadListeners.push(listner);
    }
    /**
     * Add a callback function that will be called when the playback is stopped.
     *
     * @method addStopListener
     * @param {Function} listner The callback function
     */
    addStopListener(listner) {
      this._stopListeners.push(listner);
    }
    /**
     * @method _load
     * @param {String} url
     * @private
     */
    _load(url2) {
      if (WebAudio._context) {
        const xhr = new XMLHttpRequest();
        xhr.open("GET", url2);
        xhr.responseType = "arraybuffer";
        xhr.onload = () => {
          if (xhr.status < 400) {
            this._onXhrLoad(xhr);
          }
        };
        xhr.onerror = this._loader || (() => {
          this._hasError = true;
        });
        xhr.send();
      }
    }
    /**
     * @method _onXhrLoad
     * @param {XMLHttpRequest} xhr
     * @private
     */
    _onXhrLoad({ response }) {
      let array = response;
      this._readLoopComments(new Uint8Array(array));
      WebAudio._context.decodeAudioData(array, (buffer) => {
        this._buffer = buffer;
        this._totalTime = buffer.duration;
        if (this._loopLength > 0 && this._sampleRate > 0) {
          this._loopStart /= this._sampleRate;
          this._loopLength /= this._sampleRate;
        } else {
          this._loopStart = 0;
          this._loopLength = this._totalTime;
        }
        this._onLoad();
      });
    }
    /**
     * @method _startPlaying
     * @param {Boolean} loop
     * @param {Number} offset
     * @private
     */
    _startPlaying(loop, offset) {
      if (this._loopLength > 0) {
        while (offset >= this._loopStart + this._loopLength) {
          offset -= this._loopLength;
        }
      }
      this._removeEndTimer();
      this._removeNodes();
      this._createNodes();
      this._connectNodes();
      this._sourceNode.loop = loop;
      this._sourceNode.start(0, offset);
      this._startTime = WebAudio._context.currentTime - offset / this._pitch;
      this._createEndTimer();
    }
    /**
     * @method _createNodes
     * @private
     */
    _createNodes() {
      const context2 = WebAudio._context;
      this._sourceNode = context2.createBufferSource();
      this._sourceNode.buffer = this._buffer;
      this._sourceNode.loopStart = this._loopStart;
      this._sourceNode.loopEnd = this._loopStart + this._loopLength;
      this._sourceNode.playbackRate.setValueAtTime(
        this._pitch,
        context2.currentTime
      );
      this._gainNode = context2.createGain();
      this._gainNode.gain.setValueAtTime(this._volume, context2.currentTime);
      this._pannerNode = context2.createPanner();
      this._pannerNode.panningModel = "equalpower";
      this._updatePanner();
    }
    /**
     * @method _connectNodes
     * @private
     */
    _connectNodes() {
      this._sourceNode.connect(this._gainNode);
      this._gainNode.connect(this._pannerNode);
      this._pannerNode.connect(WebAudio._masterGainNode);
    }
    /**
     * @method _removeNodes
     * @private
     */
    _removeNodes() {
      if (this._sourceNode) {
        this._sourceNode.stop(0);
        this._sourceNode = null;
        this._gainNode = null;
        this._pannerNode = null;
      }
    }
    /**
     * @method _createEndTimer
     * @private
     */
    _createEndTimer() {
      if (this._sourceNode && !this._sourceNode.loop) {
        const endTime = this._startTime + this._totalTime / this._pitch;
        const delay = endTime - WebAudio._context.currentTime;
        this._endTimer = setTimeout(() => {
          this.stop();
        }, delay * 1e3);
      }
    }
    /**
     * @method _removeEndTimer
     * @private
     */
    _removeEndTimer() {
      if (this._endTimer) {
        clearTimeout(this._endTimer);
        this._endTimer = null;
      }
    }
    /**
     * @method _updatePanner
     * @private
     */
    _updatePanner() {
      if (this._pannerNode) {
        const x = this._pan;
        const z = 1 - Math.abs(x);
        this._pannerNode.setPosition(x, 0, z);
      }
    }
    /**
     * @method _onLoad
     * @private
     */
    _onLoad() {
      while (this._loadListeners.length > 0) {
        const listner = this._loadListeners.shift();
        listner();
      }
    }
    /**
     * @method _readLoopComments
     * @param {Uint8Array} array
     * @private
     */
    _readLoopComments(array) {
      this._readOgg(array);
      this._readMp4(array);
    }
    /**
     * @method _readOgg
     * @param {Uint8Array} array
     * @private
     */
    _readOgg(array) {
      let index2 = 0;
      while (index2 < array.length) {
        if (this._readFourCharacters(array, index2) === "OggS") {
          index2 += 26;
          let vorbisHeaderFound = false;
          const numSegments = array[index2++];
          const segments = [];
          for (let i = 0; i < numSegments; i++) {
            segments.push(array[index2++]);
          }
          for (let i = 0; i < numSegments; i++) {
            if (this._readFourCharacters(array, index2 + 1) === "vorb") {
              const headerType = array[index2];
              if (headerType === 1) {
                this._sampleRate = this._readLittleEndian(array, index2 + 12);
              } else if (headerType === 3) {
                let size = 0;
                for (; i < numSegments; i++) {
                  size += segments[i];
                  if (segments[i] < 255) {
                    break;
                  }
                }
                this._readMetaData(array, index2, size);
              }
              vorbisHeaderFound = true;
            }
            index2 += segments[i];
          }
          if (!vorbisHeaderFound) {
            break;
          }
        } else {
          break;
        }
      }
    }
    /**
     * @method _readMp4
     * @param {Uint8Array} array
     * @private
     */
    _readMp4(array) {
      if (this._readFourCharacters(array, 4) === "ftyp") {
        let index2 = 0;
        while (index2 < array.length) {
          const size = this._readBigEndian(array, index2);
          const name = this._readFourCharacters(array, index2 + 4);
          if (name === "moov") {
            index2 += 8;
          } else {
            if (name === "mvhd") {
              this._sampleRate = this._readBigEndian(array, index2 + 20);
            }
            if (name === "udta" || name === "meta") {
              this._readMetaData(array, index2, size);
            }
            index2 += size;
            if (size <= 1) {
              break;
            }
          }
        }
      }
    }
    /**
     * @method _readMetaData
     * @param {Uint8Array} array
     * @param {Number} index
     * @param {Number} size
     * @private
     */
    _readMetaData(array, index2, size) {
      for (let i = index2; i < index2 + size - 10; i++) {
        if (this._readFourCharacters(array, i) === "LOOP") {
          let text = "";
          while (array[i] > 0) {
            text += String.fromCharCode(array[i++]);
          }
          if (text.match(/LOOPSTART=([0-9]+)/)) {
            this._loopStart = parseInt(RegExp.$1);
          }
          if (text.match(/LOOPLENGTH=([0-9]+)/)) {
            this._loopLength = parseInt(RegExp.$1);
          }
          if (text == "LOOPSTART" || text == "LOOPLENGTH") {
            let text2 = "";
            i += 16;
            while (array[i] > 0) {
              text2 += String.fromCharCode(array[i++]);
            }
            if (text == "LOOPSTART") {
              this._loopStart = parseInt(text2);
            } else {
              this._loopLength = parseInt(text2);
            }
          }
        }
      }
    }
    /**
     * @method _readLittleEndian
     * @param {Uint8Array} array
     * @param {Number} index
     * @private
     */
    _readLittleEndian(array, index2) {
      return array[index2 + 3] * 16777216 + array[index2 + 2] * 65536 + array[index2 + 1] * 256 + array[index2 + 0];
    }
    /**
     * @method _readBigEndian
     * @param {Uint8Array} array
     * @param {Number} index
     * @private
     */
    _readBigEndian(array, index2) {
      return array[index2 + 0] * 16777216 + array[index2 + 1] * 65536 + array[index2 + 2] * 256 + array[index2 + 3];
    }
    /**
     * @method _readFourCharacters
     * @param {Uint8Array} array
     * @param {Number} index
     * @private
     */
    _readFourCharacters(array, index2) {
      let string = "";
      for (let i = 0; i < 4; i++) {
        string += String.fromCharCode(array[index2 + i]);
      }
      return string;
    }
    static _shouldMuteOnHide() {
      return Utils_default.isMobileDevice();
    }
  };
  WebAudio._standAlone = ((top) => !top.ResourceHandler)(self);
  WebAudio._masterVolume = 1;
  WebAudio._context = null;
  WebAudio._masterGainNode = null;
  WebAudio._initialized = false;
  WebAudio._unlocked = false;
  var WebAudio_default = WebAudio;

  // src-www/js/rpg_managers/AudioManager.js
  var AudioManager = class {
    constructor() {
      throw new Error("This is a static class");
    }
    static playBgm(bgm, pos) {
      if (this.isCurrentBgm(bgm)) {
        this.updateBgmParameters(bgm);
      } else {
        this.stopBgm();
        if (bgm.name) {
          this._bgmBuffer = this.createBuffer("bgm", bgm.name);
          this.updateBgmParameters(bgm);
          if (!this._meBuffer) {
            this._bgmBuffer.play(true, pos || 0);
          }
        }
      }
      this.updateCurrentBgm(bgm, pos);
    }
    static playEncryptedBgm({ name }, pos) {
    }
    static createDecryptBuffer(url2, bgm, pos) {
    }
    static replayBgm(bgm) {
      if (this.isCurrentBgm(bgm)) {
        this.updateBgmParameters(bgm);
      } else {
        this.playBgm(bgm, bgm.pos);
        if (this._bgmBuffer) {
          this._bgmBuffer.fadeIn(this._replayFadeTime);
        }
      }
    }
    static isCurrentBgm({ name }) {
      return this._currentBgm && this._bgmBuffer && this._currentBgm.name === name;
    }
    static updateBgmParameters(bgm) {
      this.updateBufferParameters(this._bgmBuffer, this._bgmVolume, bgm);
    }
    static updateCurrentBgm({ name, volume, pitch, pan }, pos) {
      this._currentBgm = {
        name,
        volume,
        pitch,
        pan,
        pos
      };
    }
    static stopBgm() {
      if (this._bgmBuffer) {
        this._bgmBuffer.stop();
        this._bgmBuffer = null;
        this._currentBgm = null;
      }
    }
    static fadeOutBgm(duration) {
      if (this._bgmBuffer && this._currentBgm) {
        this._bgmBuffer.fadeOut(duration);
        this._currentBgm = null;
      }
    }
    static fadeInBgm(duration) {
      if (this._bgmBuffer && this._currentBgm) {
        this._bgmBuffer.fadeIn(duration);
      }
    }
    static playBgs(bgs, pos) {
      if (this.isCurrentBgs(bgs)) {
        this.updateBgsParameters(bgs);
      } else {
        this.stopBgs();
        if (bgs.name) {
          this._bgsBuffer = this.createBuffer("bgs", bgs.name);
          this.updateBgsParameters(bgs);
          this._bgsBuffer.play(true, pos || 0);
        }
      }
      this.updateCurrentBgs(bgs, pos);
    }
    static replayBgs(bgs) {
      if (this.isCurrentBgs(bgs)) {
        this.updateBgsParameters(bgs);
      } else {
        this.playBgs(bgs, bgs.pos);
        if (this._bgsBuffer) {
          this._bgsBuffer.fadeIn(this._replayFadeTime);
        }
      }
    }
    static isCurrentBgs({ name }) {
      return this._currentBgs && this._bgsBuffer && this._currentBgs.name === name;
    }
    static updateBgsParameters(bgs) {
      this.updateBufferParameters(this._bgsBuffer, this._bgsVolume, bgs);
    }
    static updateCurrentBgs({ name, volume, pitch, pan }, pos) {
      this._currentBgs = {
        name,
        volume,
        pitch,
        pan,
        pos
      };
    }
    static stopBgs() {
      if (this._bgsBuffer) {
        this._bgsBuffer.stop();
        this._bgsBuffer = null;
        this._currentBgs = null;
      }
    }
    static fadeOutBgs(duration) {
      if (this._bgsBuffer && this._currentBgs) {
        this._bgsBuffer.fadeOut(duration);
        this._currentBgs = null;
      }
    }
    static fadeInBgs(duration) {
      if (this._bgsBuffer && this._currentBgs) {
        this._bgsBuffer.fadeIn(duration);
      }
    }
    static playMe(me) {
      this.stopMe();
      if (me.name) {
        if (this._bgmBuffer && this._currentBgm) {
          this._currentBgm.pos = this._bgmBuffer.seek();
          this._bgmBuffer.stop();
        }
        this._meBuffer = this.createBuffer("me", me.name);
        this.updateMeParameters(me);
        this._meBuffer.play(false);
        this._meBuffer.addStopListener(this.stopMe.bind(this));
      }
    }
    static updateMeParameters(me) {
      this.updateBufferParameters(this._meBuffer, this._meVolume, me);
    }
    static fadeOutMe(duration) {
      if (this._meBuffer) {
        this._meBuffer.fadeOut(duration);
      }
    }
    static stopMe() {
      if (this._meBuffer) {
        this._meBuffer.stop();
        this._meBuffer = null;
        if (this._bgmBuffer && this._currentBgm && !this._bgmBuffer.isPlaying()) {
          this._bgmBuffer.play(true, this._currentBgm.pos);
          this._bgmBuffer.fadeIn(this._replayFadeTime);
        }
      }
    }
    static playSe(se) {
      if (se.name) {
        this._seBuffers = this._seBuffers.filter((audio) => audio.isPlaying());
        const buffer = this.createBuffer("se", se.name);
        this.updateSeParameters(buffer, se);
        buffer.play(false);
        this._seBuffers.push(buffer);
      }
    }
    static updateSeParameters(buffer, se) {
      this.updateBufferParameters(buffer, this._seVolume, se);
    }
    static stopSe() {
      this._seBuffers.forEach((buffer) => {
        buffer.stop();
      });
      this._seBuffers = [];
    }
    static playStaticSe(se) {
      if (se.name) {
        this.loadStaticSe(se);
        for (const buffer of this._staticBuffers) {
          if (buffer._reservedSeName === se.name) {
            buffer.stop();
            this.updateSeParameters(buffer, se);
            buffer.play(false);
            break;
          }
        }
      }
    }
    static loadStaticSe(se) {
      if (se.name && !this.isStaticSe(se)) {
        const buffer = this.createBuffer("se", se.name);
        buffer._reservedSeName = se.name;
        this._staticBuffers.push(buffer);
      }
    }
    static isStaticSe({ name }) {
      for (const buffer of this._staticBuffers) {
        if (buffer._reservedSeName === name) {
          return true;
        }
      }
      return false;
    }
    static stopAll() {
      this.stopMe();
      this.stopBgm();
      this.stopBgs();
      this.stopSe();
    }
    static saveBgm() {
      if (this._currentBgm) {
        const bgm = this._currentBgm;
        return {
          name: bgm.name,
          volume: bgm.volume,
          pitch: bgm.pitch,
          pan: bgm.pan,
          pos: this._bgmBuffer ? this._bgmBuffer.seek() : 0
        };
      } else {
        return this.makeEmptyAudioObject();
      }
    }
    static saveBgs() {
      if (this._currentBgs) {
        const bgs = this._currentBgs;
        return {
          name: bgs.name,
          volume: bgs.volume,
          pitch: bgs.pitch,
          pan: bgs.pan,
          pos: this._bgsBuffer ? this._bgsBuffer.seek() : 0
        };
      } else {
        return this.makeEmptyAudioObject();
      }
    }
    static createBuffer(folder, name) {
      const ext = this.audioFileExt();
      const url2 = `${this._path + folder}/${encodeURIComponent(name)}${ext}`;
      const audio = new WebAudio_default(url2);
      this._callCreationHook(audio);
      return audio;
    }
    static checkErrors() {
      this.checkWebAudioError(this._bgmBuffer);
      this.checkWebAudioError(this._bgsBuffer);
      this.checkWebAudioError(this._meBuffer);
      this._seBuffers.forEach((buffer) => {
        this.checkWebAudioError(buffer);
      });
      this._staticBuffers.forEach((buffer) => {
        this.checkWebAudioError(buffer);
      });
    }
    static setCreationHook(hook) {
      this._creationHook = hook;
    }
    static _callCreationHook(audio) {
      if (this._creationHook)
        this._creationHook(audio);
    }
    static audioFileExt() {
      if (WebAudio_default.canPlayOgg() && !Utils_default.isMobileDevice()) {
        return ".ogg";
      } else {
        return ".m4a";
      }
    }
    static shouldUseHtml5Audio() {
      return false;
    }
    static checkWebAudioError(webAudio) {
      if (webAudio && webAudio.isError()) {
        throw new Error(`Failed to load: ${webAudio.url}`);
      }
    }
    static makeEmptyAudioObject() {
      return {
        name: "",
        volume: 0,
        pitch: 0
      };
    }
    static updateBufferParameters(buffer, configVolume, audio) {
      if (buffer && audio) {
        buffer.volume = configVolume * (audio.volume || 0) / 1e4;
        buffer.pitch = (audio.pitch || 0) / 100;
        buffer.pan = (audio.pan || 0) / 100;
      }
    }
  };
  AudioManager._masterVolume = 1;
  AudioManager._bgmVolume = 100;
  AudioManager._bgsVolume = 100;
  AudioManager._meVolume = 100;
  AudioManager._seVolume = 100;
  AudioManager._currentBgm = null;
  AudioManager._currentBgs = null;
  AudioManager._bgmBuffer = null;
  AudioManager._bgsBuffer = null;
  AudioManager._meBuffer = null;
  AudioManager._seBuffers = [];
  AudioManager._staticBuffers = [];
  AudioManager._replayFadeTime = 0.5;
  AudioManager._path = "audio/";
  AudioManager._blobUrl = null;
  Object.defineProperty(AudioManager, "masterVolume", {
    get() {
      return this._masterVolume;
    },
    set(value3) {
      this._masterVolume = value3;
      WebAudio_default.setMasterVolume(this._masterVolume);
      Graphics_default.setVideoVolume(this._masterVolume);
    },
    configurable: true
  });
  Object.defineProperty(AudioManager, "bgmVolume", {
    get() {
      return this._bgmVolume;
    },
    set(value3) {
      this._bgmVolume = value3;
      this.updateBgmParameters(this._currentBgm);
    },
    configurable: true
  });
  Object.defineProperty(AudioManager, "bgsVolume", {
    get() {
      return this._bgsVolume;
    },
    set(value3) {
      this._bgsVolume = value3;
      this.updateBgsParameters(this._currentBgs);
    },
    configurable: true
  });
  Object.defineProperty(AudioManager, "meVolume", {
    get() {
      return this._meVolume;
    },
    set(value3) {
      this._meVolume = value3;
      this.updateMeParameters(this._currentMe);
    },
    configurable: true
  });
  Object.defineProperty(AudioManager, "seVolume", {
    get() {
      return this._seVolume;
    },
    set(value3) {
      this._seVolume = value3;
    },
    configurable: true
  });
  var AudioManager_default = AudioManager;

  // src-www/js/rpg_core/Input.js
  var Input = class {
    constructor() {
      throw new Error("This is a static class");
    }
    /**
     * Initializes the input system.
     *
     * @static
     * @method initialize
     */
    static initialize() {
      this.clear();
      this._wrapNwjsAlert();
      this._setupEventHandlers();
    }
    /**
     * Clears all the input data.
     *
     * @static
     * @method clear
     */
    static clear() {
      this._currentState = {};
      this._previousState = {};
      this._gamepadStates = [];
      this._latestButton = null;
      this._pressedTime = 0;
      this._dir4 = 0;
      this._dir8 = 0;
      this._preferredAxis = "";
      this._date = 0;
    }
    /**
     * Updates the input data.
     *
     * @static
     * @method update
     */
    static update() {
      this._pollGamepads();
      if (this._currentState[this._latestButton]) {
        this._pressedTime++;
      } else {
        this._latestButton = null;
      }
      for (let name in this._currentState) {
        if (this._currentState[name] && !this._previousState[name]) {
          this._latestButton = name;
          this._pressedTime = 0;
          this._date = Date.now();
        }
        this._previousState[name] = this._currentState[name];
      }
      this._updateDirection();
    }
    /**
     * Checks whether a key is currently pressed down.
     *
     * @static
     * @method isPressed
     * @param {String} keyName The mapped name of the key
     * @return {Boolean} True if the key is pressed
     */
    static isPressed(keyName) {
      if (this._isEscapeCompatible(keyName) && this.isPressed("escape")) {
        return true;
      } else {
        return !!this._currentState[keyName];
      }
    }
    /**
     * Checks whether a key is just pressed.
     *
     * @static
     * @method isTriggered
     * @param {String} keyName The mapped name of the key
     * @return {Boolean} True if the key is triggered
     */
    static isTriggered(keyName) {
      if (this._isEscapeCompatible(keyName) && this.isTriggered("escape")) {
        return true;
      } else {
        return this._latestButton === keyName && this._pressedTime === 0;
      }
    }
    /**
     * Checks whether a key is just pressed or a key repeat occurred.
     *
     * @static
     * @method isRepeated
     * @param {String} keyName The mapped name of the key
     * @return {Boolean} True if the key is repeated
     */
    static isRepeated(keyName) {
      if (this._isEscapeCompatible(keyName) && this.isRepeated("escape")) {
        return true;
      } else {
        return this._latestButton === keyName && (this._pressedTime === 0 || this._pressedTime >= this.keyRepeatWait && this._pressedTime % this.keyRepeatInterval === 0);
      }
    }
    /**
     * Checks whether a key is kept depressed.
     *
     * @static
     * @method isLongPressed
     * @param {String} keyName The mapped name of the key
     * @return {Boolean} True if the key is long-pressed
     */
    static isLongPressed(keyName) {
      if (this._isEscapeCompatible(keyName) && this.isLongPressed("escape")) {
        return true;
      } else {
        return this._latestButton === keyName && this._pressedTime >= this.keyRepeatWait;
      }
    }
    /**
     * @static
     * @method _setupEventHandlers
     * @private
     */
    static _setupEventHandlers() {
      document.addEventListener("keydown", this._onKeyDown.bind(this));
      document.addEventListener("keyup", this._onKeyUp.bind(this));
      window.addEventListener("blur", this._onLostFocus.bind(this));
    }
    /**
     * @static
     * @method _onKeyDown
     * @param {KeyboardEvent} event
     * @private
     */
    static _onKeyDown(event) {
      if (this._shouldPreventDefault(event.keyCode)) {
        console.log("event.preventDefault not called on worker");
      }
      if (event.keyCode === 144) {
        this.clear();
      }
      const buttonName = this.keyMapper[event.keyCode];
      if (ResourceHandler_default.exists() && buttonName === "ok") {
        ResourceHandler_default.retry();
      } else if (buttonName) {
        this._currentState[buttonName] = true;
      }
    }
    /**
     * @static
     * @method _onKeyUp
     * @param {KeyboardEvent} event
     * @private
     */
    static _onKeyUp({ keyCode }) {
      const buttonName = this.keyMapper[keyCode];
      if (buttonName) {
        this._currentState[buttonName] = false;
      }
      if (keyCode === 0) {
        this.clear();
      }
    }
    /**
     * @static
     * @method _onLostFocus
     * @private
     */
    static _onLostFocus() {
      this.clear();
    }
    /**
     * @static
     * @method _pollGamepads
     * @private
     */
    static _pollGamepads() {
      if (navigator.getGamepads) {
        const gamepads = navigator.getGamepads();
        if (gamepads) {
          for (const gamepad of gamepads) {
            if (gamepad && gamepad.connected) {
              this._updateGamepadState(gamepad);
            }
          }
        }
      }
    }
    /**
     * @static
     * @method _updateGamepadState
     * @param {Gamepad} gamepad
     * @param {Number} index
     * @private
     */
    static _updateGamepadState(gamepad) {
      const lastState = this._gamepadStates[gamepad.index] || [];
      const newState = [];
      const buttons = gamepad.buttons;
      const axes = gamepad.axes;
      const threshold = 0.5;
      newState[12] = false;
      newState[13] = false;
      newState[14] = false;
      newState[15] = false;
      for (let i = 0; i < buttons.length; i++) {
        newState[i] = buttons[i].pressed;
      }
      if (axes[1] < -threshold) {
        newState[12] = true;
      } else if (axes[1] > threshold) {
        newState[13] = true;
      }
      if (axes[0] < -threshold) {
        newState[14] = true;
      } else if (axes[0] > threshold) {
        newState[15] = true;
      }
      for (let j = 0; j < newState.length; j++) {
        if (newState[j] !== lastState[j]) {
          const buttonName = this.gamepadMapper[j];
          if (buttonName) {
            this._currentState[buttonName] = newState[j];
          }
        }
      }
      this._gamepadStates[gamepad.index] = newState;
    }
    /**
     * @static
     * @method _updateDirection
     * @private
     */
    static _updateDirection() {
      let x = this._signX();
      let y = this._signY();
      this._dir8 = this._makeNumpadDirection(x, y);
      if (x !== 0 && y !== 0) {
        if (this._preferredAxis === "x") {
          y = 0;
        } else {
          x = 0;
        }
      } else if (x !== 0) {
        this._preferredAxis = "y";
      } else if (y !== 0) {
        this._preferredAxis = "x";
      }
      this._dir4 = this._makeNumpadDirection(x, y);
    }
    /**
     * @static
     * @method _signX
     * @private
     */
    static _signX() {
      let x = 0;
      if (this.isPressed("left")) {
        x--;
      }
      if (this.isPressed("right")) {
        x++;
      }
      return x;
    }
    /**
     * @static
     * @method _signY
     * @private
     */
    static _signY() {
      let y = 0;
      if (this.isPressed("up")) {
        y--;
      }
      if (this.isPressed("down")) {
        y++;
      }
      return y;
    }
    /**
     * @static
     * @method _wrapNwjsAlert
     * @private
     */
    static _wrapNwjsAlert() {
      if (Utils_default.isNwjs()) {
        const _alert = window.alert;
        window.alert = function(...args) {
          const gui = __require("nw.gui");
          const win = gui.Window.get();
          _alert.apply(this, args);
          win.focus();
          Input.clear();
        };
      }
    }
    /**
     * @static
     * @method _shouldPreventDefault
     * @param {Number} keyCode
     * @private
     */
    static _shouldPreventDefault(keyCode) {
      switch (keyCode) {
        case 8:
        case 33:
        case 34:
        case 37:
        case 38:
        case 39:
        case 40:
          return true;
      }
      return false;
    }
    /**
     * @static
     * @method _makeNumpadDirection
     * @param {Number} x
     * @param {Number} y
     * @return {Number}
     * @private
     */
    static _makeNumpadDirection(x, y) {
      if (x !== 0 || y !== 0) {
        return 5 - y * 3 + x;
      }
      return 0;
    }
    /**
     * @static
     * @method _isEscapeCompatible
     * @param {String} keyName
     * @return {Boolean}
     * @private
     */
    static _isEscapeCompatible(keyName) {
      return keyName === "cancel" || keyName === "menu";
    }
  };
  Input.keyRepeatWait = 24;
  Input.keyRepeatInterval = 6;
  Input.keyMapper = {
    9: "tab",
    // tab
    13: "ok",
    // enter
    16: "shift",
    // shift
    17: "control",
    // control
    18: "control",
    // alt
    27: "escape",
    // escape
    32: "ok",
    // space
    33: "pageup",
    // pageup
    34: "pagedown",
    // pagedown
    37: "left",
    // left arrow
    38: "up",
    // up arrow
    39: "right",
    // right arrow
    40: "down",
    // down arrow
    45: "escape",
    // insert
    81: "pageup",
    // Q
    87: "pagedown",
    // W
    88: "escape",
    // X
    90: "ok",
    // Z
    96: "escape",
    // numpad 0
    98: "down",
    // numpad 2
    100: "left",
    // numpad 4
    102: "right",
    // numpad 6
    104: "up",
    // numpad 8
    120: "debug"
    // F9
  };
  Input.gamepadMapper = {
    0: "ok",
    // A
    1: "cancel",
    // B
    2: "shift",
    // X
    3: "menu",
    // Y
    4: "pageup",
    // LB
    5: "pagedown",
    // RB
    12: "up",
    // D-pad up
    13: "down",
    // D-pad down
    14: "left",
    // D-pad left
    15: "right"
    // D-pad right
  };
  Object.defineProperty(Input, "dir4", {
    get() {
      return this._dir4;
    },
    configurable: true
  });
  Object.defineProperty(Input, "dir8", {
    get() {
      return this._dir8;
    },
    configurable: true
  });
  Object.defineProperty(Input, "date", {
    get() {
      return this._date;
    },
    configurable: true
  });
  var Input_default = Input;

  // src-www/js/rpg_managers/PluginManager.js
  var PluginManager = class {
    constructor() {
      throw new Error("This is a static class");
    }
    static setup(plugins) {
      plugins.forEach(function({ status, name, parameters }) {
        if (status && !this._scripts.contains(name)) {
          this.setParameters(name, parameters);
          this.loadScript(`${name}.js`);
          this._scripts.push(name);
        }
      }, this);
    }
    static checkErrors() {
      const url2 = this._errorUrls.shift();
      if (url2) {
        throw new Error(`Failed to load: ${url2}`);
      }
    }
    static parameters(name) {
      return this._parameters[name.toLowerCase()] || {};
    }
    static setParameters(name, parameters) {
      this._parameters[name.toLowerCase()] = parameters;
    }
    static loadScript(name) {
      const url2 = this._path + name;
      const script2 = Utils_default.loadScript(url2);
      if (script2) {
        script2.onerror = this.onError.bind(this);
        script2._url = url2;
      }
    }
    static onError({ target: target2 }) {
      this._errorUrls.push(target2._url);
    }
  };
  PluginManager._path = "js/plugins/";
  PluginManager._scripts = [];
  PluginManager._errorUrls = [];
  PluginManager._parameters = {};
  var PluginManager_default = PluginManager;

  // src-www/js/rpg_core/TouchInput.js
  var TouchInput = class {
    constructor() {
      throw new Error("This is a static class");
    }
    /**
     * Initializes the touch system.
     *
     * @static
     * @method initialize
     */
    static initialize() {
      this.clear();
      this._setupEventHandlers();
    }
    /**
     * Clears all the touch data.
     *
     * @static
     * @method clear
     */
    static clear() {
      this._mousePressed = false;
      this._screenPressed = false;
      this._pressedTime = 0;
      this._events = {};
      this._events.triggered = false;
      this._events.cancelled = false;
      this._events.moved = false;
      this._events.released = false;
      this._events.wheelX = 0;
      this._events.wheelY = 0;
      this._triggered = false;
      this._cancelled = false;
      this._moved = false;
      this._released = false;
      this._wheelX = 0;
      this._wheelY = 0;
      this._x = 0;
      this._y = 0;
      this._date = 0;
    }
    /**
     * Updates the touch data.
     *
     * @static
     * @method update
     */
    static update() {
      this._triggered = this._events.triggered;
      this._cancelled = this._events.cancelled;
      this._moved = this._events.moved;
      this._released = this._events.released;
      this._wheelX = this._events.wheelX;
      this._wheelY = this._events.wheelY;
      this._events.triggered = false;
      this._events.cancelled = false;
      this._events.moved = false;
      this._events.released = false;
      this._events.wheelX = 0;
      this._events.wheelY = 0;
      if (this.isPressed()) {
        this._pressedTime++;
      }
    }
    /**
     * Checks whether the mouse button or touchscreen is currently pressed down.
     *
     * @static
     * @method isPressed
     * @return {Boolean} True if the mouse button or touchscreen is pressed
     */
    static isPressed() {
      return this._mousePressed || this._screenPressed;
    }
    /**
     * Checks whether the left mouse button or touchscreen is just pressed.
     *
     * @static
     * @method isTriggered
     * @return {Boolean} True if the mouse button or touchscreen is triggered
     */
    static isTriggered() {
      return this._triggered;
    }
    /**
     * Checks whether the left mouse button or touchscreen is just pressed
     * or a pseudo key repeat occurred.
     *
     * @static
     * @method isRepeated
     * @return {Boolean} True if the mouse button or touchscreen is repeated
     */
    static isRepeated() {
      return this.isPressed() && (this._triggered || this._pressedTime >= this.keyRepeatWait && this._pressedTime % this.keyRepeatInterval === 0);
    }
    /**
     * Checks whether the left mouse button or touchscreen is kept depressed.
     *
     * @static
     * @method isLongPressed
     * @return {Boolean} True if the left mouse button or touchscreen is long-pressed
     */
    static isLongPressed() {
      return this.isPressed() && this._pressedTime >= this.keyRepeatWait;
    }
    /**
     * Checks whether the right mouse button is just pressed.
     *
     * @static
     * @method isCancelled
     * @return {Boolean} True if the right mouse button is just pressed
     */
    static isCancelled() {
      return this._cancelled;
    }
    /**
     * Checks whether the mouse or a finger on the touchscreen is moved.
     *
     * @static
     * @method isMoved
     * @return {Boolean} True if the mouse or a finger on the touchscreen is moved
     */
    static isMoved() {
      return this._moved;
    }
    /**
     * Checks whether the left mouse button or touchscreen is released.
     *
     * @static
     * @method isReleased
     * @return {Boolean} True if the mouse button or touchscreen is released
     */
    static isReleased() {
      return this._released;
    }
    /**
     * @static
     * @method _setupEventHandlers
     * @private
     */
    static _setupEventHandlers() {
      const isSupportPassive = Utils_default.isSupportPassiveEvent();
      document.addEventListener("mousedown", this._onMouseDown.bind(this));
      document.addEventListener("mousemove", this._onMouseMove.bind(this));
      document.addEventListener("mouseup", this._onMouseUp.bind(this));
      document.addEventListener(
        "wheel",
        this._onWheel.bind(this),
        isSupportPassive ? {
          passive: false
        } : false
      );
      document.addEventListener(
        "touchstart",
        this._onTouchStart.bind(this),
        isSupportPassive ? {
          passive: false
        } : false
      );
      document.addEventListener(
        "touchmove",
        this._onTouchMove.bind(this),
        isSupportPassive ? {
          passive: false
        } : false
      );
      document.addEventListener("touchend", this._onTouchEnd.bind(this));
      document.addEventListener("touchcancel", this._onTouchCancel.bind(this));
      document.addEventListener("pointerdown", this._onPointerDown.bind(this));
      window.addEventListener("blur", this._onLostFocus.bind(this));
    }
    /**
     * @static
     * @method _onMouseDown
     * @param {MouseEvent} event
     * @private
     */
    static _onMouseDown(event) {
      if (event.button === 0) {
        this._onLeftButtonDown(event);
      } else if (event.button === 1) {
        this._onMiddleButtonDown(event);
      } else if (event.button === 2) {
        this._onRightButtonDown(event);
      }
    }
    /**
     * @static
     * @method _onLeftButtonDown
     * @param {MouseEvent} event
     * @private
     */
    static _onLeftButtonDown({ pageX, pageY }) {
      const x = Graphics_default.pageToCanvasX(pageX);
      const y = Graphics_default.pageToCanvasY(pageY);
      if (Graphics_default.isInsideCanvas(x, y)) {
        this._mousePressed = true;
        this._pressedTime = 0;
        this._onTrigger(x, y);
      }
    }
    /**
     * @static
     * @method _onRightButtonDown
     * @param {MouseEvent} event
     * @private
     */
    static _onRightButtonDown({ pageX, pageY }) {
      const x = Graphics_default.pageToCanvasX(pageX);
      const y = Graphics_default.pageToCanvasY(pageY);
      if (Graphics_default.isInsideCanvas(x, y)) {
        this._onCancel(x, y);
      }
    }
    /**
     * @static
     * @method _onMouseMove
     * @param {MouseEvent} event
     * @private
     */
    static _onMouseMove({ pageX, pageY }) {
      if (this._mousePressed) {
        const x = Graphics_default.pageToCanvasX(pageX);
        const y = Graphics_default.pageToCanvasY(pageY);
        this._onMove(x, y);
      }
    }
    /**
     * @static
     * @method _onMouseUp
     * @param {MouseEvent} event
     * @private
     */
    static _onMouseUp({ button, pageX, pageY }) {
      if (button === 0) {
        const x = Graphics_default.pageToCanvasX(pageX);
        const y = Graphics_default.pageToCanvasY(pageY);
        this._mousePressed = false;
        this._onRelease(x, y);
      }
    }
    /**
     * @static
     * @method _onWheel
     * @param {WheelEvent} event
     * @private
     */
    static _onWheel(event) {
      this._events.wheelX += event.deltaX;
      this._events.wheelY += event.deltaY;
      console.log("event.preventDefault not called on worker");
    }
    /**
     * @static
     * @method _onTouchStart
     * @param {TouchEvent} event
     * @private
     */
    static _onTouchStart(event) {
      for (const touch in event.changedTouches) {
        if (touch.pageX && touch.pageX) {
          const x = Graphics_default.pageToCanvasX(touch.pageX);
          const y = Graphics_default.pageToCanvasY(touch.pageY);
          if (Graphics_default.isInsideCanvas(x, y)) {
            this._screenPressed = true;
            this._pressedTime = 0;
            if (event.touches.length >= 2) {
              this._onCancel(x, y);
            } else {
              this._onTrigger(x, y);
            }
            console.log("event.preventDefault not called on worker");
          }
        }
      }
    }
    /**
     * @static
     * @method _onTouchMove
     * @param {TouchEvent} event
     * @private
     */
    static _onTouchMove({ changedTouches }) {
      for (const touch of changedTouches) {
        const x = Graphics_default.pageToCanvasX(touch.pageX);
        const y = Graphics_default.pageToCanvasY(touch.pageY);
        this._onMove(x, y);
      }
    }
    /**
     * @static
     * @method _onTouchEnd
     * @param {TouchEvent} event
     * @private
     */
    static _onTouchEnd({ changedTouches }) {
      for (const touch of changedTouches) {
        const x = Graphics_default.pageToCanvasX(touch.pageX);
        const y = Graphics_default.pageToCanvasY(touch.pageY);
        this._screenPressed = false;
        this._onRelease(x, y);
      }
    }
    /**
     * @static
     * @method _onTouchCancel
     * @param {TouchEvent} event
     * @private
     */
    static _onTouchCancel(event) {
      this._screenPressed = false;
    }
    /**
     * @static
     * @method _onPointerDown
     * @param {PointerEvent} event
     * @private
     */
    static _onPointerDown(event) {
      if (event.pointerType === "touch" && !event.isPrimary) {
        const x = Graphics_default.pageToCanvasX(event.pageX);
        const y = Graphics_default.pageToCanvasY(event.pageY);
        if (Graphics_default.isInsideCanvas(x, y)) {
          this._onCancel(x, y);
          console.log("event.preventDefault not called on worker");
        }
      }
    }
    /**
     * @static
     * @method _onLostFocus
     * @private
     */
    static _onLostFocus() {
      this.clear();
    }
    /**
     * @static
     * @method _onTrigger
     * @param {Number} x
     * @param {Number} y
     * @private
     */
    static _onTrigger(x, y) {
      this._events.triggered = true;
      this._x = x;
      this._y = y;
      this._date = Date.now();
    }
    /**
     * @static
     * @method _onCancel
     * @param {Number} x
     * @param {Number} y
     * @private
     */
    static _onCancel(x, y) {
      this._events.cancelled = true;
      this._x = x;
      this._y = y;
    }
    /**
     * @static
     * @method _onMove
     * @param {Number} x
     * @param {Number} y
     * @private
     */
    static _onMove(x, y) {
      this._events.moved = true;
      this._x = x;
      this._y = y;
    }
    /**
     * @static
     * @method _onRelease
     * @param {Number} x
     * @param {Number} y
     * @private
     */
    static _onRelease(x, y) {
      this._events.released = true;
      this._x = x;
      this._y = y;
    }
  };
  TouchInput.keyRepeatWait = 24;
  TouchInput.keyRepeatInterval = 6;
  Object.defineProperty(TouchInput, "wheelX", {
    get() {
      return this._wheelX;
    },
    configurable: true
  });
  Object.defineProperty(TouchInput, "wheelY", {
    get() {
      return this._wheelY;
    },
    configurable: true
  });
  Object.defineProperty(TouchInput, "x", {
    get() {
      return this._x;
    },
    configurable: true
  });
  Object.defineProperty(TouchInput, "y", {
    get() {
      return this._y;
    },
    configurable: true
  });
  Object.defineProperty(TouchInput, "date", {
    get() {
      return this._date;
    },
    configurable: true
  });
  TouchInput._onMiddleButtonDown = (event) => {
  };
  var TouchInput_default = TouchInput;

  // src-www/js/rpg_managers/SceneManager.js
  var SceneManager = class {
    constructor() {
      throw new Error("This is a static class");
    }
    static run(sceneClass) {
      try {
        this.initialize();
        this.goto(sceneClass);
        this.requestUpdate();
      } catch (e) {
        this.catchException(e);
      }
    }
    static initialize() {
      this.initProgressWatcher();
      this.initGraphics();
      this.checkFileAccess();
      this.initAudio();
      this.initInput();
      this.initNwjs();
      this.checkPluginErrors();
      this.setupErrorHandlers();
    }
    static initGraphics() {
      const type = this.preferableRendererType();
      Graphics_default.initialize(this._screenWidth, this._screenHeight, type);
      Graphics_default.boxWidth = this._boxWidth;
      Graphics_default.boxHeight = this._boxHeight;
      Graphics_default.setLoadingImage("img/system/Loading.png");
      if (Utils_default.isOptionValid("showfps")) {
        Graphics_default.showFps();
      }
      if (type === "webgl") {
        this.checkWebGL();
      }
    }
    static setupErrorHandlers() {
      window.addEventListener("error", this.onError.bind(this));
      document.addEventListener("keydown", this.onKeyDown.bind(this));
    }
    static frameCount() {
      return this._frameCount;
    }
    static setFrameCount(frameCount) {
      this._frameCount = frameCount;
    }
    static resetFrameCount() {
      this._frameCount = 0;
    }
    static requestUpdate() {
      if (!this._stopped) {
        requestAnimationFrame(this.update.bind(this));
      }
    }
    static update() {
      try {
        this.tickStart();
        if (Utils_default.isMobileSafari()) {
          this.updateInputData();
        }
        this.updateManagers();
        this.updateMain();
        this.tickEnd();
      } catch (e) {
        this.catchException(e);
      }
    }
    static onError({ message, filename, lineno }) {
      console.error(message);
      if (filename || lineno) {
        console.error(filename, lineno);
        try {
          this.stop();
          Graphics_default.printError("Error", message);
          AudioManager_default.stopAll();
        } catch (e2) {
        }
      }
    }
    static catchException(e) {
      if (e instanceof Error) {
        Graphics_default.printError(e.name, e.message);
        Graphics_default.printErrorDetail(e);
        console.error(e.stack);
      } else {
        Graphics_default.printError("UnknownError", e);
      }
      AudioManager_default.stopAll();
      this.stop();
    }
    static updateMain() {
      if (Utils_default.isHighFps()) {
        if (Utils_default.isMobileSafari()) {
          this.changeScene();
          this.updateScene();
        } else {
          const newTime = this._getTimeInMsWithoutMobileSafari();
          if (this._currentTime === void 0) {
            this._currentTime = newTime;
          }
          let fTime = (newTime - this._currentTime) / 1e3;
          if (fTime > 0.25) {
            fTime = 0.25;
          }
          this._currentTime = newTime;
          this._accumulator += fTime;
          while (this._accumulator >= this._deltaTime) {
            this.updateInputData();
            this.changeScene();
            this.updateScene();
            this._accumulator -= this._deltaTime;
          }
        }
        this.renderScene();
        this.requestUpdate();
      } else {
        this.updateInputData();
        this.changeScene();
        this.updateScene();
        this.renderScene();
        this.requestUpdate();
      }
    }
    static changeScene() {
      if (this.isSceneChanging() && !this.isCurrentSceneBusy()) {
        if (this._scene) {
          this._scene.terminate();
          this._scene.detachReservation();
          this._previousClass = this._scene.constructor;
        }
        this._scene = this._nextScene;
        if (this._scene) {
          this._scene.attachReservation();
          this._scene.create();
          this._nextScene = null;
          this._sceneStarted = false;
          this.onSceneCreate();
        }
        if (this._exiting) {
          this.terminate();
        }
      }
    }
    static updateScene() {
      if (this._scene) {
        if (!this._sceneStarted && this._scene.isReady()) {
          this._scene.start();
          this._sceneStarted = true;
          this.onSceneStart();
        }
        if (this.isCurrentSceneStarted()) {
          this.updateFrameCount();
          this._scene.update();
        }
      }
    }
    static renderScene() {
      if (this.isCurrentSceneStarted()) {
        Graphics_default.render(this._scene);
      } else if (this._scene) {
        this.onSceneLoading();
      }
    }
    static updateFrameCount() {
      this._frameCount++;
    }
    static isSceneChanging() {
      return this._exiting || !!this._nextScene;
    }
    static isCurrentSceneBusy() {
      return this._scene && this._scene.isBusy();
    }
    static isCurrentSceneStarted() {
      return this._scene && this._sceneStarted;
    }
    static isNextScene(sceneClass) {
      return this._nextScene && this._nextScene.constructor === sceneClass;
    }
    static isPreviousScene(sceneClass) {
      return this._previousClass === sceneClass;
    }
    static goto(sceneClass) {
      if (sceneClass) {
        this._nextScene = new sceneClass();
      }
      if (this._scene) {
        this._scene.stop();
      }
    }
    static push(sceneClass) {
      this._stack.push(this._scene.constructor);
      this.goto(sceneClass);
    }
    static pop() {
      if (this._stack.length > 0) {
        this.goto(this._stack.pop());
      } else {
        this.exit();
      }
    }
    static exit() {
      this.goto(null);
      this._exiting = true;
    }
    static clearStack() {
      this._stack = [];
    }
    static stop() {
      this._stopped = true;
    }
    static prepareNextScene(...args) {
      this._nextScene.prepare(...args);
    }
    static snap() {
      return Bitmap_default.snap(this._scene);
    }
    static snapForBackground() {
      this._backgroundBitmap = this.snap();
      this._backgroundBitmap.blur();
    }
    static backgroundBitmap() {
      return this._backgroundBitmap;
    }
    static resume() {
      this._stopped = false;
      this.requestUpdate();
      if (!Utils_default.isMobileSafari()) {
        this._currentTime = this._getTimeInMsWithoutMobileSafari();
        this._accumulator = 0;
      }
    }
    /*
     * Gets the current time in ms without on iOS Safari.
     * @private
     */
    static _getTimeInMsWithoutMobileSafari() {
      return performance.now();
    }
    static initProgressWatcher() {
      ProgressWatcher_default.initialize();
    }
    static preferableRendererType() {
      if (Utils_default.isOptionValid("canvas")) {
        return "canvas";
      } else if (Utils_default.isOptionValid("webgl")) {
        return "webgl";
      } else {
        return "auto";
      }
    }
    static shouldUseCanvasRenderer() {
      return Utils_default.isMobileDevice();
    }
    static checkWebGL() {
      if (!Graphics_default.hasWebGL()) {
        throw new Error("Your browser does not support WebGL.");
      }
    }
    static checkFileAccess() {
      if (!Utils_default.canReadGameFiles()) {
        throw new Error("Your browser does not allow to read local files.");
      }
    }
    static initAudio() {
      if (Utils_default.isWorker()) {
        console.log("WebAudio is not supported on worker.");
        return true;
      }
      const noAudio = Utils_default.isOptionValid("noaudio");
      if (!WebAudio_default.initialize(noAudio) && !noAudio) {
        throw new Error("Your browser does not support Web Audio API.");
      }
    }
    static initInput() {
      Input_default.initialize();
      TouchInput_default.initialize();
    }
    static initNwjs() {
      if (Utils_default.isNwjs()) {
        const gui = __require("nw.gui");
        const win = gui.Window.get();
        if (process.platform === "darwin" && !win.menu) {
          const menubar = new gui.Menu({
            type: "menubar"
          });
          const option = {
            hideEdit: true,
            hideWindow: true
          };
          menubar.createMacBuiltin("Game", option);
          win.menu = menubar;
        }
      }
    }
    static checkPluginErrors() {
      PluginManager_default.checkErrors();
    }
    static terminate() {
      window.close();
    }
    static onKeyDown({ ctrlKey, altKey, keyCode }) {
      if (!ctrlKey && !altKey) {
        switch (keyCode) {
          case 116:
            if (Utils_default.isNwjs()) {
              location.reload();
            }
            break;
          case 119:
            if (Utils_default.isNwjs() && Utils_default.isOptionValid("test")) {
              __require("nw.gui").Window.get().showDevTools();
            }
            break;
        }
      }
    }
    static tickStart() {
      Graphics_default.tickStart();
    }
    static tickEnd() {
      Graphics_default.tickEnd();
    }
    static updateInputData() {
      Input_default.update();
      TouchInput_default.update();
    }
    static updateManagers() {
      ImageManager_default.update();
    }
    static onSceneCreate() {
      Graphics_default.startLoading();
    }
    static onSceneStart() {
      Graphics_default.callGC();
      Graphics_default.endLoading();
    }
    static onSceneLoading() {
      Graphics_default.updateLoading();
    }
  };
  SceneManager._scene = null;
  SceneManager._nextScene = null;
  SceneManager._stack = [];
  SceneManager._stopped = false;
  SceneManager._sceneStarted = false;
  SceneManager._exiting = false;
  SceneManager._previousClass = null;
  SceneManager._backgroundBitmap = null;
  SceneManager._screenWidth = 816;
  SceneManager._screenHeight = 624;
  SceneManager._boxWidth = 816;
  SceneManager._boxHeight = 624;
  SceneManager._deltaTime = 1 / 60;
  if (!Utils_default.isMobileSafari())
    SceneManager._currentTime = SceneManager._getTimeInMsWithoutMobileSafari();
  SceneManager._accumulator = 0;
  SceneManager._frameCount = 0;
  var SceneManager_default = SceneManager;

  // src-www/js/rpg_core/ResourceHandler.js
  var ResourceHandler = class {
    constructor() {
      throw new Error("This is a static class");
    }
    static createLoader(url2, retryMethod, resignMethod, retryInterval = this._defaultRetryInterval) {
      const reloaders = this._reloaders;
      let retryCount = 0;
      return () => {
        if (retryCount < retryInterval.length) {
          setTimeout(retryMethod, retryInterval[retryCount]);
          retryCount++;
        } else {
          if (resignMethod) {
            resignMethod();
          }
          if (url2) {
            if (reloaders.length === 0) {
              Graphics_default.printLoadingError(url2);
              SceneManager_default.stop();
            }
            reloaders.push(() => {
              retryCount = 0;
              retryMethod();
            });
          }
        }
      };
    }
    static exists() {
      return this._reloaders.length > 0;
    }
    static retry() {
      if (this._reloaders.length > 0) {
        Graphics_default.eraseLoadingError();
        SceneManager_default.resume();
        this._reloaders.forEach((reloader) => {
          reloader();
        });
        this._reloaders.length = 0;
      }
    }
  };
  ResourceHandler._reloaders = [];
  ResourceHandler._defaultRetryInterval = [500, 1e3, 3e3];
  var ResourceHandler_default = ResourceHandler;

  // src-www/js/rpg_core/ContextShim.js
  var ContextShim = class {
    constructor(...args) {
      this.globalCompositeOperation = "";
      this.fillStyle = "";
      this.globalAlpha = 1;
    }
    clearRect() {
      console.log("ContextShim clearRect");
    }
    save() {
      console.log("ContextShim save");
    }
    drawImage() {
      console.log("ContextShim drawImage");
    }
    restore() {
      console.log("ContextShim restore");
    }
    fillRect() {
      console.log("ContextShim fillRect");
    }
    beginPath() {
      console.log("ContextShim beginPath");
    }
    arc() {
      console.log("ContextShim arc");
    }
    stroke() {
      console.log("ContextShim stroke");
    }
    setTransform() {
      console.log("ContextShim setTransform");
    }
    putImageData() {
      console.log("ContextShim putImageData");
    }
    createLinearGradient() {
      console.log("ContextShim createLinearGradient");
      return {
        addColorStop: () => console.log("ContextShim createLinearGradient.addColorStop")
      };
    }
    getImageData() {
      console.log("ContextShim getImageData");
      return {
        data: []
      };
    }
  };
  var ContextShim_default = ContextShim;

  // src-www/js/rpg_core/CanvasShim.js
  var CanvasShim = class extends Container {
    constructor(...args) {
      super(...args);
      this._opacity = 1;
      this._zIndex = 3;
      this.style = {};
      this.context = new ContextShim_default();
      Object.defineProperty(this.style, "opacity", {
        get() {
          return this._opacity;
        },
        set(value3) {
          this._opacity = value3;
          this.alpha = value3;
        },
        configurable: true
      });
      Object.defineProperty(this.style, "zIndex", {
        get() {
          return this._zIndex;
        },
        set(value3) {
          this._zIndex = value3;
        },
        configurable: true
      });
    }
    getContext(type) {
      return this.context;
    }
  };
  var CanvasShim_default = CanvasShim;

  // node_modules/gamestats.js/build/gamestats.module.js
  function asyncGeneratorStep(gen, resolve2, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value3 = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve2(value3);
    } else {
      Promise.resolve(value3).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve2, reject) {
        var gen = fn.apply(self2, args);
        function _next(value3) {
          asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "next", value3);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "throw", err);
        }
        _next(void 0);
      });
    };
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target2, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target2, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct2(Parent2, args2, Class2) {
        var a2 = [null];
        a2.push.apply(a2, args2);
        var Constructor = Function.bind.apply(Parent2, a2);
        var instance = new Constructor();
        if (Class2)
          _setPrototypeOf(instance, Class2.prototype);
        return instance;
      };
    }
    return _construct.apply(null, arguments);
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr))
      return _arrayLikeToArray(arr);
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
      return Array.from(iter);
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++)
      arr2[i] = arr[i];
    return arr2;
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function() {
        };
        return {
          s: F,
          n: function() {
            if (i >= o.length)
              return {
                done: true
              };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function(e) {
            throw e;
          },
          f: F
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
      s: function() {
        it = o[Symbol.iterator]();
      },
      n: function() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function(e) {
        didErr = true;
        err = e;
      },
      f: function() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      }
    };
  }
  function createCommonjsModule2(fn, module2) {
    return module2 = { exports: {} }, fn(module2, module2.exports), module2.exports;
  }
  var runtime_1 = createCommonjsModule2(function(module2) {
    var runtime = function(exports) {
      var Op = Object.prototype;
      var hasOwn = Op.hasOwnProperty;
      var undefined$1;
      var $Symbol = typeof Symbol === "function" ? Symbol : {};
      var iteratorSymbol = $Symbol.iterator || "@@iterator";
      var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
      var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define(obj, key, value3) {
        Object.defineProperty(obj, key, {
          value: value3,
          enumerable: true,
          configurable: true,
          writable: true
        });
        return obj[key];
      }
      try {
        define({}, "");
      } catch (err) {
        define = function(obj, key, value3) {
          return obj[key] = value3;
        };
      }
      function wrap(innerFn, outerFn, self2, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
        var generator = Object.create(protoGenerator.prototype);
        var context2 = new Context(tryLocsList || []);
        generator._invoke = makeInvokeMethod(innerFn, self2, context2);
        return generator;
      }
      exports.wrap = wrap;
      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }
      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed";
      var ContinueSentinel = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var IteratorPrototype = {};
      IteratorPrototype[iteratorSymbol] = function() {
        return this;
      };
      var getProto = Object.getPrototypeOf;
      var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
        IteratorPrototype = NativeIteratorPrototype;
      }
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
      GeneratorFunctionPrototype.constructor = GeneratorFunction;
      GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction");
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
          define(prototype, method, function(arg) {
            return this._invoke(method, arg);
          });
        });
      }
      exports.isGeneratorFunction = function(genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };
      exports.mark = function(genFun) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;
          define(genFun, toStringTagSymbol, "GeneratorFunction");
        }
        genFun.prototype = Object.create(Gp);
        return genFun;
      };
      exports.awrap = function(arg) {
        return {
          __await: arg
        };
      };
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve2, reject) {
          var record = tryCatch(generator[method], generator, arg);
          if (record.type === "throw") {
            reject(record.arg);
          } else {
            var result2 = record.arg;
            var value3 = result2.value;
            if (value3 && typeof value3 === "object" && hasOwn.call(value3, "__await")) {
              return PromiseImpl.resolve(value3.__await).then(function(value4) {
                invoke("next", value4, resolve2, reject);
              }, function(err) {
                invoke("throw", err, resolve2, reject);
              });
            }
            return PromiseImpl.resolve(value3).then(function(unwrapped) {
              result2.value = unwrapped;
              resolve2(result2);
            }, function(error) {
              return invoke("throw", error, resolve2, reject);
            });
          }
        }
        var previousPromise;
        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function(resolve2, reject) {
              invoke(method, arg, resolve2, reject);
            });
          }
          return previousPromise = // If enqueue has been called before, then we want to wait until
          // all previous Promises have been resolved before calling invoke,
          // so that results are always delivered in the correct order. If
          // enqueue has not been called before, then it is important to
          // call invoke immediately, without waiting on a callback to fire,
          // so that the async generator function has the opportunity to do
          // any necessary setup in a predictable way. This predictability
          // is why the Promise constructor synchronously invokes its
          // executor callback, and why async functions synchronously
          // execute code before the first await. Since we implement simple
          // async functions in terms of async generators, it is especially
          // important to get this right, even though it requires care.
          previousPromise ? previousPromise.then(
            callInvokeWithMethodAndArg,
            // Avoid propagating failures to Promises returned by later
            // invocations of the iterator.
            callInvokeWithMethodAndArg
          ) : callInvokeWithMethodAndArg();
        }
        this._invoke = enqueue;
      }
      defineIteratorMethods(AsyncIterator.prototype);
      AsyncIterator.prototype[asyncIteratorSymbol] = function() {
        return this;
      };
      exports.AsyncIterator = AsyncIterator;
      exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
        if (PromiseImpl === void 0)
          PromiseImpl = Promise;
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
        return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result2) {
          return result2.done ? result2.value : iter.next();
        });
      };
      function makeInvokeMethod(innerFn, self2, context2) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }
          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            }
            return doneResult();
          }
          context2.method = method;
          context2.arg = arg;
          while (true) {
            var delegate = context2.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context2);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel)
                  continue;
                return delegateResult;
              }
            }
            if (context2.method === "next") {
              context2.sent = context2._sent = context2.arg;
            } else if (context2.method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw context2.arg;
              }
              context2.dispatchException(context2.arg);
            } else if (context2.method === "return") {
              context2.abrupt("return", context2.arg);
            }
            state = GenStateExecuting;
            var record = tryCatch(innerFn, self2, context2);
            if (record.type === "normal") {
              state = context2.done ? GenStateCompleted : GenStateSuspendedYield;
              if (record.arg === ContinueSentinel) {
                continue;
              }
              return {
                value: record.arg,
                done: context2.done
              };
            } else if (record.type === "throw") {
              state = GenStateCompleted;
              context2.method = "throw";
              context2.arg = record.arg;
            }
          }
        };
      }
      function maybeInvokeDelegate(delegate, context2) {
        var method = delegate.iterator[context2.method];
        if (method === undefined$1) {
          context2.delegate = null;
          if (context2.method === "throw") {
            if (delegate.iterator["return"]) {
              context2.method = "return";
              context2.arg = undefined$1;
              maybeInvokeDelegate(delegate, context2);
              if (context2.method === "throw") {
                return ContinueSentinel;
              }
            }
            context2.method = "throw";
            context2.arg = new TypeError("The iterator does not provide a 'throw' method");
          }
          return ContinueSentinel;
        }
        var record = tryCatch(method, delegate.iterator, context2.arg);
        if (record.type === "throw") {
          context2.method = "throw";
          context2.arg = record.arg;
          context2.delegate = null;
          return ContinueSentinel;
        }
        var info = record.arg;
        if (!info) {
          context2.method = "throw";
          context2.arg = new TypeError("iterator result is not an object");
          context2.delegate = null;
          return ContinueSentinel;
        }
        if (info.done) {
          context2[delegate.resultName] = info.value;
          context2.next = delegate.nextLoc;
          if (context2.method !== "return") {
            context2.method = "next";
            context2.arg = undefined$1;
          }
        } else {
          return info;
        }
        context2.delegate = null;
        return ContinueSentinel;
      }
      defineIteratorMethods(Gp);
      define(Gp, toStringTagSymbol, "Generator");
      Gp[iteratorSymbol] = function() {
        return this;
      };
      Gp.toString = function() {
        return "[object Generator]";
      };
      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };
        if (1 in locs) {
          entry.catchLoc = locs[1];
        }
        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }
        this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{
          tryLoc: "root"
        }];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }
      exports.keys = function(object) {
        var keys = [];
        for (var key in object) {
          keys.push(key);
        }
        keys.reverse();
        return function next() {
          while (keys.length) {
            var key2 = keys.pop();
            if (key2 in object) {
              next.value = key2;
              next.done = false;
              return next;
            }
          }
          next.done = true;
          return next;
        };
      };
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }
          if (typeof iterable.next === "function") {
            return iterable;
          }
          if (!isNaN(iterable.length)) {
            var i = -1, next = function next2() {
              while (++i < iterable.length) {
                if (hasOwn.call(iterable, i)) {
                  next2.value = iterable[i];
                  next2.done = false;
                  return next2;
                }
              }
              next2.value = undefined$1;
              next2.done = true;
              return next2;
            };
            return next.next = next;
          }
        }
        return {
          next: doneResult
        };
      }
      exports.values = values;
      function doneResult() {
        return {
          value: undefined$1,
          done: true
        };
      }
      Context.prototype = {
        constructor: Context,
        reset: function(skipTempReset) {
          this.prev = 0;
          this.next = 0;
          this.sent = this._sent = undefined$1;
          this.done = false;
          this.delegate = null;
          this.method = "next";
          this.arg = undefined$1;
          this.tryEntries.forEach(resetTryEntry);
          if (!skipTempReset) {
            for (var name in this) {
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined$1;
              }
            }
          }
        },
        stop: function() {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;
          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }
          return this.rval;
        },
        dispatchException: function(exception) {
          if (this.done) {
            throw exception;
          }
          var context2 = this;
          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context2.next = loc;
            if (caught) {
              context2.method = "next";
              context2.arg = undefined$1;
            }
            return !!caught;
          }
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            var record = entry.completion;
            if (entry.tryLoc === "root") {
              return handle("end");
            }
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },
        abrupt: function(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            finallyEntry = null;
          }
          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;
          if (finallyEntry) {
            this.method = "next";
            this.next = finallyEntry.finallyLoc;
            return ContinueSentinel;
          }
          return this.complete(record);
        },
        complete: function(record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }
          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = this.arg = record.arg;
            this.method = "return";
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }
          return ContinueSentinel;
        },
        finish: function(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },
        "catch": function(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function(iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName,
            nextLoc
          };
          if (this.method === "next") {
            this.arg = undefined$1;
          }
          return ContinueSentinel;
        }
      };
      return exports;
    }(
      // If this script is executing as a CommonJS module, use module.exports
      // as the regeneratorRuntime namespace. Otherwise create a new empty
      // object. Either way, the resulting object will be used to initialize
      // the regeneratorRuntime variable at the top of this file.
      module2.exports
    );
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      Function("r", "regeneratorRuntime = r")(runtime);
    }
  });
  var regenerator = runtime_1;
  var GameStats = /* @__PURE__ */ function() {
    function GameStats2() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, GameStats2);
      var defaultConfig = {
        autoPlace: true,
        targetFPS: 60,
        redrawInterval: 50,
        maximumHistory: 100,
        scale: 1,
        memoryUpdateInterval: 1e3,
        memoryMaxHistory: 60 * 10,
        // 10 minutes of memory measurements
        // COLORS
        FONT_FAMILY: "Arial",
        COLOR_FPS_BAR: "#34cfa2",
        COLOR_FPS_AVG: "#FFF",
        COLOR_TEXT_LABEL: "#FFF",
        COLOR_TEXT_TO_LOW: "#eee207",
        COLOR_TEXT_BAD: "#d34646",
        COLOR_TEXT_TARGET: "#d249dd",
        COLOR_BG: "#333333"
      };
      this.config = Object.assign(defaultConfig, options);
      this.dom;
      this.canvas;
      this.ctx;
      this.currentTime;
      this.prevTime;
      this.shown = true;
      this.lastMSAverage;
      this.lastMemoryMeasure = -Number.POSITIVE_INFINITY;
      this.labels = {};
      this.labelColors = {
        "ms": this.config.COLOR_FPS_BAR,
        "memory": this.config.COLOR_FPS_BAR
      };
      this.labelOrder = [];
      this.graphYOffset = 0;
      this.extensions = {};
      this.config.baseCanvasWidth = 100 * this.config.scale;
      this.config.baseCanvasHeight = 150 * this.config.scale;
      this.msGraph = {
        width: this.config.baseCanvasWidth,
        height: this.config.baseCanvasHeight * 0.4,
        drawY: this.config.baseCanvasHeight * 0.16,
        barWidth: this.config.baseCanvasWidth / this.config.maximumHistory
      };
      this.memoryGraph = {
        width: this.config.baseCanvasWidth,
        height: this.config.baseCanvasHeight * 0.2,
        drawY: this.config.baseCanvasHeight * 0.76,
        barWidth: this.config.baseCanvasWidth / this.config.memoryMaxHistory
      };
      this.init();
    }
    _createClass(GameStats2, [{
      key: "init",
      value: function init2() {
        this.canvas = document.createElement("canvas");
        this.canvas.width = this.config.baseCanvasWidth;
        this.canvas.height = this.config.baseCanvasHeight;
        this.canvas.style.cssText = "width:".concat(this.config.baseCanvasWidth * this.config.scale, "px;height:").concat(this.config.baseCanvasHeight * this.config.scale, "px;background-color:").concat(this.config.COLOR_BG);
        this.ctx = this.canvas.getContext("2d");
        this.dom = document.createElement("div");
        this.dom.appendChild(this.canvas);
        this.dom.setAttribute("data", "gamestats");
        this.dom.style.cssText = "position:fixed;left:0;top:0;display: flex;flex-direction: column;gap: 5px;";
        if (this.config.autoPlace) {
          document.body.appendChild(this.dom);
        }
        if (performance && performance.memory) {
          this.labels["memory"] = [];
        }
        this.update = this.update.bind(this);
        this.update();
      }
    }, {
      key: "begin",
      value: function begin(label, color2) {
        if (["ms", "fps", "memory"].includes(label))
          throw "jsgraphy: label ".concat(label, " is reserved");
        if (!label)
          label = "ms";
        if (label === "ms" && this.currentTime)
          this.prevTime = this.currentTime;
        if (label !== "ms" && !this.labelColors[label]) {
          this.labelColors[label] = color2 || this.stringToColor(label);
          this.labelOrder.push(label);
        }
        if (!this.labels[label])
          this.labels[label] = [];
        var labelMeasures = this.labels[label];
        labelMeasures.push(performance.now());
        if (labelMeasures.length > this.config.maximumHistory)
          labelMeasures.shift();
        if (label === "ms") {
          this.currentTime = performance.now();
          if (this.prevTime) {
            if (!this.labels["fps"])
              this.labels["fps"] = [];
            var fpsMeasures = this.labels["fps"];
            fpsMeasures.push(this.currentTime - this.prevTime);
            if (fpsMeasures.length > this.config.maximumHistory)
              fpsMeasures.shift();
          }
        }
      }
    }, {
      key: "show",
      value: function show(visible) {
        this.shown = visible;
        this.dom.style.display = visible ? "flex" : "none";
      }
    }, {
      key: "end",
      value: function end() {
        var label = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "ms";
        var labelMeasures = this.labels[label];
        if (labelMeasures) {
          var beginTime = labelMeasures[labelMeasures.length - 1];
          labelMeasures[labelMeasures.length - 1] = performance.now() - beginTime;
        }
        if (label === "ms") {
          for (var key in this.extensions) {
            this.extensions[key].endFrame();
          }
        }
      }
    }, {
      key: "update",
      value: function update() {
        if (this.shown)
          this.draw();
        if (performance && performance.memory && performance.now() - this.lastMemoryMeasure > this.config.memoryUpdateInterval) {
          var memoryMeasures = this.labels["memory"];
          memoryMeasures.push(performance.memory.usedJSHeapSize / TOMB);
          if (memoryMeasures.length > this.config.memoryMaxHistory)
            memoryMeasures.shift();
          this.lastMemoryMeasure = performance.now();
        }
        if (this.canvas && this.canvas.parentNode) {
          setTimeout(this.update, this.config.redrawInterval);
        }
        for (var key in this.extensions) {
          this.extensions[key].update();
        }
      }
    }, {
      key: "draw",
      value: function draw() {
        if (!this.prevTime)
          return;
        var ctx = this.ctx;
        var imageData = ctx.getImageData(1, 0, ctx.canvas.width - this.msGraph.barWidth, ctx.canvas.height);
        ctx.putImageData(imageData, 0, 0);
        ctx.clearRect(ctx.canvas.width - this.msGraph.barWidth, 0, this.msGraph.barWidth, ctx.canvas.height);
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height * 0.16);
        if (performance.memory)
          ctx.clearRect(0, ctx.canvas.height * 0.6, ctx.canvas.width, ctx.canvas.height * 0.16);
        this.drawGraph("ms", 1e3 / this.config.targetFPS);
        this.drawFPS();
        this.graphYOffset = 0;
        var _iterator = _createForOfIteratorHelper(this.labelOrder), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var label = _step.value;
            this.drawGraph(label, this.previousMaxMS, true);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        this.drawLines();
        if (performance && performance.memory) {
          this.drawMemory();
        }
      }
    }, {
      key: "drawLines",
      value: function drawLines() {
        var config = this.config;
        var ctx = this.ctx;
        var targetFPS = 1e3 / config.targetFPS;
        var average = this.previousAverageMS;
        var max = this.previousMaxMS;
        ctx.fillStyle = config.COLOR_FPS_AVG;
        if (average > targetFPS * 1.66)
          ctx.fillStyle = config.COLOR_TEXT_BAD;
        else if (average > targetFPS * 1.33)
          ctx.fillStyle = config.COLOR_TEXT_TO_LOW;
        var averageH = average / max * this.msGraph.height;
        var averageY = this.msGraph.drawY + this.msGraph.height - averageH;
        ctx.fillRect(this.msGraph.width - this.msGraph.barWidth, averageY, this.msGraph.barWidth, this.msGraph.barWidth);
        ctx.fillStyle = config.COLOR_TEXT_TARGET;
        var targetH = targetFPS / max * this.msGraph.height;
        var targetY = this.msGraph.drawY + this.msGraph.height - targetH;
        ctx.fillRect(this.msGraph.width - this.msGraph.barWidth, targetY, this.msGraph.barWidth, this.msGraph.barWidth);
      }
    }, {
      key: "drawGraph",
      value: function drawGraph(label, minMaxValue, doYOffsets) {
        var labelMeasures = this.labels[label];
        var _this$getMMA = this.getMMA(labelMeasures), max = _this$getMMA.max, average = _this$getMMA.average;
        max = Math.max(average * 1.5, max);
        if (minMaxValue)
          max = Math.max(minMaxValue, max);
        var config = this.config;
        var ctx = this.ctx;
        var lastIndex = labelMeasures.length - 1;
        var measure = labelMeasures[lastIndex];
        var yOffset = 0;
        if (doYOffsets && this.graphYOffset)
          yOffset += this.graphYOffset;
        var x = config.maximumHistory * this.msGraph.barWidth - this.msGraph.barWidth;
        var y = this.msGraph.drawY;
        var w = this.msGraph.barWidth;
        var h = measure / max * this.msGraph.height;
        y += this.msGraph.height - h - yOffset;
        ctx.globalAlpha = 0.5;
        ctx.fillStyle = this.labelColors[label];
        ctx.fillRect(x, y, w, h);
        ctx.globalAlpha = 1;
        ctx.fillRect(x, y, w, w);
        if (doYOffsets) {
          this.graphYOffset = (this.graphYOffset || 0) + h;
        }
        if (label === "ms") {
          this.previousAverageMS = average;
          this.previousMaxMS = max;
        }
      }
    }, {
      key: "drawFPS",
      value: function drawFPS() {
        var ctx = this.ctx;
        var config = this.config;
        var fpsMeasures = this.labels["fps"];
        if (!fpsMeasures)
          return;
        var _this$getMMA2 = this.getMMA(fpsMeasures), min = _this$getMMA2.min, max = _this$getMMA2.max, average = _this$getMMA2.average;
        var averageFPS = Math.round(1e3 / average);
        var maxFPS = Math.round(1e3 / min);
        var minFPS = Math.round(1e3 / max);
        var msMeasures = this.labels["ms"];
        var ms = msMeasures[msMeasures.length - 1].toFixed(1);
        var FPS = Math.round(1e3 / fpsMeasures[fpsMeasures.length - 1]);
        var padding = config.baseCanvasHeight * 0.01;
        ctx.textAlign = "left";
        var fontSize = config.baseCanvasWidth * 0.09;
        ctx.font = "".concat(fontSize, "px ").concat(config.FONT_FAMILY);
        ctx.textBaseline = "top";
        ctx.fillStyle = config.COLOR_TEXT_LABEL;
        ctx.fillText("avg min max", padding, padding);
        fontSize = config.baseCanvasWidth * 0.12;
        if (FPS < config.targetFPS * 0.33)
          ctx.fillStyle = config.COLOR_TEXT_BAD;
        else if (FPS < config.targetFPS * 0.66)
          ctx.fillStyle = config.COLOR_TEXT_TO_LOW;
        ctx.font = "".concat(fontSize, "px ").concat(config.FONT_FAMILY);
        ctx.textAlign = "right";
        ctx.fillText("".concat(FPS, " fps"), config.baseCanvasWidth - padding, padding);
        fontSize = config.baseCanvasWidth * 0.1;
        ctx.font = "".concat(fontSize, "px ").concat(config.FONT_FAMILY);
        var msYOffset = config.baseCanvasWidth * 0.12;
        ctx.fillText("".concat(ms, "ms"), config.baseCanvasWidth - padding, msYOffset + padding);
        fontSize = config.baseCanvasWidth * 0.09;
        ctx.font = "".concat(fontSize, "px ").concat(config.FONT_FAMILY);
        var avgMinMaxOffsetX = config.baseCanvasWidth * 0.175;
        var avgMinMaxOffsetY = config.baseCanvasWidth * 0.1;
        var badFPS = config.targetFPS * 0.33;
        var toLowFPS = config.targetFPS * 0.66;
        ctx.fillStyle = config.COLOR_FPS_BAR;
        if (averageFPS < badFPS)
          ctx.fillStyle = config.COLOR_TEXT_BAD;
        else if (averageFPS < toLowFPS)
          ctx.fillStyle = config.COLOR_TEXT_TO_LOW;
        ctx.fillText("".concat(averageFPS), avgMinMaxOffsetX - padding, avgMinMaxOffsetY + padding);
        ctx.fillStyle = config.COLOR_FPS_BAR;
        if (minFPS < badFPS)
          ctx.fillStyle = config.COLOR_TEXT_BAD;
        else if (minFPS < toLowFPS)
          ctx.fillStyle = config.COLOR_TEXT_TO_LOW;
        ctx.fillText("".concat(minFPS), avgMinMaxOffsetX * 2.1 - padding * 2, avgMinMaxOffsetY + padding);
        ctx.fillStyle = config.COLOR_FPS_BAR;
        if (maxFPS < badFPS)
          ctx.fillStyle = config.COLOR_TEXT_BAD;
        else if (maxFPS < toLowFPS)
          ctx.fillStyle = config.COLOR_TEXT_TO_LOW;
        ctx.fillText("".concat(maxFPS), avgMinMaxOffsetX * 3.3 - padding * 3, avgMinMaxOffsetY + padding);
      }
    }, {
      key: "drawMemory",
      value: function drawMemory() {
        var config = this.config;
        var ctx = this.ctx;
        var padding = config.baseCanvasHeight * 0.01;
        var memoryTextY = config.baseCanvasHeight * 0.6;
        ctx.textAlign = "left";
        var fontSize = config.baseCanvasWidth * 0.09;
        ctx.font = "".concat(fontSize, "px ").concat(config.FONT_FAMILY);
        ctx.textBaseline = "top";
        ctx.fillStyle = config.COLOR_TEXT_LABEL;
        ctx.fillText("reserved", padding, memoryTextY + padding);
        ctx.fillStyle = config.COLOR_TEXT_TARGET;
        ctx.textAlign = "right";
        var reservedMemory = (performance.memory.jsHeapSizeLimit / TOMB).toFixed(1);
        ctx.fillText("".concat(reservedMemory, "MB"), config.baseCanvasWidth - padding, memoryTextY + padding);
        ctx.textAlign = "left";
        ctx.fillStyle = config.COLOR_TEXT_LABEL;
        ctx.fillText("allocated", padding, memoryTextY * 1.12 + padding);
        ctx.textAlign = "right";
        var allocatedMemory = (performance.memory.usedJSHeapSize / TOMB).toFixed(1);
        ctx.fillStyle = config.COLOR_FPS_BAR;
        if (allocatedMemory > reservedMemory * 0.9) {
          ctx.fillStyle = config.COLOR_TEXT_BAD;
        } else if (allocatedMemory > reservedMemory * 0.66) {
          ctx.fillStyle = config.COLOR_TEXT_TO_LOW;
        }
        ctx.fillText("".concat(allocatedMemory, "MB"), config.baseCanvasWidth - padding, memoryTextY * 1.12 + padding);
        var targetMemory = performance.memory.jsHeapSizeLimit / TOMB;
        var memoryMeasures = this.labels["memory"];
        var lastValue = memoryMeasures[memoryMeasures.length - 1];
        var x = this.memoryGraph.width - this.memoryGraph.barWidth * 6;
        var y = this.memoryGraph.drawY;
        var w = this.memoryGraph.barWidth * 6;
        var h = lastValue / targetMemory * this.memoryGraph.height;
        y += this.memoryGraph.height - h;
        ctx.globalAlpha = 0.5;
        ctx.fillStyle = this.labelColors["memory"];
        ctx.fillRect(x, y, w, h);
        ctx.globalAlpha = 1;
        ctx.fillRect(x, y, w, w);
        var _this$getMMA3 = this.getMMA(this.labels["memory"]), average = _this$getMMA3.average;
        ctx.fillStyle = config.COLOR_FPS_AVG;
        if (average > targetMemory * 0.9)
          ctx.fillStyle = config.COLOR_TEXT_BAD;
        else if (average > targetMemory * 0.66)
          ctx.fillStyle = config.COLOR_TEXT_TO_LOW;
        var averageH = average / targetMemory * this.memoryGraph.height;
        var averageY = this.memoryGraph.drawY + this.memoryGraph.height - averageH;
        ctx.fillRect(this.memoryGraph.width - this.memoryGraph.barWidth * 6, averageY, this.memoryGraph.barWidth * 6, this.memoryGraph.barWidth * 6);
        ctx.fillStyle = config.COLOR_TEXT_TARGET;
        var targetH = this.memoryGraph.height;
        var targetY = this.memoryGraph.drawY + this.memoryGraph.height - targetH;
        ctx.fillRect(this.memoryGraph.width - this.memoryGraph.barWidth * 6, targetY, this.memoryGraph.barWidth * 6, this.memoryGraph.barWidth * 6);
      }
    }, {
      key: "getMMA",
      value: function getMMA(measures) {
        var min = Number.POSITIVE_INFINITY;
        var max = -Number.POSITIVE_INFINITY;
        var average = 0;
        var _iterator2 = _createForOfIteratorHelper(measures), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var measure = _step2.value;
            if (measure < min)
              min = measure;
            if (measure > max)
              max = measure;
            average += measure;
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        average /= measures.length;
        return {
          min,
          max,
          average
        };
      }
    }, {
      key: "stringToColor",
      value: function stringToColor(str) {
        var hash = 0;
        for (var i = 0; i < str.length; i++) {
          hash = str.charCodeAt(i) + ((hash << 5) - hash);
        }
        var c = (hash & 16777215).toString(16).toUpperCase();
        return "#".concat("00000".substring(0, 6 - c.length)).concat(c);
      }
    }, {
      key: "enableExtension",
      value: function() {
        var _enableExtension = _asyncToGenerator(/* @__PURE__ */ regenerator.mark(function _callee(name, params2) {
          var module2, extension;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!this.extensions[name]) {
                    _context.next = 2;
                    break;
                  }
                  return _context.abrupt("return", null);
                case 2:
                  _context.prev = 2;
                  _context.next = 5;
                  return import("./gamestats-".concat(name, ".module.js"));
                case 5:
                  module2 = _context.sent;
                  extension = _construct(module2["default"], [this].concat(_toConsumableArray(params2)));
                  this.extensions[name] = extension;
                  _context.next = 14;
                  break;
                case 10:
                  _context.prev = 10;
                  _context.t0 = _context["catch"](2);
                  console.log(_context.t0);
                  return _context.abrupt("return", null);
                case 14:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this, [[2, 10]]);
        }));
        function enableExtension(_x, _x2) {
          return _enableExtension.apply(this, arguments);
        }
        return enableExtension;
      }()
    }]);
    return GameStats2;
  }();
  var TOMB = 1048576;
  var gamestats_module_default = GameStats;

  // src-www/js/rpg_core/Graphics.js
  var Graphics2 = class {
    constructor() {
      throw new Error("This is a static class");
    }
    /**
     * Initializes the graphics system.
     *
     * @static
     * @method initialize
     * @param {Number} width The width of the game screen
     * @param {Number} height The height of the game screen
     * @param {String} type The type of the renderer.
     *                 'canvas', 'webgl', or 'auto'.
     */
    static initialize(width, height, type) {
      this._width = width || 800;
      this._height = height || 600;
      this._rendererType = type || "auto";
      this._boxWidth = this._width;
      this._boxHeight = this._height;
      this._scale = 1;
      this._realScale = 1;
      this._errorShowed = false;
      this._errorPrinter = null;
      this._canvas = this._canvas ?? null;
      this._video = null;
      this._videoUnlocked = false;
      this._videoLoading = false;
      this._upperCanvas = null;
      this._fpsMeter = null;
      this._modeBox = null;
      this._skipCount = 0;
      this._maxSkip = 3;
      this._rendered = false;
      this._loadingImage = null;
      this._loadingImageSprite = null;
      this._loadingCount = 0;
      this._fpsMeterToggled = false;
      this._stretchEnabled = this._defaultStretchMode();
      this._canUseDifferenceBlend = false;
      this._canUseSaturationBlend = false;
      this._hiddenCanvas = null;
      this._app = null;
      this._updateRealScale();
      this._createAllElements();
      this._disableTextSelection();
      this._disableContextMenu();
      this._setupEventHandlers();
      this._setupCssFontLoading();
      this._setupProgress();
    }
    static canUseCssFontLoading() {
      return !!this._cssFontLoading;
    }
    /**
     * Renders the stage to the game screen.
     *
     * @static
     * @method render
     * @param {Stage} stage The stage object to be rendered
     */
    static render(stage) {
      if (stage)
        this._app.stage = stage;
    }
    /**
     * Checks whether the renderer type is WebGL.
     *
     * @static
     * @method isWebGL
     * @return {Boolean} True if the renderer type is WebGL
     */
    static isWebGL() {
      return this._renderer && this._renderer.type === RENDERER_TYPE.WEBGL;
    }
    /**
     * Checks whether the canvas blend mode 'difference' is supported.
     *
     * @static
     * @method canUseDifferenceBlend
     * @return {Boolean} True if the canvas blend mode 'difference' is supported
     */
    static canUseDifferenceBlend() {
      return this._canUseDifferenceBlend;
    }
    /**
     * Checks whether the canvas blend mode 'saturation' is supported.
     *
     * @static
     * @method canUseSaturationBlend
     * @return {Boolean} True if the canvas blend mode 'saturation' is supported
     */
    static canUseSaturationBlend() {
      return this._canUseSaturationBlend;
    }
    /**
     * Sets the source of the "Now Loading" image.
     *
     * @static
     * @method setLoadingImage
     */
    static setLoadingImage(src) {
      this._loadingImage = {};
      this._loadingImage.src = src;
    }
    /**
     * Sets whether the progress bar is enabled.
     *
     * @static
     * @method setEnableProgress
     */
    static setProgressEnabled(enable) {
      this._progressEnabled = enable;
    }
    /**
     * Initializes the counter for displaying the "Now Loading" image.
     *
     * @static
     * @method startLoading
     */
    static startLoading() {
      this._loadingCount = 0;
      ProgressWatcher_default.truncateProgress();
      ProgressWatcher_default.setProgressListener(this._updateProgressCount.bind(this));
      this._progressTimeout = setTimeout(() => {
        Graphics2._showProgress();
      }, 1500);
    }
    static _setupProgress() {
      if (Utils_default.isWorker()) {
        console.log("Graphics._setupProgress unsupported on worker.");
        return;
      }
      this._progressElement = document.createElement("div");
      this._progressElement.id = "loading-progress";
      this._progressElement.width = 600;
      this._progressElement.height = 300;
      this._progressElement.style.visibility = "hidden";
      this._barElement = document.createElement("div");
      this._barElement.id = "loading-bar";
      this._barElement.style.width = "100%";
      this._barElement.style.height = "10%";
      this._barElement.style.background = "linear-gradient(to top, gray, lightgray)";
      this._barElement.style.border = "5px solid white";
      this._barElement.style.borderRadius = "15px";
      this._barElement.style.marginTop = "40%";
      this._filledBarElement = document.createElement("div");
      this._filledBarElement.id = "loading-filled-bar";
      this._filledBarElement.style.width = "0%";
      this._filledBarElement.style.height = "100%";
      this._filledBarElement.style.background = "linear-gradient(to top, lime, honeydew)";
      this._filledBarElement.style.borderRadius = "10px";
      this._progressElement.appendChild(this._barElement);
      this._barElement.appendChild(this._filledBarElement);
      this._updateProgress();
      document.body.appendChild(this._progressElement);
    }
    static _showProgress() {
      if (Utils_default.isWorker()) {
        console.log("Graphics._showProgress unsupported on worker.");
        return;
      }
      if (this._progressEnabled) {
        this._progressElement.value = 0;
        this._progressElement.style.visibility = "visible";
        this._progressElement.style.zIndex = 98;
      }
    }
    static _hideProgress() {
      if (Utils_default.isWorker()) {
        console.log("Graphics._hideProgress unsupported on worker.");
        return;
      }
      if (this._progressElement) {
        this._progressElement.style.visibility = "hidden";
      }
      clearTimeout(this._progressTimeout);
    }
    static _updateProgressCount(countLoaded, countLoading) {
      if (Utils_default.isWorker()) {
        console.log("Graphics._updateProgressCount unsupported on worker.");
        return;
      }
      let progressValue;
      if (countLoading !== 0) {
        progressValue = countLoaded / countLoading * 100;
      } else {
        progressValue = 100;
      }
      this._filledBarElement.style.width = `${progressValue}%`;
    }
    static _updateProgress() {
      this._centerElement(this._progressElement);
    }
    /**
     * Increments the loading counter and displays the "Now Loading" image if necessary.
     *
     * @static
     * @method updateLoading
     */
    static updateLoading() {
      if (Utils_default.isWorker()) {
        console.log("Graphics.updateLoading unsupported on worker.");
        return;
      }
      this._loadingCount++;
      this._paintUpperCanvas();
      this._upperCanvas.style.opacity = 1;
      this._updateProgress();
    }
    /**
     * Erases the "Now Loading" image.
     *
     * @static
     * @method endLoading
     */
    static endLoading() {
      if (Utils_default.isWorker()) {
        console.log("Graphics.endLoading unsupported on worker.");
        return;
      }
      this._clearUpperCanvas();
      this._upperCanvas.style.opacity = 0;
      this._hideProgress();
    }
    /**
     * Displays the loading error text to the screen.
     *
     * @static
     * @method printLoadingError
     * @param {String} url The url of the resource failed to load
     */
    static printLoadingError(url2) {
      if (Utils_default.isWorker()) {
        console.log("Graphics.printLoadingError unsupported on worker.");
        return;
      }
      if (this._errorPrinter && !this._errorShowed) {
        this._updateErrorPrinter();
        this._errorPrinter.innerHTML = this._makeErrorHtml(
          "Loading Error",
          `Failed to load: ${url2}`
        );
        this._errorPrinter.style.userSelect = "text";
        this._errorPrinter.style.webkitUserSelect = "text";
        this._errorPrinter.style.msUserSelect = "text";
        this._errorPrinter.style.mozUserSelect = "text";
        this._errorPrinter.oncontextmenu = null;
        const button = document.createElement("button");
        button.innerHTML = "Retry";
        button.style.fontSize = "24px";
        button.style.color = "#ffffff";
        button.style.backgroundColor = "#000000";
        button.addEventListener("touchstart", (event) => {
          event.stopPropagation();
        });
        button.addEventListener("click", (event) => {
          ResourceHandler_default.retry();
        });
        this._errorPrinter.appendChild(button);
        this._loadingCount = -Infinity;
      }
    }
    /**
     * Erases the loading error text.
     *
     * @static
     * @method eraseLoadingError
     */
    static eraseLoadingError() {
      if (this._errorPrinter && !this._errorShowed) {
        this._errorPrinter.innerHTML = "";
        this._errorPrinter.style.userSelect = "none";
        this._errorPrinter.style.webkitUserSelect = "none";
        this._errorPrinter.style.msUserSelect = "none";
        this._errorPrinter.style.mozUserSelect = "none";
        this._errorPrinter.oncontextmenu = () => false;
        this._loadingCount = 0;
      }
    }
    // The following code is partly borrowed from triacontane.
    /**
     * Displays the error text to the screen.
     *
     * @static
     * @method printError
     * @param {String} name The name of the error
     * @param {String} message The message of the error
     */
    static printError(name, message) {
      this._errorShowed = true;
      this._hideProgress();
      this.hideFps();
      if (this._errorPrinter) {
        this._updateErrorPrinter();
        this._errorPrinter.innerHTML = this._makeErrorHtml(name, message);
        this._errorPrinter.style.userSelect = "text";
        this._errorPrinter.style.webkitUserSelect = "text";
        this._errorPrinter.style.msUserSelect = "text";
        this._errorPrinter.style.mozUserSelect = "text";
        this._errorPrinter.oncontextmenu = null;
        if (this._errorMessage) {
          this._makeErrorMessage();
        }
      }
      this._applyCanvasFilter();
      this._clearUpperCanvas();
    }
    /**
     * Shows the detail of error.
     *
     * @static
     * @method printErrorDetail
     */
    static printErrorDetail(error) {
      if (this._errorPrinter && this._showErrorDetail) {
        const eventInfo = this._formatEventInfo(error);
        const eventCommandInfo = this._formatEventCommandInfo(error);
        const info = eventCommandInfo ? `${eventInfo}, ${eventCommandInfo}` : eventInfo;
        const stack = this._formatStackTrace(error);
        this._makeErrorDetail(info, stack);
      }
    }
    /**
     * Sets the error message.
     *
     * @static
     * @method setErrorMessage
     */
    static setErrorMessage(message) {
      this._errorMessage = message;
    }
    /**
     * Sets whether shows the detail of error.
     *
     * @static
     * @method setShowErrorDetail
     */
    static setShowErrorDetail(showErrorDetail) {
      this._showErrorDetail = showErrorDetail;
    }
    /**
     * Shows the FPSMeter element.
     *
     * @static
     * @method showFps
     */
    static showFps() {
      if (Utils_default.isWorker())
        return;
      if (this._fpsMeter) {
        document.body.appendChild(this._fpsMeter.dom);
        this._fpsMeter.show(true);
      }
    }
    /**
     * Hides the FPSMeter element.
     *
     * @static
     * @method hideFps
     */
    static hideFps() {
      if (Utils_default.isWorker())
        return;
      if (this._fpsMeter) {
        if (document.body.contains(this._fpsMeter.dom)) {
          document.body.removeChild(this._fpsMeter.dom);
        }
        this._fpsMeter.show(false);
      }
    }
    /**
     * Loads a font file.
     *
     * @static
     * @method loadFont
     * @param {String} name The face name of the font
     * @param {String} url The url of the font file
     */
    static loadFont(name, url2) {
      if (Utils_default.isWorker()) {
        console.log("Graphics.loadFont unsupported on worker.");
        return;
      }
      const style = document.createElement("style");
      const head = document.getElementsByTagName("head");
      const rule = `@font-face { font-family: "${name}"; src: url("${url2}"); }`;
      style.type = "text/css";
      head.item(0).appendChild(style);
      style.sheet.insertRule(rule, 0);
      this._createFontLoader(name);
    }
    /**
     * Checks whether the font file is loaded.
     *
     * @static
     * @method isFontLoaded
     * @param {String} name The face name of the font
     * @return {Boolean} True if the font file is loaded
     */
    static isFontLoaded(name) {
      if (Graphics2._cssFontLoading) {
        if (Graphics2._fontLoaded) {
          return Graphics2._fontLoaded.check(`10px "${name}"`);
        }
        return false;
      } else {
        if (Utils_default.isWorker()) {
          console.log("Graphics.isFontLoaded unsupported on worker.");
          return true;
        }
        if (!this._hiddenCanvas) {
          this._hiddenCanvas = document.createElement("canvas");
        }
        const context2 = this._hiddenCanvas.getContext("2d");
        const text = "abcdefghijklmnopqrstuvwxyz";
        let width1;
        let width2;
        context2.font = `40px ${name}, sans-serif`;
        width1 = context2.measureText(text).width;
        context2.font = "40px sans-serif";
        width2 = context2.measureText(text).width;
        return width1 !== width2;
      }
    }
    /**
     * Starts playback of a video.
     *
     * @static
     * @method playVideo
     * @param {String} src
     */
    static playVideo(src) {
    }
    /**
     * @static
     * @method _playVideo
     * @param {String} src
     * @private
     */
    static _playVideo(src) {
    }
    /**
     * Checks whether the video is playing.
     *
     * @static
     * @method isVideoPlaying
     * @return {Boolean} True if the video is playing
     */
    static isVideoPlaying() {
      return false;
    }
    /**
     * Checks whether the browser can play the specified video type.
     *
     * @static
     * @method canPlayVideoType
     * @param {String} type The video type to test support for
     * @return {Boolean} True if the browser can play the specified video type
     */
    static canPlayVideoType(type) {
      return false;
    }
    /**
     * Sets volume of a video.
     *
     * @static
     * @method setVideoVolume
     * @param {Number} value
     */
    static setVideoVolume(value3) {
    }
    /**
     * Converts an x coordinate on the page to the corresponding
     * x coordinate on the canvas area.
     *
     * @static
     * @method pageToCanvasX
     * @param {Number} x The x coordinate on the page to be converted
     * @return {Number} The x coordinate on the canvas area
     */
    static pageToCanvasX(x) {
      if (this._canvas) {
        const left = this._canvas.offsetLeft;
        return Math.round((x - left) / this._realScale);
      } else {
        return 0;
      }
    }
    /**
     * Converts a y coordinate on the page to the corresponding
     * y coordinate on the canvas area.
     *
     * @static
     * @method pageToCanvasY
     * @param {Number} y The y coordinate on the page to be converted
     * @return {Number} The y coordinate on the canvas area
     */
    static pageToCanvasY(y) {
      if (this._canvas) {
        const top = this._canvas.offsetTop;
        return Math.round((y - top) / this._realScale);
      } else {
        return 0;
      }
    }
    /**
     * Checks whether the specified point is inside the game canvas area.
     *
     * @static
     * @method isInsideCanvas
     * @param {Number} x The x coordinate on the canvas area
     * @param {Number} y The y coordinate on the canvas area
     * @return {Boolean} True if the specified point is inside the game canvas area
     */
    static isInsideCanvas(x, y) {
      return x >= 0 && x < this._width && y >= 0 && y < this._height;
    }
    /**
     * @static
     * @method _createAllElements
     * @private
     */
    static _createAllElements() {
      this._createErrorPrinter();
      this._createCanvas();
      this._createVideo();
      this._createRenderer();
      this._createPixiApp();
      this._createUpperCanvas();
      this._createFPSMeter();
      this._createModeBox();
      this._createGameFontLoader();
    }
    /**
     * @static
     * @method _updateAllElements
     * @private
     */
    static _updateAllElements() {
      this._updateRealScale();
      this._updateErrorPrinter();
      this._updateCanvas();
      this._updateVideo();
      this._updateUpperCanvas();
      this._updateRenderer();
      this._paintUpperCanvas();
      this._updateProgress();
    }
    /**
     * @static
     * @method _updateRealScale
     * @private
     */
    static _updateRealScale() {
      if (this._stretchEnabled && self.window) {
        let h = self.window.innerWidth / this._width;
        let v2 = self.window.innerHeight / this._height;
        if (h >= 1 && h - 0.01 <= 1)
          h = 1;
        if (v2 >= 1 && v2 - 0.01 <= 1)
          v2 = 1;
        this._realScale = Math.min(h, v2);
      } else {
        this._realScale = this._scale;
      }
    }
    /**
     * @static
     * @method _testCanvasBlendModes
     * @private
     */
    static _testCanvasBlendModes() {
      if (Utils_default.isWorker()) {
        console.log("Graphics._testCanvasBlendModes unsupported on worker.");
        return;
      }
      let canvas;
      let context2;
      let imageData1;
      let imageData2;
      canvas = document.createElement("canvas");
      canvas.width = 1;
      canvas.height = 1;
      context2 = canvas.getContext("2d");
      context2.globalCompositeOperation = "source-over";
      context2.fillStyle = "white";
      context2.fillRect(0, 0, 1, 1);
      context2.globalCompositeOperation = "difference";
      context2.fillStyle = "white";
      context2.fillRect(0, 0, 1, 1);
      imageData1 = context2.getImageData(0, 0, 1, 1);
      context2.globalCompositeOperation = "source-over";
      context2.fillStyle = "black";
      context2.fillRect(0, 0, 1, 1);
      context2.globalCompositeOperation = "saturation";
      context2.fillStyle = "white";
      context2.fillRect(0, 0, 1, 1);
      imageData2 = context2.getImageData(0, 0, 1, 1);
      this._canUseDifferenceBlend = imageData1.data[0] === 0;
      this._canUseSaturationBlend = imageData2.data[0] === 0;
    }
    /**
     * @static
     * @method _createErrorPrinter
     * @private
     */
    static _createErrorPrinter() {
      if (Utils_default.isWorker()) {
        console.log("Graphics._createErrorPrinter unsupported on worker.");
        return;
      }
      this._errorPrinter = document.createElement("p");
      this._errorPrinter.id = "ErrorPrinter";
      this._updateErrorPrinter();
      document.body.appendChild(this._errorPrinter);
    }
    /**
     * @static
     * @method _updateErrorPrinter
     * @private
     */
    static _updateErrorPrinter() {
      if (this._errorPrinter) {
        this._errorPrinter.width = this._width * 0.9;
        if (this._errorShowed && this._showErrorDetail) {
          this._errorPrinter.height = this._height * 0.9;
        } else if (this._errorShowed && this._errorMessage) {
          this._errorPrinter.height = 100;
        } else {
          this._errorPrinter.height = 40;
        }
        this._errorPrinter.style.textAlign = "center";
        this._errorPrinter.style.textShadow = "1px 1px 3px #000";
        this._errorPrinter.style.fontSize = "20px";
        this._errorPrinter.style.zIndex = 99;
        this._centerElement(this._errorPrinter);
      }
    }
    /**
     * @static
     * @method _makeErrorMessage
     * @private
     */
    static _makeErrorMessage() {
      if (Utils_default.isWorker()) {
        console.log("Graphics._makeErrorMessage unsupported on worker.");
        return;
      }
      const mainMessage = document.createElement("div");
      const style = mainMessage.style;
      style.color = "white";
      style.textAlign = "left";
      style.fontSize = "18px";
      mainMessage.innerHTML = `<hr>${this._errorMessage}`;
      this._errorPrinter.appendChild(mainMessage);
    }
    /**
     * @static
     * @method _makeErrorDetail
     * @private
     */
    static _makeErrorDetail(info, stack) {
      if (Utils_default.isWorker()) {
        console.log("Graphics._makeErrorDetail unsupported on worker.");
        return;
      }
      const detail = document.createElement("div");
      const style = detail.style;
      style.color = "white";
      style.textAlign = "left";
      style.fontSize = "18px";
      detail.innerHTML = `<br><hr>${info}<br><br>${stack}`;
      this._errorPrinter.appendChild(detail);
    }
    /**
     * @static
     * @method _createCanvas
     * @private
     */
    static _createCanvas() {
      if (Utils_default.isWorker()) {
        if (this._canvas)
          this._updateCanvas();
      } else {
        this._canvas = document.createElement("canvas");
        this._canvas.id = "GameCanvas";
        this._updateCanvas();
        document.body.appendChild(this._canvas);
      }
    }
    /**
     * @static
     * @method _updateCanvas
     * @private
     */
    static _updateCanvas() {
      this._canvas.width = this._width;
      this._canvas.height = this._height;
      if (!Utils_default.isWorker()) {
        this._canvas.style.zIndex = 1;
        this._centerElement(this._canvas);
      }
    }
    /**
     * @static
     * @method _createVideo
     * @private
     */
    static _createVideo() {
      if (Utils_default.isWorker()) {
        console.log("Graphics._createVideo unsupported on worker.");
        return;
      }
      this._video = document.createElement("video");
      this._video.id = "GameVideo";
      this._video.style.opacity = 0;
      this._video.setAttribute("playsinline", "");
      this._video.volume = this._videoVolume;
      this._updateVideo();
      makeVideoPlayableInline(this._video);
      document.body.appendChild(this._video);
    }
    /**
     * @static
     * @method _updateVideo
     * @private
     */
    static _updateVideo() {
    }
    /**
     * @static
     * @method _createUpperCanvas
     * @private
     */
    static _createUpperCanvas() {
      this._upperCanvas = new CanvasShim_default();
      this._updateUpperCanvas();
      if (this._app.stage) {
        this._app.stage.addChild(this._upperCanvas);
      }
    }
    /**
     * @static
     * @method _updateUpperCanvas
     * @private
     */
    static _updateUpperCanvas() {
    }
    /**
     * @static
     * @method _clearUpperCanvas
     * @private
     */
    static _clearUpperCanvas() {
      if (this._upperCanvas) {
        this._upperCanvas.removeChildren();
      }
    }
    /**
     * @static
     * @method _paintUpperCanvas
     * @private
     */
    static _paintUpperCanvas() {
      this._clearUpperCanvas();
      if (this._loadingImage && this._loadingCount >= 20) {
        if (!this._loadingImageSprite) {
          this._loadingImageSprite = Sprite.from(this._loadingImage.src);
        }
        this._upperCanvas.addChild(this._loadingImageSprite);
      }
    }
    /**
     * @static
     * @method _updateRenderer
     * @private
     */
    static _updateRenderer() {
      if (this._app) {
        this._app.renderer.resize(this._width, this._height);
      }
    }
    /**
     * @static
     * @method _createFPSMeter
     * @private
     */
    static _createFPSMeter() {
      if (Utils_default.isWorker())
        return;
      if (typeof gamestats_module_default == "function") {
        this._fpsMeter = new gamestats_module_default({
          autoPlace: false
        });
        this._fpsMeter.show(false);
        this._fpsMeter.dom.style.zIndex = 1;
      }
    }
    /**
     * @static
     * @method _createModeBox
     * @private
     */
    static _createModeBox() {
      if (Utils_default.isWorker()) {
        console.log("Graphics._createModeBox unsupported on worker.");
        return;
      }
      const box = document.createElement("div");
      box.id = "modeTextBack";
      box.style.position = "absolute";
      box.style.left = "5px";
      box.style.top = "5px";
      box.style.width = "119px";
      box.style.height = "58px";
      box.style.background = "rgba(0,0,0,0.2)";
      box.style.zIndex = 9;
      box.style.opacity = 0;
      const text = document.createElement("div");
      text.id = "modeText";
      text.style.position = "absolute";
      text.style.left = "0px";
      text.style.top = "41px";
      text.style.width = "119px";
      text.style.fontSize = "12px";
      text.style.fontFamily = "monospace";
      text.style.color = "white";
      text.style.textAlign = "center";
      text.style.textShadow = "1px 1px 0 rgba(0,0,0,0.5)";
      text.innerHTML = this.isWebGL() ? "WebGL mode" : "Canvas mode";
      document.body.appendChild(box);
      box.appendChild(text);
      this._modeBox = box;
    }
    /**
     * @static
     * @method _createGameFontLoader
     * @private
     */
    static _createGameFontLoader() {
      this._createFontLoader("GameFont");
    }
    /**
     * @static
     * @method _centerElement
     * @param {HTMLElement} element
     * @private
     */
    static _centerElement(element) {
      if (Utils_default.isWorker()) {
        console.log("Graphics._centerElement is not supported on worker.");
        return;
      }
      const width = element.width * this._realScale;
      const height = element.height * this._realScale;
      element.style.position = "absolute";
      element.style.margin = "auto";
      element.style.top = 0;
      element.style.left = 0;
      element.style.right = 0;
      element.style.bottom = 0;
      element.style.width = `${width}px`;
      element.style.height = `${height}px`;
    }
    /**
     * @static
     * @method _applyCanvasFilter
     * @private
     */
    static _applyCanvasFilter() {
    }
    /**
     * @static
     * @method _onVideoLoad
     * @private
     */
    static _onVideoLoad() {
    }
    /**
     * @static
     * @method _onVideoError
     * @private
     */
    static _onVideoError() {
    }
    /**
     * @static
     * @method _onVideoEnd
     * @private
     */
    static _onVideoEnd() {
    }
    /**
     * @static
     * @method _updateVisibility
     * @param {Boolean} videoVisible
     * @private
     */
    static _updateVisibility(videoVisible) {
    }
    /**
     * @static
     * @method _isVideoVisible
     * @return {Boolean}
     * @private
     */
    static _isVideoVisible() {
      return false;
    }
    /**
     * @static
     * @method _setupEventHandlers
     * @private
     */
    static _setupEventHandlers() {
      window.addEventListener("resize", this._onWindowResize.bind(this));
      document.addEventListener("keydown", this._onKeyDown.bind(this));
      document.addEventListener("keydown", this._onTouchEnd.bind(this));
      document.addEventListener("mousedown", this._onTouchEnd.bind(this));
      document.addEventListener("touchend", this._onTouchEnd.bind(this));
    }
    /**
     * @static
     * @method _onWindowResize
     * @private
     */
    static _onWindowResize(event) {
      if (self.window) {
        self.window.innerWidth = event.innerWidth;
        self.window.innerHeight = event.innerHeight;
      } else {
        console.log("self.window does not exist");
      }
      this._updateAllElements();
    }
    /**
     * @static
     * @method _onKeyDown
     * @param {KeyboardEvent} event
     * @private
     */
    static _onKeyDown(event) {
      if (!event.ctrlKey && !event.altKey) {
        switch (event.keyCode) {
          case 113:
            this._switchFPSMeter();
            break;
          case 114:
            this._switchStretchMode();
            break;
          case 115:
            this._switchFullScreen();
            break;
        }
      }
    }
    /**
     * @static
     * @method _onTouchEnd
     * @param {TouchEvent} event
     * @private
     */
    static _onTouchEnd(event) {
    }
    /**
     * @static
     * @method _switchFPSMeter
     * @private
     */
    static _switchFPSMeter() {
      if (Utils_default.isWorker())
        return;
      if (this._fpsMeter && this._fpsMeterToggled) {
        this.hideFps();
        this._fpsMeterToggled = false;
      } else if (this._fpsMeter && !this._fpsMeterToggled) {
        this.showFps();
        this._fpsMeterToggled = true;
      }
    }
    /**
     * @static
     * @method _switchStretchMode
     * @return {Boolean}
     * @private
     */
    static _switchStretchMode() {
      this._stretchEnabled = !this._stretchEnabled;
      this._updateAllElements();
    }
    /**
     * @static
     * @method _switchFullScreen
     * @private
     */
    static _switchFullScreen() {
      if (this._isFullScreen()) {
        this._cancelFullScreen();
      } else {
        this._requestFullScreen();
      }
    }
    /**
     * @static
     * @method _onTick
     * @param {Number} delta
     * @private
     */
    static _onTick(delta) {
      if (this._fpsMeter && this._fpsMeter.shown)
        this._fpsMeter.begin();
      if (this._app.stage) {
        this._app.render();
      }
      if (this._fpsMeter && this._fpsMeter.shown)
        this._fpsMeter.end();
    }
    /**
     * @static
     * @method _createPixiApp
     * @private
     */
    static _createPixiApp() {
      const options = {
        view: this._canvas,
        width: this._width,
        height: this._height,
        resolution: window.devicePixelRatio,
        powerPreference: "high-performance",
        autoStart: true,
        forceCanvas: SceneManager_default.preferableRendererType() === "canvas"
      };
      try {
        this._app = new Application(options);
        this._app.ticker.remove(this._app.render, this._app);
        this._app.ticker.add(this._onTick, this);
      } catch (e) {
        this._app = null;
        console.error(e);
      }
    }
    static _setupCssFontLoading() {
      if (Graphics2._cssFontLoading) {
        document.fonts.ready.then((fonts) => {
          Graphics2._fontLoaded = fonts;
        }).catch((error) => {
          SceneManager_default.onError(error);
        });
      }
    }
    /**
     * Marks the beginning of each frame for FPSMeter.
     *
     * @static
     * @method tickStart
     */
    static tickStart() {
    }
    /**
     * Marks the end of each frame for FPSMeter.
     *
     * @static
     * @method tickEnd
     */
    static tickEnd() {
    }
    /**
     * Checks whether the current browser supports WebGL.
     *
     * @static
     * @method hasWebGL
     * @return {Boolean} True if the current browser supports WebGL.
     */
    static hasWebGL() {
      if (typeof Graphics2._canWebGL === "boolean") {
        return Graphics2._canWebGL;
      }
      if (Utils_default.isWorker()) {
        console.log("Graphics.hasWebGL unsupported on worker.");
        return true;
      }
      try {
        const canvas = document.createElement("canvas");
        const result2 = !!(canvas.getContext("webgl") || canvas.getContext("experimental-webgl"));
        Graphics2._canWebGL = result2;
        return result2;
      } catch (e) {
        Graphics2._canWebGL = false;
        return false;
      }
    }
    /**
     * Calls pixi.js garbage collector
     */
    static callGC() {
      if (Graphics2.isWebGL()) {
        Graphics2._renderer.textureGC.run();
      }
    }
    /**
     * @static
     * @method _makeErrorHtml
     * @param {String} name
     * @param {String} message
     * @return {String}
     * @private
     */
    static _makeErrorHtml(name, message) {
      return `<font color="yellow"><b>${name}</b></font><br><font color="white">${decodeURIComponent(
        message
      )}</font><br>`;
    }
    /**
     * @static
     * @method _defaultStretchMode
     * @private
     */
    static _defaultStretchMode() {
      return Utils_default.isNwjs() || Utils_default.isMobileDevice() || Utils_default.isTauri();
    }
    /**
     * @static
     * @method _modifyExistingElements
     * @private
     */
    static _modifyExistingElements() {
    }
    /**
     * @static
     * @method _formatEventInfo
     * @private
     */
    static _formatEventInfo(error) {
      switch (String(error.eventType)) {
        case "map_event":
          return "MapID: %1, MapEventID: %2, page: %3, line: %4".format(
            error.mapId,
            error.mapEventId,
            error.page,
            error.line
          );
        case "common_event":
          return "CommonEventID: %1, line: %2".format(
            error.commonEventId,
            error.line
          );
        case "battle_event":
          return "TroopID: %1, page: %2, line: %3".format(
            error.troopId,
            error.page,
            error.line
          );
        case "test_event":
          return "TestEvent, line: %1".format(error.line);
        default:
          return "No information";
      }
    }
    /**
     * @static
     * @method _formatEventCommandInfo
     * @private
     */
    static _formatEventCommandInfo({ eventCommand, content }) {
      switch (String(eventCommand)) {
        case "plugin_command":
          return `\u25C6Plugin Command: ${content}`;
        case "script":
          return `\u25C6Script: ${content}`;
        case "control_variables":
          return `\u25C6Control Variables: Script: ${content}`;
        case "conditional_branch_script":
          return `\u25C6If: Script: ${content}`;
        case "set_route_script":
          return `\u25C6Set Movement Route: \u25C7Script: ${content}`;
        case "auto_route_script":
          return `Autonomous Movement Custom Route: \u25C7Script: ${content}`;
        case "other":
        default:
          return "";
      }
    }
    /**
     * @static
     * @method _formatStackTrace
     * @private
     */
    static _formatStackTrace({ stack }) {
      return decodeURIComponent(
        (stack || "").replace(/file:.*js\//g, "").replace(/http:.*js\//g, "").replace(/https:.*js\//g, "").replace(/chrome-extension:.*js\//g, "").replace(/\n/g, "<br>")
      );
    }
    /**
     * @static
     * @method _createRenderer
     * @private
     */
    static _createRenderer() {
    }
    /**
     * @static
     * @method _createFontLoader
     * @param {String} name
     * @private
     */
    static _createFontLoader(name) {
      if (Utils_default.isWorker()) {
        console.log("Graphics._createFontLoader unsupported on worker.");
        return;
      }
      const div = document.createElement("div");
      const text = document.createTextNode(".");
      div.style.fontFamily = name;
      div.style.fontSize = "0px";
      div.style.color = "transparent";
      div.style.position = "absolute";
      div.style.margin = "auto";
      div.style.top = "0px";
      div.style.left = "0px";
      div.style.width = "1px";
      div.style.height = "1px";
      div.appendChild(text);
      document.body.appendChild(div);
    }
    /**
     * @static
     * @method _disableTextSelection
     * @private
     */
    static _disableTextSelection() {
      if (Utils_default.isWorker()) {
        console.log("Graphics._disableTextSelection unsupported on worker.");
        return;
      }
      const body = document.body;
      body.style.userSelect = "none";
      body.style.webkitUserSelect = "none";
      body.style.msUserSelect = "none";
      body.style.mozUserSelect = "none";
    }
    /**
     * @static
     * @method _disableContextMenu
     * @private
     */
    static _disableContextMenu() {
      if (Utils_default.isWorker()) {
        console.log("Graphics._disableContextMenu unsupported on worker.");
        return;
      }
      const elements = document.body.getElementsByTagName("*");
      const oncontextmenu = () => false;
      for (let i = 0; i < elements.length; i++) {
        elements[i].oncontextmenu = oncontextmenu;
      }
    }
    /**
     * @static
     * @method _isFullScreen
     * @return {Boolean}
     * @private
     */
    static _isFullScreen() {
      return document.fullscreenElement || document.mozFullScreen || document.webkitFullscreenElement || document.msFullscreenElement;
    }
    /**
     * @static
     * @method _requestFullScreen
     * @private
     */
    static _requestFullScreen() {
      if (Utils_default.isWorker()) {
        console.log("Graphics._requestFullScreen unsupported on worker.");
        return;
      }
      const element = document.body;
      if (element.requestFullscreen) {
        element.requestFullscreen();
      } else if (element.mozRequestFullScreen) {
        element.mozRequestFullScreen();
      } else if (element.webkitRequestFullScreen) {
        element.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT);
      } else if (element.msRequestFullscreen) {
        element.msRequestFullscreen();
      }
    }
    /**
     * @static
     * @method _cancelFullScreen
     * @private
     */
    static _cancelFullScreen() {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.mozCancelFullScreen) {
        document.mozCancelFullScreen();
      } else if (document.webkitCancelFullScreen) {
        document.webkitCancelFullScreen();
      } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
      }
    }
  };
  Graphics2._cssFontLoading = !Utils_default.isWorker() && document.fonts && document.fonts.ready && document.fonts.ready.then;
  Graphics2._fontLoaded = null;
  Graphics2._videoVolume = 1;
  Object.defineProperty(Graphics2, "app", {
    get() {
      return this._app;
    },
    configurable: true
  });
  Object.defineProperty(Graphics2, "_renderer", {
    get() {
      return this._app.renderer;
    },
    configurable: true
  });
  Graphics2.frameCount = 0;
  Graphics2.BLEND_NORMAL = 0;
  Graphics2.BLEND_ADD = 1;
  Graphics2.BLEND_MULTIPLY = 2;
  Graphics2.BLEND_SCREEN = 3;
  Graphics2._canWebGL = null;
  Object.defineProperty(Graphics2, "width", {
    get() {
      return this._width;
    },
    set(value3) {
      if (this._width !== value3) {
        this._width = value3;
        this._updateAllElements();
      }
    },
    configurable: true
  });
  Object.defineProperty(Graphics2, "height", {
    get() {
      return this._height;
    },
    set(value3) {
      if (this._height !== value3) {
        this._height = value3;
        this._updateAllElements();
      }
    },
    configurable: true
  });
  Object.defineProperty(Graphics2, "boxWidth", {
    get() {
      return this._boxWidth;
    },
    set(value3) {
      this._boxWidth = value3;
    },
    configurable: true
  });
  Object.defineProperty(Graphics2, "boxHeight", {
    get() {
      return this._boxHeight;
    },
    set(value3) {
      this._boxHeight = value3;
    },
    configurable: true
  });
  Object.defineProperty(Graphics2, "scale", {
    get() {
      return this._scale;
    },
    set(value3) {
      if (this._scale !== value3) {
        this._scale = value3;
        this._updateAllElements();
      }
    },
    configurable: true
  });
  var Graphics_default = Graphics2;

  // src-www/js/rpg_core/Rectangle.js
  var Rectangle2 = class extends Rectangle {
    constructor(...args) {
      super(...args);
    }
  };
  Rectangle2.emptyRectangle = new Rectangle2(0, 0, 0, 0);
  var Rectangle_default = Rectangle2;

  // src-www/js/rpg_core/Bitmap.js
  var Bitmap = class extends Container {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(width, height) {
      width = Math.max(width || 0, 1);
      height = Math.max(height || 0, 1);
      if (!this._defer) {
        this._createCanvas(width, height);
      }
      this._width = width;
      this._height = height;
      this._image = null;
      this._url = "";
      this._paintOpacity = 255;
      this._smooth = false;
      this._loadListeners = [];
      this._loadingState = "none";
      this._decodeAfterRequest = false;
      this._tint = "0xffffff";
      this.textPadding = 2;
      this.wordWrap = false;
      this.wordWrapWidth = 0;
      this.textCache = [];
      this.cacheEntry = null;
      this.fontFace = "GameFont";
      this.fontSize = 28;
      this.fontItalic = false;
      this.textColor = "#ffffff";
      this.outlineColor = "rgba(0, 0, 0, 0.5)";
      this.outlineWidth = 4;
    }
    //-----------------------------------------------------------------------------
    /**
     * Methods relating to Bitmap's nature as a container.
     */
    /**
     * Make sure the text cache is emptied and all children are destroyed
     *
     * @method _onRemoveAsAChild
     * @private
     */
    onRemoveAsAChild() {
      this.textCache = [];
      for (let i = this.children.length - 1; i >= 0; i--) {
        this.children[i].destroy({
          children: true,
          texture: true
        });
        this.removeChild(this.children[i]);
      }
    }
    /**
     * The opacity of the drawing object in the range (0, 255).
     *
     * @property paintOpacity
     * @type Number
     */
    get paintOpacity() {
      return this._paintOpacity;
    }
    set paintOpacity(value3) {
      if (this._paintOpacity !== value3) {
        this._paintOpacity = value3;
      }
    }
    /**
     * [read-only] The width of the bitmap.
     *
     * @property width
     * @type Number
     */
    get width() {
      return this._width;
    }
    set width(value3) {
      if (this._width !== value3) {
        this._width = value3;
      }
    }
    /**
     * [read-only] The height of the bitmap.
     *
     * @property height
     * @type Number
     */
    get height() {
      return this._height;
    }
    set height(value3) {
      if (this._height !== value3) {
        this._height = value3;
      }
    }
    /**
     * Resizes the bitmap.
     *
     * @method resize
     * @param {Number} width The new width of the bitmap
     * @param {Number} height The new height of the bitmap
     */
    resize(width, height) {
      width = Math.max(width || 0, 1);
      height = Math.max(height || 0, 1);
      this._width = width;
      this._height = height;
    }
    /**
     * Clear text and destroy children.
     *
     * @method clear
     */
    clear() {
      for (let i = this.children.length - 1; i >= 0; i--) {
        if (this.children[i].isBitmapText) {
          this.children[i].text = "";
          continue;
        }
        this.children[i].destroy({
          children: true,
          texture: true
        });
        this.removeChild(this.children[i]);
      }
    }
    /**
     * Clear text and destroy children in a given area.
     *
     * @method clearRect
     * @param {Number} x Horizontal coordinate of area to clear
     * @param {Number} y Vertical coordinate of area to clear
     * @param {Number} width The width of area to clear
     * @param {Number} height The height of area to clear
     */
    clearRect(x, y, width, height) {
      const context2 = this;
      const toRemove = [];
      this.children.forEach((child) => {
        if (child && child.x >= x && child.x < x + width && child.y >= y && child.y < y + height) {
          if (child.isBitmapText) {
            child.text = "";
          } else {
            toRemove.push(child);
          }
        }
      });
      toRemove.forEach((child) => {
        child.destroy({
          children: true,
          texture: true
        });
        context2.removeChild(child);
      });
    }
    //-----------------------------------------------------------------------------
    /**
     * Methods relating to drawing images.
     */
    /**
     * Creates a nine slice plane.
     *
     * @method create9Slice
     */
    create9Slice(source, x, y, w, h, tl, tr, br, bl) {
      return new NineSlicePlane(
        new Texture(source, new Rectangle(x, y, w, h)),
        tl,
        tr,
        br,
        bl
      );
    }
    /**
     * Creates a tiling sprite.
     *
     * @method createTilingSprite
     */
    createTilingSprite(source, x, y, w, h, tileWidth, tileHeight) {
      return new TilingSprite(
        new Texture(source, new Rectangle(x, y, w, h)),
        tileWidth,
        tileHeight
      );
    }
    /**
     * Creates a sprite by cropping a texture.
     *
     * @method createCroppedSprite
     */
    createCroppedSprite(source, x, y, w, h) {
      return new Sprite(
        new Texture(source, new Rectangle(x, y, w, h))
      );
    }
    /**
     * Equivalent to a block transfer.
     * Create a sprite and adds it as a child.
     *
     * @method blt
     * @param {Bitmap} source The bitmap to draw
     * @param {Number} sx The x coordinate in the source
     * @param {Number} sy The y coordinate in the source
     * @param {Number} sw The width of the source image
     * @param {Number} sh The height of the source image
     * @param {Number} dx The x coordinate in the destination
     * @param {Number} dy The y coordinate in the destination
     * @param {Number} [dw=sw] The width to draw the image in the destination
     * @param {Number} [dh=sh] The height to draw the image in the destination
     */
    blt({ width, height, baseTexture }, sx, sy, sw, sh, dx, dy, dw, dh) {
      dw = dw || sw;
      dh = dh || sh;
      sx = Math.floor(sx);
      sy = Math.floor(sy);
      sw = Math.floor(sw);
      sh = Math.floor(sh);
      dx = Math.floor(dx);
      dy = Math.floor(dy);
      dw = Math.floor(dw);
      dh = Math.floor(dh);
      if (sx >= 0 && sy >= 0 && sw > 0 && sh > 0 && dw > 0 && dh > 0 && sx + sw <= width && sy + sh <= height) {
        const sprite = this.createCroppedSprite(baseTexture, sx, sy, sw, sh);
        if (sprite) {
          sprite.x = dx;
          sprite.y = dy;
          sprite.width = dw;
          sprite.height = dh;
          sprite.alpha = this._paintOpacity / 255;
          this.tint = this._tint;
          this.addChild(sprite);
          return sprite;
        }
      }
    }
    /**
     * Fills the specified rectangle.
     *
     * @method fillRect
     * @param {Number} x The x coordinate for the upper-left corner
     * @param {Number} y The y coordinate for the upper-left corner
     * @param {Number} width The width of the rectangle to fill
     * @param {Number} height The height of the rectangle to fill
     * @param {String} color The color of the rectangle in CSS format
     */
    fillRect(x, y, width, height, color2) {
      x = Math.floor(x);
      y = Math.floor(y);
      width = Math.floor(width);
      height = Math.floor(height);
      color2 = index.string2hex(color2);
      const rectangle = new Graphics();
      rectangle.beginFill(color2);
      rectangle.drawRect(0, 0, width, height);
      rectangle.endFill();
      if (rectangle) {
        rectangle.x = x;
        rectangle.y = y;
        rectangle.alpha = this._paintOpacity / 255;
        rectangle.tint = this._tint;
        this.addChild(rectangle);
      }
      return rectangle;
    }
    /**
     * Performs a block transfer, using assumption that original image was not modified (no hue)
     *
     * @method blt
     * @param {Bitmap} source The bitmap to draw
     * @param {Number} sx The x coordinate in the source
     * @param {Number} sy The y coordinate in the source
     * @param {Number} sw The width of the source image
     * @param {Number} sh The height of the source image
     * @param {Number} dx The x coordinate in the destination
     * @param {Number} dy The y coordinate in the destination
     * @param {Number} [dw=sw] The width to draw the image in the destination
     * @param {Number} [dh=sh] The height to draw the image in the destination
     */
    bltImage({ width, height, _image }, sx, sy, sw, sh, dx, dy, dw, dh) {
      return this.blt(
        {
          width,
          height,
          _image
        },
        sx,
        sy,
        sw,
        sh,
        dx,
        dy,
        dw,
        dh
      );
    }
    /**
     * Fills the entire bitmap.
     *
     * @method fillAll
     * @param {String} color The color of the rectangle in CSS format
     */
    fillAll(color2) {
      this.fillRect(0, 0, this.width, this.height, color2);
    }
    /**
     * Ignores the 2nd colour and returns a solid-colour rectangle.
     *
     * @method gradientFillRect
     * @param {Number} x The x coordinate for the upper-left corner
     * @param {Number} y The y coordinate for the upper-left corner
     * @param {Number} width The width of the rectangle to fill
     * @param {Number} height The height of the rectangle to fill
     * @param {String} color1 The gradient starting color
     * @param {String} color2 The gradient ending color
     * @param {Boolean} vertical Wether the gradient should be draw as vertical or not
     */
    gradientFillRect(x, y, width, height, color1, color2, vertical) {
      return this.fillRect(x, y, width, height, color1);
    }
    /**
     * Draw a shape in the shape of a circle
     *
     * @method drawCircle
     * @param {Number} x The x coordinate based on the circle center
     * @param {Number} y The y coordinate based on the circle center
     * @param {Number} radius The radius of the circle
     * @param {String} color The color of the circle in CSS format
     */
    drawCircle(x, y, radius, color2) {
      x = Math.floor(x);
      y = Math.floor(y);
      const circle = new Graphics();
      color2 = index.string2hex(color2);
      circle.beginFill(color2);
      circle.drawCircle(0, 0, radius);
      circle.endFill();
      if (circle) {
        circle.x = x;
        circle.y = y;
        circle.alpha = this._paintOpacity / 255;
        circle.tint = this._tint;
        this.addChild(circle);
      }
      return circle;
    }
    /**
     * [read-only] The base texture that holds the image.
     *
     * @property baseTexture
     * @type PIXI.BaseTexture
     */
    get baseTexture() {
      return this._baseTexture;
    }
    /**
     * [read-only] The bitmap canvas.
     *
     * @property canvas
     * @type HTMLCanvasElement
     */
    get canvas() {
      return this._canvas;
    }
    /**
     * [read-only] The 2d context of the bitmap canvas.
     *
     * @property context
     * @type CanvasRenderingContext2D
     */
    get context() {
      return this._canvas.context;
    }
    /**
     * [read-only] The rectangle of the bitmap.
     *
     * @property rect
     * @type Rectangle
     */
    get rect() {
      return new Rectangle_default(0, 0, this.width, this.height);
    }
    /**
     * Bitmap states(Bitmap._loadingState):
     *
     * none:
     * Empty Bitmap
     *
     * pending:
     * Url requested, but pending to load until startRequest called
     *
     * purged:
     * Url request completed and purged.
     *
     * requesting:
     * Requesting supplied URI now.
     *
     * requestCompleted:
     * Request completed
     *
     * loaded:
     * loaded. isReady() === true, so It's usable.
     *
     * error:
     * error occurred
     *
     */
    _createCanvas(width, height) {
      this.__canvas = {};
      this.__canvas = new CanvasShim_default();
      this.__context = this.__canvas.getContext("2d");
      this.__canvas.width = Math.max(width || 0, 1);
      this.__canvas.height = Math.max(height || 0, 1);
      if (this._image) {
        const w = Math.max(this._image.width || 0, 1);
        const h = Math.max(this._image.height || 0, 1);
        this.__canvas.width = w;
        this.__canvas.height = h;
        this._createBaseTexture(this._image);
      } else {
        this._createBaseTexture(
          new Resource(this.__canvas.width, this.__canvas.height)
        );
      }
    }
    _createBaseTexture(source) {
      if (source && source.baseTexture) {
        this.__baseTexture = source.baseTexture;
        this.__baseTexture.width = source.width;
        this.__baseTexture.height = source.height;
        this.__baseTexture.mipmap = false;
        this.__baseTexture.scaleMode = SCALE_MODES.NEAREST;
      } else {
        this.__baseTexture = new BaseTexture(source);
      }
    }
    _clearImgInstance() {
      this._image = null;
    }
    _renewCanvas() {
      const newImage = this._image;
      if (newImage && this.__canvas && (this.__canvas.width < newImage.width || this.__canvas.height < newImage.height)) {
        this._createCanvas();
      }
    }
    /**
     * Takes a snapshot of the game screen and returns a new bitmap object.
     *
     * @static
     * @method snap
     * @param {Stage} stage The stage object
     * @return Bitmap
     */
    static snap(stage) {
      const width = Graphics_default.width;
      const height = Graphics_default.height;
      const bitmap = new Bitmap(width, height);
      if (stage) {
        const renderTexture = RenderTexture.create({
          width,
          height
        });
        Graphics_default._renderer.render(stage, {
          renderTexture
        });
        bitmap.__baseTexture = renderTexture.baseTexture;
      }
      return bitmap;
    }
    /**
     * Returns pixel color at the specified point.
     *
     * @method getPixel
     * @param {Number} x The x coordinate of the pixel in the bitmap
     * @param {Number} y The y coordinate of the pixel in the bitmap
     * @return {String} The pixel color (hex format)
     */
    getPixel(x, y) {
      if (!this.baseTexture) {
        return "#ffffff";
      }
      const sprite = Sprite.from(this.baseTexture);
      const pixels = Graphics_default._renderer.extract.pixels(sprite, {
        x,
        y,
        width: 1,
        height: 1,
        resolution: this.baseTexture.resolution
      });
      const rgb = index.rgb2hex([
        pixels[0] / 255,
        pixels[1] / 255,
        pixels[2] / 255
      ]);
      const result2 = index.hex2string(rgb);
      sprite.destroy({
        children: true,
        texture: true,
        baseTexture: false
      });
      return result2;
    }
    /**
     * Returns alpha pixel value at the specified point.
     *
     * @method getAlphaPixel
     * @param {Number} x The x coordinate of the pixel in the bitmap
     * @param {Number} y The y coordinate of the pixel in the bitmap
     * @return {String} The alpha value
     */
    getAlphaPixel(x, y) {
      if (!this.baseTexture) {
        return "1";
      }
      const sprite = Sprite.from(this.baseTexture);
      const pixels = Graphics_default._renderer.plugins.extract.pixels(sprite, {
        x,
        y,
        width: 1,
        height: 1,
        resolution: this.baseTexture.resolution
      });
      const result2 = String(pixels[3]);
      sprite.destroy({
        children: true,
        texture: true,
        baseTexture: false
      });
      return result2;
    }
    /**
     * Changes the color tone of children which support Tint.
     *
     * @method adjustTone
     * @param {Number} r The red strength in the range (-255, 255)
     * @param {Number} g The green strength in the range (-255, 255)
     * @param {Number} b The blue strength in the range (-255, 255)
     */
    adjustTone(r, g, b2) {
      this._tint = index.rgb2hex(r, g, b2);
    }
    //-----------------------------------------------------------------------------
    /**
     * Methods relating to drawing text.
     */
    /**
     * Draws PIXI BitmapText.
     *
     * @method drawText
     * @param {String} text The text that will be drawn
     * @param {Number} x The x coordinate for the left of the text
     * @param {Number} y The y coordinate for the top of the text
     * @param {Number} maxWidth The maximum allowed width of the text
     * @param {Number} lineHeight The height of the text line
     * @param {String} align The alignment of the text
     */
    drawText(text, x, y, maxWidth, lineHeight, align) {
      if (text === void 0)
        return;
      const alpha = this._paintOpacity / 255;
      maxWidth = Math.floor(maxWidth) || 4294967295;
      lineHeight = Math.floor(lineHeight * 1.75);
      if (align === "center") {
        x = x + maxWidth / 2;
      } else if (align === "right") {
        x = x + maxWidth;
      }
      y = y + lineHeight - this.fontSize * 2.25;
      x = Math.floor(x);
      y = Math.floor(y);
      const updateExisting = this._updateExistingText(text, x, y, alpha);
      if (!updateExisting) {
        this._drawNewText(text, x, y, alpha, maxWidth, lineHeight, align);
      }
    }
    /**
     * Updates instance of PIXI BitmapText.
     *
     * @method _updateExistingText
     * @return {Boolean} Returns true if update was successful
     * @private
     */
    _updateExistingText(text, x, y, alpha) {
      for (const bitmapTextInstance of this.textCache) {
        if (bitmapTextInstance.x === x && bitmapTextInstance.y === y) {
          const newTint = index.string2hex(this.textColor);
          if (bitmapTextInstance._tint !== newTint)
            bitmapTextInstance.tint = newTint;
          if (bitmapTextInstance.text !== text)
            bitmapTextInstance.text = text;
          if (bitmapTextInstance.alpha !== alpha)
            bitmapTextInstance.alpha = alpha;
          this.addChild(bitmapTextInstance);
          return true;
        }
      }
      return false;
    }
    /**
     * Creates instances of PIXI BitmapText.
     *
     * @method _drawNewText
     * @private
     */
    _drawNewText(text, x, y, alpha, maxWidth, lineHeight, align) {
      const style = {
        fontFamily: this.fontFace,
        fontSize: this.fontSize,
        fill: 16777215,
        lineHeight,
        wordWrap: this.wordWrap,
        wordWrapWidth: this.wordWrapWidth,
        padding: this.textPadding,
        fontStyle: this.fontItalic ? "italic" : "normal",
        stroke: this.outlineColor,
        strokeThickness: this.outlineWidth
      };
      if (!BitmapFont.available[style.fontFamily]) {
        this._makeBitmapFont(style);
      }
      const pixiText = new BitmapText(text, {
        fontName: style.fontFamily,
        fontSize: style.fontSize
      });
      if (!style.wordWrap && pixiText.width > maxWidth) {
        pixiText.scale.x = maxWidth / pixiText.width;
      }
      if (align === "center") {
        pixiText.anchor.set(0.5, 0);
      } else if (align === "right") {
        pixiText.anchor.set(1, 0);
      }
      if (pixiText) {
        pixiText.x = x;
        pixiText.y = y;
        pixiText.tint = index.string2hex(this.textColor);
        pixiText.alpha = alpha;
        pixiText.isBitmapText = true;
        this.textCache.push(pixiText);
        this.addChild(pixiText);
      }
    }
    /**
     * Creates a bitmap font.
     *
     * @method _makeBitmapFont
     * @private
     */
    _makeBitmapFont(style) {
      const bitmapOptions = {
        chars: [[" ", "~"], "\u2192", "\u2019"]
      };
      BitmapFont.from(style.fontFamily, style, bitmapOptions);
    }
    /**
     * Returns the width of the specified text.
     *
     * @method measureTextWidth
     * @param {String} text The text to be measured
     * @return {Number} The width of the text in pixels
     */
    measureTextWidth(text) {
      text = String(text);
      const style = new TextStyle({
        fontFamily: this.fontFace,
        fontSize: this.fontSize,
        padding: this.textPadding
      });
      const textMetrics = TextMetrics.measureText(text, style);
      return textMetrics.width;
    }
    //-----------------------------------------------------------------------------
    /**
     * Methods relating to loading and listeners.
     */
    /**
     * [read-only] The url of the image file.
     *
     * @property url
     * @type String
     */
    get url() {
      return this._url;
    }
    /**
     * Add a callback function that will be called when the bitmap is loaded.
     *
     * @method addLoadListener
     * @param {Function} listner The callback function
     */
    addLoadListener(listner) {
      if (!this.isReady()) {
        this._loadListeners.push(listner);
      } else {
        if (this._image)
          listner(this);
      }
    }
    /**
     * Checks whether the bitmap is ready to render.
     *
     * @method isReady
     * @return {Boolean} True if the bitmap is ready to render
     */
    isReady() {
      return this._loadingState === "loaded" || this._loadingState === "none";
    }
    /**
     * Checks whether a loading error has occurred.
     *
     * @method isError
     * @return {Boolean} True if a loading error has occurred
     */
    isError() {
      return this._loadingState === "error";
    }
    /**
     * touch the resource
     * @method touch
     */
    touch() {
      if (this.cacheEntry) {
        this.cacheEntry.touch();
      }
    }
    /**
     * @method _onLoad
     * @private
     */
    _onLoad() {
      this._renewCanvas();
      switch (this._loadingState) {
        case "requesting":
          this._loadingState = "requestCompleted";
          this.decode();
          break;
      }
    }
    decode() {
      switch (this._loadingState) {
        case "requestCompleted":
          this._loadingState = "loaded";
          this._createBaseTexture(this._image);
          this._callLoadListeners();
          break;
        case "requesting":
          this._decodeAfterRequest = true;
          break;
        case "pending":
        case "purged":
        case "error":
          this._decodeAfterRequest = true;
          this._requestImage(this._url);
          break;
      }
    }
    /**
     * @method _callLoadListeners
     * @private
     */
    _callLoadListeners() {
      while (this._loadListeners.length > 0) {
        const listener = this._loadListeners.shift();
        listener(this);
      }
    }
    /**
     * @method _onError
     * @private
     */
    _onError() {
      this._loadingState = "error";
    }
    _requestImage(src) {
      const url2 = `../${src}`;
      this._url = url2;
      this._loadingState = "requesting";
      Assets.load(url2).then((texture) => {
        this._image = texture;
        this._width = this._image.width;
        this._height = this._image.height;
        this._onLoad();
      }).catch((error) => {
        console.error(error);
        this._onError();
      });
    }
    isRequestOnly() {
      return !(this._decodeAfterRequest || this.isReady());
    }
    isRequestReady() {
      return this._loadingState !== "pending" && this._loadingState !== "requesting";
    }
    startRequest() {
      if (this._loadingState === "pending") {
        this._decodeAfterRequest = false;
        this._requestImage(this._url);
      }
    }
    /**
     * Loads a image file and returns a new bitmap object.
     *
     * @static
     * @method load
     * @param {String} url The image url of the texture
     * @return Bitmap
     */
    static load(url2) {
      const bitmap = Object.create(Bitmap.prototype);
      bitmap._defer = true;
      bitmap.initialize();
      bitmap._decodeAfterRequest = true;
      bitmap._requestImage(url2);
      return bitmap;
    }
    static request(url2) {
      const bitmap = Object.create(Bitmap.prototype);
      bitmap._defer = true;
      bitmap.initialize();
      bitmap._url = url2;
      bitmap._loadingState = "pending";
      return bitmap;
    }
    /**
     * Deprecated function.
     */
    rotateHue(offset) {
    }
    /**
     * Deprecated function.
     */
    blur() {
    }
    /**
     * Deprecated function.
     */
    _drawTextOutline(text, tx, ty, maxWidth) {
    }
    /**
     * Deprecated function.
     */
    _drawTextBody(text, tx, ty, maxWidth) {
    }
    /**
     * Deprecated function.
     *
     * @method drawSmallText
     */
    drawSmallText(text, x, y, maxWidth, lineHeight, align) {
    }
    /**
     * Deprecated function.
     */
    _setDirty() {
    }
    /**
     * Deprecated function.
     * @method checkDirty
     */
    checkDirty() {
    }
    /**
     * Deprecated property.
     *
     * @property smooth
     * @type Boolean
     */
    get smooth() {
      return this._smooth;
    }
    set smooth(value3) {
      if (this._smooth !== false) {
        this._smooth = false;
      }
    }
  };
  Bitmap._reuseImages = [];
  Object.defineProperties(Bitmap.prototype, {
    _canvas: {
      get() {
        if (!this.__canvas)
          this._createCanvas();
        return this.__canvas;
      }
    },
    _context: {
      get() {
        if (!this.__context)
          this._createCanvas();
        return this.__context;
      }
    },
    _baseTexture: {
      get() {
        if (!this.__baseTexture)
          this._createBaseTexture(this._image);
        return this.__baseTexture;
      }
    }
  });
  var Bitmap_default = Bitmap;

  // src-www/js/rpg_managers/ImageManager.js
  var ImageManager2 = class {
    constructor() {
      throw new Error("This is a static class");
    }
    static loadAnimation(filename, hue) {
      return this.loadBitmap("img/animations/", filename, hue, true);
    }
    static loadBattleback1(filename, hue) {
      return this.loadBitmap("img/battlebacks1/", filename, hue, true);
    }
    static loadBattleback2(filename, hue) {
      return this.loadBitmap("img/battlebacks2/", filename, hue, true);
    }
    static loadEnemy(filename, hue) {
      return this.loadBitmap("img/enemies/", filename, hue, true);
    }
    static loadCharacter(filename, hue) {
      return this.loadBitmap("img/characters/", filename, hue, false);
    }
    static loadFace(filename, hue) {
      return this.loadBitmap("img/faces/", filename, hue, true);
    }
    static loadParallax(filename, hue) {
      return this.loadBitmap("img/parallaxes/", filename, hue, true);
    }
    static loadPicture(filename, hue) {
      return this.loadBitmap("img/pictures/", filename, hue, true);
    }
    static loadSvActor(filename, hue) {
      return this.loadBitmap("img/sv_actors/", filename, hue, false);
    }
    static loadSvEnemy(filename, hue) {
      return this.loadBitmap("img/sv_enemies/", filename, hue, true);
    }
    static loadSystem(filename, hue) {
      return this.loadBitmap("img/system/", filename, hue, false);
    }
    static loadTileset(filename, hue) {
      return this.loadBitmap("img/tilesets/", filename, hue, false);
    }
    static loadBitmap(folder, filename, hue, smooth) {
      if (filename) {
        const path2 = `${folder + encodeURIComponent(filename)}.png`;
        const bitmap = this.loadNormalBitmap(path2, hue || 0);
        return bitmap;
      } else {
        return this.loadEmptyBitmap();
      }
    }
    static loadEmptyBitmap() {
      let empty = this._imageCache.get("empty");
      if (!empty) {
        empty = new Bitmap_default();
        this._imageCache.add("empty", empty);
        this._imageCache.reserve("empty", empty, this._systemReservationId);
      }
      return empty;
    }
    static loadNormalBitmap(path2, hue) {
      const key = this._generateCacheKey(path2, hue);
      let bitmap = this._imageCache.get(key);
      if (!bitmap) {
        bitmap = Bitmap_default.load(path2);
        this._callCreationHook(bitmap);
        bitmap.addLoadListener(() => {
          bitmap.rotateHue(hue);
        });
        this._imageCache.add(key, bitmap);
      } else if (!bitmap.isReady()) {
        bitmap.decode();
      }
      return bitmap;
    }
    static clear() {
      this._imageCache = new ImageCache_default();
    }
    static isReady() {
      return this._imageCache.isReady();
    }
    static reserveAnimation(filename, hue, reservationId) {
      return this.reserveBitmap(
        "img/animations/",
        filename,
        hue,
        true,
        reservationId
      );
    }
    static reserveBattleback1(filename, hue, reservationId) {
      return this.reserveBitmap(
        "img/battlebacks1/",
        filename,
        hue,
        true,
        reservationId
      );
    }
    static reserveBattleback2(filename, hue, reservationId) {
      return this.reserveBitmap(
        "img/battlebacks2/",
        filename,
        hue,
        true,
        reservationId
      );
    }
    static reserveEnemy(filename, hue, reservationId) {
      return this.reserveBitmap(
        "img/enemies/",
        filename,
        hue,
        true,
        reservationId
      );
    }
    static reserveCharacter(filename, hue, reservationId) {
      return this.reserveBitmap(
        "img/characters/",
        filename,
        hue,
        false,
        reservationId
      );
    }
    static reserveFace(filename, hue, reservationId) {
      return this.reserveBitmap("img/faces/", filename, hue, true, reservationId);
    }
    static reserveParallax(filename, hue, reservationId) {
      return this.reserveBitmap(
        "img/parallaxes/",
        filename,
        hue,
        true,
        reservationId
      );
    }
    static reservePicture(filename, hue, reservationId) {
      return this.reserveBitmap(
        "img/pictures/",
        filename,
        hue,
        true,
        reservationId
      );
    }
    static reserveSvActor(filename, hue, reservationId) {
      return this.reserveBitmap(
        "img/sv_actors/",
        filename,
        hue,
        false,
        reservationId
      );
    }
    static reserveSvEnemy(filename, hue, reservationId) {
      return this.reserveBitmap(
        "img/sv_enemies/",
        filename,
        hue,
        true,
        reservationId
      );
    }
    static reserveSystem(filename, hue, reservationId) {
      return this.reserveBitmap(
        "img/system/",
        filename,
        hue,
        false,
        reservationId || this._systemReservationId
      );
    }
    static reserveTileset(filename, hue, reservationId) {
      return this.reserveBitmap(
        "img/tilesets/",
        filename,
        hue,
        false,
        reservationId
      );
    }
    static reserveTitle1(filename, hue, reservationId) {
      return this.reserveBitmap(
        "img/titles1/",
        filename,
        hue,
        true,
        reservationId
      );
    }
    static reserveTitle2(filename, hue, reservationId) {
      return this.reserveBitmap(
        "img/titles2/",
        filename,
        hue,
        true,
        reservationId
      );
    }
    static reserveBitmap(folder, filename, hue, smooth, reservationId) {
      if (filename) {
        const path2 = `${folder + encodeURIComponent(filename)}.png`;
        const bitmap = this.reserveNormalBitmap(
          path2,
          hue || 0,
          reservationId || this._defaultReservationId
        );
        return bitmap;
      } else {
        return this.loadEmptyBitmap();
      }
    }
    static reserveNormalBitmap(path2, hue, reservationId) {
      const bitmap = this.loadNormalBitmap(path2, hue);
      this._imageCache.reserve(
        this._generateCacheKey(path2, hue),
        bitmap,
        reservationId
      );
      return bitmap;
    }
    static releaseReservation(reservationId) {
      this._imageCache.releaseReservation(reservationId);
    }
    static setDefaultReservationId(reservationId) {
      this._defaultReservationId = reservationId;
    }
    static requestAnimation(filename, hue) {
      return this.requestBitmap("img/animations/", filename, hue, true);
    }
    static requestBattleback1(filename, hue) {
      return this.requestBitmap("img/battlebacks1/", filename, hue, true);
    }
    static requestBattleback2(filename, hue) {
      return this.requestBitmap("img/battlebacks2/", filename, hue, true);
    }
    static requestEnemy(filename, hue) {
      return this.requestBitmap("img/enemies/", filename, hue, true);
    }
    static requestCharacter(filename, hue) {
      return this.requestBitmap("img/characters/", filename, hue, false);
    }
    static requestFace(filename, hue) {
      return this.requestBitmap("img/faces/", filename, hue, true);
    }
    static requestParallax(filename, hue) {
      return this.requestBitmap("img/parallaxes/", filename, hue, true);
    }
    static requestPicture(filename, hue) {
      return this.requestBitmap("img/pictures/", filename, hue, true);
    }
    static requestSvActor(filename, hue) {
      return this.requestBitmap("img/sv_actors/", filename, hue, false);
    }
    static requestSvEnemy(filename, hue) {
      return this.requestBitmap("img/sv_enemies/", filename, hue, true);
    }
    static requestSystem(filename, hue) {
      return this.requestBitmap("img/system/", filename, hue, false);
    }
    static requestTileset(filename, hue) {
      return this.requestBitmap("img/tilesets/", filename, hue, false);
    }
    static requestTitle1(filename, hue) {
      return this.requestBitmap("img/titles1/", filename, hue, true);
    }
    static requestTitle2(filename, hue) {
      return this.requestBitmap("img/titles2/", filename, hue, true);
    }
    static requestBitmap(folder, filename, hue, smooth) {
      if (filename) {
        const path2 = `${folder + encodeURIComponent(filename)}.png`;
        const bitmap = this.requestNormalBitmap(path2, hue || 0);
        return bitmap;
      } else {
        return this.loadEmptyBitmap();
      }
    }
    static requestNormalBitmap(path2, hue) {
      const key = this._generateCacheKey(path2, hue);
      let bitmap = this._imageCache.get(key);
      if (!bitmap) {
        bitmap = Bitmap_default.request(path2);
        this._callCreationHook(bitmap);
        bitmap.addLoadListener(() => {
          bitmap.rotateHue(hue);
        });
        this._imageCache.add(key, bitmap);
        this._requestQueue.enqueue(key, bitmap);
      } else {
        this._requestQueue.raisePriority(key);
      }
      return bitmap;
    }
    static update() {
      this._requestQueue.update();
    }
    static clearRequest() {
      this._requestQueue.clear();
    }
    static setCreationHook(hook) {
      this._creationHook = hook;
    }
    static _callCreationHook(bitmap) {
      if (this._creationHook)
        this._creationHook(bitmap);
    }
    static isObjectCharacter(filename) {
      const sign3 = filename.match(/^[\!\$]+/);
      return sign3 && sign3[0].contains("!");
    }
    static isBigCharacter(filename) {
      const sign3 = filename.match(/^[\!\$]+/);
      return sign3 && sign3[0].contains("$");
    }
    static isZeroParallax(filename) {
      return filename.charAt(0) === "!";
    }
    static _generateCacheKey(path2, hue) {
      return `${path2}:${hue}`;
    }
  };
  ImageManager2.cache = new CacheMap_default(ImageManager2);
  ImageManager2._imageCache = new ImageCache_default();
  ImageManager2._requestQueue = new RequestQueue_default();
  ImageManager2._systemReservationId = Utils_default.generateRuntimeId();
  var ImageManager_default = ImageManager2;

  // src-www/js/rpg_core/ProgressWatcher.js
  var ProgressWatcher = class {
    constructor() {
      throw new Error("This is a static class");
    }
    static initialize() {
      this.clearProgress();
      ImageManager_default.setCreationHook(this._bitmapListener.bind(this));
      AudioManager_default.setCreationHook(this._audioListener.bind(this));
    }
    static _bitmapListener(bitmap) {
      this._countLoading++;
      bitmap.addLoadListener(() => {
        this._countLoaded++;
        if (this._progressListener)
          this._progressListener(this._countLoaded, this._countLoading);
      });
    }
    static _audioListener(audio) {
      this._countLoading++;
      audio.addLoadListener(() => {
        this._countLoaded++;
        if (this._progressListener)
          this._progressListener(this._countLoaded, this._countLoading);
      });
    }
    static setProgressListener(progressListener) {
      this._progressListener = progressListener;
    }
    static clearProgress() {
      this._countLoading = 0;
      this._countLoaded = 0;
    }
    static truncateProgress() {
      if (this._countLoaded) {
        this._countLoading -= this._countLoaded;
        this._countLoaded = 0;
      }
    }
  };
  var ProgressWatcher_default = ProgressWatcher;

  // src-www/js/rpg_core/Point.js
  var Point2 = class extends Point {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(x, y) {
    }
    /**
     * The x coordinate.
     *
     * @property x
     * @type Number
     */
    /**
     * The y coordinate.
     *
     * @property y
     * @type Number
     */
  };
  var Point_default = Point2;

  // src-www/js/rpg_core/Sprite.js
  var GRAPHICS_QUALITY_LEVEL = 1;
  var Sprite2 = class extends Sprite {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      this.filters = null;
      this._frame = new Rectangle_default();
      this._blendColor = [0, 0, 0, 0];
      this._colorTone = [0, 0, 0, 0];
      this._colorMatrixFilter = null;
      this.spriteId = Sprite2._counter++;
      this.on("removed", this.onRemoveAsAChild);
    }
    /**
     * Nullify filters when the sprite is removed.
     *
     * @method _onRemoveAsAChild
     * @private
     */
    onRemoveAsAChild() {
      this.filters = null;
    }
    /**
     * The image for the sprite.
     *
     * @property bitmap
     * @type Bitmap
     */
    get bitmap() {
      console.log("DEPRECATED: Sprite.bitmap (getter)");
    }
    set bitmap(value3) {
      console.log("DEPRECATED: Sprite.bitmap (setter)");
    }
    /**
     * The width of the sprite without the scale.
     *
     * @property width
     * @type Number
     */
    get width() {
      return this._frame.width;
    }
    set width(value3) {
      this._frame.width = value3;
      this._refresh();
    }
    /**
     * The height of the sprite without the scale.
     *
     * @property height
     * @type Number
     */
    get height() {
      return this._frame.height;
    }
    set height(value3) {
      this._frame.height = value3;
      this._refresh();
    }
    /**
     * The opacity of the sprite (0 to 255).
     *
     * @property opacity
     * @type Number
     */
    get opacity() {
      return this.alpha * 255;
    }
    set opacity(value3) {
      this.alpha = value3.clamp(0, 255) / 255;
    }
    /**
     * Updates the sprite for each frame.
     *
     * @method update
     */
    update() {
      this.children.forEach((child) => {
        if (child.update) {
          child.update();
        }
      });
    }
    /**
     * Sets the x and y at once.
     *
     * @method move
     * @param {Number} x The x coordinate of the sprite
     * @param {Number} y The y coordinate of the sprite
     */
    move(x, y) {
      this.x = x;
      this.y = y;
    }
    /**
     * Sets the rectagle of the bitmap that the sprite displays.
     *
     * @method setFrame
     * @param {Number} x The x coordinate of the frame
     * @param {Number} y The y coordinate of the frame
     * @param {Number} width The width of the frame
     * @param {Number} height The height of the frame
     */
    setFrame(x, y, width, height) {
      this._refreshFrame = false;
      const frame = this._frame;
      if (x !== frame.x || y !== frame.y || width !== frame.width || height !== frame.height) {
        frame.x = x;
        frame.y = y;
        frame.width = width;
        frame.height = height;
        this._refresh();
      }
    }
    /**
     * Gets the blend color for the sprite.
     *
     * @method getBlendColor
     * @return {Array} The blend color [r, g, b, a]
     */
    getBlendColor() {
      return this._blendColor.clone();
    }
    /**
     * Sets the blend color for the sprite.
     *
     * @method setBlendColor
     * @param {Array} color The blend color [r, g, b, a]
     */
    setBlendColor(color2) {
      if (!(color2 instanceof Array)) {
        throw new Error("Argument must be an array");
      }
      if (!this._blendColor.equals(color2)) {
        this._blendColor = color2.clone();
        this._refresh();
      }
    }
    /**
     * Gets the color tone for the sprite.
     *
     * @method getColorTone
     * @return {Array} The color tone [r, g, b, gray]
     */
    getColorTone() {
      return this._colorTone.clone();
    }
    /**
     * Sets the color tone for the sprite.
     *
     * @method setColorTone
     * @param {Array} tone The color tone [r, g, b, gray]
     */
    setColorTone(tone) {
      if (!(tone instanceof Array)) {
        throw new Error("Argument must be an array");
      }
      if (!this._colorTone.equals(tone)) {
        this._colorTone = tone.clone();
        this._refresh();
      }
    }
    /**
     * @method _refresh
     * @private
     */
    _refresh() {
      if (this._needsTint()) {
        this._createTinter();
        this._executeTint();
      } else {
        this._clearTint();
      }
    }
    /**
     * @method _isInBitmapRect
     * @param {Number} x
     * @param {Number} y
     * @param {Number} w
     * @param {Number} h
     * @return {Boolean}
     * @private
     */
    _isInBitmapRect(x, y, w, h) {
      console.log("DEPRECATED Sprite._isInBitmapRect");
    }
    /**
     * @method _needsTint
     * @return {Boolean}
     * @private
     */
    _needsTint() {
      const tone = this._colorTone;
      return tone[0] || tone[1] || tone[2] || tone[3] || this._blendColor[3] > 0;
    }
    /**
     * @method _createTinter
     * @private
     */
    _createTinter() {
      if (GRAPHICS_QUALITY_LEVEL === 0) {
        return;
      }
      if (!this.filters) {
        this.filters = [];
        if (this._frame) {
          this.filterArea = new Rectangle(
            this._frame.x,
            this._frame.y,
            this._frame.width,
            this._frame.height
          );
        }
      }
      if (!this._colorMatrixFilter) {
        this._colorMatrixFilter = new filters.ColorMatrixFilter();
        this.filters.push(this._colorMatrixFilter);
      }
      this._colorMatrixFilter.enabled = true;
    }
    /**
     * @method _executeTint
     * @private
     */
    _executeTint() {
      if (GRAPHICS_QUALITY_LEVEL === 0) {
        this.tint = index.rgb2hex(color[0], color[1], color[2]);
      } else {
        const color2 = this._blendColor;
        const red2 = color2[0] / 255;
        const green2 = color2[1] / 255;
        const blue2 = color2[2] / 255;
        const opacity = color2[3] / 255;
        this._colorMatrixFilter.matrix = [
          red2 / 64,
          0,
          0,
          0,
          red2,
          0,
          green2 / 64,
          0,
          0,
          green2,
          0,
          0,
          blue2 / 64,
          0,
          blue2,
          0,
          0,
          0,
          1,
          0
        ];
        this._colorMatrixFilter.alpha = opacity;
      }
    }
    /**
     * @method _clearTint
     * @private
     */
    _clearTint() {
      if (this._colorMatrixFilter) {
        this._colorMatrixFilter.enabled = false;
      } else {
        this.tint = "0xffffff";
      }
    }
    // The important members from Pixi.js
    /**
     * The visibility of the sprite.
     *
     * @property visible
     * @type Boolean
     */
    /**
     * The x coordinate of the sprite.
     *
     * @property x
     * @type Number
     */
    /**
     * The y coordinate of the sprite.
     *
     * @property y
     * @type Number
     */
    /**
     * The origin point of the sprite. (0,0) to (1,1).
     *
     * @property anchor
     * @type Point
     */
    /**
     * The scale factor of the sprite.
     *
     * @property scale
     * @type Point
     */
    /**
     * The rotation of the sprite in radians.
     *
     * @property rotation
     * @type Number
     */
    /**
     * The blend mode to be applied to the sprite.
     *
     * @property blendMode
     * @type Number
     */
    /**
     * Sets the filters for the sprite.
     *
     * @property filters
     * @type Array
     */
    /**
     * [read-only] The array of children of the sprite.
     *
     * @property children
     * @type Array
     */
    /**
     * [read-only] The object that contains the sprite.
     *
     * @property parent
     * @type Object
     */
    /**
     * Adds a child to the container.
     *
     * @method addChild
     * @param {Object} child The child to add
     * @return {Object} The child that was added
     */
    /**
     * Adds a child to the container at a specified index.
     *
     * @method addChildAt
     * @param {Object} child The child to add
     * @param {Number} index The index to place the child in
     * @return {Object} The child that was added
     */
    /**
     * Removes a child from the container.
     *
     * @method removeChild
     * @param {Object} child The child to remove
     * @return {Object} The child that was removed
     */
    /**
     * Removes a child from the specified index position.
     *
     * @method removeChildAt
     * @param {Number} index The index to get the child from
     * @return {Object} The child that was removed
     */
  };
  Sprite2.voidFilter = new filters.AlphaFilter();
  Sprite2._counter = 0;
  var Sprite_default = Sprite2;

  // src-www/js/rpg_core/Tilemap.js
  var Tilemap = class extends Container {
    constructor() {
      super();
      this.initialize();
    }
    initialize() {
      this._margin = 20;
      this._width = Graphics_default.width + this._margin * 2;
      this._height = Graphics_default.height + this._margin * 2;
      this._tileWidth = 48;
      this._tileHeight = 48;
      this._mapWidth = 0;
      this._mapHeight = 0;
      this._mapData = null;
      this._layerWidth = 0;
      this._layerHeight = 0;
      this._lastTiles = [];
      this.bitmaps = [];
      this.origin = new Point_default();
      this.flags = [];
      this.animationCount = 0;
      this.horizontalWrap = false;
      this.verticalWrap = false;
      this._createLayers();
      this.refresh();
    }
    /**
     * The width of the screen in pixels.
     *
     * @property width
     * @type Number
     */
    get width() {
      return this._width;
    }
    set width(value3) {
      if (this._width !== value3) {
        this._width = value3;
        this._createLayers();
      }
    }
    /**
     * The height of the screen in pixels.
     *
     * @property height
     * @type Number
     */
    get height() {
      return this._height;
    }
    set height(value3) {
      if (this._height !== value3) {
        this._height = value3;
        this._createLayers();
      }
    }
    /**
     * The width of a tile in pixels.
     *
     * @property tileWidth
     * @type Number
     */
    get tileWidth() {
      return this._tileWidth;
    }
    set tileWidth(value3) {
      if (this._tileWidth !== value3) {
        this._tileWidth = value3;
        this._createLayers();
      }
    }
    /**
     * The height of a tile in pixels.
     *
     * @property tileHeight
     * @type Number
     */
    get tileHeight() {
      return this._tileHeight;
    }
    set tileHeight(value3) {
      if (this._tileHeight !== value3) {
        this._tileHeight = value3;
        this._createLayers();
      }
    }
    /**
     * Sets the tilemap data.
     *
     * @method setData
     * @param {Number} width The width of the map in number of tiles
     * @param {Number} height The height of the map in number of tiles
     * @param {Array} data The one dimensional array for the map data
     */
    setData(width, height, data) {
      this._mapWidth = width;
      this._mapHeight = height;
      this._mapData = data;
    }
    /**
     * Checks whether the tileset is ready to render.
     *
     * @method isReady
     * @type Boolean
     * @return {Boolean} True if the tilemap is ready
     */
    isReady() {
      for (let i = 0; i < this.bitmaps.length; i++) {
        if (this.bitmaps[i] && !this.bitmaps[i].isReady()) {
          return false;
        }
      }
      return true;
    }
    /**
     * Updates the tilemap for each frame.
     *
     * @method update
     */
    update() {
      this.animationCount++;
      this.animationFrame = Math.floor(this.animationCount / 30);
      this.children.forEach((child) => {
        if (child.update) {
          child.update();
        }
      });
      for (let i = 0; i < this.bitmaps.length; i++) {
        if (this.bitmaps[i]) {
          this.bitmaps[i].touch();
        }
      }
    }
    /**
     * Forces to repaint the entire tilemap.
     *
     * @method refresh
     */
    refresh() {
      this._lastTiles.length = 0;
    }
    /**
     * Forces to refresh the tileset
     *
     * @method refresh
     */
    refreshTileset() {
    }
    /**
     * @method updateTransform
     * @private
     */
    updateTransform() {
      const ox = Math.floor(this.origin.x);
      const oy = Math.floor(this.origin.y);
      const startX = Math.floor((ox - this._margin) / this._tileWidth);
      const startY = Math.floor((oy - this._margin) / this._tileHeight);
      this._updateLayerPositions(startX, startY);
      if (this._needsRepaint || this._lastAnimationFrame !== this.animationFrame || this._lastStartX !== startX || this._lastStartY !== startY) {
        this._frameUpdated = this._lastAnimationFrame !== this.animationFrame;
        this._lastAnimationFrame = this.animationFrame;
        this._lastStartX = startX;
        this._lastStartY = startY;
        this._paintAllTiles(startX, startY);
        this._needsRepaint = false;
      }
      this._sortChildren();
      super.updateTransform();
    }
    /**
     * @method _createLayers
     * @private
     */
    _createLayers() {
      const width = this._width;
      const height = this._height;
      const margin = this._margin;
      const tileCols = Math.ceil(width / this._tileWidth) + 1;
      const tileRows = Math.ceil(height / this._tileHeight) + 1;
      const layerWidth = tileCols * this._tileWidth;
      const layerHeight = tileRows * this._tileHeight;
      this._lowerBitmap = new Bitmap_default(layerWidth, layerHeight);
      this._upperBitmap = new Bitmap_default(layerWidth, layerHeight);
      this._layerWidth = layerWidth;
      this._layerHeight = layerHeight;
      this._lowerLayer = new Sprite_default();
      this._lowerLayer.move(-margin, -margin, width, height);
      this._lowerLayer.z = 0;
      this._upperLayer = new Sprite_default();
      this._upperLayer.move(-margin, -margin, width, height);
      this._upperLayer.z = 4;
      for (let i = 0; i < 4; i++) {
        this._lowerLayer.addChild(new Sprite_default(this._lowerBitmap));
        this._upperLayer.addChild(new Sprite_default(this._upperBitmap));
      }
      this.addChild(this._lowerLayer);
      this.addChild(this._upperLayer);
    }
    /**
     * @method _updateLayerPositions
     * @param {Number} startX
     * @param {Number} startY
     * @private
     */
    _updateLayerPositions(startX, startY) {
      const m = this._margin;
      const ox = Math.floor(this.origin.x);
      const oy = Math.floor(this.origin.y);
      const x2 = (ox - m).mod(this._layerWidth);
      const y2 = (oy - m).mod(this._layerHeight);
      const w1 = this._layerWidth - x2;
      const h1 = this._layerHeight - y2;
      const w2 = this._width - w1;
      const h2 = this._height - h1;
      for (let i = 0; i < 2; i++) {
        let children;
        if (i === 0) {
          children = this._lowerLayer.children;
        } else {
          children = this._upperLayer.children;
        }
        children[0].move(0, 0, w1, h1);
        children[0].setFrame(x2, y2, w1, h1);
        children[1].move(w1, 0, w2, h1);
        children[1].setFrame(0, y2, w2, h1);
        children[2].move(0, h1, w1, h2);
        children[2].setFrame(x2, 0, w1, h2);
        children[3].move(w1, h1, w2, h2);
        children[3].setFrame(0, 0, w2, h2);
      }
    }
    /**
     * @method _paintAllTiles
     * @param {Number} startX
     * @param {Number} startY
     * @private
     */
    _paintAllTiles(startX, startY) {
      const tileCols = Math.ceil(this._width / this._tileWidth) + 1;
      const tileRows = Math.ceil(this._height / this._tileHeight) + 1;
      for (let y = 0; y < tileRows; y++) {
        for (let x = 0; x < tileCols; x++) {
          this._paintTiles(startX, startY, x, y);
        }
      }
    }
    /**
     * @method _paintTiles
     * @param {Number} startX
     * @param {Number} startY
     * @param {Number} x
     * @param {Number} y
     * @private
     */
    _paintTiles(startX, startY, x, y) {
      const tableEdgeVirtualId = 1e4;
      const mx = startX + x;
      const my = startY + y;
      const dx = (mx * this._tileWidth).mod(this._layerWidth);
      const dy = (my * this._tileHeight).mod(this._layerHeight);
      const lx = dx / this._tileWidth;
      const ly = dy / this._tileHeight;
      const tileId0 = this._readMapData(mx, my, 0);
      const tileId1 = this._readMapData(mx, my, 1);
      const tileId2 = this._readMapData(mx, my, 2);
      const tileId3 = this._readMapData(mx, my, 3);
      const shadowBits = this._readMapData(mx, my, 4);
      const upperTileId1 = this._readMapData(mx, my - 1, 1);
      const lowerTiles = [];
      const upperTiles = [];
      if (this._isHigherTile(tileId0)) {
        upperTiles.push(tileId0);
      } else {
        lowerTiles.push(tileId0);
      }
      if (this._isHigherTile(tileId1)) {
        upperTiles.push(tileId1);
      } else {
        lowerTiles.push(tileId1);
      }
      lowerTiles.push(-shadowBits);
      if (this._isTableTile(upperTileId1) && !this._isTableTile(tileId1)) {
        if (!Tilemap.isShadowingTile(tileId0)) {
          lowerTiles.push(tableEdgeVirtualId + upperTileId1);
        }
      }
      if (this._isOverpassPosition(mx, my)) {
        upperTiles.push(tileId2);
        upperTiles.push(tileId3);
      } else {
        if (this._isHigherTile(tileId2)) {
          upperTiles.push(tileId2);
        } else {
          lowerTiles.push(tileId2);
        }
        if (this._isHigherTile(tileId3)) {
          upperTiles.push(tileId3);
        } else {
          lowerTiles.push(tileId3);
        }
      }
      const lastLowerTiles = this._readLastTiles(0, lx, ly);
      if (!lowerTiles.equals(lastLowerTiles) || Tilemap.isTileA1(tileId0) && this._frameUpdated) {
        this._lowerBitmap.clearRect(dx, dy, this._tileWidth, this._tileHeight);
        for (const lowerTileId of lowerTiles) {
          if (lowerTileId < 0) {
            this._drawShadow(this._lowerBitmap, shadowBits, dx, dy);
          } else if (lowerTileId >= tableEdgeVirtualId) {
            this._drawTableEdge(this._lowerBitmap, upperTileId1, dx, dy);
          } else {
            this._drawTile(this._lowerBitmap, lowerTileId, dx, dy);
          }
        }
        this._writeLastTiles(0, lx, ly, lowerTiles);
      }
      const lastUpperTiles = this._readLastTiles(1, lx, ly);
      if (!upperTiles.equals(lastUpperTiles)) {
        this._upperBitmap.clearRect(dx, dy, this._tileWidth, this._tileHeight);
        for (let j = 0; j < upperTiles.length; j++) {
          this._drawTile(this._upperBitmap, upperTiles[j], dx, dy);
        }
        this._writeLastTiles(1, lx, ly, upperTiles);
      }
    }
    /**
     * @method _readLastTiles
     * @param {Number} i
     * @param {Number} x
     * @param {Number} y
     * @private
     */
    _readLastTiles(i, x, y) {
      const array1 = this._lastTiles[i];
      if (array1) {
        const array2 = array1[y];
        if (array2) {
          const tiles = array2[x];
          if (tiles) {
            return tiles;
          }
        }
      }
      return [];
    }
    /**
     * @method _writeLastTiles
     * @param {Number} i
     * @param {Number} x
     * @param {Number} y
     * @param {Array} tiles
     * @private
     */
    _writeLastTiles(i, x, y, tiles) {
      let array1 = this._lastTiles[i];
      if (!array1) {
        array1 = this._lastTiles[i] = [];
      }
      let array2 = array1[y];
      if (!array2) {
        array2 = array1[y] = [];
      }
      array2[x] = tiles;
    }
    /**
     * @method _drawTile
     * @param {Bitmap} bitmap
     * @param {Number} tileId
     * @param {Number} dx
     * @param {Number} dy
     * @private
     */
    _drawTile(bitmap, tileId, dx, dy) {
      if (Tilemap.isVisibleTile(tileId)) {
        if (Tilemap.isAutotile(tileId)) {
          this._drawAutotile(bitmap, tileId, dx, dy);
        } else {
          this._drawNormalTile(bitmap, tileId, dx, dy);
        }
      }
    }
    /**
     * @method _drawNormalTile
     * @param {Bitmap} bitmap
     * @param {Number} tileId
     * @param {Number} dx
     * @param {Number} dy
     * @private
     */
    _drawNormalTile(bitmap, tileId, dx, dy) {
      let setNumber = 0;
      if (Tilemap.isTileA5(tileId)) {
        setNumber = 4;
      } else {
        setNumber = 5 + Math.floor(tileId / 256);
      }
      const w = this._tileWidth;
      const h = this._tileHeight;
      const sx = (Math.floor(tileId / 128) % 2 * 8 + tileId % 8) * w;
      const sy = Math.floor(tileId % 256 / 8) % 16 * h;
      const source = this.bitmaps[setNumber];
      if (source) {
        bitmap.bltImage(source, sx, sy, w, h, dx, dy, w, h);
      }
    }
    /**
     * @method _drawAutotile
     * @param {Bitmap} bitmap
     * @param {Number} tileId
     * @param {Number} dx
     * @param {Number} dy
     * @private
     */
    _drawAutotile(bitmap, tileId, dx, dy) {
      let autotileTable = Tilemap.FLOOR_AUTOTILE_TABLE;
      const kind = Tilemap.getAutotileKind(tileId);
      const shape = Tilemap.getAutotileShape(tileId);
      const tx = kind % 8;
      const ty = Math.floor(kind / 8);
      let bx = 0;
      let by = 0;
      let setNumber = 0;
      let isTable = false;
      if (Tilemap.isTileA1(tileId)) {
        const waterSurfaceIndex = [0, 1, 2, 1][this.animationFrame % 4];
        setNumber = 0;
        if (kind === 0) {
          bx = waterSurfaceIndex * 2;
          by = 0;
        } else if (kind === 1) {
          bx = waterSurfaceIndex * 2;
          by = 3;
        } else if (kind === 2) {
          bx = 6;
          by = 0;
        } else if (kind === 3) {
          bx = 6;
          by = 3;
        } else {
          bx = Math.floor(tx / 4) * 8;
          by = ty * 6 + Math.floor(tx / 2) % 2 * 3;
          if (kind % 2 === 0) {
            bx += waterSurfaceIndex * 2;
          } else {
            bx += 6;
            autotileTable = Tilemap.WATERFALL_AUTOTILE_TABLE;
            by += this.animationFrame % 3;
          }
        }
      } else if (Tilemap.isTileA2(tileId)) {
        setNumber = 1;
        bx = tx * 2;
        by = (ty - 2) * 3;
        isTable = this._isTableTile(tileId);
      } else if (Tilemap.isTileA3(tileId)) {
        setNumber = 2;
        bx = tx * 2;
        by = (ty - 6) * 2;
        autotileTable = Tilemap.WALL_AUTOTILE_TABLE;
      } else if (Tilemap.isTileA4(tileId)) {
        setNumber = 3;
        bx = tx * 2;
        by = Math.floor((ty - 10) * 2.5 + (ty % 2 === 1 ? 0.5 : 0));
        if (ty % 2 === 1) {
          autotileTable = Tilemap.WALL_AUTOTILE_TABLE;
        }
      }
      const table = autotileTable[shape];
      const source = this.bitmaps[setNumber];
      if (table && source) {
        const w1 = this._tileWidth / 2;
        const h1 = this._tileHeight / 2;
        for (let i = 0; i < 4; i++) {
          const qsx = table[i][0];
          const qsy = table[i][1];
          const sx1 = (bx * 2 + qsx) * w1;
          const sy1 = (by * 2 + qsy) * h1;
          const dx1 = dx + i % 2 * w1;
          let dy1 = dy + Math.floor(i / 2) * h1;
          if (isTable && (qsy === 1 || qsy === 5)) {
            let qsx2 = qsx;
            let qsy2 = 3;
            if (qsy === 1) {
              qsx2 = [0, 3, 2, 1][qsx];
            }
            const sx2 = (bx * 2 + qsx2) * w1;
            const sy2 = (by * 2 + qsy2) * h1;
            bitmap.bltImage(source, sx2, sy2, w1, h1, dx1, dy1, w1, h1);
            dy1 += h1 / 2;
            bitmap.bltImage(source, sx1, sy1, w1, h1 / 2, dx1, dy1, w1, h1 / 2);
          } else {
            bitmap.bltImage(source, sx1, sy1, w1, h1, dx1, dy1, w1, h1);
          }
        }
      }
    }
    /**
     * @method _drawTableEdge
     * @param {Bitmap} bitmap
     * @param {Number} tileId
     * @param {Number} dx
     * @param {Number} dy
     * @private
     */
    _drawTableEdge(bitmap, tileId, dx, dy) {
      if (Tilemap.isTileA2(tileId)) {
        const autotileTable = Tilemap.FLOOR_AUTOTILE_TABLE;
        const kind = Tilemap.getAutotileKind(tileId);
        const shape = Tilemap.getAutotileShape(tileId);
        const tx = kind % 8;
        const ty = Math.floor(kind / 8);
        const setNumber = 1;
        const bx = tx * 2;
        const by = (ty - 2) * 3;
        const table = autotileTable[shape];
        if (table) {
          const source = this.bitmaps[setNumber];
          const w1 = this._tileWidth / 2;
          const h1 = this._tileHeight / 2;
          for (let i = 0; i < 2; i++) {
            const qsx = table[2 + i][0];
            const qsy = table[2 + i][1];
            const sx1 = (bx * 2 + qsx) * w1;
            const sy1 = (by * 2 + qsy) * h1 + h1 / 2;
            const dx1 = dx + i % 2 * w1;
            const dy1 = dy + Math.floor(i / 2) * h1;
            bitmap.bltImage(source, sx1, sy1, w1, h1 / 2, dx1, dy1, w1, h1 / 2);
          }
        }
      }
    }
    /**
     * @method _drawShadow
     * @param {Bitmap} bitmap
     * @param {Number} shadowBits
     * @param {Number} dx
     * @param {Number} dy
     * @private
     */
    _drawShadow(bitmap, shadowBits, dx, dy) {
    }
    /**
     * @method _readMapData
     * @param {Number} x
     * @param {Number} y
     * @param {Number} z
     * @return {Number}
     * @private
     */
    _readMapData(x, y, z) {
      if (this._mapData) {
        const width = this._mapWidth;
        const height = this._mapHeight;
        if (this.horizontalWrap) {
          x = x.mod(width);
        }
        if (this.verticalWrap) {
          y = y.mod(height);
        }
        if (x >= 0 && x < width && y >= 0 && y < height) {
          return this._mapData[(z * height + y) * width + x] || 0;
        } else {
          return 0;
        }
      } else {
        return 0;
      }
    }
    /**
     * @method _isHigherTile
     * @param {Number} tileId
     * @return {Boolean}
     * @private
     */
    _isHigherTile(tileId) {
      return this.flags[tileId] & 16;
    }
    /**
     * @method _isTableTile
     * @param {Number} tileId
     * @return {Boolean}
     * @private
     */
    _isTableTile(tileId) {
      return Tilemap.isTileA2(tileId) && this.flags[tileId] & 128;
    }
    /**
     * @method _isOverpassPosition
     * @param {Number} mx
     * @param {Number} my
     * @return {Boolean}
     * @private
     */
    _isOverpassPosition(mx, my) {
      return false;
    }
    /**
     * @method _sortChildren
     * @private
     */
    _sortChildren() {
      this.children.sort(this._compareChildOrder.bind(this));
    }
    /**
     * @method _compareChildOrder
     * @param {Object} a
     * @param {Object} b
     * @private
     */
    _compareChildOrder(a2, b2) {
      if (a2.z === b2.z) {
        if (a2.y === b2.y) {
          return a2.spriteId - b2.spriteId;
        }
        return a2.y - b2.y;
      }
      return a2.z - b2.z;
    }
    static isVisibleTile(tileId) {
      return tileId > 0 && tileId < this.TILE_ID_MAX;
    }
    static isAutotile(tileId) {
      return tileId >= this.TILE_ID_A1;
    }
    static getAutotileKind(tileId) {
      return Math.floor((tileId - this.TILE_ID_A1) / 48);
    }
    static getAutotileShape(tileId) {
      return (tileId - this.TILE_ID_A1) % 48;
    }
    static makeAutotileId(kind, shape) {
      return this.TILE_ID_A1 + kind * 48 + shape;
    }
    static isSameKindTile(tileID1, tileID2) {
      if (this.isAutotile(tileID1) && this.isAutotile(tileID2)) {
        return this.getAutotileKind(tileID1) === this.getAutotileKind(tileID2);
      } else {
        return tileID1 === tileID2;
      }
    }
    static isTileA1(tileId) {
      return tileId >= this.TILE_ID_A1 && tileId < this.TILE_ID_A2;
    }
    static isTileA2(tileId) {
      return tileId >= this.TILE_ID_A2 && tileId < this.TILE_ID_A3;
    }
    static isTileA3(tileId) {
      return tileId >= this.TILE_ID_A3 && tileId < this.TILE_ID_A4;
    }
    static isTileA4(tileId) {
      return tileId >= this.TILE_ID_A4 && tileId < this.TILE_ID_MAX;
    }
    static isTileA5(tileId) {
      return tileId >= this.TILE_ID_A5 && tileId < this.TILE_ID_A1;
    }
    static isWaterTile(tileId) {
      if (this.isTileA1(tileId)) {
        return !(tileId >= this.TILE_ID_A1 + 96 && tileId < this.TILE_ID_A1 + 192);
      } else {
        return false;
      }
    }
    static isWaterfallTile(tileId) {
      if (tileId >= this.TILE_ID_A1 + 192 && tileId < this.TILE_ID_A2) {
        return this.getAutotileKind(tileId) % 2 === 1;
      } else {
        return false;
      }
    }
    static isGroundTile(tileId) {
      return this.isTileA1(tileId) || this.isTileA2(tileId) || this.isTileA5(tileId);
    }
    static isShadowingTile(tileId) {
      return this.isTileA3(tileId) || this.isTileA4(tileId);
    }
    static isRoofTile(tileId) {
      return this.isTileA3(tileId) && this.getAutotileKind(tileId) % 16 < 8;
    }
    static isWallTopTile(tileId) {
      return this.isTileA4(tileId) && this.getAutotileKind(tileId) % 16 < 8;
    }
    static isWallSideTile(tileId) {
      return (this.isTileA3(tileId) || this.isTileA4(tileId)) && this.getAutotileKind(tileId) % 16 >= 8;
    }
    static isWallTile(tileId) {
      return this.isWallTopTile(tileId) || this.isWallSideTile(tileId);
    }
    static isFloorTypeAutotile(tileId) {
      return this.isTileA1(tileId) && !this.isWaterfallTile(tileId) || this.isTileA2(tileId) || this.isWallTopTile(tileId);
    }
    static isWallTypeAutotile(tileId) {
      return this.isRoofTile(tileId) || this.isWallSideTile(tileId);
    }
    static isWaterfallTypeAutotile(tileId) {
      return this.isWaterfallTile(tileId);
    }
  };
  Tilemap.TILE_ID_B = 0;
  Tilemap.TILE_ID_C = 256;
  Tilemap.TILE_ID_D = 512;
  Tilemap.TILE_ID_E = 768;
  Tilemap.TILE_ID_A5 = 1536;
  Tilemap.TILE_ID_A1 = 2048;
  Tilemap.TILE_ID_A2 = 2816;
  Tilemap.TILE_ID_A3 = 4352;
  Tilemap.TILE_ID_A4 = 5888;
  Tilemap.TILE_ID_MAX = 8192;
  Tilemap.FLOOR_AUTOTILE_TABLE = [
    [
      [2, 4],
      [1, 4],
      [2, 3],
      [1, 3]
    ],
    [
      [2, 0],
      [1, 4],
      [2, 3],
      [1, 3]
    ],
    [
      [2, 4],
      [3, 0],
      [2, 3],
      [1, 3]
    ],
    [
      [2, 0],
      [3, 0],
      [2, 3],
      [1, 3]
    ],
    [
      [2, 4],
      [1, 4],
      [2, 3],
      [3, 1]
    ],
    [
      [2, 0],
      [1, 4],
      [2, 3],
      [3, 1]
    ],
    [
      [2, 4],
      [3, 0],
      [2, 3],
      [3, 1]
    ],
    [
      [2, 0],
      [3, 0],
      [2, 3],
      [3, 1]
    ],
    [
      [2, 4],
      [1, 4],
      [2, 1],
      [1, 3]
    ],
    [
      [2, 0],
      [1, 4],
      [2, 1],
      [1, 3]
    ],
    [
      [2, 4],
      [3, 0],
      [2, 1],
      [1, 3]
    ],
    [
      [2, 0],
      [3, 0],
      [2, 1],
      [1, 3]
    ],
    [
      [2, 4],
      [1, 4],
      [2, 1],
      [3, 1]
    ],
    [
      [2, 0],
      [1, 4],
      [2, 1],
      [3, 1]
    ],
    [
      [2, 4],
      [3, 0],
      [2, 1],
      [3, 1]
    ],
    [
      [2, 0],
      [3, 0],
      [2, 1],
      [3, 1]
    ],
    [
      [0, 4],
      [1, 4],
      [0, 3],
      [1, 3]
    ],
    [
      [0, 4],
      [3, 0],
      [0, 3],
      [1, 3]
    ],
    [
      [0, 4],
      [1, 4],
      [0, 3],
      [3, 1]
    ],
    [
      [0, 4],
      [3, 0],
      [0, 3],
      [3, 1]
    ],
    [
      [2, 2],
      [1, 2],
      [2, 3],
      [1, 3]
    ],
    [
      [2, 2],
      [1, 2],
      [2, 3],
      [3, 1]
    ],
    [
      [2, 2],
      [1, 2],
      [2, 1],
      [1, 3]
    ],
    [
      [2, 2],
      [1, 2],
      [2, 1],
      [3, 1]
    ],
    [
      [2, 4],
      [3, 4],
      [2, 3],
      [3, 3]
    ],
    [
      [2, 4],
      [3, 4],
      [2, 1],
      [3, 3]
    ],
    [
      [2, 0],
      [3, 4],
      [2, 3],
      [3, 3]
    ],
    [
      [2, 0],
      [3, 4],
      [2, 1],
      [3, 3]
    ],
    [
      [2, 4],
      [1, 4],
      [2, 5],
      [1, 5]
    ],
    [
      [2, 0],
      [1, 4],
      [2, 5],
      [1, 5]
    ],
    [
      [2, 4],
      [3, 0],
      [2, 5],
      [1, 5]
    ],
    [
      [2, 0],
      [3, 0],
      [2, 5],
      [1, 5]
    ],
    [
      [0, 4],
      [3, 4],
      [0, 3],
      [3, 3]
    ],
    [
      [2, 2],
      [1, 2],
      [2, 5],
      [1, 5]
    ],
    [
      [0, 2],
      [1, 2],
      [0, 3],
      [1, 3]
    ],
    [
      [0, 2],
      [1, 2],
      [0, 3],
      [3, 1]
    ],
    [
      [2, 2],
      [3, 2],
      [2, 3],
      [3, 3]
    ],
    [
      [2, 2],
      [3, 2],
      [2, 1],
      [3, 3]
    ],
    [
      [2, 4],
      [3, 4],
      [2, 5],
      [3, 5]
    ],
    [
      [2, 0],
      [3, 4],
      [2, 5],
      [3, 5]
    ],
    [
      [0, 4],
      [1, 4],
      [0, 5],
      [1, 5]
    ],
    [
      [0, 4],
      [3, 0],
      [0, 5],
      [1, 5]
    ],
    [
      [0, 2],
      [3, 2],
      [0, 3],
      [3, 3]
    ],
    [
      [0, 2],
      [1, 2],
      [0, 5],
      [1, 5]
    ],
    [
      [0, 4],
      [3, 4],
      [0, 5],
      [3, 5]
    ],
    [
      [2, 2],
      [3, 2],
      [2, 5],
      [3, 5]
    ],
    [
      [0, 2],
      [3, 2],
      [0, 5],
      [3, 5]
    ],
    [
      [0, 0],
      [1, 0],
      [0, 1],
      [1, 1]
    ]
  ];
  Tilemap.WALL_AUTOTILE_TABLE = [
    [
      [2, 2],
      [1, 2],
      [2, 1],
      [1, 1]
    ],
    [
      [0, 2],
      [1, 2],
      [0, 1],
      [1, 1]
    ],
    [
      [2, 0],
      [1, 0],
      [2, 1],
      [1, 1]
    ],
    [
      [0, 0],
      [1, 0],
      [0, 1],
      [1, 1]
    ],
    [
      [2, 2],
      [3, 2],
      [2, 1],
      [3, 1]
    ],
    [
      [0, 2],
      [3, 2],
      [0, 1],
      [3, 1]
    ],
    [
      [2, 0],
      [3, 0],
      [2, 1],
      [3, 1]
    ],
    [
      [0, 0],
      [3, 0],
      [0, 1],
      [3, 1]
    ],
    [
      [2, 2],
      [1, 2],
      [2, 3],
      [1, 3]
    ],
    [
      [0, 2],
      [1, 2],
      [0, 3],
      [1, 3]
    ],
    [
      [2, 0],
      [1, 0],
      [2, 3],
      [1, 3]
    ],
    [
      [0, 0],
      [1, 0],
      [0, 3],
      [1, 3]
    ],
    [
      [2, 2],
      [3, 2],
      [2, 3],
      [3, 3]
    ],
    [
      [0, 2],
      [3, 2],
      [0, 3],
      [3, 3]
    ],
    [
      [2, 0],
      [3, 0],
      [2, 3],
      [3, 3]
    ],
    [
      [0, 0],
      [3, 0],
      [0, 3],
      [3, 3]
    ]
  ];
  Tilemap.WATERFALL_AUTOTILE_TABLE = [
    [
      [2, 0],
      [1, 0],
      [2, 1],
      [1, 1]
    ],
    [
      [0, 0],
      [1, 0],
      [0, 1],
      [1, 1]
    ],
    [
      [2, 0],
      [3, 0],
      [2, 1],
      [3, 1]
    ],
    [
      [0, 0],
      [3, 0],
      [0, 1],
      [3, 1]
    ]
  ];
  var Tilemap_default = Tilemap;

  // src-www/js/rpg_core/TilingSprite.js
  var TilingSprite2 = class extends TilingSprite {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(bitmap) {
      const texture = new Texture(new BaseTexture());
      this._bitmap = null;
      this._width = 0;
      this._height = 0;
      this._frame = new Rectangle_default();
      this.spriteId = Sprite_default._counter++;
      this.origin = new Point_default();
      this.bitmap = bitmap;
    }
    /**
     * @method _renderCanvas
     * @param {Object} renderer
     * @private
     */
    _renderCanvas(renderer) {
      if (this._bitmap) {
        this._bitmap.touch();
      }
      if (this.texture.frame.width > 0 && this.texture.frame.height > 0) {
        this._renderCanvas_PIXI(renderer);
      }
    }
    /**
     * The image for the tiling sprite.
     *
     * @property bitmap
     * @type Bitmap
     */
    get bitmap() {
      return this._bitmap;
    }
    set bitmap(value3) {
      if (this._bitmap !== value3) {
        this._bitmap = value3;
        if (this._bitmap) {
          this._bitmap.addLoadListener(this._onBitmapLoad.bind(this));
        } else {
          this.texture.frame = Rectangle_default.emptyRectangle;
        }
      }
    }
    /**
     * The opacity of the tiling sprite (0 to 255).
     *
     * @property opacity
     * @type Number
     */
    get opacity() {
      return this.alpha * 255;
    }
    set opacity(value3) {
      this.alpha = value3.clamp(0, 255) / 255;
    }
    /**
     * Updates the tiling sprite for each frame.
     *
     * @method update
     */
    update() {
      this.children.forEach((child) => {
        if (child.update) {
          child.update();
        }
      });
    }
    /**
     * Sets the x, y, width, and height all at once.
     *
     * @method move
     * @param {Number} x The x coordinate of the tiling sprite
     * @param {Number} y The y coordinate of the tiling sprite
     * @param {Number} width The width of the tiling sprite
     * @param {Number} height The height of the tiling sprite
     */
    move(x, y, width, height) {
      this.x = x || 0;
      this.y = y || 0;
      this._width = width || 0;
      this._height = height || 0;
    }
    /**
     * Specifies the region of the image that the tiling sprite will use.
     *
     * @method setFrame
     * @param {Number} x The x coordinate of the frame
     * @param {Number} y The y coordinate of the frame
     * @param {Number} width The width of the frame
     * @param {Number} height The height of the frame
     */
    setFrame(x, y, width, height) {
      this._frame.x = x;
      this._frame.y = y;
      this._frame.width = width;
      this._frame.height = height;
      this._refresh();
    }
    /**
     * @method updateTransform
     * @private
     */
    updateTransform() {
      this.tilePosition.x = Math.round(-this.origin.x);
      this.tilePosition.y = Math.round(-this.origin.y);
      this.updateTransformTS();
    }
    /**
     * @method _onBitmapLoad
     * @private
     */
    _onBitmapLoad() {
      this.texture.baseTexture = this._bitmap.baseTexture;
      this._refresh();
    }
    /**
     * @method _refresh
     * @private
     */
    _refresh() {
      const frame = this._frame.clone();
      if (frame.width === 0 && frame.height === 0 && this._bitmap) {
        frame.width = this._bitmap.width;
        frame.height = this._bitmap.height;
      }
      this.texture.frame = frame;
      this.texture._updateID++;
      this.tilingTexture = null;
    }
    /**
     * @method _render
     * @param {Object} renderer
     * @private
     */
    _render(renderer) {
      if (this._bitmap) {
        this._bitmap.touch();
        this._bitmap.checkDirty();
      }
      this._render_PIXI(renderer);
    }
    // The important members from Pixi.js
    /**
     * The visibility of the tiling sprite.
     *
     * @property visible
     * @type Boolean
     */
    /**
     * The x coordinate of the tiling sprite.
     *
     * @property x
     * @type Number
     */
    /**
     * The y coordinate of the tiling sprite.
     *
     * @property y
     * @type Number
     */
  };
  TilingSprite2.prototype._renderCanvas_PIXI = TilingSprite.prototype._renderCanvas;
  TilingSprite2.prototype._render_PIXI = TilingSprite.prototype._render;
  TilingSprite2.prototype.updateTransformTS = TilingSprite.prototype.updateTransform;
  var TilingSprite_default = TilingSprite2;

  // src-www/js/rpg_core/ScreenSprite.js
  var ScreenSprite = class extends Container {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      this._graphics = new Graphics();
      this.addChild(this._graphics);
      this.opacity = 0;
      this._red = -1;
      this._green = -1;
      this._blue = -1;
      this._colorText = "";
      this.setBlack();
    }
    /**
     * The opacity of the sprite (0 to 255).
     *
     * @property opacity
     * @type Number
     */
    get opacity() {
      return this.alpha * 255;
    }
    set opacity(value3) {
      this.alpha = value3.clamp(0, 255) / 255;
    }
    get anchor() {
      ScreenSprite.warnYep();
      this.scale.x = 1;
      this.scale.y = 1;
      return {
        x: 0,
        y: 0
      };
    }
    set anchor(value3) {
      this.alpha = value3.clamp(0, 255) / 255;
    }
    get blendMode() {
      return this._graphics.blendMode;
    }
    set blendMode(value3) {
      this._graphics.blendMode = value3;
    }
    /**
     * Sets black to the color of the screen sprite.
     *
     * @method setBlack
     */
    setBlack() {
      this.setColor(0, 0, 0);
    }
    /**
     * Sets white to the color of the screen sprite.
     *
     * @method setWhite
     */
    setWhite() {
      this.setColor(255, 255, 255);
    }
    /**
     * Sets the color of the screen sprite by values.
     *
     * @method setColor
     * @param {Number} r The red value in the range (0, 255)
     * @param {Number} g The green value in the range (0, 255)
     * @param {Number} b The blue value in the range (0, 255)
     */
    setColor(r, g, b2) {
      if (this._red !== r || this._green !== g || this._blue !== b2) {
        r = Math.round(r || 0).clamp(0, 255);
        g = Math.round(g || 0).clamp(0, 255);
        b2 = Math.round(b2 || 0).clamp(0, 255);
        this._red = r;
        this._green = g;
        this._blue = b2;
        this._colorText = Utils_default.rgbToCssColor(r, g, b2);
        const graphics = this._graphics;
        graphics.clear();
        const intColor = r << 16 | g << 8 | b2;
        graphics.beginFill(intColor, 1);
        graphics.drawRect(
          -Graphics_default.width * 5,
          -Graphics_default.height * 5,
          Graphics_default.width * 10,
          Graphics_default.height * 10
        );
      }
    }
  };
  var ScreenSprite_default = ScreenSprite;

  // src-www/js/rpg_core/WindowSkinCache.js
  var WindowSkinCache = class {
    constructor() {
      throw new Error("This is a static class");
    }
    static setItem(name, resource, type) {
      if (!WindowSkinCache._cache[name]) {
        WindowSkinCache._cache[name] = {};
      }
      WindowSkinCache._cache[name][type] = resource;
    }
    static getItem(name, type) {
      if (!WindowSkinCache._cache[name])
        return false;
      if (!WindowSkinCache._cache[name][type])
        return false;
      return WindowSkinCache._cache[name][type];
    }
  };
  WindowSkinCache._cache = {};
  var WindowSkinCache_default = WindowSkinCache;

  // src-www/js/rpg_core/Window.js
  var Window = class extends Container {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      this._isWindow = true;
      this._windowskin = null;
      this._width = 0;
      this._height = 0;
      this._cursorRect = new Rectangle_default();
      this._openness = 255;
      this._animationCount = 0;
      this._padding = 18;
      this._margin = 4;
      this._colorTone = [0, 0, 0];
      this._windowSpriteContainer = null;
      this._windowBackSprite = null;
      this._windowCursorSprite = null;
      this._windowFrameSprite = null;
      this._windowContentsSprite = null;
      this._windowArrowSprites = [];
      this._windowPauseSignSprite = null;
      this._createAllParts();
      this.origin = new Point_default();
      this.active = true;
      this.downArrowVisible = false;
      this.upArrowVisible = false;
      this.pause = false;
    }
    /**
     * The image used as a window skin.
     *
     * @property windowskin
     * @type Bitmap
     */
    get windowskin() {
      return this._windowskin;
    }
    set windowskin(value3) {
      if (this._windowskin !== value3) {
        this._windowskin = value3;
        this._windowskin.addLoadListener(this._onWindowskinLoad.bind(this));
      }
    }
    /**
     * The bitmap used for the window contents.
     *
     * @property contents
     * @type Bitmap
     */
    get contents() {
      return this._windowContentsSprite.children[0];
    }
    set contents(value3) {
      const oldContents = this._windowContentsSprite.children[0];
      if (oldContents) {
        this._windowContentsSprite.removeChild(oldContents);
      }
      this._windowContentsSprite.addChild(value3);
    }
    /**
     * The width of the window in pixels.
     *
     * @property width
     * @type Number
     */
    get width() {
      return this._width;
    }
    set width(value3) {
      this._width = value3;
      this._refreshAllParts();
    }
    /**
     * The height of the window in pixels.
     *
     * @property height
     * @type Number
     */
    get height() {
      return this._height;
    }
    set height(value3) {
      this._height = value3;
      this._refreshAllParts();
    }
    /**
     * The size of the padding between the frame and contents.
     *
     * @property padding
     * @type Number
     */
    get padding() {
      return this._padding;
    }
    set padding(value3) {
      this._padding = value3;
      this._refreshAllParts();
    }
    /**
     * The size of the margin for the window background.
     *
     * @property margin
     * @type Number
     */
    get margin() {
      return this._margin;
    }
    set margin(value3) {
      this._margin = value3;
      this._refreshAllParts();
    }
    /**
     * The opacity of the window without contents (0 to 255).
     *
     * @property opacity
     * @type Number
     */
    get opacity() {
      return this._windowSpriteContainer.alpha * 255;
    }
    set opacity(value3) {
      this._windowSpriteContainer.alpha = value3.clamp(0, 255) / 255;
    }
    /**
     * The opacity of the window background (0 to 255).
     *
     * @property backOpacity
     * @type Number
     */
    get backOpacity() {
      return this._windowBackSprite.alpha * 255;
    }
    set backOpacity(value3) {
      this._windowBackSprite.alpha = value3.clamp(0, 255) / 255;
    }
    /**
     * The opacity of the window contents (0 to 255).
     *
     * @property contentsOpacity
     * @type Number
     */
    get contentsOpacity() {
      return this._windowContentsSprite.alpha * 255;
    }
    set contentsOpacity(value3) {
      this._windowContentsSprite.alpha = value3.clamp(0, 255) / 255;
    }
    /**
     * The openness of the window (0 to 255).
     *
     * @property openness
     * @type Number
     */
    get openness() {
      return this._openness;
    }
    set openness(value3) {
      if (this._openness !== value3) {
        this._openness = value3.clamp(0, 255);
        this._windowSpriteContainer.scale.y = this._openness / 255;
        this._windowSpriteContainer.y = this.height / 2 * (1 - this._openness / 255);
      }
    }
    /**
     * Updates the window for each frame.
     *
     * @method update
     */
    update() {
      if (this.active) {
        this._animationCount++;
      }
      this.children.forEach((child) => {
        if (child.update) {
          child.update();
        }
      });
    }
    /**
     * Sets the x, y, width, and height all at once.
     *
     * @method move
     * @param {Number} x The x coordinate of the window
     * @param {Number} y The y coordinate of the window
     * @param {Number} width The width of the window
     * @param {Number} height The height of the window
     */
    move(x, y, width, height) {
      this.x = Math.floor(x || 0);
      this.y = Math.floor(y || 0);
      if (this._width !== width || this._height !== height) {
        this._width = Math.floor(width || 0);
        this._height = Math.floor(height || 0);
        this._refreshAllParts();
      }
    }
    /**
     * Returns true if the window is completely open (openness == 255).
     *
     * @method isOpen
     */
    isOpen() {
      return this._openness >= 255;
    }
    /**
     * Returns true if the window is completely closed (openness == 0).
     *
     * @method isClosed
     */
    isClosed() {
      return this._openness <= 0;
    }
    /**
     * Sets the position of the command cursor.
     *
     * @method setCursorRect
     * @param {Number} x The x coordinate of the cursor
     * @param {Number} y The y coordinate of the cursor
     * @param {Number} width The width of the cursor
     * @param {Number} height The height of the cursor
     */
    setCursorRect(x, y, width, height) {
      const cx = Math.floor(x || 0);
      const cy = Math.floor(y || 0);
      const cw = Math.floor(width || 0);
      const ch = Math.floor(height || 0);
      const rect = this._cursorRect;
      if (rect.x !== cx || rect.y !== cy || rect.width !== cw || rect.height !== ch) {
        this._cursorRect.x = cx;
        this._cursorRect.y = cy;
        this._cursorRect.width = cw;
        this._cursorRect.height = ch;
        this._refreshCursor();
      }
    }
    /**
     * Changes the color of the background.
     *
     * @method setTone
     * @param {Number} r The red value in the range (-255, 255)
     * @param {Number} g The green value in the range (-255, 255)
     * @param {Number} b The blue value in the range (-255, 255)
     */
    setTone(r, g, b2) {
      const tone = this._colorTone;
      r = r / 255;
      g = g / 255;
      b2 = b2 / 255;
      if (r < 0)
        r = 0;
      if (g < 0)
        g = 0;
      if (b2 < 0)
        b2 = 0;
      if (r !== tone[0] || g !== tone[1] || b2 !== tone[2]) {
        this._colorTone = [r, g, b2];
        this._refreshBack();
      }
    }
    /**
     * Adds a child between the background and contents.
     *
     * @method addChildToBack
     * @param {Object} child The child to add
     * @return {Object} The child that was added
     */
    addChildToBack(child) {
      const containerIndex = this.children.indexOf(this._windowSpriteContainer);
      return this.addChildAt(child, containerIndex + 1);
    }
    /**
     * @method updateTransform
     * @private
     */
    updateTransform() {
      this._updateCursor();
      this._updateArrows();
      this._updatePauseSign();
      this._updateContents();
      super.updateTransform();
    }
    /**
     * @method _createAllParts
     * @private
     */
    _createAllParts() {
      this._windowSpriteContainer = new Container();
      this._windowBackSprite = new Bitmap_default();
      this._windowCursorSprite = new Bitmap_default();
      this._windowFrameSprite = new Container();
      this._windowContentsSprite = new Sprite_default();
      this._downArrowSprite = new Sprite_default();
      this._upArrowSprite = new Sprite_default();
      this._windowPauseSignSprite = new Sprite_default();
      this._windowBackSprite.alpha = 192 / 255;
      this.addChild(this._windowSpriteContainer);
      this._windowSpriteContainer.addChild(this._windowBackSprite);
      this._windowSpriteContainer.addChild(this._windowFrameSprite);
      this.addChild(this._windowCursorSprite);
      this.addChild(this._windowContentsSprite);
      this.addChild(this._downArrowSprite);
      this.addChild(this._upArrowSprite);
      this.addChild(this._windowPauseSignSprite);
    }
    /**
     * @method _onWindowskinLoad
     * @private
     */
    _onWindowskinLoad() {
      this._refreshAllParts();
    }
    /**
     * @method _refreshAllParts
     * @private
     */
    _refreshAllParts() {
      this._refreshBack();
      this._refreshFrame();
      this._refreshCursor();
      this._refreshContents();
      this._refreshArrows();
      this._refreshPauseSign();
    }
    /**
     * @method _refreshBack
     * @private
     */
    _refreshBack() {
      const m = this._margin;
      const w = this._width - m * 2;
      const h = this._height - m * 2;
      const tone = index.rgb2hex(this._colorTone);
      if (w > 0 && h > 0 && this._windowskin && !this._windowBackSprite._setupComplete) {
        const p = 96;
        this._windowBackSprite.blt(this._windowskin, 0, 0, p, p, 0, 0, w, h);
        this._windowBackSprite.addChild(
          this._windowBackSprite.createTilingSprite(
            this._windowskin.baseTexture,
            0,
            p,
            p,
            p,
            w,
            h
          )
        );
        this._windowBackSprite._setupComplete = true;
      }
      this._windowBackSprite.width = w;
      this._windowBackSprite.height = h;
      this._windowBackSprite.x = m;
      this._windowBackSprite.y = m;
      this._windowBackSprite.children.forEach((child) => {
        if (child) {
          child.width = w;
          child.height = h;
          child.tint = tone;
        }
      });
    }
    /**
     * @method _refreshFrame
     * @private
     */
    _refreshFrame() {
      const w = this._width;
      const h = this._height;
      const m = 24;
      if (w > 0 && h > 0 && this._windowskin && !this._windowFrameSprite._setupComplete) {
        let texture;
        const cachedFrame = WindowSkinCache_default.getItem(
          this._windowskin._url,
          "frame"
        );
        if (cachedFrame) {
          texture = cachedFrame;
        } else {
          const container = new Bitmap_default();
          const skin = this._windowskin;
          const p = 96;
          const q = 96;
          container.blt(skin, p + m, 0 + 0, p - m * 2, m, m, 0, w - m * 2, m);
          container.blt(
            skin,
            p + m,
            0 + q - m,
            p - m * 2,
            m,
            m,
            h - m,
            w - m * 2,
            m
          );
          container.blt(skin, p + 0, 0 + m, m, p - m * 2, 0, m, m, h - m * 2);
          container.blt(
            skin,
            p + q - m,
            0 + m,
            m,
            p - m * 2,
            w - m,
            m,
            m,
            h - m * 2
          );
          container.blt(skin, p + 0, 0 + 0, m, m, 0, 0, m, m);
          container.blt(skin, p + q - m, 0 + 0, m, m, w - m, 0, m, m);
          container.blt(skin, p + 0, 0 + q - m, m, m, 0, h - m, m, m);
          container.blt(skin, p + q - m, 0 + q - m, m, m, w - m, h - m, m, m);
          texture = Graphics_default._renderer.generateTexture(container);
          container.destroy({
            children: true,
            texture: true
          });
          WindowSkinCache_default.setItem(this._windowskin._url, texture, "frame");
        }
        this._windowFramePlane = new NineSlicePlane(texture, 12, 12, 12, 12);
        this._windowFrameSprite.addChild(this._windowFramePlane);
        this._windowFrameSprite._setupComplete = true;
      }
      if (this._windowFrameSprite._setupComplete) {
        this._windowFramePlane.width = w;
        this._windowFramePlane.height = h;
      }
    }
    /**
     * @method _refreshCursor
     * @private
     */
    _refreshCursor() {
      const pad = this._padding;
      const x = this._cursorRect.x + pad - this.origin.x;
      const y = this._cursorRect.y + pad - this.origin.y;
      const w = this._cursorRect.width;
      const h = this._cursorRect.height;
      if (w > 0 && h > 0 && this._windowskin && !this._windowCursorSprite._setupComplete) {
        const p = 96;
        const q = 48;
        this._windowCursorPlane = this._windowCursorSprite.create9Slice(
          this._windowskin.baseTexture,
          p,
          p,
          q,
          q,
          12,
          12,
          12,
          12
        );
        this._windowCursorSprite.addChild(this._windowCursorPlane);
        this._windowCursorSprite._setupComplete = true;
      }
      if (this._windowCursorPlane) {
        this._windowCursorPlane.x = x;
        this._windowCursorPlane.y = y;
        this._windowCursorPlane.width = w;
        this._windowCursorPlane.height = h;
      }
    }
    /**
     * @method _refreshContents
     * @private
     */
    _refreshContents() {
      this._windowContentsSprite.move(this.padding, this.padding);
      if (this._windowContentsSprite.children.length)
        this._windowContentsSprite.children[0].clear();
    }
    /**
     * @method _refreshArrows
     * @private
     */
    _refreshArrows() {
      const w = this._width;
      const h = this._height;
      const p = 24;
      const q = p / 2;
      const sx = 96 + p;
      const sy = 0 + p;
      this._downArrowSprite.bitmap = this._windowskin;
      this._downArrowSprite.anchor.x = 0.5;
      this._downArrowSprite.anchor.y = 0.5;
      this._downArrowSprite.setFrame(sx + q, sy + q + p, p, q);
      this._downArrowSprite.move(w / 2, h - q);
      this._upArrowSprite.bitmap = this._windowskin;
      this._upArrowSprite.anchor.x = 0.5;
      this._upArrowSprite.anchor.y = 0.5;
      this._upArrowSprite.setFrame(sx + q, sy, p, q);
      this._upArrowSprite.move(w / 2, q);
    }
    /**
     * @method _refreshPauseSign
     * @private
     */
    _refreshPauseSign() {
      const sx = 144;
      const sy = 96;
      const p = 24;
      this._windowPauseSignSprite.bitmap = this._windowskin;
      this._windowPauseSignSprite.anchor.x = 0.5;
      this._windowPauseSignSprite.anchor.y = 1;
      this._windowPauseSignSprite.move(this._width / 2, this._height);
      this._windowPauseSignSprite.setFrame(sx, sy, p, p);
      this._windowPauseSignSprite.alpha = 0;
    }
    /**
     * @method _updateCursor
     * @private
     */
    _updateCursor() {
      const blinkCount = this._animationCount % 40;
      let cursorOpacity = this.contentsOpacity;
      if (this.active) {
        if (blinkCount < 20) {
          cursorOpacity -= blinkCount * 8;
        } else {
          cursorOpacity -= (40 - blinkCount) * 8;
        }
      }
      this._windowCursorSprite.alpha = cursorOpacity / 255;
      this._windowCursorSprite.visible = this.isOpen();
    }
    /**
     * @method _updateContents
     * @private
     */
    _updateContents() {
      const w = this._width - this._padding * 2;
      const h = this._height - this._padding * 2;
      if (w > 0 && h > 0) {
        this._windowContentsSprite.setFrame(this.origin.x, this.origin.y, w, h);
        this._windowContentsSprite.visible = this.isOpen();
      } else {
        this._windowContentsSprite.visible = false;
      }
    }
    /**
     * @method _updateArrows
     * @private
     */
    _updateArrows() {
      this._downArrowSprite.visible = this.isOpen() && this.downArrowVisible;
      this._upArrowSprite.visible = this.isOpen() && this.upArrowVisible;
    }
    /**
     * @method _updatePauseSign
     * @private
     */
    _updatePauseSign() {
      const sprite = this._windowPauseSignSprite;
      const x = Math.floor(this._animationCount / 16) % 2;
      const y = Math.floor(this._animationCount / 16 / 2) % 2;
      const sx = 144;
      const sy = 96;
      const p = 24;
      if (!this.pause) {
        sprite.alpha = 0;
      } else if (sprite.alpha < 1) {
        sprite.alpha = Math.min(sprite.alpha + 0.1, 1);
      }
      sprite.setFrame(sx + x * p, sy + y * p, p, p);
      sprite.visible = this.isOpen();
    }
    // The important members from Pixi.js
    /**
     * The visibility of the window.
     *
     * @property visible
     * @type Boolean
     */
    /**
     * The x coordinate of the window.
     *
     * @property x
     * @type Number
     */
    /**
     * The y coordinate of the window.
     *
     * @property y
     * @type Number
     */
    /**
     * [read-only] The array of children of the window.
     *
     * @property children
     * @type Array
     */
    /**
     * [read-only] The object that contains the window.
     *
     * @property parent
     * @type Object
     */
    /**
     * Adds a child to the container.
     *
     * @method addChild
     * @param {Object} child The child to add
     * @return {Object} The child that was added
     */
    /**
     * Adds a child to the container at a specified index.
     *
     * @method addChildAt
     * @param {Object} child The child to add
     * @param {Number} index The index to place the child in
     * @return {Object} The child that was added
     */
    /**
     * Removes a child from the container.
     *
     * @method removeChild
     * @param {Object} child The child to remove
     * @return {Object} The child that was removed
     */
    /**
     * Removes a child from the specified index position.
     *
     * @method removeChildAt
     * @param {Number} index The index to get the child from
     * @return {Object} The child that was removed
     */
  };
  var Window_default = Window;

  // src-www/js/rpg_core/WindowLayer.js
  var WindowLayer = class extends Container {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      this._width = 0;
      this._height = 0;
    }
    // onRemoveAsAChild() {
    // 	this.removeChildren();
    // }
    /**
     * The width of the window layer in pixels.
     *
     * @property width
     * @type Number
     */
    get width() {
      return this._width;
    }
    set width(value3) {
      this._width = value3;
    }
    /**
     * The height of the window layer in pixels.
     *
     * @property height
     * @type Number
     */
    get height() {
      return this._height;
    }
    set height(value3) {
      this._height = value3;
    }
    /**
     * Sets the x, y, width, and height all at once.
     *
     * @method move
     * @param {Number} x The x coordinate of the window layer
     * @param {Number} y The y coordinate of the window layer
     * @param {Number} width The width of the window layer
     * @param {Number} height The height of the window layer
     */
    move(x, y, width, height) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
    }
    /**
     * Updates the window layer for each frame.
     *
     * @method update
     */
    update() {
      this.children.forEach((child) => {
        if (child.update) {
          child.update();
        }
      });
    }
  };
  var WindowLayer_default = WindowLayer;

  // src-www/js/rpg_core/ToneFilter.js
  var ToneFilter = class extends filters.ColorMatrixFilter {
    constructor() {
      super();
    }
    /**
     * Changes the hue.
     *
     * @method adjustHue
     * @param {Number} value The hue value in the range (-360, 360)
     */
    adjustHue(value3) {
      this.hue(value3, true);
    }
    /**
     * Changes the saturation.
     *
     * @method adjustSaturation
     * @param {Number} value The saturation value in the range (-255, 255)
     */
    adjustSaturation(value3) {
      value3 = (value3 || 0).clamp(-255, 255) / 255;
      this.saturate(value3, true);
    }
    /**
     * Changes the tone.
     *
     * @method adjustTone
     * @param {Number} r The red strength in the range (-255, 255)
     * @param {Number} g The green strength in the range (-255, 255)
     * @param {Number} b The blue strength in the range (-255, 255)
     */
    adjustTone(r, g, b2) {
      r = (r || 0).clamp(-255, 255) / 255;
      g = (g || 0).clamp(-255, 255) / 255;
      b2 = (b2 || 0).clamp(-255, 255) / 255;
      if (r !== 0 || g !== 0 || b2 !== 0) {
        const matrix = [
          1,
          0,
          0,
          r,
          0,
          0,
          1,
          0,
          g,
          0,
          0,
          0,
          1,
          b2,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, true);
      }
    }
  };
  var ToneFilter_default = ToneFilter;

  // src-www/js/rpg_core/ToneSprite.js
  var ToneSprite = class extends Container {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      this.clear();
    }
    /**
     * Clears the tone.
     *
     * @method reset
     */
    clear() {
      this._red = 0;
      this._green = 0;
      this._blue = 0;
      this._gray = 0;
    }
    /**
     * Sets the tone.
     *
     * @method setTone
     * @param {Number} r The red strength in the range (-255, 255)
     * @param {Number} g The green strength in the range (-255, 255)
     * @param {Number} b The blue strength in the range (-255, 255)
     * @param {Number} gray The grayscale level in the range (0, 255)
     */
    setTone(r, g, b2, gray2) {
      this._red = Math.round(r || 0).clamp(-255, 255);
      this._green = Math.round(g || 0).clamp(-255, 255);
      this._blue = Math.round(b2 || 0).clamp(-255, 255);
      this._gray = Math.round(gray2 || 0).clamp(0, 255);
    }
    /**
     * @method _renderCanvas
     * @param {Object} renderSession
     * @private
     */
    _renderCanvas(renderer) {
      if (this.visible) {
        const context2 = renderer.context;
        const t = this.worldTransform;
        const r = renderer.resolution;
        const width = Graphics_default.width;
        const height = Graphics_default.height;
        context2.save();
        context2.setTransform(t.a, t.b, t.c, t.d, t.tx * r, t.ty * r);
        if (Graphics_default.canUseSaturationBlend() && this._gray > 0) {
          context2.globalCompositeOperation = "saturation";
          context2.globalAlpha = this._gray / 255;
          context2.fillStyle = "#ffffff";
          context2.fillRect(0, 0, width, height);
        }
        context2.globalAlpha = 1;
        const r1 = Math.max(0, this._red);
        const g1 = Math.max(0, this._green);
        const b1 = Math.max(0, this._blue);
        if (r1 || g1 || b1) {
          context2.globalCompositeOperation = "lighter";
          context2.fillStyle = Utils_default.rgbToCssColor(r1, g1, b1);
          context2.fillRect(0, 0, width, height);
        }
        if (Graphics_default.canUseDifferenceBlend()) {
          const r2 = Math.max(0, -this._red);
          const g2 = Math.max(0, -this._green);
          const b2 = Math.max(0, -this._blue);
          if (r2 || g2 || b2) {
            context2.globalCompositeOperation = "difference";
            context2.fillStyle = "#ffffff";
            context2.fillRect(0, 0, width, height);
            context2.globalCompositeOperation = "lighter";
            context2.fillStyle = Utils_default.rgbToCssColor(r2, g2, b2);
            context2.fillRect(0, 0, width, height);
            context2.globalCompositeOperation = "difference";
            context2.fillStyle = "#ffffff";
            context2.fillRect(0, 0, width, height);
          }
        }
        context2.restore();
      }
    }
    /**
     * @method _render
     * @param {Object} renderSession
     * @private
     */
    _render(renderer) {
    }
  };
  var ToneSprite_default = ToneSprite;

  // src-www/js/rpg_core/Stage.js
  var Stage = class extends Container {
    constructor() {
      super();
      this.initialize();
    }
    initialize() {
      this.interactive = false;
    }
    /**
     * [read-only] The array of children of the stage.
     *
     * @property children
     * @type Array
     */
    /**
     * Adds a child to the container.
     *
     * @method addChild
     * @param {Object} child The child to add
     * @return {Object} The child that was added
     */
    /**
     * Adds a child to the container at a specified index.
     *
     * @method addChildAt
     * @param {Object} child The child to add
     * @param {Number} index The index to place the child in
     * @return {Object} The child that was added
     */
    /**
     * Removes a child from the container.
     *
     * @method removeChild
     * @param {Object} child The child to remove
     * @return {Object} The child that was removed
     */
    /**
     * Removes a child from the specified index position.
     *
     * @method removeChildAt
     * @param {Number} index The index to get the child from
     * @return {Object} The child that was removed
     */
  };
  var Stage_default = Stage;

  // src-www/js/rpg_core/JsonEx.js
  var JsonEx = class {
    constructor() {
      throw new Error("This is a static class");
    }
    /**
     * Converts an object to a JSON string with object information.
     *
     * @static
     * @method stringify
     * @param {Object} object The object to be converted
     * @return {String} The JSON string
     */
    static stringify(object) {
      const circular = [];
      JsonEx._id = 1;
      const json = JSON.stringify(this._encode(object, circular, 0));
      this._cleanMetadata(object);
      this._restoreCircularReference(circular);
      return json;
    }
    /**
     * Parses a JSON string and reconstructs the corresponding object.
     *
     * @static
     * @method parse
     * @param {String} json The JSON string
     * @return {Object} The reconstructed object
     */
    static parse(json) {
      const circular = [];
      const registry = {};
      const contents = this._decode(JSON.parse(json), circular, registry);
      this._cleanMetadata(contents);
      this._linkCircularReference(contents, circular, registry);
      return contents;
    }
    /**
     * Makes a deep copy of the specified object.
     *
     * @static
     * @method makeDeepCopy
     * @param {Object} object The object to be copied
     * @return {Object} The copied object
     */
    static makeDeepCopy(object) {
      return this.parse(this.stringify(object));
    }
    /**
     * @static
     * @method _encode
     * @param {Object} value
     * @param {Array} circular
     * @param {Number} depth
     * @return {Object}
     * @private
     */
    static _encode(value3, circular, depth = 0) {
      if (++depth >= this.maxDepth) {
        throw new Error("Object too deep");
      }
      const type = Object.prototype.toString.call(value3);
      if (type === "[object Object]" || type === "[object Array]") {
        value3["@c"] = JsonEx._generateId();
        const constructorName = this._getConstructorName(value3);
        if (constructorName !== "Object" && constructorName !== "Array") {
          value3["@"] = constructorName;
        }
        for (let key in value3) {
          if ((!value3.hasOwnProperty || value3.hasOwnProperty(key)) && !key.match(/^@./)) {
            if (value3[key] && typeof value3[key] === "object") {
              if (value3[key]["@c"]) {
                circular.push([key, value3, value3[key]]);
                value3[key] = {
                  "@r": value3[key]["@c"]
                };
              } else {
                value3[key] = this._encode(value3[key], circular, depth + 1);
                if (value3[key] instanceof Array) {
                  circular.push([key, value3, value3[key]]);
                  value3[key] = {
                    "@c": value3[key]["@c"],
                    "@a": value3[key]
                  };
                }
              }
            } else {
              value3[key] = this._encode(value3[key], circular, depth + 1);
            }
          }
        }
      }
      depth--;
      return value3;
    }
    /**
     * @static
     * @method _decode
     * @param {Object} value
     * @param {Array} circular
     * @param {Object} registry
     * @return {Object}
     * @private
     */
    static _decode(value3, circular, registry) {
      const type = Object.prototype.toString.call(value3);
      if (type === "[object Object]" || type === "[object Array]") {
        registry[value3["@c"]] = value3;
        if (value3["@"] === null) {
          value3 = this._resetPrototype(value3, null);
        } else if (value3["@"]) {
          const constructor = self[value3["@"]];
          if (constructor) {
            value3 = this._resetPrototype(value3, constructor.prototype);
          }
        }
        for (let key in value3) {
          if (!value3.hasOwnProperty || value3.hasOwnProperty(key)) {
            if (value3[key] && value3[key]["@a"]) {
              const body = value3[key]["@a"];
              body["@c"] = value3[key]["@c"];
              value3[key] = body;
            }
            if (value3[key] && value3[key]["@r"]) {
              circular.push([key, value3, value3[key]["@r"]]);
            }
            value3[key] = this._decode(value3[key], circular, registry);
          }
        }
      }
      return value3;
    }
    static _generateId() {
      return JsonEx._id++;
    }
    static _restoreCircularReference(circulars) {
      circulars.forEach((circular) => {
        const key = circular[0];
        const value3 = circular[1];
        const content = circular[2];
        value3[key] = content;
      });
    }
    static _linkCircularReference(contents, circulars, registry) {
      circulars.forEach((circular) => {
        const key = circular[0];
        const value3 = circular[1];
        const id = circular[2];
        value3[key] = registry[id];
      });
    }
    static _cleanMetadata(object) {
      if (!object)
        return;
      delete object["@"];
      delete object["@c"];
      if (typeof object === "object") {
        Object.keys(object).forEach((key) => {
          const value3 = object[key];
          if (typeof value3 === "object") {
            JsonEx._cleanMetadata(value3);
          }
        });
      }
    }
    /**
     * @static
     * @method _getConstructorName
     * @param {Object} value
     * @return {String}
     * @private
     */
    static _getConstructorName({ constructor }) {
      if (!constructor) {
        return null;
      }
      let name = constructor.name;
      if (name === void 0) {
        const func = /^\s*function\s*([A-Za-z0-9_$]*)/;
        name = func.exec(constructor)[1];
      }
      return name;
    }
    /**
     * @static
     * @method _resetPrototype
     * @param {Object} value
     * @param {Object} prototype
     * @return {Object}
     * @private
     */
    static _resetPrototype(value3, prototype) {
      if (Object.setPrototypeOf !== void 0 && typeof prototype == "object") {
        Object.setPrototypeOf(value3, prototype);
      } else if ("__proto__" in value3) {
        value3.__proto__ = prototype;
      } else {
        const newValue = Object.create(prototype);
        for (let key in value3) {
          if (value3.hasOwnProperty(key)) {
            newValue[key] = value3[key];
          }
        }
        value3 = newValue;
      }
      return value3;
    }
  };
  JsonEx.maxDepth = 100;
  JsonEx._id = 1;
  var JsonEx_default = JsonEx;

  // src-www/js/rpg_core/WindowShim.js
  var WindowShim = class {
    constructor() {
      throw new Error("This is a static class");
    }
    static addEventListener(type, func) {
      this._eventStack.push({
        type,
        func
      });
    }
    static triggerEvent(payload) {
      this._eventStack.forEach((event) => {
        if (event.type === payload.type) {
          event.func(payload);
        }
      });
    }
    static close() {
      self.postMessage({
        type: "close",
        data: {}
      });
    }
  };
  WindowShim._eventStack = [];
  WindowShim.devicePixelRatio = 1;
  WindowShim.innerWidth = 0;
  WindowShim.innerHeight = 0;
  WindowShim.cordova = false;
  WindowShim.navigatorStandalone = false;
  WindowShim.__TAURI__ = false;
  var WindowShim_default = WindowShim;

  // src-www/js/rpg_core/DocumentShim.js
  var DocumentShim = class {
    constructor() {
      throw new Error("This is a static class");
    }
    static addEventListener(type, func) {
      this._eventStack.push({
        type,
        func
      });
    }
    static triggerEvent(payload) {
      this._eventStack.forEach((event) => {
        if (event.type === payload.type) {
          event.func(payload);
        }
      });
    }
    static createElement(element, options) {
      console.log("Attempted document.createElement on worker thread.");
    }
    static getElementsByTagName(elements) {
      console.log("Attempted document.getElementsByTagName on worker thread.");
      return [];
    }
  };
  DocumentShim._eventStack = [];
  DocumentShim.body = {
    appendChild: () => {
      console.log("Attempted document.body.appendChild on worker thread.");
    }
  };
  var DocumentShim_default = DocumentShim;

  // src-www/js/rpg_managers/StorageManagerShim.js
  var StorageManagerShim = class {
    constructor() {
      throw new Error("This is a static class");
    }
    static _makeRequestData(savefileId, data) {
      return {
        id: savefileId,
        webKey: DataManager._globalId,
        data: data || null
      };
    }
    static async save(savefileId, json) {
      if (Utils_default.isWorker()) {
      } else {
        const transfer = await Data_Thread.makeSave(
          "save",
          this._makeRequestData(savefileId, json)
        );
        return transfer.result;
      }
    }
    static async load(savefileId) {
      if (Utils_default.isWorker()) {
      } else {
        const transfer = await Data_Thread.loadSave(
          "load",
          this._makeRequestData(savefileId)
        );
        return transfer.result;
      }
    }
    static async exists(savefileId) {
      if (Utils_default.isWorker()) {
      } else {
        const transfer = await Data_Thread.checkSaveExists(
          "exists",
          this._makeRequestData(savefileId)
        );
        return transfer.result;
      }
    }
    static async remove(savefileId) {
      if (Utils_default.isWorker()) {
      } else {
      }
    }
    static async backup(savefileId) {
      if (Utils_default.isWorker()) {
      } else {
        const transfer = await Data_Thread.backupSave(
          "backup",
          this._makeRequestData(savefileId)
        );
        return transfer.result;
      }
    }
    static cleanBackup(savefileId) {
      if (Utils_default.isWorker()) {
      } else {
      }
    }
    static restoreBackup(savefileId) {
      if (Utils_default.isWorker()) {
      } else {
      }
    }
    static isLocalMode() {
      return false;
    }
    static backupExists(savefileId) {
    }
    static saveToLocalFile(savefileId, json) {
    }
    static loadFromLocalFile(savefileId) {
    }
    static loadFromLocalBackupFile(savefileId) {
    }
    static localFileBackupExists(savefileId) {
    }
    static localFileExists(savefileId) {
    }
    static removeLocalFile(savefileId) {
    }
    static saveToWebStorage(savefileId, json) {
    }
    static loadFromWebStorage(savefileId) {
    }
    static loadFromWebStorageBackup(savefileId) {
    }
    static webStorageBackupExists(savefileId) {
    }
    static webStorageExists(savefileId) {
    }
    static removeWebStorage(savefileId) {
    }
    static localFileDirectoryPath() {
    }
    static localFilePath(savefileId) {
    }
    static canMakeWwwSaveDirectory() {
    }
    static webStorageKey(savefileId) {
    }
  };
  var StorageManagerShim_default = StorageManagerShim;

  // src-www/js/rpg_managers/TextManager.js
  var TextManager = class {
    constructor() {
      throw new Error("This is a static class");
    }
    static basic(basicId) {
      return self.$dataSystem.terms.basic[basicId] || "";
    }
    static param(paramId) {
      return self.$dataSystem.terms.params[paramId] || "";
    }
    static command(commandId) {
      return self.$dataSystem.terms.commands[commandId] || "";
    }
    static message(messageId) {
      return self.$dataSystem.terms.messages[messageId] || "";
    }
    static getter(method, param) {
      return {
        get() {
          return this[method](param);
        },
        configurable: true
      };
    }
  };
  Object.defineProperty(TextManager, "currencyUnit", {
    get() {
      return self.$dataSystem.currencyUnit;
    },
    configurable: true
  });
  Object.defineProperties(TextManager, {
    level: TextManager.getter("basic", 0),
    levelA: TextManager.getter("basic", 1),
    hp: TextManager.getter("basic", 2),
    hpA: TextManager.getter("basic", 3),
    mp: TextManager.getter("basic", 4),
    mpA: TextManager.getter("basic", 5),
    tp: TextManager.getter("basic", 6),
    tpA: TextManager.getter("basic", 7),
    exp: TextManager.getter("basic", 8),
    expA: TextManager.getter("basic", 9),
    fight: TextManager.getter("command", 0),
    escape: TextManager.getter("command", 1),
    attack: TextManager.getter("command", 2),
    guard: TextManager.getter("command", 3),
    item: TextManager.getter("command", 4),
    skill: TextManager.getter("command", 5),
    equip: TextManager.getter("command", 6),
    status: TextManager.getter("command", 7),
    formation: TextManager.getter("command", 8),
    save: TextManager.getter("command", 9),
    gameEnd: TextManager.getter("command", 10),
    options: TextManager.getter("command", 11),
    weapon: TextManager.getter("command", 12),
    armor: TextManager.getter("command", 13),
    keyItem: TextManager.getter("command", 14),
    equip2: TextManager.getter("command", 15),
    optimize: TextManager.getter("command", 16),
    clear: TextManager.getter("command", 17),
    newGame: TextManager.getter("command", 18),
    continue_: TextManager.getter("command", 19),
    toTitle: TextManager.getter("command", 21),
    cancel: TextManager.getter("command", 22),
    buy: TextManager.getter("command", 24),
    sell: TextManager.getter("command", 25),
    alwaysDash: TextManager.getter("message", "alwaysDash"),
    commandRemember: TextManager.getter("message", "commandRemember"),
    bgmVolume: TextManager.getter("message", "bgmVolume"),
    bgsVolume: TextManager.getter("message", "bgsVolume"),
    meVolume: TextManager.getter("message", "meVolume"),
    seVolume: TextManager.getter("message", "seVolume"),
    possession: TextManager.getter("message", "possession"),
    expTotal: TextManager.getter("message", "expTotal"),
    expNext: TextManager.getter("message", "expNext"),
    saveMessage: TextManager.getter("message", "saveMessage"),
    loadMessage: TextManager.getter("message", "loadMessage"),
    file: TextManager.getter("message", "file"),
    partyName: TextManager.getter("message", "partyName"),
    emerge: TextManager.getter("message", "emerge"),
    preemptive: TextManager.getter("message", "preemptive"),
    surprise: TextManager.getter("message", "surprise"),
    escapeStart: TextManager.getter("message", "escapeStart"),
    escapeFailure: TextManager.getter("message", "escapeFailure"),
    victory: TextManager.getter("message", "victory"),
    defeat: TextManager.getter("message", "defeat"),
    obtainExp: TextManager.getter("message", "obtainExp"),
    obtainGold: TextManager.getter("message", "obtainGold"),
    obtainItem: TextManager.getter("message", "obtainItem"),
    levelUp: TextManager.getter("message", "levelUp"),
    obtainSkill: TextManager.getter("message", "obtainSkill"),
    useItem: TextManager.getter("message", "useItem"),
    criticalToEnemy: TextManager.getter("message", "criticalToEnemy"),
    criticalToActor: TextManager.getter("message", "criticalToActor"),
    actorDamage: TextManager.getter("message", "actorDamage"),
    actorRecovery: TextManager.getter("message", "actorRecovery"),
    actorGain: TextManager.getter("message", "actorGain"),
    actorLoss: TextManager.getter("message", "actorLoss"),
    actorDrain: TextManager.getter("message", "actorDrain"),
    actorNoDamage: TextManager.getter("message", "actorNoDamage"),
    actorNoHit: TextManager.getter("message", "actorNoHit"),
    enemyDamage: TextManager.getter("message", "enemyDamage"),
    enemyRecovery: TextManager.getter("message", "enemyRecovery"),
    enemyGain: TextManager.getter("message", "enemyGain"),
    enemyLoss: TextManager.getter("message", "enemyLoss"),
    enemyDrain: TextManager.getter("message", "enemyDrain"),
    enemyNoDamage: TextManager.getter("message", "enemyNoDamage"),
    enemyNoHit: TextManager.getter("message", "enemyNoHit"),
    evasion: TextManager.getter("message", "evasion"),
    magicEvasion: TextManager.getter("message", "magicEvasion"),
    magicReflection: TextManager.getter("message", "magicReflection"),
    counterAttack: TextManager.getter("message", "counterAttack"),
    substitute: TextManager.getter("message", "substitute"),
    buffAdd: TextManager.getter("message", "buffAdd"),
    debuffAdd: TextManager.getter("message", "debuffAdd"),
    buffRemove: TextManager.getter("message", "buffRemove"),
    actionFailure: TextManager.getter("message", "actionFailure")
  });
  var TextManager_default = TextManager;

  // src-www/js/rpg_managers/SoundManager.js
  var SoundManager = class {
    constructor() {
      throw new Error("This is a static class");
    }
    static preloadImportantSounds() {
      this.loadSystemSound(0);
      this.loadSystemSound(1);
      this.loadSystemSound(2);
      this.loadSystemSound(3);
    }
    static playCursor() {
      this.playSystemSound(0);
    }
    static playOk() {
      this.playSystemSound(1);
    }
    static playCancel() {
      this.playSystemSound(2);
    }
    static playBuzzer() {
      this.playSystemSound(3);
    }
    static playEquip() {
      this.playSystemSound(4);
    }
    static playSave() {
      this.playSystemSound(5);
    }
    static playLoad() {
      this.playSystemSound(6);
    }
    static playBattleStart() {
      this.playSystemSound(7);
    }
    static playEscape() {
      this.playSystemSound(8);
    }
    static playEnemyAttack() {
      this.playSystemSound(9);
    }
    static playEnemyDamage() {
      this.playSystemSound(10);
    }
    static playEnemyCollapse() {
      this.playSystemSound(11);
    }
    static playBossCollapse1() {
      this.playSystemSound(12);
    }
    static playBossCollapse2() {
      this.playSystemSound(13);
    }
    static playActorDamage() {
      this.playSystemSound(14);
    }
    static playActorCollapse() {
      this.playSystemSound(15);
    }
    static playRecovery() {
      this.playSystemSound(16);
    }
    static playMiss() {
      this.playSystemSound(17);
    }
    static playEvasion() {
      this.playSystemSound(18);
    }
    static playMagicEvasion() {
      this.playSystemSound(19);
    }
    static playReflection() {
      this.playSystemSound(20);
    }
    static playShop() {
      this.playSystemSound(21);
    }
    static playUseItem() {
      this.playSystemSound(22);
    }
    static playUseSkill() {
      this.playSystemSound(23);
    }
    static loadSystemSound(n) {
      if (self.$dataSystem) {
        AudioManager_default.loadStaticSe(self.$dataSystem.sounds[n]);
      }
    }
    static playSystemSound(n) {
      if (self.$dataSystem) {
        AudioManager_default.playStaticSe(self.$dataSystem.sounds[n]);
      }
    }
  };
  var SoundManager_default = SoundManager;

  // src-www/js/rpg_objects/Game_Item.js
  var Game_Item = class {
    constructor(...args) {
      this.initialize(...args);
    }
    initialize(item2) {
      this._dataClass = "";
      this._itemId = 0;
      if (item2) {
        this.setObject(item2);
      }
    }
    isSkill() {
      return this._dataClass === "skill";
    }
    isItem() {
      return this._dataClass === "item";
    }
    isUsableItem() {
      return this.isSkill() || this.isItem();
    }
    isWeapon() {
      return this._dataClass === "weapon";
    }
    isArmor() {
      return this._dataClass === "armor";
    }
    isEquipItem() {
      return this.isWeapon() || this.isArmor();
    }
    isNull() {
      return this._dataClass === "";
    }
    itemId() {
      return this._itemId;
    }
    object() {
      if (this.isSkill()) {
        return self.$dataSkills[this._itemId];
      } else if (this.isItem()) {
        return self.$dataItems[this._itemId];
      } else if (this.isWeapon()) {
        return self.$dataWeapons[this._itemId];
      } else if (this.isArmor()) {
        return self.$dataArmors[this._itemId];
      } else {
        return null;
      }
    }
    setObject(item2) {
      if (DataManager2.isSkill(item2)) {
        this._dataClass = "skill";
      } else if (DataManager2.isItem(item2)) {
        this._dataClass = "item";
      } else if (DataManager2.isWeapon(item2)) {
        this._dataClass = "weapon";
      } else if (DataManager2.isArmor(item2)) {
        this._dataClass = "armor";
      } else {
        this._dataClass = "";
      }
      this._itemId = item2 ? item2.id : 0;
    }
    setEquip(isWeapon, itemId) {
      this._dataClass = isWeapon ? "weapon" : "armor";
      this._itemId = itemId;
    }
  };
  var Game_Item_default = Game_Item;

  // src-www/js/rpg_objects/Game_Action.js
  var _Game_Action = class {
    constructor(...args) {
      this.initialize(...args);
    }
    initialize(subject, forcing) {
      this._subjectActorId = 0;
      this._subjectEnemyIndex = -1;
      this._forcing = forcing || false;
      this.setSubject(subject);
      this.clear();
    }
    clear() {
      this._item = new Game_Item_default();
      this._targetIndex = -1;
    }
    setSubject(subject) {
      if (subject.isActor()) {
        this._subjectActorId = subject.actorId();
        this._subjectEnemyIndex = -1;
      } else {
        this._subjectEnemyIndex = subject.index();
        this._subjectActorId = 0;
      }
    }
    subject() {
      if (this._subjectActorId > 0) {
        return self.$gameActors.actor(this._subjectActorId);
      } else {
        return self.$gameTroop.members()[this._subjectEnemyIndex];
      }
    }
    friendsUnit() {
      return this.subject().friendsUnit();
    }
    opponentsUnit() {
      return this.subject().opponentsUnit();
    }
    setEnemyAction(action) {
      if (action) {
        this.setSkill(action.skillId);
      } else {
        this.clear();
      }
    }
    setAttack() {
      this.setSkill(this.subject().attackSkillId());
    }
    setGuard() {
      this.setSkill(this.subject().guardSkillId());
    }
    setSkill(skillId) {
      this._item.setObject(self.$dataSkills[skillId]);
    }
    setItem(itemId) {
      this._item.setObject(self.$dataItems[itemId]);
    }
    setItemObject(object) {
      this._item.setObject(object);
    }
    setTarget(targetIndex) {
      this._targetIndex = targetIndex;
    }
    item() {
      return this._item.object();
    }
    isSkill() {
      return this._item.isSkill();
    }
    isItem() {
      return this._item.isItem();
    }
    numRepeats() {
      let repeats = this.item().repeats;
      if (this.isAttack()) {
        repeats += this.subject().attackTimesAdd();
      }
      return Math.floor(repeats);
    }
    checkItemScope(list) {
      return list.contains(this.item().scope);
    }
    isForOpponent() {
      return this.checkItemScope([1, 2, 3, 4, 5, 6]);
    }
    isForFriend() {
      return this.checkItemScope([7, 8, 9, 10, 11]);
    }
    isForDeadFriend() {
      return this.checkItemScope([9, 10]);
    }
    isForUser() {
      return this.checkItemScope([11]);
    }
    isForOne() {
      return this.checkItemScope([1, 3, 7, 9, 11]);
    }
    isForRandom() {
      return this.checkItemScope([3, 4, 5, 6]);
    }
    isForAll() {
      return this.checkItemScope([2, 8, 10]);
    }
    needsSelection() {
      return this.checkItemScope([1, 7, 9]);
    }
    numTargets() {
      return this.isForRandom() ? this.item().scope - 2 : 0;
    }
    checkDamageType(list) {
      return list.contains(this.item().damage.type);
    }
    isHpEffect() {
      return this.checkDamageType([1, 3, 5]);
    }
    isMpEffect() {
      return this.checkDamageType([2, 4, 6]);
    }
    isDamage() {
      return this.checkDamageType([1, 2]);
    }
    isRecover() {
      return this.checkDamageType([3, 4]);
    }
    isDrain() {
      return this.checkDamageType([5, 6]);
    }
    isHpRecover() {
      return this.checkDamageType([3]);
    }
    isMpRecover() {
      return this.checkDamageType([4]);
    }
    isCertainHit() {
      return this.item().hitType === _Game_Action.HITTYPE_CERTAIN;
    }
    isPhysical() {
      return this.item().hitType === _Game_Action.HITTYPE_PHYSICAL;
    }
    isMagical() {
      return this.item().hitType === _Game_Action.HITTYPE_MAGICAL;
    }
    isAttack() {
      return this.item() === self.$dataSkills[this.subject().attackSkillId()];
    }
    isGuard() {
      return this.item() === self.$dataSkills[this.subject().guardSkillId()];
    }
    isMagicSkill() {
      if (this.isSkill()) {
        return self.$dataSystem.magicSkills.contains(this.item().stypeId);
      } else {
        return false;
      }
    }
    decideRandomTarget() {
      let target2;
      if (this.isForDeadFriend()) {
        target2 = this.friendsUnit().randomDeadTarget();
      } else if (this.isForFriend()) {
        target2 = this.friendsUnit().randomTarget();
      } else {
        target2 = this.opponentsUnit().randomTarget();
      }
      if (target2) {
        this._targetIndex = target2.index();
      } else {
        this.clear();
      }
    }
    setConfusion() {
      this.setAttack();
    }
    prepare() {
      if (this.subject().isConfused() && !this._forcing) {
        this.setConfusion();
      }
    }
    isValid() {
      return this._forcing && this.item() || this.subject().canUse(this.item());
    }
    speed() {
      const agi = this.subject().agi;
      let speed = agi + Math.randomInt(Math.floor(5 + agi / 4));
      if (this.item()) {
        speed += this.item().speed;
      }
      if (this.isAttack()) {
        speed += this.subject().attackSpeed();
      }
      return speed;
    }
    makeTargets() {
      let targets = [];
      if (!this._forcing && this.subject().isConfused()) {
        targets = [this.confusionTarget()];
      } else if (this.isForOpponent()) {
        targets = this.targetsForOpponents();
      } else if (this.isForFriend()) {
        targets = this.targetsForFriends();
      }
      return this.repeatTargets(targets);
    }
    repeatTargets(targets) {
      const repeatedTargets = [];
      const repeats = this.numRepeats();
      for (const target2 of targets) {
        if (target2) {
          for (let j = 0; j < repeats; j++) {
            repeatedTargets.push(target2);
          }
        }
      }
      return repeatedTargets;
    }
    confusionTarget() {
      switch (this.subject().confusionLevel()) {
        case 1:
          return this.opponentsUnit().randomTarget();
        case 2:
          if (Math.randomInt(2) === 0) {
            return this.opponentsUnit().randomTarget();
          }
          return this.friendsUnit().randomTarget();
        default:
          return this.friendsUnit().randomTarget();
      }
    }
    targetsForOpponents() {
      let targets = [];
      const unit = this.opponentsUnit();
      if (this.isForRandom()) {
        for (let i = 0; i < this.numTargets(); i++) {
          targets.push(unit.randomTarget());
        }
      } else if (this.isForOne()) {
        if (this._targetIndex < 0) {
          targets.push(unit.randomTarget());
        } else {
          targets.push(unit.smoothTarget(this._targetIndex));
        }
      } else {
        targets = unit.aliveMembers();
      }
      return targets;
    }
    targetsForFriends() {
      let targets = [];
      const unit = this.friendsUnit();
      if (this.isForUser()) {
        return [this.subject()];
      } else if (this.isForDeadFriend()) {
        if (this.isForOne()) {
          targets.push(unit.smoothDeadTarget(this._targetIndex));
        } else {
          targets = unit.deadMembers();
        }
      } else if (this.isForOne()) {
        if (this._targetIndex < 0) {
          targets.push(unit.randomTarget());
        } else {
          targets.push(unit.smoothTarget(this._targetIndex));
        }
      } else {
        targets = unit.aliveMembers();
      }
      return targets;
    }
    evaluate() {
      let value3 = 0;
      this.itemTargetCandidates().forEach(function(target2) {
        const targetValue = this.evaluateWithTarget(target2);
        if (this.isForAll()) {
          value3 += targetValue;
        } else if (targetValue > value3) {
          value3 = targetValue;
          this._targetIndex = target2.index();
        }
      }, this);
      value3 *= this.numRepeats();
      if (value3 > 0) {
        value3 += Math.random();
      }
      return value3;
    }
    itemTargetCandidates() {
      if (!this.isValid()) {
        return [];
      } else if (this.isForOpponent()) {
        return this.opponentsUnit().aliveMembers();
      } else if (this.isForUser()) {
        return [this.subject()];
      } else if (this.isForDeadFriend()) {
        return this.friendsUnit().deadMembers();
      } else {
        return this.friendsUnit().aliveMembers();
      }
    }
    evaluateWithTarget(target2) {
      if (this.isHpEffect()) {
        const value3 = this.makeDamageValue(target2, false);
        if (this.isForOpponent()) {
          return value3 / Math.max(target2.hp, 1);
        } else {
          const recovery = Math.min(-value3, target2.mhp - target2.hp);
          return recovery / target2.mhp;
        }
      }
    }
    testApply(target2) {
      return this.isForDeadFriend() === target2.isDead() && (self.$gameParty.inBattle() || this.isForOpponent() || this.isHpRecover() && target2.hp < target2.mhp || this.isMpRecover() && target2.mp < target2.mmp || this.hasItemAnyValidEffects(target2));
    }
    hasItemAnyValidEffects(target2) {
      return this.item().effects.some(function(effect) {
        return this.testItemEffect(target2, effect);
      }, this);
    }
    testItemEffect(target2, { code, value1: value12, value2: value22, dataId }) {
      switch (code) {
        case _Game_Action.EFFECT_RECOVER_HP:
          return target2.hp < target2.mhp || value12 < 0 || value22 < 0;
        case _Game_Action.EFFECT_RECOVER_MP:
          return target2.mp < target2.mmp || value12 < 0 || value22 < 0;
        case _Game_Action.EFFECT_ADD_STATE:
          return !target2.isStateAffected(dataId);
        case _Game_Action.EFFECT_REMOVE_STATE:
          return target2.isStateAffected(dataId);
        case _Game_Action.EFFECT_ADD_BUFF:
          return !target2.isMaxBuffAffected(dataId);
        case _Game_Action.EFFECT_ADD_DEBUFF:
          return !target2.isMaxDebuffAffected(dataId);
        case _Game_Action.EFFECT_REMOVE_BUFF:
          return target2.isBuffAffected(dataId);
        case _Game_Action.EFFECT_REMOVE_DEBUFF:
          return target2.isDebuffAffected(dataId);
        case _Game_Action.EFFECT_LEARN_SKILL:
          return target2.isActor() && !target2.isLearnedSkill(dataId);
        default:
          return true;
      }
    }
    itemCnt(target2) {
      if (this.isPhysical() && target2.canMove()) {
        return target2.cnt;
      } else {
        return 0;
      }
    }
    itemMrf({ mrf }) {
      if (this.isMagical()) {
        return mrf;
      } else {
        return 0;
      }
    }
    itemHit(target2) {
      if (this.isPhysical()) {
        return this.item().successRate * 0.01 * this.subject().hit;
      } else {
        return this.item().successRate * 0.01;
      }
    }
    itemEva({ eva, mev }) {
      if (this.isPhysical()) {
        return eva;
      } else if (this.isMagical()) {
        return mev;
      } else {
        return 0;
      }
    }
    itemCri({ cev }) {
      return this.item().damage.critical ? this.subject().cri * (1 - cev) : 0;
    }
    apply(target2) {
      const result2 = target2.result();
      this.subject().clearResult();
      result2.clear();
      result2.used = this.testApply(target2);
      result2.missed = this.processItemHitFormula(result2, target2);
      result2.evaded = this.processItemEvaFormula(result2, target2);
      result2.physical = this.isPhysical();
      result2.drain = this.isDrain();
      if (result2.isHit()) {
        if (this.item().damage.type > 0) {
          result2.critical = this.processItemCriFormula(result2, target2);
          const value3 = this.makeDamageValue(target2, result2.critical);
          this.executeDamage(target2, value3);
          this.subject().onApplyDamage(this, target2, value3);
          target2.onReceiveDamage(this, this.subject(), value3);
          if (result2.critical) {
            this.subject().onApplyCritical(this, target2, value3);
            target2.onReceiveCritical(this, this.subject(), value3);
          }
        }
        this.item().effects.forEach(function(effect) {
          this.applyItemEffect(target2, effect);
        }, this);
        this.applyItemUserEffect(target2);
      } else {
        this.subject().onHitAction(this, target2);
        target2.onEvadeAction(this, this.subject());
      }
    }
    processItemHitFormula(result2, target2) {
      return result2.used && Math.random() >= this.itemHit(target2);
    }
    processItemEvaFormula(result2, target2) {
      return !result2.missed && Math.random() < this.itemEva(target2);
    }
    processItemCriFormula(result2, target2) {
      return Math.random() < this.itemCri(target2);
    }
    makeDamageValue(target2, critical) {
      const item2 = this.item();
      const baseValue = this.evalDamageFormula(target2);
      let value3 = this.processElementalDamage(item2, baseValue, target2, critical);
      if (this.isPhysical()) {
        value3 = this.processPhysicalDamage(item2, value3, target2, critical);
      }
      if (this.isMagical()) {
        value3 = this.processMagicalDamage(item2, value3, target2, critical);
      }
      if (baseValue < 0) {
        value3 = this.processRecoveryDamage(item2, value3, target2, critical);
      }
      if (critical) {
        value3 = this.processCriticalDamage(item2, value3, target2, critical);
      }
      value3 = this.processVarianceDamage(item2, value3, target2, critical);
      value3 = this.processGuardDamage(item2, value3, target2, critical);
      value3 = this.processDamageEnd(item2, value3, target2, critical);
      return value3;
    }
    processElementalDamage(item2, value3, target2, critical) {
      return value3 * this.calcElementRate(target2);
    }
    processPhysicalDamage(item2, value3, target2, critical) {
      return value3 *= target2.pdr;
    }
    processMagicalDamage(item2, value3, target2, critical) {
      return value3 *= target2.mdr;
    }
    processRecoveryDamage(item2, value3, target2, critical) {
      return value3 *= target2.rec;
    }
    processCriticalDamage(item2, value3, target2, critical) {
      return this.applyCritical(value3);
    }
    processVarianceDamage(item2, value3, target2, critical) {
      return this.applyVariance(value3, item2.damage.variance);
    }
    processGuardDamage(item2, value3, target2, critical) {
      return this.applyGuard(value3, target2);
    }
    processDamageEnd(item2, value3, target2, critical) {
      return Math.round(value3);
    }
    evalDamageFormula(target) {
      try {
        const item = this.item();
        const a = this.subject();
        const b = target;
        const v = self.$gameVariables._data;
        const sign = [3, 4].contains(item.damage.type) ? -1 : 1;
        let value = Math.max(eval(item.damage.formula), 0) * sign;
        if (isNaN(value))
          value = 0;
        return value;
      } catch (e) {
        return 0;
      }
    }
    calcElementRate(target2) {
      if (this.item().damage.elementId < 0) {
        return this.elementsMaxRate(target2, this.subject().attackElements());
      } else {
        return target2.elementRate(this.item().damage.elementId);
      }
    }
    elementsMaxRate(target2, elements) {
      if (elements.length > 0) {
        return Math.max.apply(
          null,
          elements.map((elementId) => target2.elementRate(elementId), this)
        );
      } else {
        return 1;
      }
    }
    applyCritical(damage) {
      return damage * 3;
    }
    applyVariance(damage, variance) {
      const amp = Math.floor(Math.max(Math.abs(damage) * variance / 100, 0));
      const v2 = Math.randomInt(amp + 1) + Math.randomInt(amp + 1) - amp;
      return damage >= 0 ? damage + v2 : damage - v2;
    }
    applyGuard(damage, target2) {
      return damage / (damage > 0 && target2.isGuard() ? 2 * target2.grd : 1);
    }
    executeDamage(target2, value3) {
      const result2 = target2.result();
      if (value3 === 0) {
        result2.critical = false;
      }
      if (this.isHpEffect()) {
        this.executeHpDamage(target2, value3);
      }
      if (this.isMpEffect()) {
        this.executeMpDamage(target2, value3);
      }
    }
    executeHpDamage(target2, value3) {
      if (this.isDrain()) {
        value3 = Math.min(target2.hp, value3);
      }
      this.makeSuccess(target2);
      target2.gainHp(-value3);
      if (value3 > 0) {
        target2.onDamage(value3);
      }
      this.gainDrainedHp(value3);
    }
    executeMpDamage(target2, value3) {
      if (!this.isMpRecover()) {
        value3 = Math.min(target2.mp, value3);
      }
      if (value3 !== 0) {
        this.makeSuccess(target2);
      }
      target2.gainMp(-value3);
      this.gainDrainedMp(value3);
    }
    gainDrainedHp(value3) {
      if (this.isDrain()) {
        let gainTarget = this.subject();
        if (this._reflectionTarget !== void 0) {
          gainTarget = this._reflectionTarget;
        }
        gainTarget.gainHp(value3);
      }
    }
    gainDrainedMp(value3) {
      if (this.isDrain()) {
        let gainTarget = this.subject();
        if (this._reflectionTarget !== void 0) {
          gainTarget = this._reflectionTarget;
        }
        gainTarget.gainMp(value3);
      }
    }
    applyItemEffect(target2, effect) {
      switch (effect.code) {
        case _Game_Action.EFFECT_RECOVER_HP:
          this.itemEffectRecoverHp(target2, effect);
          break;
        case _Game_Action.EFFECT_RECOVER_MP:
          this.itemEffectRecoverMp(target2, effect);
          break;
        case _Game_Action.EFFECT_GAIN_TP:
          this.itemEffectGainTp(target2, effect);
          break;
        case _Game_Action.EFFECT_ADD_STATE:
          this.itemEffectAddState(target2, effect);
          break;
        case _Game_Action.EFFECT_REMOVE_STATE:
          this.itemEffectRemoveState(target2, effect);
          break;
        case _Game_Action.EFFECT_ADD_BUFF:
          this.itemEffectAddBuff(target2, effect);
          break;
        case _Game_Action.EFFECT_ADD_DEBUFF:
          this.itemEffectAddDebuff(target2, effect);
          break;
        case _Game_Action.EFFECT_REMOVE_BUFF:
          this.itemEffectRemoveBuff(target2, effect);
          break;
        case _Game_Action.EFFECT_REMOVE_DEBUFF:
          this.itemEffectRemoveDebuff(target2, effect);
          break;
        case _Game_Action.EFFECT_SPECIAL:
          this.itemEffectSpecial(target2, effect);
          break;
        case _Game_Action.EFFECT_GROW:
          this.itemEffectGrow(target2, effect);
          break;
        case _Game_Action.EFFECT_LEARN_SKILL:
          this.itemEffectLearnSkill(target2, effect);
          break;
        case _Game_Action.EFFECT_COMMON_EVENT:
          this.itemEffectCommonEvent(target2, effect);
          break;
      }
    }
    itemEffectRecoverHp(target2, { value1: value12, value2: value22 }) {
      let value3 = (target2.mhp * value12 + value22) * target2.rec;
      if (this.isItem()) {
        value3 *= this.subject().pha;
      }
      value3 = Math.floor(value3);
      if (value3 !== 0) {
        target2.gainHp(value3);
        this.makeSuccess(target2);
      }
    }
    itemEffectRecoverMp(target2, { value1: value12, value2: value22 }) {
      let value3 = (target2.mmp * value12 + value22) * target2.rec;
      if (this.isItem()) {
        value3 *= this.subject().pha;
      }
      value3 = Math.floor(value3);
      if (value3 !== 0) {
        target2.gainMp(value3);
        this.makeSuccess(target2);
      }
    }
    itemEffectGainTp(target2, { value1: value12 }) {
      const value3 = Math.floor(value12);
      if (value3 !== 0) {
        target2.gainTp(value3);
        this.makeSuccess(target2);
      }
    }
    itemEffectAddState(target2, effect) {
      if (effect.dataId === 0) {
        this.itemEffectAddAttackState(target2, effect);
      } else {
        this.itemEffectAddNormalState(target2, effect);
      }
    }
    itemEffectAddAttackState(target2, { value1: value12 }) {
      this.subject().attackStates().forEach((stateId) => {
        let chance = value12;
        chance *= target2.stateRate(stateId);
        chance *= this.subject().attackStatesRate(stateId);
        chance *= this.lukEffectRate(target2);
        if (Math.random() < chance) {
          target2.addState(stateId, this.subject());
          this.makeSuccess(target2);
        }
      }, target2);
    }
    itemEffectAddNormalState(target2, { value1: value12, dataId }) {
      let chance = value12;
      if (!this.isCertainHit()) {
        chance *= target2.stateRate(dataId);
        chance *= this.lukEffectRate(target2);
      }
      if (Math.random() < chance) {
        target2.addState(dataId, this.subject());
        this.makeSuccess(target2);
      }
    }
    itemEffectRemoveState(target2, { value1: value12, dataId }) {
      const chance = value12;
      if (Math.random() < chance) {
        target2.removeState(dataId);
        this.makeSuccess(target2);
      }
    }
    itemEffectAddBuff(target2, { dataId, value1: value12 }) {
      target2.addBuff(dataId, value12);
      this.makeSuccess(target2);
    }
    itemEffectAddDebuff(target2, { dataId, value1: value12 }) {
      const chance = target2.debuffRate(dataId) * this.lukEffectRate(target2);
      if (Math.random() < chance) {
        target2.addDebuff(dataId, value12);
        this.makeSuccess(target2);
      }
    }
    itemEffectRemoveBuff(target2, { dataId }) {
      if (target2.isBuffAffected(dataId)) {
        target2.removeBuff(dataId);
        this.makeSuccess(target2);
      }
    }
    itemEffectRemoveDebuff(target2, { dataId }) {
      if (target2.isDebuffAffected(dataId)) {
        target2.removeBuff(dataId);
        this.makeSuccess(target2);
      }
    }
    itemEffectSpecial(target2, { dataId }) {
      if (dataId === _Game_Action.SPECIAL_EFFECT_ESCAPE) {
        target2.escape();
        this.makeSuccess(target2);
      }
    }
    itemEffectGrow(target2, { dataId, value1: value12 }) {
      target2.addParam(dataId, Math.floor(value12));
      this.makeSuccess(target2);
    }
    itemEffectLearnSkill(target2, { dataId }) {
      if (target2.isActor()) {
        target2.learnSkill(dataId);
        this.makeSuccess(target2);
      }
    }
    itemEffectCommonEvent(target2, effect) {
    }
    makeSuccess(target2) {
      target2.result().success = true;
    }
    applyItemUserEffect(target2) {
      const value3 = Math.floor(this.item().tpGain * this.subject().tcr);
      this.subject().gainSilentTp(value3);
    }
    lukEffectRate({ luk }) {
      return Math.max(1 + (this.subject().luk - luk) * 1e-3, 0);
    }
    applyGlobal() {
      this.item().effects.forEach(({ code, dataId }) => {
        if (code === _Game_Action.EFFECT_COMMON_EVENT) {
          self.$gameTemp.reserveCommonEvent(dataId);
        }
      }, this);
    }
  };
  _Game_Action.EFFECT_RECOVER_HP = 11;
  _Game_Action.EFFECT_RECOVER_MP = 12;
  _Game_Action.EFFECT_GAIN_TP = 13;
  _Game_Action.EFFECT_ADD_STATE = 21;
  _Game_Action.EFFECT_REMOVE_STATE = 22;
  _Game_Action.EFFECT_ADD_BUFF = 31;
  _Game_Action.EFFECT_ADD_DEBUFF = 32;
  _Game_Action.EFFECT_REMOVE_BUFF = 33;
  _Game_Action.EFFECT_REMOVE_DEBUFF = 34;
  _Game_Action.EFFECT_SPECIAL = 41;
  _Game_Action.EFFECT_GROW = 42;
  _Game_Action.EFFECT_LEARN_SKILL = 43;
  _Game_Action.EFFECT_COMMON_EVENT = 44;
  _Game_Action.SPECIAL_EFFECT_ESCAPE = 0;
  _Game_Action.HITTYPE_CERTAIN = 0;
  _Game_Action.HITTYPE_PHYSICAL = 1;
  _Game_Action.HITTYPE_MAGICAL = 2;
  var Game_Action_default = _Game_Action;

  // src-www/js/rpg_scenes/Scene_Base.js
  var Scene_Base = class extends Stage_default {
    constructor() {
      super();
      this.initialize();
    }
    /**
     * Create a instance of Scene_Base.
     *
     * @instance
     * @memberof Scene_Base
     */
    initialize() {
      super.initialize();
      this._active = false;
      this._fadeSign = 0;
      this._fadeDuration = 0;
      this._fadeSprite = null;
    }
    /**
     * Attach a reservation to the reserve queue.
     *
     * @method attachReservation
     * @instance
     * @memberof Scene_Base
     */
    attachReservation() {
      console.log("DEPRECATED: Scene_Base.attachReservation");
    }
    /**
     * Remove the reservation from the Reserve queue.
     *
     * @method detachReservation
     * @instance
     * @memberof Scene_Base
     */
    detachReservation() {
      console.log("DEPRECATED: Scene_Base.detachReservation");
    }
    /**
     * Create the components and add them to the rendering process.
     *
     * @method create
     * @instance
     * @memberof Scene_Base
     */
    create() {
    }
    /**
     * Returns whether the scene is active or not.
     *
     * @method isActive
     * @instance
     * @memberof Scene_Base
     * @return {Boolean} return true if the scene is active
     */
    isActive() {
      return this._active;
    }
    /**
     * Return whether the scene is ready to start or not.
     *
     * @method isReady
     * @instance
     * @memberof Scene_Base
     * @return {Boolean} Return true if the scene is ready to start
     */
    isReady() {
      return ImageManager.isReady();
    }
    /**
     * Start the scene processing.
     *
     * @method start
     * @instance
     * @memberof Scene_Base
     */
    start() {
      this._active = true;
    }
    /**
     * Update the scene processing each new frame.
     *
     * @method update
     * @instance
     * @memberof Scene_Base
     */
    update() {
      this.updateFade();
      this.updateChildren();
    }
    /**
     * Stop the scene processing.
     *
     * @method stop
     * @instance
     * @memberof Scene_Base
     */
    stop() {
      this._active = false;
    }
    /**
     * Return whether the scene is busy or not.
     *
     * @method isBusy
     * @instance
     * @memberof Scene_Base
     * @return {Boolean} Return true if the scene is currently busy
     */
    isBusy() {
      return this._fadeDuration > 0;
    }
    /**
     * Terminate the scene before switching to a another scene.
     *
     * @method terminate
     * @instance
     * @memberof Scene_Base
     */
    terminate() {
    }
    /**
     * Create the layer for the windows children
     * and add it to the rendering process.
     *
     * @method createWindowLayer
     * @instance
     * @memberof Scene_Base
     */
    createWindowLayer() {
      const width = Graphics_default.boxWidth;
      const height = Graphics_default.boxHeight;
      const x = (Graphics_default.width - width) / 2;
      const y = (Graphics_default.height - height) / 2;
      this._windowLayer = new WindowLayer_default();
      this._windowLayer.move(x, y, width, height);
      this.addChild(this._windowLayer);
    }
    /**
     * Add the children window to the windowLayer processing.
     *
     * @method addWindow
     * @instance
     * @memberof Scene_Base
     */
    addWindow(window2) {
      this._windowLayer.addChild(window2);
    }
    /**
     * Request a fadeIn screen process.
     *
     * @method startFadeIn
     * @param {Number} [duration=30] The time the process will take for fadeIn the screen
     * @param {Boolean} [white=false] If true the fadein will be process with a white color else it's will be black
     *
     * @instance
     * @memberof Scene_Base
     */
    startFadeIn(duration, white2) {
      this.createFadeSprite(white2);
      this._fadeSign = 1;
      this._fadeDuration = duration || 30;
      this._fadeSprite.opacity = 255;
    }
    /**
     * Request a fadeOut screen process.
     *
     * @method startFadeOut
     * @param {Number} [duration=30] The time the process will take for fadeOut the screen
     * @param {Boolean} [white=false] If true the fadeOut will be process with a white color else it's will be black
     *
     * @instance
     * @memberof Scene_Base
     */
    startFadeOut(duration, white2) {
      this.createFadeSprite(white2);
      this._fadeSign = -1;
      this._fadeDuration = duration || 30;
      this._fadeSprite.opacity = 0;
    }
    /**
     * Create a Screen sprite for the fadein and fadeOut purpose and
     * add it to the rendering process.
     *
     * @method createFadeSprite
     * @instance
     * @memberof Scene_Base
     */
    createFadeSprite(white2) {
      if (!this._fadeSprite) {
        this._fadeSprite = new ScreenSprite_default();
        this.addChild(this._fadeSprite);
      }
      if (white2) {
        this._fadeSprite.setWhite();
      } else {
        this._fadeSprite.setBlack();
      }
    }
    /**
     * Update the screen fade processing.
     *
     * @method updateFade
     * @instance
     * @memberof Scene_Base
     */
    updateFade() {
      if (this._fadeDuration > 0) {
        const d = this._fadeDuration;
        if (this._fadeSign > 0) {
          this._fadeSprite.opacity -= this._fadeSprite.opacity / d;
        } else {
          this._fadeSprite.opacity += (255 - this._fadeSprite.opacity) / d;
        }
        this._fadeDuration--;
      }
    }
    /**
     * Update the children of the scene EACH frame.
     *
     * @method updateChildren
     * @instance
     * @memberof Scene_Base
     */
    updateChildren() {
      this.children.forEach((child) => {
        if (child.update) {
          child.update();
        }
      });
    }
    /**
     * Pop the scene from the stack array and switch to the
     * previous scene.
     *
     * @method popScene
     * @instance
     * @memberof Scene_Base
     */
    popScene() {
      SceneManager_default.pop();
    }
    /**
     * Check whether the game should be triggering a gameover.
     *
     * @method checkGameover
     * @instance
     * @memberof Scene_Base
     */
    checkGameover() {
      if (self.$gameParty.isAllDead()) {
        SceneManager_default.goto(Scene_Gameover_default);
      }
    }
    /**
     * Slowly fade out all the visual and audio of the scene.
     *
     * @method fadeOutAll
     * @instance
     * @memberof Scene_Base
     */
    fadeOutAll() {
      const time = this.slowFadeSpeed() / 60;
      AudioManager_default.fadeOutBgm(time);
      AudioManager_default.fadeOutBgs(time);
      AudioManager_default.fadeOutMe(time);
      this.startFadeOut(this.slowFadeSpeed());
    }
    /**
     * Return the screen fade speed value.
     *
     * @method fadeSpeed
     * @instance
     * @memberof Scene_Base
     * @return {Number} Return the fade speed
     */
    fadeSpeed() {
      return 24;
    }
    /**
     * Return a slow screen fade speed value.
     *
     * @method slowFadeSpeed
     * @instance
     * @memberof Scene_Base
     * @return {Number} Return the fade speed
     */
    slowFadeSpeed() {
      return this.fadeSpeed() * 2;
    }
  };
  var Scene_Base_default = Scene_Base;

  // src-www/js/rpg_sprites/Sprite_Picture.js
  var Sprite_Picture = class extends Sprite_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(pictureId) {
      super.initialize();
      this._pictureId = pictureId;
      this._pictureName = "";
      this.update();
    }
    picture() {
      return self.$gameScreen.picture(this._pictureId);
    }
    update() {
      super.update();
      this.updateBitmap();
      if (this.visible) {
        this.updateOrigin();
        this.updatePosition();
        this.updateScale();
        this.updateTone();
        this.updateOther();
      }
    }
    updateBitmap() {
      const picture = this.picture();
      if (picture) {
        const pictureName = picture.name();
        if (this._pictureName !== pictureName) {
          this._pictureName = pictureName;
          this.loadBitmap();
        }
        this.visible = true;
      } else {
        this._pictureName = "";
        this.bitmap = null;
        this.visible = false;
      }
    }
    updateOrigin() {
      const picture = this.picture();
      if (picture.origin() === 0) {
        this.anchor.x = 0;
        this.anchor.y = 0;
      } else {
        this.anchor.x = 0.5;
        this.anchor.y = 0.5;
      }
    }
    updatePosition() {
      const picture = this.picture();
      this.x = Math.floor(picture.x());
      this.y = Math.floor(picture.y());
    }
    updateScale() {
      const picture = this.picture();
      this.scale.x = picture.scaleX() / 100;
      this.scale.y = picture.scaleY() / 100;
    }
    updateTone() {
      const picture = this.picture();
      if (picture.tone()) {
        this.setColorTone(picture.tone());
      } else {
        this.setColorTone([0, 0, 0, 0]);
      }
    }
    updateOther() {
      const picture = this.picture();
      this.opacity = picture.opacity();
      this.blendMode = picture.blendMode();
      this.rotation = picture.angle() * Math.PI / 180;
    }
    loadBitmap() {
      this.bitmap = ImageManager_default.loadPicture(this._pictureName);
    }
  };
  var Sprite_Picture_default = Sprite_Picture;

  // src-www/js/rpg_sprites/Sprite_Timer.js
  var Sprite_Timer = class extends Sprite_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
      this._seconds = 0;
      this.createBitmap();
      this.update();
    }
    createBitmap() {
      this.bitmap = new Bitmap_default(96, 48);
      this.bitmap.fontSize = 32;
    }
    update() {
      super.update();
      this.updateBitmap();
      this.updatePosition();
      this.updateVisibility();
    }
    updateBitmap() {
      if (this._seconds !== self.$gameTimer.seconds()) {
        this._seconds = self.$gameTimer.seconds();
        this.redraw();
      }
    }
    redraw() {
      const text = this.timerText();
      const width = this.bitmap.width;
      const height = this.bitmap.height;
      this.bitmap.clear();
      this.bitmap.drawText(text, 0, 0, width, height, "center");
    }
    timerText() {
      const min = Math.floor(this._seconds / 60) % 60;
      const sec = this._seconds % 60;
      return `${min.padZero(2)}:${sec.padZero(2)}`;
    }
    updatePosition() {
      this.x = Graphics_default.width - this.bitmap.width;
      this.y = 0;
    }
    updateVisibility() {
      this.visible = self.$gameTimer.isWorking();
    }
  };
  var Sprite_Timer_default = Sprite_Timer;

  // src-www/js/rpg_sprites/Spriteset_Base.js
  var Spriteset_Base = class extends Sprite_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
      this.setFrame(0, 0, Graphics_default.width, Graphics_default.height);
      this._tone = [0, 0, 0, 0];
      this.opaque = true;
      this.createLowerLayer();
      this.createToneChanger();
      this.createUpperLayer();
      this.update();
    }
    createLowerLayer() {
      this.createBaseSprite();
    }
    createUpperLayer() {
      this.createPictures();
      this.createTimer();
      this.createScreenSprites();
    }
    update() {
      super.update();
      this.updateScreenSprites();
      this.updateToneChanger();
      this.updatePosition();
    }
    createBaseSprite() {
      this._baseSprite = new Sprite_default();
      this._baseSprite.setFrame(0, 0, this.width, this.height);
      this._blackScreen = new ScreenSprite_default();
      this._blackScreen.opacity = 255;
      this.addChild(this._baseSprite);
      this._baseSprite.addChild(this._blackScreen);
    }
    createToneChanger() {
      if (Graphics_default.isWebGL()) {
        this.createWebGLToneChanger();
      } else {
        this.createCanvasToneChanger();
      }
    }
    createWebGLToneChanger() {
      const margin = 48;
      const width = Graphics_default.width + margin * 2;
      const height = Graphics_default.height + margin * 2;
      this._toneFilter = new ToneFilter_default();
      this._toneFilter.enabled = false;
      this._baseSprite.filters = [this._toneFilter];
      this._baseSprite.filterArea = new Rectangle_default(
        -margin,
        -margin,
        width,
        height
      );
    }
    createCanvasToneChanger() {
      this._toneSprite = new ToneSprite_default();
      this.addChild(this._toneSprite);
    }
    createPictures() {
      const width = Graphics_default.boxWidth;
      const height = Graphics_default.boxHeight;
      const x = (Graphics_default.width - width) / 2;
      const y = (Graphics_default.height - height) / 2;
      this._pictureContainer = new Sprite_default();
      this._pictureContainer.setFrame(x, y, width, height);
      for (let i = 1; i <= self.$gameScreen.maxPictures(); i++) {
        this._pictureContainer.addChild(new Sprite_Picture_default(i));
      }
      this.addChild(this._pictureContainer);
    }
    createTimer() {
      this._timerSprite = new Sprite_Timer_default();
      this.addChild(this._timerSprite);
    }
    createScreenSprites() {
      this._flashSprite = new ScreenSprite_default();
      this._fadeSprite = new ScreenSprite_default();
      this.addChild(this._flashSprite);
      this.addChild(this._fadeSprite);
    }
    updateScreenSprites() {
      const color2 = self.$gameScreen.flashColor();
      this._flashSprite.setColor(color2[0], color2[1], color2[2]);
      this._flashSprite.opacity = color2[3];
      this._fadeSprite.opacity = 255 - self.$gameScreen.brightness();
    }
    updateToneChanger() {
      const tone = self.$gameScreen.tone();
      if (!this._tone.equals(tone)) {
        this._tone = tone.clone();
        if (Graphics_default.isWebGL()) {
          this.updateWebGLToneChanger();
        } else {
          this.updateCanvasToneChanger();
        }
      }
    }
    updateWebGLToneChanger() {
      const tone = this._tone;
      this._toneFilter.reset();
      if (tone[0] || tone[1] || tone[2] || tone[3]) {
        this._toneFilter.enabled = true;
        this._toneFilter.adjustTone(tone[0], tone[1], tone[2]);
        this._toneFilter.adjustSaturation(-tone[3]);
      } else {
        this._toneFilter.enabled = false;
      }
    }
    updateCanvasToneChanger() {
      const tone = this._tone;
      this._toneSprite.setTone(tone[0], tone[1], tone[2], tone[3]);
    }
    updatePosition() {
      const screen = self.$gameScreen;
      const scale = screen.zoomScale();
      this.scale.x = scale;
      this.scale.y = scale;
      this.x = Math.round(-screen.zoomX() * (scale - 1));
      this.y = Math.round(-screen.zoomY() * (scale - 1));
      this.x += Math.round(screen.shake());
    }
  };
  var Spriteset_Base_default = Spriteset_Base;

  // src-www/js/rpg_sprites/Sprite_Animation.js
  var Sprite_Animation = class extends Sprite_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
      this.initMembers();
    }
    initMembers() {
      this._target = null;
      this._animation = null;
      this._mirror = false;
      this._delay = 0;
      this._rate = 4;
      this._duration = 0;
      this._flashColor = [0, 0, 0, 0];
      this._flashDuration = 0;
      this._screenFlashDuration = 0;
      this._hidingDuration = 0;
      this._bitmap1 = null;
      this._bitmap2 = null;
      this._cellSprites = [];
      this._screenFlashSprite = null;
      this._duplicated = false;
      this.z = 8;
    }
    setup(target2, animation, mirror, delay) {
      this._target = target2;
      this._animation = animation;
      this._mirror = mirror;
      this._delay = delay;
      if (this._animation) {
        this.remove();
        this.setupRate();
        this.setupDuration();
        this.loadBitmaps();
        this.createSprites();
      }
    }
    remove() {
      if (this.parent && this.parent.removeChild(this)) {
        this._target.setBlendColor([0, 0, 0, 0]);
        this._target.show();
      }
    }
    setupRate() {
      this._rate = 4;
    }
    setupDuration() {
      this._duration = this._animation.frames.length * this._rate + 1;
    }
    update() {
      super.update();
      this.updateMain();
      this.updateFlash();
      this.updateScreenFlash();
      this.updateHiding();
      Sprite_Animation._checker1 = {};
      Sprite_Animation._checker2 = {};
    }
    updateFlash() {
      if (this._flashDuration > 0) {
        const d = this._flashDuration--;
        this._flashColor[3] *= (d - 1) / d;
        this._target.setBlendColor(this._flashColor);
      }
    }
    updateScreenFlash() {
      if (this._screenFlashDuration > 0) {
        const d = this._screenFlashDuration--;
        if (this._screenFlashSprite) {
          this._screenFlashSprite.x = -this.absoluteX();
          this._screenFlashSprite.y = -this.absoluteY();
          this._screenFlashSprite.opacity *= (d - 1) / d;
          this._screenFlashSprite.visible = this._screenFlashDuration > 0;
        }
      }
    }
    absoluteX() {
      let x = 0;
      let object = this;
      while (object) {
        x += object.x;
        object = object.parent;
      }
      return x;
    }
    absoluteY() {
      let y = 0;
      let object = this;
      while (object) {
        y += object.y;
        object = object.parent;
      }
      return y;
    }
    updateHiding() {
      if (this._hidingDuration > 0) {
        this._hidingDuration--;
        if (this._hidingDuration === 0) {
          this._target.show();
        }
      }
    }
    isPlaying() {
      return this._duration > 0;
    }
    loadBitmaps() {
      const name1 = this._animation.animation1Name;
      const name2 = this._animation.animation2Name;
      const hue1 = this._animation.animation1Hue;
      const hue2 = this._animation.animation2Hue;
      this._bitmap1 = ImageManager_default.loadAnimation(name1, hue1);
      this._bitmap2 = ImageManager_default.loadAnimation(name2, hue2);
    }
    isReady() {
      return this._bitmap1 && this._bitmap1.isReady() && this._bitmap2 && this._bitmap2.isReady();
    }
    createSprites() {
      if (!Sprite_Animation._checker2[this._animation]) {
        this.createCellSprites();
        if (this._animation.position === 3) {
          Sprite_Animation._checker2[this._animation] = true;
        }
        this.createScreenFlashSprite();
      }
      if (Sprite_Animation._checker1[this._animation]) {
        this._duplicated = true;
      } else {
        this._duplicated = false;
        if (this._animation.position === 3) {
          Sprite_Animation._checker1[this._animation] = true;
        }
      }
    }
    createCellSprites() {
      this._cellSprites = [];
      for (let i = 0; i < 16; i++) {
        const sprite = new Sprite_default();
        sprite.anchor.x = 0.5;
        sprite.anchor.y = 0.5;
        this._cellSprites.push(sprite);
        this.addChild(sprite);
      }
    }
    createScreenFlashSprite() {
      this._screenFlashSprite = new ScreenSprite_default();
      this.addChild(this._screenFlashSprite);
    }
    updateMain() {
      if (this.isPlaying() && this.isReady()) {
        if (this._delay > 0) {
          this._delay--;
        } else {
          this._duration--;
          this.updatePosition();
          if (this._duration % this._rate === 0) {
            this.updateFrame();
          }
        }
      }
    }
    updatePosition() {
      if (this._animation.position === 3) {
        this.x = this.parent.width / 2;
        this.y = this.parent.height / 2;
      } else {
        const parent = this._target.parent;
        const grandparent = parent ? parent.parent : null;
        this.x = this._target.x;
        this.y = this._target.y;
        if (this.parent === grandparent) {
          this.x += parent.x;
          this.y += parent.y;
        }
        if (this._animation.position === 0) {
          this.y -= this._target.height;
        } else if (this._animation.position === 1) {
          this.y -= this._target.height / 2;
        }
      }
    }
    updateFrame() {
      if (this._duration > 0) {
        const frameIndex = this.currentFrameIndex();
        this.updateAllCellSprites(this._animation.frames[frameIndex]);
        this._animation.timings.forEach(function(timing) {
          if (timing.frame === frameIndex) {
            this.processTimingData(timing);
          }
        }, this);
      }
    }
    currentFrameIndex() {
      return this._animation.frames.length - Math.floor((this._duration + this._rate - 1) / this._rate);
    }
    updateAllCellSprites(frame) {
      this._cellSprites.forEach((sprite, i) => {
        if (i < frame.length) {
          this.updateCellSprite(sprite, frame[i]);
        } else {
          sprite.visible = false;
        }
      });
    }
    updateCellSprite(sprite, cell) {
      const pattern = cell[0];
      if (pattern >= 0) {
        const sx = pattern % 5 * 192;
        const sy = Math.floor(pattern % 100 / 5) * 192;
        const mirror = this._mirror;
        sprite.bitmap = pattern < 100 ? this._bitmap1 : this._bitmap2;
        sprite.setFrame(sx, sy, 192, 192);
        sprite.x = cell[1];
        sprite.y = cell[2];
        sprite.rotation = cell[4] * Math.PI / 180;
        sprite.scale.x = cell[3] / 100;
        if (cell[5]) {
          sprite.scale.x *= -1;
        }
        if (mirror) {
          sprite.x *= -1;
          sprite.rotation *= -1;
          sprite.scale.x *= -1;
        }
        sprite.scale.y = cell[3] / 100;
        sprite.opacity = cell[6];
        sprite.blendMode = cell[7];
        sprite.visible = true;
      } else {
        sprite.visible = false;
      }
    }
    processTimingData({ flashDuration, flashScope, flashColor, se }) {
      const duration = flashDuration * this._rate;
      switch (flashScope) {
        case 1:
          this.startFlash(flashColor, duration);
          break;
        case 2:
          this.startScreenFlash(flashColor, duration);
          break;
        case 3:
          this.startHiding(duration);
          break;
      }
      if (!this._duplicated && se) {
        AudioManager_default.playSe(se);
      }
    }
    startFlash(color2, duration) {
      this._flashColor = color2.clone();
      this._flashDuration = duration;
    }
    startScreenFlash(color2, duration) {
      this._screenFlashDuration = duration;
      if (this._screenFlashSprite) {
        this._screenFlashSprite.setColor(color2[0], color2[1], color2[2]);
        this._screenFlashSprite.opacity = color2[3];
      }
    }
    startHiding(duration) {
      this._hidingDuration = duration;
      this._target.hide();
    }
  };
  Sprite_Animation._checker1 = {};
  Sprite_Animation._checker2 = {};
  var Sprite_Animation_default = Sprite_Animation;

  // src-www/js/rpg_sprites/Sprite_Base.js
  var Sprite_Base = class extends Sprite_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
      this._animationSprites = [];
      this._effectTarget = this;
      this._hiding = false;
    }
    update() {
      super.update();
      this.updateVisibility();
      this.updateAnimationSprites();
    }
    hide() {
      this._hiding = true;
      this.updateVisibility();
    }
    show() {
      this._hiding = false;
      this.updateVisibility();
    }
    updateVisibility() {
      this.visible = !this._hiding;
    }
    updateAnimationSprites() {
      if (this._animationSprites.length > 0) {
        const sprites = this._animationSprites.clone();
        this._animationSprites = [];
        for (const sprite of sprites) {
          if (sprite.isPlaying()) {
            this._animationSprites.push(sprite);
          } else {
            sprite.remove();
          }
        }
      }
    }
    startAnimation(animation, mirror, delay) {
      const sprite = new Sprite_Animation_default();
      sprite.setup(this._effectTarget, animation, mirror, delay);
      this.parent.addChild(sprite);
      this._animationSprites.push(sprite);
    }
    isAnimationPlaying() {
      return this._animationSprites.length > 0;
    }
  };
  var Sprite_Base_default = Sprite_Base;

  // src-www/js/rpg_sprites/Sprite_Damage.js
  var Sprite_Damage = class extends Sprite_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
      this._duration = 90;
      this._flashColor = [0, 0, 0, 0];
      this._flashDuration = 0;
      this._damageBitmap = ImageManager_default.loadSystem("Damage");
    }
    setup(target2) {
      const result2 = target2.result();
      if (result2.missed || result2.evaded) {
        this.createMiss();
      } else if (result2.hpAffected) {
        this.createDigits(0, result2.hpDamage);
      } else if (target2.isAlive() && result2.mpDamage !== 0) {
        this.createDigits(2, result2.mpDamage);
      }
      if (result2.critical) {
        this.setupCriticalEffect();
      }
    }
    setupCriticalEffect() {
      this._flashColor = [255, 0, 0, 160];
      this._flashDuration = 60;
    }
    digitWidth() {
      return this._damageBitmap ? this._damageBitmap.width / 10 : 0;
    }
    digitHeight() {
      return this._damageBitmap ? this._damageBitmap.height / 5 : 0;
    }
    createMiss() {
      const w = this.digitWidth();
      const h = this.digitHeight();
      const sprite = this.createChildSprite();
      sprite.setFrame(0, 4 * h, 4 * w, h);
      sprite.dy = 0;
    }
    createDigits(baseRow, value3) {
      const string = Math.abs(value3).toString();
      const row = baseRow + (value3 < 0 ? 1 : 0);
      const w = this.digitWidth();
      const h = this.digitHeight();
      for (let i = 0; i < string.length; i++) {
        const sprite = this.createChildSprite();
        const n = Number(string[i]);
        sprite.setFrame(n * w, row * h, w, h);
        sprite.x = (i - (string.length - 1) / 2) * w;
        sprite.dy = -i;
      }
    }
    createChildSprite() {
      const sprite = new Sprite_default();
      sprite.bitmap = this._damageBitmap;
      sprite.anchor.x = 0.5;
      sprite.anchor.y = 1;
      sprite.y = -40;
      sprite.ry = sprite.y;
      this.addChild(sprite);
      return sprite;
    }
    update() {
      super.update();
      if (this._duration > 0) {
        this._duration--;
        for (let i = 0; i < this.children.length; i++) {
          this.updateChild(this.children[i]);
        }
      }
      this.updateFlash();
      this.updateOpacity();
    }
    updateChild(sprite) {
      sprite.dy += 0.5;
      sprite.ry += sprite.dy;
      if (sprite.ry >= 0) {
        sprite.ry = 0;
        sprite.dy *= -0.6;
      }
      sprite.y = Math.round(sprite.ry);
      sprite.setBlendColor(this._flashColor);
    }
    updateFlash() {
      if (this._flashDuration > 0) {
        const d = this._flashDuration--;
        this._flashColor[3] *= (d - 1) / d;
      }
    }
    updateOpacity() {
      if (this._duration < 10) {
        this.opacity = 255 * this._duration / 10;
      }
    }
    isPlaying() {
      return this._duration > 0;
    }
  };
  var Sprite_Damage_default = Sprite_Damage;

  // src-www/js/rpg_sprites/Sprite_Battler.js
  var Sprite_Battler = class extends Sprite_Base_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(battler) {
      super.initialize();
      this.initMembers();
      this.setBattler(battler);
    }
    initMembers() {
      this.anchor.x = 0.5;
      this.anchor.y = 1;
      this._battler = null;
      this._damages = [];
      this._homeX = 0;
      this._homeY = 0;
      this._offsetX = 0;
      this._offsetY = 0;
      this._targetOffsetX = NaN;
      this._targetOffsetY = NaN;
      this._movementDuration = 0;
      this._selectionEffectCount = 0;
    }
    setBattler(battler) {
      this._battler = battler;
    }
    setHome(x, y) {
      this._homeX = x;
      this._homeY = y;
      this.updatePosition();
    }
    update() {
      super.update();
      if (this._battler) {
        this.updateMain();
        this.updateAnimation();
        this.updateDamagePopup();
        this.updateSelectionEffect();
      } else {
        this.bitmap = null;
      }
    }
    updateVisibility() {
      super.updateVisibility();
      if (!this._battler || !this._battler.isSpriteVisible()) {
        this.visible = false;
      }
    }
    updateMain() {
      if (this._battler.isSpriteVisible()) {
        this.updateBitmap();
        this.updateFrame();
      }
      this.updateMove();
      this.updatePosition();
    }
    updateBitmap() {
    }
    updateFrame() {
    }
    updateMove() {
      if (this._movementDuration > 0) {
        const d = this._movementDuration;
        this._offsetX = (this._offsetX * (d - 1) + this._targetOffsetX) / d;
        this._offsetY = (this._offsetY * (d - 1) + this._targetOffsetY) / d;
        this._movementDuration--;
        if (this._movementDuration === 0) {
          this.onMoveEnd();
        }
      }
    }
    updatePosition() {
      this.x = this._homeX + this._offsetX;
      this.y = this._homeY + this._offsetY;
    }
    updateAnimation() {
      this.setupAnimation();
    }
    updateDamagePopup() {
      this.setupDamagePopup();
      if (this._damages.length > 0) {
        for (let i = 0; i < this._damages.length; i++) {
          this._damages[i].update();
        }
        if (!this._damages[0].isPlaying()) {
          this.parent.removeChild(this._damages[0]);
          this._damages.shift();
        }
      }
    }
    updateSelectionEffect() {
      const target2 = this._effectTarget;
      if (this._battler.isSelected()) {
        this._selectionEffectCount++;
        if (this._selectionEffectCount % 30 < 15) {
          target2.setBlendColor([255, 255, 255, 64]);
        } else {
          target2.setBlendColor([0, 0, 0, 0]);
        }
      } else if (this._selectionEffectCount > 0) {
        this._selectionEffectCount = 0;
        target2.setBlendColor([0, 0, 0, 0]);
      }
    }
    setupAnimation() {
      while (this._battler.isAnimationRequested()) {
        const data = this._battler.shiftAnimation();
        const animation = self.$dataAnimations[data.animationId];
        const mirror = data.mirror;
        const delay = animation.position === 3 ? 0 : data.delay;
        this.startAnimation(animation, mirror, delay);
        for (const sprite of this._animationSprites) {
          sprite.visible = this._battler.isSpriteVisible();
        }
      }
    }
    setupDamagePopup() {
      if (this._battler.isDamagePopupRequested()) {
        if (this._battler.isSpriteVisible()) {
          const sprite = new Sprite_Damage_default();
          sprite.x = this.x + this.damageOffsetX();
          sprite.y = this.y + this.damageOffsetY();
          sprite.setup(this._battler);
          this._damages.push(sprite);
          this.parent.addChild(sprite);
        }
        this._battler.clearDamagePopup();
        this._battler.clearResult();
      }
    }
    damageOffsetX() {
      return 0;
    }
    damageOffsetY() {
      return 0;
    }
    startMove(x, y, duration) {
      if (this._targetOffsetX !== x || this._targetOffsetY !== y) {
        this._targetOffsetX = x;
        this._targetOffsetY = y;
        this._movementDuration = duration;
        if (duration === 0) {
          this._offsetX = x;
          this._offsetY = y;
        }
      }
    }
    onMoveEnd() {
    }
    isEffecting() {
      return false;
    }
    isMoving() {
      return this._movementDuration > 0;
    }
    inHomePosition() {
      return this._offsetX === 0 && this._offsetY === 0;
    }
  };
  var Sprite_Battler_default = Sprite_Battler;

  // src-www/js/rpg_sprites/Sprite_StateIcon.js
  var Sprite_StateIcon = class extends Sprite_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
      this.initMembers();
      this.loadBitmap();
    }
    initMembers() {
      this._battler = null;
      this._iconIndex = 0;
      this._animationCount = 0;
      this._animationIndex = 0;
      this.anchor.x = 0.5;
      this.anchor.y = 0.5;
    }
    loadBitmap() {
      this.bitmap = ImageManager_default.loadSystem("IconSet");
      this.setFrame(0, 0, 0, 0);
    }
    setup(battler) {
      this._battler = battler;
    }
    update() {
      super.update();
      this._animationCount++;
      if (this._animationCount >= this.animationWait()) {
        this.updateIcon();
        this.updateFrame();
        this._animationCount = 0;
      }
    }
    animationWait() {
      return 40;
    }
    updateIcon() {
      let icons = [];
      if (this._battler && this._battler.isAlive()) {
        icons = this._battler.allIcons();
      }
      if (icons.length > 0) {
        this._animationIndex++;
        if (this._animationIndex >= icons.length) {
          this._animationIndex = 0;
        }
        this._iconIndex = icons[this._animationIndex];
      } else {
        this._animationIndex = 0;
        this._iconIndex = 0;
      }
    }
    updateFrame() {
      const pw = Sprite_StateIcon._iconWidth;
      const ph = Sprite_StateIcon._iconHeight;
      const sx = this._iconIndex % 16 * pw;
      const sy = Math.floor(this._iconIndex / 16) * ph;
      this.setFrame(sx, sy, pw, ph);
    }
  };
  Sprite_StateIcon._iconWidth = 32;
  Sprite_StateIcon._iconHeight = 32;
  var Sprite_StateIcon_default = Sprite_StateIcon;

  // src-www/js/rpg_sprites/Sprite_Enemy.js
  var Sprite_Enemy = class extends Sprite_Battler_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(battler) {
      super.initialize(battler);
    }
    initMembers() {
      super.initMembers();
      this._enemy = null;
      this._appeared = false;
      this._battlerName = "";
      this._battlerHue = 0;
      this._effectType = null;
      this._effectDuration = 0;
      this._shake = 0;
      this.createStateIconSprite();
    }
    createStateIconSprite() {
      this._stateIconSprite = new Sprite_StateIcon_default();
      this.addChild(this._stateIconSprite);
    }
    setBattler(battler) {
      super.setBattler(battler);
      this._enemy = battler;
      this.setHome(battler.screenX(), battler.screenY());
      this._stateIconSprite.setup(battler);
    }
    update() {
      super.update();
      if (this._enemy) {
        this.updateEffect();
        this.updateStateSprite();
      }
    }
    updateBitmap() {
      super.updateBitmap();
      const name = this._enemy.battlerName();
      const hue = this._enemy.battlerHue();
      if (this._battlerName !== name || this._battlerHue !== hue) {
        this._battlerName = name;
        this._battlerHue = hue;
        this.loadBitmap(name, hue);
        this.initVisibility();
      }
    }
    loadBitmap(name, hue) {
      if (self.$gameSystem.isSideView()) {
        this.bitmap = ImageManager_default.loadSvEnemy(name, hue);
      } else {
        this.bitmap = ImageManager_default.loadEnemy(name, hue);
      }
    }
    updateFrame() {
      super.updateFrame();
      if (this.bitmap._image) {
        let frameHeight = this.bitmap.height;
        if (this._effectType === "bossCollapse") {
          frameHeight = this._effectDuration;
        }
        this.setFrame(0, 0, this.bitmap.width, frameHeight);
      }
    }
    updatePosition() {
      super.updatePosition();
      this.x += this._shake;
    }
    updateStateSprite() {
      this._stateIconSprite.y = -Math.round((this.bitmap.height + 40) * 0.9);
      if (this._stateIconSprite.y < 20 - this.y) {
        this._stateIconSprite.y = 20 - this.y;
      }
    }
    initVisibility() {
      this._appeared = this._enemy.isAlive();
      if (!this._appeared) {
        this.opacity = 0;
      }
    }
    setupEffect() {
      if (this._appeared && this._enemy.isEffectRequested()) {
        this.startEffect(this._enemy.effectType());
        this._enemy.clearEffect();
      }
      if (!this._appeared && this._enemy.isAlive()) {
        this.startEffect("appear");
      } else if (this._appeared && this._enemy.isHidden()) {
        this.startEffect("disappear");
      }
    }
    startEffect(effectType) {
      this._effectType = effectType;
      switch (this._effectType) {
        case "appear":
          this.startAppear();
          break;
        case "disappear":
          this.startDisappear();
          break;
        case "whiten":
          this.startWhiten();
          break;
        case "blink":
          this.startBlink();
          break;
        case "collapse":
          this.startCollapse();
          break;
        case "bossCollapse":
          this.startBossCollapse();
          break;
        case "instantCollapse":
          this.startInstantCollapse();
          break;
      }
      this.revertToNormal();
    }
    startAppear() {
      this._effectDuration = 16;
      this._appeared = true;
    }
    startDisappear() {
      this._effectDuration = 32;
      this._appeared = false;
    }
    startWhiten() {
      this._effectDuration = 16;
    }
    startBlink() {
      this._effectDuration = 20;
    }
    startCollapse() {
      this._effectDuration = 32;
      this._appeared = false;
    }
    startBossCollapse() {
      this._effectDuration = this.bitmap.height;
      this._appeared = false;
    }
    startInstantCollapse() {
      this._effectDuration = 16;
      this._appeared = false;
    }
    updateEffect() {
      this.setupEffect();
      if (this._effectDuration > 0) {
        this._effectDuration--;
        switch (this._effectType) {
          case "whiten":
            this.updateWhiten();
            break;
          case "blink":
            this.updateBlink();
            break;
          case "appear":
            this.updateAppear();
            break;
          case "disappear":
            this.updateDisappear();
            break;
          case "collapse":
            this.updateCollapse();
            break;
          case "bossCollapse":
            this.updateBossCollapse();
            break;
          case "instantCollapse":
            this.updateInstantCollapse();
            break;
        }
        if (this._effectDuration === 0) {
          this._effectType = null;
        }
      }
    }
    isEffecting() {
      return this._effectType !== null;
    }
    revertToNormal() {
      this._shake = 0;
      this.blendMode = 0;
      this.opacity = 255;
      this.setBlendColor([0, 0, 0, 0]);
    }
    updateWhiten() {
      const alpha = 128 - (16 - this._effectDuration) * 10;
      this.setBlendColor([255, 255, 255, alpha]);
    }
    updateBlink() {
      this.opacity = this._effectDuration % 10 < 5 ? 255 : 0;
    }
    updateAppear() {
      this.opacity = (16 - this._effectDuration) * 16;
    }
    updateDisappear() {
      this.opacity = 256 - (32 - this._effectDuration) * 10;
    }
    updateCollapse() {
      this.blendMode = Graphics_default.BLEND_ADD;
      this.setBlendColor([255, 128, 128, 128]);
      this.opacity *= this._effectDuration / (this._effectDuration + 1);
    }
    updateBossCollapse() {
      this._shake = this._effectDuration % 2 * 4 - 2;
      this.blendMode = Graphics_default.BLEND_ADD;
      this.opacity *= this._effectDuration / (this._effectDuration + 1);
      this.setBlendColor([255, 255, 255, 255 - this.opacity]);
      if (this._effectDuration % 20 === 19) {
        SoundManager_default.playBossCollapse2();
      }
    }
    updateInstantCollapse() {
      this.opacity = 0;
    }
    damageOffsetX() {
      return 0;
    }
    damageOffsetY() {
      return -8;
    }
  };
  var Sprite_Enemy_default = Sprite_Enemy;

  // src-www/js/rpg_sprites/Sprite_Weapon.js
  var Sprite_Weapon = class extends Sprite_Base_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
      this.initMembers();
    }
    initMembers() {
      this._weaponImageId = 0;
      this._animationCount = 0;
      this._pattern = 0;
      this.anchor.x = 0.5;
      this.anchor.y = 1;
      this.x = -16;
    }
    setup(weaponImageId) {
      this._weaponImageId = weaponImageId;
      this._animationCount = 0;
      this._pattern = 0;
      this.loadBitmap();
      this.updateFrame();
    }
    update() {
      super.update();
      this._animationCount++;
      if (this._animationCount >= this.animationWait()) {
        this.updatePattern();
        this.updateFrame();
        this._animationCount = 0;
      }
    }
    animationWait() {
      return 12;
    }
    updatePattern() {
      this._pattern++;
      if (this._pattern >= 3) {
        this._weaponImageId = 0;
      }
    }
    loadBitmap() {
      const pageId = Math.floor((this._weaponImageId - 1) / 12) + 1;
      if (pageId >= 1) {
        this.bitmap = ImageManager_default.loadSystem(`Weapons${pageId}`);
      } else {
        this.bitmap = ImageManager_default.loadSystem("");
      }
    }
    updateFrame() {
      if (this._weaponImageId > 0) {
        const index2 = (this._weaponImageId - 1) % 12;
        const w = 96;
        const h = 64;
        const sx = (Math.floor(index2 / 6) * 3 + this._pattern) * w;
        const sy = Math.floor(index2 % 6) * h;
        this.setFrame(sx, sy, w, h);
      } else {
        this.setFrame(0, 0, 0, 0);
      }
    }
    isPlaying() {
      return this._weaponImageId > 0;
    }
  };
  var Sprite_Weapon_default = Sprite_Weapon;

  // src-www/js/rpg_sprites/Sprite_StateOverlay.js
  var Sprite_StateOverlay = class extends Sprite_Base_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
      this.initMembers();
      this.loadBitmap();
    }
    initMembers() {
      this._battler = null;
      this._overlayIndex = 0;
      this._animationCount = 0;
      this._pattern = 0;
      this.anchor.x = 0.5;
      this.anchor.y = 1;
    }
    loadBitmap() {
      this.bitmap = ImageManager_default.loadSystem("States");
      this.setFrame(0, 0, 0, 0);
    }
    setup(battler) {
      this._battler = battler;
    }
    update() {
      super.update();
      this._animationCount++;
      if (this._animationCount >= this.animationWait()) {
        this.updatePattern();
        this.updateFrame();
        this._animationCount = 0;
      }
    }
    animationWait() {
      return 8;
    }
    updatePattern() {
      this._pattern++;
      this._pattern %= 8;
      if (this._battler) {
        this._overlayIndex = this._battler.stateOverlayIndex();
      }
    }
    updateFrame() {
      if (this._overlayIndex > 0) {
        const w = 96;
        const h = 96;
        const sx = this._pattern * w;
        const sy = (this._overlayIndex - 1) * h;
        this.setFrame(sx, sy, w, h);
      } else {
        this.setFrame(0, 0, 0, 0);
      }
    }
  };
  var Sprite_StateOverlay_default = Sprite_StateOverlay;

  // src-www/js/rpg_sprites/Sprite_Actor.js
  var Sprite_Actor = class extends Sprite_Battler_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(battler) {
      super.initialize(battler);
      this.moveToStartPosition();
    }
    initMembers() {
      super.initMembers();
      this._battlerName = "";
      this._motion = null;
      this._motionCount = 0;
      this._pattern = 0;
      this.createShadowSprite();
      this.createWeaponSprite();
      this.createMainSprite();
      this.createStateSprite();
    }
    createMainSprite() {
      this._mainSprite = new Sprite_Base_default();
      this._mainSprite.anchor.x = 0.5;
      this._mainSprite.anchor.y = 1;
      this.addChild(this._mainSprite);
      this._effectTarget = this._mainSprite;
    }
    createShadowSprite() {
      this._shadowSprite = new Sprite_default();
      this._shadowSprite.bitmap = ImageManager_default.loadSystem("Shadow2");
      this._shadowSprite.anchor.x = 0.5;
      this._shadowSprite.anchor.y = 0.5;
      this._shadowSprite.y = -2;
      this.addChild(this._shadowSprite);
    }
    createWeaponSprite() {
      this._weaponSprite = new Sprite_Weapon_default();
      this.addChild(this._weaponSprite);
    }
    createStateSprite() {
      this._stateSprite = new Sprite_StateOverlay_default();
      this.addChild(this._stateSprite);
    }
    setBattler(battler) {
      super.setBattler(battler);
      const changed = battler !== this._actor;
      if (changed) {
        this._actor = battler;
        if (battler) {
          this.setActorHome(battler.index());
        }
        this.startEntryMotion();
        this._stateSprite.setup(battler);
      }
    }
    moveToStartPosition() {
      this.startMove(300, 0, 0);
    }
    setActorHome(index2) {
      this.setHome(600 + index2 * 32, 280 + index2 * 48);
    }
    update() {
      super.update();
      this.updateShadow();
      if (this._actor) {
        this.updateMotion();
      }
    }
    updateShadow() {
      this._shadowSprite.visible = !!this._actor;
    }
    updateMain() {
      super.updateMain();
      if (this._actor.isSpriteVisible() && !this.isMoving()) {
        this.updateTargetPosition();
      }
    }
    setupMotion() {
      if (this._actor.isMotionRequested()) {
        this.startMotion(this._actor.motionType());
        this._actor.clearMotion();
      }
    }
    setupWeaponAnimation() {
      if (this._actor.isWeaponAnimationRequested()) {
        this._weaponSprite.setup(this._actor.weaponImageId());
        this._actor.clearWeaponAnimation();
      }
    }
    startMotion(motionType) {
      const newMotion = Sprite_Actor.MOTIONS[motionType];
      if (this._motion !== newMotion) {
        this._motion = newMotion;
        this._motionCount = 0;
        this._pattern = 0;
      }
    }
    updateTargetPosition() {
      if (this._actor.isInputting() || this._actor.isActing()) {
        this.stepForward();
      } else if (this._actor.canMove() && BattleManager_default.isEscaped()) {
        this.retreat();
      } else if (!this.inHomePosition()) {
        this.stepBack();
      }
    }
    updateBitmap() {
      super.updateBitmap();
      const name = this._actor.battlerName();
      if (this._battlerName !== name) {
        this._battlerName = name;
        this._mainSprite.bitmap = ImageManager_default.loadSvActor(name);
      }
    }
    updateFrame() {
      super.updateFrame();
      const bitmap = this._mainSprite.bitmap;
      if (bitmap) {
        const motionIndex = this._motion ? this._motion.index : 0;
        const pattern = this._pattern < 3 ? this._pattern : 1;
        const cw = bitmap.width / 9;
        const ch = bitmap.height / 6;
        const cx = Math.floor(motionIndex / 6) * 3 + pattern;
        const cy = motionIndex % 6;
        this._mainSprite.setFrame(cx * cw, cy * ch, cw, ch);
      }
    }
    updateMove() {
      const bitmap = this._mainSprite.bitmap;
      if (!bitmap || bitmap.isReady()) {
        super.updateMove();
      }
    }
    updateMotion() {
      this.setupMotion();
      this.setupWeaponAnimation();
      if (this._actor.isMotionRefreshRequested()) {
        this.refreshMotion();
        this._actor.clearMotion();
      }
      this.updateMotionCount();
    }
    updateMotionCount() {
      if (this._motion && ++this._motionCount >= this.motionSpeed()) {
        if (this._motion.loop) {
          this._pattern = (this._pattern + 1) % 4;
        } else if (this._pattern < 2) {
          this._pattern++;
        } else {
          this.refreshMotion();
        }
        this._motionCount = 0;
      }
    }
    motionSpeed() {
      return 12;
    }
    refreshMotion() {
      const actor2 = this._actor;
      const motionGuard = Sprite_Actor.MOTIONS.guard;
      if (actor2) {
        if (this._motion === motionGuard && !BattleManager_default.isInputting()) {
          return;
        }
        const stateMotion = actor2.stateMotionIndex();
        if (actor2.isInputting() || actor2.isActing()) {
          this.startMotion("walk");
        } else if (stateMotion === 3) {
          this.startMotion("dead");
        } else if (stateMotion === 2) {
          this.startMotion("sleep");
        } else if (actor2.isChanting()) {
          this.startMotion("chant");
        } else if (actor2.isGuard() || actor2.isGuardWaiting()) {
          this.startMotion("guard");
        } else if (stateMotion === 1) {
          this.startMotion("abnormal");
        } else if (actor2.isDying()) {
          this.startMotion("dying");
        } else if (actor2.isUndecided()) {
          this.startMotion("walk");
        } else {
          this.startMotion("wait");
        }
      }
    }
    startEntryMotion() {
      if (this._actor && this._actor.canMove()) {
        this.startMotion("walk");
        this.startMove(0, 0, 30);
      } else if (!this.isMoving()) {
        this.refreshMotion();
        this.startMove(0, 0, 0);
      }
    }
    stepForward() {
      this.startMove(-48, 0, 12);
    }
    stepBack() {
      this.startMove(0, 0, 12);
    }
    retreat() {
      this.startMove(300, 0, 30);
    }
    onMoveEnd() {
      super.onMoveEnd();
      if (!BattleManager_default.isBattleEnd()) {
        this.refreshMotion();
      }
    }
    damageOffsetX() {
      return -32;
    }
    damageOffsetY() {
      return 0;
    }
  };
  Sprite_Actor.MOTIONS = {
    walk: {
      index: 0,
      loop: true
    },
    wait: {
      index: 1,
      loop: true
    },
    chant: {
      index: 2,
      loop: true
    },
    guard: {
      index: 3,
      loop: true
    },
    damage: {
      index: 4,
      loop: false
    },
    evade: {
      index: 5,
      loop: false
    },
    thrust: {
      index: 6,
      loop: false
    },
    swing: {
      index: 7,
      loop: false
    },
    missile: {
      index: 8,
      loop: false
    },
    skill: {
      index: 9,
      loop: false
    },
    spell: {
      index: 10,
      loop: false
    },
    item: {
      index: 11,
      loop: false
    },
    escape: {
      index: 12,
      loop: true
    },
    victory: {
      index: 13,
      loop: true
    },
    dying: {
      index: 14,
      loop: true
    },
    abnormal: {
      index: 15,
      loop: true
    },
    sleep: {
      index: 16,
      loop: true
    },
    dead: {
      index: 17,
      loop: true
    }
  };
  var Sprite_Actor_default = Sprite_Actor;

  // src-www/js/rpg_sprites/Spriteset_Battle.js
  var Spriteset_Battle = class extends Spriteset_Base_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
      this._battlebackLocated = false;
    }
    createLowerLayer() {
      super.createLowerLayer();
      this.createBackground();
      this.createBattleField();
      this.createBattleback();
      this.createEnemies();
      this.createActors();
    }
    createBackground() {
      this._backgroundSprite = new Sprite(
        new Texture(SceneManager_default.backgroundBitmap().baseTexture)
      );
      if (Graphics_default.isWebGL()) {
        const filter = new filters.PixelateFilter(12, 12);
        this._backgroundSprite.filters = [filter];
        this._backgroundSprite.cacheAsBitmap = true;
      }
      this._baseSprite.addChild(this._backgroundSprite);
    }
    update() {
      super.update();
      this.updateActors();
      this.updateBattleback();
    }
    createBattleField() {
      const width = Graphics_default.boxWidth;
      const height = Graphics_default.boxHeight;
      const x = (Graphics_default.width - width) / 2;
      const y = (Graphics_default.height - height) / 2;
      this._battleField = new Sprite_default();
      this._battleField.setFrame(x, y, width, height);
      this._battleField.x = x;
      this._battleField.y = y;
      this._baseSprite.addChild(this._battleField);
    }
    createBattleback() {
      const margin = 32;
      const x = -this._battleField.x - margin;
      const y = -this._battleField.y - margin;
      const width = Graphics_default.width + margin * 2;
      const height = Graphics_default.height + margin * 2;
      this._back1Sprite = new TilingSprite_default();
      this._back2Sprite = new TilingSprite_default();
      this._back1Sprite.bitmap = this.battleback1Bitmap();
      this._back2Sprite.bitmap = this.battleback2Bitmap();
      this._back1Sprite.move(x, y, width, height);
      this._back2Sprite.move(x, y, width, height);
      this._battleField.addChild(this._back1Sprite);
      this._battleField.addChild(this._back2Sprite);
    }
    updateBattleback() {
      if (!this._battlebackLocated) {
        this.locateBattleback();
        this._battlebackLocated = true;
      }
    }
    locateBattleback() {
      const width = this._battleField.width;
      const height = this._battleField.height;
      const sprite1 = this._back1Sprite;
      const sprite2 = this._back2Sprite;
      sprite1.origin.x = sprite1.x + (sprite1.bitmap.width - width) / 2;
      sprite2.origin.x = sprite1.y + (sprite2.bitmap.width - width) / 2;
      if (self.$gameSystem.isSideView()) {
        sprite1.origin.y = sprite1.x + sprite1.bitmap.height - height;
        sprite2.origin.y = sprite1.y + sprite2.bitmap.height - height;
      }
    }
    battleback1Bitmap() {
      return ImageManager_default.loadBattleback1(this.battleback1Name());
    }
    battleback2Bitmap() {
      return ImageManager_default.loadBattleback2(this.battleback2Name());
    }
    battleback1Name() {
      if (BattleManager_default.isBattleTest()) {
        return self.$dataSystem.battleback1Name;
      } else if (self.$gameMap.battleback1Name()) {
        return self.$gameMap.battleback1Name();
      } else if (self.$gameMap.isOverworld()) {
        return this.overworldBattleback1Name();
      } else {
        return "";
      }
    }
    battleback2Name() {
      if (BattleManager_default.isBattleTest()) {
        return self.$dataSystem.battleback2Name;
      } else if (self.$gameMap.battleback2Name()) {
        return self.$gameMap.battleback2Name();
      } else if (self.$gameMap.isOverworld()) {
        return this.overworldBattleback2Name();
      } else {
        return "";
      }
    }
    overworldBattleback1Name() {
      if (self.$gameMap.battleback1Name() === "")
        return "";
      if (self.$gamePlayer.isInVehicle()) {
        return this.shipBattleback1Name();
      } else {
        return this.normalBattleback1Name();
      }
    }
    overworldBattleback2Name() {
      if (self.$gameMap.battleback2Name() === "")
        return "";
      if (self.$gamePlayer.isInVehicle()) {
        return this.shipBattleback2Name();
      } else {
        return this.normalBattleback2Name();
      }
    }
    normalBattleback1Name() {
      return this.terrainBattleback1Name(this.autotileType(1)) || this.terrainBattleback1Name(this.autotileType(0)) || this.defaultBattleback1Name();
    }
    normalBattleback2Name() {
      return this.terrainBattleback2Name(this.autotileType(1)) || this.terrainBattleback2Name(this.autotileType(0)) || this.defaultBattleback2Name();
    }
    terrainBattleback1Name(type) {
      switch (type) {
        case 24:
        case 25:
          return "Wasteland";
        case 26:
        case 27:
          return "DirtField";
        case 32:
        case 33:
          return "Desert";
        case 34:
          return "Lava1";
        case 35:
          return "Lava2";
        case 40:
        case 41:
          return "Snowfield";
        case 42:
          return "Clouds";
        case 4:
        case 5:
          return "PoisonSwamp";
        default:
          return null;
      }
    }
    terrainBattleback2Name(type) {
      switch (type) {
        case 20:
        case 21:
          return "Forest";
        case 22:
        case 30:
        case 38:
          return "Cliff";
        case 24:
        case 25:
        case 26:
        case 27:
          return "Wasteland";
        case 32:
        case 33:
          return "Desert";
        case 34:
        case 35:
          return "Lava";
        case 40:
        case 41:
          return "Snowfield";
        case 42:
          return "Clouds";
        case 4:
        case 5:
          return "PoisonSwamp";
      }
    }
    defaultBattleback1Name() {
      return "Grassland";
    }
    defaultBattleback2Name() {
      return "Grassland";
    }
    shipBattleback1Name() {
      return "Ship";
    }
    shipBattleback2Name() {
      return "Ship";
    }
    autotileType(z) {
      return self.$gameMap.autotileType(
        self.$gamePlayer.x,
        self.$gamePlayer.y,
        z
      );
    }
    createEnemies() {
      const enemies = self.$gameTroop.members();
      const sprites = [];
      for (let i = 0; i < enemies.length; i++) {
        sprites[i] = new Sprite_Enemy_default(enemies[i]);
      }
      sprites.sort(this.compareEnemySprite.bind(this));
      for (let j = 0; j < sprites.length; j++) {
        this._battleField.addChild(sprites[j]);
      }
      this._enemySprites = sprites;
    }
    compareEnemySprite(a2, b2) {
      if (a2.y !== b2.y) {
        return a2.y - b2.y;
      } else {
        return a2.spriteId - b2.spriteId;
      }
    }
    createActors() {
      this._actorSprites = [];
      for (let i = 0; i < self.$gameParty.maxBattleMembers(); i++) {
        this._actorSprites[i] = new Sprite_Actor_default();
        this._battleField.addChild(this._actorSprites[i]);
      }
    }
    updateActors() {
      const members = self.$gameParty.battleMembers();
      for (let i = 0; i < this._actorSprites.length; i++) {
        this._actorSprites[i].setBattler(members[i]);
      }
    }
    battlerSprites() {
      return this._enemySprites.concat(this._actorSprites);
    }
    isAnimationPlaying() {
      return this.battlerSprites().some((sprite) => sprite.isAnimationPlaying());
    }
    isEffecting() {
      return this.battlerSprites().some((sprite) => sprite.isEffecting());
    }
    isAnyoneMoving() {
      return this.battlerSprites().some((sprite) => sprite.isMoving());
    }
    isBusy() {
      return this.isAnimationPlaying() || this.isAnyoneMoving();
    }
  };
  var Spriteset_Battle_default = Spriteset_Battle;

  // src-www/js/rpg_windows/Window_Base.js
  var Window_Base = class extends Window_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(x, y, width, height) {
      super.initialize();
      this.loadWindowskin();
      this.move(x, y, width, height);
      this.updatePadding();
      this.updateBackOpacity();
      this.updateTone();
      this.createContents();
      this._opening = false;
      this._closing = false;
      this._dimmerSprite = null;
    }
    lineHeight() {
      return 36;
    }
    standardFontFace() {
      if (self.$gameSystem.isChinese()) {
        return "SimHei, Heiti TC, sans-serif";
      } else if (self.$gameSystem.isKorean()) {
        return "Dotum, AppleGothic, sans-serif";
      } else {
        return "GameFont";
      }
    }
    standardFontSize() {
      return 28;
    }
    standardPadding() {
      return 18;
    }
    textPadding() {
      return 6;
    }
    standardBackOpacity() {
      return 192;
    }
    loadWindowskin() {
      this.windowskin = ImageManager_default.loadSystem("Window");
    }
    updatePadding() {
      this.padding = this.standardPadding();
    }
    updateBackOpacity() {
      this.backOpacity = this.standardBackOpacity();
    }
    contentsWidth() {
      return this.width - this.standardPadding() * 2;
    }
    contentsHeight() {
      return this.height - this.standardPadding() * 2;
    }
    fittingHeight(numLines) {
      return numLines * this.lineHeight() + this.standardPadding() * 2;
    }
    updateTone() {
      const tone = self.$gameSystem.windowTone();
      this.setTone(tone[0], tone[1], tone[2]);
    }
    createContents() {
      if (!this.contents) {
        this.contents = new Bitmap_default(this.contentsWidth(), this.contentsHeight());
        this._windowContentsSprite.addChild(this.contents);
      } else {
        this.contents.clear();
      }
      this.resetFontSettings();
    }
    resetFontSettings() {
      this.contents.fontFace = this.standardFontFace();
      this.contents.fontSize = this.standardFontSize();
      this.resetTextColor();
    }
    resetTextColor() {
      this.changeTextColor(this.normalColor());
    }
    update() {
      super.update();
      this.updateTone();
      this.updateOpen();
      this.updateClose();
      this.updateBackgroundDimmer();
    }
    updateOpen() {
      if (this._opening) {
        this.openness += 32;
        if (this.isOpen()) {
          this._opening = false;
        }
      }
    }
    updateClose() {
      if (this._closing) {
        this.openness -= 32;
        if (this.isClosed()) {
          this._closing = false;
        }
      }
    }
    open() {
      if (!this.isOpen()) {
        this._opening = true;
      }
      this._closing = false;
    }
    close() {
      if (!this.isClosed()) {
        this._closing = true;
      }
      this._opening = false;
    }
    isOpening() {
      return this._opening;
    }
    isClosing() {
      return this._closing;
    }
    show() {
      this.visible = true;
    }
    hide() {
      this.visible = false;
    }
    activate() {
      this.active = true;
    }
    deactivate() {
      this.active = false;
    }
    textColor(n) {
      const px = 96 + n % 8 * 12 + 6;
      const py = 144 + Math.floor(n / 8) * 12 + 6;
      if (this.windowskin) {
        return this.windowskin.getPixel(px, py);
      }
      return "0x000000";
    }
    normalColor() {
      return this.textColor(0);
    }
    systemColor() {
      return this.textColor(16);
    }
    crisisColor() {
      return this.textColor(17);
    }
    deathColor() {
      return this.textColor(18);
    }
    gaugeBackColor() {
      return this.textColor(19);
    }
    hpGaugeColor1() {
      return this.textColor(20);
    }
    hpGaugeColor2() {
      return this.textColor(21);
    }
    mpGaugeColor1() {
      return this.textColor(22);
    }
    mpGaugeColor2() {
      return this.textColor(23);
    }
    mpCostColor() {
      return this.textColor(23);
    }
    powerUpColor() {
      return this.textColor(24);
    }
    powerDownColor() {
      return this.textColor(25);
    }
    tpGaugeColor1() {
      return this.textColor(28);
    }
    tpGaugeColor2() {
      return this.textColor(29);
    }
    tpCostColor() {
      return this.textColor(29);
    }
    pendingColor() {
      return this.windowskin.getPixel(120, 120);
    }
    translucentOpacity() {
      return 160;
    }
    changeTextColor(color2) {
      this.contents.textColor = color2;
    }
    changePaintOpacity(enabled) {
      this.contents.paintOpacity = enabled ? 255 : this.translucentOpacity();
    }
    drawText(text, x, y, maxWidth, align) {
      this.contents.drawText(text, x, y, maxWidth, this.lineHeight(), align);
    }
    textWidth(text) {
      return this.contents.measureTextWidth(text);
    }
    drawTextEx(text, x, y) {
      if (text) {
        const textState = {
          index: 0,
          x,
          y,
          left: x
        };
        textState.text = this.convertEscapeCharacters(text);
        textState.height = this.calcTextHeight(textState, false);
        this.resetFontSettings();
        while (textState.index < textState.text.length) {
          this.processCharacter(textState);
        }
        return textState.x - x;
      } else {
        return 0;
      }
    }
    convertEscapeCharacters(text) {
      text = text.replace(/\\/g, "\x1B");
      text = text.replace(/\x1b\x1b/g, "\\");
      text = text.replace(
        /\x1bV\[(\d+)\]/gi,
        function(...args) {
          return self.$gameVariables.value(parseInt(args[1]));
        }.bind(this)
      );
      text = text.replace(
        /\x1bV\[(\d+)\]/gi,
        function(...args) {
          return self.$gameVariables.value(parseInt(args[1]));
        }.bind(this)
      );
      text = text.replace(
        /\x1bN\[(\d+)\]/gi,
        function(...args) {
          return this.actorName(parseInt(args[1]));
        }.bind(this)
      );
      text = text.replace(
        /\x1bP\[(\d+)\]/gi,
        function(...args) {
          return this.partyMemberName(parseInt(args[1]));
        }.bind(this)
      );
      text = text.replace(/\x1bG/gi, TextManager_default.currencyUnit);
      return text;
    }
    actorName(n) {
      const actor2 = n >= 1 ? self.$gameActors.actor(n) : null;
      return actor2 ? actor2.name() : "";
    }
    partyMemberName(n) {
      const actor2 = n >= 1 ? self.$gameParty.members()[n - 1] : null;
      return actor2 ? actor2.name() : "";
    }
    processCharacter(textState) {
      switch (textState.text[textState.index]) {
        case "\n":
          this.processNewLine(textState);
          break;
        case "\f":
          this.processNewPage(textState);
          break;
        case "\x1B":
          this.processEscapeCharacter(
            this.obtainEscapeCode(textState),
            textState
          );
          break;
        default:
          this.processNormalCharacter(textState);
          break;
      }
    }
    processNormalCharacter(textState) {
      const c = textState.text[textState.index++];
      const w = this.textWidth(c);
      this.contents.drawText(
        c,
        textState.x,
        textState.y,
        w * 2,
        textState.height
      );
      textState.x += w;
    }
    processNewLine(textState) {
      textState.x = textState.left;
      textState.y += textState.height;
      textState.height = this.calcTextHeight(textState, false);
      textState.index++;
    }
    processNewPage(textState) {
      textState.index++;
    }
    obtainEscapeCode(textState) {
      textState.index++;
      const regExp = /^[\$\.\|\^!><\{\}\\]|^[A-Z]+/i;
      const arr = regExp.exec(textState.text.slice(textState.index));
      if (arr) {
        textState.index += arr[0].length;
        return arr[0].toUpperCase();
      } else {
        return "";
      }
    }
    obtainEscapeParam(textState) {
      const arr = /^\[\d+\]/.exec(textState.text.slice(textState.index));
      if (arr) {
        textState.index += arr[0].length;
        return parseInt(arr[0].slice(1));
      } else {
        return "";
      }
    }
    processEscapeCharacter(code, textState) {
      switch (code) {
        case "C":
          this.changeTextColor(this.textColor(this.obtainEscapeParam(textState)));
          break;
        case "I":
          this.processDrawIcon(this.obtainEscapeParam(textState), textState);
          break;
        case "{":
          this.makeFontBigger();
          break;
        case "}":
          this.makeFontSmaller();
          break;
      }
    }
    processDrawIcon(iconIndex, textState) {
      this.drawIcon(iconIndex, textState.x + 2, textState.y + 2);
      textState.x += Window_Base._iconWidth + 4;
    }
    makeFontBigger() {
      if (this.contents.fontSize <= 96) {
        this.contents.fontSize += 12;
      }
    }
    makeFontSmaller() {
      if (this.contents.fontSize >= 24) {
        this.contents.fontSize -= 12;
      }
    }
    calcTextHeight({ text, index: index2 }, all) {
      const lastFontSize = this.contents.fontSize;
      let textHeight = 0;
      const lines = text.slice(index2).split("\n");
      const maxLines = all ? lines.length : 1;
      for (let i = 0; i < maxLines; i++) {
        let maxFontSize = this.contents.fontSize;
        const regExp = /\x1b[\{\}]/g;
        for (; ; ) {
          const array = regExp.exec(lines[i]);
          if (array) {
            if (array[0] === "\x1B{") {
              this.makeFontBigger();
            }
            if (array[0] === "\x1B}") {
              this.makeFontSmaller();
            }
            if (maxFontSize < this.contents.fontSize) {
              maxFontSize = this.contents.fontSize;
            }
          } else {
            break;
          }
        }
        textHeight += maxFontSize + 8;
      }
      this.contents.fontSize = lastFontSize;
      return textHeight;
    }
    drawIcon(iconIndex, x, y) {
      const bitmap = ImageManager_default.loadSystem("IconSet");
      const pw = Window_Base._iconWidth;
      const ph = Window_Base._iconHeight;
      const sx = iconIndex % 16 * pw;
      const sy = Math.floor(iconIndex / 16) * ph;
      this.contents.blt(bitmap, sx, sy, pw, ph, x, y);
    }
    drawFace(faceName, faceIndex, x, y, width = Window_Base._faceWidth, height = Window_Base._faceHeight) {
      const bitmap = ImageManager_default.loadFace(faceName);
      const pw = Window_Base._faceWidth;
      const ph = Window_Base._faceHeight;
      const sw = Math.min(width, pw);
      const sh = Math.min(height, ph);
      const dx = Math.floor(x + Math.max(width - pw, 0) / 2);
      const dy = Math.floor(y + Math.max(height - ph, 0) / 2);
      const sx = faceIndex % 4 * pw + (pw - sw) / 2;
      const sy = Math.floor(faceIndex / 4) * ph + (ph - sh) / 2;
      this.contents.blt(bitmap, sx, sy, sw, sh, dx, dy);
    }
    drawCharacter(characterName, characterIndex, x, y) {
      const bitmap = ImageManager_default.loadCharacter(characterName);
      const big = ImageManager_default.isBigCharacter(characterName);
      const pw = bitmap.width / (big ? 3 : 12);
      const ph = bitmap.height / (big ? 4 : 8);
      const n = big ? 0 : characterIndex;
      const sx = (n % 4 * 3 + 1) * pw;
      const sy = Math.floor(n / 4) * 4 * ph;
      this.contents.blt(bitmap, sx, sy, pw, ph, x - pw / 2, y - ph);
    }
    drawGauge(x, y, width, rate, color1, color2) {
      const fillW = Math.floor(width * rate);
      const gaugeY = y + this.lineHeight() - 8;
      this.contents.fillRect(x, gaugeY, width, 6, this.gaugeBackColor());
      this.contents.gradientFillRect(x, gaugeY, fillW, 6, color1, color2);
    }
    hpColor(actor2) {
      if (actor2.isDead()) {
        return this.deathColor();
      } else if (actor2.isDying()) {
        return this.crisisColor();
      } else {
        return this.normalColor();
      }
    }
    mpColor(actor2) {
      return this.normalColor();
    }
    tpColor(actor2) {
      return this.normalColor();
    }
    drawActorCharacter(actor2, x, y) {
      this.drawCharacter(actor2.characterName(), actor2.characterIndex(), x, y);
    }
    drawActorFace(actor2, x, y, width, height) {
      this.drawFace(actor2.faceName(), actor2.faceIndex(), x, y, width, height);
    }
    drawActorName(actor2, x, y, width = 168) {
      this.changeTextColor(this.hpColor(actor2));
      this.drawText(actor2.name(), x, y, width);
    }
    drawActorClass(actor2, x, y, width = 168) {
      this.resetTextColor();
      this.drawText(actor2.currentClass().name, x, y, width);
    }
    drawActorNickname(actor2, x, y, width = 270) {
      this.resetTextColor();
      this.drawText(actor2.nickname(), x, y, width);
    }
    drawActorLevel({ level }, x, y) {
      this.changeTextColor(this.systemColor());
      this.drawText(TextManager_default.levelA, x, y, 48);
      this.resetTextColor();
      this.drawText(level, x + 84, y, 36, "right");
    }
    drawActorIcons(actor2, x, y, width = 144) {
      const icons = actor2.allIcons().slice(0, Math.floor(width / Window_Base._iconWidth));
      for (let i = 0; i < icons.length; i++) {
        this.drawIcon(icons[i], x + Window_Base._iconWidth * i, y + 2);
      }
    }
    drawCurrentAndMax(current, max, x, y, width, color1, color2) {
      const labelWidth = this.textWidth("HP");
      const valueWidth = this.textWidth("0000");
      const slashWidth = this.textWidth("/");
      const x1 = x + width - valueWidth;
      const x2 = x1 - slashWidth;
      const x3 = x2 - valueWidth;
      if (x3 >= x + labelWidth) {
        this.changeTextColor(color1);
        this.drawText(current, x3, y, valueWidth, "right");
        this.changeTextColor(color2);
        this.drawText("/", x2, y, slashWidth, "right");
        this.drawText(max, x1, y, valueWidth, "right");
      } else {
        this.changeTextColor(color1);
        this.drawText(current, x1, y, valueWidth, "right");
      }
    }
    drawActorHp(actor2, x, y, width = 186) {
      const color1 = this.hpGaugeColor1();
      const color2 = this.hpGaugeColor2();
      this.drawGauge(x, y, width, actor2.hpRate(), color1, color2);
      this.changeTextColor(this.systemColor());
      this.drawText(TextManager_default.hpA, x, y, 44);
      this.drawCurrentAndMax(
        actor2.hp,
        actor2.mhp,
        x,
        y,
        width,
        this.hpColor(actor2),
        this.normalColor()
      );
    }
    drawActorMp(actor2, x, y, width = 186) {
      const color1 = this.mpGaugeColor1();
      const color2 = this.mpGaugeColor2();
      this.drawGauge(x, y, width, actor2.mpRate(), color1, color2);
      this.changeTextColor(this.systemColor());
      this.drawText(TextManager_default.mpA, x, y, 44);
      this.drawCurrentAndMax(
        actor2.mp,
        actor2.mmp,
        x,
        y,
        width,
        this.mpColor(actor2),
        this.normalColor()
      );
    }
    drawActorTp(actor2, x, y, width = 96) {
      const color1 = this.tpGaugeColor1();
      const color2 = this.tpGaugeColor2();
      this.drawGauge(x, y, width, actor2.tpRate(), color1, color2);
      this.changeTextColor(this.systemColor());
      this.drawText(TextManager_default.tpA, x, y, 44);
      this.changeTextColor(this.tpColor(actor2));
      this.drawText(actor2.tp, x + width - 64, y, 64, "right");
    }
    drawActorSimpleStatus(actor2, x, y, width) {
      const lineHeight = this.lineHeight();
      const x2 = x + 180;
      const width2 = Math.min(200, width - 180 - this.textPadding());
      this.drawActorName(actor2, x, y);
      this.drawActorLevel(actor2, x, y + lineHeight * 1);
      this.drawActorIcons(actor2, x, y + lineHeight * 2);
      this.drawActorClass(actor2, x2, y);
      this.drawActorHp(actor2, x2, y + lineHeight * 1, width2);
      this.drawActorMp(actor2, x2, y + lineHeight * 2, width2);
    }
    drawItemName(item2, x, y, width = 312) {
      if (item2) {
        const iconBoxWidth = Window_Base._iconWidth + 4;
        this.resetTextColor();
        this.drawIcon(item2.iconIndex, x + 2, y + 2);
        this.drawText(item2.name, x + iconBoxWidth, y, width - iconBoxWidth);
      }
    }
    drawCurrencyValue(value3, unit, x, y, width) {
      const unitWidth = Math.min(80, this.textWidth(unit));
      this.resetTextColor();
      this.drawText(value3, x, y, width - unitWidth - 6, "right");
      this.changeTextColor(this.systemColor());
      this.drawText(unit, x + width - unitWidth, y, unitWidth, "right");
    }
    paramchangeTextColor(change) {
      if (change > 0) {
        return this.powerUpColor();
      } else if (change < 0) {
        return this.powerDownColor();
      } else {
        return this.normalColor();
      }
    }
    setBackgroundType(type) {
      if (type === 0) {
        this.opacity = 255;
      } else {
        this.opacity = 0;
      }
      if (type === 1) {
        this.showBackgroundDimmer();
      } else {
        this.hideBackgroundDimmer();
      }
    }
    showBackgroundDimmer() {
      if (!this._dimmerSprite) {
        this._dimmerSprite = new Sprite_default();
        this._dimmerSprite.bitmap = new Bitmap_default(0, 0);
        this.addChildToBack(this._dimmerSprite);
      }
      const bitmap = this._dimmerSprite.bitmap;
      if (bitmap.width !== this.width || bitmap.height !== this.height) {
        this.refreshDimmerBitmap();
      }
      this._dimmerSprite.visible = true;
      this.updateBackgroundDimmer();
    }
    hideBackgroundDimmer() {
      if (this._dimmerSprite) {
        this._dimmerSprite.visible = false;
      }
    }
    updateBackgroundDimmer() {
      if (this._dimmerSprite) {
        this._dimmerSprite.opacity = this.openness;
      }
    }
    refreshDimmerBitmap() {
      if (this._dimmerSprite) {
        const bitmap = this._dimmerSprite.bitmap;
        const w = this.width;
        const h = this.height;
        const m = this.padding;
        const c1 = this.dimColor1();
        const c2 = this.dimColor2();
        bitmap.resize(w, h);
        bitmap.gradientFillRect(0, 0, w, m, c2, c1, true);
        bitmap.fillRect(0, m, w, h - m * 2, c1);
        bitmap.gradientFillRect(0, h - m, w, m, c1, c2, true);
        this._dimmerSprite.setFrame(0, 0, w, h);
      }
    }
    dimColor1() {
      return "rgba(0, 0, 0, 0.6)";
    }
    dimColor2() {
      return "rgba(0, 0, 0, 0)";
    }
    canvasToLocalX(x) {
      let node = this;
      while (node) {
        x -= node.x;
        node = node.parent;
      }
      return x;
    }
    canvasToLocalY(y) {
      let node = this;
      while (node) {
        y -= node.y;
        node = node.parent;
      }
      return y;
    }
    reserveFaceImages() {
      self.$gameParty.members().forEach((actor2) => {
        ImageManager_default.reserveFace(actor2.faceName());
      }, this);
    }
  };
  Window_Base._iconWidth = 32;
  Window_Base._iconHeight = 32;
  Window_Base._faceWidth = 144;
  Window_Base._faceHeight = 144;
  var Window_Base_default = Window_Base;

  // src-www/js/rpg_windows/Window_Help.js
  var Window_Help = class extends Window_Base_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(numLines) {
      const width = Graphics_default.boxWidth;
      const height = this.fittingHeight(numLines || 2);
      super.initialize(0, 0, width, height);
      this._text = "";
    }
    setText(text) {
      if (this._text !== text) {
        this._text = text;
        this.refresh();
      }
    }
    clear() {
      this.setText("");
    }
    setItem(item2) {
      this.setText(item2 ? item2.description : "");
    }
    refresh() {
      this.contents.clear();
      this.drawTextEx(this._text, this.textPadding(), 0);
    }
  };
  var Window_Help_default = Window_Help;

  // src-www/js/rpg_windows/Window_Gold.js
  var Window_Gold = class extends Window_Base_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(x, y) {
      const width = this.windowWidth();
      const height = this.windowHeight();
      super.initialize(x, y, width, height);
      this.refresh();
    }
    windowWidth() {
      return 240;
    }
    windowHeight() {
      return this.fittingHeight(1);
    }
    refresh() {
      const x = this.textPadding();
      const width = this.contents.width - this.textPadding() * 2;
      this.contents.clear();
      this.drawCurrencyValue(this.value(), this.currencyUnit(), x, 0, width);
    }
    value() {
      return self.$gameParty.gold();
    }
    currencyUnit() {
      return TextManager_default.currencyUnit;
    }
    open() {
      this.refresh();
      super.open();
    }
  };
  var Window_Gold_default = Window_Gold;

  // src-www/js/rpg_windows/Window_Selectable.js
  var Window_Selectable = class extends Window_Base_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(x, y, width, height) {
      super.initialize(x, y, width, height);
      this._index = -1;
      this._cursorFixed = false;
      this._cursorAll = false;
      this._stayCount = 0;
      this._helpWindow = null;
      this._handlers = {};
      this._touching = false;
      this._scrollX = 0;
      this._scrollY = 0;
      this.deactivate();
    }
    index() {
      return this._index;
    }
    cursorFixed() {
      return this._cursorFixed;
    }
    setCursorFixed(cursorFixed) {
      this._cursorFixed = cursorFixed;
    }
    cursorAll() {
      return this._cursorAll;
    }
    setCursorAll(cursorAll) {
      this._cursorAll = cursorAll;
    }
    maxCols() {
      return 1;
    }
    maxItems() {
      return 0;
    }
    spacing() {
      return 12;
    }
    itemWidth() {
      return Math.floor(
        (this.width - this.padding * 2 + this.spacing()) / this.maxCols() - this.spacing()
      );
    }
    itemHeight() {
      return this.lineHeight();
    }
    maxRows() {
      return Math.max(Math.ceil(this.maxItems() / this.maxCols()), 1);
    }
    activate() {
      super.activate();
      this.reselect();
    }
    deactivate() {
      super.deactivate();
      this.reselect();
    }
    select(index2) {
      this._index = index2;
      this._stayCount = 0;
      this.ensureCursorVisible();
      this.updateCursor();
      this.callUpdateHelp();
    }
    deselect() {
      this.select(-1);
    }
    reselect() {
      this.select(this._index);
    }
    row() {
      return Math.floor(this.index() / this.maxCols());
    }
    topRow() {
      return Math.floor(this._scrollY / this.itemHeight());
    }
    maxTopRow() {
      return Math.max(0, this.maxRows() - this.maxPageRows());
    }
    setTopRow(row) {
      const scrollY = row.clamp(0, this.maxTopRow()) * this.itemHeight();
      if (this._scrollY !== scrollY) {
        this._scrollY = scrollY;
        this.refresh();
        this.updateCursor();
      }
    }
    resetScroll() {
      this.setTopRow(0);
    }
    maxPageRows() {
      const pageHeight = this.height - this.padding * 2;
      return Math.floor(pageHeight / this.itemHeight());
    }
    maxPageItems() {
      return this.maxPageRows() * this.maxCols();
    }
    isHorizontal() {
      return this.maxPageRows() === 1;
    }
    bottomRow() {
      return Math.max(0, this.topRow() + this.maxPageRows() - 1);
    }
    setBottomRow(row) {
      this.setTopRow(row - (this.maxPageRows() - 1));
    }
    topIndex() {
      return this.topRow() * this.maxCols();
    }
    itemRect(index2) {
      const rect = new Rectangle_default();
      const maxCols = this.maxCols();
      rect.width = this.itemWidth();
      rect.height = this.itemHeight();
      rect.x = index2 % maxCols * (rect.width + this.spacing()) - this._scrollX;
      rect.y = Math.floor(index2 / maxCols) * rect.height - this._scrollY;
      return rect;
    }
    itemRectForText(index2) {
      const rect = this.itemRect(index2);
      rect.x += this.textPadding();
      rect.width -= this.textPadding() * 2;
      return rect;
    }
    setHelpWindow(helpWindow) {
      this._helpWindow = helpWindow;
      this.callUpdateHelp();
    }
    showHelpWindow() {
      if (this._helpWindow) {
        this._helpWindow.show();
      }
    }
    hideHelpWindow() {
      if (this._helpWindow) {
        this._helpWindow.hide();
      }
    }
    setHandler(symbol, method) {
      this._handlers[symbol] = method;
    }
    isHandled(symbol) {
      return !!this._handlers[symbol];
    }
    callHandler(symbol) {
      if (this.isHandled(symbol)) {
        this._handlers[symbol]();
      }
    }
    isOpenAndActive() {
      return this.isOpen() && this.active;
    }
    isCursorMovable() {
      return this.isOpenAndActive() && !this._cursorFixed && !this._cursorAll && this.maxItems() > 0;
    }
    cursorDown(wrap) {
      const index2 = this.index();
      const maxItems = this.maxItems();
      const maxCols = this.maxCols();
      if (index2 < maxItems - maxCols || wrap && maxCols === 1) {
        this.select((index2 + maxCols) % maxItems);
      }
    }
    cursorUp(wrap) {
      const index2 = this.index();
      const maxItems = this.maxItems();
      const maxCols = this.maxCols();
      if (index2 >= maxCols || wrap && maxCols === 1) {
        this.select((index2 - maxCols + maxItems) % maxItems);
      }
    }
    cursorRight(wrap) {
      const index2 = this.index();
      const maxItems = this.maxItems();
      const maxCols = this.maxCols();
      if (maxCols >= 2 && (index2 < maxItems - 1 || wrap && this.isHorizontal())) {
        this.select((index2 + 1) % maxItems);
      }
    }
    cursorLeft(wrap) {
      const index2 = this.index();
      const maxItems = this.maxItems();
      const maxCols = this.maxCols();
      if (maxCols >= 2 && (index2 > 0 || wrap && this.isHorizontal())) {
        this.select((index2 - 1 + maxItems) % maxItems);
      }
    }
    cursorPagedown() {
      const index2 = this.index();
      const maxItems = this.maxItems();
      if (this.topRow() + this.maxPageRows() < this.maxRows()) {
        this.setTopRow(this.topRow() + this.maxPageRows());
        this.select(Math.min(index2 + this.maxPageItems(), maxItems - 1));
      }
    }
    cursorPageup() {
      const index2 = this.index();
      if (this.topRow() > 0) {
        this.setTopRow(this.topRow() - this.maxPageRows());
        this.select(Math.max(index2 - this.maxPageItems(), 0));
      }
    }
    scrollDown() {
      if (this.topRow() + 1 < this.maxRows()) {
        this.setTopRow(this.topRow() + 1);
      }
    }
    scrollUp() {
      if (this.topRow() > 0) {
        this.setTopRow(this.topRow() - 1);
      }
    }
    update() {
      super.update();
      this.updateArrows();
      this.processCursorMove();
      this.processHandling();
      this.processWheel();
      this.processTouch();
      this._stayCount++;
    }
    updateArrows() {
      const topRow = this.topRow();
      const maxTopRow = this.maxTopRow();
      this.downArrowVisible = maxTopRow > 0 && topRow < maxTopRow;
      this.upArrowVisible = topRow > 0;
    }
    processCursorMove() {
      if (this.isCursorMovable()) {
        const lastIndex = this.index();
        if (Input_default.isRepeated("down")) {
          this.cursorDown(Input_default.isTriggered("down"));
        }
        if (Input_default.isRepeated("up")) {
          this.cursorUp(Input_default.isTriggered("up"));
        }
        if (Input_default.isRepeated("right")) {
          this.cursorRight(Input_default.isTriggered("right"));
        }
        if (Input_default.isRepeated("left")) {
          this.cursorLeft(Input_default.isTriggered("left"));
        }
        if (!this.isHandled("pagedown") && Input_default.isTriggered("pagedown")) {
          this.cursorPagedown();
        }
        if (!this.isHandled("pageup") && Input_default.isTriggered("pageup")) {
          this.cursorPageup();
        }
        if (this.index() !== lastIndex) {
          SoundManager_default.playCursor();
        }
      }
    }
    processHandling() {
      if (this.isOpenAndActive()) {
        if (this.isOkEnabled() && this.isOkTriggered()) {
          this.processOk();
        } else if (this.isCancelEnabled() && this.isCancelTriggered()) {
          this.processCancel();
        } else if (this.isHandled("pagedown") && Input_default.isTriggered("pagedown")) {
          this.processPagedown();
        } else if (this.isHandled("pageup") && Input_default.isTriggered("pageup")) {
          this.processPageup();
        }
      }
    }
    processWheel() {
      if (this.isOpenAndActive()) {
        const threshold = 20;
        if (TouchInput_default.wheelY >= threshold) {
          this.scrollDown();
        }
        if (TouchInput_default.wheelY <= -threshold) {
          this.scrollUp();
        }
      }
    }
    processTouch() {
      if (this.isOpenAndActive()) {
        if (TouchInput_default.isTriggered() && this.isTouchedInsideFrame()) {
          this._touching = true;
          this.onTouch(true);
        } else if (TouchInput_default.isCancelled()) {
          if (this.isCancelEnabled()) {
            this.processCancel();
          }
        }
        if (this._touching) {
          if (TouchInput_default.isPressed()) {
            this.onTouch(false);
          } else {
            this._touching = false;
          }
        }
      } else {
        this._touching = false;
      }
    }
    isTouchedInsideFrame() {
      const x = this.canvasToLocalX(TouchInput_default.x);
      const y = this.canvasToLocalY(TouchInput_default.y);
      return x >= 0 && y >= 0 && x < this.width && y < this.height;
    }
    onTouch(triggered) {
      const lastIndex = this.index();
      const x = this.canvasToLocalX(TouchInput_default.x);
      const y = this.canvasToLocalY(TouchInput_default.y);
      const hitIndex = this.hitTest(x, y);
      if (hitIndex >= 0) {
        if (hitIndex === this.index()) {
          if (triggered && this.isTouchOkEnabled()) {
            this.processOk();
          }
        } else if (this.isCursorMovable()) {
          this.select(hitIndex);
        }
      } else if (this._stayCount >= 10) {
        if (y < this.padding) {
          this.cursorUp();
        } else if (y >= this.height - this.padding) {
          this.cursorDown();
        }
      }
      if (this.index() !== lastIndex) {
        SoundManager_default.playCursor();
      }
    }
    hitTest(x, y) {
      if (this.isContentsArea(x, y)) {
        const cx = x - this.padding;
        const cy = y - this.padding;
        const topIndex = this.topIndex();
        for (let i = 0; i < this.maxPageItems(); i++) {
          const index2 = topIndex + i;
          if (index2 < this.maxItems()) {
            const rect = this.itemRect(index2);
            const right = rect.x + rect.width;
            const bottom = rect.y + rect.height;
            if (cx >= rect.x && cy >= rect.y && cx < right && cy < bottom) {
              return index2;
            }
          }
        }
      }
      return -1;
    }
    isContentsArea(x, y) {
      const left = this.padding;
      const top = this.padding;
      const right = this.width - this.padding;
      const bottom = this.height - this.padding;
      return x >= left && y >= top && x < right && y < bottom;
    }
    isTouchOkEnabled() {
      return this.isOkEnabled();
    }
    isOkEnabled() {
      return this.isHandled("ok");
    }
    isCancelEnabled() {
      return this.isHandled("cancel");
    }
    isOkTriggered() {
      return Input_default.isRepeated("ok");
    }
    isCancelTriggered() {
      return Input_default.isRepeated("cancel");
    }
    processOk() {
      if (this.isCurrentItemEnabled()) {
        this.playOkSound();
        this.updateInputData();
        this.deactivate();
        this.callOkHandler();
      } else {
        this.playBuzzerSound();
      }
    }
    playOkSound() {
      SoundManager_default.playOk();
    }
    playBuzzerSound() {
      SoundManager_default.playBuzzer();
    }
    callOkHandler() {
      this.callHandler("ok");
    }
    processCancel() {
      SoundManager_default.playCancel();
      this.updateInputData();
      this.deactivate();
      this.callCancelHandler();
    }
    callCancelHandler() {
      this.callHandler("cancel");
    }
    processPageup() {
      SoundManager_default.playCursor();
      this.updateInputData();
      this.deactivate();
      this.callHandler("pageup");
    }
    processPagedown() {
      SoundManager_default.playCursor();
      this.updateInputData();
      this.deactivate();
      this.callHandler("pagedown");
    }
    updateInputData() {
      Input_default.update();
      TouchInput_default.update();
    }
    updateCursor() {
      if (this._cursorAll) {
        const allRowsHeight = this.maxRows() * this.itemHeight();
        this.setCursorRect(0, 0, this.contents.width, allRowsHeight);
        this.setTopRow(0);
      } else if (this.isCursorVisible()) {
        const rect = this.itemRect(this.index());
        this.setCursorRect(rect.x, rect.y, rect.width, rect.height);
      } else {
        this.setCursorRect(0, 0, 0, 0);
      }
    }
    isCursorVisible() {
      const row = this.row();
      return row >= this.topRow() && row <= this.bottomRow();
    }
    ensureCursorVisible() {
      const row = this.row();
      if (row < this.topRow()) {
        this.setTopRow(row);
      } else if (row > this.bottomRow()) {
        this.setBottomRow(row);
      }
    }
    callUpdateHelp() {
      if (this.active && this._helpWindow) {
        this.updateHelp();
      }
    }
    updateHelp() {
      this._helpWindow.clear();
    }
    setHelpWindowItem(item2) {
      if (this._helpWindow) {
        this._helpWindow.setItem(item2);
      }
    }
    isCurrentItemEnabled() {
      return true;
    }
    drawAllItems() {
      const topIndex = this.topIndex();
      for (let i = 0; i < this.maxPageItems(); i++) {
        const index2 = topIndex + i;
        if (index2 < this.maxItems()) {
          this.drawItem(index2);
        }
      }
    }
    drawItem(index2) {
    }
    clearItem(index2) {
      const rect = this.itemRect(index2);
      this.contents.clearRect(rect.x, rect.y, rect.width, rect.height);
    }
    redrawItem(index2) {
      if (index2 >= 0) {
        this.clearItem(index2);
        this.drawItem(index2);
      }
    }
    redrawCurrentItem() {
      this.redrawItem(this.index());
    }
    refresh() {
      if (this.contents) {
        this.contents.clear();
        this.drawAllItems();
      }
    }
  };
  var Window_Selectable_default = Window_Selectable;

  // src-www/js/rpg_windows/Window_Command.js
  var Window_Command = class extends Window_Selectable_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(x, y) {
      this.clearCommandList();
      this.makeCommandList();
      const width = this.windowWidth();
      const height = this.windowHeight();
      super.initialize(x, y, width, height);
      this.refresh();
      this.select(0);
      this.activate();
    }
    windowWidth() {
      return 240;
    }
    windowHeight() {
      return this.fittingHeight(this.numVisibleRows());
    }
    numVisibleRows() {
      return Math.ceil(this.maxItems() / this.maxCols());
    }
    maxItems() {
      return this._list.length;
    }
    clearCommandList() {
      this._list = [];
    }
    makeCommandList() {
    }
    addCommand(name, symbol, enabled, ext) {
      if (enabled === void 0) {
        enabled = true;
      }
      if (ext === void 0) {
        ext = null;
      }
      this._list.push({
        name,
        symbol,
        enabled,
        ext
      });
    }
    commandName(index2) {
      return this._list[index2].name;
    }
    commandSymbol(index2) {
      return this._list[index2].symbol;
    }
    isCommandEnabled(index2) {
      return this._list[index2].enabled;
    }
    currentData() {
      return this.index() >= 0 ? this._list[this.index()] : null;
    }
    isCurrentItemEnabled() {
      return this.currentData() ? this.currentData().enabled : false;
    }
    currentSymbol() {
      return this.currentData() ? this.currentData().symbol : null;
    }
    currentExt() {
      return this.currentData() ? this.currentData().ext : null;
    }
    findSymbol(symbol) {
      for (let i = 0; i < this._list.length; i++) {
        if (this._list[i].symbol === symbol) {
          return i;
        }
      }
      return -1;
    }
    selectSymbol(symbol) {
      const index2 = this.findSymbol(symbol);
      if (index2 >= 0) {
        this.select(index2);
      } else {
        this.select(0);
      }
    }
    findExt(ext) {
      for (let i = 0; i < this._list.length; i++) {
        if (this._list[i].ext === ext) {
          return i;
        }
      }
      return -1;
    }
    selectExt(ext) {
      const index2 = this.findExt(ext);
      if (index2 >= 0) {
        this.select(index2);
      } else {
        this.select(0);
      }
    }
    drawItem(index2) {
      const rect = this.itemRectForText(index2);
      const align = this.itemTextAlign();
      this.resetTextColor();
      this.changePaintOpacity(this.isCommandEnabled(index2));
      this.drawText(this.commandName(index2), rect.x, rect.y, rect.width, align);
    }
    itemTextAlign() {
      return "left";
    }
    isOkEnabled() {
      return true;
    }
    callOkHandler() {
      const symbol = this.currentSymbol();
      if (this.isHandled(symbol)) {
        this.callHandler(symbol);
      } else if (this.isHandled("ok")) {
        super.callOkHandler();
      } else {
        this.activate();
      }
    }
    refresh() {
      this.clearCommandList();
      this.makeCommandList();
      this.createContents();
      super.refresh();
    }
  };
  var Window_Command_default = Window_Command;

  // src-www/js/rpg_windows/Window_ChoiceList.js
  var Window_ChoiceList = class extends Window_Command_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(messageWindow) {
      this._messageWindow = messageWindow;
      super.initialize(0, 0);
      this.openness = 0;
      this.deactivate();
      this._background = 0;
    }
    start() {
      this.updatePlacement();
      this.updateBackground();
      this.refresh();
      this.selectDefault();
      this.open();
      this.activate();
    }
    selectDefault() {
      this.select(self.$gameMessage.choiceDefaultType());
    }
    updatePlacement() {
      const positionType = self.$gameMessage.choicePositionType();
      const messageY = this._messageWindow.y;
      this.width = this.windowWidth();
      this.height = this.windowHeight();
      switch (positionType) {
        case 0:
          this.x = 0;
          break;
        case 1:
          this.x = (Graphics_default.boxWidth - this.width) / 2;
          break;
        case 2:
          this.x = Graphics_default.boxWidth - this.width;
          break;
      }
      if (messageY >= Graphics_default.boxHeight / 2) {
        this.y = messageY - this.height;
      } else {
        this.y = messageY + this._messageWindow.height;
      }
    }
    updateBackground() {
      this._background = self.$gameMessage.choiceBackground();
      this.setBackgroundType(this._background);
    }
    windowWidth() {
      const width = this.maxChoiceWidth() + this.padding * 2;
      return Math.min(width, Graphics_default.boxWidth);
    }
    numVisibleRows() {
      const messageY = this._messageWindow.y;
      const messageHeight = this._messageWindow.height;
      const centerY = Graphics_default.boxHeight / 2;
      const choices = self.$gameMessage.choices();
      let numLines = choices.length;
      let maxLines = 8;
      if (messageY < centerY && messageY + messageHeight > centerY) {
        maxLines = 4;
      }
      if (numLines > maxLines) {
        numLines = maxLines;
      }
      return numLines;
    }
    maxChoiceWidth() {
      let maxWidth = 96;
      const choices = self.$gameMessage.choices();
      for (let i = 0; i < choices.length; i++) {
        const choiceWidth = this.textWidthEx(choices[i]) + this.textPadding() * 2;
        if (maxWidth < choiceWidth) {
          maxWidth = choiceWidth;
        }
      }
      return maxWidth;
    }
    textWidthEx(text) {
      return this.drawTextEx(text, 0, this.contents.height);
    }
    contentsHeight() {
      return this.maxItems() * this.itemHeight();
    }
    makeCommandList() {
      const choices = self.$gameMessage.choices();
      for (let i = 0; i < choices.length; i++) {
        this.addCommand(choices[i], "choice");
      }
    }
    drawItem(index2) {
      const rect = this.itemRectForText(index2);
      this.drawTextEx(this.commandName(index2), rect.x, rect.y);
    }
    isCancelEnabled() {
      return self.$gameMessage.choiceCancelType() !== -1;
    }
    isOkTriggered() {
      return Input_default.isTriggered("ok");
    }
    callOkHandler() {
      self.$gameMessage.onChoice(this.index());
      this._messageWindow.terminateMessage();
      this.close();
    }
    callCancelHandler() {
      self.$gameMessage.onChoice(self.$gameMessage.choiceCancelType());
      this._messageWindow.terminateMessage();
      this.close();
    }
  };
  var Window_ChoiceList_default = Window_ChoiceList;

  // src-www/js/rpg_sprites/Sprite_Button.js
  var Sprite_Button = class extends Sprite_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
      this._touching = false;
      this._coldFrame = null;
      this._hotFrame = null;
      this._clickHandler = null;
    }
    update() {
      super.update();
      this.updateFrame();
      this.processTouch();
    }
    updateFrame() {
      let frame;
      if (this._touching) {
        frame = this._hotFrame;
      } else {
        frame = this._coldFrame;
      }
      if (frame) {
        this.setFrame(frame.x, frame.y, frame.width, frame.height);
      }
    }
    setColdFrame(x, y, width, height) {
      this._coldFrame = new Rectangle_default(x, y, width, height);
    }
    setHotFrame(x, y, width, height) {
      this._hotFrame = new Rectangle_default(x, y, width, height);
    }
    setClickHandler(method) {
      this._clickHandler = method;
    }
    callClickHandler() {
      if (this._clickHandler) {
        this._clickHandler();
      }
    }
    processTouch() {
      if (this.isActive()) {
        if (TouchInput_default.isTriggered() && this.isButtonTouched()) {
          this._touching = true;
        }
        if (this._touching) {
          if (TouchInput_default.isReleased() || !this.isButtonTouched()) {
            this._touching = false;
            if (TouchInput_default.isReleased()) {
              this.callClickHandler();
            }
          }
        }
      } else {
        this._touching = false;
      }
    }
    isActive() {
      let node = this;
      while (node) {
        if (!node.visible) {
          return false;
        }
        node = node.parent;
      }
      return true;
    }
    isButtonTouched() {
      const x = this.canvasToLocalX(TouchInput_default.x);
      const y = this.canvasToLocalY(TouchInput_default.y);
      return x >= 0 && y >= 0 && x < this.width && y < this.height;
    }
    canvasToLocalX(x) {
      let node = this;
      while (node) {
        x -= node.x;
        node = node.parent;
      }
      return x;
    }
    canvasToLocalY(y) {
      let node = this;
      while (node) {
        y -= node.y;
        node = node.parent;
      }
      return y;
    }
  };
  var Sprite_Button_default = Sprite_Button;

  // src-www/js/rpg_windows/Window_NumberInput.js
  var Window_NumberInput = class extends Window_Selectable_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(messageWindow) {
      this._messageWindow = messageWindow;
      super.initialize(0, 0, 0, 0);
      this._number = 0;
      this._maxDigits = 1;
      this.openness = 0;
      this.createButtons();
      this.deactivate();
    }
    start() {
      this._maxDigits = self.$gameMessage.numInputMaxDigits();
      this._number = self.$gameVariables.value(
        self.$gameMessage.numInputVariableId()
      );
      this._number = this._number.clamp(0, Math.pow(10, this._maxDigits) - 1);
      this.updatePlacement();
      this.placeButtons();
      this.updateButtonsVisiblity();
      this.createContents();
      this.refresh();
      this.open();
      this.activate();
      this.select(0);
    }
    updatePlacement() {
      const messageY = this._messageWindow.y;
      const spacing = 8;
      this.width = this.windowWidth();
      this.height = this.windowHeight();
      this.x = (Graphics_default.boxWidth - this.width) / 2;
      if (messageY >= Graphics_default.boxHeight / 2) {
        this.y = messageY - this.height - spacing;
      } else {
        this.y = messageY + this._messageWindow.height + spacing;
      }
    }
    windowWidth() {
      return this.maxCols() * this.itemWidth() + this.padding * 2;
    }
    windowHeight() {
      return this.fittingHeight(1);
    }
    maxCols() {
      return this._maxDigits;
    }
    maxItems() {
      return this._maxDigits;
    }
    spacing() {
      return 0;
    }
    itemWidth() {
      return 32;
    }
    createButtons() {
      const bitmap = ImageManager_default.loadSystem("ButtonSet");
      const buttonWidth = 48;
      const buttonHeight = 48;
      this._buttons = [];
      for (let i = 0; i < 3; i++) {
        const button = new Sprite_Button_default();
        const x = buttonWidth * [1, 2, 4][i];
        const w = buttonWidth * (i === 2 ? 2 : 1);
        button.bitmap = bitmap;
        button.setColdFrame(x, 0, w, buttonHeight);
        button.setHotFrame(x, buttonHeight, w, buttonHeight);
        button.visible = false;
        this._buttons.push(button);
        this.addChild(button);
      }
      this._buttons[0].setClickHandler(this.onButtonDown.bind(this));
      this._buttons[1].setClickHandler(this.onButtonUp.bind(this));
      this._buttons[2].setClickHandler(this.onButtonOk.bind(this));
    }
    placeButtons() {
      const numButtons = this._buttons.length;
      const spacing = 16;
      let totalWidth = -spacing;
      for (let i = 0; i < numButtons; i++) {
        totalWidth += this._buttons[i].width + spacing;
      }
      let x = (this.width - totalWidth) / 2;
      for (let j = 0; j < numButtons; j++) {
        const button = this._buttons[j];
        button.x = x;
        button.y = this.buttonY();
        x += button.width + spacing;
      }
    }
    updateButtonsVisiblity() {
      if (TouchInput_default.date > Input_default.date) {
        this.showButtons();
      } else {
        this.hideButtons();
      }
    }
    showButtons() {
      for (let i = 0; i < this._buttons.length; i++) {
        this._buttons[i].visible = true;
      }
    }
    hideButtons() {
      for (let i = 0; i < this._buttons.length; i++) {
        this._buttons[i].visible = false;
      }
    }
    buttonY() {
      const spacing = 8;
      if (this._messageWindow.y >= Graphics_default.boxHeight / 2) {
        return 0 - this._buttons[0].height - spacing;
      } else {
        return this.height + spacing;
      }
    }
    update() {
      super.update();
      this.processDigitChange();
    }
    processDigitChange() {
      if (this.isOpenAndActive()) {
        if (Input_default.isRepeated("up")) {
          this.changeDigit(true);
        } else if (Input_default.isRepeated("down")) {
          this.changeDigit(false);
        }
      }
    }
    changeDigit(up) {
      const index2 = this.index();
      const place = Math.pow(10, this._maxDigits - 1 - index2);
      let n = Math.floor(this._number / place) % 10;
      this._number -= n * place;
      if (up) {
        n = (n + 1) % 10;
      } else {
        n = (n + 9) % 10;
      }
      this._number += n * place;
      this.refresh();
      SoundManager_default.playCursor();
    }
    isTouchOkEnabled() {
      return false;
    }
    isOkEnabled() {
      return true;
    }
    isCancelEnabled() {
      return false;
    }
    isOkTriggered() {
      return Input_default.isTriggered("ok");
    }
    processOk() {
      SoundManager_default.playOk();
      self.$gameVariables.setValue(
        self.$gameMessage.numInputVariableId(),
        this._number
      );
      this._messageWindow.terminateMessage();
      this.updateInputData();
      this.deactivate();
      this.close();
    }
    drawItem(index2) {
      const rect = this.itemRect(index2);
      const align = "center";
      const s = this._number.padZero(this._maxDigits);
      const c = s.slice(index2, index2 + 1);
      this.resetTextColor();
      this.drawText(c, rect.x, rect.y, rect.width, align);
    }
    onButtonUp() {
      this.changeDigit(true);
    }
    onButtonDown() {
      this.changeDigit(false);
    }
    onButtonOk() {
      this.processOk();
      this.hideButtons();
    }
  };
  var Window_NumberInput_default = Window_NumberInput;

  // src-www/js/rpg_windows/Window_ItemList.js
  var Window_ItemList = class extends Window_Selectable_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(x, y, width, height) {
      super.initialize(x, y, width, height);
      this._category = "none";
      this._data = [];
    }
    setCategory(category) {
      if (this._category !== category) {
        this._category = category;
        this.refresh();
        this.resetScroll();
      }
    }
    maxCols() {
      return 2;
    }
    spacing() {
      return 48;
    }
    maxItems() {
      return this._data ? this._data.length : 1;
    }
    item() {
      const index2 = this.index();
      return this._data && index2 >= 0 ? this._data[index2] : null;
    }
    isCurrentItemEnabled() {
      return this.isEnabled(this.item());
    }
    includes(item2) {
      switch (this._category) {
        case "item":
          return DataManager2.isItem(item2) && item2.itypeId === 1;
        case "weapon":
          return DataManager2.isWeapon(item2);
        case "armor":
          return DataManager2.isArmor(item2);
        case "keyItem":
          return DataManager2.isItem(item2) && item2.itypeId === 2;
        default:
          return false;
      }
    }
    needsNumber() {
      return true;
    }
    isEnabled(item2) {
      return self.$gameParty.canUse(item2);
    }
    makeItemList() {
      this._data = self.$gameParty.allItems().filter(function(item2) {
        return this.includes(item2);
      }, this);
      if (this.includes(null)) {
        this._data.push(null);
      }
    }
    selectLast() {
      const index2 = this._data.indexOf(self.$gameParty.lastItem());
      this.select(index2 >= 0 ? index2 : 0);
    }
    drawItem(index2) {
      const item2 = this._data[index2];
      if (item2) {
        const numberWidth = this.numberWidth();
        const rect = this.itemRect(index2);
        rect.width -= this.textPadding();
        this.changePaintOpacity(this.isEnabled(item2));
        this.drawItemName(item2, rect.x, rect.y, rect.width - numberWidth);
        this.drawItemNumber(item2, rect.x, rect.y, rect.width);
        this.changePaintOpacity(1);
      }
    }
    numberWidth() {
      return this.textWidth("000");
    }
    drawItemNumber(item2, x, y, width) {
      if (this.needsNumber()) {
        this.drawText(":", x, y, width - this.textWidth("00"), "right");
        this.drawText(self.$gameParty.numItems(item2), x, y, width, "right");
      }
    }
    updateHelp() {
      this.setHelpWindowItem(this.item());
    }
    refresh() {
      this.makeItemList();
      this.createContents();
      this.drawAllItems();
    }
  };
  var Window_ItemList_default = Window_ItemList;

  // src-www/js/rpg_windows/Window_EventItem.js
  var Window_EventItem = class extends Window_ItemList_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(messageWindow) {
      this._messageWindow = messageWindow;
      const width = Graphics_default.boxWidth;
      const height = this.windowHeight();
      super.initialize(0, 0, width, height);
      this.openness = 0;
      this.deactivate();
      this.setHandler("ok", this.onOk.bind(this));
      this.setHandler("cancel", this.onCancel.bind(this));
    }
    windowHeight() {
      return this.fittingHeight(this.numVisibleRows());
    }
    numVisibleRows() {
      return 4;
    }
    start() {
      this.refresh();
      this.updatePlacement();
      this.select(0);
      this.open();
      this.activate();
    }
    updatePlacement() {
      if (this._messageWindow.y >= Graphics_default.boxHeight / 2) {
        this.y = 0;
      } else {
        this.y = Graphics_default.boxHeight - this.height;
      }
    }
    includes(item2) {
      const itypeId = self.$gameMessage.itemChoiceItypeId();
      return DataManager2.isItem(item2) && item2.itypeId === itypeId;
    }
    isEnabled(item2) {
      return true;
    }
    onOk() {
      const item2 = this.item();
      const itemId = item2 ? item2.id : 0;
      self.$gameVariables.setValue(
        self.$gameMessage.itemChoiceVariableId(),
        itemId
      );
      this._messageWindow.terminateMessage();
      this.close();
    }
    onCancel() {
      self.$gameVariables.setValue(self.$gameMessage.itemChoiceVariableId(), 0);
      this._messageWindow.terminateMessage();
      this.close();
    }
  };
  var Window_EventItem_default = Window_EventItem;

  // src-www/js/rpg_windows/Window_Message.js
  var Window_Message = class extends Window_Base_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      const width = this.windowWidth();
      const height = this.windowHeight();
      const x = (Graphics_default.boxWidth - width) / 2;
      super.initialize(x, 0, width, height);
      this.openness = 0;
      this.initMembers();
      this.createSubWindows();
      this.updatePlacement();
    }
    initMembers() {
      this._imageReservationId = Utils_default.generateRuntimeId();
      this._background = 0;
      this._positionType = 2;
      this._waitCount = 0;
      this._faceBitmap = null;
      this._textState = null;
      this.clearFlags();
    }
    subWindows() {
      return [
        this._goldWindow,
        this._choiceWindow,
        this._numberWindow,
        this._itemWindow
      ];
    }
    createSubWindows() {
      this._goldWindow = new Window_Gold_default(0, 0);
      this._goldWindow.x = Graphics_default.boxWidth - this._goldWindow.width;
      this._goldWindow.openness = 0;
      this._choiceWindow = new Window_ChoiceList_default(this);
      this._numberWindow = new Window_NumberInput_default(this);
      this._itemWindow = new Window_EventItem_default(this);
    }
    windowWidth() {
      return Graphics_default.boxWidth;
    }
    windowHeight() {
      return this.fittingHeight(this.numVisibleRows());
    }
    clearFlags() {
      this._showFast = false;
      this._lineShowFast = false;
      this._pauseSkip = false;
      this._textSpeed = 0;
      this._textSpeedCount = 0;
    }
    numVisibleRows() {
      return 4;
    }
    update() {
      this.checkToNotClose();
      super.update();
      while (!this.isOpening() && !this.isClosing()) {
        if (this.updateWait()) {
          return;
        } else if (this.updateLoading()) {
          return;
        } else if (this.updateInput()) {
          return;
        } else if (this.updateMessage()) {
          return;
        } else if (this.canStart()) {
          this.startMessage();
        } else {
          this.startInput();
          return;
        }
      }
    }
    checkToNotClose() {
      if (this.isClosing() && this.isOpen()) {
        if (this.doesContinue()) {
          this.open();
        }
      }
    }
    canStart() {
      return self.$gameMessage.hasText() && !self.$gameMessage.scrollMode();
    }
    startMessage() {
      this._textState = {};
      this._textState.index = 0;
      this._textState.text = this.convertEscapeCharacters(
        self.$gameMessage.allText()
      );
      this.newPage(this._textState);
      this.updatePlacement();
      this.updateBackground();
      this.open();
    }
    updatePlacement() {
      this._positionType = self.$gameMessage.positionType();
      this.y = this._positionType * (Graphics_default.boxHeight - this.height) / 2;
      this._goldWindow.y = this.y > 0 ? 0 : Graphics_default.boxHeight - this._goldWindow.height;
    }
    updateBackground() {
      this._background = self.$gameMessage.background();
      this.setBackgroundType(this._background);
    }
    terminateMessage() {
      this.close();
      this._goldWindow.close();
      self.$gameMessage.clear();
    }
    updateWait() {
      if (this._waitCount > 0) {
        this._waitCount--;
        return true;
      } else {
        return false;
      }
    }
    updateLoading() {
      if (this._faceBitmap) {
        if (this._faceBitmap.isReady()) {
          this.drawMessageFace();
          this._faceBitmap = null;
          return false;
        } else {
          return true;
        }
      } else {
        return false;
      }
    }
    updateInput() {
      if (this.isAnySubWindowActive()) {
        return true;
      }
      if (this.pause) {
        if (this.isTriggered()) {
          Input_default.update();
          this.pause = false;
          if (!this._textState) {
            this.terminateMessage();
          }
        }
        return true;
      }
      return false;
    }
    isAnySubWindowActive() {
      return this._choiceWindow.active || this._numberWindow.active || this._itemWindow.active;
    }
    updateMessage() {
      if (this._textState) {
        while (!this.isEndOfText(this._textState)) {
          if (this.needsNewPage(this._textState)) {
            this.newPage(this._textState);
          }
          this.updateShowFast();
          if (!this._showFast && !this._lineShowFast && this._textSpeedCount < this._textSpeed) {
            this._textSpeedCount++;
            break;
          }
          this._textSpeedCount = 0;
          this.processCharacter(this._textState);
          if (!this._showFast && !this._lineShowFast && this._textSpeed !== -1) {
            break;
          }
          if (this.pause || this._waitCount > 0) {
            break;
          }
        }
        if (this.isEndOfText(this._textState)) {
          this.onEndOfText();
        }
        return true;
      } else {
        return false;
      }
    }
    onEndOfText() {
      if (!this.startInput()) {
        if (!this._pauseSkip) {
          this.startPause();
        } else {
          this.terminateMessage();
        }
      }
      this._textState = null;
    }
    startInput() {
      if (self.$gameMessage.isChoice()) {
        this._choiceWindow.start();
        return true;
      } else if (self.$gameMessage.isNumberInput()) {
        this._numberWindow.start();
        return true;
      } else if (self.$gameMessage.isItemChoice()) {
        this._itemWindow.start();
        return true;
      } else {
        return false;
      }
    }
    isTriggered() {
      return Input_default.isRepeated("ok") || Input_default.isRepeated("cancel") || TouchInput_default.isRepeated();
    }
    doesContinue() {
      return self.$gameMessage.hasText() && !self.$gameMessage.scrollMode() && !this.areSettingsChanged();
    }
    areSettingsChanged() {
      return this._background !== self.$gameMessage.background() || this._positionType !== self.$gameMessage.positionType();
    }
    updateShowFast() {
      if (this.isTriggered()) {
        this._showFast = true;
      }
    }
    newPage(textState) {
      this.contents.clear();
      this.resetFontSettings();
      this.clearFlags();
      this.loadMessageFace();
      textState.x = this.newLineX();
      textState.y = 0;
      textState.left = this.newLineX();
      textState.height = this.calcTextHeight(textState, false);
    }
    loadMessageFace() {
      this._faceBitmap = ImageManager_default.reserveFace(
        self.$gameMessage.faceName(),
        0,
        this._imageReservationId
      );
    }
    drawMessageFace() {
      this.drawFace(
        self.$gameMessage.faceName(),
        self.$gameMessage.faceIndex(),
        0,
        0
      );
      ImageManager_default.releaseReservation(this._imageReservationId);
    }
    newLineX() {
      return self.$gameMessage.faceName() === "" ? 0 : 168;
    }
    processNewLine(textState) {
      this._lineShowFast = false;
      super.processNewLine(textState);
      if (this.needsNewPage(textState)) {
        this.startPause();
      }
    }
    processNewPage(textState) {
      super.processNewPage(textState);
      if (textState.text[textState.index] === "\n") {
        textState.index++;
      }
      textState.y = this.contents.height;
      this.startPause();
    }
    isEndOfText({ index: index2, text }) {
      return index2 >= text.length;
    }
    needsNewPage(textState) {
      return !this.isEndOfText(textState) && textState.y + textState.height > this.contents.height;
    }
    processEscapeCharacter(code, textState) {
      switch (code) {
        case "$":
          this._goldWindow.open();
          break;
        case ".":
          this.startWait(15);
          break;
        case "|":
          this.startWait(60);
          break;
        case "!":
          this.startPause();
          break;
        case ">":
          this._lineShowFast = true;
          break;
        case "<":
          this._lineShowFast = false;
          break;
        case "^":
          this._pauseSkip = true;
          break;
        case "S":
          this._textSpeed = this.obtainEscapeParam(textState) - 1;
          break;
        default:
          super.processEscapeCharacter(code, textState);
          break;
      }
    }
    startWait(count) {
      this._waitCount = count;
    }
    startPause() {
      this.startWait(10);
      this.pause = true;
    }
  };
  var Window_Message_default = Window_Message;

  // src-www/js/rpg_windows/Window_ScrollText.js
  var Window_ScrollText = class extends Window_Base_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      const width = Graphics_default.boxWidth;
      const height = Graphics_default.boxHeight;
      super.initialize(0, 0, width, height);
      this.opacity = 0;
      this.hide();
      this._text = "";
      this._allTextHeight = 0;
    }
    update() {
      super.update();
      if (self.$gameMessage.scrollMode()) {
        if (this._text) {
          this.updateMessage();
        }
        if (!this._text && self.$gameMessage.hasText()) {
          this.startMessage();
        }
      }
    }
    startMessage() {
      this._text = self.$gameMessage.allText();
      this.refresh();
      this.show();
    }
    refresh() {
      const textState = {
        index: 0
      };
      textState.text = this.convertEscapeCharacters(this._text);
      this.resetFontSettings();
      this._allTextHeight = this.calcTextHeight(textState, true);
      this.createContents();
      this.origin.y = -this.height;
      this.drawTextEx(this._text, this.textPadding(), 1);
    }
    contentsHeight() {
      return Math.max(this._allTextHeight, 1);
    }
    updateMessage() {
      this.origin.y += this.scrollSpeed();
      if (this.origin.y >= this.contents.height) {
        this.terminateMessage();
      }
    }
    scrollSpeed() {
      let speed = self.$gameMessage.scrollSpeed() / 2;
      if (this.isFastForward()) {
        speed *= this.fastForwardRate();
      }
      return speed;
    }
    isFastForward() {
      if (self.$gameMessage.scrollNoFast()) {
        return false;
      } else {
        return Input_default.isPressed("ok") || Input_default.isPressed("shift") || TouchInput_default.isPressed();
      }
    }
    fastForwardRate() {
      return 3;
    }
    terminateMessage() {
      this._text = null;
      self.$gameMessage.clear();
      this.hide();
    }
  };
  var Window_ScrollText_default = Window_ScrollText;

  // src-www/js/rpg_windows/Window_BattleLog.js
  var Window_BattleLog = class extends Window_Selectable_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      const width = this.windowWidth();
      const height = this.windowHeight();
      super.initialize(0, 0, width, height);
      this.opacity = 0;
      this._lines = [];
      this._methods = [];
      this._waitCount = 0;
      this._waitMode = "";
      this._baseLineStack = [];
      this._spriteset = null;
      this.createBackBitmap();
      this.createBackSprite();
      this.refresh();
    }
    setSpriteset(spriteset) {
      this._spriteset = spriteset;
    }
    windowWidth() {
      return Graphics_default.boxWidth;
    }
    windowHeight() {
      return this.fittingHeight(this.maxLines());
    }
    maxLines() {
      return 10;
    }
    createBackBitmap() {
      this._backBitmap = new Bitmap_default(this.width, this.height);
    }
    createBackSprite() {
      this._backSprite = new Sprite_default();
      this._backSprite.bitmap = this._backBitmap;
      this._backSprite.y = this.y;
      this.addChildToBack(this._backSprite);
    }
    numLines() {
      return this._lines.length;
    }
    messageSpeed() {
      return 16;
    }
    isBusy() {
      return this._waitCount > 0 || this._waitMode || this._methods.length > 0;
    }
    update() {
      if (!this.updateWait()) {
        this.callNextMethod();
      }
    }
    updateWait() {
      return this.updateWaitCount() || this.updateWaitMode();
    }
    updateWaitCount() {
      if (this._waitCount > 0) {
        this._waitCount -= this.isFastForward() ? 3 : 1;
        if (this._waitCount < 0) {
          this._waitCount = 0;
        }
        return true;
      }
      return false;
    }
    updateWaitMode() {
      let waiting = false;
      switch (this._waitMode) {
        case "effect":
          waiting = this._spriteset.isEffecting();
          break;
        case "movement":
          waiting = this._spriteset.isAnyoneMoving();
          break;
      }
      if (!waiting) {
        this._waitMode = "";
      }
      return waiting;
    }
    setWaitMode(waitMode) {
      this._waitMode = waitMode;
    }
    callNextMethod() {
      if (this._methods.length > 0) {
        const method = this._methods.shift();
        if (method.name && this[method.name]) {
          this[method.name](...method.params);
        } else {
          throw new Error(`Method not found: ${method.name}`);
        }
      }
    }
    isFastForward() {
      return Input_default.isLongPressed("ok") || Input_default.isPressed("shift") || TouchInput_default.isLongPressed();
    }
    push(methodName) {
      const methodArgs = Array.prototype.slice.call(arguments, 1);
      this._methods.push({
        name: methodName,
        params: methodArgs
      });
    }
    clear() {
      this._lines = [];
      this._baseLineStack = [];
      this.refresh();
    }
    wait() {
      this._waitCount = this.messageSpeed();
    }
    waitForEffect() {
      this.setWaitMode("effect");
    }
    waitForMovement() {
      this.setWaitMode("movement");
    }
    addText(text) {
      this._lines.push(text);
      this.refresh();
      this.wait();
    }
    pushBaseLine() {
      this._baseLineStack.push(this._lines.length);
    }
    popBaseLine() {
      const baseLine = this._baseLineStack.pop();
      while (this._lines.length > baseLine) {
        this._lines.pop();
      }
    }
    waitForNewLine() {
      let baseLine = 0;
      if (this._baseLineStack.length > 0) {
        baseLine = this._baseLineStack[this._baseLineStack.length - 1];
      }
      if (this._lines.length > baseLine) {
        this.wait();
      }
    }
    popupDamage(target2) {
      target2.startDamagePopup();
    }
    performActionStart(subject, action) {
      subject.performActionStart(action);
    }
    performAction(subject, action) {
      subject.performAction(action);
    }
    performActionEnd(subject) {
      subject.performActionEnd();
    }
    performDamage(target2) {
      target2.performDamage();
    }
    performMiss(target2) {
      target2.performMiss();
    }
    performRecovery(target2) {
      target2.performRecovery();
    }
    performEvasion(target2) {
      target2.performEvasion();
    }
    performMagicEvasion(target2) {
      target2.performMagicEvasion();
    }
    performCounter(target2) {
      target2.performCounter();
    }
    performReflection(target2) {
      target2.performReflection();
    }
    performSubstitute(substitute, target2) {
      substitute.performSubstitute(target2);
    }
    performCollapse(target2) {
      target2.performCollapse();
    }
    showAnimation(subject, targets, animationId) {
      if (animationId < 0) {
        this.showAttackAnimation(subject, targets);
      } else {
        this.showNormalAnimation(targets, animationId);
      }
    }
    showAttackAnimation(subject, targets) {
      if (subject.isActor()) {
        this.showActorAttackAnimation(subject, targets);
      } else {
        this.showEnemyAttackAnimation(subject, targets);
      }
    }
    showActorAttackAnimation(subject, targets) {
      this.showNormalAnimation(targets, subject.attackAnimationId1(), false);
      this.showNormalAnimation(targets, subject.attackAnimationId2(), true);
    }
    showEnemyAttackAnimation(subject, targets) {
      SoundManager_default.playEnemyAttack();
    }
    showNormalAnimation(targets, animationId, mirror) {
      const animation = self.$dataAnimations[animationId];
      if (animation) {
        let delay = this.animationBaseDelay();
        const nextDelay = this.animationNextDelay();
        targets.forEach((target2) => {
          target2.startAnimation(animationId, mirror, delay);
          delay += nextDelay;
        });
      }
    }
    animationBaseDelay() {
      return 8;
    }
    animationNextDelay() {
      return 12;
    }
    refresh() {
      this.drawBackground();
      this.contents.clear();
      for (let i = 0; i < this._lines.length; i++) {
        this.drawLineText(i);
      }
    }
    drawBackground() {
      const rect = this.backRect();
      const color2 = this.backColor();
      this._backBitmap.clear();
      this._backBitmap.paintOpacity = this.backPaintOpacity();
      this._backBitmap.fillRect(rect.x, rect.y, rect.width, rect.height, color2);
      this._backBitmap.paintOpacity = 255;
    }
    backRect() {
      return {
        x: 0,
        y: this.padding,
        width: this.width,
        height: this.numLines() * this.lineHeight()
      };
    }
    backColor() {
      return "#000000";
    }
    backPaintOpacity() {
      return 64;
    }
    drawLineText(index2) {
      const rect = this.itemRectForText(index2);
      this.contents.clearRect(rect.x, rect.y, rect.width, rect.height);
      this.drawTextEx(this._lines[index2], rect.x, rect.y, rect.width);
    }
    startTurn() {
      this.push("wait");
    }
    startAction(subject, action, targets) {
      const item2 = action.item();
      this.push("performActionStart", subject, action);
      this.push("waitForMovement");
      this.push("performAction", subject, action);
      this.push("showAnimation", subject, targets.clone(), item2.animationId);
      this.displayAction(subject, item2);
    }
    endAction(subject) {
      this.push("waitForNewLine");
      this.push("clear");
      this.push("performActionEnd", subject);
    }
    displayCurrentState(subject) {
      const stateText = subject.mostImportantStateText();
      if (stateText) {
        this.push("addText", subject.name() + stateText);
        this.push("wait");
        this.push("clear");
      }
    }
    displayRegeneration(subject) {
      this.push("popupDamage", subject);
    }
    displayAction(subject, item2) {
      const numMethods = this._methods.length;
      if (DataManager2.isSkill(item2)) {
        if (item2.message1) {
          this.push("addText", subject.name() + item2.message1.format(item2.name));
        }
        if (item2.message2) {
          this.push("addText", item2.message2.format(item2.name));
        }
      } else {
        this.push(
          "addText",
          TextManager_default.useItem.format(subject.name(), item2.name)
        );
      }
      if (this._methods.length === numMethods) {
        this.push("wait");
      }
    }
    displayCounter(target2) {
      this.push("performCounter", target2);
      this.push("addText", TextManager_default.counterAttack.format(target2.name()));
    }
    displayReflection(target2) {
      this.push("performReflection", target2);
      this.push("addText", TextManager_default.magicReflection.format(target2.name()));
    }
    displaySubstitute(substitute, target2) {
      const substName = substitute.name();
      this.push("performSubstitute", substitute, target2);
      this.push(
        "addText",
        TextManager_default.substitute.format(substName, target2.name())
      );
    }
    displayActionResults(subject, target2) {
      if (target2.result().used) {
        this.push("pushBaseLine");
        this.displayCritical(target2);
        this.push("popupDamage", target2);
        this.push("popupDamage", subject);
        this.displayDamage(target2);
        this.displayAffectedStatus(target2);
        this.displayFailure(target2);
        this.push("waitForNewLine");
        this.push("popBaseLine");
      }
    }
    displayFailure(target2) {
      if (target2.result().isHit() && !target2.result().success) {
        this.push("addText", TextManager_default.actionFailure.format(target2.name()));
      }
    }
    displayCritical(target2) {
      if (target2.result().critical) {
        if (target2.isActor()) {
          this.push("addText", TextManager_default.criticalToActor);
        } else {
          this.push("addText", TextManager_default.criticalToEnemy);
        }
      }
    }
    displayDamage(target2) {
      if (target2.result().missed) {
        this.displayMiss(target2);
      } else if (target2.result().evaded) {
        this.displayEvasion(target2);
      } else {
        this.displayHpDamage(target2);
        this.displayMpDamage(target2);
        this.displayTpDamage(target2);
      }
    }
    displayMiss(target2) {
      let fmt;
      if (target2.result().physical) {
        fmt = target2.isActor() ? TextManager_default.actorNoHit : TextManager_default.enemyNoHit;
        this.push("performMiss", target2);
      } else {
        fmt = TextManager_default.actionFailure;
      }
      this.push("addText", fmt.format(target2.name()));
    }
    displayEvasion(target2) {
      let fmt;
      if (target2.result().physical) {
        fmt = TextManager_default.evasion;
        this.push("performEvasion", target2);
      } else {
        fmt = TextManager_default.magicEvasion;
        this.push("performMagicEvasion", target2);
      }
      this.push("addText", fmt.format(target2.name()));
    }
    displayHpDamage(target2) {
      if (target2.result().hpAffected) {
        if (target2.result().hpDamage > 0 && !target2.result().drain) {
          this.push("performDamage", target2);
        }
        if (target2.result().hpDamage < 0) {
          this.push("performRecovery", target2);
        }
        this.push("addText", this.makeHpDamageText(target2));
      }
    }
    displayMpDamage(target2) {
      if (target2.isAlive() && target2.result().mpDamage !== 0) {
        if (target2.result().mpDamage < 0) {
          this.push("performRecovery", target2);
        }
        this.push("addText", this.makeMpDamageText(target2));
      }
    }
    displayTpDamage(target2) {
      if (target2.isAlive() && target2.result().tpDamage !== 0) {
        if (target2.result().tpDamage < 0) {
          this.push("performRecovery", target2);
        }
        this.push("addText", this.makeTpDamageText(target2));
      }
    }
    displayAffectedStatus(target2) {
      if (target2.result().isStatusAffected()) {
        this.push("pushBaseLine");
        this.displayChangedStates(target2);
        this.displayChangedBuffs(target2);
        this.push("waitForNewLine");
        this.push("popBaseLine");
      }
    }
    displayAutoAffectedStatus(target2) {
      if (target2.result().isStatusAffected()) {
        this.displayAffectedStatus(target2, null);
        this.push("clear");
      }
    }
    displayChangedStates(target2) {
      this.displayAddedStates(target2);
      this.displayRemovedStates(target2);
    }
    displayAddedStates(target2) {
      target2.result().addedStateObjects().forEach(function({ message1, message2, id }) {
        const stateMsg = target2.isActor() ? message1 : message2;
        if (id === target2.deathStateId()) {
          this.push("performCollapse", target2);
        }
        if (stateMsg) {
          this.push("popBaseLine");
          this.push("pushBaseLine");
          this.push("addText", target2.name() + stateMsg);
          this.push("waitForEffect");
        }
      }, this);
    }
    displayRemovedStates(target2) {
      target2.result().removedStateObjects().forEach(function({ message4 }) {
        if (message4) {
          this.push("popBaseLine");
          this.push("pushBaseLine");
          this.push("addText", target2.name() + message4);
        }
      }, this);
    }
    displayChangedBuffs(target2) {
      const result2 = target2.result();
      this.displayBuffs(target2, result2.addedBuffs, TextManager_default.buffAdd);
      this.displayBuffs(target2, result2.addedDebuffs, TextManager_default.debuffAdd);
      this.displayBuffs(target2, result2.removedBuffs, TextManager_default.buffRemove);
    }
    displayBuffs(target2, buffs, fmt) {
      buffs.forEach(function(paramId) {
        this.push("popBaseLine");
        this.push("pushBaseLine");
        this.push(
          "addText",
          fmt.format(target2.name(), TextManager_default.param(paramId))
        );
      }, this);
    }
    makeHpDamageText(target2) {
      const result2 = target2.result();
      const damage = result2.hpDamage;
      const isActor = target2.isActor();
      let fmt;
      if (damage > 0 && result2.drain) {
        fmt = isActor ? TextManager_default.actorDrain : TextManager_default.enemyDrain;
        return fmt.format(target2.name(), TextManager_default.hp, damage);
      } else if (damage > 0) {
        fmt = isActor ? TextManager_default.actorDamage : TextManager_default.enemyDamage;
        return fmt.format(target2.name(), damage);
      } else if (damage < 0) {
        fmt = isActor ? TextManager_default.actorRecovery : TextManager_default.enemyRecovery;
        return fmt.format(target2.name(), TextManager_default.hp, -damage);
      } else {
        fmt = isActor ? TextManager_default.actorNoDamage : TextManager_default.enemyNoDamage;
        return fmt.format(target2.name());
      }
    }
    makeMpDamageText(target2) {
      const result2 = target2.result();
      const damage = result2.mpDamage;
      const isActor = target2.isActor();
      let fmt;
      if (damage > 0 && result2.drain) {
        fmt = isActor ? TextManager_default.actorDrain : TextManager_default.enemyDrain;
        return fmt.format(target2.name(), TextManager_default.mp, damage);
      } else if (damage > 0) {
        fmt = isActor ? TextManager_default.actorLoss : TextManager_default.enemyLoss;
        return fmt.format(target2.name(), TextManager_default.mp, damage);
      } else if (damage < 0) {
        fmt = isActor ? TextManager_default.actorRecovery : TextManager_default.enemyRecovery;
        return fmt.format(target2.name(), TextManager_default.mp, -damage);
      } else {
        return "";
      }
    }
    makeTpDamageText(target2) {
      const result2 = target2.result();
      const damage = result2.tpDamage;
      const isActor = target2.isActor();
      let fmt;
      if (damage > 0) {
        fmt = isActor ? TextManager_default.actorLoss : TextManager_default.enemyLoss;
        return fmt.format(target2.name(), TextManager_default.tp, damage);
      } else if (damage < 0) {
        fmt = isActor ? TextManager_default.actorGain : TextManager_default.enemyGain;
        return fmt.format(target2.name(), TextManager_default.tp, -damage);
      } else {
        return "";
      }
    }
  };
  var Window_BattleLog_default = Window_BattleLog;

  // src-www/js/rpg_windows/Window_PartyCommand.js
  var Window_PartyCommand = class extends Window_Command_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      const y = Graphics_default.boxHeight - this.windowHeight();
      super.initialize(0, y);
      this.openness = 0;
      this.deactivate();
    }
    windowWidth() {
      return 192;
    }
    numVisibleRows() {
      return 4;
    }
    makeCommandList() {
      this.addCommand(TextManager_default.fight, "fight");
      this.addCommand(TextManager_default.escape, "escape", BattleManager_default.canEscape());
    }
    setup() {
      this.clearCommandList();
      this.makeCommandList();
      this.refresh();
      this.select(0);
      this.activate();
      this.open();
    }
  };
  var Window_PartyCommand_default = Window_PartyCommand;

  // src-www/js/rpg_managers/ConfigManager.js
  var ConfigManager = class {
    constructor() {
      throw new Error("This is a static class");
    }
    static async load() {
      let json;
      let config = {};
      try {
        json = await StorageManagerShim_default.load(-1);
      } catch (e) {
        console.error(e);
      }
      if (json) {
        config = JSON.parse(json);
      }
      this.applyData(config);
    }
    static save() {
      StorageManagerShim_default.save(-1, JSON.stringify(this.makeData()));
    }
    static makeData() {
      const config = {};
      config.alwaysDash = this.alwaysDash;
      config.commandRemember = this.commandRemember;
      config.bgmVolume = this.bgmVolume;
      config.bgsVolume = this.bgsVolume;
      config.meVolume = this.meVolume;
      config.seVolume = this.seVolume;
      return config;
    }
    static applyData(config) {
      this.alwaysDash = this.readFlag(config, "alwaysDash");
      this.commandRemember = this.readFlag(config, "commandRemember");
      this.bgmVolume = this.readVolume(config, "bgmVolume");
      this.bgsVolume = this.readVolume(config, "bgsVolume");
      this.meVolume = this.readVolume(config, "meVolume");
      this.seVolume = this.readVolume(config, "seVolume");
    }
    static readFlag(config, name) {
      return !!config[name];
    }
    static readVolume(config, name) {
      const value3 = config[name];
      if (value3 !== void 0) {
        return Number(value3).clamp(0, 100);
      } else {
        return 100;
      }
    }
  };
  ConfigManager.alwaysDash = false;
  ConfigManager.commandRemember = false;
  Object.defineProperty(ConfigManager, "bgmVolume", {
    get() {
      return AudioManager_default._bgmVolume;
    },
    set(value3) {
      AudioManager_default.bgmVolume = value3;
    },
    configurable: true
  });
  Object.defineProperty(ConfigManager, "bgsVolume", {
    get() {
      return AudioManager_default.bgsVolume;
    },
    set(value3) {
      AudioManager_default.bgsVolume = value3;
    },
    configurable: true
  });
  Object.defineProperty(ConfigManager, "meVolume", {
    get() {
      return AudioManager_default.meVolume;
    },
    set(value3) {
      AudioManager_default.meVolume = value3;
    },
    configurable: true
  });
  Object.defineProperty(ConfigManager, "seVolume", {
    get() {
      return AudioManager_default.seVolume;
    },
    set(value3) {
      AudioManager_default.seVolume = value3;
    },
    configurable: true
  });
  var ConfigManager_default = ConfigManager;

  // src-www/js/rpg_windows/Window_ActorCommand.js
  var Window_ActorCommand = class extends Window_Command_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      const y = Graphics_default.boxHeight - this.windowHeight();
      super.initialize(0, y);
      this.openness = 0;
      this.deactivate();
      this._actor = null;
    }
    windowWidth() {
      return 192;
    }
    numVisibleRows() {
      return 4;
    }
    makeCommandList() {
      if (this._actor) {
        this.addAttackCommand();
        this.addSkillCommands();
        this.addGuardCommand();
        this.addItemCommand();
      }
    }
    addAttackCommand() {
      this.addCommand(TextManager_default.attack, "attack", this._actor.canAttack());
    }
    addSkillCommands() {
      const skillTypes = this._actor.addedSkillTypes();
      skillTypes.sort((a2, b2) => a2 - b2);
      skillTypes.forEach(function(stypeId) {
        const name = self.$dataSystem.skillTypes[stypeId];
        this.addCommand(name, "skill", true, stypeId);
      }, this);
    }
    addGuardCommand() {
      this.addCommand(TextManager_default.guard, "guard", this._actor.canGuard());
    }
    addItemCommand() {
      this.addCommand(TextManager_default.item, "item");
    }
    setup(actor2) {
      this._actor = actor2;
      this.clearCommandList();
      this.makeCommandList();
      this.refresh();
      this.selectLast();
      this.activate();
      this.open();
    }
    processOk() {
      if (this._actor) {
        if (ConfigManager_default.commandRemember) {
          this._actor.setLastCommandSymbol(this.currentSymbol());
        } else {
          this._actor.setLastCommandSymbol("");
        }
      }
      super.processOk();
    }
    selectLast() {
      this.select(0);
      if (this._actor && ConfigManager_default.commandRemember) {
        const symbol = this._actor.lastCommandSymbol();
        this.selectSymbol(symbol);
        if (symbol === "skill") {
          const skill = this._actor.lastBattleSkill();
          if (skill) {
            this.selectExt(skill.stypeId);
          }
        }
      }
    }
  };
  var Window_ActorCommand_default = Window_ActorCommand;

  // src-www/js/rpg_windows/Window_BattleStatus.js
  var Window_BattleStatus = class extends Window_Selectable_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      const width = this.windowWidth();
      const height = this.windowHeight();
      const x = Graphics_default.boxWidth - width;
      const y = Graphics_default.boxHeight - height;
      super.initialize(x, y, width, height);
      this.refresh();
      this.openness = 0;
    }
    windowWidth() {
      return Graphics_default.boxWidth - 192;
    }
    windowHeight() {
      return this.fittingHeight(this.numVisibleRows());
    }
    numVisibleRows() {
      return 4;
    }
    maxItems() {
      return self.$gameParty.battleMembers().length;
    }
    refresh() {
      this.contents.clear();
      this.drawAllItems();
    }
    drawItem(index2) {
      const actor2 = self.$gameParty.battleMembers()[index2];
      this.drawBasicArea(this.basicAreaRect(index2), actor2);
      this.drawGaugeArea(this.gaugeAreaRect(index2), actor2);
    }
    basicAreaRect(index2) {
      const rect = this.itemRectForText(index2);
      rect.width -= this.gaugeAreaWidth() + 15;
      return rect;
    }
    gaugeAreaRect(index2) {
      const rect = this.itemRectForText(index2);
      rect.x += rect.width - this.gaugeAreaWidth();
      rect.width = this.gaugeAreaWidth();
      return rect;
    }
    gaugeAreaWidth() {
      return 330;
    }
    drawBasicArea({ x, y, width }, actor2) {
      this.drawActorName(actor2, x + 0, y, 150);
      this.drawActorIcons(actor2, x + 156, y, width - 156);
    }
    drawGaugeArea(rect, actor2) {
      if (self.$dataSystem.optDisplayTp) {
        this.drawGaugeAreaWithTp(rect, actor2);
      } else {
        this.drawGaugeAreaWithoutTp(rect, actor2);
      }
    }
    drawGaugeAreaWithTp({ x, y }, actor2) {
      this.drawActorHp(actor2, x + 0, y, 108);
      this.drawActorMp(actor2, x + 123, y, 96);
      this.drawActorTp(actor2, x + 234, y, 96);
    }
    drawGaugeAreaWithoutTp({ x, y }, actor2) {
      this.drawActorHp(actor2, x + 0, y, 201);
      this.drawActorMp(actor2, x + 216, y, 114);
    }
  };
  var Window_BattleStatus_default = Window_BattleStatus;

  // src-www/js/rpg_windows/Window_BattleActor.js
  var Window_BattleActor = class extends Window_BattleStatus_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(x, y) {
      super.initialize();
      this.x = x;
      this.y = y;
      this.openness = 255;
      this.hide();
    }
    show() {
      this.select(0);
      super.show();
    }
    hide() {
      super.hide();
      self.$gameParty.select(null);
    }
    select(index2) {
      super.select(index2);
      self.$gameParty.select(this.actor());
    }
    actor() {
      return self.$gameParty.members()[this.index()];
    }
  };
  var Window_BattleActor_default = Window_BattleActor;

  // src-www/js/rpg_windows/Window_BattleEnemy.js
  var Window_BattleEnemy = class extends Window_Selectable_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(x, y) {
      this._enemies = [];
      const width = this.windowWidth();
      const height = this.windowHeight();
      super.initialize(x, y, width, height);
      this.refresh();
      this.hide();
    }
    windowWidth() {
      return Graphics_default.boxWidth - 192;
    }
    windowHeight() {
      return this.fittingHeight(this.numVisibleRows());
    }
    numVisibleRows() {
      return 4;
    }
    maxCols() {
      return 2;
    }
    maxItems() {
      return this._enemies.length;
    }
    enemy() {
      return this._enemies[this.index()];
    }
    enemyIndex() {
      const enemy2 = this.enemy();
      return enemy2 ? enemy2.index() : -1;
    }
    drawItem(index2) {
      this.resetTextColor();
      const name = this._enemies[index2].name();
      const rect = this.itemRectForText(index2);
      this.drawText(name, rect.x, rect.y, rect.width);
    }
    show() {
      this.refresh();
      this.select(0);
      super.show();
    }
    hide() {
      super.hide();
      self.$gameTroop.select(null);
    }
    refresh() {
      this._enemies = self.$gameTroop.aliveMembers();
      super.refresh();
    }
    select(index2) {
      super.select(index2);
      self.$gameTroop.select(this.enemy());
    }
  };
  var Window_BattleEnemy_default = Window_BattleEnemy;

  // src-www/js/rpg_windows/Window_SkillList.js
  var Window_SkillList = class extends Window_Selectable_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(x, y, width, height) {
      super.initialize(x, y, width, height);
      this._actor = null;
      this._stypeId = 0;
      this._data = [];
    }
    setActor(actor2) {
      if (this._actor !== actor2) {
        this._actor = actor2;
        this.refresh();
        this.resetScroll();
      }
    }
    setStypeId(stypeId) {
      if (this._stypeId !== stypeId) {
        this._stypeId = stypeId;
        this.refresh();
        this.resetScroll();
      }
    }
    maxCols() {
      return 2;
    }
    spacing() {
      return 48;
    }
    maxItems() {
      return this._data ? this._data.length : 1;
    }
    item() {
      return this._data && this.index() >= 0 ? this._data[this.index()] : null;
    }
    isCurrentItemEnabled() {
      return this.isEnabled(this._data[this.index()]);
    }
    includes(item2) {
      return item2 && item2.stypeId === this._stypeId;
    }
    isEnabled(item2) {
      return this._actor && this._actor.canUse(item2);
    }
    makeItemList() {
      if (this._actor) {
        this._data = this._actor.skills().filter(function(item2) {
          return this.includes(item2);
        }, this);
      } else {
        this._data = [];
      }
    }
    selectLast() {
      let skill;
      if (self.$gameParty.inBattle()) {
        skill = this._actor.lastBattleSkill();
      } else {
        skill = this._actor.lastMenuSkill();
      }
      const index2 = this._data.indexOf(skill);
      this.select(index2 >= 0 ? index2 : 0);
    }
    drawItem(index2) {
      const skill = this._data[index2];
      if (skill) {
        const costWidth = this.costWidth();
        const rect = this.itemRect(index2);
        rect.width -= this.textPadding();
        this.changePaintOpacity(this.isEnabled(skill));
        this.drawItemName(skill, rect.x, rect.y, rect.width - costWidth);
        this.drawSkillCost(skill, rect.x, rect.y, rect.width);
        this.changePaintOpacity(1);
      }
    }
    costWidth() {
      return this.textWidth("000");
    }
    drawSkillCost(skill, x, y, width) {
      if (this._actor.skillTpCost(skill) > 0) {
        this.changeTextColor(this.tpCostColor());
        this.drawText(this._actor.skillTpCost(skill), x, y, width, "right");
      } else if (this._actor.skillMpCost(skill) > 0) {
        this.changeTextColor(this.mpCostColor());
        this.drawText(this._actor.skillMpCost(skill), x, y, width, "right");
      }
    }
    updateHelp() {
      this.setHelpWindowItem(this.item());
    }
    refresh() {
      this.makeItemList();
      this.createContents();
      this.drawAllItems();
    }
  };
  var Window_SkillList_default = Window_SkillList;

  // src-www/js/rpg_windows/Window_BattleSkill.js
  var Window_BattleSkill = class extends Window_SkillList_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(x, y, width, height) {
      super.initialize(x, y, width, height);
      this.hide();
    }
    show() {
      this.selectLast();
      this.showHelpWindow();
      super.show();
    }
    hide() {
      this.hideHelpWindow();
      super.hide();
    }
  };
  var Window_BattleSkill_default = Window_BattleSkill;

  // src-www/js/rpg_windows/Window_BattleItem.js
  var Window_BattleItem = class extends Window_ItemList_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(x, y, width, height) {
      super.initialize(x, y, width, height);
      this.hide();
    }
    includes(item2) {
      return self.$gameParty.canUse(item2);
    }
    show() {
      this.selectLast();
      this.showHelpWindow();
      super.show();
    }
    hide() {
      this.hideHelpWindow();
      super.hide();
    }
  };
  var Window_BattleItem_default = Window_BattleItem;

  // src-www/js/rpg_scenes/Scene_Battle.js
  var Scene_Battle = class extends Scene_Base_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
    }
    create() {
      super.create();
      this.createDisplayObjects();
    }
    start() {
      super.start();
      this.startFadeIn(this.fadeSpeed(), false);
      BattleManager_default.playBattleBgm();
      BattleManager_default.startBattle();
    }
    update() {
      const active = this.isActive();
      self.$gameTimer.update(active);
      self.$gameScreen.update();
      this.updateStatusWindow();
      this.updateWindowPositions();
      if (active && !this.isBusy()) {
        this.updateBattleProcess();
      }
      super.update();
    }
    updateBattleProcess() {
      if (!this.isAnyInputWindowActive() || BattleManager_default.isAborting() || BattleManager_default.isBattleEnd()) {
        BattleManager_default.update();
        this.changeInputWindow();
      }
    }
    isAnyInputWindowActive() {
      return this._partyCommandWindow.active || this._actorCommandWindow.active || this._skillWindow.active || this._itemWindow.active || this._actorWindow.active || this._enemyWindow.active;
    }
    changeInputWindow() {
      if (BattleManager_default.isInputting()) {
        if (BattleManager_default.actor()) {
          this.startActorCommandSelection();
        } else {
          this.startPartyCommandSelection();
        }
      } else {
        this.endCommandSelection();
      }
    }
    stop() {
      super.stop();
      if (this.needsSlowFadeOut()) {
        this.startFadeOut(this.slowFadeSpeed(), false);
      } else {
        this.startFadeOut(this.fadeSpeed(), false);
      }
      this._statusWindow.close();
      this._partyCommandWindow.close();
      this._actorCommandWindow.close();
    }
    terminate() {
      super.terminate();
      self.$gameParty.onBattleEnd();
      self.$gameTroop.onBattleEnd();
      AudioManager_default.stopMe();
      ImageManager_default.clearRequest();
    }
    needsSlowFadeOut() {
      return SceneManager_default.isNextScene(Scene_Title_default) || SceneManager_default.isNextScene(Scene_Gameover_default);
    }
    updateStatusWindow() {
      if (self.$gameMessage.isBusy()) {
        this._statusWindow.close();
        this._partyCommandWindow.close();
        this._actorCommandWindow.close();
      } else if (this.isActive() && !this._messageWindow.isClosing()) {
        this._statusWindow.open();
      }
    }
    updateWindowPositions() {
      let statusX = 0;
      if (BattleManager_default.isInputting()) {
        statusX = this._partyCommandWindow.width;
      } else {
        statusX = this._partyCommandWindow.width / 2;
      }
      if (this._statusWindow.x < statusX) {
        this._statusWindow.x += 16;
        if (this._statusWindow.x > statusX) {
          this._statusWindow.x = statusX;
        }
      }
      if (this._statusWindow.x > statusX) {
        this._statusWindow.x -= 16;
        if (this._statusWindow.x < statusX) {
          this._statusWindow.x = statusX;
        }
      }
    }
    createDisplayObjects() {
      this.createSpriteset();
      this.createWindowLayer();
      this.createAllWindows();
      BattleManager_default.setLogWindow(this._logWindow);
      BattleManager_default.setStatusWindow(this._statusWindow);
      BattleManager_default.setSpriteset(this._spriteset);
      this._logWindow.setSpriteset(this._spriteset);
    }
    createSpriteset() {
      this._spriteset = new Spriteset_Battle_default();
      this.addChild(this._spriteset);
    }
    createAllWindows() {
      this.createLogWindow();
      this.createStatusWindow();
      this.createPartyCommandWindow();
      this.createActorCommandWindow();
      this.createHelpWindow();
      this.createSkillWindow();
      this.createItemWindow();
      this.createActorWindow();
      this.createEnemyWindow();
      this.createMessageWindow();
      this.createScrollTextWindow();
    }
    createLogWindow() {
      this._logWindow = new Window_BattleLog_default();
      this.addWindow(this._logWindow);
    }
    createStatusWindow() {
      this._statusWindow = new Window_BattleStatus_default();
      this.addWindow(this._statusWindow);
    }
    createPartyCommandWindow() {
      this._partyCommandWindow = new Window_PartyCommand_default();
      this._partyCommandWindow.setHandler("fight", this.commandFight.bind(this));
      this._partyCommandWindow.setHandler(
        "escape",
        this.commandEscape.bind(this)
      );
      this._partyCommandWindow.deselect();
      this.addWindow(this._partyCommandWindow);
    }
    createActorCommandWindow() {
      this._actorCommandWindow = new Window_ActorCommand_default();
      this._actorCommandWindow.setHandler(
        "attack",
        this.commandAttack.bind(this)
      );
      this._actorCommandWindow.setHandler("skill", this.commandSkill.bind(this));
      this._actorCommandWindow.setHandler("guard", this.commandGuard.bind(this));
      this._actorCommandWindow.setHandler("item", this.commandItem.bind(this));
      this._actorCommandWindow.setHandler(
        "cancel",
        this.selectPreviousCommand.bind(this)
      );
      this.addWindow(this._actorCommandWindow);
    }
    createHelpWindow() {
      this._helpWindow = new Window_Help_default();
      this._helpWindow.visible = false;
      this.addWindow(this._helpWindow);
    }
    createSkillWindow() {
      const wy = this._helpWindow.y + this._helpWindow.height;
      const wh = this._statusWindow.y - wy;
      this._skillWindow = new Window_BattleSkill_default(0, wy, Graphics_default.boxWidth, wh);
      this._skillWindow.setHelpWindow(this._helpWindow);
      this._skillWindow.setHandler("ok", this.onSkillOk.bind(this));
      this._skillWindow.setHandler("cancel", this.onSkillCancel.bind(this));
      this.addWindow(this._skillWindow);
    }
    createItemWindow() {
      const wy = this._helpWindow.y + this._helpWindow.height;
      const wh = this._statusWindow.y - wy;
      this._itemWindow = new Window_BattleItem_default(0, wy, Graphics_default.boxWidth, wh);
      this._itemWindow.setHelpWindow(this._helpWindow);
      this._itemWindow.setHandler("ok", this.onItemOk.bind(this));
      this._itemWindow.setHandler("cancel", this.onItemCancel.bind(this));
      this.addWindow(this._itemWindow);
    }
    createActorWindow() {
      this._actorWindow = new Window_BattleActor_default(0, this._statusWindow.y);
      this._actorWindow.setHandler("ok", this.onActorOk.bind(this));
      this._actorWindow.setHandler("cancel", this.onActorCancel.bind(this));
      this.addWindow(this._actorWindow);
    }
    createEnemyWindow() {
      this._enemyWindow = new Window_BattleEnemy_default(0, this._statusWindow.y);
      this._enemyWindow.x = Graphics_default.boxWidth - this._enemyWindow.width;
      this._enemyWindow.setHandler("ok", this.onEnemyOk.bind(this));
      this._enemyWindow.setHandler("cancel", this.onEnemyCancel.bind(this));
      this.addWindow(this._enemyWindow);
    }
    createMessageWindow() {
      this._messageWindow = new Window_Message_default();
      this.addWindow(this._messageWindow);
      this._messageWindow.subWindows().forEach(function(window2) {
        this.addWindow(window2);
      }, this);
    }
    createScrollTextWindow() {
      this._scrollTextWindow = new Window_ScrollText_default();
      this.addWindow(this._scrollTextWindow);
    }
    refreshStatus() {
      this._statusWindow.refresh();
    }
    startPartyCommandSelection() {
      this.refreshStatus();
      this._statusWindow.deselect();
      this._statusWindow.open();
      this._actorCommandWindow.close();
      this._partyCommandWindow.setup();
    }
    commandFight() {
      this.selectNextCommand();
    }
    commandEscape() {
      BattleManager_default.processEscape();
      this.changeInputWindow();
    }
    startActorCommandSelection() {
      this._statusWindow.select(BattleManager_default.actor().index());
      this._partyCommandWindow.close();
      this._actorCommandWindow.setup(BattleManager_default.actor());
    }
    commandAttack() {
      BattleManager_default.inputtingAction().setAttack();
      this.selectEnemySelection();
    }
    commandSkill() {
      this._skillWindow.setActor(BattleManager_default.actor());
      this._skillWindow.setStypeId(this._actorCommandWindow.currentExt());
      this._skillWindow.refresh();
      this._skillWindow.show();
      this._skillWindow.activate();
    }
    commandGuard() {
      BattleManager_default.inputtingAction().setGuard();
      this.selectNextCommand();
    }
    commandItem() {
      this._itemWindow.refresh();
      this._itemWindow.show();
      this._itemWindow.activate();
    }
    selectNextCommand() {
      BattleManager_default.selectNextCommand();
      this.changeInputWindow();
    }
    selectPreviousCommand() {
      BattleManager_default.selectPreviousCommand();
      this.changeInputWindow();
    }
    selectActorSelection() {
      this._actorWindow.refresh();
      this._actorWindow.show();
      this._actorWindow.activate();
    }
    onActorOk() {
      const action = BattleManager_default.inputtingAction();
      action.setTarget(this._actorWindow.index());
      this._actorWindow.hide();
      this._skillWindow.hide();
      this._itemWindow.hide();
      this.selectNextCommand();
    }
    onActorCancel() {
      this._actorWindow.hide();
      switch (this._actorCommandWindow.currentSymbol()) {
        case "skill":
          this._skillWindow.show();
          this._skillWindow.activate();
          break;
        case "item":
          this._itemWindow.show();
          this._itemWindow.activate();
          break;
      }
    }
    selectEnemySelection() {
      this._enemyWindow.refresh();
      this._enemyWindow.show();
      this._enemyWindow.select(0);
      this._enemyWindow.activate();
    }
    onEnemyOk() {
      const action = BattleManager_default.inputtingAction();
      action.setTarget(this._enemyWindow.enemyIndex());
      this._enemyWindow.hide();
      this._skillWindow.hide();
      this._itemWindow.hide();
      this.selectNextCommand();
    }
    onEnemyCancel() {
      this._enemyWindow.hide();
      switch (this._actorCommandWindow.currentSymbol()) {
        case "attack":
          this._actorCommandWindow.activate();
          break;
        case "skill":
          this._skillWindow.show();
          this._skillWindow.activate();
          break;
        case "item":
          this._itemWindow.show();
          this._itemWindow.activate();
          break;
      }
    }
    onSkillOk() {
      const skill = this._skillWindow.item();
      const action = BattleManager_default.inputtingAction();
      action.setSkill(skill.id);
      BattleManager_default.actor().setLastBattleSkill(skill);
      this.onSelectAction();
    }
    onSkillCancel() {
      this._skillWindow.hide();
      this._actorCommandWindow.activate();
    }
    onItemOk() {
      const item2 = this._itemWindow.item();
      const action = BattleManager_default.inputtingAction();
      action.setItem(item2.id);
      self.$gameParty.setLastItem(item2);
      this.onSelectAction();
    }
    onItemCancel() {
      this._itemWindow.hide();
      this._actorCommandWindow.activate();
    }
    onSelectAction() {
      const action = BattleManager_default.inputtingAction();
      this._skillWindow.hide();
      this._itemWindow.hide();
      if (!action.needsSelection()) {
        this.selectNextCommand();
      } else if (action.isForOpponent()) {
        this.selectEnemySelection();
      } else {
        this.selectActorSelection();
      }
    }
    endCommandSelection() {
      this._partyCommandWindow.close();
      this._actorCommandWindow.close();
      this._statusWindow.deselect();
    }
  };
  var Scene_Battle_default = Scene_Battle;

  // src-www/js/rpg_scenes/Scene_MenuBase.js
  var Scene_MenuBase = class extends Scene_Base_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
    }
    create() {
      super.create();
      this.createBackground();
      this.updateActor();
      this.createWindowLayer();
    }
    actor() {
      return this._actor;
    }
    updateActor() {
      this._actor = self.$gameParty.menuActor();
    }
    createBackground() {
      this._backgroundSprite = new Sprite(
        new Texture(SceneManager_default.backgroundBitmap().baseTexture)
      );
      if (Graphics_default.isWebGL()) {
        const filter = new filters.PixelateFilter(12, 12);
        this._backgroundSprite.filters = [filter];
        this._backgroundSprite.cacheAsBitmap = true;
      }
      this.addChild(this._backgroundSprite);
    }
    setBackgroundOpacity(opacity) {
      this._backgroundSprite.opacity = opacity;
    }
    createHelpWindow() {
      this._helpWindow = new Window_Help_default();
      this.addWindow(this._helpWindow);
    }
    nextActor() {
      self.$gameParty.makeMenuActorNext();
      this.updateActor();
      this.onActorChange();
    }
    previousActor() {
      self.$gameParty.makeMenuActorPrevious();
      this.updateActor();
      this.onActorChange();
    }
    onActorChange() {
    }
  };
  var Scene_MenuBase_default = Scene_MenuBase;

  // src-www/js/rpg_windows/Window_MenuCommand.js
  var Window_MenuCommand = class extends Window_Command_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(x, y) {
      super.initialize(x, y);
      this.selectLast();
    }
    static initCommandPosition() {
      this._lastCommandSymbol = null;
    }
    windowWidth() {
      return 240;
    }
    numVisibleRows() {
      return this.maxItems();
    }
    makeCommandList() {
      this.addMainCommands();
      this.addFormationCommand();
      this.addOriginalCommands();
      this.addOptionsCommand();
      this.addSaveCommand();
      this.addGameEndCommand();
    }
    addMainCommands() {
      const enabled = this.areMainCommandsEnabled();
      if (this.needsCommand("item")) {
        this.addCommand(TextManager_default.item, "item", enabled);
      }
      if (this.needsCommand("skill")) {
        this.addCommand(TextManager_default.skill, "skill", enabled);
      }
      if (this.needsCommand("equip")) {
        this.addCommand(TextManager_default.equip, "equip", enabled);
      }
      if (this.needsCommand("status")) {
        this.addCommand(TextManager_default.status, "status", enabled);
      }
    }
    addFormationCommand() {
      if (this.needsCommand("formation")) {
        const enabled = this.isFormationEnabled();
        this.addCommand(TextManager_default.formation, "formation", enabled);
      }
    }
    addOriginalCommands() {
    }
    addOptionsCommand() {
      if (this.needsCommand("options")) {
        const enabled = this.isOptionsEnabled();
        this.addCommand(TextManager_default.options, "options", enabled);
      }
    }
    addSaveCommand() {
      if (this.needsCommand("save")) {
        const enabled = this.isSaveEnabled();
        this.addCommand(TextManager_default.save, "save", enabled);
      }
    }
    addGameEndCommand() {
      const enabled = this.isGameEndEnabled();
      this.addCommand(TextManager_default.gameEnd, "gameEnd", enabled);
    }
    needsCommand(name) {
      const flags = self.$dataSystem.menuCommands;
      if (flags) {
        switch (name) {
          case "item":
            return flags[0];
          case "skill":
            return flags[1];
          case "equip":
            return flags[2];
          case "status":
            return flags[3];
          case "formation":
            return flags[4];
          case "save":
            return flags[5];
        }
      }
      return true;
    }
    areMainCommandsEnabled() {
      return self.$gameParty.exists();
    }
    isFormationEnabled() {
      return self.$gameParty.size() >= 2 && self.$gameSystem.isFormationEnabled();
    }
    isOptionsEnabled() {
      return true;
    }
    isSaveEnabled() {
      return !DataManager2.isEventTest() && self.$gameSystem.isSaveEnabled();
    }
    isGameEndEnabled() {
      return true;
    }
    processOk() {
      Window_MenuCommand._lastCommandSymbol = this.currentSymbol();
      super.processOk();
    }
    selectLast() {
      this.selectSymbol(Window_MenuCommand._lastCommandSymbol);
    }
  };
  Window_MenuCommand._lastCommandSymbol = null;
  var Window_MenuCommand_default = Window_MenuCommand;

  // src-www/js/rpg_windows/Window_MenuStatus.js
  var Window_MenuStatus = class extends Window_Selectable_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(x, y) {
      const width = this.windowWidth();
      const height = this.windowHeight();
      super.initialize(x, y, width, height);
      this._formationMode = false;
      this._pendingIndex = -1;
      this.refresh();
    }
    windowWidth() {
      return Graphics_default.boxWidth - 240;
    }
    windowHeight() {
      return Graphics_default.boxHeight;
    }
    maxItems() {
      return self.$gameParty.size();
    }
    itemHeight() {
      const clientHeight = this.height - this.padding * 2;
      return Math.floor(clientHeight / this.numVisibleRows());
    }
    numVisibleRows() {
      return 4;
    }
    loadImages() {
      self.$gameParty.members().forEach((actor2) => {
        ImageManager_default.reserveFace(actor2.faceName());
      }, this);
    }
    drawItem(index2) {
      this.drawItemBackground(index2);
      this.drawItemImage(index2);
      this.drawItemStatus(index2);
    }
    drawItemBackground(index2) {
      if (index2 === this._pendingIndex) {
        const rect = this.itemRect(index2);
        const color2 = this.pendingColor();
        this.changePaintOpacity(false);
        this.contents.fillRect(rect.x, rect.y, rect.width, rect.height, color2);
        this.changePaintOpacity(true);
      }
    }
    drawItemImage(index2) {
      const actor2 = self.$gameParty.members()[index2];
      const rect = this.itemRect(index2);
      this.changePaintOpacity(actor2.isBattleMember());
      this.drawActorFace(
        actor2,
        rect.x + 1,
        rect.y + 1,
        Window_Base_default._faceWidth,
        Window_Base_default._faceHeight
      );
      this.changePaintOpacity(true);
    }
    drawItemStatus(index2) {
      const actor2 = self.$gameParty.members()[index2];
      const rect = this.itemRect(index2);
      const x = rect.x + 162;
      const y = rect.y + rect.height / 2 - this.lineHeight() * 1.5;
      const width = rect.width - x - this.textPadding();
      this.drawActorSimpleStatus(actor2, x, y, width);
    }
    processOk() {
      super.processOk();
      self.$gameParty.setMenuActor(self.$gameParty.members()[this.index()]);
    }
    isCurrentItemEnabled() {
      if (this._formationMode) {
        const actor2 = self.$gameParty.members()[this.index()];
        return actor2 && actor2.isFormationChangeOk();
      } else {
        return true;
      }
    }
    selectLast() {
      this.select(self.$gameParty.menuActor().index() || 0);
    }
    formationMode() {
      return this._formationMode;
    }
    setFormationMode(formationMode) {
      this._formationMode = formationMode;
    }
    pendingIndex() {
      return this._pendingIndex;
    }
    setPendingIndex(index2) {
      const lastPendingIndex = this._pendingIndex;
      this._pendingIndex = index2;
      this.redrawItem(this._pendingIndex);
      this.redrawItem(lastPendingIndex);
    }
  };
  var Window_MenuStatus_default = Window_MenuStatus;

  // src-www/js/rpg_windows/Window_MenuActor.js
  var Window_MenuActor = class extends Window_MenuStatus_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize(0, 0);
      this.hide();
    }
    processOk() {
      if (!this.cursorAll()) {
        self.$gameParty.setTargetActor(self.$gameParty.members()[this.index()]);
      }
      this.callOkHandler();
    }
    selectLast() {
      this.select(self.$gameParty.targetActor().index() || 0);
    }
    selectForItem(item2) {
      const actor2 = self.$gameParty.menuActor();
      const action = new Game_Action_default(actor2);
      action.setItemObject(item2);
      this.setCursorFixed(false);
      this.setCursorAll(false);
      if (action.isForUser()) {
        if (DataManager2.isSkill(item2)) {
          this.setCursorFixed(true);
          this.select(actor2.index());
        } else {
          this.selectLast();
        }
      } else if (action.isForAll()) {
        this.setCursorAll(true);
        this.select(0);
      } else {
        this.selectLast();
      }
    }
  };
  var Window_MenuActor_default = Window_MenuActor;

  // src-www/js/rpg_scenes/Scene_ItemBase.js
  var Scene_ItemBase = class extends Scene_MenuBase_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
    }
    create() {
      super.create();
    }
    createActorWindow() {
      this._actorWindow = new Window_MenuActor_default();
      this._actorWindow.setHandler("ok", this.onActorOk.bind(this));
      this._actorWindow.setHandler("cancel", this.onActorCancel.bind(this));
      this.addWindow(this._actorWindow);
    }
    item() {
      return this._itemWindow.item();
    }
    user() {
      return null;
    }
    isCursorLeft() {
      return this._itemWindow.index() % 2 === 0;
    }
    showSubWindow(window2) {
      window2.x = this.isCursorLeft() ? Graphics_default.boxWidth - window2.width : 0;
      window2.show();
      window2.activate();
    }
    hideSubWindow(window2) {
      window2.hide();
      window2.deactivate();
      this.activateItemWindow();
    }
    onActorOk() {
      if (this.canUse()) {
        this.useItem();
      } else {
        SoundManager_default.playBuzzer();
      }
    }
    onActorCancel() {
      this.hideSubWindow(this._actorWindow);
    }
    action() {
      const action = new Game_Action_default(this.user());
      action.setItemObject(this.item());
      return action;
    }
    determineItem() {
      const action = this.action();
      if (action.isForFriend()) {
        this.showSubWindow(this._actorWindow);
        this._actorWindow.selectForItem(this.item());
      } else {
        this.useItem();
        this.activateItemWindow();
      }
    }
    useItem() {
      this.playSeForItem();
      this.user().useItem(this.item());
      this.applyItem();
      this.checkCommonEvent();
      this.checkGameover();
      this._actorWindow.refresh();
    }
    activateItemWindow() {
      this._itemWindow.refresh();
      this._itemWindow.activate();
    }
    itemTargetActors() {
      const action = this.action();
      if (!action.isForFriend()) {
        return [];
      } else if (action.isForAll()) {
        return self.$gameParty.members();
      } else {
        return [self.$gameParty.members()[this._actorWindow.index()]];
      }
    }
    canUse() {
      const user = this.user();
      if (user) {
        return user.canUse(this.item()) && this.isItemEffectsValid();
      }
      return false;
    }
    isItemEffectsValid() {
      const action = this.action();
      return this.itemTargetActors().some(
        (target2) => action.testApply(target2),
        this
      );
    }
    applyItem() {
      const action = this.action();
      const targets = this.itemTargetActors();
      targets.forEach((battler) => {
        const repeats = action.numRepeats();
        for (let i = 0; i < repeats; i++) {
          action.apply(battler);
        }
      });
      action.applyGlobal();
    }
    checkCommonEvent() {
      if (self.$gameTemp.isCommonEventReserved()) {
        SceneManager_default.goto(Scene_Map_default);
      }
    }
  };
  var Scene_ItemBase_default = Scene_ItemBase;

  // src-www/js/rpg_windows/Window_HorzCommand.js
  var Window_HorzCommand = class extends Window_Command_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(x, y) {
      super.initialize(x, y);
    }
    numVisibleRows() {
      return 1;
    }
    maxCols() {
      return 4;
    }
    itemTextAlign() {
      return "center";
    }
  };
  var Window_HorzCommand_default = Window_HorzCommand;

  // src-www/js/rpg_windows/Window_ItemCategory.js
  var Window_ItemCategory = class extends Window_HorzCommand_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize(0, 0);
    }
    windowWidth() {
      return Graphics_default.boxWidth;
    }
    maxCols() {
      return 4;
    }
    update() {
      super.update();
      if (this._itemWindow) {
        this._itemWindow.setCategory(this.currentSymbol());
      }
    }
    makeCommandList() {
      this.addCommand(TextManager_default.item, "item");
      this.addCommand(TextManager_default.weapon, "weapon");
      this.addCommand(TextManager_default.armor, "armor");
      this.addCommand(TextManager_default.keyItem, "keyItem");
    }
    setItemWindow(itemWindow) {
      this._itemWindow = itemWindow;
    }
  };
  var Window_ItemCategory_default = Window_ItemCategory;

  // src-www/js/rpg_scenes/Scene_Item.js
  var Scene_Item = class extends Scene_ItemBase_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
    }
    create() {
      super.create();
      this.createHelpWindow();
      this.createCategoryWindow();
      this.createItemWindow();
      this.createActorWindow();
    }
    createCategoryWindow() {
      this._categoryWindow = new Window_ItemCategory_default();
      this._categoryWindow.setHelpWindow(this._helpWindow);
      this._categoryWindow.y = this._helpWindow.height;
      this._categoryWindow.setHandler("ok", this.onCategoryOk.bind(this));
      this._categoryWindow.setHandler("cancel", this.popScene.bind(this));
      this.addWindow(this._categoryWindow);
    }
    createItemWindow() {
      const wy = this._categoryWindow.y + this._categoryWindow.height;
      const wh = Graphics_default.boxHeight - wy;
      this._itemWindow = new Window_ItemList_default(0, wy, Graphics_default.boxWidth, wh);
      this._itemWindow.setHelpWindow(this._helpWindow);
      this._itemWindow.setHandler("ok", this.onItemOk.bind(this));
      this._itemWindow.setHandler("cancel", this.onItemCancel.bind(this));
      this.addWindow(this._itemWindow);
      this._categoryWindow.setItemWindow(this._itemWindow);
    }
    user() {
      const members = self.$gameParty.movableMembers();
      let bestActor = members[0];
      let bestPha = 0;
      for (let i = 0; i < members.length; i++) {
        if (members[i].pha > bestPha) {
          bestPha = members[i].pha;
          bestActor = members[i];
        }
      }
      return bestActor;
    }
    onCategoryOk() {
      this._itemWindow.activate();
      this._itemWindow.selectLast();
    }
    onItemOk() {
      self.$gameParty.setLastItem(this.item());
      this.determineItem();
    }
    onItemCancel() {
      this._itemWindow.deselect();
      this._categoryWindow.activate();
    }
    playSeForItem() {
      SoundManager_default.playUseItem();
    }
    useItem() {
      super.useItem();
      this._itemWindow.redrawCurrentItem();
    }
  };
  var Scene_Item_default = Scene_Item;

  // src-www/js/rpg_windows/Window_SkillType.js
  var Window_SkillType = class extends Window_Command_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(x, y) {
      super.initialize(x, y);
      this._actor = null;
    }
    windowWidth() {
      return 240;
    }
    setActor(actor2) {
      if (this._actor !== actor2) {
        this._actor = actor2;
        this.refresh();
        this.selectLast();
      }
    }
    numVisibleRows() {
      return 4;
    }
    makeCommandList() {
      if (this._actor) {
        const skillTypes = this._actor.addedSkillTypes();
        skillTypes.sort((a2, b2) => a2 - b2);
        skillTypes.forEach(function(stypeId) {
          const name = self.$dataSystem.skillTypes[stypeId];
          this.addCommand(name, "skill", true, stypeId);
        }, this);
      }
    }
    update() {
      super.update();
      if (this._skillWindow) {
        this._skillWindow.setStypeId(this.currentExt());
      }
    }
    setSkillWindow(skillWindow) {
      this._skillWindow = skillWindow;
    }
    selectLast() {
      const skill = this._actor.lastMenuSkill();
      if (skill) {
        this.selectExt(skill.stypeId);
      } else {
        this.select(0);
      }
    }
  };
  var Window_SkillType_default = Window_SkillType;

  // src-www/js/rpg_windows/Window_SkillStatus.js
  var Window_SkillStatus = class extends Window_Base_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(x, y, width, height) {
      super.initialize(x, y, width, height);
      this._actor = null;
    }
    setActor(actor2) {
      if (this._actor !== actor2) {
        this._actor = actor2;
        this.refresh();
      }
    }
    refresh() {
      this.contents.clear();
      if (this._actor) {
        const w = this.width - this.padding * 2;
        const h = this.height - this.padding * 2;
        const y = h / 2 - this.lineHeight() * 1.5;
        const width = w - 162 - this.textPadding();
        this.drawActorFace(this._actor, 0, 0, 144, h);
        this.drawActorSimpleStatus(this._actor, 162, y, width);
      }
    }
  };
  var Window_SkillStatus_default = Window_SkillStatus;

  // src-www/js/rpg_scenes/Scene_Skill.js
  var Scene_Skill = class extends Scene_ItemBase_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
    }
    create() {
      super.create();
      this.createHelpWindow();
      this.createSkillTypeWindow();
      this.createStatusWindow();
      this.createItemWindow();
      this.createActorWindow();
    }
    start() {
      super.start();
      this.refreshActor();
    }
    createSkillTypeWindow() {
      const wy = this._helpWindow.height;
      this._skillTypeWindow = new Window_SkillType_default(0, wy);
      this._skillTypeWindow.setHelpWindow(this._helpWindow);
      this._skillTypeWindow.setHandler("skill", this.commandSkill.bind(this));
      this._skillTypeWindow.setHandler("cancel", this.popScene.bind(this));
      this._skillTypeWindow.setHandler("pagedown", this.nextActor.bind(this));
      this._skillTypeWindow.setHandler("pageup", this.previousActor.bind(this));
      this.addWindow(this._skillTypeWindow);
    }
    createStatusWindow() {
      const wx = this._skillTypeWindow.width;
      const wy = this._helpWindow.height;
      const ww = Graphics_default.boxWidth - wx;
      const wh = this._skillTypeWindow.height;
      this._statusWindow = new Window_SkillStatus_default(wx, wy, ww, wh);
      this._statusWindow.reserveFaceImages();
      this.addWindow(this._statusWindow);
    }
    createItemWindow() {
      const wx = 0;
      const wy = this._statusWindow.y + this._statusWindow.height;
      const ww = Graphics_default.boxWidth;
      const wh = Graphics_default.boxHeight - wy;
      this._itemWindow = new Window_SkillList_default(wx, wy, ww, wh);
      this._itemWindow.setHelpWindow(this._helpWindow);
      this._itemWindow.setHandler("ok", this.onItemOk.bind(this));
      this._itemWindow.setHandler("cancel", this.onItemCancel.bind(this));
      this._skillTypeWindow.setSkillWindow(this._itemWindow);
      this.addWindow(this._itemWindow);
    }
    refreshActor() {
      const actor2 = this.actor();
      this._skillTypeWindow.setActor(actor2);
      this._statusWindow.setActor(actor2);
      this._itemWindow.setActor(actor2);
    }
    user() {
      return this.actor();
    }
    commandSkill() {
      this._itemWindow.activate();
      this._itemWindow.selectLast();
    }
    onItemOk() {
      this.actor().setLastMenuSkill(this.item());
      this.determineItem();
    }
    onItemCancel() {
      this._itemWindow.deselect();
      this._skillTypeWindow.activate();
    }
    playSeForItem() {
      SoundManager_default.playUseSkill();
    }
    useItem() {
      super.useItem();
      this._statusWindow.refresh();
      this._itemWindow.refresh();
    }
    onActorChange() {
      this.refreshActor();
      this._skillTypeWindow.activate();
    }
  };
  var Scene_Skill_default = Scene_Skill;

  // src-www/js/rpg_windows/Window_EquipStatus.js
  var Window_EquipStatus = class extends Window_Base_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(x, y) {
      const width = this.windowWidth();
      const height = this.windowHeight();
      super.initialize(x, y, width, height);
      this._actor = null;
      this._tempActor = null;
      this.refresh();
    }
    windowWidth() {
      return 312;
    }
    windowHeight() {
      return this.fittingHeight(this.numVisibleRows());
    }
    numVisibleRows() {
      return 7;
    }
    setActor(actor2) {
      if (this._actor !== actor2) {
        this._actor = actor2;
        this.refresh();
      }
    }
    refresh() {
      this.contents.clear();
      if (this._actor) {
        this.drawActorName(this._actor, this.textPadding(), 0);
        for (let i = 0; i < 6; i++) {
          this.drawItem(0, this.lineHeight() * (1 + i), 2 + i);
        }
      }
    }
    setTempActor(tempActor) {
      if (this._tempActor !== tempActor) {
        this._tempActor = tempActor;
        this.refresh();
      }
    }
    drawItem(x, y, paramId) {
      this.drawParamName(x + this.textPadding(), y, paramId);
      if (this._actor) {
        this.drawCurrentParam(x + 140, y, paramId);
      }
      this.drawRightArrow(x + 188, y);
      if (this._tempActor) {
        this.drawNewParam(x + 222, y, paramId);
      }
    }
    drawParamName(x, y, paramId) {
      this.changeTextColor(this.systemColor());
      this.drawText(TextManager_default.param(paramId), x, y, 120);
    }
    drawCurrentParam(x, y, paramId) {
      this.resetTextColor();
      this.drawText(this._actor.param(paramId), x, y, 48, "right");
    }
    drawRightArrow(x, y) {
      this.changeTextColor(this.systemColor());
      this.drawText("\u2192", x, y, 32, "center");
    }
    drawNewParam(x, y, paramId) {
      const newValue = this._tempActor.param(paramId);
      const diffvalue = newValue - this._actor.param(paramId);
      this.changeTextColor(this.paramchangeTextColor(diffvalue));
      this.drawText(newValue, x, y, 48, "right");
    }
  };
  var Window_EquipStatus_default = Window_EquipStatus;

  // src-www/js/rpg_windows/Window_EquipCommand.js
  var Window_EquipCommand = class extends Window_HorzCommand_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(x, y, width) {
      this._windowWidth = width;
      super.initialize(x, y);
    }
    windowWidth() {
      return this._windowWidth;
    }
    maxCols() {
      return 3;
    }
    makeCommandList() {
      this.addCommand(TextManager_default.equip2, "equip");
      this.addCommand(TextManager_default.optimize, "optimize");
      this.addCommand(TextManager_default.clear, "clear");
    }
  };
  var Window_EquipCommand_default = Window_EquipCommand;

  // src-www/js/rpg_windows/Window_EquipSlot.js
  var Window_EquipSlot = class extends Window_Selectable_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(x, y, width, height) {
      super.initialize(x, y, width, height);
      this._actor = null;
      this.refresh();
    }
    setActor(actor2) {
      if (this._actor !== actor2) {
        this._actor = actor2;
        this.refresh();
      }
    }
    update() {
      super.update();
      if (this._itemWindow) {
        this._itemWindow.setSlotId(this.index());
      }
    }
    maxItems() {
      return this._actor ? this._actor.equipSlots().length : 0;
    }
    item() {
      return this._actor ? this._actor.equips()[this.index()] : null;
    }
    drawItem(index2) {
      if (this._actor) {
        const rect = this.itemRectForText(index2);
        this.changeTextColor(this.systemColor());
        this.changePaintOpacity(this.isEnabled(index2));
        this.drawText(
          this.slotName(index2),
          rect.x,
          rect.y,
          138,
          this.lineHeight()
        );
        this.drawItemName(this._actor.equips()[index2], rect.x + 138, rect.y);
        this.changePaintOpacity(true);
      }
    }
    slotName(index2) {
      const slots = this._actor.equipSlots();
      return this._actor ? self.$dataSystem.equipTypes[slots[index2]] : "";
    }
    isEnabled(index2) {
      return this._actor ? this._actor.isEquipChangeOk(index2) : false;
    }
    isCurrentItemEnabled() {
      return this.isEnabled(this.index());
    }
    setStatusWindow(statusWindow) {
      this._statusWindow = statusWindow;
      this.callUpdateHelp();
    }
    setItemWindow(itemWindow) {
      this._itemWindow = itemWindow;
    }
    updateHelp() {
      super.updateHelp();
      this.setHelpWindowItem(this.item());
      if (this._statusWindow) {
        this._statusWindow.setTempActor(null);
      }
    }
  };
  var Window_EquipSlot_default = Window_EquipSlot;

  // src-www/js/rpg_windows/Window_EquipItem.js
  var Window_EquipItem = class extends Window_ItemList_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(x, y, width, height) {
      super.initialize(x, y, width, height);
      this._actor = null;
      this._slotId = 0;
    }
    setActor(actor2) {
      if (this._actor !== actor2) {
        this._actor = actor2;
        this.refresh();
        this.resetScroll();
      }
    }
    setSlotId(slotId) {
      if (this._slotId !== slotId) {
        this._slotId = slotId;
        this.refresh();
        this.resetScroll();
      }
    }
    includes(item2) {
      if (item2 === null) {
        return true;
      }
      if (this._slotId < 0 || item2.etypeId !== this._actor.equipSlots()[this._slotId]) {
        return false;
      }
      return this._actor.canEquip(item2);
    }
    isEnabled(item2) {
      return true;
    }
    selectLast() {
    }
    setStatusWindow(statusWindow) {
      this._statusWindow = statusWindow;
      this.callUpdateHelp();
    }
    updateHelp() {
      super.updateHelp();
      if (this._actor && this._statusWindow) {
        const actor2 = JsonEx_default.makeDeepCopy(this._actor);
        actor2.forceChangeEquip(this._slotId, this.item());
        this._statusWindow.setTempActor(actor2);
      }
    }
    playOkSound() {
    }
  };
  var Window_EquipItem_default = Window_EquipItem;

  // src-www/js/rpg_scenes/Scene_Equip.js
  var Scene_Equip = class extends Scene_MenuBase_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
    }
    create() {
      super.create();
      this.createHelpWindow();
      this.createStatusWindow();
      this.createCommandWindow();
      this.createSlotWindow();
      this.createItemWindow();
      this.refreshActor();
    }
    createStatusWindow() {
      this._statusWindow = new Window_EquipStatus_default(0, this._helpWindow.height);
      this.addWindow(this._statusWindow);
    }
    createCommandWindow() {
      const wx = this._statusWindow.width;
      const wy = this._helpWindow.height;
      const ww = Graphics_default.boxWidth - this._statusWindow.width;
      this._commandWindow = new Window_EquipCommand_default(wx, wy, ww);
      this._commandWindow.setHelpWindow(this._helpWindow);
      this._commandWindow.setHandler("equip", this.commandEquip.bind(this));
      this._commandWindow.setHandler("optimize", this.commandOptimize.bind(this));
      this._commandWindow.setHandler("clear", this.commandClear.bind(this));
      this._commandWindow.setHandler("cancel", this.popScene.bind(this));
      this._commandWindow.setHandler("pagedown", this.nextActor.bind(this));
      this._commandWindow.setHandler("pageup", this.previousActor.bind(this));
      this.addWindow(this._commandWindow);
    }
    createSlotWindow() {
      const wx = this._statusWindow.width;
      const wy = this._commandWindow.y + this._commandWindow.height;
      const ww = Graphics_default.boxWidth - this._statusWindow.width;
      const wh = this._statusWindow.height - this._commandWindow.height;
      this._slotWindow = new Window_EquipSlot_default(wx, wy, ww, wh);
      this._slotWindow.setHelpWindow(this._helpWindow);
      this._slotWindow.setStatusWindow(this._statusWindow);
      this._slotWindow.setHandler("ok", this.onSlotOk.bind(this));
      this._slotWindow.setHandler("cancel", this.onSlotCancel.bind(this));
      this.addWindow(this._slotWindow);
    }
    createItemWindow() {
      const wx = 0;
      const wy = this._statusWindow.y + this._statusWindow.height;
      const ww = Graphics_default.boxWidth;
      const wh = Graphics_default.boxHeight - wy;
      this._itemWindow = new Window_EquipItem_default(wx, wy, ww, wh);
      this._itemWindow.setHelpWindow(this._helpWindow);
      this._itemWindow.setStatusWindow(this._statusWindow);
      this._itemWindow.setHandler("ok", this.onItemOk.bind(this));
      this._itemWindow.setHandler("cancel", this.onItemCancel.bind(this));
      this._slotWindow.setItemWindow(this._itemWindow);
      this.addWindow(this._itemWindow);
    }
    refreshActor() {
      const actor2 = this.actor();
      this._statusWindow.setActor(actor2);
      this._slotWindow.setActor(actor2);
      this._itemWindow.setActor(actor2);
    }
    commandEquip() {
      this._slotWindow.activate();
      this._slotWindow.select(0);
    }
    commandOptimize() {
      SoundManager_default.playEquip();
      this.actor().optimizeEquipments();
      this._statusWindow.refresh();
      this._slotWindow.refresh();
      this._commandWindow.activate();
    }
    commandClear() {
      SoundManager_default.playEquip();
      this.actor().clearEquipments();
      this._statusWindow.refresh();
      this._slotWindow.refresh();
      this._commandWindow.activate();
    }
    onSlotOk() {
      this._itemWindow.activate();
      this._itemWindow.select(0);
    }
    onSlotCancel() {
      this._slotWindow.deselect();
      this._commandWindow.activate();
    }
    onItemOk() {
      SoundManager_default.playEquip();
      this.actor().changeEquip(this._slotWindow.index(), this._itemWindow.item());
      this._slotWindow.activate();
      this._slotWindow.refresh();
      this._itemWindow.deselect();
      this._itemWindow.refresh();
      this._statusWindow.refresh();
    }
    onItemCancel() {
      this._slotWindow.activate();
      this._itemWindow.deselect();
    }
    onActorChange() {
      this.refreshActor();
      this._commandWindow.activate();
    }
  };
  var Scene_Equip_default = Scene_Equip;

  // src-www/js/rpg_windows/Window_Status.js
  var Window_Status = class extends Window_Selectable_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      const width = Graphics_default.boxWidth;
      const height = Graphics_default.boxHeight;
      super.initialize(0, 0, width, height);
      this._actor = null;
      this.refresh();
      this.activate();
    }
    setActor(actor2) {
      if (this._actor !== actor2) {
        this._actor = actor2;
        this.refresh();
      }
    }
    refresh() {
      this.contents.clear();
      if (this._actor) {
        const lineHeight = this.lineHeight();
        this.drawBlock1(lineHeight * 0);
        this.drawHorzLine(lineHeight * 1);
        this.drawBlock2(lineHeight * 2);
        this.drawHorzLine(lineHeight * 6);
        this.drawBlock3(lineHeight * 7);
        this.drawHorzLine(lineHeight * 13);
        this.drawBlock4(lineHeight * 14);
      }
    }
    drawBlock1(y) {
      this.drawActorName(this._actor, 6, y);
      this.drawActorClass(this._actor, 192, y);
      this.drawActorNickname(this._actor, 432, y);
    }
    drawBlock2(y) {
      this.drawActorFace(this._actor, 12, y);
      this.drawBasicInfo(204, y);
      this.drawExpInfo(456, y);
    }
    drawBlock3(y) {
      this.drawParameters(48, y);
      this.drawEquipments(432, y);
    }
    drawBlock4(y) {
      this.drawProfile(6, y);
    }
    drawHorzLine(y) {
      const lineY = y + this.lineHeight() / 2 - 1;
      this.contents.paintOpacity = 48;
      this.contents.fillRect(0, lineY, this.contentsWidth(), 2, this.lineColor());
      this.contents.paintOpacity = 255;
    }
    lineColor() {
      return this.normalColor();
    }
    drawBasicInfo(x, y) {
      const lineHeight = this.lineHeight();
      this.drawActorLevel(this._actor, x, y + lineHeight * 0);
      this.drawActorIcons(this._actor, x, y + lineHeight * 1);
      this.drawActorHp(this._actor, x, y + lineHeight * 2);
      this.drawActorMp(this._actor, x, y + lineHeight * 3);
    }
    drawParameters(x, y) {
      const lineHeight = this.lineHeight();
      for (let i = 0; i < 6; i++) {
        const paramId = i + 2;
        const y2 = y + lineHeight * i;
        this.changeTextColor(this.systemColor());
        this.drawText(TextManager_default.param(paramId), x, y2, 160);
        this.resetTextColor();
        this.drawText(this._actor.param(paramId), x + 160, y2, 60, "right");
      }
    }
    drawExpInfo(x, y) {
      const lineHeight = this.lineHeight();
      const expTotal = TextManager_default.expTotal.format(TextManager_default.exp);
      const expNext = TextManager_default.expNext.format(TextManager_default.level);
      let value12 = this._actor.currentExp();
      let value22 = this._actor.nextRequiredExp();
      if (this._actor.isMaxLevel()) {
        value12 = "-------";
        value22 = "-------";
      }
      this.changeTextColor(this.systemColor());
      this.drawText(expTotal, x, y + lineHeight * 0, 270);
      this.drawText(expNext, x, y + lineHeight * 2, 270);
      this.resetTextColor();
      this.drawText(value12, x, y + lineHeight * 1, 270, "right");
      this.drawText(value22, x, y + lineHeight * 3, 270, "right");
    }
    drawEquipments(x, y) {
      const equips = this._actor.equips();
      const count = Math.min(equips.length, this.maxEquipmentLines());
      for (let i = 0; i < count; i++) {
        this.drawItemName(equips[i], x, y + this.lineHeight() * i);
      }
    }
    drawProfile(x, y) {
      this.drawTextEx(this._actor.profile(), x, y);
    }
    maxEquipmentLines() {
      return 6;
    }
  };
  var Window_Status_default = Window_Status;

  // src-www/js/rpg_scenes/Scene_Status.js
  var Scene_Status = class extends Scene_MenuBase_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
    }
    create() {
      super.create();
      this._statusWindow = new Window_Status_default();
      this._statusWindow.setHandler("cancel", this.popScene.bind(this));
      this._statusWindow.setHandler("pagedown", this.nextActor.bind(this));
      this._statusWindow.setHandler("pageup", this.previousActor.bind(this));
      this._statusWindow.reserveFaceImages();
      this.addWindow(this._statusWindow);
    }
    start() {
      super.start();
      this.refreshActor();
    }
    refreshActor() {
      const actor2 = this.actor();
      this._statusWindow.setActor(actor2);
    }
    onActorChange() {
      this.refreshActor();
      this._statusWindow.activate();
    }
  };
  var Scene_Status_default = Scene_Status;

  // src-www/js/rpg_windows/Window_Options.js
  var Window_Options = class extends Window_Command_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize(0, 0);
      this.updatePlacement();
    }
    windowWidth() {
      return 400;
    }
    windowHeight() {
      return this.fittingHeight(Math.min(this.numVisibleRows(), 12));
    }
    updatePlacement() {
      this.x = (Graphics_default.boxWidth - this.width) / 2;
      this.y = (Graphics_default.boxHeight - this.height) / 2;
    }
    makeCommandList() {
      this.addGeneralOptions();
      this.addVolumeOptions();
    }
    addGeneralOptions() {
      this.addCommand(TextManager_default.alwaysDash, "alwaysDash");
      this.addCommand(TextManager_default.commandRemember, "commandRemember");
    }
    addVolumeOptions() {
      this.addCommand(TextManager_default.bgmVolume, "bgmVolume");
      this.addCommand(TextManager_default.bgsVolume, "bgsVolume");
      this.addCommand(TextManager_default.meVolume, "meVolume");
      this.addCommand(TextManager_default.seVolume, "seVolume");
    }
    drawItem(index2) {
      const rect = this.itemRectForText(index2);
      const statusWidth = this.statusWidth();
      const titleWidth = rect.width - statusWidth;
      this.resetTextColor();
      this.changePaintOpacity(this.isCommandEnabled(index2));
      this.drawText(this.commandName(index2), rect.x, rect.y, titleWidth, "left");
      this.drawText(
        this.statusText(index2),
        rect.x + titleWidth,
        rect.y,
        statusWidth,
        "right"
      );
    }
    statusWidth() {
      return 120;
    }
    statusText(index2) {
      const symbol = this.commandSymbol(index2);
      const value3 = this.getConfigValue(symbol);
      if (this.isVolumeSymbol(symbol)) {
        return this.volumeStatusText(value3);
      } else {
        return this.booleanStatusText(value3);
      }
    }
    isVolumeSymbol(symbol) {
      return symbol.contains("Volume");
    }
    booleanStatusText(value3) {
      return value3 ? "ON" : "OFF";
    }
    volumeStatusText(value3) {
      return `${value3}%`;
    }
    processOk() {
      const index2 = this.index();
      const symbol = this.commandSymbol(index2);
      let value3 = this.getConfigValue(symbol);
      if (this.isVolumeSymbol(symbol)) {
        value3 += this.volumeOffset();
        if (value3 > 100) {
          value3 = 0;
        }
        value3 = value3.clamp(0, 100);
        this.changeValue(symbol, value3);
      } else {
        this.changeValue(symbol, !value3);
      }
    }
    cursorRight(wrap) {
      const index2 = this.index();
      const symbol = this.commandSymbol(index2);
      let value3 = this.getConfigValue(symbol);
      if (this.isVolumeSymbol(symbol)) {
        value3 += this.volumeOffset();
        value3 = value3.clamp(0, 100);
        this.changeValue(symbol, value3);
      } else {
        this.changeValue(symbol, true);
      }
    }
    cursorLeft(wrap) {
      const index2 = this.index();
      const symbol = this.commandSymbol(index2);
      let value3 = this.getConfigValue(symbol);
      if (this.isVolumeSymbol(symbol)) {
        value3 -= this.volumeOffset();
        value3 = value3.clamp(0, 100);
        this.changeValue(symbol, value3);
      } else {
        this.changeValue(symbol, false);
      }
    }
    volumeOffset() {
      return 20;
    }
    changeValue(symbol, value3) {
      const lastValue = this.getConfigValue(symbol);
      if (lastValue !== value3) {
        this.setConfigValue(symbol, value3);
        this.redrawItem(this.findSymbol(symbol));
        SoundManager_default.playCursor();
      }
    }
    getConfigValue(symbol) {
      return ConfigManager_default[symbol];
    }
    setConfigValue(symbol, volume) {
      ConfigManager_default[symbol] = volume;
    }
  };
  var Window_Options_default = Window_Options;

  // src-www/js/rpg_scenes/Scene_Options.js
  var Scene_Options = class extends Scene_MenuBase_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
    }
    create() {
      super.create();
      this.createOptionsWindow();
    }
    terminate() {
      super.terminate();
      ConfigManager_default.save();
    }
    createOptionsWindow() {
      this._optionsWindow = new Window_Options_default();
      this._optionsWindow.setHandler("cancel", this.popScene.bind(this));
      this.addWindow(this._optionsWindow);
    }
  };
  var Scene_Options_default = Scene_Options;

  // src-www/js/rpg_windows/Window_SavefileList.js
  var Window_SavefileList = class extends Window_Selectable_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(x, y, width, height) {
      super.initialize(x, y, width, height);
      this.activate();
      this._mode = null;
    }
    setMode(mode) {
      this._mode = mode;
    }
    maxItems() {
      return DataManager2.maxSavefiles();
    }
    maxVisibleItems() {
      return 5;
    }
    itemHeight() {
      const innerHeight = this.height - this.padding * 2;
      return Math.floor(innerHeight / this.maxVisibleItems());
    }
    drawItem(index2) {
      const id = index2 + 1;
      const valid = DataManager2.isThisGameFile(id);
      const info = DataManager2.loadSavefileInfo(id);
      const rect = this.itemRectForText(index2);
      this.resetTextColor();
      if (this._mode === "load") {
        this.changePaintOpacity(valid);
      }
      this.drawFileId(id, rect.x, rect.y);
      if (info) {
        this.changePaintOpacity(valid);
        this.drawContents(info, rect, valid);
        this.changePaintOpacity(true);
      }
    }
    drawFileId(id, x, y) {
      if (DataManager2.isAutoSaveFileId(id)) {
        if (this._mode === "save") {
          this.changePaintOpacity(false);
        }
        this.drawText(`${TextManager_default.file} ${id}(Auto)`, x, y, 180);
      } else {
        this.drawText(`${TextManager_default.file} ${id}`, x, y, 180);
      }
    }
    drawContents(info, { y, height, width, x }, valid) {
      const bottom = y + height;
      if (width >= 420) {
        this.drawGameTitle(info, x + 192, y, width - 192);
        if (valid) {
          this.drawPartyCharacters(info, x + 220, bottom - 4);
        }
      }
      const lineHeight = this.lineHeight();
      const y2 = bottom - lineHeight;
      if (y2 >= lineHeight) {
        this.drawPlaytime(info, x, y2, width);
      }
    }
    drawGameTitle({ title }, x, y, width) {
      if (title) {
        this.drawText(title, x, y, width);
      }
    }
    drawPartyCharacters({ characters }, x, y) {
      if (characters) {
        characters.forEach((data, i) => {
          this.drawCharacter(data[0], data[1], x + i * 48, y);
        });
      }
    }
    drawPlaytime({ playtime }, x, y, width) {
      if (playtime) {
        this.drawText(playtime, x, y, width, "right");
      }
    }
    playOkSound() {
    }
  };
  var Window_SavefileList_default = Window_SavefileList;

  // src-www/js/rpg_scenes/Scene_File.js
  var Scene_File = class extends Scene_MenuBase_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
    }
    create() {
      super.create();
      DataManager2.loadAllSavefileImages();
      this.createHelpWindow();
      this.createListWindow();
    }
    start() {
      super.start();
      this._listWindow.refresh();
    }
    savefileId() {
      return this._listWindow.index() + 1;
    }
    createHelpWindow() {
      this._helpWindow = new Window_Help_default(1);
      this._helpWindow.setText(this.helpWindowText());
      this.addWindow(this._helpWindow);
    }
    createListWindow() {
      const x = 0;
      const y = this._helpWindow.height;
      const width = Graphics_default.boxWidth;
      const height = Graphics_default.boxHeight - y;
      this._listWindow = new Window_SavefileList_default(x, y, width, height);
      this._listWindow.setHandler("ok", this.onSavefileOk.bind(this));
      this._listWindow.setHandler("cancel", this.popScene.bind(this));
      this._listWindow.select(this.firstSavefileIndex());
      this._listWindow.setTopRow(this.firstSavefileIndex() - 2);
      this._listWindow.setMode(this.mode());
      this._listWindow.refresh();
      this.addWindow(this._listWindow);
    }
    mode() {
      return null;
    }
    activateListWindow() {
      this._listWindow.activate();
    }
    helpWindowText() {
      return "";
    }
    firstSavefileIndex() {
      return 0;
    }
    onSavefileOk() {
    }
  };
  var Scene_File_default = Scene_File;

  // src-www/js/rpg_scenes/Scene_Save.js
  var Scene_Save = class extends Scene_File_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
    }
    mode() {
      return "save";
    }
    helpWindowText() {
      return TextManager_default.saveMessage;
    }
    firstSavefileIndex() {
      return DataManager2.lastAccessedSavefileId() - 1;
    }
    onSavefileOk() {
      if (DataManager2.isAutoSaveFileId(this.savefileId())) {
        this.onSaveFailure();
        return;
      }
      super.onSavefileOk();
      self.$gameSystem.onBeforeSave();
      if (DataManager2.saveGame(this.savefileId())) {
        this.onSaveSuccess();
      } else {
        this.onSaveFailure();
      }
    }
    onSaveSuccess() {
      SoundManager_default.playSave();
      StorageManagerShim_default.cleanBackup(this.savefileId());
      this.popScene();
    }
    onSaveFailure() {
      SoundManager_default.playBuzzer();
      this.activateListWindow();
    }
  };
  var Scene_Save_default = Scene_Save;

  // src-www/js/rpg_windows/Window_GameEnd.js
  var Window_GameEnd = class extends Window_Command_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize(0, 0);
      this.updatePlacement();
      this.openness = 0;
      this.open();
    }
    windowWidth() {
      return 240;
    }
    updatePlacement() {
      this.x = (Graphics_default.boxWidth - this.width) / 2;
      this.y = (Graphics_default.boxHeight - this.height) / 2;
    }
    makeCommandList() {
      this.addCommand(TextManager_default.toTitle, "toTitle");
      this.addCommand(TextManager_default.cancel, "cancel");
    }
  };
  var Window_GameEnd_default = Window_GameEnd;

  // src-www/js/rpg_scenes/Scene_GameEnd.js
  var Scene_GameEnd = class extends Scene_MenuBase_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
    }
    create() {
      super.create();
      this.createCommandWindow();
    }
    stop() {
      super.stop();
      this._commandWindow.close();
    }
    createBackground() {
      super.createBackground();
      this.setBackgroundOpacity(128);
    }
    createCommandWindow() {
      this._commandWindow = new Window_GameEnd_default();
      this._commandWindow.setHandler("toTitle", this.commandToTitle.bind(this));
      this._commandWindow.setHandler("cancel", this.popScene.bind(this));
      this.addWindow(this._commandWindow);
    }
    commandToTitle() {
      this.fadeOutAll();
      SceneManager_default.goto(Scene_Title_default);
    }
  };
  var Scene_GameEnd_default = Scene_GameEnd;

  // src-www/js/rpg_scenes/Scene_Menu.js
  var Scene_Menu = class extends Scene_MenuBase_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
    }
    create() {
      super.create();
      this.createCommandWindow();
      this.createGoldWindow();
      this.createStatusWindow();
    }
    start() {
      super.start();
      this._statusWindow.refresh();
    }
    createCommandWindow() {
      this._commandWindow = new Window_MenuCommand_default(0, 0);
      this._commandWindow.setHandler("item", this.commandItem.bind(this));
      this._commandWindow.setHandler("skill", this.commandPersonal.bind(this));
      this._commandWindow.setHandler("equip", this.commandPersonal.bind(this));
      this._commandWindow.setHandler("status", this.commandPersonal.bind(this));
      this._commandWindow.setHandler(
        "formation",
        this.commandFormation.bind(this)
      );
      this._commandWindow.setHandler("options", this.commandOptions.bind(this));
      this._commandWindow.setHandler("save", this.commandSave.bind(this));
      this._commandWindow.setHandler("gameEnd", this.commandGameEnd.bind(this));
      this._commandWindow.setHandler("cancel", this.popScene.bind(this));
      this.addWindow(this._commandWindow);
    }
    createGoldWindow() {
      this._goldWindow = new Window_Gold_default(0, 0);
      this._goldWindow.y = Graphics_default.boxHeight - this._goldWindow.height;
      this.addWindow(this._goldWindow);
    }
    createStatusWindow() {
      this._statusWindow = new Window_MenuStatus_default(this._commandWindow.width, 0);
      this._statusWindow.reserveFaceImages();
      this.addWindow(this._statusWindow);
    }
    commandItem() {
      SceneManager_default.push(Scene_Item_default);
    }
    commandPersonal() {
      this._statusWindow.setFormationMode(false);
      this._statusWindow.selectLast();
      this._statusWindow.activate();
      this._statusWindow.setHandler("ok", this.onPersonalOk.bind(this));
      this._statusWindow.setHandler("cancel", this.onPersonalCancel.bind(this));
    }
    commandFormation() {
      this._statusWindow.setFormationMode(true);
      this._statusWindow.selectLast();
      this._statusWindow.activate();
      this._statusWindow.setHandler("ok", this.onFormationOk.bind(this));
      this._statusWindow.setHandler("cancel", this.onFormationCancel.bind(this));
    }
    commandOptions() {
      SceneManager_default.push(Scene_Options_default);
    }
    commandSave() {
      SceneManager_default.push(Scene_Save_default);
    }
    commandGameEnd() {
      SceneManager_default.push(Scene_GameEnd_default);
    }
    onPersonalOk() {
      switch (this._commandWindow.currentSymbol()) {
        case "skill":
          SceneManager_default.push(Scene_Skill_default);
          break;
        case "equip":
          SceneManager_default.push(Scene_Equip_default);
          break;
        case "status":
          SceneManager_default.push(Scene_Status_default);
          break;
      }
    }
    onPersonalCancel() {
      this._statusWindow.deselect();
      this._commandWindow.activate();
    }
    onFormationOk() {
      const index2 = this._statusWindow.index();
      const pendingIndex = this._statusWindow.pendingIndex();
      if (pendingIndex >= 0) {
        self.$gameParty.swapOrder(index2, pendingIndex);
        this._statusWindow.setPendingIndex(-1);
        this._statusWindow.redrawItem(index2);
      } else {
        this._statusWindow.setPendingIndex(index2);
      }
      this._statusWindow.activate();
    }
    onFormationCancel() {
      if (this._statusWindow.pendingIndex() >= 0) {
        this._statusWindow.setPendingIndex(-1);
        this._statusWindow.activate();
      } else {
        this._statusWindow.deselect();
        this._commandWindow.activate();
      }
    }
  };
  var Scene_Menu_default = Scene_Menu;

  // src-www/js/rpg_scenes/Scene_Load.js
  var Scene_Load = class extends Scene_File_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
      this._loadSuccess = false;
    }
    terminate() {
      super.terminate();
      if (this._loadSuccess) {
        self.$gameSystem.onAfterLoad();
      }
    }
    mode() {
      return "load";
    }
    helpWindowText() {
      return TextManager_default.loadMessage;
    }
    firstSavefileIndex() {
      return DataManager2.latestSavefileId() - 1;
    }
    async onSavefileOk() {
      super.onSavefileOk();
      if (await DataManager2.loadGame(this.savefileId())) {
        this.onLoadSuccess();
      } else {
        this.onLoadFailure();
      }
    }
    onLoadSuccess() {
      SoundManager_default.playLoad();
      this.fadeOutAll();
      this.reloadMapIfUpdated();
      SceneManager_default.goto(Scene_Map_default);
      this._loadSuccess = true;
    }
    onLoadFailure() {
      SoundManager_default.playBuzzer();
      this.activateListWindow();
    }
    reloadMapIfUpdated() {
      if (self.$gameSystem.versionId() !== self.$dataSystem.versionId) {
        self.$gamePlayer.reserveTransfer(
          self.$gameMap.mapId(),
          self.$gamePlayer.x,
          self.$gamePlayer.y
        );
        self.$gamePlayer.requestMapReload();
      }
    }
  };
  var Scene_Load_default = Scene_Load;

  // src-www/js/rpg_windows/Window_DebugRange.js
  var Window_DebugRange = class extends Window_Selectable_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(x, y) {
      this._maxSwitches = Math.ceil((self.$dataSystem.switches.length - 1) / 10);
      this._maxVariables = Math.ceil(
        (self.$dataSystem.variables.length - 1) / 10
      );
      const width = this.windowWidth();
      const height = this.windowHeight();
      super.initialize(x, y, width, height);
      this.refresh();
      this.setTopRow(Window_DebugRange.lastTopRow);
      this.select(Window_DebugRange.lastIndex);
      this.activate();
    }
    windowWidth() {
      return 246;
    }
    windowHeight() {
      return Graphics_default.boxHeight;
    }
    maxItems() {
      return this._maxSwitches + this._maxVariables;
    }
    update() {
      super.update();
      if (this._editWindow) {
        this._editWindow.setMode(this.mode());
        this._editWindow.setTopId(this.topId());
      }
    }
    mode() {
      return this.index() < this._maxSwitches ? "switch" : "variable";
    }
    topId() {
      const index2 = this.index();
      if (index2 < this._maxSwitches) {
        return index2 * 10 + 1;
      } else {
        return (index2 - this._maxSwitches) * 10 + 1;
      }
    }
    refresh() {
      this.createContents();
      this.drawAllItems();
    }
    drawItem(index2) {
      const rect = this.itemRectForText(index2);
      let start;
      let text;
      if (index2 < this._maxSwitches) {
        start = index2 * 10 + 1;
        text = "S";
      } else {
        start = (index2 - this._maxSwitches) * 10 + 1;
        text = "V";
      }
      const end = start + 9;
      text += ` [${start.padZero(4)}-${end.padZero(4)}]`;
      this.drawText(text, rect.x, rect.y, rect.width);
    }
    isCancelTriggered() {
      return Window_Selectable_default.prototype.isCancelTriggered() || Input_default.isTriggered("debug");
    }
    processCancel() {
      super.processCancel();
      Window_DebugRange.lastTopRow = this.topRow();
      Window_DebugRange.lastIndex = this.index();
    }
    setEditWindow(editWindow) {
      this._editWindow = editWindow;
    }
  };
  Window_DebugRange.lastTopRow = 0;
  Window_DebugRange.lastIndex = 0;
  var Window_DebugRange_default = Window_DebugRange;

  // src-www/js/rpg_windows/Window_DebugEdit.js
  var Window_DebugEdit = class extends Window_Selectable_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(x, y, width) {
      const height = this.fittingHeight(10);
      super.initialize(x, y, width, height);
      this._mode = "switch";
      this._topId = 1;
      this.refresh();
    }
    maxItems() {
      return 10;
    }
    refresh() {
      this.contents.clear();
      this.drawAllItems();
    }
    drawItem(index2) {
      const dataId = this._topId + index2;
      const idText = `${dataId.padZero(4)}:`;
      const idWidth = this.textWidth(idText);
      const statusWidth = this.textWidth("-00000000");
      const name = this.itemName(dataId);
      const status = this.itemStatus(dataId);
      const rect = this.itemRectForText(index2);
      this.resetTextColor();
      this.drawText(idText, rect.x, rect.y, rect.width);
      rect.x += idWidth;
      rect.width -= idWidth + statusWidth;
      this.drawText(name, rect.x, rect.y, rect.width);
      this.drawText(status, rect.x + rect.width, rect.y, statusWidth, "right");
    }
    itemName(dataId) {
      if (this._mode === "switch") {
        return self.$dataSystem.switches[dataId];
      } else {
        return self.$dataSystem.variables[dataId];
      }
    }
    itemStatus(dataId) {
      if (this._mode === "switch") {
        return self.$gameSwitches.value(dataId) ? "[ON]" : "[OFF]";
      } else {
        return String(self.$gameVariables.value(dataId));
      }
    }
    setMode(mode) {
      if (this._mode !== mode) {
        this._mode = mode;
        this.refresh();
      }
    }
    setTopId(id) {
      if (this._topId !== id) {
        this._topId = id;
        this.refresh();
      }
    }
    currentId() {
      return this._topId + this.index();
    }
    update() {
      super.update();
      if (this.active) {
        if (this._mode === "switch") {
          this.updateSwitch();
        } else {
          this.updateVariable();
        }
      }
    }
    updateSwitch() {
      if (Input_default.isRepeated("ok")) {
        const switchId = this.currentId();
        SoundManager_default.playCursor();
        self.$gameSwitches.setValue(
          switchId,
          !self.$gameSwitches.value(switchId)
        );
        this.redrawCurrentItem();
      }
    }
    updateVariable() {
      const variableId = this.currentId();
      let value3 = self.$gameVariables.value(variableId);
      if (typeof value3 === "number") {
        if (Input_default.isRepeated("right")) {
          value3++;
        }
        if (Input_default.isRepeated("left")) {
          value3--;
        }
        if (Input_default.isRepeated("pagedown")) {
          value3 += 10;
        }
        if (Input_default.isRepeated("pageup")) {
          value3 -= 10;
        }
        if (self.$gameVariables.value(variableId) !== value3) {
          self.$gameVariables.setValue(variableId, value3);
          SoundManager_default.playCursor();
          this.redrawCurrentItem();
        }
      }
    }
  };
  var Window_DebugEdit_default = Window_DebugEdit;

  // src-www/js/rpg_scenes/Scene_Debug.js
  var Scene_Debug = class extends Scene_MenuBase_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
    }
    create() {
      super.create();
      this.createRangeWindow();
      this.createEditWindow();
      this.createDebugHelpWindow();
    }
    createRangeWindow() {
      this._rangeWindow = new Window_DebugRange_default(0, 0);
      this._rangeWindow.setHandler("ok", this.onRangeOk.bind(this));
      this._rangeWindow.setHandler("cancel", this.popScene.bind(this));
      this.addWindow(this._rangeWindow);
    }
    createEditWindow() {
      const wx = this._rangeWindow.width;
      const ww = Graphics_default.boxWidth - wx;
      this._editWindow = new Window_DebugEdit_default(wx, 0, ww);
      this._editWindow.setHandler("cancel", this.onEditCancel.bind(this));
      this._rangeWindow.setEditWindow(this._editWindow);
      this.addWindow(this._editWindow);
    }
    createDebugHelpWindow() {
      const wx = this._editWindow.x;
      const wy = this._editWindow.height;
      const ww = this._editWindow.width;
      const wh = Graphics_default.boxHeight - wy;
      this._debugHelpWindow = new Window_Base_default(wx, wy, ww, wh);
      this.addWindow(this._debugHelpWindow);
    }
    onRangeOk() {
      this._editWindow.activate();
      this._editWindow.select(0);
      this.refreshHelpWindow();
    }
    onEditCancel() {
      this._rangeWindow.activate();
      this._editWindow.deselect();
      this.refreshHelpWindow();
    }
    refreshHelpWindow() {
      this._debugHelpWindow.contents.clear();
      if (this._editWindow.active) {
        this._debugHelpWindow.drawTextEx(this.helpText(), 4, 0);
      }
    }
    helpText() {
      if (this._rangeWindow.mode() === "switch") {
        return "Enter : ON / OFF";
      } else {
        return "Left     :  -1\nRight    :  +1\nPageup   : -10\nPagedown : +10";
      }
    }
  };
  var Scene_Debug_default = Scene_Debug;

  // src-www/js/rpg_windows/Window_MapName.js
  var Window_MapName = class extends Window_Base_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      const wight = this.windowWidth();
      const height = this.windowHeight();
      super.initialize(0, 0, wight, height);
      this.opacity = 0;
      this.contentsOpacity = 0;
      this._showCount = 0;
      this.refresh();
    }
    windowWidth() {
      return 360;
    }
    windowHeight() {
      return this.fittingHeight(1);
    }
    update() {
      super.update();
      if (this._showCount > 0 && self.$gameMap.isNameDisplayEnabled()) {
        this.updateFadeIn();
        this._showCount--;
      } else {
        this.updateFadeOut();
      }
    }
    updateFadeIn() {
      this.contentsOpacity += 16;
    }
    updateFadeOut() {
      this.contentsOpacity -= 16;
    }
    open() {
      this.refresh();
      this._showCount = 150;
    }
    close() {
      this._showCount = 0;
    }
    refresh() {
      this.contents.clear();
      if (self.$gameMap.displayName()) {
        const width = this.contentsWidth();
        this.drawBackground(0, 0, width, this.lineHeight());
        this.drawText(self.$gameMap.displayName(), 0, 0, width, "center");
      }
    }
    drawBackground(x, y, width, height) {
      const color1 = this.dimColor1();
      const color2 = this.dimColor2();
      this.contents.gradientFillRect(x, y, width / 2, height, color2, color1);
      this.contents.gradientFillRect(
        x + width / 2,
        y,
        width / 2,
        height,
        color1,
        color2
      );
    }
  };
  var Window_MapName_default = Window_MapName;

  // src-www/js/rpg_sprites/Sprite_Balloon.js
  var Sprite_Balloon = class extends Sprite_Base_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
      this.initMembers();
      this.loadBitmap();
    }
    initMembers() {
      this._balloonId = 0;
      this._duration = 0;
      this.anchor.x = 0.5;
      this.anchor.y = 1;
      this.z = 7;
    }
    loadBitmap() {
      this.bitmap = ImageManager_default.loadSystem("Balloon");
      this.setFrame(0, 0, 0, 0);
    }
    setup(balloonId) {
      this._balloonId = balloonId;
      this._duration = 8 * this.speed() + this.waitTime();
    }
    update() {
      super.update();
      if (this._duration > 0) {
        this._duration--;
        if (this._duration > 0) {
          this.updateFrame();
        }
      }
    }
    updateFrame() {
      const w = 48;
      const h = 48;
      const sx = this.frameIndex() * w;
      const sy = (this._balloonId - 1) * h;
      this.setFrame(sx, sy, w, h);
    }
    speed() {
      return 8;
    }
    waitTime() {
      return 12;
    }
    frameIndex() {
      const index2 = (this._duration - this.waitTime()) / this.speed();
      return 7 - Math.max(Math.floor(index2), 0);
    }
    isPlaying() {
      return this._duration > 0;
    }
  };
  var Sprite_Balloon_default = Sprite_Balloon;

  // src-www/js/rpg_sprites/Sprite_Character.js
  var Sprite_Character = class extends Sprite_Base_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(character2) {
      super.initialize();
      this.initMembers();
      this.setCharacter(character2);
    }
    initMembers() {
      this.anchor.x = 0.5;
      this.anchor.y = 1;
      this._character = null;
      this._balloonDuration = 0;
      this._tilesetId = 0;
      this._upperBody = null;
      this._lowerBody = null;
    }
    setCharacter(character2) {
      this._character = character2;
    }
    update() {
      super.update();
      this.updateBitmap();
      this.updateFrame();
      this.updatePosition();
      this.updateAnimation();
      this.updateBalloon();
      this.updateOther();
    }
    updateVisibility() {
      super.updateVisibility();
      if (this._character.isTransparent()) {
        this.visible = false;
      }
    }
    isTile() {
      return this._character.tileId > 0;
    }
    tilesetBitmap(tileId) {
      const tileset = self.$gameMap.tileset();
      const setNumber = 5 + Math.floor(tileId / 256);
      return ImageManager_default.loadTileset(tileset.tilesetNames[setNumber]);
    }
    updateBitmap() {
      if (this.isImageChanged()) {
        this._tilesetId = self.$gameMap.tilesetId();
        this._tileId = this._character.tileId();
        this._characterName = this._character.characterName();
        this._characterIndex = this._character.characterIndex();
        if (this._tileId > 0) {
          this.setTileBitmap();
        } else {
          this.setCharacterBitmap();
        }
      }
    }
    isImageChanged() {
      return this._tilesetId !== self.$gameMap.tilesetId() || this._tileId !== this._character.tileId() || this._characterName !== this._character.characterName() || this._characterIndex !== this._character.characterIndex();
    }
    setTileBitmap() {
      this.bitmap = this.tilesetBitmap(this._tileId);
    }
    setCharacterBitmap() {
      this.bitmap = ImageManager_default.loadCharacter(this._characterName);
      this._isBigCharacter = ImageManager_default.isBigCharacter(this._characterName);
    }
    updateFrame() {
      if (this._tileId > 0) {
        this.updateTileFrame();
      } else {
        this.updateCharacterFrame();
      }
    }
    updateTileFrame() {
      const pw = this.patternWidth();
      const ph = this.patternHeight();
      const sx = (Math.floor(this._tileId / 128) % 2 * 8 + this._tileId % 8) * pw;
      const sy = Math.floor(this._tileId % 256 / 8) % 16 * ph;
      this.setFrame(sx, sy, pw, ph);
    }
    updateCharacterFrame() {
      const pw = this.patternWidth();
      const ph = this.patternHeight();
      const sx = (this.characterBlockX() + this.characterPatternX()) * pw;
      const sy = (this.characterBlockY() + this.characterPatternY()) * ph;
      this.updateHalfBodySprites();
      if (this._bushDepth > 0) {
        const d = this._bushDepth;
        this._upperBody.setFrame(sx, sy, pw, ph - d);
        this._lowerBody.setFrame(sx, sy + ph - d, pw, d);
        this.setFrame(sx, sy, 0, ph);
      } else {
        this.setFrame(sx, sy, pw, ph);
      }
    }
    characterBlockX() {
      if (this._isBigCharacter) {
        return 0;
      } else {
        const index2 = this._character.characterIndex();
        return index2 % 4 * 3;
      }
    }
    characterBlockY() {
      if (this._isBigCharacter) {
        return 0;
      } else {
        const index2 = this._character.characterIndex();
        return Math.floor(index2 / 4) * 4;
      }
    }
    characterPatternX() {
      return this._character.pattern();
    }
    characterPatternY() {
      return (this._character.direction() - 2) / 2;
    }
    patternWidth() {
      if (this._tileId > 0) {
        return self.$gameMap.tileWidth();
      } else if (this._isBigCharacter) {
        return this.bitmap.width / 3;
      } else {
        return this.bitmap.width / 12;
      }
    }
    patternHeight() {
      if (this._tileId > 0) {
        return self.$gameMap.tileHeight();
      } else if (this._isBigCharacter) {
        return this.bitmap.height / 4;
      } else {
        return this.bitmap.height / 8;
      }
    }
    updateHalfBodySprites() {
      if (this._bushDepth > 0) {
        this.createHalfBodySprites();
        this._upperBody.bitmap = this.bitmap;
        this._upperBody.visible = true;
        this._upperBody.y = -this._bushDepth;
        this._lowerBody.bitmap = this.bitmap;
        this._lowerBody.visible = true;
        this._upperBody.setBlendColor(this.getBlendColor());
        this._lowerBody.setBlendColor(this.getBlendColor());
        this._upperBody.setColorTone(this.getColorTone());
        this._lowerBody.setColorTone(this.getColorTone());
      } else if (this._upperBody) {
        this._upperBody.visible = false;
        this._lowerBody.visible = false;
      }
    }
    createHalfBodySprites() {
      if (!this._upperBody) {
        this._upperBody = new Sprite_default();
        this._upperBody.anchor.x = 0.5;
        this._upperBody.anchor.y = 1;
        this.addChild(this._upperBody);
      }
      if (!this._lowerBody) {
        this._lowerBody = new Sprite_default();
        this._lowerBody.anchor.x = 0.5;
        this._lowerBody.anchor.y = 1;
        this._lowerBody.opacity = 128;
        this.addChild(this._lowerBody);
      }
    }
    updatePosition() {
      this.x = this._character.screenX();
      this.y = this._character.screenY();
      this.z = this._character.screenZ();
    }
    updateAnimation() {
      this.setupAnimation();
      if (!this.isAnimationPlaying()) {
        this._character.endAnimation();
      }
      if (!this.isBalloonPlaying()) {
        this._character.endBalloon();
      }
    }
    updateOther() {
      this.opacity = this._character.opacity();
      this.blendMode = this._character.blendMode();
      this._bushDepth = this._character.bushDepth();
    }
    setupAnimation() {
      if (this._character.animationId() > 0) {
        const animation = self.$dataAnimations[this._character.animationId()];
        this.startAnimation(animation, false, 0);
        this._character.startAnimation();
      }
    }
    setupBalloon() {
      if (this._character.balloonId() > 0) {
        this.startBalloon();
        this._character.startBalloon();
      }
    }
    startBalloon() {
      if (!this._balloonSprite) {
        this._balloonSprite = new Sprite_Balloon_default();
      }
      this._balloonSprite.setup(this._character.balloonId());
      this.parent.addChild(this._balloonSprite);
    }
    updateBalloon() {
      this.setupBalloon();
      if (this._balloonSprite) {
        this._balloonSprite.x = this.x;
        this._balloonSprite.y = this.y - this.height;
        if (!this._balloonSprite.isPlaying()) {
          this.endBalloon();
        }
      }
    }
    endBalloon() {
      if (this._balloonSprite) {
        this.parent.removeChild(this._balloonSprite);
        this._balloonSprite = null;
      }
    }
    isBalloonPlaying() {
      return !!this._balloonSprite;
    }
  };
  var Sprite_Character_default = Sprite_Character;

  // src-www/js/rpg_sprites/Sprite_Destination.js
  var Sprite_Destination = class extends Sprite_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
      this.createBitmap();
      this._frameCount = 0;
    }
    update() {
      super.update();
      if (self.$gameTemp.isDestinationValid()) {
        this.updatePosition();
        this.updateAnimation();
        this.visible = true;
      } else {
        this._frameCount = 0;
        this.visible = false;
      }
    }
    createBitmap() {
      const tileWidth = self.$gameMap.tileWidth();
      const tileHeight = self.$gameMap.tileHeight();
      this.bitmap = new Bitmap_default(tileWidth, tileHeight);
      this.bitmap.fillAll("white");
      this.anchor.x = 0.5;
      this.anchor.y = 0.5;
      this.blendMode = Graphics_default.BLEND_ADD;
    }
    updatePosition() {
      const tileWidth = self.$gameMap.tileWidth();
      const tileHeight = self.$gameMap.tileHeight();
      const x = self.$gameTemp.destinationX();
      const y = self.$gameTemp.destinationY();
      this.x = (self.$gameMap.adjustX(x) + 0.5) * tileWidth;
      this.y = (self.$gameMap.adjustY(y) + 0.5) * tileHeight;
    }
    updateAnimation() {
      this._frameCount++;
      this._frameCount %= 20;
      this.opacity = (20 - this._frameCount) * 6;
      this.scale.x = 1 + this._frameCount / 20;
      this.scale.y = this.scale.x;
    }
  };
  var Sprite_Destination_default = Sprite_Destination;

  // src-www/js/rpg_sprites/Spriteset_Map.js
  var Spriteset_Map = class extends Spriteset_Base_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
      this._tilesetReady = false;
    }
    createLowerLayer() {
      super.createLowerLayer();
      this.createParallax();
      this.createTilemap();
      this.createCharacters();
      this.createShadow();
      this.createDestination();
      this.createWeather();
    }
    update() {
      super.update();
      this.updateTileset();
      this.updateParallax();
      this.updateTilemap();
      this.updateShadow();
      this.updateWeather();
    }
    hideCharacters() {
      for (const sprite of this._characterSprites) {
        if (!sprite.isTile()) {
          sprite.hide();
        }
      }
    }
    createParallax() {
      this._parallax = new TilingSprite_default();
      this._parallax.move(0, 0, Graphics_default.width, Graphics_default.height);
      this._baseSprite.addChild(this._parallax);
    }
    createTilemap() {
      if (Graphics_default.isWebGL()) {
        this._tilemap = new ShaderTilemap();
      } else {
        this._tilemap = new Tilemap_default();
      }
      this._tilemap.tileWidth = self.$gameMap.tileWidth();
      this._tilemap.tileHeight = self.$gameMap.tileHeight();
      this._tilemap.setData(
        self.$gameMap.width(),
        self.$gameMap.height(),
        self.$gameMap.data()
      );
      this._tilemap.horizontalWrap = self.$gameMap.isLoopHorizontal();
      this._tilemap.verticalWrap = self.$gameMap.isLoopVertical();
      this.loadTileset();
      this._baseSprite.addChild(this._tilemap);
    }
    loadTileset() {
      this._tileset = self.$gameMap.tileset();
      if (this._tileset) {
        const tilesetNames = this._tileset.tilesetNames;
        for (let i = 0; i < tilesetNames.length; i++) {
          this._tilemap.bitmaps[i] = ImageManager_default.loadTileset(tilesetNames[i]);
        }
        const newTilesetFlags = self.$gameMap.tilesetFlags();
        this._tilemap.refreshTileset();
        if (!this._tilemap.flags.equals(newTilesetFlags)) {
          this._tilemap.refresh();
        }
        this._tilemap.flags = newTilesetFlags;
      }
    }
    createCharacters() {
      this._characterSprites = [];
      self.$gameMap.events().forEach(function(event) {
        this._characterSprites.push(new Sprite_Character_default(event));
      }, this);
      self.$gameMap.vehicles().forEach(function(vehicle) {
        this._characterSprites.push(new Sprite_Character_default(vehicle));
      }, this);
      self.$gamePlayer.followers().reverseEach(function(follower) {
        this._characterSprites.push(new Sprite_Character_default(follower));
      }, this);
      this._characterSprites.push(new Sprite_Character_default(self.$gamePlayer));
      for (let i = 0; i < this._characterSprites.length; i++) {
        this._tilemap.addChild(this._characterSprites[i]);
      }
    }
    createShadow() {
      this._shadowSprite = new Sprite_default();
      this._shadowSprite.bitmap = ImageManager_default.loadSystem("Shadow1");
      this._shadowSprite.anchor.x = 0.5;
      this._shadowSprite.anchor.y = 1;
      this._shadowSprite.z = 6;
      this._tilemap.addChild(this._shadowSprite);
    }
    createDestination() {
      this._destinationSprite = new Sprite_Destination_default();
      this._destinationSprite.z = 9;
      this._tilemap.addChild(this._destinationSprite);
    }
    createWeather() {
    }
    updateTileset() {
      if (this._tileset !== self.$gameMap.tileset()) {
        this.loadTileset();
      }
    }
    /*
     * Simple fix for canvas parallax issue, destroy old parallax and readd to  the tree.
     */
    _canvasReAddParallax() {
      const index2 = this._baseSprite.children.indexOf(this._parallax);
      this._baseSprite.removeChild(this._parallax);
      this._parallax = new TilingSprite_default();
      this._parallax.move(0, 0, Graphics_default.width, Graphics_default.height);
      this._parallax.bitmap = ImageManager_default.loadParallax(this._parallaxName);
      this._baseSprite.addChildAt(this._parallax, index2);
    }
    updateParallax() {
      if (this._parallaxName !== self.$gameMap.parallaxName()) {
        this._parallaxName = self.$gameMap.parallaxName();
        if (this._parallax.bitmap && Graphics_default.isWebGL() != true) {
          this._canvasReAddParallax();
        } else {
          this._parallax.bitmap = ImageManager_default.loadParallax(this._parallaxName);
        }
      }
      if (this._parallax.bitmap) {
        this._parallax.origin.x = self.$gameMap.parallaxOx();
        this._parallax.origin.y = self.$gameMap.parallaxOy();
      }
    }
    updateTilemap() {
      this._tilemap.origin.x = self.$gameMap.displayX() * self.$gameMap.tileWidth();
      this._tilemap.origin.y = self.$gameMap.displayY() * self.$gameMap.tileHeight();
      if (this._tilemap.bitmaps) {
        if (!this._tilesetReady && this._tilemap.bitmaps.every((bitmap) => bitmap.isRequestReady())) {
          this._tilemap.refreshTileset();
          this._tilesetReady = true;
        }
      }
    }
    updateShadow() {
      const airship = self.$gameMap.airship();
      this._shadowSprite.x = airship.shadowX();
      this._shadowSprite.y = airship.shadowY();
      this._shadowSprite.opacity = airship.shadowOpacity();
    }
    updateWeather() {
    }
  };
  var Spriteset_Map_default = Spriteset_Map;

  // src-www/js/rpg_scenes/Scene_Map.js
  var Scene_Map = class extends Scene_Base_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
      this._waitCount = 0;
      this._encounterEffectDuration = 0;
      this._mapLoaded = false;
      this._touchCount = 0;
    }
    create() {
      super.create();
      this._transfer = self.$gamePlayer.isTransferring();
      const mapId = this._transfer ? self.$gamePlayer.newMapId() : self.$gameMap.mapId();
      DataManager2.loadMapData(mapId);
    }
    isReady() {
      if (!this._mapLoaded && DataManager2.isMapLoaded()) {
        this.onMapLoaded();
        this._mapLoaded = true;
      }
      return this._mapLoaded && Scene_Base_default.prototype.isReady.call(this);
    }
    onMapLoaded() {
      if (this._transfer) {
        self.$gamePlayer.performTransfer();
      }
      this.createDisplayObjects();
    }
    start() {
      super.start();
      SceneManager_default.clearStack();
      if (this._transfer) {
        this.fadeInForTransfer();
        this._mapNameWindow.open();
        self.$gameMap.autoplay();
      } else if (this.needsFadeIn()) {
        this.startFadeIn(this.fadeSpeed(), false);
      }
      this.menuCalling = false;
    }
    update() {
      this.updateDestination();
      this.updateMainMultiply();
      if (this.isSceneChangeOk()) {
        this.updateScene();
      } else if (SceneManager_default.isNextScene(Scene_Battle_default)) {
        this.updateEncounterEffect();
      }
      this.updateWaitCount();
      super.update();
    }
    updateMainMultiply() {
      this.updateMain();
      if (this.isFastForward()) {
        if (!this.isMapTouchOk()) {
          this.updateDestination();
        }
        this.updateMain();
      }
    }
    updateMain() {
      const active = this.isActive();
      self.$gameMap.update(active);
      self.$gamePlayer.update(active);
      self.$gameTimer.update(active);
      self.$gameScreen.update();
    }
    isFastForward() {
      return self.$gameMap.isEventRunning() && !SceneManager_default.isSceneChanging() && (Input_default.isLongPressed("ok") || TouchInput_default.isLongPressed());
    }
    stop() {
      super.stop();
      self.$gamePlayer.straighten();
      this._mapNameWindow.close();
      if (this.needsSlowFadeOut()) {
        this.startFadeOut(this.slowFadeSpeed(), false);
      } else if (SceneManager_default.isNextScene(Scene_Map)) {
        this.fadeOutForTransfer();
      } else if (SceneManager_default.isNextScene(Scene_Battle_default)) {
        this.launchBattle();
      }
    }
    isBusy() {
      return this._messageWindow && this._messageWindow.isClosing() || this._waitCount > 0 || this._encounterEffectDuration > 0 || Scene_Base_default.prototype.isBusy.call(this);
    }
    terminate() {
      super.terminate();
      if (!SceneManager_default.isNextScene(Scene_Battle_default)) {
        this._spriteset.update();
        this._mapNameWindow.hide();
        SceneManager_default.snapForBackground();
      } else {
        ImageManager_default.clearRequest();
      }
      if (SceneManager_default.isNextScene(Scene_Map)) {
        ImageManager_default.clearRequest();
      }
      self.$gameScreen.clearZoom();
      this.removeChild(this._fadeSprite);
      this.removeChild(this._mapNameWindow);
      this.removeChild(this._windowLayer);
      this.removeChild(this._spriteset);
    }
    needsFadeIn() {
      return SceneManager_default.isPreviousScene(Scene_Battle_default) || SceneManager_default.isPreviousScene(Scene_Load_default);
    }
    needsSlowFadeOut() {
      return SceneManager_default.isNextScene(Scene_Title_default) || SceneManager_default.isNextScene(Scene_Gameover_default);
    }
    updateWaitCount() {
      if (this._waitCount > 0) {
        this._waitCount--;
        return true;
      }
      return false;
    }
    updateDestination() {
      if (this.isMapTouchOk()) {
        this.processMapTouch();
      } else {
        self.$gameTemp.clearDestination();
        this._touchCount = 0;
      }
    }
    isMapTouchOk() {
      return this.isActive() && self.$gamePlayer.canMove();
    }
    processMapTouch() {
      if (TouchInput_default.isTriggered() || this._touchCount > 0) {
        if (TouchInput_default.isPressed()) {
          if (this._touchCount === 0 || this._touchCount >= 15) {
            const x = self.$gameMap.canvasToMapX(TouchInput_default.x);
            const y = self.$gameMap.canvasToMapY(TouchInput_default.y);
            self.$gameTemp.setDestination(x, y);
          }
          this._touchCount++;
        } else {
          this._touchCount = 0;
        }
      }
    }
    isSceneChangeOk() {
      return this.isActive() && !self.$gameMessage.isBusy();
    }
    updateScene() {
      this.checkGameover();
      if (!SceneManager_default.isSceneChanging()) {
        this.updateTransferPlayer();
      }
      if (!SceneManager_default.isSceneChanging()) {
        this.updateEncounter();
      }
      if (!SceneManager_default.isSceneChanging()) {
        this.updateCallMenu();
      }
      if (!SceneManager_default.isSceneChanging()) {
        this.updateCallDebug();
      }
    }
    createDisplayObjects() {
      this.createSpriteset();
      this.createMapNameWindow();
      this.createWindowLayer();
      this.createAllWindows();
    }
    createSpriteset() {
      this._spriteset = new Spriteset_Map_default();
      this.addChild(this._spriteset);
    }
    createAllWindows() {
      this.createMessageWindow();
      this.createScrollTextWindow();
    }
    createMapNameWindow() {
      this._mapNameWindow = new Window_MapName_default();
      this.addChild(this._mapNameWindow);
    }
    createMessageWindow() {
      this._messageWindow = new Window_Message_default();
      this.addWindow(this._messageWindow);
      this._messageWindow.subWindows().forEach(function(window2) {
        this.addWindow(window2);
      }, this);
    }
    createScrollTextWindow() {
      this._scrollTextWindow = new Window_ScrollText_default();
      this.addWindow(this._scrollTextWindow);
    }
    updateTransferPlayer() {
      if (self.$gamePlayer.isTransferring()) {
        SceneManager_default.goto(Scene_Map);
      }
    }
    updateEncounter() {
      if (self.$gamePlayer.executeEncounter()) {
        SceneManager_default.push(Scene_Battle_default);
      }
    }
    updateCallMenu() {
      if (this.isMenuEnabled()) {
        if (this.isMenuCalled()) {
          this.menuCalling = true;
        }
        if (this.menuCalling && !self.$gamePlayer.isMoving()) {
          this.callMenu();
        }
      } else {
        this.menuCalling = false;
      }
    }
    isMenuEnabled() {
      return self.$gameSystem.isMenuEnabled() && !self.$gameMap.isEventRunning();
    }
    isMenuCalled() {
      return Input_default.isTriggered("menu") || TouchInput_default.isCancelled();
    }
    callMenu() {
      SoundManager_default.playOk();
      SceneManager_default.push(Scene_Menu_default);
      Window_MenuCommand_default.initCommandPosition();
      self.$gameTemp.clearDestination();
      this._mapNameWindow.hide();
      this._waitCount = 2;
    }
    updateCallDebug() {
      if (this.isDebugCalled()) {
        SceneManager_default.push(Scene_Debug_default);
      }
    }
    isDebugCalled() {
      return Input_default.isTriggered("debug") && self.$gameTemp.isPlaytest();
    }
    fadeInForTransfer() {
      const fadeType = self.$gamePlayer.fadeType();
      switch (fadeType) {
        case 0:
        case 1:
          this.startFadeIn(this.fadeSpeed(), fadeType === 1);
          break;
      }
    }
    fadeOutForTransfer() {
      const fadeType = self.$gamePlayer.fadeType();
      switch (fadeType) {
        case 0:
        case 1:
          this.startFadeOut(this.fadeSpeed(), fadeType === 1);
          break;
      }
    }
    launchBattle() {
      BattleManager_default.saveBgmAndBgs();
      this.stopAudioOnBattleStart();
      SoundManager_default.playBattleStart();
      this.startEncounterEffect();
      this._mapNameWindow.hide();
    }
    stopAudioOnBattleStart() {
      if (!AudioManager_default.isCurrentBgm(self.$gameSystem.battleBgm())) {
        AudioManager_default.stopBgm();
      }
      AudioManager_default.stopBgs();
      AudioManager_default.stopMe();
      AudioManager_default.stopSe();
    }
    startEncounterEffect() {
      this._spriteset.hideCharacters();
      this._encounterEffectDuration = this.encounterEffectSpeed();
    }
    updateEncounterEffect() {
      if (this._encounterEffectDuration > 0) {
        this._encounterEffectDuration--;
        const speed = this.encounterEffectSpeed();
        const n = speed - this._encounterEffectDuration;
        const p = n / speed;
        const q = ((p - 1) * 20 * p + 5) * p + 1;
        const zoomX = self.$gamePlayer.screenX();
        const zoomY = self.$gamePlayer.screenY() - 24;
        if (n === 2) {
          self.$gameScreen.setZoom(zoomX, zoomY, 1);
          this.snapForBattleBackground();
          this.startFlashForEncounter(speed / 2);
        }
        self.$gameScreen.setZoom(zoomX, zoomY, q);
        if (n === Math.floor(speed / 6)) {
          this.startFlashForEncounter(speed / 2);
        }
        if (n === Math.floor(speed / 2)) {
          BattleManager_default.playBattleBgm();
          this.startFadeOut(this.fadeSpeed());
        }
      }
    }
    snapForBattleBackground() {
      this._windowLayer.visible = false;
      SceneManager_default.snapForBackground();
      this._windowLayer.visible = true;
    }
    startFlashForEncounter(duration) {
      const color2 = [255, 255, 255, 255];
      self.$gameScreen.startFlash(color2, duration);
    }
    encounterEffectSpeed() {
      return 60;
    }
  };
  var Scene_Map_default = Scene_Map;

  // src-www/js/rpg_windows/Window_TitleCommand.js
  var Window_TitleCommand = class extends Window_Command_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize(0, 0);
      this.updatePlacement();
      this.openness = 0;
      this.selectLast();
    }
    static initCommandPosition() {
      this._lastCommandSymbol = null;
    }
    windowWidth() {
      return 240;
    }
    updatePlacement() {
      this.x = (Graphics_default.boxWidth - this.width) / 2;
      this.y = Graphics_default.boxHeight - this.height - 96;
    }
    makeCommandList() {
      this.addCommand(TextManager_default.newGame, "newGame");
      this.addCommand(
        TextManager_default.continue_,
        "continue",
        this.isContinueEnabled()
      );
      this.addCommand(TextManager_default.options, "options");
    }
    isContinueEnabled() {
      return DataManager2.isAnySavefileExists();
    }
    processOk() {
      Window_TitleCommand._lastCommandSymbol = this.currentSymbol();
      super.processOk();
    }
    selectLast() {
      if (Window_TitleCommand._lastCommandSymbol) {
        this.selectSymbol(Window_TitleCommand._lastCommandSymbol);
      } else if (this.isContinueEnabled()) {
        this.selectSymbol("continue");
      }
    }
  };
  Window_TitleCommand._lastCommandSymbol = null;
  var Window_TitleCommand_default = Window_TitleCommand;

  // src-www/js/rpg_scenes/Scene_Title.js
  var Scene_Title = class extends Scene_Base_default {
    constructor(...args) {
      super(...args);
      this.initialize();
    }
    initialize() {
      super.initialize();
    }
    async create() {
      super.create();
      await this.createBackground();
      this.createForeground();
      this.createWindowLayer();
      this.createCommandWindow();
    }
    start() {
      super.start();
      SceneManager_default.clearStack();
      this.playTitleMusic();
      this.startFadeIn(this.fadeSpeed(), false);
    }
    update() {
      if (!this.isBusy()) {
        this._commandWindow.open();
      }
      super.update();
    }
    isBusy() {
      if (!this._commandWindow) {
        return true;
      }
      return this._commandWindow.isClosing() || Scene_Base_default.prototype.isBusy.call(this);
    }
    terminate() {
      super.terminate();
      SceneManager_default.snapForBackground();
    }
    async createBackground() {
      if (self.$dataSystem.title1Name) {
        const title1 = await PIXI.Assets.load(
          "../img/titles1/" + self.$dataSystem.title1Name + ".png"
        );
        this._backSprite1 = new Sprite_default(title1);
        this.centerSprite(this._backSprite1);
        this.addChild(this._backSprite1);
      }
      if (self.$dataSystem.title2Name) {
        const title2 = await PIXI.Assets.load(
          "../img/titles2/" + self.$dataSystem.title2Name + ".png"
        );
        this._backSprite2 = new Sprite_default(title2);
        this.centerSprite(this._backSprite2);
        this.addChild(this._backSprite2);
      }
    }
    createForeground() {
      if (self.$dataSystem.optDrawTitle) {
        this._gameTitleSprite = new Bitmap_default(Graphics_default.width, Graphics_default.height);
        this.addChild(this._gameTitleSprite);
        this.drawGameTitle();
      }
    }
    drawGameTitle() {
      const x = 20;
      const y = Math.floor(Graphics_default.height / 4);
      const maxWidth = Graphics_default.width - x * 2;
      const text = self.$dataSystem.gameTitle;
      this._gameTitleSprite.outlineColor = "black";
      this._gameTitleSprite.outlineWidth = 8;
      this._gameTitleSprite.fontSize = 72;
      this._gameTitleSprite.drawText(text, x, y, maxWidth, 48, "center");
    }
    centerSprite(sprite) {
      sprite.x = 0;
      sprite.y = 0;
      sprite.width = Graphics_default.width;
      sprite.height = Graphics_default.height;
    }
    createCommandWindow() {
      this._commandWindow = new Window_TitleCommand_default();
      this._commandWindow.setHandler("newGame", this.commandNewGame.bind(this));
      this._commandWindow.setHandler("continue", this.commandContinue.bind(this));
      this._commandWindow.setHandler("options", this.commandOptions.bind(this));
      this.addWindow(this._commandWindow);
    }
    commandNewGame() {
      DataManager2.setupNewGame();
      this._commandWindow.close();
      this.fadeOutAll();
      SceneManager_default.goto(Scene_Map_default);
    }
    commandContinue() {
      this._commandWindow.close();
      SceneManager_default.push(Scene_Load_default);
    }
    commandOptions() {
      this._commandWindow.close();
      SceneManager_default.push(Scene_Options_default);
    }
    playTitleMusic() {
      AudioManager_default.playBgm(self.$dataSystem.titleBgm);
      AudioManager_default.stopBgs();
      AudioManager_default.stopMe();
    }
  };
  var Scene_Title_default = Scene_Title;

  // src-www/js/rpg_scenes/Scene_Gameover.js
  var Scene_Gameover = class extends Scene_Base_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
    }
    create() {
      super.create();
      this.playGameoverMusic();
      this.createBackground();
    }
    start() {
      super.start();
      this.startFadeIn(this.slowFadeSpeed(), false);
    }
    update() {
      if (this.isActive() && !this.isBusy() && this.isTriggered()) {
        this.gotoTitle();
      }
      super.update();
    }
    stop() {
      super.stop();
      this.fadeOutAll();
    }
    terminate() {
      super.terminate();
      AudioManager_default.stopAll();
    }
    playGameoverMusic() {
      AudioManager_default.stopBgm();
      AudioManager_default.stopBgs();
      AudioManager_default.playMe(self.$dataSystem.gameoverMe);
    }
    createBackground() {
      this._backSprite = new Sprite_default();
      this._backSprite.bitmap = ImageManager_default.loadSystem("GameOver");
      this.addChild(this._backSprite);
    }
    isTriggered() {
      return Input_default.isTriggered("ok") || TouchInput_default.isTriggered();
    }
    gotoTitle() {
      SceneManager_default.goto(Scene_Title_default);
    }
  };
  var Scene_Gameover_default = Scene_Gameover;

  // src-www/js/rpg_managers/BattleManager.js
  var BattleManager = class {
    constructor() {
      throw new Error("This is a static class");
    }
    static setup(troopId, canEscape, canLose) {
      this.initMembers();
      this._canEscape = canEscape;
      this._canLose = canLose;
      self.$gameTroop.setup(troopId);
      self.$gameScreen.onBattleStart();
      this.makeEscapeRatio();
    }
    static initMembers() {
      this._phase = "init";
      this._canEscape = false;
      this._canLose = false;
      this._battleTest = false;
      this._eventCallback = null;
      this._preemptive = false;
      this._surprise = false;
      this._actorIndex = -1;
      this._actionForcedBattler = null;
      this._mapBgm = null;
      this._mapBgs = null;
      this._actionBattlers = [];
      this._subject = null;
      this._action = null;
      this._targets = [];
      this._logWindow = null;
      this._statusWindow = null;
      this._spriteset = null;
      this._escapeRatio = 0;
      this._escaped = false;
      this._rewards = {};
      this._turnForced = false;
    }
    static isBattleTest() {
      return this._battleTest;
    }
    static setBattleTest(battleTest) {
      this._battleTest = battleTest;
    }
    static setEventCallback(callback) {
      this._eventCallback = callback;
    }
    static setLogWindow(logWindow) {
      this._logWindow = logWindow;
    }
    static setStatusWindow(statusWindow) {
      this._statusWindow = statusWindow;
    }
    static setSpriteset(spriteset) {
      this._spriteset = spriteset;
    }
    static onEncounter() {
      this._preemptive = Math.random() < this.ratePreemptive();
      this._surprise = Math.random() < this.rateSurprise() && !this._preemptive;
    }
    static saveBgmAndBgs() {
      this._mapBgm = AudioManager_default.saveBgm();
      this._mapBgs = AudioManager_default.saveBgs();
    }
    static replayBgmAndBgs() {
      if (this._mapBgm) {
        AudioManager_default.replayBgm(this._mapBgm);
      } else {
        AudioManager_default.stopBgm();
      }
      if (this._mapBgs) {
        AudioManager_default.replayBgs(this._mapBgs);
      }
    }
    static makeEscapeRatio() {
      this._escapeRatio = 0.5 * self.$gameParty.agility() / self.$gameTroop.agility();
    }
    static update() {
      if (!this.isBusy() && !this.updateEvent()) {
        switch (this._phase) {
          case "start":
            this.startInput();
            break;
          case "turn":
            this.updateTurn();
            break;
          case "action":
            this.updateAction();
            break;
          case "turnEnd":
            this.updateTurnEnd();
            break;
          case "battleEnd":
            this.updateBattleEnd();
            break;
        }
      }
    }
    static updateEvent() {
      switch (this._phase) {
        case "start":
        case "turn":
        case "turnEnd":
          if (this.isActionForced()) {
            this.processForcedAction();
            return true;
          } else {
            return this.updateEventMain();
          }
      }
      return this.checkAbort();
    }
    static updateEventMain() {
      self.$gameTroop.updateInterpreter();
      self.$gameParty.requestMotionRefresh();
      if (self.$gameTroop.isEventRunning() || this.checkBattleEnd()) {
        return true;
      }
      self.$gameTroop.setupBattleEvent();
      if (self.$gameTroop.isEventRunning() || SceneManager_default.isSceneChanging()) {
        return true;
      }
      return false;
    }
    static isBusy() {
      return self.$gameMessage.isBusy() || this._spriteset.isBusy() || this._logWindow.isBusy();
    }
    static isInputting() {
      return this._phase === "input";
    }
    static isInTurn() {
      return this._phase === "turn";
    }
    static isTurnEnd() {
      return this._phase === "turnEnd";
    }
    static isAborting() {
      return this._phase === "aborting";
    }
    static isBattleEnd() {
      return this._phase === "battleEnd";
    }
    static canEscape() {
      return this._canEscape;
    }
    static canLose() {
      return this._canLose;
    }
    static isEscaped() {
      return this._escaped;
    }
    static actor() {
      return this._actorIndex >= 0 ? self.$gameParty.members()[this._actorIndex] : null;
    }
    static clearActor() {
      this.changeActor(-1, "");
    }
    static changeActor(newActorIndex, lastActorActionState) {
      const lastActor = this.actor();
      this._actorIndex = newActorIndex;
      const newActor = this.actor();
      if (lastActor) {
        lastActor.setActionState(lastActorActionState);
      }
      if (newActor) {
        newActor.setActionState("inputting");
      }
    }
    static startBattle() {
      this._phase = "start";
      self.$gameSystem.onBattleStart();
      self.$gameParty.onBattleStart();
      self.$gameTroop.onBattleStart();
      this.displayStartMessages();
    }
    static displayStartMessages() {
      self.$gameTroop.enemyNames().forEach((name) => {
        self.$gameMessage.add(TextManager_default.emerge.format(name));
      });
      if (this._preemptive) {
        self.$gameMessage.add(
          TextManager_default.preemptive.format(self.$gameParty.name())
        );
      } else if (this._surprise) {
        self.$gameMessage.add(
          TextManager_default.surprise.format(self.$gameParty.name())
        );
      }
    }
    static startInput() {
      this._phase = "input";
      self.$gameParty.makeActions();
      self.$gameTroop.makeActions();
      this.clearActor();
      if (this._surprise || !self.$gameParty.canInput()) {
        this.startTurn();
      }
    }
    static inputtingAction() {
      const actor2 = this.actor();
      return actor2 ? actor2.inputtingAction() : null;
    }
    static selectNextCommand() {
      do {
        const actor2 = this.actor();
        if (!actor2 || !actor2.selectNextCommand()) {
          this.changeActor(this._actorIndex + 1, "waiting");
          if (this._actorIndex >= self.$gameParty.size()) {
            this.startTurn();
            break;
          }
        }
      } while (!this.actor().canInput());
    }
    static selectPreviousCommand() {
      do {
        const actor2 = this.actor();
        if (!actor2 || !actor2.selectPreviousCommand()) {
          this.changeActor(this._actorIndex - 1, "undecided");
          if (this._actorIndex < 0) {
            return;
          }
        }
      } while (!this.actor().canInput());
    }
    static refreshStatus() {
      this._statusWindow.refresh();
    }
    static startTurn() {
      this._phase = "turn";
      this.clearActor();
      self.$gameTroop.increaseTurn();
      this.makeActionOrders();
      self.$gameParty.requestMotionRefresh();
      this._logWindow.startTurn();
    }
    static updateTurn() {
      self.$gameParty.requestMotionRefresh();
      if (!this._subject) {
        this._subject = this.getNextSubject();
      }
      if (this._subject) {
        this.processTurn();
      } else {
        this.endTurn();
      }
    }
    static processTurn() {
      const subject = this._subject;
      const action = subject.currentAction();
      if (action) {
        action.prepare();
        if (action.isValid()) {
          this.startAction();
        }
        subject.removeCurrentAction();
      } else {
        subject.onAllActionsEnd();
        this.refreshStatus();
        this._logWindow.displayAutoAffectedStatus(subject);
        this._logWindow.displayCurrentState(subject);
        this._logWindow.displayRegeneration(subject);
        this._subject = this.getNextSubject();
      }
    }
    static endTurn() {
      this._phase = "turnEnd";
      this._preemptive = false;
      this._surprise = false;
      this.allBattleMembers().forEach(function(battler) {
        battler.onTurnEnd();
        this.refreshStatus();
        this._logWindow.displayAutoAffectedStatus(battler);
        this._logWindow.displayRegeneration(battler);
      }, this);
      if (this.isForcedTurn()) {
        this._turnForced = false;
      }
    }
    static isForcedTurn() {
      return this._turnForced;
    }
    static updateTurnEnd() {
      this.startInput();
    }
    static getNextSubject() {
      for (; ; ) {
        const battler = this._actionBattlers.shift();
        if (!battler) {
          return null;
        }
        if (battler.isBattleMember() && battler.isAlive()) {
          return battler;
        }
      }
    }
    static makeActionOrders() {
      let battlers = [];
      if (!this._surprise) {
        battlers = battlers.concat(self.$gameParty.members());
      }
      if (!this._preemptive) {
        battlers = battlers.concat(self.$gameTroop.members());
      }
      battlers.forEach((battler) => {
        battler.makeSpeed();
      });
      battlers.sort((a2, b2) => b2.speed() - a2.speed());
      this._actionBattlers = battlers;
    }
    static startAction() {
      const subject = this._subject;
      const action = subject.currentAction();
      const targets = action.makeTargets();
      this._phase = "action";
      this._action = action;
      this._targets = targets;
      subject.useItem(action.item());
      this._action.applyGlobal();
      this.refreshStatus();
      this._logWindow.startAction(subject, action, targets);
    }
    static updateAction() {
      const target2 = this._targets.shift();
      if (target2) {
        this.invokeAction(this._subject, target2);
      } else {
        this.endAction();
      }
    }
    static endAction() {
      this._logWindow.endAction(this._subject);
      this._phase = "turn";
    }
    static invokeAction(subject, target2) {
      this._logWindow.push("pushBaseLine");
      if (Math.random() < this._action.itemCnt(target2)) {
        this.invokeCounterAttack(subject, target2);
      } else if (Math.random() < this._action.itemMrf(target2)) {
        this.invokeMagicReflection(subject, target2);
      } else {
        this.invokeNormalAction(subject, target2);
      }
      subject.setLastTarget(target2);
      this._logWindow.push("popBaseLine");
      this.refreshStatus();
    }
    static invokeNormalAction(subject, target2) {
      const realTarget = this.applySubstitute(target2);
      this._action.apply(realTarget);
      this._logWindow.displayActionResults(subject, realTarget);
    }
    static invokeCounterAttack(subject, target2) {
      const action = new Game_Action_default(target2);
      action.setAttack();
      action.apply(subject);
      this._logWindow.displayCounter(target2);
      this._logWindow.displayActionResults(target2, subject);
    }
    static invokeMagicReflection(subject, target2) {
      this._action._reflectionTarget = target2;
      this._logWindow.displayReflection(target2);
      this._action.apply(subject);
      this._logWindow.displayActionResults(target2, subject);
    }
    static applySubstitute(target2) {
      if (this.checkSubstitute(target2)) {
        const substitute = target2.friendsUnit().substituteBattler();
        if (substitute && target2 !== substitute) {
          this._logWindow.displaySubstitute(substitute, target2);
          return substitute;
        }
      }
      return target2;
    }
    static checkSubstitute(target2) {
      return target2.isDying() && !this._action.isCertainHit();
    }
    static isActionForced() {
      return !!this._actionForcedBattler;
    }
    static forceAction(battler) {
      this._actionForcedBattler = battler;
      const index2 = this._actionBattlers.indexOf(battler);
      if (index2 >= 0) {
        this._actionBattlers.splice(index2, 1);
      }
    }
    static processForcedAction() {
      if (this._actionForcedBattler) {
        this._turnForced = true;
        this._subject = this._actionForcedBattler;
        this._actionForcedBattler = null;
        this.startAction();
        this._subject.removeCurrentAction();
      }
    }
    static abort() {
      this._phase = "aborting";
    }
    static checkBattleEnd() {
      if (this._phase) {
        if (this.checkAbort()) {
          return true;
        } else if (self.$gameParty.isAllDead()) {
          this.processDefeat();
          return true;
        } else if (self.$gameTroop.isAllDead()) {
          this.processVictory();
          return true;
        }
      }
      return false;
    }
    static checkAbort() {
      if (self.$gameParty.isEmpty() || this.isAborting()) {
        SoundManager_default.playEscape();
        this._escaped = true;
        this.processAbort();
      }
      return false;
    }
    static processVictory() {
      self.$gameParty.removeBattleStates();
      self.$gameParty.performVictory();
      this.playVictoryMe();
      this.replayBgmAndBgs();
      this.makeRewards();
      this.displayVictoryMessage();
      this.displayRewards();
      this.gainRewards();
      this.endBattle(0);
    }
    static processEscape() {
      self.$gameParty.performEscape();
      SoundManager_default.playEscape();
      const success = this.processEscapeFormula();
      if (success) {
        this.displayEscapeSuccessMessage();
        this._escaped = true;
        this.processAbort();
      } else {
        this.displayEscapeFailureMessage();
        this._escapeRatio += 0.1;
        self.$gameParty.clearActions();
        this.startTurn();
      }
      return success;
    }
    static processEscapeFormula() {
      return this._preemptive ? true : Math.random() < this._escapeRatio;
    }
    static processAbort() {
      self.$gameParty.removeBattleStates();
      this.replayBgmAndBgs();
      this.endBattle(1);
    }
    static processDefeat() {
      this.displayDefeatMessage();
      this.playDefeatMe();
      if (this._canLose) {
        this.replayBgmAndBgs();
      } else {
        AudioManager_default.stopBgm();
      }
      this.endBattle(2);
    }
    static endBattle(result2) {
      this._phase = "battleEnd";
      if (this._eventCallback) {
        this._eventCallback(result2);
      }
      if (result2 === 0) {
        self.$gameSystem.onBattleWin();
      } else if (this._escaped) {
        self.$gameSystem.onBattleEscape();
      }
    }
    static updateBattleEnd() {
      if (this.isBattleTest()) {
        AudioManager_default.stopBgm();
        SceneManager_default.exit();
      } else if (!this._escaped && self.$gameParty.isAllDead()) {
        if (this._canLose) {
          self.$gameParty.reviveBattleMembers();
          SceneManager_default.pop();
        } else {
          SceneManager_default.goto(Scene_Gameover_default);
        }
      } else {
        SceneManager_default.pop();
      }
      this._phase = null;
    }
    static makeRewards() {
      this._rewards = {};
      this._rewards.gold = self.$gameTroop.goldTotal();
      this._rewards.exp = self.$gameTroop.expTotal();
      this._rewards.items = self.$gameTroop.makeDropItems();
    }
    static displayRewards() {
      this.displayExp();
      this.displayGold();
      this.displayDropItems();
    }
    static displayExp() {
      const exp = this._rewards.exp;
      if (exp > 0) {
        const text = TextManager_default.obtainExp.format(exp, TextManager_default.exp);
        self.$gameMessage.add(`\\.${text}`);
      }
    }
    static displayGold() {
      const gold2 = this._rewards.gold;
      if (gold2 > 0) {
        self.$gameMessage.add(`\\.${TextManager_default.obtainGold.format(gold2)}`);
      }
    }
    static displayDropItems() {
      const items = this._rewards.items;
      if (items.length > 0) {
        self.$gameMessage.newPage();
        items.forEach(({ name }) => {
          self.$gameMessage.add(TextManager_default.obtainItem.format(name));
        });
      }
    }
    static gainRewards() {
      this.gainExp();
      this.gainGold();
      this.gainDropItems();
    }
    static gainExp() {
      const exp = this._rewards.exp;
      self.$gameParty.allMembers().forEach((actor2) => {
        actor2.gainExp(exp);
      });
    }
    static gainGold() {
      self.$gameParty.gainGold(this._rewards.gold);
    }
    static gainDropItems() {
      const items = this._rewards.items;
      items.forEach((item2) => {
        self.$gameParty.gainItem(item2, 1);
      });
    }
    static ratePreemptive() {
      return self.$gameParty.ratePreemptive(self.$gameTroop.agility());
    }
    static rateSurprise() {
      return self.$gameParty.rateSurprise(self.$gameTroop.agility());
    }
    static playBattleBgm() {
      AudioManager_default.playBgm(self.$gameSystem.battleBgm());
      AudioManager_default.stopBgs();
    }
    static playVictoryMe() {
      AudioManager_default.playMe(self.$gameSystem.victoryMe());
    }
    static playDefeatMe() {
      AudioManager_default.playMe(self.$gameSystem.defeatMe());
    }
    static allBattleMembers() {
      return self.$gameParty.members().concat(self.$gameTroop.members());
    }
    static displayVictoryMessage() {
      self.$gameMessage.add(TextManager_default.victory.format(self.$gameParty.name()));
    }
    static displayDefeatMessage() {
      self.$gameMessage.add(TextManager_default.defeat.format(self.$gameParty.name()));
    }
    static displayEscapeSuccessMessage() {
      self.$gameMessage.add(
        TextManager_default.escapeStart.format(self.$gameParty.name())
      );
    }
    static displayEscapeFailureMessage() {
      self.$gameMessage.add(
        TextManager_default.escapeStart.format(self.$gameParty.name())
      );
      self.$gameMessage.add(`\\.${TextManager_default.escapeFailure}`);
    }
  };
  var BattleManager_default = BattleManager;

  // src-www/js/rpg_scenes/Scene_Boot.js
  var Scene_Boot = class extends Scene_Base_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
      this._startDate = Date.now();
    }
    async create() {
      super.create();
      DataManager2.loadDatabase();
      await ConfigManager_default.load();
      this.loadSystemWindowImage();
      DataManager2.loadGlobalInfoAsync();
    }
    loadSystemWindowImage() {
      ImageManager_default.reserveSystem("Window");
    }
    isReady() {
      if (Scene_Base_default.prototype.isReady.call(this)) {
        return DataManager2._globalInfo && DataManager2.isDatabaseLoaded() && this.isGameFontLoaded();
      } else {
        return false;
      }
    }
    isGameFontLoaded() {
      if (Graphics_default.isFontLoaded("GameFont")) {
        return true;
      } else if (!Graphics_default.canUseCssFontLoading()) {
        const elapsed = Date.now() - this._startDate;
        if (elapsed >= 6e4) {
          throw new Error("Failed to load GameFont");
        }
      }
    }
    start() {
      super.start();
      SoundManager_default.preloadImportantSounds();
      if (DataManager2.isBattleTest()) {
        DataManager2.setupBattleTest();
        SceneManager_default.goto(Scene_Battle_default);
      } else if (DataManager2.isEventTest()) {
        DataManager2.setupEventTest();
        SceneManager_default.goto(Scene_Map_default);
      } else {
        this.checkPlayerLocation();
        DataManager2.setupNewGame();
        SceneManager_default.goto(Scene_Title_default);
        Window_TitleCommand_default.initCommandPosition();
      }
      this.updateDocumentTitle();
    }
    updateDocumentTitle() {
      document.title = self.$dataSystem.gameTitle;
    }
    checkPlayerLocation() {
      if (self.$dataSystem.startMapId === 0) {
        throw new Error("Player's starting position is not set");
      }
    }
    static loadSystemImages() {
      ImageManager_default.reserveSystem("IconSet");
      ImageManager_default.reserveSystem("Balloon");
      ImageManager_default.reserveSystem("Shadow1");
      ImageManager_default.reserveSystem("Shadow2");
      ImageManager_default.reserveSystem("Damage");
      ImageManager_default.reserveSystem("States");
      ImageManager_default.reserveSystem("Weapons1");
      ImageManager_default.reserveSystem("Weapons2");
      ImageManager_default.reserveSystem("Weapons3");
      ImageManager_default.reserveSystem("ButtonSet");
    }
  };
  var Scene_Boot_default = Scene_Boot;

  // src-www/js/rpg_objects/Game_Temp.js
  var Game_Temp = class {
    constructor(...args) {
      this.initialize(...args);
    }
    initialize() {
      this._isPlaytest = Utils_default.isOptionValid("test");
      this._commonEventId = 0;
      this._destinationX = null;
      this._destinationY = null;
    }
    isPlaytest() {
      return this._isPlaytest;
    }
    reserveCommonEvent(commonEventId) {
      this._commonEventId = commonEventId;
    }
    clearCommonEvent() {
      this._commonEventId = 0;
    }
    isCommonEventReserved() {
      return this._commonEventId > 0;
    }
    reservedCommonEvent() {
      return self.$dataCommonEvents[this._commonEventId];
    }
    reservedCommonEventId() {
      return this._commonEventId;
    }
    setDestination(x, y) {
      this._destinationX = x;
      this._destinationY = y;
    }
    clearDestination() {
      this._destinationX = null;
      this._destinationY = null;
    }
    isDestinationValid() {
      return this._destinationX !== null;
    }
    destinationX() {
      return this._destinationX;
    }
    destinationY() {
      return this._destinationY;
    }
  };
  var Game_Temp_default = Game_Temp;

  // src-www/js/rpg_objects/Game_System.js
  var Game_System = class {
    constructor(...args) {
      this.initialize(...args);
    }
    initialize() {
      this._saveEnabled = true;
      this._menuEnabled = true;
      this._encounterEnabled = true;
      this._formationEnabled = true;
      this._battleCount = 0;
      this._winCount = 0;
      this._escapeCount = 0;
      this._saveCount = 0;
      this._versionId = 0;
      this._framesOnSave = 0;
      this._sceneFramesOnSave = 0;
      this._bgmOnSave = null;
      this._bgsOnSave = null;
      this._windowTone = null;
      this._battleBgm = null;
      this._victoryMe = null;
      this._defeatMe = null;
      this._savedBgm = null;
      this._walkingBgm = null;
    }
    isJapanese() {
      return self.$dataSystem.locale.match(/^ja/);
    }
    isChinese() {
      return self.$dataSystem.locale.match(/^zh/);
    }
    isKorean() {
      return self.$dataSystem.locale.match(/^ko/);
    }
    isCJK() {
      return self.$dataSystem.locale.match(/^(ja|zh|ko)/);
    }
    isRussian() {
      return self.$dataSystem.locale.match(/^ru/);
    }
    isSideView() {
      return self.$dataSystem.optSideView;
    }
    isSaveEnabled() {
      return this._saveEnabled;
    }
    disableSave() {
      this._saveEnabled = false;
    }
    enableSave() {
      this._saveEnabled = true;
    }
    isMenuEnabled() {
      return this._menuEnabled;
    }
    disableMenu() {
      this._menuEnabled = false;
    }
    enableMenu() {
      this._menuEnabled = true;
    }
    isEncounterEnabled() {
      return this._encounterEnabled;
    }
    disableEncounter() {
      this._encounterEnabled = false;
    }
    enableEncounter() {
      this._encounterEnabled = true;
    }
    isFormationEnabled() {
      return this._formationEnabled;
    }
    disableFormation() {
      this._formationEnabled = false;
    }
    enableFormation() {
      this._formationEnabled = true;
    }
    battleCount() {
      return this._battleCount;
    }
    winCount() {
      return this._winCount;
    }
    escapeCount() {
      return this._escapeCount;
    }
    saveCount() {
      return this._saveCount;
    }
    versionId() {
      return this._versionId;
    }
    windowTone() {
      return this._windowTone || self.$dataSystem.windowTone;
    }
    setWindowTone(value3) {
      this._windowTone = value3;
    }
    battleBgm() {
      return this._battleBgm || self.$dataSystem.battleBgm;
    }
    setBattleBgm(value3) {
      this._battleBgm = value3;
    }
    victoryMe() {
      return this._victoryMe || self.$dataSystem.victoryMe;
    }
    setVictoryMe(value3) {
      this._victoryMe = value3;
    }
    defeatMe() {
      return this._defeatMe || self.$dataSystem.defeatMe;
    }
    setDefeatMe(value3) {
      this._defeatMe = value3;
    }
    onBattleStart() {
      this._battleCount++;
    }
    onBattleWin() {
      this._winCount++;
    }
    onBattleEscape() {
      this._escapeCount++;
    }
    onBeforeSave() {
      this._saveCount++;
      this._versionId = self.$dataSystem.versionId;
      this._framesOnSave = Graphics_default.frameCount;
      this._sceneFramesOnSave = SceneManager_default.frameCount();
      this._bgmOnSave = AudioManager_default.saveBgm();
      this._bgsOnSave = AudioManager_default.saveBgs();
    }
    onAfterLoad() {
      Graphics_default.frameCount = this._framesOnSave;
      SceneManager_default.setFrameCount(this._sceneFramesOnSave || this._framesOnSave);
      AudioManager_default.playBgm(this._bgmOnSave);
      AudioManager_default.playBgs(this._bgsOnSave);
    }
    playtime() {
      return Math.floor(SceneManager_default.frameCount() / 60);
    }
    playtimeText() {
      const hour = Math.floor(this.playtime() / 60 / 60);
      const min = Math.floor(this.playtime() / 60) % 60;
      const sec = this.playtime() % 60;
      return `${hour.padZero(2)}:${min.padZero(2)}:${sec.padZero(2)}`;
    }
    saveBgm() {
      this._savedBgm = AudioManager_default.saveBgm();
    }
    replayBgm() {
      if (this._savedBgm) {
        AudioManager_default.replayBgm(this._savedBgm);
      }
    }
    saveWalkingBgm() {
      this._walkingBgm = AudioManager_default.saveBgm();
    }
    replayWalkingBgm() {
      if (this._walkingBgm) {
        AudioManager_default.playBgm(this._walkingBgm);
      }
    }
    saveWalkingBgm2() {
      this._walkingBgm = self.$dataMap.bgm;
    }
  };
  var Game_System_default = Game_System;

  // src-www/js/rpg_objects/Game_Picture.js
  var Game_Picture = class {
    constructor(...args) {
      this.initialize(...args);
    }
    initialize() {
      this.initBasic();
      this.initTarget();
      this.initTone();
      this.initRotation();
    }
    name() {
      return this._name;
    }
    origin() {
      return this._origin;
    }
    x() {
      return this._x;
    }
    y() {
      return this._y;
    }
    scaleX() {
      return this._scaleX;
    }
    scaleY() {
      return this._scaleY;
    }
    opacity() {
      return this._opacity;
    }
    blendMode() {
      return this._blendMode;
    }
    tone() {
      return this._tone;
    }
    angle() {
      return this._angle;
    }
    initBasic() {
      this._name = "";
      this._origin = 0;
      this._x = 0;
      this._y = 0;
      this._scaleX = 100;
      this._scaleY = 100;
      this._opacity = 255;
      this._blendMode = 0;
    }
    initTarget() {
      this._targetX = this._x;
      this._targetY = this._y;
      this._targetScaleX = this._scaleX;
      this._targetScaleY = this._scaleY;
      this._targetOpacity = this._opacity;
      this._duration = 0;
    }
    initTone() {
      this._tone = null;
      this._toneTarget = null;
      this._toneDuration = 0;
    }
    initRotation() {
      this._angle = 0;
      this._rotationSpeed = 0;
    }
    show(name, origin, x, y, scaleX, scaleY, opacity, blendMode) {
      this._name = name;
      this._origin = origin;
      this._x = x;
      this._y = y;
      this._scaleX = scaleX;
      this._scaleY = scaleY;
      this._opacity = opacity;
      this._blendMode = blendMode;
      this.initTarget();
      this.initTone();
      this.initRotation();
    }
    move(origin, x, y, scaleX, scaleY, opacity, blendMode, duration) {
      this._origin = origin;
      this._targetX = x;
      this._targetY = y;
      this._targetScaleX = scaleX;
      this._targetScaleY = scaleY;
      this._targetOpacity = opacity;
      this._blendMode = blendMode;
      this._duration = duration;
    }
    rotate(speed) {
      this._rotationSpeed = speed;
    }
    tint(tone, duration) {
      if (!this._tone) {
        this._tone = [0, 0, 0, 0];
      }
      this._toneTarget = tone.clone();
      this._toneDuration = duration;
      if (this._toneDuration === 0) {
        this._tone = this._toneTarget.clone();
      }
    }
    erase() {
      this._name = "";
      this._origin = 0;
      this.initTarget();
      this.initTone();
      this.initRotation();
    }
    update() {
      this.updateMove();
      this.updateTone();
      this.updateRotation();
    }
    updateMove() {
      if (this._duration > 0) {
        const d = this._duration;
        this._x = (this._x * (d - 1) + this._targetX) / d;
        this._y = (this._y * (d - 1) + this._targetY) / d;
        this._scaleX = (this._scaleX * (d - 1) + this._targetScaleX) / d;
        this._scaleY = (this._scaleY * (d - 1) + this._targetScaleY) / d;
        this._opacity = (this._opacity * (d - 1) + this._targetOpacity) / d;
        this._duration--;
      }
    }
    updateTone() {
      if (this._toneDuration > 0) {
        const d = this._toneDuration;
        for (let i = 0; i < 4; i++) {
          this._tone[i] = (this._tone[i] * (d - 1) + this._toneTarget[i]) / d;
        }
        this._toneDuration--;
      }
    }
    updateRotation() {
      if (this._rotationSpeed !== 0) {
        this._angle += this._rotationSpeed / 2;
      }
    }
  };
  var Game_Picture_default = Game_Picture;

  // src-www/js/rpg_objects/Game_Screen.js
  var Game_Screen = class {
    constructor(...args) {
      this.initialize(...args);
    }
    initialize() {
      this.clear();
    }
    clear() {
      this.clearFade();
      this.clearTone();
      this.clearFlash();
      this.clearShake();
      this.clearZoom();
      this.clearWeather();
      this.clearPictures();
    }
    onBattleStart() {
      this.clearFade();
      this.clearFlash();
      this.clearShake();
      this.clearZoom();
      this.eraseBattlePictures();
    }
    brightness() {
      return this._brightness;
    }
    tone() {
      return this._tone;
    }
    flashColor() {
      return this._flashColor;
    }
    shake() {
      return this._shake;
    }
    zoomX() {
      return this._zoomX;
    }
    zoomY() {
      return this._zoomY;
    }
    zoomScale() {
      return this._zoomScale;
    }
    weatherType() {
      return this._weatherType;
    }
    weatherPower() {
      return this._weatherPower;
    }
    picture(pictureId) {
      const realPictureId = this.realPictureId(pictureId);
      return this._pictures[realPictureId];
    }
    realPictureId(pictureId) {
      if (self.$gameParty.inBattle()) {
        return pictureId + this.maxPictures();
      } else {
        return pictureId;
      }
    }
    clearFade() {
      this._brightness = 255;
      this._fadeOutDuration = 0;
      this._fadeInDuration = 0;
    }
    clearTone() {
      this._tone = [0, 0, 0, 0];
      this._toneTarget = [0, 0, 0, 0];
      this._toneDuration = 0;
    }
    clearFlash() {
      this._flashColor = [0, 0, 0, 0];
      this._flashDuration = 0;
    }
    clearShake() {
      this._shakePower = 0;
      this._shakeSpeed = 0;
      this._shakeDuration = 0;
      this._shakeDirection = 1;
      this._shake = 0;
    }
    clearZoom() {
      this._zoomX = 0;
      this._zoomY = 0;
      this._zoomScale = 1;
      this._zoomScaleTarget = 1;
      this._zoomDuration = 0;
    }
    clearWeather() {
      this._weatherType = "none";
      this._weatherPower = 0;
      this._weatherPowerTarget = 0;
      this._weatherDuration = 0;
    }
    clearPictures() {
      this._pictures = [];
    }
    eraseBattlePictures() {
      this._pictures = this._pictures.slice(0, this.maxPictures() + 1);
    }
    maxPictures() {
      return 100;
    }
    startFadeOut(duration) {
      this._fadeOutDuration = duration;
      this._fadeInDuration = 0;
    }
    startFadeIn(duration) {
      this._fadeInDuration = duration;
      this._fadeOutDuration = 0;
    }
    startTint(tone, duration) {
      this._toneTarget = tone.clone();
      this._toneDuration = duration;
      if (this._toneDuration === 0) {
        this._tone = this._toneTarget.clone();
      }
    }
    startFlash(color2, duration) {
      this._flashColor = color2.clone();
      this._flashDuration = duration;
    }
    startShake(power, speed, duration) {
      this._shakePower = power;
      this._shakeSpeed = speed;
      this._shakeDuration = duration;
    }
    startZoom(x, y, scale, duration) {
      this._zoomX = x;
      this._zoomY = y;
      this._zoomScaleTarget = scale;
      this._zoomDuration = duration;
    }
    setZoom(x, y, scale) {
      this._zoomX = x;
      this._zoomY = y;
      this._zoomScale = scale;
    }
    changeWeather(type, power, duration) {
      if (type !== "none" || duration === 0) {
        this._weatherType = type;
      }
      this._weatherPowerTarget = type === "none" ? 0 : power;
      this._weatherDuration = duration;
      if (duration === 0) {
        this._weatherPower = this._weatherPowerTarget;
      }
    }
    update() {
      this.updateFadeOut();
      this.updateFadeIn();
      this.updateTone();
      this.updateFlash();
      this.updateShake();
      this.updateZoom();
      this.updateWeather();
      this.updatePictures();
    }
    updateFadeOut() {
      if (this._fadeOutDuration > 0) {
        const d = this._fadeOutDuration;
        this._brightness = this._brightness * (d - 1) / d;
        this._fadeOutDuration--;
      }
    }
    updateFadeIn() {
      if (this._fadeInDuration > 0) {
        const d = this._fadeInDuration;
        this._brightness = (this._brightness * (d - 1) + 255) / d;
        this._fadeInDuration--;
      }
    }
    updateTone() {
      if (this._toneDuration > 0) {
        const d = this._toneDuration;
        for (let i = 0; i < 4; i++) {
          this._tone[i] = (this._tone[i] * (d - 1) + this._toneTarget[i]) / d;
        }
        this._toneDuration--;
      }
    }
    updateFlash() {
      if (this._flashDuration > 0) {
        const d = this._flashDuration;
        this._flashColor[3] *= (d - 1) / d;
        this._flashDuration--;
      }
    }
    updateShake() {
      if (this._shakeDuration > 0 || this._shake !== 0) {
        const delta = this._shakePower * this._shakeSpeed * this._shakeDirection / 10;
        if (this._shakeDuration <= 1 && this._shake * (this._shake + delta) < 0) {
          this._shake = 0;
        } else {
          this._shake += delta;
        }
        if (this._shake > this._shakePower * 2) {
          this._shakeDirection = -1;
        }
        if (this._shake < -this._shakePower * 2) {
          this._shakeDirection = 1;
        }
        this._shakeDuration--;
      }
    }
    updateZoom() {
      if (this._zoomDuration > 0) {
        const d = this._zoomDuration;
        const t = this._zoomScaleTarget;
        this._zoomScale = (this._zoomScale * (d - 1) + t) / d;
        this._zoomDuration--;
      }
    }
    updateWeather() {
      if (this._weatherDuration > 0) {
        const d = this._weatherDuration;
        const t = this._weatherPowerTarget;
        this._weatherPower = (this._weatherPower * (d - 1) + t) / d;
        this._weatherDuration--;
        if (this._weatherDuration === 0 && this._weatherPowerTarget === 0) {
          this._weatherType = "none";
        }
      }
    }
    updatePictures() {
      this._pictures.forEach((picture) => {
        if (picture) {
          picture.update();
        }
      });
    }
    startFlashForDamage() {
      this.startFlash([255, 0, 0, 128], 8);
    }
    showPicture(pictureId, name, origin, x, y, scaleX, scaleY, opacity, blendMode) {
      const realPictureId = this.realPictureId(pictureId);
      const picture = new Game_Picture_default();
      picture.show(name, origin, x, y, scaleX, scaleY, opacity, blendMode);
      this._pictures[realPictureId] = picture;
    }
    movePicture(pictureId, origin, x, y, scaleX, scaleY, opacity, blendMode, duration) {
      const picture = this.picture(pictureId);
      if (picture) {
        picture.move(origin, x, y, scaleX, scaleY, opacity, blendMode, duration);
      }
    }
    rotatePicture(pictureId, speed) {
      const picture = this.picture(pictureId);
      if (picture) {
        picture.rotate(speed);
      }
    }
    tintPicture(pictureId, tone, duration) {
      const picture = this.picture(pictureId);
      if (picture) {
        picture.tint(tone, duration);
      }
    }
    erasePicture(pictureId) {
      const realPictureId = this.realPictureId(pictureId);
      this._pictures[realPictureId] = null;
    }
  };
  var Game_Screen_default = Game_Screen;

  // src-www/js/rpg_objects/Game_Timer.js
  var Game_Timer = class {
    constructor(...args) {
      this.initialize(...args);
    }
    initialize() {
      this._frames = 0;
      this._working = false;
    }
    update(sceneActive) {
      if (sceneActive && this._working && this._frames > 0) {
        this._frames--;
        if (this._frames === 0) {
          this.onExpire();
        }
      }
    }
    start(count) {
      this._frames = count;
      this._working = true;
    }
    stop() {
      this._working = false;
    }
    isWorking() {
      return this._working;
    }
    seconds() {
      return Math.floor(this._frames / 60);
    }
    onExpire() {
      BattleManager_default.abort();
    }
  };
  var Game_Timer_default = Game_Timer;

  // src-www/js/rpg_objects/Game_Message.js
  var Game_Message = class {
    constructor(...args) {
      this.initialize(...args);
    }
    initialize() {
      this.clear();
    }
    clear() {
      this._texts = [];
      this._choices = [];
      this._faceName = "";
      this._faceIndex = 0;
      this._background = 0;
      this._positionType = 2;
      this._choiceDefaultType = 0;
      this._choiceCancelType = 0;
      this._choiceBackground = 0;
      this._choicePositionType = 2;
      this._numInputVariableId = 0;
      this._numInputMaxDigits = 0;
      this._itemChoiceVariableId = 0;
      this._itemChoiceItypeId = 0;
      this._scrollMode = false;
      this._scrollSpeed = 2;
      this._scrollNoFast = false;
      this._choiceCallback = null;
    }
    choices() {
      return this._choices;
    }
    faceName() {
      return this._faceName;
    }
    faceIndex() {
      return this._faceIndex;
    }
    background() {
      return this._background;
    }
    positionType() {
      return this._positionType;
    }
    choiceDefaultType() {
      return this._choiceDefaultType;
    }
    choiceCancelType() {
      return this._choiceCancelType;
    }
    choiceBackground() {
      return this._choiceBackground;
    }
    choicePositionType() {
      return this._choicePositionType;
    }
    numInputVariableId() {
      return this._numInputVariableId;
    }
    numInputMaxDigits() {
      return this._numInputMaxDigits;
    }
    itemChoiceVariableId() {
      return this._itemChoiceVariableId;
    }
    itemChoiceItypeId() {
      return this._itemChoiceItypeId;
    }
    scrollMode() {
      return this._scrollMode;
    }
    scrollSpeed() {
      return this._scrollSpeed;
    }
    scrollNoFast() {
      return this._scrollNoFast;
    }
    add(text) {
      this._texts.push(text);
    }
    setFaceImage(faceName, faceIndex) {
      this._faceName = faceName;
      this._faceIndex = faceIndex;
    }
    setBackground(background) {
      this._background = background;
    }
    setPositionType(positionType) {
      this._positionType = positionType;
    }
    setChoices(choices, defaultType, cancelType) {
      this._choices = choices;
      this._choiceDefaultType = defaultType;
      this._choiceCancelType = cancelType;
    }
    setChoiceBackground(background) {
      this._choiceBackground = background;
    }
    setChoicePositionType(positionType) {
      this._choicePositionType = positionType;
    }
    setNumberInput(variableId, maxDigits) {
      this._numInputVariableId = variableId;
      this._numInputMaxDigits = maxDigits;
    }
    setItemChoice(variableId, itemType) {
      this._itemChoiceVariableId = variableId;
      this._itemChoiceItypeId = itemType;
    }
    setScroll(speed, noFast) {
      this._scrollMode = true;
      this._scrollSpeed = speed;
      this._scrollNoFast = noFast;
    }
    setChoiceCallback(callback) {
      this._choiceCallback = callback;
    }
    onChoice(n) {
      if (this._choiceCallback) {
        this._choiceCallback(n);
        this._choiceCallback = null;
      }
    }
    hasText() {
      return this._texts.length > 0;
    }
    isChoice() {
      return this._choices.length > 0;
    }
    isNumberInput() {
      return this._numInputVariableId > 0;
    }
    isItemChoice() {
      return this._itemChoiceVariableId > 0;
    }
    isBusy() {
      return this.hasText() || this.isChoice() || this.isNumberInput() || this.isItemChoice();
    }
    newPage() {
      if (this._texts.length > 0) {
        this._texts[this._texts.length - 1] += "\f";
      }
    }
    allText() {
      return this._texts.join("\n");
    }
  };
  var Game_Message_default = Game_Message;

  // src-www/js/rpg_objects/Game_Switches.js
  var Game_Switches = class {
    constructor(...args) {
      this.initialize(...args);
    }
    initialize() {
      this.clear();
    }
    clear() {
      this._data = [];
    }
    value(switchId) {
      return !!this._data[switchId];
    }
    setValue(switchId, value3) {
      if (switchId > 0 && switchId < self.$dataSystem.switches.length) {
        this._data[switchId] = value3;
        this.onChange();
      }
    }
    onChange() {
      self.$gameMap.requestRefresh();
    }
  };
  var Game_Switches_default = Game_Switches;

  // src-www/js/rpg_objects/Game_Variables.js
  var Game_Variables = class {
    constructor(...args) {
      this.initialize(...args);
    }
    initialize() {
      this.clear();
    }
    clear() {
      this._data = [];
    }
    value(variableId) {
      return this._data[variableId] || 0;
    }
    setValue(variableId, value3) {
      if (variableId > 0 && variableId < self.$dataSystem.variables.length) {
        if (typeof value3 === "number") {
          value3 = Math.floor(value3);
        }
        this._data[variableId] = value3;
        this.onChange();
      }
    }
    onChange() {
      self.$gameMap.requestRefresh();
    }
  };
  var Game_Variables_default = Game_Variables;

  // src-www/js/rpg_objects/Game_SelfSwitches.js
  var Game_SelfSwitches = class {
    constructor(...args) {
      this.initialize(...args);
    }
    initialize() {
      this.clear();
    }
    clear() {
      this._data = {};
    }
    value(key) {
      return !!this._data[key];
    }
    setValue(key, value3) {
      if (value3) {
        this._data[key] = true;
      } else {
        delete this._data[key];
      }
      this.onChange();
    }
    onChange() {
      self.$gameMap.requestRefresh();
    }
  };
  var Game_SelfSwitches_default = Game_SelfSwitches;

  // src-www/js/rpg_objects/Game_BattlerBase.js
  var Game_BattlerBase = class {
    constructor(...args) {
      this.initialize(...args);
    }
    initialize() {
      this.initMembers();
    }
    initMembers() {
      this._hp = 1;
      this._mp = 0;
      this._tp = 0;
      this._hidden = false;
      this.clearParamPlus();
      this.clearStates();
      this.clearBuffs();
    }
    clearParamPlus() {
      this._paramPlus = [0, 0, 0, 0, 0, 0, 0, 0];
    }
    clearStates() {
      this._states = [];
      this._stateTurns = {};
    }
    eraseState(stateId) {
      const index2 = this._states.indexOf(stateId);
      if (index2 >= 0) {
        this._states.splice(index2, 1);
      }
      delete this._stateTurns[stateId];
    }
    isStateAffected(stateId) {
      return this._states.contains(stateId);
    }
    isDeathStateAffected() {
      return this.isStateAffected(this.deathStateId());
    }
    deathStateId() {
      return 1;
    }
    resetStateCounts(stateId) {
      const state = self.$dataStates[stateId];
      const variance = 1 + Math.max(state.maxTurns - state.minTurns, 0);
      this._stateTurns[stateId] = state.minTurns + Math.randomInt(variance);
    }
    isStateExpired(stateId) {
      return this._stateTurns[stateId] === 0;
    }
    updateStateTurns() {
      this._states.forEach(function(stateId) {
        if (this._stateTurns[stateId] > 0) {
          this._stateTurns[stateId]--;
        }
      }, this);
    }
    clearBuffs() {
      this._buffs = [0, 0, 0, 0, 0, 0, 0, 0];
      this._buffTurns = [0, 0, 0, 0, 0, 0, 0, 0];
    }
    eraseBuff(paramId) {
      this._buffs[paramId] = 0;
      this._buffTurns[paramId] = 0;
    }
    buffLength() {
      return this._buffs.length;
    }
    buff(paramId) {
      return this._buffs[paramId];
    }
    isBuffAffected(paramId) {
      return this._buffs[paramId] > 0;
    }
    isDebuffAffected(paramId) {
      return this._buffs[paramId] < 0;
    }
    isBuffOrDebuffAffected(paramId) {
      return this._buffs[paramId] !== 0;
    }
    isMaxBuffAffected(paramId) {
      return this._buffs[paramId] === 2;
    }
    isMaxDebuffAffected(paramId) {
      return this._buffs[paramId] === -2;
    }
    increaseBuff(paramId) {
      if (!this.isMaxBuffAffected(paramId)) {
        this._buffs[paramId]++;
      }
    }
    decreaseBuff(paramId) {
      if (!this.isMaxDebuffAffected(paramId)) {
        this._buffs[paramId]--;
      }
    }
    overwriteBuffTurns(paramId, turns) {
      if (this._buffTurns[paramId] < turns) {
        this._buffTurns[paramId] = turns;
      }
    }
    isBuffExpired(paramId) {
      return this._buffTurns[paramId] === 0;
    }
    updateBuffTurns() {
      for (let i = 0; i < this._buffTurns.length; i++) {
        if (this._buffTurns[i] > 0) {
          this._buffTurns[i]--;
        }
      }
    }
    die() {
      this._hp = 0;
      this.clearStates();
      this.clearBuffs();
    }
    revive() {
      if (this._hp === 0) {
        this._hp = 1;
      }
    }
    states() {
      return this._states.map((id) => self.$dataStates[id]);
    }
    stateIcons() {
      return this.states().map(({ iconIndex }) => iconIndex).filter((iconIndex) => iconIndex > 0);
    }
    buffIcons() {
      const icons = [];
      for (let i = 0; i < this._buffs.length; i++) {
        if (this._buffs[i] !== 0) {
          icons.push(this.buffIconIndex(this._buffs[i], i));
        }
      }
      return icons;
    }
    buffIconIndex(buffLevel, paramId) {
      if (buffLevel > 0) {
        return Game_BattlerBase.ICON_BUFF_START + (buffLevel - 1) * 8 + paramId;
      } else if (buffLevel < 0) {
        return Game_BattlerBase.ICON_DEBUFF_START + (-buffLevel - 1) * 8 + paramId;
      } else {
        return 0;
      }
    }
    allIcons() {
      return this.stateIcons().concat(this.buffIcons());
    }
    traitObjects() {
      return this.states();
    }
    allTraits() {
      return this.traitObjects().reduce((r, { traits }) => r.concat(traits), []);
    }
    traits(code) {
      return this.allTraits().filter((trait) => trait.code === code);
    }
    traitsWithId(code, id) {
      return this.allTraits().filter(
        (trait) => trait.code === code && trait.dataId === id
      );
    }
    traitsPi(code, id) {
      return this.traitsWithId(code, id).reduce((r, { value: value3 }) => r * value3, 1);
    }
    traitsSum(code, id) {
      return this.traitsWithId(code, id).reduce((r, { value: value3 }) => r + value3, 0);
    }
    traitsSumAll(code) {
      return this.traits(code).reduce((r, { value: value3 }) => r + value3, 0);
    }
    traitsSet(code) {
      return this.traits(code).reduce((r, { dataId }) => r.concat(dataId), []);
    }
    paramBase(paramId) {
      return 0;
    }
    paramPlus(paramId) {
      return this._paramPlus[paramId];
    }
    paramMin(paramId) {
      if (paramId === 1) {
        return 0;
      } else {
        return 1;
      }
    }
    paramMax(paramId) {
      if (paramId === 0) {
        return 999999;
      } else if (paramId === 1) {
        return 9999;
      } else {
        return 999;
      }
    }
    paramRate(paramId) {
      return this.traitsPi(Game_BattlerBase.TRAIT_PARAM, paramId);
    }
    paramBuffRate(paramId) {
      return this._buffs[paramId] * 0.25 + 1;
    }
    param(paramId) {
      let value3 = this.paramBase(paramId) + this.paramPlus(paramId);
      value3 *= this.paramRate(paramId) * this.paramBuffRate(paramId);
      const maxValue = this.paramMax(paramId);
      const minValue = this.paramMin(paramId);
      return Math.round(value3.clamp(minValue, maxValue));
    }
    xparam(xparamId) {
      return this.traitsSum(Game_BattlerBase.TRAIT_XPARAM, xparamId);
    }
    sparam(sparamId) {
      return this.traitsPi(Game_BattlerBase.TRAIT_SPARAM, sparamId);
    }
    elementRate(elementId) {
      return this.traitsPi(Game_BattlerBase.TRAIT_ELEMENT_RATE, elementId);
    }
    debuffRate(paramId) {
      return this.traitsPi(Game_BattlerBase.TRAIT_DEBUFF_RATE, paramId);
    }
    stateRate(stateId) {
      return this.traitsPi(Game_BattlerBase.TRAIT_STATE_RATE, stateId);
    }
    stateResistSet() {
      return this.traitsSet(Game_BattlerBase.TRAIT_STATE_RESIST);
    }
    isStateResist(stateId) {
      return this.stateResistSet().contains(stateId);
    }
    attackElements() {
      return this.traitsSet(Game_BattlerBase.TRAIT_ATTACK_ELEMENT);
    }
    attackStates() {
      return this.traitsSet(Game_BattlerBase.TRAIT_ATTACK_STATE);
    }
    attackStatesRate(stateId) {
      return this.traitsSum(Game_BattlerBase.TRAIT_ATTACK_STATE, stateId);
    }
    attackSpeed() {
      return this.traitsSumAll(Game_BattlerBase.TRAIT_ATTACK_SPEED);
    }
    attackTimesAdd() {
      return Math.max(this.traitsSumAll(Game_BattlerBase.TRAIT_ATTACK_TIMES), 0);
    }
    addedSkillTypes() {
      return this.traitsSet(Game_BattlerBase.TRAIT_STYPE_ADD);
    }
    isSkillTypeSealed(stypeId) {
      return this.traitsSet(Game_BattlerBase.TRAIT_STYPE_SEAL).contains(stypeId);
    }
    addedSkills() {
      return this.traitsSet(Game_BattlerBase.TRAIT_SKILL_ADD);
    }
    isSkillSealed(skillId) {
      return this.traitsSet(Game_BattlerBase.TRAIT_SKILL_SEAL).contains(skillId);
    }
    isEquipWtypeOk(wtypeId) {
      return this.traitsSet(Game_BattlerBase.TRAIT_EQUIP_WTYPE).contains(wtypeId);
    }
    isEquipAtypeOk(atypeId) {
      return this.traitsSet(Game_BattlerBase.TRAIT_EQUIP_ATYPE).contains(atypeId);
    }
    isEquipTypeLocked(etypeId) {
      return this.traitsSet(Game_BattlerBase.TRAIT_EQUIP_LOCK).contains(etypeId);
    }
    isEquipTypeSealed(etypeId) {
      return this.traitsSet(Game_BattlerBase.TRAIT_EQUIP_SEAL).contains(etypeId);
    }
    slotType() {
      const set = this.traitsSet(Game_BattlerBase.TRAIT_SLOT_TYPE);
      return set.length > 0 ? Math.max.apply(null, set) : 0;
    }
    isDualWield() {
      return this.slotType() === 1;
    }
    actionPlusSet() {
      return this.traits(Game_BattlerBase.TRAIT_ACTION_PLUS).map(
        ({ value: value3 }) => value3
      );
    }
    specialFlag(flagId) {
      return this.traits(Game_BattlerBase.TRAIT_SPECIAL_FLAG).some(
        ({ dataId }) => dataId === flagId
      );
    }
    collapseType() {
      const set = this.traitsSet(Game_BattlerBase.TRAIT_COLLAPSE_TYPE);
      return set.length > 0 ? Math.max.apply(null, set) : 0;
    }
    partyAbility(abilityId) {
      return this.traits(Game_BattlerBase.TRAIT_PARTY_ABILITY).some(
        ({ dataId }) => dataId === abilityId
      );
    }
    isAutoBattle() {
      return this.specialFlag(Game_BattlerBase.FLAG_ID_AUTO_BATTLE);
    }
    isGuard() {
      return this.specialFlag(Game_BattlerBase.FLAG_ID_GUARD) && this.canMove();
    }
    isSubstitute() {
      return this.specialFlag(Game_BattlerBase.FLAG_ID_SUBSTITUTE) && this.canMove();
    }
    isPreserveTp() {
      return this.specialFlag(Game_BattlerBase.FLAG_ID_PRESERVE_TP);
    }
    addParam(paramId, value3) {
      this._paramPlus[paramId] += value3;
      this.refresh();
    }
    setHp(hp) {
      this._hp = hp;
      this.refresh();
    }
    setMp(mp) {
      this._mp = mp;
      this.refresh();
    }
    setTp(tp) {
      this._tp = tp;
      this.refresh();
    }
    maxTp() {
      return 100;
    }
    refresh() {
      this.stateResistSet().forEach(function(stateId) {
        this.eraseState(stateId);
      }, this);
      this._hp = this._hp.clamp(0, this.mhp);
      this._mp = this._mp.clamp(0, this.mmp);
      this._tp = this._tp.clamp(0, this.maxTp());
    }
    recoverAll() {
      this.clearStates();
      this._hp = this.mhp;
      this._mp = this.mmp;
    }
    hpRate() {
      return this.hp / this.mhp;
    }
    mpRate() {
      return this.mmp > 0 ? this.mp / this.mmp : 0;
    }
    tpRate() {
      return this.tp / this.maxTp();
    }
    hide() {
      this._hidden = true;
    }
    appear() {
      this._hidden = false;
    }
    isHidden() {
      return this._hidden;
    }
    isAppeared() {
      return !this.isHidden();
    }
    isDead() {
      return this.isAppeared() && this.isDeathStateAffected();
    }
    isAlive() {
      return this.isAppeared() && !this.isDeathStateAffected();
    }
    isDying() {
      return this.isAlive() && this._hp < this.mhp / 4;
    }
    isRestricted() {
      return this.isAppeared() && this.restriction() > 0;
    }
    canInput() {
      return this.isAppeared() && !this.isRestricted() && !this.isAutoBattle();
    }
    canMove() {
      return this.isAppeared() && this.restriction() < 4;
    }
    isConfused() {
      return this.isAppeared() && this.restriction() >= 1 && this.restriction() <= 3;
    }
    confusionLevel() {
      return this.isConfused() ? this.restriction() : 0;
    }
    isActor() {
      return false;
    }
    isEnemy() {
      return false;
    }
    sortStates() {
      this._states.sort((a2, b2) => {
        const p1 = self.$dataStates[a2].priority;
        const p2 = self.$dataStates[b2].priority;
        if (p1 !== p2) {
          return p2 - p1;
        }
        return a2 - b2;
      });
    }
    restriction() {
      return Math.max.apply(
        null,
        this.states().map(({ restriction }) => restriction).concat(0)
      );
    }
    addNewState(stateId, source) {
      if (stateId === this.deathStateId()) {
        this.die();
      }
      const restricted = this.isRestricted();
      this._states.push(stateId);
      this.sortStates();
      if (!restricted && this.isRestricted()) {
        this.onRestrict();
      }
    }
    onRestrict() {
    }
    mostImportantStateText() {
      const states = this.states();
      for (let i = 0; i < states.length; i++) {
        if (states[i].message3) {
          return states[i].message3;
        }
      }
      return "";
    }
    stateMotionIndex() {
      const states = this.states();
      if (states.length > 0) {
        return states[0].motion;
      } else {
        return 0;
      }
    }
    stateOverlayIndex() {
      const states = this.states();
      if (states.length > 0) {
        return states[0].overlay;
      } else {
        return 0;
      }
    }
    isSkillWtypeOk(skill) {
      return true;
    }
    skillMpCost({ mpCost }) {
      return Math.floor(mpCost * this.mcr);
    }
    skillTpCost({ tpCost }) {
      return tpCost;
    }
    canPaySkillCost(skill) {
      return this._tp >= this.skillTpCost(skill) && this._mp >= this.skillMpCost(skill);
    }
    paySkillCost(skill) {
      this._mp -= this.skillMpCost(skill);
      this._tp -= this.skillTpCost(skill);
    }
    isOccasionOk({ occasion }) {
      if (self.$gameParty.inBattle()) {
        return occasion === 0 || occasion === 1;
      } else {
        return occasion === 0 || occasion === 2;
      }
    }
    meetsUsableItemConditions(item2) {
      return this.canMove() && this.isOccasionOk(item2);
    }
    meetsSkillConditions(skill) {
      return this.meetsUsableItemConditions(skill) && this.isSkillWtypeOk(skill) && this.canPaySkillCost(skill) && !this.isSkillSealed(skill.id) && !this.isSkillTypeSealed(skill.stypeId);
    }
    meetsItemConditions(item2) {
      return this.meetsUsableItemConditions(item2) && self.$gameParty.hasItem(item2);
    }
    canUse(item2) {
      if (!item2) {
        return false;
      } else if (DataManager2.isSkill(item2)) {
        return this.meetsSkillConditions(item2);
      } else if (DataManager2.isItem(item2)) {
        return this.meetsItemConditions(item2);
      } else {
        return false;
      }
    }
    canEquip(item2) {
      if (!item2) {
        return false;
      } else if (DataManager2.isWeapon(item2)) {
        return this.canEquipWeapon(item2);
      } else if (DataManager2.isArmor(item2)) {
        return this.canEquipArmor(item2);
      } else {
        return false;
      }
    }
    canEquipWeapon({ wtypeId, etypeId }) {
      return this.isEquipWtypeOk(wtypeId) && !this.isEquipTypeSealed(etypeId);
    }
    canEquipArmor({ atypeId, etypeId }) {
      return this.isEquipAtypeOk(atypeId) && !this.isEquipTypeSealed(etypeId);
    }
    attackSkillId() {
      return 1;
    }
    guardSkillId() {
      return 2;
    }
    canAttack() {
      return this.canUse(self.$dataSkills[this.attackSkillId()]);
    }
    canGuard() {
      return this.canUse(self.$dataSkills[this.guardSkillId()]);
    }
  };
  Game_BattlerBase.TRAIT_ELEMENT_RATE = 11;
  Game_BattlerBase.TRAIT_DEBUFF_RATE = 12;
  Game_BattlerBase.TRAIT_STATE_RATE = 13;
  Game_BattlerBase.TRAIT_STATE_RESIST = 14;
  Game_BattlerBase.TRAIT_PARAM = 21;
  Game_BattlerBase.TRAIT_XPARAM = 22;
  Game_BattlerBase.TRAIT_SPARAM = 23;
  Game_BattlerBase.TRAIT_ATTACK_ELEMENT = 31;
  Game_BattlerBase.TRAIT_ATTACK_STATE = 32;
  Game_BattlerBase.TRAIT_ATTACK_SPEED = 33;
  Game_BattlerBase.TRAIT_ATTACK_TIMES = 34;
  Game_BattlerBase.TRAIT_STYPE_ADD = 41;
  Game_BattlerBase.TRAIT_STYPE_SEAL = 42;
  Game_BattlerBase.TRAIT_SKILL_ADD = 43;
  Game_BattlerBase.TRAIT_SKILL_SEAL = 44;
  Game_BattlerBase.TRAIT_EQUIP_WTYPE = 51;
  Game_BattlerBase.TRAIT_EQUIP_ATYPE = 52;
  Game_BattlerBase.TRAIT_EQUIP_LOCK = 53;
  Game_BattlerBase.TRAIT_EQUIP_SEAL = 54;
  Game_BattlerBase.TRAIT_SLOT_TYPE = 55;
  Game_BattlerBase.TRAIT_ACTION_PLUS = 61;
  Game_BattlerBase.TRAIT_SPECIAL_FLAG = 62;
  Game_BattlerBase.TRAIT_COLLAPSE_TYPE = 63;
  Game_BattlerBase.TRAIT_PARTY_ABILITY = 64;
  Game_BattlerBase.FLAG_ID_AUTO_BATTLE = 0;
  Game_BattlerBase.FLAG_ID_GUARD = 1;
  Game_BattlerBase.FLAG_ID_SUBSTITUTE = 2;
  Game_BattlerBase.FLAG_ID_PRESERVE_TP = 3;
  Game_BattlerBase.ICON_BUFF_START = 32;
  Game_BattlerBase.ICON_DEBUFF_START = 48;
  Object.defineProperties(Game_BattlerBase.prototype, {
    // Hit Points
    hp: {
      get() {
        return this._hp;
      },
      configurable: true
    },
    // Magic Points
    mp: {
      get() {
        return this._mp;
      },
      configurable: true
    },
    // Tactical Points
    tp: {
      get() {
        return this._tp;
      },
      configurable: true
    },
    // Maximum Hit Points
    mhp: {
      get() {
        return this.param(0);
      },
      configurable: true
    },
    // Maximum Magic Points
    mmp: {
      get() {
        return this.param(1);
      },
      configurable: true
    },
    // ATtacK power
    atk: {
      get() {
        return this.param(2);
      },
      configurable: true
    },
    // DEFense power
    def: {
      get() {
        return this.param(3);
      },
      configurable: true
    },
    // Magic ATtack power
    mat: {
      get() {
        return this.param(4);
      },
      configurable: true
    },
    // Magic DeFense power
    mdf: {
      get() {
        return this.param(5);
      },
      configurable: true
    },
    // AGIlity
    agi: {
      get() {
        return this.param(6);
      },
      configurable: true
    },
    // LUcK
    luk: {
      get() {
        return this.param(7);
      },
      configurable: true
    },
    // HIT rate
    hit: {
      get() {
        return this.xparam(0);
      },
      configurable: true
    },
    // EVAsion rate
    eva: {
      get() {
        return this.xparam(1);
      },
      configurable: true
    },
    // CRItical rate
    cri: {
      get() {
        return this.xparam(2);
      },
      configurable: true
    },
    // Critical EVasion rate
    cev: {
      get() {
        return this.xparam(3);
      },
      configurable: true
    },
    // Magic EVasion rate
    mev: {
      get() {
        return this.xparam(4);
      },
      configurable: true
    },
    // Magic ReFlection rate
    mrf: {
      get() {
        return this.xparam(5);
      },
      configurable: true
    },
    // CouNTer attack rate
    cnt: {
      get() {
        return this.xparam(6);
      },
      configurable: true
    },
    // Hp ReGeneration rate
    hrg: {
      get() {
        return this.xparam(7);
      },
      configurable: true
    },
    // Mp ReGeneration rate
    mrg: {
      get() {
        return this.xparam(8);
      },
      configurable: true
    },
    // Tp ReGeneration rate
    trg: {
      get() {
        return this.xparam(9);
      },
      configurable: true
    },
    // TarGet Rate
    tgr: {
      get() {
        return this.sparam(0);
      },
      configurable: true
    },
    // GuaRD effect rate
    grd: {
      get() {
        return this.sparam(1);
      },
      configurable: true
    },
    // RECovery effect rate
    rec: {
      get() {
        return this.sparam(2);
      },
      configurable: true
    },
    // PHArmacology
    pha: {
      get() {
        return this.sparam(3);
      },
      configurable: true
    },
    // Mp Cost Rate
    mcr: {
      get() {
        return this.sparam(4);
      },
      configurable: true
    },
    // Tp Charge Rate
    tcr: {
      get() {
        return this.sparam(5);
      },
      configurable: true
    },
    // Physical Damage Rate
    pdr: {
      get() {
        return this.sparam(6);
      },
      configurable: true
    },
    // Magical Damage Rate
    mdr: {
      get() {
        return this.sparam(7);
      },
      configurable: true
    },
    // Floor Damage Rate
    fdr: {
      get() {
        return this.sparam(8);
      },
      configurable: true
    },
    // EXperience Rate
    exr: {
      get() {
        return this.sparam(9);
      },
      configurable: true
    }
  });
  var Game_BattlerBase_default = Game_BattlerBase;

  // src-www/js/rpg_objects/Game_ActionResult.js
  var Game_ActionResult = class {
    constructor(...args) {
      this.initialize(...args);
    }
    initialize() {
      this.clear();
    }
    clear() {
      this.used = false;
      this.missed = false;
      this.evaded = false;
      this.physical = false;
      this.drain = false;
      this.critical = false;
      this.success = false;
      this.hpAffected = false;
      this.hpDamage = 0;
      this.mpDamage = 0;
      this.tpDamage = 0;
      this.addedStates = [];
      this.removedStates = [];
      this.addedBuffs = [];
      this.addedDebuffs = [];
      this.removedBuffs = [];
    }
    addedStateObjects() {
      return this.addedStates.map((id) => self.$dataStates[id]);
    }
    removedStateObjects() {
      return this.removedStates.map((id) => self.$dataStates[id]);
    }
    isStatusAffected() {
      return this.addedStates.length > 0 || this.removedStates.length > 0 || this.addedBuffs.length > 0 || this.addedDebuffs.length > 0 || this.removedBuffs.length > 0;
    }
    isHit() {
      return this.used && !this.missed && !this.evaded;
    }
    isStateAdded(stateId) {
      return this.addedStates.contains(stateId);
    }
    pushAddedState(stateId) {
      if (!this.isStateAdded(stateId)) {
        this.addedStates.push(stateId);
      }
    }
    isStateRemoved(stateId) {
      return this.removedStates.contains(stateId);
    }
    pushRemovedState(stateId) {
      if (!this.isStateRemoved(stateId)) {
        this.removedStates.push(stateId);
      }
    }
    isBuffAdded(paramId) {
      return this.addedBuffs.contains(paramId);
    }
    pushAddedBuff(paramId) {
      if (!this.isBuffAdded(paramId)) {
        this.addedBuffs.push(paramId);
      }
    }
    isDebuffAdded(paramId) {
      return this.addedDebuffs.contains(paramId);
    }
    pushAddedDebuff(paramId) {
      if (!this.isDebuffAdded(paramId)) {
        this.addedDebuffs.push(paramId);
      }
    }
    isBuffRemoved(paramId) {
      return this.removedBuffs.contains(paramId);
    }
    pushRemovedBuff(paramId) {
      if (!this.isBuffRemoved(paramId)) {
        this.removedBuffs.push(paramId);
      }
    }
  };
  var Game_ActionResult_default = Game_ActionResult;

  // src-www/js/rpg_objects/Game_Battler.js
  var Game_Battler = class extends Game_BattlerBase_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
    }
    initMembers() {
      super.initMembers();
      this._actions = [];
      this._speed = 0;
      this._result = new Game_ActionResult_default();
      this._actionState = "";
      this._lastTargetIndex = 0;
      this._animations = [];
      this._damagePopup = false;
      this._effectType = null;
      this._motionType = null;
      this._weaponImageId = 0;
      this._motionRefresh = false;
      this._selected = false;
    }
    clearAnimations() {
      this._animations = [];
    }
    clearDamagePopup() {
      this._damagePopup = false;
    }
    clearWeaponAnimation() {
      this._weaponImageId = 0;
    }
    clearEffect() {
      this._effectType = null;
    }
    clearMotion() {
      this._motionType = null;
      this._motionRefresh = false;
    }
    requestEffect(effectType) {
      this._effectType = effectType;
    }
    requestMotion(motionType) {
      this._motionType = motionType;
    }
    requestMotionRefresh() {
      this._motionRefresh = true;
    }
    select() {
      this._selected = true;
    }
    deselect() {
      this._selected = false;
    }
    isAnimationRequested() {
      return this._animations.length > 0;
    }
    isDamagePopupRequested() {
      return this._damagePopup;
    }
    isEffectRequested() {
      return !!this._effectType;
    }
    isMotionRequested() {
      return !!this._motionType;
    }
    isWeaponAnimationRequested() {
      return this._weaponImageId > 0;
    }
    isMotionRefreshRequested() {
      return this._motionRefresh;
    }
    isSelected() {
      return this._selected;
    }
    effectType() {
      return this._effectType;
    }
    motionType() {
      return this._motionType;
    }
    weaponImageId() {
      return this._weaponImageId;
    }
    shiftAnimation() {
      return this._animations.shift();
    }
    startAnimation(animationId, mirror, delay) {
      const data = {
        animationId,
        mirror,
        delay
      };
      this._animations.push(data);
    }
    startDamagePopup() {
      this._damagePopup = true;
    }
    startWeaponAnimation(weaponImageId) {
      this._weaponImageId = weaponImageId;
    }
    action(index2) {
      return this._actions[index2];
    }
    setAction(index2, action) {
      this._actions[index2] = action;
    }
    numActions() {
      return this._actions.length;
    }
    clearActions() {
      this._actions = [];
    }
    result() {
      return this._result;
    }
    clearResult() {
      this._result.clear();
    }
    refresh() {
      super.refresh();
      if (this.hp === 0) {
        this.addState(this.deathStateId());
      } else {
        this.removeState(this.deathStateId());
      }
    }
    onApplyDamage(action, target2, value3) {
    }
    onReceiveDamage(action, source, value3) {
    }
    onHitAction(action, target2) {
    }
    onEvadeAction(action, source) {
    }
    onApplyCritical(action, target2, value3) {
    }
    onReceiveCritical(action, source, value3) {
    }
    addState(stateId, source) {
      if (this.isStateAddable(stateId)) {
        if (!this.isStateAffected(stateId)) {
          this.addNewState(stateId, source);
          this.refresh();
        }
        if (source)
          source.onApplyStateSuccess(stateId, this);
        this.resetStateCounts(stateId);
        this._result.pushAddedState(stateId);
      } else {
        if (source)
          source.onApplyStateFailure(stateId, this);
      }
    }
    onApplyStateSuccess(stateId, target2) {
    }
    onApplyStateFailure(stateId, target2) {
    }
    isStateAddable(stateId) {
      return this.isAlive() && self.$dataStates[stateId] && !this.isStateResist(stateId) && !this._result.isStateRemoved(stateId) && !this.isStateRestrict(stateId);
    }
    isStateRestrict(stateId) {
      return self.$dataStates[stateId].removeByRestriction && this.isRestricted();
    }
    onRestrict() {
      super.onRestrict();
      this.clearActions();
      this.states().forEach(function({ removeByRestriction, id }) {
        if (removeByRestriction) {
          this.removeState(id);
        }
      }, this);
    }
    removeState(stateId) {
      if (this.isStateAffected(stateId)) {
        if (stateId === this.deathStateId()) {
          this.revive();
        }
        this.eraseState(stateId);
        this.refresh();
        this._result.pushRemovedState(stateId);
      }
    }
    escape() {
      if (self.$gameParty.inBattle()) {
        this.hide();
      }
      this.clearActions();
      this.clearStates();
      SoundManager_default.playEscape();
    }
    addBuff(paramId, turns) {
      if (this.isAlive()) {
        this.increaseBuff(paramId);
        if (this.isBuffAffected(paramId)) {
          this.overwriteBuffTurns(paramId, turns);
        }
        this._result.pushAddedBuff(paramId);
        this.refresh();
      }
    }
    addDebuff(paramId, turns) {
      if (this.isAlive()) {
        this.decreaseBuff(paramId);
        if (this.isDebuffAffected(paramId)) {
          this.overwriteBuffTurns(paramId, turns);
        }
        this._result.pushAddedDebuff(paramId);
        this.refresh();
      }
    }
    removeBuff(paramId) {
      if (this.isAlive() && this.isBuffOrDebuffAffected(paramId)) {
        this.eraseBuff(paramId);
        this._result.pushRemovedBuff(paramId);
        this.refresh();
      }
    }
    removeBattleStates() {
      this.states().forEach(function({ removeAtBattleEnd, id }) {
        if (removeAtBattleEnd) {
          this.removeState(id);
        }
      }, this);
    }
    removeAllBuffs() {
      for (let i = 0; i < this.buffLength(); i++) {
        this.removeBuff(i);
      }
    }
    removeStatesAuto(timing) {
      this.states().forEach(function({ id, autoRemovalTiming }) {
        if (this.isStateExpired(id) && autoRemovalTiming === timing) {
          this.removeState(id);
        }
      }, this);
    }
    removeBuffsAuto() {
      for (let i = 0; i < this.buffLength(); i++) {
        if (this.isBuffExpired(i)) {
          this.removeBuff(i);
        }
      }
    }
    removeStatesByDamage() {
      this.states().forEach(function({ removeByDamage, chanceByDamage, id }) {
        if (removeByDamage && Math.randomInt(100) < chanceByDamage) {
          this.removeState(id);
        }
      }, this);
    }
    makeActionTimes() {
      return this.actionPlusSet().reduce(
        (r, p) => Math.random() < p ? r + 1 : r,
        1
      );
    }
    makeActions() {
      this.clearActions();
      if (this.canMove()) {
        const actionTimes = this.makeActionTimes();
        this._actions = [];
        for (let i = 0; i < actionTimes; i++) {
          this._actions.push(new Game_Action_default(this));
        }
      }
    }
    speed() {
      return this._speed;
    }
    makeSpeed() {
      this._speed = Math.min.apply(
        null,
        this._actions.map((action) => action.speed())
      ) || 0;
    }
    currentAction() {
      return this._actions[0];
    }
    removeCurrentAction() {
      this._actions.shift();
    }
    setLastTarget(target2) {
      if (target2) {
        this._lastTargetIndex = target2.index();
      } else {
        this._lastTargetIndex = 0;
      }
    }
    forceAction(skillId, targetIndex) {
      this.clearActions();
      const action = new Game_Action_default(this, true);
      action.setSkill(skillId);
      if (targetIndex === -2) {
        action.setTarget(this._lastTargetIndex);
      } else if (targetIndex === -1) {
        action.decideRandomTarget();
      } else {
        action.setTarget(targetIndex);
      }
      this._actions.push(action);
    }
    useItem(item2) {
      if (DataManager2.isSkill(item2)) {
        this.paySkillCost(item2);
      } else if (DataManager2.isItem(item2)) {
        this.consumeItem(item2);
      }
    }
    consumeItem(item2) {
      self.$gameParty.consumeItem(item2);
    }
    gainHp(value3) {
      this._result.hpDamage = -value3;
      this._result.hpAffected = true;
      this.setHp(this.hp + value3);
    }
    gainMp(value3) {
      this._result.mpDamage = -value3;
      this.setMp(this.mp + value3);
    }
    gainTp(value3) {
      this._result.tpDamage = -value3;
      this.setTp(this.tp + value3);
    }
    gainSilentTp(value3) {
      this.setTp(this.tp + value3);
    }
    initTp() {
      this.setTp(Math.randomInt(25));
    }
    clearTp() {
      this.setTp(0);
    }
    chargeTpByDamage(damageRate) {
      const value3 = Math.floor(50 * damageRate * this.tcr);
      this.gainSilentTp(value3);
    }
    regenerateHp() {
      let value3 = Math.floor(this.mhp * this.hrg);
      value3 = Math.max(value3, -this.maxSlipDamage());
      if (value3 !== 0) {
        this.gainHp(value3);
      }
    }
    maxSlipDamage() {
      return self.$dataSystem.optSlipDeath ? this.hp : Math.max(this.hp - 1, 0);
    }
    regenerateMp() {
      const value3 = Math.floor(this.mmp * this.mrg);
      if (value3 !== 0) {
        this.gainMp(value3);
      }
    }
    regenerateTp() {
      const value3 = Math.floor(100 * this.trg);
      this.gainSilentTp(value3);
    }
    regenerateAll() {
      if (this.isAlive()) {
        this.regenerateHp();
        this.regenerateMp();
        this.regenerateTp();
      }
    }
    onBattleStart() {
      this.setActionState("undecided");
      this.clearMotion();
      if (!this.isPreserveTp()) {
        this.initTp();
      }
    }
    onAllActionsEnd() {
      this.clearResult();
      this.removeStatesAuto(1);
      this.removeBuffsAuto();
    }
    onTurnEnd() {
      this.clearResult();
      this.regenerateAll();
      if (!BattleManager_default.isForcedTurn()) {
        this.updateStateTurns();
        this.updateBuffTurns();
      }
      this.removeStatesAuto(2);
    }
    onBattleEnd() {
      this.clearResult();
      this.removeBattleStates();
      this.removeAllBuffs();
      this.clearActions();
      if (!this.isPreserveTp()) {
        this.clearTp();
      }
      this.appear();
    }
    onDamage(value3) {
      this.removeStatesByDamage();
      this.chargeTpByDamage(value3 / this.mhp);
    }
    setActionState(actionState) {
      this._actionState = actionState;
      this.requestMotionRefresh();
    }
    isUndecided() {
      return this._actionState === "undecided";
    }
    isInputting() {
      return this._actionState === "inputting";
    }
    isWaiting() {
      return this._actionState === "waiting";
    }
    isActing() {
      return this._actionState === "acting";
    }
    isChanting() {
      if (this.isWaiting()) {
        return this._actions.some((action) => action.isMagicSkill());
      }
      return false;
    }
    isGuardWaiting() {
      if (this.isWaiting()) {
        return this._actions.some((action) => action.isGuard());
      }
      return false;
    }
    performActionStart(action) {
      if (!action.isGuard()) {
        this.setActionState("acting");
      }
    }
    performAction(action) {
    }
    performActionEnd() {
      this.setActionState("done");
    }
    performDamage() {
    }
    performMiss() {
      SoundManager_default.playMiss();
    }
    performRecovery() {
      SoundManager_default.playRecovery();
    }
    performEvasion() {
      SoundManager_default.playEvasion();
    }
    performMagicEvasion() {
      SoundManager_default.playMagicEvasion();
    }
    performCounter() {
      SoundManager_default.playEvasion();
    }
    performReflection() {
      SoundManager_default.playReflection();
    }
    performSubstitute(target2) {
    }
    performCollapse() {
    }
  };
  var Game_Battler_default = Game_Battler;

  // src-www/js/rpg_objects/Game_Actor.js
  var Game_Actor = class extends Game_Battler_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    get level() {
      return this._level;
    }
    initialize(actorId) {
      super.initialize();
      this.setup(actorId);
    }
    initMembers() {
      super.initMembers();
      this._actorId = 0;
      this._name = "";
      this._nickname = "";
      this._classId = 0;
      this._level = 0;
      this._characterName = "";
      this._characterIndex = 0;
      this._faceName = "";
      this._faceIndex = 0;
      this._battlerName = "";
      this._exp = {};
      this._skills = [];
      this._equips = [];
      this._actionInputIndex = 0;
      this._lastMenuSkill = new Game_Item_default();
      this._lastBattleSkill = new Game_Item_default();
      this._lastCommandSymbol = "";
    }
    setup(actorId) {
      const actor2 = self.$dataActors[actorId];
      this._actorId = actorId;
      this._name = actor2.name;
      this._nickname = actor2.nickname;
      this._profile = actor2.profile;
      this._classId = actor2.classId;
      this._level = actor2.initialLevel;
      this.initImages();
      this.initExp();
      this.initSkills();
      this.initEquips(actor2.equips);
      this.clearParamPlus();
      this.recoverAll();
    }
    actorId() {
      return this._actorId;
    }
    actor() {
      return self.$dataActors[this._actorId];
    }
    name() {
      return this._name;
    }
    setName(name) {
      this._name = name;
    }
    nickname() {
      return this._nickname;
    }
    setNickname(nickname) {
      this._nickname = nickname;
    }
    profile() {
      return this._profile;
    }
    setProfile(profile) {
      this._profile = profile;
    }
    characterName() {
      return this._characterName;
    }
    characterIndex() {
      return this._characterIndex;
    }
    faceName() {
      return this._faceName;
    }
    faceIndex() {
      return this._faceIndex;
    }
    battlerName() {
      return this._battlerName;
    }
    clearStates() {
      super.clearStates();
      this._stateSteps = {};
    }
    eraseState(stateId) {
      super.eraseState(stateId);
      delete this._stateSteps[stateId];
    }
    resetStateCounts(stateId) {
      super.resetStateCounts(stateId);
      this._stateSteps[stateId] = self.$dataStates[stateId].stepsToRemove;
    }
    initImages() {
      const actor2 = this.actor();
      this._characterName = actor2.characterName;
      this._characterIndex = actor2.characterIndex;
      this._faceName = actor2.faceName;
      this._faceIndex = actor2.faceIndex;
      this._battlerName = actor2.battlerName;
    }
    expForLevel(level) {
      const c = this.currentClass();
      const basis = c.expParams[0];
      const extra = c.expParams[1];
      const acc_a = c.expParams[2];
      const acc_b = c.expParams[3];
      return Math.round(
        basis * Math.pow(level - 1, 0.9 + acc_a / 250) * level * (level + 1) / (6 + Math.pow(level, 2) / 50 / acc_b) + (level - 1) * extra
      );
    }
    initExp() {
      this._exp[this._classId] = this.currentLevelExp();
    }
    currentExp() {
      return this._exp[this._classId];
    }
    currentLevelExp() {
      return this.expForLevel(this._level);
    }
    nextLevelExp() {
      return this.expForLevel(this._level + 1);
    }
    nextRequiredExp() {
      return this.nextLevelExp() - this.currentExp();
    }
    maxLevel() {
      return this.actor().maxLevel;
    }
    isMaxLevel() {
      return this._level >= this.maxLevel();
    }
    initSkills() {
      this._skills = [];
      this.currentClass().learnings.forEach(function({ level, skillId }) {
        if (level <= this._level) {
          this.learnSkill(skillId);
        }
      }, this);
    }
    initEquips(equips) {
      const slots = this.equipSlots();
      const maxSlots = slots.length;
      this._equips = [];
      for (let i = 0; i < maxSlots; i++) {
        this._equips[i] = new Game_Item_default();
      }
      for (let j = 0; j < equips.length; j++) {
        if (j < maxSlots) {
          this._equips[j].setEquip(slots[j] === 1, equips[j]);
        }
      }
      this.releaseUnequippableItems(true);
      this.refresh();
    }
    equipSlots() {
      const slots = [];
      for (let i = 1; i < self.$dataSystem.equipTypes.length; i++) {
        slots.push(i);
      }
      if (slots.length >= 2 && this.isDualWield()) {
        slots[1] = 1;
      }
      return slots;
    }
    equips() {
      return this._equips.map((item2) => item2.object());
    }
    weapons() {
      return this.equips().filter((item2) => item2 && DataManager2.isWeapon(item2));
    }
    armors() {
      return this.equips().filter((item2) => item2 && DataManager2.isArmor(item2));
    }
    hasWeapon(weapon) {
      return this.weapons().contains(weapon);
    }
    hasArmor(armor) {
      return this.armors().contains(armor);
    }
    isEquipChangeOk(slotId) {
      return !this.isEquipTypeLocked(this.equipSlots()[slotId]) && !this.isEquipTypeSealed(this.equipSlots()[slotId]);
    }
    changeEquip(slotId, item2) {
      if (this.tradeItemWithParty(item2, this.equips()[slotId]) && (!item2 || this.equipSlots()[slotId] === item2.etypeId)) {
        this._equips[slotId].setObject(item2);
        this.refresh();
      }
    }
    forceChangeEquip(slotId, item2) {
      this._equips[slotId].setObject(item2);
      this.releaseUnequippableItems(true);
      this.refresh();
    }
    tradeItemWithParty(newItem, oldItem) {
      if (newItem && !self.$gameParty.hasItem(newItem)) {
        return false;
      } else {
        self.$gameParty.gainItem(oldItem, 1);
        self.$gameParty.loseItem(newItem, 1);
        return true;
      }
    }
    changeEquipById(etypeId, itemId) {
      const slotId = etypeId - 1;
      if (this.equipSlots()[slotId] === 1) {
        this.changeEquip(slotId, self.$dataWeapons[itemId]);
      } else {
        this.changeEquip(slotId, self.$dataArmors[itemId]);
      }
    }
    isEquipped(item2) {
      return this.equips().contains(item2);
    }
    discardEquip(item2) {
      const slotId = this.equips().indexOf(item2);
      if (slotId >= 0) {
        this._equips[slotId].setObject(null);
      }
    }
    releaseUnequippableItems(forcing) {
      for (; ; ) {
        const slots = this.equipSlots();
        const equips = this.equips();
        let changed = false;
        equips.forEach((item2, i) => {
          if (item2 && (!this.canEquip(item2) || item2.etypeId !== slots[i])) {
            if (!forcing) {
              this.tradeItemWithParty(null, item2);
            }
            this._equips[i].setObject(null);
            changed = true;
          }
        });
        if (!changed) {
          break;
        }
      }
    }
    clearEquipments() {
      const maxSlots = this.equipSlots().length;
      for (let i = 0; i < maxSlots; i++) {
        if (this.isEquipChangeOk(i)) {
          this.changeEquip(i, null);
        }
      }
    }
    optimizeEquipments() {
      const maxSlots = this.equipSlots().length;
      this.clearEquipments();
      for (let i = 0; i < maxSlots; i++) {
        if (this.isEquipChangeOk(i)) {
          this.changeEquip(i, this.bestEquipItem(i));
        }
      }
    }
    bestEquipItem(slotId) {
      const etypeId = this.equipSlots()[slotId];
      const items = self.$gameParty.equipItems().filter(function(item2) {
        return item2.etypeId === etypeId && this.canEquip(item2);
      }, this);
      let bestItem = null;
      let bestPerformance = -1e3;
      for (let i = 0; i < items.length; i++) {
        const performance2 = this.calcEquipItemPerformance(items[i]);
        if (performance2 > bestPerformance) {
          bestPerformance = performance2;
          bestItem = items[i];
        }
      }
      return bestItem;
    }
    calcEquipItemPerformance({ params: params2 }) {
      return params2.reduce((a2, b2) => a2 + b2);
    }
    isSkillWtypeOk({ requiredWtypeId1, requiredWtypeId2 }) {
      const wtypeId1 = requiredWtypeId1;
      const wtypeId2 = requiredWtypeId2;
      if (wtypeId1 === 0 && wtypeId2 === 0 || wtypeId1 > 0 && this.isWtypeEquipped(wtypeId1) || wtypeId2 > 0 && this.isWtypeEquipped(wtypeId2)) {
        return true;
      } else {
        return false;
      }
    }
    isWtypeEquipped(wtypeId) {
      return this.weapons().some((weapon) => weapon.wtypeId === wtypeId);
    }
    refresh() {
      this.releaseUnequippableItems(false);
      super.refresh();
    }
    isActor() {
      return true;
    }
    friendsUnit() {
      return self.$gameParty;
    }
    opponentsUnit() {
      return self.$gameTroop;
    }
    index() {
      return self.$gameParty.members().indexOf(this);
    }
    isBattleMember() {
      return self.$gameParty.battleMembers().contains(this);
    }
    isFormationChangeOk() {
      return true;
    }
    currentClass() {
      return self.$dataClasses[this._classId];
    }
    isClass(gameClass) {
      return gameClass && this._classId === gameClass.id;
    }
    skills() {
      const list = [];
      this._skills.concat(this.addedSkills()).forEach((id) => {
        if (!list.contains(self.$dataSkills[id])) {
          list.push(self.$dataSkills[id]);
        }
      });
      return list;
    }
    usableSkills() {
      return this.skills().filter(function(skill) {
        return this.canUse(skill);
      }, this);
    }
    traitObjects() {
      let objects = Game_Battler_default.prototype.traitObjects.call(this);
      objects = objects.concat([this.actor(), this.currentClass()]);
      const equips = this.equips();
      for (const item2 of equips) {
        if (item2) {
          objects.push(item2);
        }
      }
      return objects;
    }
    attackElements() {
      const set = Game_Battler_default.prototype.attackElements.call(this);
      if (this.hasNoWeapons() && !set.contains(this.bareHandsElementId())) {
        set.push(this.bareHandsElementId());
      }
      return set;
    }
    hasNoWeapons() {
      return this.weapons().length === 0;
    }
    bareHandsElementId() {
      return 1;
    }
    paramMax(paramId) {
      if (paramId === 0) {
        return 9999;
      }
      return Game_Battler_default.prototype.paramMax.call(this, paramId);
    }
    paramBase(paramId) {
      return this.currentClass().params[paramId][this._level];
    }
    paramPlus(paramId) {
      let value3 = Game_Battler_default.prototype.paramPlus.call(this, paramId);
      const equips = this.equips();
      for (const item2 of equips) {
        if (item2) {
          value3 += item2.params[paramId];
        }
      }
      return value3;
    }
    attackAnimationId1() {
      if (this.hasNoWeapons()) {
        return this.bareHandsAnimationId();
      } else {
        const weapons = this.weapons();
        return weapons[0] ? weapons[0].animationId : 0;
      }
    }
    attackAnimationId2() {
      const weapons = this.weapons();
      return weapons[1] ? weapons[1].animationId : 0;
    }
    bareHandsAnimationId() {
      return 1;
    }
    changeExp(exp, show) {
      this._exp[this._classId] = Math.max(exp, 0);
      const lastLevel = this._level;
      const lastSkills = this.skills();
      while (!this.isMaxLevel() && this.currentExp() >= this.nextLevelExp()) {
        this.levelUp();
      }
      while (this.currentExp() < this.currentLevelExp()) {
        this.levelDown();
      }
      if (show && this._level > lastLevel) {
        this.displayLevelUp(this.findNewSkills(lastSkills));
      }
      this.refresh();
    }
    levelUp() {
      this._level++;
      this.currentClass().learnings.forEach(function({ level, skillId }) {
        if (level === this._level) {
          this.learnSkill(skillId);
        }
      }, this);
    }
    levelDown() {
      this._level--;
    }
    findNewSkills(lastSkills) {
      const newSkills = this.skills();
      for (let i = 0; i < lastSkills.length; i++) {
        const index2 = newSkills.indexOf(lastSkills[i]);
        if (index2 >= 0) {
          newSkills.splice(index2, 1);
        }
      }
      return newSkills;
    }
    displayLevelUp(newSkills) {
      const text = TextManager_default.levelUp.format(
        this._name,
        TextManager_default.level,
        this._level
      );
      self.$gameMessage.newPage();
      self.$gameMessage.add(text);
      newSkills.forEach(({ name }) => {
        self.$gameMessage.add(TextManager_default.obtainSkill.format(name));
      });
    }
    gainExp(exp) {
      const newExp = this.currentExp() + Math.round(exp * this.finalExpRate());
      this.changeExp(newExp, this.shouldDisplayLevelUp());
    }
    finalExpRate() {
      return this.exr * (this.isBattleMember() ? 1 : this.benchMembersExpRate());
    }
    benchMembersExpRate() {
      return self.$dataSystem.optExtraExp ? 1 : 0;
    }
    shouldDisplayLevelUp() {
      return true;
    }
    changeLevel(level, show) {
      level = level.clamp(1, this.maxLevel());
      this.changeExp(this.expForLevel(level), show);
    }
    learnSkill(skillId) {
      if (!this.isLearnedSkill(skillId)) {
        this._skills.push(skillId);
        this._skills.sort((a2, b2) => a2 - b2);
      }
    }
    forgetSkill(skillId) {
      const index2 = this._skills.indexOf(skillId);
      if (index2 >= 0) {
        this._skills.splice(index2, 1);
      }
    }
    isLearnedSkill(skillId) {
      return this._skills.contains(skillId);
    }
    hasSkill(skillId) {
      return this.skills().contains(self.$dataSkills[skillId]);
    }
    changeClass(classId, keepExp) {
      if (keepExp) {
        this._exp[classId] = this.currentExp();
      }
      this._classId = classId;
      this.changeExp(this._exp[this._classId] || 0, false);
      this.refresh();
    }
    setCharacterImage(characterName, characterIndex) {
      this._characterName = characterName;
      this._characterIndex = characterIndex;
    }
    setFaceImage(faceName, faceIndex) {
      this._faceName = faceName;
      this._faceIndex = faceIndex;
    }
    setBattlerImage(battlerName) {
      this._battlerName = battlerName;
    }
    isSpriteVisible() {
      return self.$gameSystem.isSideView();
    }
    startAnimation(animationId, mirror, delay) {
      mirror = !mirror;
      super.startAnimation(animationId, mirror, delay);
    }
    performActionStart(action) {
      super.performActionStart(action);
    }
    performAction(action) {
      super.performAction(action);
      if (action.isAttack()) {
        this.performAttack();
      } else if (action.isGuard()) {
        this.requestMotion("guard");
      } else if (action.isMagicSkill()) {
        this.requestMotion("spell");
      } else if (action.isSkill()) {
        this.requestMotion("skill");
      } else if (action.isItem()) {
        this.requestMotion("item");
      }
    }
    performActionEnd() {
      super.performActionEnd();
    }
    performAttack() {
      const weapons = this.weapons();
      const wtypeId = weapons[0] ? weapons[0].wtypeId : 0;
      const attackMotion = self.$dataSystem.attackMotions[wtypeId];
      if (attackMotion) {
        if (attackMotion.type === 0) {
          this.requestMotion("thrust");
        } else if (attackMotion.type === 1) {
          this.requestMotion("swing");
        } else if (attackMotion.type === 2) {
          this.requestMotion("missile");
        }
        this.startWeaponAnimation(attackMotion.weaponImageId);
      }
    }
    performDamage() {
      super.performDamage();
      if (this.isSpriteVisible()) {
        this.requestMotion("damage");
      } else {
        self.$gameScreen.startShake(5, 5, 10);
      }
      SoundManager_default.playActorDamage();
    }
    performEvasion() {
      super.performEvasion();
      this.requestMotion("evade");
    }
    performMagicEvasion() {
      super.performMagicEvasion();
      this.requestMotion("evade");
    }
    performCounter() {
      super.performCounter();
      this.performAttack();
    }
    performCollapse() {
      super.performCollapse();
      if (self.$gameParty.inBattle()) {
        SoundManager_default.playActorCollapse();
      }
    }
    performVictory() {
      if (this.canMove()) {
        this.requestMotion("victory");
      }
    }
    performEscape() {
      if (this.canMove()) {
        this.requestMotion("escape");
      }
    }
    makeActionList() {
      const list = [];
      let action = new Game_Action_default(this);
      action.setAttack();
      list.push(action);
      this.usableSkills().forEach(function({ id }) {
        action = new Game_Action_default(this);
        action.setSkill(id);
        list.push(action);
      }, this);
      return list;
    }
    makeAutoBattleActions() {
      for (let i = 0; i < this.numActions(); i++) {
        const list = this.makeActionList();
        let maxValue = Number.MIN_VALUE;
        for (let j = 0; j < list.length; j++) {
          const value3 = list[j].evaluate();
          if (value3 > maxValue) {
            maxValue = value3;
            this.setAction(i, list[j]);
          }
        }
      }
      this.setActionState("waiting");
    }
    makeConfusionActions() {
      for (let i = 0; i < this.numActions(); i++) {
        this.action(i).setConfusion();
      }
      this.setActionState("waiting");
    }
    makeActions() {
      super.makeActions();
      if (this.numActions() > 0) {
        this.setActionState("undecided");
      } else {
        this.setActionState("waiting");
      }
      if (this.isAutoBattle()) {
        this.makeAutoBattleActions();
      } else if (this.isConfused()) {
        this.makeConfusionActions();
      }
    }
    onPlayerWalk() {
      this.clearResult();
      this.checkFloorEffect();
      if (self.$gamePlayer.isNormal()) {
        this.turnEndOnMap();
        this.states().forEach(function(state) {
          this.updateStateSteps(state);
        }, this);
        this.showAddedStates();
        this.showRemovedStates();
      }
    }
    updateStateSteps({ removeByWalking, id }) {
      if (removeByWalking) {
        if (this._stateSteps[id] > 0) {
          if (--this._stateSteps[id] === 0) {
            this.removeState(id);
          }
        }
      }
    }
    showAddedStates() {
      this.result().addedStateObjects().forEach(function({ message1 }) {
        if (message1) {
          self.$gameMessage.add(this._name + message1);
        }
      }, this);
    }
    showRemovedStates() {
      this.result().removedStateObjects().forEach(function({ message4 }) {
        if (message4) {
          self.$gameMessage.add(this._name + message4);
        }
      }, this);
    }
    stepsForTurn() {
      return 20;
    }
    turnEndOnMap() {
      if (self.$gameParty.steps() % this.stepsForTurn() === 0) {
        this.onTurnEnd();
        if (this.result().hpDamage > 0) {
          this.performMapDamage();
        }
      }
    }
    checkFloorEffect() {
      if (self.$gamePlayer.isOnDamageFloor()) {
        this.executeFloorDamage();
      }
    }
    executeFloorDamage() {
      let damage = Math.floor(this.basicFloorDamage() * this.fdr);
      damage = Math.min(damage, this.maxFloorDamage());
      this.gainHp(-damage);
      if (damage > 0) {
        this.performMapDamage();
      }
    }
    basicFloorDamage() {
      return 10;
    }
    maxFloorDamage() {
      return self.$dataSystem.optFloorDeath ? this.hp : Math.max(this.hp - 1, 0);
    }
    performMapDamage() {
      if (!self.$gameParty.inBattle()) {
        self.$gameScreen.startFlashForDamage();
      }
    }
    clearActions() {
      super.clearActions();
      this._actionInputIndex = 0;
    }
    inputtingAction() {
      return this.action(this._actionInputIndex);
    }
    selectNextCommand() {
      if (this._actionInputIndex < this.numActions() - 1) {
        this._actionInputIndex++;
        return true;
      } else {
        return false;
      }
    }
    selectPreviousCommand() {
      if (this._actionInputIndex > 0) {
        this._actionInputIndex--;
        return true;
      } else {
        return false;
      }
    }
    lastMenuSkill() {
      return this._lastMenuSkill.object();
    }
    setLastMenuSkill(skill) {
      this._lastMenuSkill.setObject(skill);
    }
    lastBattleSkill() {
      return this._lastBattleSkill.object();
    }
    setLastBattleSkill(skill) {
      this._lastBattleSkill.setObject(skill);
    }
    lastCommandSymbol() {
      return this._lastCommandSymbol;
    }
    setLastCommandSymbol(symbol) {
      this._lastCommandSymbol = symbol;
    }
    testEscape({ effects }) {
      return effects.some(
        (effect, index2, ar) => effect && effect.code === Game_Action_default.EFFECT_SPECIAL
      );
    }
    meetsUsableItemConditions(item2) {
      if (self.$gameParty.inBattle() && !BattleManager_default.canEscape() && this.testEscape(item2)) {
        return false;
      }
      return Game_BattlerBase_default.prototype.meetsUsableItemConditions.call(
        this,
        item2
      );
    }
  };
  var Game_Actor_default = Game_Actor;

  // src-www/js/rpg_objects/Game_Actors.js
  var Game_Actors = class {
    constructor(...args) {
      this.initialize(...args);
    }
    initialize() {
      this._data = [];
    }
    actor(actorId) {
      if (self.$dataActors[actorId]) {
        if (!this._data[actorId]) {
          this._data[actorId] = new Game_Actor_default(actorId);
        }
        return this._data[actorId];
      }
      return null;
    }
  };
  var Game_Actors_default = Game_Actors;

  // src-www/js/rpg_objects/Game_Unit.js
  var Game_Unit = class {
    constructor(...args) {
      this.initialize(...args);
    }
    initialize() {
      this._inBattle = false;
    }
    inBattle() {
      return this._inBattle;
    }
    members() {
      return [];
    }
    aliveMembers() {
      return this.members().filter((member) => member.isAlive());
    }
    deadMembers() {
      return this.members().filter((member) => member.isDead());
    }
    movableMembers() {
      return this.members().filter((member) => member.canMove());
    }
    clearActions() {
      return this.members().forEach((member) => member.clearActions());
    }
    agility() {
      const members = this.members();
      if (members.length === 0) {
        return 1;
      }
      const sum = members.reduce((r, { agi }) => r + agi, 0);
      return sum / members.length;
    }
    tgrSum() {
      return this.aliveMembers().reduce((r, { tgr }) => r + tgr, 0);
    }
    randomTarget() {
      let tgrRand = Math.random() * this.tgrSum();
      let target2 = null;
      this.aliveMembers().forEach((member) => {
        tgrRand -= member.tgr;
        if (tgrRand <= 0 && !target2) {
          target2 = member;
        }
      });
      return target2;
    }
    randomDeadTarget() {
      const members = this.deadMembers();
      if (members.length === 0) {
        return null;
      }
      return members[Math.floor(Math.random() * members.length)];
    }
    smoothTarget(index2) {
      if (index2 < 0) {
        index2 = 0;
      }
      const member = this.members()[index2];
      return member && member.isAlive() ? member : this.aliveMembers()[0];
    }
    smoothDeadTarget(index2) {
      if (index2 < 0) {
        index2 = 0;
      }
      const member = this.members()[index2];
      return member && member.isDead() ? member : this.deadMembers()[0];
    }
    clearResults() {
      this.members().forEach((member) => {
        member.clearResult();
      });
    }
    onBattleStart() {
      this.members().forEach((member) => {
        member.onBattleStart();
      });
      this._inBattle = true;
    }
    onBattleEnd() {
      this._inBattle = false;
      this.members().forEach((member) => {
        member.onBattleEnd();
      });
    }
    makeActions() {
      this.members().forEach((member) => {
        member.makeActions();
      });
    }
    select(activeMember) {
      this.members().forEach((member) => {
        if (member === activeMember) {
          member.select();
        } else {
          member.deselect();
        }
      });
    }
    isAllDead() {
      return this.aliveMembers().length === 0;
    }
    substituteBattler() {
      const members = this.members();
      for (let i = 0; i < members.length; i++) {
        if (members[i].isSubstitute()) {
          return members[i];
        }
      }
    }
  };
  var Game_Unit_default = Game_Unit;

  // src-www/js/rpg_objects/Game_Party.js
  var Game_Party = class extends Game_Unit_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
      this._gold = 0;
      this._steps = 0;
      this._lastItem = new Game_Item_default();
      this._menuActorId = 0;
      this._targetActorId = 0;
      this._actors = [];
      this.initAllItems();
    }
    initAllItems() {
      this._items = {};
      this._weapons = {};
      this._armors = {};
    }
    exists() {
      return this._actors.length > 0;
    }
    size() {
      return this.members().length;
    }
    isEmpty() {
      return this.size() === 0;
    }
    members() {
      return this.inBattle() ? this.battleMembers() : this.allMembers();
    }
    allMembers() {
      return this._actors.map((id) => self.$gameActors.actor(id));
    }
    battleMembers() {
      return this.allMembers().slice(0, this.maxBattleMembers()).filter((actor2) => actor2.isAppeared());
    }
    maxBattleMembers() {
      return 4;
    }
    leader() {
      return this.battleMembers()[0];
    }
    reviveBattleMembers() {
      this.battleMembers().forEach((actor2) => {
        if (actor2.isDead()) {
          actor2.setHp(1);
        }
      });
    }
    items() {
      const list = [];
      for (let id in this._items) {
        list.push(self.$dataItems[id]);
      }
      return list;
    }
    weapons() {
      const list = [];
      for (let id in this._weapons) {
        list.push(self.$dataWeapons[id]);
      }
      return list;
    }
    armors() {
      const list = [];
      for (let id in this._armors) {
        list.push(self.$dataArmors[id]);
      }
      return list;
    }
    equipItems() {
      return this.weapons().concat(this.armors());
    }
    allItems() {
      return this.items().concat(this.equipItems());
    }
    itemContainer(item2) {
      if (!item2) {
        return null;
      } else if (DataManager2.isItem(item2)) {
        return this._items;
      } else if (DataManager2.isWeapon(item2)) {
        return this._weapons;
      } else if (DataManager2.isArmor(item2)) {
        return this._armors;
      } else {
        return null;
      }
    }
    setupStartingMembers() {
      this._actors = [];
      self.$dataSystem.partyMembers.forEach(function(actorId) {
        if (self.$gameActors.actor(actorId)) {
          this._actors.push(actorId);
        }
      }, this);
    }
    name() {
      const numBattleMembers = this.battleMembers().length;
      if (numBattleMembers === 0) {
        return "";
      } else if (numBattleMembers === 1) {
        return this.leader().name();
      } else {
        return TextManager_default.partyName.format(this.leader().name());
      }
    }
    setupBattleTest() {
      this.setupBattleTestMembers();
      this.setupBattleTestItems();
    }
    setupBattleTestMembers() {
      self.$dataSystem.testBattlers.forEach(
        function({
          actorId,
          level,
          equips
        }) {
          const actor2 = self.$gameActors.actor(actorId);
          if (actor2) {
            actor2.changeLevel(level, false);
            actor2.initEquips(equips);
            actor2.recoverAll();
            this.addActor(actorId);
          }
        },
        this
      );
    }
    setupBattleTestItems() {
      self.$dataItems.forEach(function(item2) {
        if (item2 && item2.name.length > 0) {
          this.gainItem(item2, this.maxItems(item2));
        }
      }, this);
    }
    highestLevel() {
      return Math.max.apply(
        null,
        this.members().map(({ level }) => level)
      );
    }
    addActor(actorId) {
      if (!this._actors.contains(actorId)) {
        this._actors.push(actorId);
        self.$gamePlayer.refresh();
        self.$gameMap.requestRefresh();
      }
    }
    removeActor(actorId) {
      if (this._actors.contains(actorId)) {
        this._actors.splice(this._actors.indexOf(actorId), 1);
        self.$gamePlayer.refresh();
        self.$gameMap.requestRefresh();
      }
    }
    gold() {
      return this._gold;
    }
    gainGold(amount) {
      this._gold = (this._gold + amount).clamp(0, this.maxGold());
    }
    loseGold(amount) {
      this.gainGold(-amount);
    }
    maxGold() {
      return 99999999;
    }
    steps() {
      return this._steps;
    }
    increaseSteps() {
      this._steps++;
    }
    numItems(item2) {
      const container = this.itemContainer(item2);
      return container ? container[item2.id] || 0 : 0;
    }
    maxItems(item2) {
      return 99;
    }
    hasMaxItems(item2) {
      return this.numItems(item2) >= this.maxItems(item2);
    }
    hasItem(item2, includeEquip) {
      if (includeEquip === void 0) {
        includeEquip = false;
      }
      if (this.numItems(item2) > 0) {
        return true;
      } else if (includeEquip && this.isAnyMemberEquipped(item2)) {
        return true;
      } else {
        return false;
      }
    }
    isAnyMemberEquipped(item2) {
      return this.members().some((actor2) => actor2.equips().contains(item2));
    }
    gainItem(item2, amount, includeEquip) {
      const container = this.itemContainer(item2);
      if (container) {
        const lastNumber = this.numItems(item2);
        const newNumber = lastNumber + amount;
        container[item2.id] = newNumber.clamp(0, this.maxItems(item2));
        if (container[item2.id] === 0) {
          delete container[item2.id];
        }
        if (includeEquip && newNumber < 0) {
          this.discardMembersEquip(item2, -newNumber);
        }
        self.$gameMap.requestRefresh();
      }
    }
    discardMembersEquip(item2, amount) {
      let n = amount;
      this.members().forEach((actor2) => {
        while (n > 0 && actor2.isEquipped(item2)) {
          actor2.discardEquip(item2);
          n--;
        }
      });
    }
    loseItem(item2, amount, includeEquip) {
      this.gainItem(item2, -amount, includeEquip);
    }
    consumeItem(item2) {
      if (DataManager2.isItem(item2) && item2.consumable) {
        this.loseItem(item2, 1);
      }
    }
    canUse(item2) {
      return this.members().some((actor2) => actor2.canUse(item2));
    }
    canInput() {
      return this.members().some((actor2) => actor2.canInput());
    }
    isAllDead() {
      if (Game_Unit_default.prototype.isAllDead.call(this)) {
        return this.inBattle() || !this.isEmpty();
      } else {
        return false;
      }
    }
    onPlayerWalk() {
      this.members().forEach((actor2) => actor2.onPlayerWalk());
    }
    menuActor() {
      let actor2 = self.$gameActors.actor(this._menuActorId);
      if (!this.members().contains(actor2)) {
        actor2 = this.members()[0];
      }
      return actor2;
    }
    setMenuActor(actor2) {
      this._menuActorId = actor2.actorId();
    }
    makeMenuActorNext() {
      let index2 = this.members().indexOf(this.menuActor());
      if (index2 >= 0) {
        index2 = (index2 + 1) % this.members().length;
        this.setMenuActor(this.members()[index2]);
      } else {
        this.setMenuActor(this.members()[0]);
      }
    }
    makeMenuActorPrevious() {
      let index2 = this.members().indexOf(this.menuActor());
      if (index2 >= 0) {
        index2 = (index2 + this.members().length - 1) % this.members().length;
        this.setMenuActor(this.members()[index2]);
      } else {
        this.setMenuActor(this.members()[0]);
      }
    }
    targetActor() {
      let actor2 = self.$gameActors.actor(this._targetActorId);
      if (!this.members().contains(actor2)) {
        actor2 = this.members()[0];
      }
      return actor2;
    }
    setTargetActor(actor2) {
      this._targetActorId = actor2.actorId();
    }
    lastItem() {
      return this._lastItem.object();
    }
    setLastItem(item2) {
      this._lastItem.setObject(item2);
    }
    swapOrder(index1, index2) {
      const temp2 = this._actors[index1];
      this._actors[index1] = this._actors[index2];
      this._actors[index2] = temp2;
      self.$gamePlayer.refresh();
    }
    charactersForSavefile() {
      return this.battleMembers().map((actor2) => [
        actor2.characterName(),
        actor2.characterIndex()
      ]);
    }
    facesForSavefile() {
      return this.battleMembers().map((actor2) => [
        actor2.faceName(),
        actor2.faceIndex()
      ]);
    }
    partyAbility(abilityId) {
      return this.battleMembers().some((actor2) => actor2.partyAbility(abilityId));
    }
    hasEncounterHalf() {
      return this.partyAbility(Game_Party.ABILITY_ENCOUNTER_HALF);
    }
    hasEncounterNone() {
      return this.partyAbility(Game_Party.ABILITY_ENCOUNTER_NONE);
    }
    hasCancelSurprise() {
      return this.partyAbility(Game_Party.ABILITY_CANCEL_SURPRISE);
    }
    hasRaisePreemptive() {
      return this.partyAbility(Game_Party.ABILITY_RAISE_PREEMPTIVE);
    }
    hasGoldDouble() {
      return this.partyAbility(Game_Party.ABILITY_GOLD_DOUBLE);
    }
    hasDropItemDouble() {
      return this.partyAbility(Game_Party.ABILITY_DROP_ITEM_DOUBLE);
    }
    ratePreemptive(troopAgi) {
      let rate = this.agility() >= troopAgi ? 0.05 : 0.03;
      if (this.hasRaisePreemptive()) {
        rate *= 4;
      }
      return rate;
    }
    rateSurprise(troopAgi) {
      let rate = this.agility() >= troopAgi ? 0.03 : 0.05;
      if (this.hasCancelSurprise()) {
        rate = 0;
      }
      return rate;
    }
    performVictory() {
      this.members().forEach((actor2) => {
        actor2.performVictory();
      });
    }
    performEscape() {
      this.members().forEach((actor2) => {
        actor2.performEscape();
      });
    }
    removeBattleStates() {
      this.members().forEach((actor2) => {
        actor2.removeBattleStates();
      });
    }
    requestMotionRefresh() {
      this.members().forEach((actor2) => {
        actor2.requestMotionRefresh();
      });
    }
  };
  Game_Party.ABILITY_ENCOUNTER_HALF = 0;
  Game_Party.ABILITY_ENCOUNTER_NONE = 1;
  Game_Party.ABILITY_CANCEL_SURPRISE = 2;
  Game_Party.ABILITY_RAISE_PREEMPTIVE = 3;
  Game_Party.ABILITY_GOLD_DOUBLE = 4;
  Game_Party.ABILITY_DROP_ITEM_DOUBLE = 5;
  var Game_Party_default = Game_Party;

  // src-www/js/rpg_objects/Game_Enemy.js
  var Game_Enemy = class extends Game_Battler_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(enemyId, x, y) {
      super.initialize();
      this.setup(enemyId, x, y);
    }
    initMembers() {
      super.initMembers();
      this._enemyId = 0;
      this._letter = "";
      this._plural = false;
      this._screenX = 0;
      this._screenY = 0;
    }
    setup(enemyId, x, y) {
      this._enemyId = enemyId;
      this._screenX = x;
      this._screenY = y;
      this.recoverAll();
    }
    isEnemy() {
      return true;
    }
    friendsUnit() {
      return self.$gameTroop;
    }
    opponentsUnit() {
      return self.$gameParty;
    }
    index() {
      return self.$gameTroop.members().indexOf(this);
    }
    isBattleMember() {
      return this.index() >= 0;
    }
    enemyId() {
      return this._enemyId;
    }
    enemy() {
      return self.$dataEnemies[this._enemyId];
    }
    traitObjects() {
      return Game_Battler_default.prototype.traitObjects.call(this).concat(this.enemy());
    }
    paramBase(paramId) {
      return this.enemy().params[paramId];
    }
    exp() {
      return this.enemy().exp;
    }
    gold() {
      return this.enemy().gold;
    }
    makeDropItems() {
      return this.enemy().dropItems.reduce((r, { kind, denominator, dataId }) => {
        if (kind > 0 && Math.random() * denominator < this.dropItemRate()) {
          return r.concat(this.itemObject(kind, dataId));
        } else {
          return r;
        }
      }, []);
    }
    dropItemRate() {
      return self.$gameParty.hasDropItemDouble() ? 2 : 1;
    }
    itemObject(kind, dataId) {
      if (kind === 1) {
        return self.$dataItems[dataId];
      } else if (kind === 2) {
        return self.$dataWeapons[dataId];
      } else if (kind === 3) {
        return self.$dataArmors[dataId];
      } else {
        return null;
      }
    }
    isSpriteVisible() {
      return true;
    }
    screenX() {
      return this._screenX;
    }
    screenY() {
      return this._screenY;
    }
    battlerName() {
      return this.enemy().battlerName;
    }
    battlerHue() {
      return this.enemy().battlerHue;
    }
    originalName() {
      return this.enemy().name;
    }
    name() {
      return this.originalName() + (this._plural ? this._letter : "");
    }
    isLetterEmpty() {
      return this._letter === "";
    }
    setLetter(letter) {
      this._letter = letter;
    }
    setPlural(plural) {
      this._plural = plural;
    }
    performActionStart(action) {
      super.performActionStart(action);
      this.requestEffect("whiten");
    }
    performAction(action) {
      super.performAction(action);
    }
    performActionEnd() {
      super.performActionEnd();
    }
    performDamage() {
      super.performDamage();
      SoundManager_default.playEnemyDamage();
      this.requestEffect("blink");
    }
    performCollapse() {
      super.performCollapse();
      switch (this.collapseType()) {
        case 0:
          this.requestEffect("collapse");
          SoundManager_default.playEnemyCollapse();
          break;
        case 1:
          this.requestEffect("bossCollapse");
          SoundManager_default.playBossCollapse1();
          break;
        case 2:
          this.requestEffect("instantCollapse");
          break;
      }
    }
    transform(enemyId) {
      const name = this.originalName();
      this._enemyId = enemyId;
      if (this.originalName() !== name) {
        this._letter = "";
        this._plural = false;
      }
      this.refresh();
      if (this.numActions() > 0) {
        this.makeActions();
      }
    }
    meetsCondition({ conditionParam1, conditionParam2, conditionType }) {
      const param1 = conditionParam1;
      const param2 = conditionParam2;
      switch (conditionType) {
        case 1:
          return this.meetsTurnCondition(param1, param2);
        case 2:
          return this.meetsHpCondition(param1, param2);
        case 3:
          return this.meetsMpCondition(param1, param2);
        case 4:
          return this.meetsStateCondition(param1);
        case 5:
          return this.meetsPartyLevelCondition(param1);
        case 6:
          return this.meetsSwitchCondition(param1);
        default:
          return true;
      }
    }
    meetsTurnCondition(param1, param2) {
      const n = self.$gameTroop.turnCount();
      if (param2 === 0) {
        return n === param1;
      } else {
        return n > 0 && n >= param1 && n % param2 === param1 % param2;
      }
    }
    meetsHpCondition(param1, param2) {
      return this.hpRate() >= param1 && this.hpRate() <= param2;
    }
    meetsMpCondition(param1, param2) {
      return this.mpRate() >= param1 && this.mpRate() <= param2;
    }
    meetsStateCondition(param) {
      return this.isStateAffected(param);
    }
    meetsPartyLevelCondition(param) {
      return self.$gameParty.highestLevel() >= param;
    }
    meetsSwitchCondition(param) {
      return self.$gameSwitches.value(param);
    }
    isActionValid(action) {
      return this.meetsCondition(action) && this.canUse(self.$dataSkills[action.skillId]);
    }
    selectAction(actionList, ratingZero) {
      const sum = actionList.reduce(
        (r, { rating }) => r + rating - ratingZero,
        0
      );
      if (sum > 0) {
        let value3 = Math.randomInt(sum);
        for (const action of actionList) {
          value3 -= action.rating - ratingZero;
          if (value3 < 0) {
            return action;
          }
        }
      } else {
        return null;
      }
    }
    selectAllActions(actionList) {
      const ratingMax = Math.max.apply(
        null,
        actionList.map(({ rating }) => rating)
      );
      const ratingZero = ratingMax - 3;
      actionList = actionList.filter(({ rating }) => rating > ratingZero);
      for (let i = 0; i < this.numActions(); i++) {
        this.action(i).setEnemyAction(this.selectAction(actionList, ratingZero));
      }
    }
    makeActions() {
      super.makeActions();
      if (this.numActions() > 0) {
        const actionList = this.enemy().actions.filter(function(a2) {
          return this.isActionValid(a2);
        }, this);
        if (actionList.length > 0) {
          this.selectAllActions(actionList);
        }
      }
      this.setActionState("waiting");
    }
  };
  var Game_Enemy_default = Game_Enemy;

  // src-www/js/rpg_objects/Game_CharacterBase.js
  var Game_CharacterBase = class {
    constructor(...args) {
      this.initialize(...args);
    }
    initialize() {
      this.initMembers();
    }
    initMembers() {
      this._x = 0;
      this._y = 0;
      this._realX = 0;
      this._realY = 0;
      this._moveSpeed = 4;
      this._moveFrequency = 6;
      this._opacity = 255;
      this._blendMode = 0;
      this._direction = 2;
      this._pattern = 1;
      this._priorityType = 1;
      this._tileId = 0;
      this._characterName = "";
      this._characterIndex = 0;
      this._isObjectCharacter = false;
      this._walkAnime = true;
      this._stepAnime = false;
      this._directionFix = false;
      this._through = false;
      this._transparent = false;
      this._bushDepth = 0;
      this._animationId = 0;
      this._balloonId = 0;
      this._animationPlaying = false;
      this._balloonPlaying = false;
      this._animationCount = 0;
      this._stopCount = 0;
      this._jumpCount = 0;
      this._jumpPeak = 0;
      this._movementSuccess = true;
    }
    pos(x, y) {
      return this._x === x && this._y === y;
    }
    posNt(x, y) {
      return this.pos(x, y) && !this.isThrough();
    }
    moveSpeed() {
      return this._moveSpeed;
    }
    setMoveSpeed(moveSpeed) {
      this._moveSpeed = moveSpeed;
    }
    moveFrequency() {
      return this._moveFrequency;
    }
    setMoveFrequency(moveFrequency) {
      this._moveFrequency = moveFrequency;
    }
    opacity() {
      return this._opacity;
    }
    setOpacity(opacity) {
      this._opacity = opacity;
    }
    blendMode() {
      return this._blendMode;
    }
    setBlendMode(blendMode) {
      this._blendMode = blendMode;
    }
    isNormalPriority() {
      return this._priorityType === 1;
    }
    setPriorityType(priorityType) {
      this._priorityType = priorityType;
    }
    isMoving() {
      return this._realX !== this._x || this._realY !== this._y;
    }
    isJumping() {
      return this._jumpCount > 0;
    }
    jumpHeight() {
      return (this._jumpPeak * this._jumpPeak - Math.pow(Math.abs(this._jumpCount - this._jumpPeak), 2)) / 2;
    }
    isStopping() {
      return !this.isMoving() && !this.isJumping();
    }
    checkStop(threshold) {
      return this._stopCount > threshold;
    }
    resetStopCount() {
      this._stopCount = 0;
    }
    realMoveSpeed() {
      return this._moveSpeed + (this.isDashing() ? 1 : 0);
    }
    distancePerFrame() {
      return Math.pow(2, this.realMoveSpeed()) / 256;
    }
    isDashing() {
      return false;
    }
    isDebugThrough() {
      return false;
    }
    straighten() {
      if (this.hasWalkAnime() || this.hasStepAnime()) {
        this._pattern = 1;
      }
      this._animationCount = 0;
    }
    reverseDir(d) {
      return 10 - d;
    }
    canPass(x, y, d) {
      const x2 = self.$gameMap.roundXWithDirection(x, d);
      const y2 = self.$gameMap.roundYWithDirection(y, d);
      if (!self.$gameMap.isValid(x2, y2)) {
        return false;
      }
      if (this.isThrough() || this.isDebugThrough()) {
        return true;
      }
      if (!this.isMapPassable(x, y, d)) {
        return false;
      }
      if (this.isCollidedWithCharacters(x2, y2)) {
        return false;
      }
      return true;
    }
    canPassDiagonally(x, y, horz, vert) {
      const x2 = self.$gameMap.roundXWithDirection(x, horz);
      const y2 = self.$gameMap.roundYWithDirection(y, vert);
      if (this.canPass(x, y, vert) && this.canPass(x, y2, horz)) {
        return true;
      }
      if (this.canPass(x, y, horz) && this.canPass(x2, y, vert)) {
        return true;
      }
      return false;
    }
    isMapPassable(x, y, d) {
      const x2 = self.$gameMap.roundXWithDirection(x, d);
      const y2 = self.$gameMap.roundYWithDirection(y, d);
      const d2 = this.reverseDir(d);
      return self.$gameMap.isPassable(x, y, d) && self.$gameMap.isPassable(x2, y2, d2);
    }
    isCollidedWithCharacters(x, y) {
      return this.isCollidedWithEvents(x, y) || this.isCollidedWithVehicles(x, y);
    }
    isCollidedWithEvents(x, y) {
      const events = self.$gameMap.eventsXyNt(x, y);
      return events.some((event) => event.isNormalPriority());
    }
    isCollidedWithVehicles(x, y) {
      return self.$gameMap.boat().posNt(x, y) || self.$gameMap.ship().posNt(x, y);
    }
    setPosition(x, y) {
      this._x = Math.round(x);
      this._y = Math.round(y);
      this._realX = x;
      this._realY = y;
    }
    copyPosition(character2) {
      this._x = character2._x;
      this._y = character2._y;
      this._realX = character2._realX;
      this._realY = character2._realY;
      this._direction = character2._direction;
    }
    locate(x, y) {
      this.setPosition(x, y);
      this.straighten();
      this.refreshBushDepth();
    }
    direction() {
      return this._direction;
    }
    setDirection(d) {
      if (!this.isDirectionFixed() && d) {
        this._direction = d;
      }
      this.resetStopCount();
    }
    isTile() {
      return this._tileId > 0 && this._priorityType === 0;
    }
    isObjectCharacter() {
      return this._isObjectCharacter;
    }
    shiftY() {
      return this.isObjectCharacter() ? 0 : 6;
    }
    scrolledX() {
      return self.$gameMap.adjustX(this._realX);
    }
    scrolledY() {
      return self.$gameMap.adjustY(this._realY);
    }
    screenX() {
      const tw = self.$gameMap.tileWidth();
      return Math.round(this.scrolledX() * tw + tw / 2);
    }
    screenY() {
      const th = self.$gameMap.tileHeight();
      return Math.round(
        this.scrolledY() * th + th - this.shiftY() - this.jumpHeight()
      );
    }
    screenZ() {
      return this._priorityType * 2 + 1;
    }
    isNearTheScreen() {
      const gw = Graphics_default.width;
      const gh = Graphics_default.height;
      const tw = self.$gameMap.tileWidth();
      const th = self.$gameMap.tileHeight();
      const px = this.scrolledX() * tw + tw / 2 - gw / 2;
      const py = this.scrolledY() * th + th / 2 - gh / 2;
      return px >= -gw && px <= gw && py >= -gh && py <= gh;
    }
    update() {
      if (this.isStopping()) {
        this.updateStop();
      }
      if (this.isJumping()) {
        this.updateJump();
      } else if (this.isMoving()) {
        this.updateMove();
      }
      this.updateAnimation();
    }
    updateStop() {
      this._stopCount++;
    }
    updateJump() {
      this._jumpCount--;
      this._realX = (this._realX * this._jumpCount + this._x) / (this._jumpCount + 1);
      this._realY = (this._realY * this._jumpCount + this._y) / (this._jumpCount + 1);
      this.refreshBushDepth();
      if (this._jumpCount === 0) {
        this._realX = this._x = self.$gameMap.roundX(this._x);
        this._realY = this._y = self.$gameMap.roundY(this._y);
      }
    }
    updateMove() {
      if (this._x < this._realX) {
        this._realX = Math.max(this._realX - this.distancePerFrame(), this._x);
      }
      if (this._x > this._realX) {
        this._realX = Math.min(this._realX + this.distancePerFrame(), this._x);
      }
      if (this._y < this._realY) {
        this._realY = Math.max(this._realY - this.distancePerFrame(), this._y);
      }
      if (this._y > this._realY) {
        this._realY = Math.min(this._realY + this.distancePerFrame(), this._y);
      }
      if (!this.isMoving()) {
        this.refreshBushDepth();
      }
    }
    updateAnimation() {
      this.updateAnimationCount();
      if (this._animationCount >= this.animationWait()) {
        this.updatePattern();
        this._animationCount = 0;
      }
    }
    animationWait() {
      return (9 - this.realMoveSpeed()) * 3;
    }
    updateAnimationCount() {
      if (this.isMoving() && this.hasWalkAnime()) {
        this._animationCount += 1.5;
      } else if (this.hasStepAnime() || !this.isOriginalPattern()) {
        this._animationCount++;
      }
    }
    updatePattern() {
      if (!this.hasStepAnime() && this._stopCount > 0) {
        this.resetPattern();
      } else {
        this._pattern = (this._pattern + 1) % this.maxPattern();
      }
    }
    maxPattern() {
      return 4;
    }
    pattern() {
      return this._pattern < 3 ? this._pattern : 1;
    }
    setPattern(pattern) {
      this._pattern = pattern;
    }
    isOriginalPattern() {
      return this.pattern() === 1;
    }
    resetPattern() {
      this.setPattern(1);
    }
    refreshBushDepth() {
      if (this.isNormalPriority() && !this.isObjectCharacter() && this.isOnBush() && !this.isJumping()) {
        if (!this.isMoving()) {
          this._bushDepth = 12;
        }
      } else {
        this._bushDepth = 0;
      }
    }
    isOnLadder() {
      return self.$gameMap.isLadder(this._x, this._y);
    }
    isOnBush() {
      return self.$gameMap.isBush(this._x, this._y);
    }
    terrainTag() {
      return self.$gameMap.terrainTag(this._x, this._y);
    }
    regionId() {
      return self.$gameMap.regionId(this._x, this._y);
    }
    increaseSteps() {
      if (this.isOnLadder()) {
        this.setDirection(8);
      }
      this.resetStopCount();
      this.refreshBushDepth();
    }
    tileId() {
      return this._tileId;
    }
    characterName() {
      return this._characterName;
    }
    characterIndex() {
      return this._characterIndex;
    }
    setImage(characterName, characterIndex) {
      this._tileId = 0;
      this._characterName = characterName;
      this._characterIndex = characterIndex;
      this._isObjectCharacter = ImageManager_default.isObjectCharacter(characterName);
    }
    setTileImage(tileId) {
      this._tileId = tileId;
      this._characterName = "";
      this._characterIndex = 0;
      this._isObjectCharacter = true;
    }
    checkEventTriggerTouchFront(d) {
      const x2 = self.$gameMap.roundXWithDirection(this._x, d);
      const y2 = self.$gameMap.roundYWithDirection(this._y, d);
      this.checkEventTriggerTouch(x2, y2);
    }
    checkEventTriggerTouch(x, y) {
      return false;
    }
    isMovementSucceeded(x, y) {
      return this._movementSuccess;
    }
    setMovementSuccess(success) {
      this._movementSuccess = success;
    }
    moveStraight(d) {
      this.setMovementSuccess(this.canPass(this._x, this._y, d));
      if (this.isMovementSucceeded()) {
        this.setDirection(d);
        this._x = self.$gameMap.roundXWithDirection(this._x, d);
        this._y = self.$gameMap.roundYWithDirection(this._y, d);
        this._realX = self.$gameMap.xWithDirection(this._x, this.reverseDir(d));
        this._realY = self.$gameMap.yWithDirection(this._y, this.reverseDir(d));
        this.increaseSteps();
      } else {
        this.setDirection(d);
        this.checkEventTriggerTouchFront(d);
      }
    }
    moveDiagonally(horz, vert) {
      this.setMovementSuccess(
        this.canPassDiagonally(this._x, this._y, horz, vert)
      );
      if (this.isMovementSucceeded()) {
        this._x = self.$gameMap.roundXWithDirection(this._x, horz);
        this._y = self.$gameMap.roundYWithDirection(this._y, vert);
        this._realX = self.$gameMap.xWithDirection(
          this._x,
          this.reverseDir(horz)
        );
        this._realY = self.$gameMap.yWithDirection(
          this._y,
          this.reverseDir(vert)
        );
        this.increaseSteps();
      }
      if (this._direction === this.reverseDir(horz)) {
        this.setDirection(horz);
      }
      if (this._direction === this.reverseDir(vert)) {
        this.setDirection(vert);
      }
    }
    jump(xPlus, yPlus) {
      if (Math.abs(xPlus) > Math.abs(yPlus)) {
        if (xPlus !== 0) {
          this.setDirection(xPlus < 0 ? 4 : 6);
        }
      } else {
        if (yPlus !== 0) {
          this.setDirection(yPlus < 0 ? 8 : 2);
        }
      }
      this._x += xPlus;
      this._y += yPlus;
      const distance = Math.round(Math.sqrt(xPlus * xPlus + yPlus * yPlus));
      this._jumpPeak = 10 + distance - this._moveSpeed;
      this._jumpCount = this._jumpPeak * 2;
      this.resetStopCount();
      this.straighten();
    }
    hasWalkAnime() {
      return this._walkAnime;
    }
    setWalkAnime(walkAnime) {
      this._walkAnime = walkAnime;
    }
    hasStepAnime() {
      return this._stepAnime;
    }
    setStepAnime(stepAnime) {
      this._stepAnime = stepAnime;
    }
    isDirectionFixed() {
      return this._directionFix;
    }
    setDirectionFix(directionFix) {
      this._directionFix = directionFix;
    }
    isThrough() {
      return this._through;
    }
    setThrough(through) {
      this._through = through;
    }
    isTransparent() {
      return this._transparent;
    }
    bushDepth() {
      return this._bushDepth;
    }
    setTransparent(transparent) {
      this._transparent = transparent;
    }
    requestAnimation(animationId) {
      this._animationId = animationId;
    }
    requestBalloon(balloonId) {
      this._balloonId = balloonId;
    }
    animationId() {
      return this._animationId;
    }
    balloonId() {
      return this._balloonId;
    }
    startAnimation() {
      this._animationId = 0;
      this._animationPlaying = true;
    }
    startBalloon() {
      this._balloonId = 0;
      this._balloonPlaying = true;
    }
    isAnimationPlaying() {
      return this._animationId > 0 || this._animationPlaying;
    }
    isBalloonPlaying() {
      return this._balloonId > 0 || this._balloonPlaying;
    }
    endAnimation() {
      this._animationPlaying = false;
    }
    endBalloon() {
      this._balloonPlaying = false;
    }
  };
  Object.defineProperties(Game_CharacterBase.prototype, {
    x: {
      get() {
        return this._x;
      },
      configurable: true
    },
    y: {
      get() {
        return this._y;
      },
      configurable: true
    }
  });
  var Game_CharacterBase_default = Game_CharacterBase;

  // src-www/js/rpg_objects/Game_Character.js
  var _Game_Character = class extends Game_CharacterBase_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
    }
    initMembers() {
      super.initMembers();
      this._moveRouteForcing = false;
      this._moveRoute = null;
      this._moveRouteIndex = 0;
      this._originalMoveRoute = null;
      this._originalMoveRouteIndex = 0;
      this._waitCount = 0;
      this._callerEventInfo = null;
    }
    memorizeMoveRoute() {
      this._originalMoveRoute = this._moveRoute;
      this._originalMoveRouteIndex = this._moveRouteIndex;
    }
    restoreMoveRoute() {
      this._moveRoute = this._originalMoveRoute;
      this._moveRouteIndex = this._originalMoveRouteIndex - 1;
      this._originalMoveRoute = null;
      this._callerEventInfo = null;
    }
    isMoveRouteForcing() {
      return this._moveRouteForcing;
    }
    setMoveRoute(moveRoute) {
      this._moveRoute = moveRoute;
      this._moveRouteIndex = 0;
      this._moveRouteForcing = false;
    }
    forceMoveRoute(moveRoute) {
      if (!this._originalMoveRoute) {
        this.memorizeMoveRoute();
      }
      this._moveRoute = moveRoute;
      this._moveRouteIndex = 0;
      this._moveRouteForcing = true;
      this._waitCount = 0;
    }
    setCallerEventInfo(callerEventInfo) {
      this._callerEventInfo = callerEventInfo;
    }
    updateStop() {
      super.updateStop();
      if (this._moveRouteForcing) {
        this.updateRoutineMove();
      }
    }
    updateRoutineMove() {
      if (this._waitCount > 0) {
        this._waitCount--;
      } else {
        this.setMovementSuccess(true);
        const command2 = this._moveRoute.list[this._moveRouteIndex];
        if (command2) {
          this.processMoveCommand(command2);
          this.advanceMoveRouteIndex();
        }
      }
    }
    processMoveCommand(command) {
      const gc = _Game_Character;
      const params = command.parameters;
      switch (command.code) {
        case gc.ROUTE_END:
          this.processRouteEnd();
          break;
        case gc.ROUTE_MOVE_DOWN:
          this.moveStraight(2);
          break;
        case gc.ROUTE_MOVE_LEFT:
          this.moveStraight(4);
          break;
        case gc.ROUTE_MOVE_RIGHT:
          this.moveStraight(6);
          break;
        case gc.ROUTE_MOVE_UP:
          this.moveStraight(8);
          break;
        case gc.ROUTE_MOVE_LOWER_L:
          this.moveDiagonally(4, 2);
          break;
        case gc.ROUTE_MOVE_LOWER_R:
          this.moveDiagonally(6, 2);
          break;
        case gc.ROUTE_MOVE_UPPER_L:
          this.moveDiagonally(4, 8);
          break;
        case gc.ROUTE_MOVE_UPPER_R:
          this.moveDiagonally(6, 8);
          break;
        case gc.ROUTE_MOVE_RANDOM:
          this.moveRandom();
          break;
        case gc.ROUTE_MOVE_TOWARD:
          this.moveTowardPlayer();
          break;
        case gc.ROUTE_MOVE_AWAY:
          this.moveAwayFromPlayer();
          break;
        case gc.ROUTE_MOVE_FORWARD:
          this.moveForward();
          break;
        case gc.ROUTE_MOVE_BACKWARD:
          this.moveBackward();
          break;
        case gc.ROUTE_JUMP:
          this.jump(params[0], params[1]);
          break;
        case gc.ROUTE_WAIT:
          this._waitCount = params[0] - 1;
          break;
        case gc.ROUTE_TURN_DOWN:
          this.setDirection(2);
          break;
        case gc.ROUTE_TURN_LEFT:
          this.setDirection(4);
          break;
        case gc.ROUTE_TURN_RIGHT:
          this.setDirection(6);
          break;
        case gc.ROUTE_TURN_UP:
          this.setDirection(8);
          break;
        case gc.ROUTE_TURN_90D_R:
          this.turnRight90();
          break;
        case gc.ROUTE_TURN_90D_L:
          this.turnLeft90();
          break;
        case gc.ROUTE_TURN_180D:
          this.turn180();
          break;
        case gc.ROUTE_TURN_90D_R_L:
          this.turnRightOrLeft90();
          break;
        case gc.ROUTE_TURN_RANDOM:
          this.turnRandom();
          break;
        case gc.ROUTE_TURN_TOWARD:
          this.turnTowardPlayer();
          break;
        case gc.ROUTE_TURN_AWAY:
          this.turnAwayFromPlayer();
          break;
        case gc.ROUTE_SWITCH_ON:
          self.$gameSwitches.setValue(params[0], true);
          break;
        case gc.ROUTE_SWITCH_OFF:
          self.$gameSwitches.setValue(params[0], false);
          break;
        case gc.ROUTE_CHANGE_SPEED:
          this.setMoveSpeed(params[0]);
          break;
        case gc.ROUTE_CHANGE_FREQ:
          this.setMoveFrequency(params[0]);
          break;
        case gc.ROUTE_WALK_ANIME_ON:
          this.setWalkAnime(true);
          break;
        case gc.ROUTE_WALK_ANIME_OFF:
          this.setWalkAnime(false);
          break;
        case gc.ROUTE_STEP_ANIME_ON:
          this.setStepAnime(true);
          break;
        case gc.ROUTE_STEP_ANIME_OFF:
          this.setStepAnime(false);
          break;
        case gc.ROUTE_DIR_FIX_ON:
          this.setDirectionFix(true);
          break;
        case gc.ROUTE_DIR_FIX_OFF:
          this.setDirectionFix(false);
          break;
        case gc.ROUTE_THROUGH_ON:
          this.setThrough(true);
          break;
        case gc.ROUTE_THROUGH_OFF:
          this.setThrough(false);
          break;
        case gc.ROUTE_TRANSPARENT_ON:
          this.setTransparent(true);
          break;
        case gc.ROUTE_TRANSPARENT_OFF:
          this.setTransparent(false);
          break;
        case gc.ROUTE_CHANGE_IMAGE:
          this.setImage(params[0], params[1]);
          break;
        case gc.ROUTE_CHANGE_OPACITY:
          this.setOpacity(params[0]);
          break;
        case gc.ROUTE_CHANGE_BLEND_MODE:
          this.setBlendMode(params[0]);
          break;
        case gc.ROUTE_PLAY_SE:
          AudioManager_default.playSe(params[0]);
          break;
        case gc.ROUTE_SCRIPT:
          try {
            eval(params[0]);
          } catch (error) {
            if (this._callerEventInfo) {
              for (let key in this._callerEventInfo) {
                error[key] = this._callerEventInfo[key];
              }
              error.line += this._moveRouteIndex + 1;
              error.eventCommand = "set_route_script";
              error.content = command.parameters[0];
            } else {
              error.eventType = "map_event";
              error.mapId = this._mapId;
              error.mapEventId = this._eventId;
              error.page = this._pageIndex + 1;
              error.line = this._moveRouteIndex + 1;
              error.eventCommand = "auto_route_script";
              error.content = command.parameters[0];
            }
            throw error;
          }
          break;
      }
    }
    deltaXFrom(x) {
      return self.$gameMap.deltaX(this.x, x);
    }
    deltaYFrom(y) {
      return self.$gameMap.deltaY(this.y, y);
    }
    moveRandom() {
      const d = 2 + Math.randomInt(4) * 2;
      if (this.canPass(this.x, this.y, d)) {
        this.moveStraight(d);
      }
    }
    moveTowardCharacter({ x, y }) {
      const sx = this.deltaXFrom(x);
      const sy = this.deltaYFrom(y);
      if (Math.abs(sx) > Math.abs(sy)) {
        this.moveStraight(sx > 0 ? 4 : 6);
        if (!this.isMovementSucceeded() && sy !== 0) {
          this.moveStraight(sy > 0 ? 8 : 2);
        }
      } else if (sy !== 0) {
        this.moveStraight(sy > 0 ? 8 : 2);
        if (!this.isMovementSucceeded() && sx !== 0) {
          this.moveStraight(sx > 0 ? 4 : 6);
        }
      }
    }
    moveAwayFromCharacter({ x, y }) {
      const sx = this.deltaXFrom(x);
      const sy = this.deltaYFrom(y);
      if (Math.abs(sx) > Math.abs(sy)) {
        this.moveStraight(sx > 0 ? 6 : 4);
        if (!this.isMovementSucceeded() && sy !== 0) {
          this.moveStraight(sy > 0 ? 2 : 8);
        }
      } else if (sy !== 0) {
        this.moveStraight(sy > 0 ? 2 : 8);
        if (!this.isMovementSucceeded() && sx !== 0) {
          this.moveStraight(sx > 0 ? 6 : 4);
        }
      }
    }
    turnTowardCharacter({ x, y }) {
      const sx = this.deltaXFrom(x);
      const sy = this.deltaYFrom(y);
      if (Math.abs(sx) > Math.abs(sy)) {
        this.setDirection(sx > 0 ? 4 : 6);
      } else if (sy !== 0) {
        this.setDirection(sy > 0 ? 8 : 2);
      }
    }
    turnAwayFromCharacter({ x, y }) {
      const sx = this.deltaXFrom(x);
      const sy = this.deltaYFrom(y);
      if (Math.abs(sx) > Math.abs(sy)) {
        this.setDirection(sx > 0 ? 6 : 4);
      } else if (sy !== 0) {
        this.setDirection(sy > 0 ? 2 : 8);
      }
    }
    turnTowardPlayer() {
      this.turnTowardCharacter(self.$gamePlayer);
    }
    turnAwayFromPlayer() {
      this.turnAwayFromCharacter(self.$gamePlayer);
    }
    moveTowardPlayer() {
      this.moveTowardCharacter(self.$gamePlayer);
    }
    moveAwayFromPlayer() {
      this.moveAwayFromCharacter(self.$gamePlayer);
    }
    moveForward() {
      this.moveStraight(this.direction());
    }
    moveBackward() {
      const lastDirectionFix = this.isDirectionFixed();
      this.setDirectionFix(true);
      this.moveStraight(this.reverseDir(this.direction()));
      this.setDirectionFix(lastDirectionFix);
    }
    processRouteEnd() {
      if (this._moveRoute.repeat) {
        this._moveRouteIndex = -1;
      } else if (this._moveRouteForcing) {
        this._moveRouteForcing = false;
        this.restoreMoveRoute();
      }
    }
    advanceMoveRouteIndex() {
      const moveRoute = this._moveRoute;
      if (moveRoute && (this.isMovementSucceeded() || moveRoute.skippable)) {
        const numCommands = moveRoute.list.length - 1;
        this._moveRouteIndex++;
        if (moveRoute.repeat && this._moveRouteIndex >= numCommands) {
          this._moveRouteIndex = 0;
        }
      }
    }
    turnRight90() {
      switch (this.direction()) {
        case 2:
          this.setDirection(4);
          break;
        case 4:
          this.setDirection(8);
          break;
        case 6:
          this.setDirection(2);
          break;
        case 8:
          this.setDirection(6);
          break;
      }
    }
    turnLeft90() {
      switch (this.direction()) {
        case 2:
          this.setDirection(6);
          break;
        case 4:
          this.setDirection(2);
          break;
        case 6:
          this.setDirection(8);
          break;
        case 8:
          this.setDirection(4);
          break;
      }
    }
    turn180() {
      this.setDirection(this.reverseDir(this.direction()));
    }
    turnRightOrLeft90() {
      switch (Math.randomInt(2)) {
        case 0:
          this.turnRight90();
          break;
        case 1:
          this.turnLeft90();
          break;
      }
    }
    turnRandom() {
      this.setDirection(2 + Math.randomInt(4) * 2);
    }
    swap(character2) {
      const newX = character2.x;
      const newY = character2.y;
      character2.locate(this.x, this.y);
      this.locate(newX, newY);
    }
    findDirectionTo(goalX, goalY) {
      const searchLimit = this.searchLimit();
      const mapWidth = self.$gameMap.width();
      const nodeList = [];
      const openList = [];
      const closedList = [];
      const start = {};
      let best = start;
      if (this.x === goalX && this.y === goalY) {
        return 0;
      }
      start.parent = null;
      start.x = this.x;
      start.y = this.y;
      start.g = 0;
      start.f = self.$gameMap.distance(start.x, start.y, goalX, goalY);
      nodeList.push(start);
      openList.push(start.y * mapWidth + start.x);
      while (nodeList.length > 0) {
        let bestIndex = 0;
        for (let i = 0; i < nodeList.length; i++) {
          if (nodeList[i].f < nodeList[bestIndex].f) {
            bestIndex = i;
          }
        }
        const current = nodeList[bestIndex];
        const x1 = current.x;
        const y1 = current.y;
        const pos1 = y1 * mapWidth + x1;
        const g1 = current.g;
        nodeList.splice(bestIndex, 1);
        openList.splice(openList.indexOf(pos1), 1);
        closedList.push(pos1);
        if (current.x === goalX && current.y === goalY) {
          best = current;
          break;
        }
        if (g1 >= searchLimit) {
          continue;
        }
        for (let j = 0; j < 4; j++) {
          const direction = 2 + j * 2;
          const x2 = self.$gameMap.roundXWithDirection(x1, direction);
          const y2 = self.$gameMap.roundYWithDirection(y1, direction);
          const pos2 = y2 * mapWidth + x2;
          if (closedList.contains(pos2)) {
            continue;
          }
          if (!this.canPass(x1, y1, direction)) {
            continue;
          }
          const g2 = g1 + 1;
          const index2 = openList.indexOf(pos2);
          if (index2 < 0 || g2 < nodeList[index2].g) {
            let neighbor;
            if (index2 >= 0) {
              neighbor = nodeList[index2];
            } else {
              neighbor = {};
              nodeList.push(neighbor);
              openList.push(pos2);
            }
            neighbor.parent = current;
            neighbor.x = x2;
            neighbor.y = y2;
            neighbor.g = g2;
            neighbor.f = g2 + self.$gameMap.distance(x2, y2, goalX, goalY);
            if (!best || neighbor.f - neighbor.g < best.f - best.g) {
              best = neighbor;
            }
          }
        }
      }
      let node = best;
      while (node.parent && node.parent !== start) {
        node = node.parent;
      }
      const deltaX1 = self.$gameMap.deltaX(node.x, start.x);
      const deltaY1 = self.$gameMap.deltaY(node.y, start.y);
      if (deltaY1 > 0) {
        return 2;
      } else if (deltaX1 < 0) {
        return 4;
      } else if (deltaX1 > 0) {
        return 6;
      } else if (deltaY1 < 0) {
        return 8;
      }
      const deltaX2 = this.deltaXFrom(goalX);
      const deltaY2 = this.deltaYFrom(goalY);
      if (Math.abs(deltaX2) > Math.abs(deltaY2)) {
        return deltaX2 > 0 ? 4 : 6;
      } else if (deltaY2 !== 0) {
        return deltaY2 > 0 ? 8 : 2;
      }
      return 0;
    }
    searchLimit() {
      return 12;
    }
  };
  _Game_Character.ROUTE_END = 0;
  _Game_Character.ROUTE_MOVE_DOWN = 1;
  _Game_Character.ROUTE_MOVE_LEFT = 2;
  _Game_Character.ROUTE_MOVE_RIGHT = 3;
  _Game_Character.ROUTE_MOVE_UP = 4;
  _Game_Character.ROUTE_MOVE_LOWER_L = 5;
  _Game_Character.ROUTE_MOVE_LOWER_R = 6;
  _Game_Character.ROUTE_MOVE_UPPER_L = 7;
  _Game_Character.ROUTE_MOVE_UPPER_R = 8;
  _Game_Character.ROUTE_MOVE_RANDOM = 9;
  _Game_Character.ROUTE_MOVE_TOWARD = 10;
  _Game_Character.ROUTE_MOVE_AWAY = 11;
  _Game_Character.ROUTE_MOVE_FORWARD = 12;
  _Game_Character.ROUTE_MOVE_BACKWARD = 13;
  _Game_Character.ROUTE_JUMP = 14;
  _Game_Character.ROUTE_WAIT = 15;
  _Game_Character.ROUTE_TURN_DOWN = 16;
  _Game_Character.ROUTE_TURN_LEFT = 17;
  _Game_Character.ROUTE_TURN_RIGHT = 18;
  _Game_Character.ROUTE_TURN_UP = 19;
  _Game_Character.ROUTE_TURN_90D_R = 20;
  _Game_Character.ROUTE_TURN_90D_L = 21;
  _Game_Character.ROUTE_TURN_180D = 22;
  _Game_Character.ROUTE_TURN_90D_R_L = 23;
  _Game_Character.ROUTE_TURN_RANDOM = 24;
  _Game_Character.ROUTE_TURN_TOWARD = 25;
  _Game_Character.ROUTE_TURN_AWAY = 26;
  _Game_Character.ROUTE_SWITCH_ON = 27;
  _Game_Character.ROUTE_SWITCH_OFF = 28;
  _Game_Character.ROUTE_CHANGE_SPEED = 29;
  _Game_Character.ROUTE_CHANGE_FREQ = 30;
  _Game_Character.ROUTE_WALK_ANIME_ON = 31;
  _Game_Character.ROUTE_WALK_ANIME_OFF = 32;
  _Game_Character.ROUTE_STEP_ANIME_ON = 33;
  _Game_Character.ROUTE_STEP_ANIME_OFF = 34;
  _Game_Character.ROUTE_DIR_FIX_ON = 35;
  _Game_Character.ROUTE_DIR_FIX_OFF = 36;
  _Game_Character.ROUTE_THROUGH_ON = 37;
  _Game_Character.ROUTE_THROUGH_OFF = 38;
  _Game_Character.ROUTE_TRANSPARENT_ON = 39;
  _Game_Character.ROUTE_TRANSPARENT_OFF = 40;
  _Game_Character.ROUTE_CHANGE_IMAGE = 41;
  _Game_Character.ROUTE_CHANGE_OPACITY = 42;
  _Game_Character.ROUTE_CHANGE_BLEND_MODE = 43;
  _Game_Character.ROUTE_PLAY_SE = 44;
  _Game_Character.ROUTE_SCRIPT = 45;
  var Game_Character_default = _Game_Character;

  // src-www/js/rpg_windows/Window_ShopCommand.js
  var Window_ShopCommand = class extends Window_HorzCommand_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(width, purchaseOnly) {
      this._windowWidth = width;
      this._purchaseOnly = purchaseOnly;
      super.initialize(0, 0);
    }
    windowWidth() {
      return this._windowWidth;
    }
    maxCols() {
      return 3;
    }
    makeCommandList() {
      this.addCommand(TextManager_default.buy, "buy");
      this.addCommand(TextManager_default.sell, "sell", !this._purchaseOnly);
      this.addCommand(TextManager_default.cancel, "cancel");
    }
  };
  var Window_ShopCommand_default = Window_ShopCommand;

  // src-www/js/rpg_windows/Window_ShopBuy.js
  var Window_ShopBuy = class extends Window_Selectable_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(x, y, height, shopGoods) {
      const width = this.windowWidth();
      super.initialize(x, y, width, height);
      this._shopGoods = shopGoods;
      this._money = 0;
      this.refresh();
      this.select(0);
    }
    windowWidth() {
      return 456;
    }
    maxItems() {
      return this._data ? this._data.length : 1;
    }
    item() {
      return this._data[this.index()];
    }
    setMoney(money) {
      this._money = money;
      this.refresh();
    }
    isCurrentItemEnabled() {
      return this.isEnabled(this._data[this.index()]);
    }
    price(item2) {
      return this._price[this._data.indexOf(item2)] || 0;
    }
    isEnabled(item2) {
      return item2 && this.price(item2) <= this._money && !self.$gameParty.hasMaxItems(item2);
    }
    refresh() {
      this.makeItemList();
      this.createContents();
      this.drawAllItems();
    }
    makeItemList() {
      this._data = [];
      this._price = [];
      this._shopGoods.forEach(function(goods) {
        let item2 = null;
        switch (goods[0]) {
          case 0:
            item2 = self.$dataItems[goods[1]];
            break;
          case 1:
            item2 = self.$dataWeapons[goods[1]];
            break;
          case 2:
            item2 = self.$dataArmors[goods[1]];
            break;
        }
        if (item2) {
          this._data.push(item2);
          this._price.push(goods[2] === 0 ? item2.price : goods[3]);
        }
      }, this);
    }
    drawItem(index2) {
      const item2 = this._data[index2];
      const rect = this.itemRect(index2);
      const priceWidth = 96;
      rect.width -= this.textPadding();
      this.changePaintOpacity(this.isEnabled(item2));
      this.drawItemName(item2, rect.x, rect.y, rect.width - priceWidth);
      this.drawText(
        this.price(item2),
        rect.x + rect.width - priceWidth,
        rect.y,
        priceWidth,
        "right"
      );
      this.changePaintOpacity(true);
    }
    setStatusWindow(statusWindow) {
      this._statusWindow = statusWindow;
      this.callUpdateHelp();
    }
    updateHelp() {
      this.setHelpWindowItem(this.item());
      if (this._statusWindow) {
        this._statusWindow.setItem(this.item());
      }
    }
  };
  var Window_ShopBuy_default = Window_ShopBuy;

  // src-www/js/rpg_windows/Window_ShopSell.js
  var Window_ShopSell = class extends Window_ItemList_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(x, y, width, height) {
      super.initialize(x, y, width, height);
    }
    isEnabled(item2) {
      return item2 && item2.price > 0;
    }
  };
  var Window_ShopSell_default = Window_ShopSell;

  // src-www/js/rpg_windows/Window_ShopNumber.js
  var Window_ShopNumber = class extends Window_Selectable_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(x, y, height) {
      const width = this.windowWidth();
      super.initialize(x, y, width, height);
      this._item = null;
      this._max = 1;
      this._price = 0;
      this._number = 1;
      this._currencyUnit = TextManager_default.currencyUnit;
      this.createButtons();
    }
    windowWidth() {
      return 456;
    }
    number() {
      return this._number;
    }
    setup(item2, max, price) {
      this._item = item2;
      this._max = Math.floor(max);
      this._price = price;
      this._number = 1;
      this.placeButtons();
      this.updateButtonsVisiblity();
      this.refresh();
    }
    setCurrencyUnit(currencyUnit) {
      this._currencyUnit = currencyUnit;
      this.refresh();
    }
    createButtons() {
      const bitmap = ImageManager_default.loadSystem("ButtonSet");
      const buttonWidth = 48;
      const buttonHeight = 48;
      this._buttons = [];
      for (let i = 0; i < 5; i++) {
        const button = new Sprite_Button_default();
        const x = buttonWidth * i;
        const w = buttonWidth * (i === 4 ? 2 : 1);
        button.bitmap = bitmap;
        button.setColdFrame(x, 0, w, buttonHeight);
        button.setHotFrame(x, buttonHeight, w, buttonHeight);
        button.visible = false;
        this._buttons.push(button);
        this.addChild(button);
      }
      this._buttons[0].setClickHandler(this.onButtonDown2.bind(this));
      this._buttons[1].setClickHandler(this.onButtonDown.bind(this));
      this._buttons[2].setClickHandler(this.onButtonUp.bind(this));
      this._buttons[3].setClickHandler(this.onButtonUp2.bind(this));
      this._buttons[4].setClickHandler(this.onButtonOk.bind(this));
    }
    placeButtons() {
      const numButtons = this._buttons.length;
      const spacing = 16;
      let totalWidth = -spacing;
      for (let i = 0; i < numButtons; i++) {
        totalWidth += this._buttons[i].width + spacing;
      }
      let x = (this.width - totalWidth) / 2;
      for (let j = 0; j < numButtons; j++) {
        const button = this._buttons[j];
        button.x = x;
        button.y = this.buttonY();
        x += button.width + spacing;
      }
    }
    updateButtonsVisiblity() {
      if (TouchInput_default.date > Input_default.date) {
        this.showButtons();
      } else {
        this.hideButtons();
      }
    }
    showButtons() {
      for (let i = 0; i < this._buttons.length; i++) {
        this._buttons[i].visible = true;
      }
    }
    hideButtons() {
      for (let i = 0; i < this._buttons.length; i++) {
        this._buttons[i].visible = false;
      }
    }
    refresh() {
      this.contents.clear();
      this.drawItemName(this._item, 0, this.itemY());
      this.drawMultiplicationSign();
      this.drawNumber();
      this.drawTotalPrice();
    }
    drawMultiplicationSign() {
      const sign3 = "\xD7";
      const width = this.textWidth(sign3);
      const x = this.cursorX() - width * 2;
      const y = this.itemY();
      this.resetTextColor();
      this.drawText(sign3, x, y, width);
    }
    drawNumber() {
      const x = this.cursorX();
      const y = this.itemY();
      const width = this.cursorWidth() - this.textPadding();
      this.resetTextColor();
      this.drawText(this._number, x, y, width, "right");
    }
    drawTotalPrice() {
      const total = this._price * this._number;
      const width = this.contentsWidth() - this.textPadding();
      this.drawCurrencyValue(total, this._currencyUnit, 0, this.priceY(), width);
    }
    itemY() {
      return Math.round(this.contentsHeight() / 2 - this.lineHeight() * 1.5);
    }
    priceY() {
      return Math.round(this.contentsHeight() / 2 + this.lineHeight() / 2);
    }
    buttonY() {
      return Math.round(this.priceY() + this.lineHeight() * 2.5);
    }
    cursorWidth() {
      const digitWidth = this.textWidth("0");
      return this.maxDigits() * digitWidth + this.textPadding() * 2;
    }
    cursorX() {
      return this.contentsWidth() - this.cursorWidth() - this.textPadding();
    }
    maxDigits() {
      return 2;
    }
    update() {
      super.update();
      this.processNumberChange();
    }
    isOkTriggered() {
      return Input_default.isTriggered("ok");
    }
    playOkSound() {
    }
    processNumberChange() {
      if (this.isOpenAndActive()) {
        if (Input_default.isRepeated("right")) {
          this.changeNumber(1);
        }
        if (Input_default.isRepeated("left")) {
          this.changeNumber(-1);
        }
        if (Input_default.isRepeated("up")) {
          this.changeNumber(10);
        }
        if (Input_default.isRepeated("down")) {
          this.changeNumber(-10);
        }
      }
    }
    changeNumber(amount) {
      const lastNumber = this._number;
      this._number = (this._number + amount).clamp(1, this._max);
      if (this._number !== lastNumber) {
        SoundManager_default.playCursor();
        this.refresh();
      }
    }
    updateCursor() {
      this.setCursorRect(
        this.cursorX(),
        this.itemY(),
        this.cursorWidth(),
        this.lineHeight()
      );
    }
    onButtonUp() {
      this.changeNumber(1);
    }
    onButtonUp2() {
      this.changeNumber(10);
    }
    onButtonDown() {
      this.changeNumber(-1);
    }
    onButtonDown2() {
      this.changeNumber(-10);
    }
    onButtonOk() {
      this.processOk();
    }
  };
  var Window_ShopNumber_default = Window_ShopNumber;

  // src-www/js/rpg_windows/Window_ShopStatus.js
  var Window_ShopStatus = class extends Window_Base_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(x, y, width, height) {
      super.initialize(x, y, width, height);
      this._item = null;
      this._pageIndex = 0;
      this.refresh();
    }
    refresh() {
      this.contents.clear();
      if (this._item) {
        const x = this.textPadding();
        this.drawPossession(x, 0);
        if (this.isEquipItem()) {
          this.drawEquipInfo(x, this.lineHeight() * 2);
        }
      }
    }
    setItem(item2) {
      this._item = item2;
      this.refresh();
    }
    isEquipItem() {
      return DataManager2.isWeapon(this._item) || DataManager2.isArmor(this._item);
    }
    drawPossession(x, y) {
      const width = this.contents.width - this.textPadding() - x;
      const possessionWidth = this.textWidth("0000");
      this.changeTextColor(this.systemColor());
      this.drawText(TextManager_default.possession, x, y, width - possessionWidth);
      this.resetTextColor();
      this.drawText(self.$gameParty.numItems(this._item), x, y, width, "right");
    }
    drawEquipInfo(x, y) {
      const members = this.statusMembers();
      for (let i = 0; i < members.length; i++) {
        this.drawActorEquipInfo(x, y + this.lineHeight() * (i * 2.4), members[i]);
      }
    }
    statusMembers() {
      const start = this._pageIndex * this.pageSize();
      const end = start + this.pageSize();
      return self.$gameParty.members().slice(start, end);
    }
    pageSize() {
      return 4;
    }
    maxPages() {
      return Math.floor(
        (self.$gameParty.size() + this.pageSize() - 1) / this.pageSize()
      );
    }
    drawActorEquipInfo(x, y, actor2) {
      const enabled = actor2.canEquip(this._item);
      this.changePaintOpacity(enabled);
      this.resetTextColor();
      this.drawText(actor2.name(), x, y, 168);
      const item1 = this.currentEquippedItem(actor2, this._item.etypeId);
      if (enabled) {
        this.drawActorParamChange(x, y, actor2, item1);
      }
      this.drawItemName(item1, x, y + this.lineHeight());
      this.changePaintOpacity(true);
    }
    drawActorParamChange(x, y, actor2, item1) {
      const width = this.contents.width - this.textPadding() - x;
      const paramId = this.paramId();
      const change = this._item.params[paramId] - (item1 ? item1.params[paramId] : 0);
      this.changeTextColor(this.paramchangeTextColor(change));
      this.drawText((change > 0 ? "+" : "") + change, x, y, width, "right");
    }
    paramId() {
      return DataManager2.isWeapon(this._item) ? 2 : 3;
    }
    currentEquippedItem(actor2, etypeId) {
      const list = [];
      const equips = actor2.equips();
      const slots = actor2.equipSlots();
      for (let i = 0; i < slots.length; i++) {
        if (slots[i] === etypeId) {
          list.push(equips[i]);
        }
      }
      const paramId = this.paramId();
      let worstParam = Number.MAX_VALUE;
      let worstItem = null;
      for (let j = 0; j < list.length; j++) {
        if (list[j] && list[j].params[paramId] < worstParam) {
          worstParam = list[j].params[paramId];
          worstItem = list[j];
        }
      }
      return worstItem;
    }
    update() {
      super.update();
      this.updatePage();
    }
    updatePage() {
      if (this.isPageChangeEnabled() && this.isPageChangeRequested()) {
        this.changePage();
      }
    }
    isPageChangeEnabled() {
      return this.visible && this.maxPages() >= 2;
    }
    isPageChangeRequested() {
      if (Input_default.isTriggered("shift")) {
        return true;
      }
      if (TouchInput_default.isTriggered() && this.isTouchedInsideFrame()) {
        return true;
      }
      return false;
    }
    isTouchedInsideFrame() {
      const x = this.canvasToLocalX(TouchInput_default.x);
      const y = this.canvasToLocalY(TouchInput_default.y);
      return x >= 0 && y >= 0 && x < this.width && y < this.height;
    }
    changePage() {
      this._pageIndex = (this._pageIndex + 1) % this.maxPages();
      this.refresh();
      SoundManager_default.playCursor();
    }
  };
  var Window_ShopStatus_default = Window_ShopStatus;

  // src-www/js/rpg_scenes/Scene_Shop.js
  var Scene_Shop = class extends Scene_MenuBase_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
    }
    prepare(goods, purchaseOnly) {
      this._goods = goods;
      this._purchaseOnly = purchaseOnly;
      this._item = null;
    }
    create() {
      super.create();
      this.createHelpWindow();
      this.createGoldWindow();
      this.createCommandWindow();
      this.createDummyWindow();
      this.createNumberWindow();
      this.createStatusWindow();
      this.createBuyWindow();
      this.createCategoryWindow();
      this.createSellWindow();
    }
    createGoldWindow() {
      this._goldWindow = new Window_Gold_default(0, this._helpWindow.height);
      this._goldWindow.x = Graphics_default.boxWidth - this._goldWindow.width;
      this.addWindow(this._goldWindow);
    }
    createCommandWindow() {
      this._commandWindow = new Window_ShopCommand_default(
        this._goldWindow.x,
        this._purchaseOnly
      );
      this._commandWindow.y = this._helpWindow.height;
      this._commandWindow.setHandler("buy", this.commandBuy.bind(this));
      this._commandWindow.setHandler("sell", this.commandSell.bind(this));
      this._commandWindow.setHandler("cancel", this.popScene.bind(this));
      this.addWindow(this._commandWindow);
    }
    createDummyWindow() {
      const wy = this._commandWindow.y + this._commandWindow.height;
      const wh = Graphics_default.boxHeight - wy;
      this._dummyWindow = new Window_Base_default(0, wy, Graphics_default.boxWidth, wh);
      this.addWindow(this._dummyWindow);
    }
    createNumberWindow() {
      const wy = this._dummyWindow.y;
      const wh = this._dummyWindow.height;
      this._numberWindow = new Window_ShopNumber_default(0, wy, wh);
      this._numberWindow.hide();
      this._numberWindow.setHandler("ok", this.onNumberOk.bind(this));
      this._numberWindow.setHandler("cancel", this.onNumberCancel.bind(this));
      this.addWindow(this._numberWindow);
    }
    createStatusWindow() {
      const wx = this._numberWindow.width;
      const wy = this._dummyWindow.y;
      const ww = Graphics_default.boxWidth - wx;
      const wh = this._dummyWindow.height;
      this._statusWindow = new Window_ShopStatus_default(wx, wy, ww, wh);
      this._statusWindow.hide();
      this.addWindow(this._statusWindow);
    }
    createBuyWindow() {
      const wy = this._dummyWindow.y;
      const wh = this._dummyWindow.height;
      this._buyWindow = new Window_ShopBuy_default(0, wy, wh, this._goods);
      this._buyWindow.setHelpWindow(this._helpWindow);
      this._buyWindow.setStatusWindow(this._statusWindow);
      this._buyWindow.hide();
      this._buyWindow.setHandler("ok", this.onBuyOk.bind(this));
      this._buyWindow.setHandler("cancel", this.onBuyCancel.bind(this));
      this.addWindow(this._buyWindow);
    }
    createCategoryWindow() {
      this._categoryWindow = new Window_ItemCategory_default();
      this._categoryWindow.setHelpWindow(this._helpWindow);
      this._categoryWindow.y = this._dummyWindow.y;
      this._categoryWindow.hide();
      this._categoryWindow.deactivate();
      this._categoryWindow.setHandler("ok", this.onCategoryOk.bind(this));
      this._categoryWindow.setHandler("cancel", this.onCategoryCancel.bind(this));
      this.addWindow(this._categoryWindow);
    }
    createSellWindow() {
      const wy = this._categoryWindow.y + this._categoryWindow.height;
      const wh = Graphics_default.boxHeight - wy;
      this._sellWindow = new Window_ShopSell_default(0, wy, Graphics_default.boxWidth, wh);
      this._sellWindow.setHelpWindow(this._helpWindow);
      this._sellWindow.hide();
      this._sellWindow.setHandler("ok", this.onSellOk.bind(this));
      this._sellWindow.setHandler("cancel", this.onSellCancel.bind(this));
      this._categoryWindow.setItemWindow(this._sellWindow);
      this.addWindow(this._sellWindow);
    }
    activateBuyWindow() {
      this._buyWindow.setMoney(this.money());
      this._buyWindow.show();
      this._buyWindow.activate();
      this._statusWindow.show();
    }
    activateSellWindow() {
      this._categoryWindow.show();
      this._sellWindow.refresh();
      this._sellWindow.show();
      this._sellWindow.activate();
      this._statusWindow.hide();
    }
    commandBuy() {
      this._dummyWindow.hide();
      this.activateBuyWindow();
    }
    commandSell() {
      this._dummyWindow.hide();
      this._categoryWindow.show();
      this._categoryWindow.activate();
      this._sellWindow.show();
      this._sellWindow.deselect();
      this._sellWindow.refresh();
    }
    onBuyOk() {
      this._item = this._buyWindow.item();
      this._buyWindow.hide();
      this._numberWindow.setup(this._item, this.maxBuy(), this.buyingPrice());
      this._numberWindow.setCurrencyUnit(this.currencyUnit());
      this._numberWindow.show();
      this._numberWindow.activate();
    }
    onBuyCancel() {
      this._commandWindow.activate();
      this._dummyWindow.show();
      this._buyWindow.hide();
      this._statusWindow.hide();
      this._statusWindow.setItem(null);
      this._helpWindow.clear();
    }
    onCategoryOk() {
      this.activateSellWindow();
      this._sellWindow.select(0);
    }
    onCategoryCancel() {
      this._commandWindow.activate();
      this._dummyWindow.show();
      this._categoryWindow.hide();
      this._sellWindow.hide();
    }
    onSellOk() {
      this._item = this._sellWindow.item();
      this._categoryWindow.hide();
      this._sellWindow.hide();
      this._numberWindow.setup(this._item, this.maxSell(), this.sellingPrice());
      this._numberWindow.setCurrencyUnit(this.currencyUnit());
      this._numberWindow.show();
      this._numberWindow.activate();
      this._statusWindow.setItem(this._item);
      this._statusWindow.show();
    }
    onSellCancel() {
      this._sellWindow.deselect();
      this._categoryWindow.activate();
      this._statusWindow.setItem(null);
      this._helpWindow.clear();
    }
    onNumberOk() {
      SoundManager_default.playShop();
      switch (this._commandWindow.currentSymbol()) {
        case "buy":
          this.doBuy(this._numberWindow.number());
          break;
        case "sell":
          this.doSell(this._numberWindow.number());
          break;
      }
      this.endNumberInput();
      this._goldWindow.refresh();
      this._statusWindow.refresh();
    }
    onNumberCancel() {
      SoundManager_default.playCancel();
      this.endNumberInput();
    }
    doBuy(number) {
      self.$gameParty.loseGold(number * this.buyingPrice());
      self.$gameParty.gainItem(this._item, number);
    }
    doSell(number) {
      self.$gameParty.gainGold(number * this.sellingPrice());
      self.$gameParty.loseItem(this._item, number);
    }
    endNumberInput() {
      this._numberWindow.hide();
      switch (this._commandWindow.currentSymbol()) {
        case "buy":
          this.activateBuyWindow();
          break;
        case "sell":
          this.activateSellWindow();
          break;
      }
    }
    maxBuy() {
      const max = self.$gameParty.maxItems(this._item) - self.$gameParty.numItems(this._item);
      const price = this.buyingPrice();
      if (price > 0) {
        return Math.min(max, Math.floor(this.money() / price));
      } else {
        return max;
      }
    }
    maxSell() {
      return self.$gameParty.numItems(this._item);
    }
    money() {
      return this._goldWindow.value();
    }
    currencyUnit() {
      return this._goldWindow.currencyUnit();
    }
    buyingPrice() {
      return this._buyWindow.price(this._item);
    }
    sellingPrice() {
      return Math.floor(this._item.price / 2);
    }
  };
  var Scene_Shop_default = Scene_Shop;

  // src-www/js/rpg_windows/Window_NameEdit.js
  var Window_NameEdit = class extends Window_Base_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(actor2, maxLength) {
      const width = this.windowWidth();
      const height = this.windowHeight();
      const x = (Graphics_default.boxWidth - width) / 2;
      const y = (Graphics_default.boxHeight - (height + this.fittingHeight(9) + 8)) / 2;
      super.initialize(x, y, width, height);
      this._actor = actor2;
      this._name = actor2.name().slice(0, this._maxLength);
      this._index = this._name.length;
      this._maxLength = maxLength;
      this._defaultName = this._name;
      this.deactivate();
      this.refresh();
      ImageManager_default.reserveFace(actor2.faceName());
    }
    windowWidth() {
      return 480;
    }
    windowHeight() {
      return this.fittingHeight(4);
    }
    name() {
      return this._name;
    }
    restoreDefault() {
      this._name = this._defaultName;
      this._index = this._name.length;
      this.refresh();
      return this._name.length > 0;
    }
    add(ch) {
      if (this._index < this._maxLength) {
        this._name += ch;
        this._index++;
        this.refresh();
        return true;
      } else {
        return false;
      }
    }
    back() {
      if (this._index > 0) {
        this._index--;
        this._name = this._name.slice(0, this._index);
        this.refresh();
        return true;
      } else {
        return false;
      }
    }
    faceWidth() {
      return 144;
    }
    charWidth() {
      const text = self.$gameSystem.isJapanese() ? "\uFF21" : "A";
      return this.textWidth(text);
    }
    left() {
      const nameCenter = (this.contentsWidth() + this.faceWidth()) / 2;
      const nameWidth = (this._maxLength + 1) * this.charWidth();
      return Math.min(
        nameCenter - nameWidth / 2,
        this.contentsWidth() - nameWidth
      );
    }
    itemRect(index2) {
      return {
        x: this.left() + index2 * this.charWidth(),
        y: 54,
        width: this.charWidth(),
        height: this.lineHeight()
      };
    }
    underlineRect(index2) {
      const rect = this.itemRect(index2);
      rect.x++;
      rect.y += rect.height - 4;
      rect.width -= 2;
      rect.height = 2;
      return rect;
    }
    underlineColor() {
      return this.normalColor();
    }
    drawUnderline(index2) {
      const rect = this.underlineRect(index2);
      const color2 = this.underlineColor();
      this.contents.paintOpacity = 48;
      this.contents.fillRect(rect.x, rect.y, rect.width, rect.height, color2);
      this.contents.paintOpacity = 255;
    }
    drawChar(index2) {
      const rect = this.itemRect(index2);
      this.resetTextColor();
      this.drawText(this._name[index2] || "", rect.x, rect.y);
    }
    refresh() {
      this.contents.clear();
      this.drawActorFace(this._actor, 0, 0);
      for (let i = 0; i < this._maxLength; i++) {
        this.drawUnderline(i);
      }
      for (let j = 0; j < this._name.length; j++) {
        this.drawChar(j);
      }
      const rect = this.itemRect(this._index);
      this.setCursorRect(rect.x, rect.y, rect.width, rect.height);
    }
  };
  var Window_NameEdit_default = Window_NameEdit;

  // src-www/js/rpg_windows/Window_NameInput.js
  var Window_NameInput = class extends Window_Selectable_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(editWindow) {
      const x = editWindow.x;
      const y = editWindow.y + editWindow.height + 8;
      const width = editWindow.width;
      const height = this.windowHeight();
      super.initialize(x, y, width, height);
      this._editWindow = editWindow;
      this._page = 0;
      this._index = 0;
      this.refresh();
      this.updateCursor();
      this.activate();
    }
    windowHeight() {
      return this.fittingHeight(9);
    }
    table() {
      if (self.$gameSystem.isJapanese()) {
        return [
          Window_NameInput.JAPAN1,
          Window_NameInput.JAPAN2,
          Window_NameInput.JAPAN3
        ];
      } else if (self.$gameSystem.isRussian()) {
        return [Window_NameInput.RUSSIA];
      } else {
        return [Window_NameInput.LATIN1, Window_NameInput.LATIN2];
      }
    }
    maxCols() {
      return 10;
    }
    maxItems() {
      return 90;
    }
    character() {
      return this._index < 88 ? this.table()[this._page][this._index] : "";
    }
    isPageChange() {
      return this._index === 88;
    }
    isOk() {
      return this._index === 89;
    }
    itemRect(index2) {
      return {
        x: index2 % 10 * 42 + Math.floor(index2 % 10 / 5) * 24,
        y: Math.floor(index2 / 10) * this.lineHeight(),
        width: 42,
        height: this.lineHeight()
      };
    }
    refresh() {
      const table = this.table();
      this.contents.clear();
      this.resetTextColor();
      for (let i = 0; i < 90; i++) {
        const rect = this.itemRect(i);
        rect.x += 3;
        rect.width -= 6;
        this.drawText(table[this._page][i], rect.x, rect.y, rect.width, "center");
      }
    }
    updateCursor() {
      const rect = this.itemRect(this._index);
      this.setCursorRect(rect.x, rect.y, rect.width, rect.height);
    }
    isCursorMovable() {
      return this.active;
    }
    cursorDown(wrap) {
      if (this._index < 80 || wrap) {
        this._index = (this._index + 10) % 90;
      }
    }
    cursorUp(wrap) {
      if (this._index >= 10 || wrap) {
        this._index = (this._index + 80) % 90;
      }
    }
    cursorRight(wrap) {
      if (this._index % 10 < 9) {
        this._index++;
      } else if (wrap) {
        this._index -= 9;
      }
    }
    cursorLeft(wrap) {
      if (this._index % 10 > 0) {
        this._index--;
      } else if (wrap) {
        this._index += 9;
      }
    }
    cursorPagedown() {
      this._page = (this._page + 1) % this.table().length;
      this.refresh();
    }
    cursorPageup() {
      this._page = (this._page + this.table().length - 1) % this.table().length;
      this.refresh();
    }
    processCursorMove() {
      const lastPage = this._page;
      super.processCursorMove();
      this.updateCursor();
      if (this._page !== lastPage) {
        SoundManager_default.playCursor();
      }
    }
    processHandling() {
      if (this.isOpen() && this.active) {
        if (Input_default.isTriggered("shift")) {
          this.processJump();
        }
        if (Input_default.isRepeated("cancel")) {
          this.processBack();
        }
        if (Input_default.isRepeated("ok")) {
          this.processOk();
        }
      }
    }
    isCancelEnabled() {
      return true;
    }
    processCancel() {
      this.processBack();
    }
    processJump() {
      if (this._index !== 89) {
        this._index = 89;
        SoundManager_default.playCursor();
      }
    }
    processBack() {
      if (this._editWindow.back()) {
        SoundManager_default.playCancel();
      }
    }
    processOk() {
      if (this.character()) {
        this.onNameAdd();
      } else if (this.isPageChange()) {
        SoundManager_default.playOk();
        this.cursorPagedown();
      } else if (this.isOk()) {
        this.onNameOk();
      }
    }
    onNameAdd() {
      if (this._editWindow.add(this.character())) {
        SoundManager_default.playOk();
      } else {
        SoundManager_default.playBuzzer();
      }
    }
    onNameOk() {
      if (this._editWindow.name() === "") {
        if (this._editWindow.restoreDefault()) {
          SoundManager_default.playOk();
        } else {
          SoundManager_default.playBuzzer();
        }
      } else {
        SoundManager_default.playOk();
        this.callOkHandler();
      }
    }
  };
  Window_NameInput.LATIN1 = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "a",
    "b",
    "c",
    "d",
    "e",
    "F",
    "G",
    "H",
    "I",
    "J",
    "f",
    "g",
    "h",
    "i",
    "j",
    "K",
    "L",
    "M",
    "N",
    "O",
    "k",
    "l",
    "m",
    "n",
    "o",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "p",
    "q",
    "r",
    "s",
    "t",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "u",
    "v",
    "w",
    "x",
    "y",
    "Z",
    "[",
    "]",
    "^",
    "_",
    "z",
    "{",
    "}",
    "|",
    "~",
    "0",
    "1",
    "2",
    "3",
    "4",
    "!",
    "#",
    "$",
    "%",
    "&",
    "5",
    "6",
    "7",
    "8",
    "9",
    "(",
    ")",
    "*",
    "+",
    "-",
    "/",
    "=",
    "@",
    "<",
    ">",
    ":",
    ";",
    " ",
    "Page",
    "OK"
  ];
  Window_NameInput.LATIN2 = [
    "\xC1",
    "\xC9",
    "\xCD",
    "\xD3",
    "\xDA",
    "\xE1",
    "\xE9",
    "\xED",
    "\xF3",
    "\xFA",
    "\xC0",
    "\xC8",
    "\xCC",
    "\xD2",
    "\xD9",
    "\xE0",
    "\xE8",
    "\xEC",
    "\xF2",
    "\xF9",
    "\xC2",
    "\xCA",
    "\xCE",
    "\xD4",
    "\xDB",
    "\xE2",
    "\xEA",
    "\xEE",
    "\xF4",
    "\xFB",
    "\xC4",
    "\xCB",
    "\xCF",
    "\xD6",
    "\xDC",
    "\xE4",
    "\xEB",
    "\xEF",
    "\xF6",
    "\xFC",
    "\u0100",
    "\u0112",
    "\u012A",
    "\u014C",
    "\u016A",
    "\u0101",
    "\u0113",
    "\u012B",
    "\u014D",
    "\u016B",
    "\xC3",
    "\xC5",
    "\xC6",
    "\xC7",
    "\xD0",
    "\xE3",
    "\xE5",
    "\xE6",
    "\xE7",
    "\xF0",
    "\xD1",
    "\xD5",
    "\xD8",
    "\u0160",
    "\u0174",
    "\xF1",
    "\xF5",
    "\xF8",
    "\u0161",
    "\u0175",
    "\xDD",
    "\u0176",
    "\u0178",
    "\u017D",
    "\xDE",
    "\xFD",
    "\xFF",
    "\u0177",
    "\u017E",
    "\xFE",
    "\u0132",
    "\u0152",
    "\u0133",
    "\u0153",
    "\xDF",
    "\xAB",
    "\xBB",
    " ",
    "Page",
    "OK"
  ];
  Window_NameInput.RUSSIA = [
    "\u0410",
    "\u0411",
    "\u0412",
    "\u0413",
    "\u0414",
    "\u0430",
    "\u0431",
    "\u0432",
    "\u0433",
    "\u0434",
    "\u0415",
    "\u0401",
    "\u0416",
    "\u0417",
    "\u0418",
    "\u0435",
    "\u0451",
    "\u0436",
    "\u0437",
    "\u0438",
    "\u0419",
    "\u041A",
    "\u041B",
    "\u041C",
    "\u041D",
    "\u0439",
    "\u043A",
    "\u043B",
    "\u043C",
    "\u043D",
    "\u041E",
    "\u041F",
    "\u0420",
    "\u0421",
    "\u0422",
    "\u043E",
    "\u043F",
    "\u0440",
    "\u0441",
    "\u0442",
    "\u0423",
    "\u0424",
    "\u0425",
    "\u0426",
    "\u0427",
    "\u0443",
    "\u0444",
    "\u0445",
    "\u0446",
    "\u0447",
    "\u0428",
    "\u0429",
    "\u042A",
    "\u042B",
    "\u042C",
    "\u0448",
    "\u0449",
    "\u044A",
    "\u044B",
    "\u044C",
    "\u042D",
    "\u042E",
    "\u042F",
    "^",
    "_",
    "\u044D",
    "\u044E",
    "\u044F",
    "%",
    "&",
    "0",
    "1",
    "2",
    "3",
    "4",
    "(",
    ")",
    "*",
    "+",
    "-",
    "5",
    "6",
    "7",
    "8",
    "9",
    ":",
    ";",
    " ",
    "",
    "OK"
  ];
  Window_NameInput.JAPAN1 = [
    "\u3042",
    "\u3044",
    "\u3046",
    "\u3048",
    "\u304A",
    "\u304C",
    "\u304E",
    "\u3050",
    "\u3052",
    "\u3054",
    "\u304B",
    "\u304D",
    "\u304F",
    "\u3051",
    "\u3053",
    "\u3056",
    "\u3058",
    "\u305A",
    "\u305C",
    "\u305E",
    "\u3055",
    "\u3057",
    "\u3059",
    "\u305B",
    "\u305D",
    "\u3060",
    "\u3062",
    "\u3065",
    "\u3067",
    "\u3069",
    "\u305F",
    "\u3061",
    "\u3064",
    "\u3066",
    "\u3068",
    "\u3070",
    "\u3073",
    "\u3076",
    "\u3079",
    "\u307C",
    "\u306A",
    "\u306B",
    "\u306C",
    "\u306D",
    "\u306E",
    "\u3071",
    "\u3074",
    "\u3077",
    "\u307A",
    "\u307D",
    "\u306F",
    "\u3072",
    "\u3075",
    "\u3078",
    "\u307B",
    "\u3041",
    "\u3043",
    "\u3045",
    "\u3047",
    "\u3049",
    "\u307E",
    "\u307F",
    "\u3080",
    "\u3081",
    "\u3082",
    "\u3063",
    "\u3083",
    "\u3085",
    "\u3087",
    "\u308E",
    "\u3084",
    "\u3086",
    "\u3088",
    "\u308F",
    "\u3093",
    "\u30FC",
    "\uFF5E",
    "\u30FB",
    "\uFF1D",
    "\u2606",
    "\u3089",
    "\u308A",
    "\u308B",
    "\u308C",
    "\u308D",
    "\u3094",
    "\u3092",
    "\u3000",
    "\u30AB\u30CA",
    "\u6C7A\u5B9A"
  ];
  Window_NameInput.JAPAN2 = [
    "\u30A2",
    "\u30A4",
    "\u30A6",
    "\u30A8",
    "\u30AA",
    "\u30AC",
    "\u30AE",
    "\u30B0",
    "\u30B2",
    "\u30B4",
    "\u30AB",
    "\u30AD",
    "\u30AF",
    "\u30B1",
    "\u30B3",
    "\u30B6",
    "\u30B8",
    "\u30BA",
    "\u30BC",
    "\u30BE",
    "\u30B5",
    "\u30B7",
    "\u30B9",
    "\u30BB",
    "\u30BD",
    "\u30C0",
    "\u30C2",
    "\u30C5",
    "\u30C7",
    "\u30C9",
    "\u30BF",
    "\u30C1",
    "\u30C4",
    "\u30C6",
    "\u30C8",
    "\u30D0",
    "\u30D3",
    "\u30D6",
    "\u30D9",
    "\u30DC",
    "\u30CA",
    "\u30CB",
    "\u30CC",
    "\u30CD",
    "\u30CE",
    "\u30D1",
    "\u30D4",
    "\u30D7",
    "\u30DA",
    "\u30DD",
    "\u30CF",
    "\u30D2",
    "\u30D5",
    "\u30D8",
    "\u30DB",
    "\u30A1",
    "\u30A3",
    "\u30A5",
    "\u30A7",
    "\u30A9",
    "\u30DE",
    "\u30DF",
    "\u30E0",
    "\u30E1",
    "\u30E2",
    "\u30C3",
    "\u30E3",
    "\u30E5",
    "\u30E7",
    "\u30EE",
    "\u30E4",
    "\u30E6",
    "\u30E8",
    "\u30EF",
    "\u30F3",
    "\u30FC",
    "\uFF5E",
    "\u30FB",
    "\uFF1D",
    "\u2606",
    "\u30E9",
    "\u30EA",
    "\u30EB",
    "\u30EC",
    "\u30ED",
    "\u30F4",
    "\u30F2",
    "\u3000",
    "\u82F1\u6570",
    "\u6C7A\u5B9A"
  ];
  Window_NameInput.JAPAN3 = [
    "\uFF21",
    "\uFF22",
    "\uFF23",
    "\uFF24",
    "\uFF25",
    "\uFF41",
    "\uFF42",
    "\uFF43",
    "\uFF44",
    "\uFF45",
    "\uFF26",
    "\uFF27",
    "\uFF28",
    "\uFF29",
    "\uFF2A",
    "\uFF46",
    "\uFF47",
    "\uFF48",
    "\uFF49",
    "\uFF4A",
    "\uFF2B",
    "\uFF2C",
    "\uFF2D",
    "\uFF2E",
    "\uFF2F",
    "\uFF4B",
    "\uFF4C",
    "\uFF4D",
    "\uFF4E",
    "\uFF4F",
    "\uFF30",
    "\uFF31",
    "\uFF32",
    "\uFF33",
    "\uFF34",
    "\uFF50",
    "\uFF51",
    "\uFF52",
    "\uFF53",
    "\uFF54",
    "\uFF35",
    "\uFF36",
    "\uFF37",
    "\uFF38",
    "\uFF39",
    "\uFF55",
    "\uFF56",
    "\uFF57",
    "\uFF58",
    "\uFF59",
    "\uFF3A",
    "\uFF3B",
    "\uFF3D",
    "\uFF3E",
    "\uFF3F",
    "\uFF5A",
    "\uFF5B",
    "\uFF5D",
    "\uFF5C",
    "\uFF5E",
    "\uFF10",
    "\uFF11",
    "\uFF12",
    "\uFF13",
    "\uFF14",
    "\uFF01",
    "\uFF03",
    "\uFF04",
    "\uFF05",
    "\uFF06",
    "\uFF15",
    "\uFF16",
    "\uFF17",
    "\uFF18",
    "\uFF19",
    "\uFF08",
    "\uFF09",
    "\uFF0A",
    "\uFF0B",
    "\uFF0D",
    "\uFF0F",
    "\uFF1D",
    "\uFF20",
    "\uFF1C",
    "\uFF1E",
    "\uFF1A",
    "\uFF1B",
    "\u3000",
    "\u304B\u306A",
    "\u6C7A\u5B9A"
  ];
  var Window_NameInput_default = Window_NameInput;

  // src-www/js/rpg_scenes/Scene_Name.js
  var Scene_Name = class extends Scene_MenuBase_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
    }
    prepare(actorId, maxLength) {
      this._actorId = actorId;
      this._maxLength = maxLength;
    }
    create() {
      super.create();
      this._actor = self.$gameActors.actor(this._actorId);
      this.createEditWindow();
      this.createInputWindow();
    }
    start() {
      super.start();
      this._editWindow.refresh();
    }
    createEditWindow() {
      this._editWindow = new Window_NameEdit_default(this._actor, this._maxLength);
      this.addWindow(this._editWindow);
    }
    createInputWindow() {
      this._inputWindow = new Window_NameInput_default(this._editWindow);
      this._inputWindow.setHandler("ok", this.onInputOk.bind(this));
      this.addWindow(this._inputWindow);
    }
    onInputOk() {
      this._actor.setName(this._editWindow.name());
      this.popScene();
    }
  };
  var Scene_Name_default = Scene_Name;

  // src-www/js/rpg_objects/Game_Interpreter.js
  var _Game_Interpreter = class {
    constructor(...args) {
      this.initialize(...args);
    }
    initialize(depth) {
      this._depth = depth || 0;
      this.checkOverflow();
      this.clear();
      this._branch = {};
      this._params = [];
      this._indent = 0;
      this._frameCount = 0;
      this._freezeChecker = 0;
    }
    checkOverflow() {
      if (this._depth >= 100) {
        throw new Error("Common event calls exceeded the limit");
      }
    }
    clear() {
      this._mapId = 0;
      this._eventId = 0;
      this._list = null;
      this._index = 0;
      this._waitCount = 0;
      this._waitMode = "";
      this._comments = "";
      this._eventInfo = null;
      this._character = null;
      this._childInterpreter = null;
    }
    setup(list, eventId) {
      this.clear();
      this._mapId = self.$gameMap.mapId();
      this._eventId = eventId || 0;
      this._list = list;
      _Game_Interpreter.requestImages(list);
    }
    eventId() {
      return this._eventId;
    }
    isOnCurrentMap() {
      return this._mapId === self.$gameMap.mapId();
    }
    setEventInfo(eventInfo) {
      this._eventInfo = eventInfo;
    }
    setupReservedCommonEvent() {
      if (self.$gameTemp.isCommonEventReserved()) {
        this.setup(self.$gameTemp.reservedCommonEvent().list);
        this.setEventInfo({
          eventType: "common_event",
          commonEventId: self.$gameTemp.reservedCommonEventId()
        });
        self.$gameTemp.clearCommonEvent();
        return true;
      } else {
        return false;
      }
    }
    isRunning() {
      return !!this._list;
    }
    update() {
      while (this.isRunning()) {
        if (this.updateChild() || this.updateWait()) {
          break;
        }
        if (SceneManager_default.isSceneChanging()) {
          break;
        }
        if (!this.executeCommand()) {
          break;
        }
        if (this.checkFreeze()) {
          break;
        }
      }
    }
    updateChild() {
      if (this._childInterpreter) {
        this._childInterpreter.update();
        if (this._childInterpreter.isRunning()) {
          return true;
        } else {
          this._childInterpreter = null;
        }
      }
      return false;
    }
    updateWait() {
      return this.updateWaitCount() || this.updateWaitMode();
    }
    updateWaitCount() {
      if (this._waitCount > 0) {
        this._waitCount--;
        return true;
      }
      return false;
    }
    updateWaitMode() {
      let waiting = false;
      switch (this._waitMode) {
        case "message":
          waiting = self.$gameMessage.isBusy();
          break;
        case "transfer":
          waiting = self.$gamePlayer.isTransferring();
          break;
        case "scroll":
          waiting = self.$gameMap.isScrolling();
          break;
        case "route":
          waiting = this._character.isMoveRouteForcing();
          break;
        case "animation":
          waiting = this._character.isAnimationPlaying();
          break;
        case "balloon":
          waiting = this._character.isBalloonPlaying();
          break;
        case "gather":
          waiting = self.$gamePlayer.areFollowersGathering();
          break;
        case "action":
          waiting = BattleManager_default.isActionForced();
          break;
        case "video":
          waiting = Graphics_default.isVideoPlaying();
          break;
        case "image":
          waiting = !ImageManager_default.isReady();
          break;
      }
      if (!waiting) {
        this._waitMode = "";
      }
      return waiting;
    }
    setWaitMode(waitMode) {
      this._waitMode = waitMode;
    }
    wait(duration) {
      this._waitCount = duration;
    }
    fadeSpeed() {
      return 24;
    }
    executeCommand() {
      const command2 = this.currentCommand();
      if (command2) {
        this._params = command2.parameters;
        this._indent = command2.indent;
        const methodName = `command${command2.code}`;
        if (typeof this[methodName] === "function") {
          try {
            if (!this[methodName]()) {
              return false;
            }
          } catch (error) {
            for (let key in this._eventInfo) {
              error[key] = this._eventInfo[key];
            }
            error.eventCommand = error.eventCommand || "other";
            error.line = error.line || this._index + 1;
            throw error;
          }
        }
        this._index++;
      } else {
        this.terminate();
      }
      return true;
    }
    checkFreeze() {
      if (this._frameCount !== Graphics_default.frameCount) {
        this._frameCount = Graphics_default.frameCount;
        this._freezeChecker = 0;
      }
      if (this._freezeChecker++ >= 1e5) {
        return true;
      } else {
        return false;
      }
    }
    terminate() {
      this._list = null;
      this._comments = "";
    }
    skipBranch() {
      while (this._list[this._index + 1].indent > this._indent) {
        this._index++;
      }
    }
    currentCommand() {
      return this._list[this._index];
    }
    nextEventCode() {
      const command2 = this._list[this._index + 1];
      if (command2) {
        return command2.code;
      } else {
        return 0;
      }
    }
    iterateActorId(param, callback) {
      if (param === 0) {
        self.$gameParty.members().forEach(callback);
      } else {
        const actor2 = self.$gameActors.actor(param);
        if (actor2) {
          callback(actor2);
        }
      }
    }
    iterateActorEx(param1, param2, callback) {
      if (param1 === 0) {
        this.iterateActorId(param2, callback);
      } else {
        this.iterateActorId(self.$gameVariables.value(param2), callback);
      }
    }
    iterateActorIndex(param, callback) {
      if (param < 0) {
        self.$gameParty.members().forEach(callback);
      } else {
        const actor2 = self.$gameParty.members()[param];
        if (actor2) {
          callback(actor2);
        }
      }
    }
    iterateEnemyIndex(param, callback) {
      if (param < 0) {
        self.$gameTroop.members().forEach(callback);
      } else {
        const enemy2 = self.$gameTroop.members()[param];
        if (enemy2) {
          callback(enemy2);
        }
      }
    }
    iterateBattler(param1, param2, callback) {
      if (self.$gameParty.inBattle()) {
        if (param1 === 0) {
          this.iterateEnemyIndex(param2, callback);
        } else {
          this.iterateActorId(param2, callback);
        }
      }
    }
    character(param) {
      if (self.$gameParty.inBattle()) {
        return null;
      } else if (param < 0) {
        return self.$gamePlayer;
      } else if (this.isOnCurrentMap()) {
        return self.$gameMap.event(param > 0 ? param : this._eventId);
      } else {
        return null;
      }
    }
    operateValue(operation, operandType, operand) {
      const value3 = operandType === 0 ? operand : self.$gameVariables.value(operand);
      return operation === 0 ? value3 : -value3;
    }
    changeHp(target2, value3, allowDeath) {
      if (target2.isAlive()) {
        if (!allowDeath && target2.hp <= -value3) {
          value3 = 1 - target2.hp;
        }
        target2.gainHp(value3);
        if (target2.isDead()) {
          target2.performCollapse();
        }
      }
    }
    // Show Text
    command101() {
      if (!self.$gameMessage.isBusy()) {
        self.$gameMessage.setFaceImage(this._params[0], this._params[1]);
        self.$gameMessage.setBackground(this._params[2]);
        self.$gameMessage.setPositionType(this._params[3]);
        while (this.nextEventCode() === 401) {
          this._index++;
          self.$gameMessage.add(this.currentCommand().parameters[0]);
        }
        switch (this.nextEventCode()) {
          case 102:
            this._index++;
            this.setupChoices(this.currentCommand().parameters);
            break;
          case 103:
            this._index++;
            this.setupNumInput(this.currentCommand().parameters);
            break;
          case 104:
            this._index++;
            this.setupItemChoice(this.currentCommand().parameters);
            break;
        }
        this._index++;
        this.setWaitMode("message");
      }
      return false;
    }
    // Show Choices
    command102() {
      if (!self.$gameMessage.isBusy()) {
        this.setupChoices(this._params);
        this._index++;
        this.setWaitMode("message");
      }
      return false;
    }
    setupChoices(params2) {
      const choices = params2[0].clone();
      let cancelType = params2[1];
      const defaultType = params2.length > 2 ? params2[2] : 0;
      const positionType = params2.length > 3 ? params2[3] : 2;
      const background = params2.length > 4 ? params2[4] : 0;
      if (cancelType >= choices.length) {
        cancelType = -2;
      }
      self.$gameMessage.setChoices(choices, defaultType, cancelType);
      self.$gameMessage.setChoiceBackground(background);
      self.$gameMessage.setChoicePositionType(positionType);
      self.$gameMessage.setChoiceCallback((n) => {
        this._branch[this._indent] = n;
      });
    }
    // When [**]
    command402() {
      if (this._branch[this._indent] !== this._params[0]) {
        this.skipBranch();
      }
      return true;
    }
    // When Cancel
    command403() {
      if (this._branch[this._indent] >= 0) {
        this.skipBranch();
      }
      return true;
    }
    // Input Number
    command103() {
      if (!self.$gameMessage.isBusy()) {
        this.setupNumInput(this._params);
        this._index++;
        this.setWaitMode("message");
      }
      return false;
    }
    setupNumInput(params2) {
      self.$gameMessage.setNumberInput(params2[0], params2[1]);
    }
    // Select Item
    command104() {
      if (!self.$gameMessage.isBusy()) {
        this.setupItemChoice(this._params);
        this._index++;
        this.setWaitMode("message");
      }
      return false;
    }
    setupItemChoice(params2) {
      self.$gameMessage.setItemChoice(params2[0], params2[1] || 2);
    }
    // Show Scrolling Text
    command105() {
      if (!self.$gameMessage.isBusy()) {
        self.$gameMessage.setScroll(this._params[0], this._params[1]);
        while (this.nextEventCode() === 405) {
          this._index++;
          self.$gameMessage.add(this.currentCommand().parameters[0]);
        }
        this._index++;
        this.setWaitMode("message");
      }
      return false;
    }
    // Comment
    command108() {
      this._comments = [this._params[0]];
      while (this.nextEventCode() === 408) {
        this._index++;
        this._comments.push(this.currentCommand().parameters[0]);
      }
      return true;
    }
    // Conditional Branch
    command111() {
      let result = false;
      switch (this._params[0]) {
        case 0:
          result = self.$gameSwitches.value(this._params[1]) === (this._params[2] === 0);
          break;
        case 1:
          const value1 = self.$gameVariables.value(this._params[1]);
          let value2;
          if (this._params[2] === 0) {
            value2 = this._params[3];
          } else {
            value2 = self.$gameVariables.value(this._params[3]);
          }
          switch (this._params[4]) {
            case 0:
              result = value1 === value2;
              break;
            case 1:
              result = value1 >= value2;
              break;
            case 2:
              result = value1 <= value2;
              break;
            case 3:
              result = value1 > value2;
              break;
            case 4:
              result = value1 < value2;
              break;
            case 5:
              result = value1 !== value2;
              break;
          }
          break;
        case 2:
          if (this._eventId > 0) {
            const key = [this._mapId, this._eventId, this._params[1]];
            result = self.$gameSelfSwitches.value(key) === (this._params[2] === 0);
          }
          break;
        case 3:
          if (self.$gameTimer.isWorking()) {
            if (this._params[2] === 0) {
              result = self.$gameTimer.seconds() >= this._params[1];
            } else {
              result = self.$gameTimer.seconds() <= this._params[1];
            }
          }
          break;
        case 4:
          const actor = self.$gameActors.actor(this._params[1]);
          if (actor) {
            const n = this._params[3];
            switch (this._params[2]) {
              case 0:
                result = self.$gameParty.members().contains(actor);
                break;
              case 1:
                result = actor.name() === n;
                break;
              case 2:
                result = actor.isClass(self.$dataClasses[n]);
                break;
              case 3:
                result = actor.hasSkill(n);
                break;
              case 4:
                result = actor.hasWeapon(self.$dataWeapons[n]);
                break;
              case 5:
                result = actor.hasArmor(self.$dataArmors[n]);
                break;
              case 6:
                result = actor.isStateAffected(n);
                break;
            }
          }
          break;
        case 5:
          const enemy = self.$gameTroop.members()[this._params[1]];
          if (enemy) {
            switch (this._params[2]) {
              case 0:
                result = enemy.isAlive();
                break;
              case 1:
                result = enemy.isStateAffected(this._params[3]);
                break;
            }
          }
          break;
        case 6:
          const character = this.character(this._params[1]);
          if (character) {
            result = character.direction() === this._params[2];
          }
          break;
        case 7:
          switch (this._params[2]) {
            case 0:
              result = self.$gameParty.gold() >= this._params[1];
              break;
            case 1:
              result = self.$gameParty.gold() <= this._params[1];
              break;
            case 2:
              result = self.$gameParty.gold() < this._params[1];
              break;
          }
          break;
        case 8:
          result = self.$gameParty.hasItem(self.$dataItems[this._params[1]]);
          break;
        case 9:
          result = self.$gameParty.hasItem(
            self.$dataWeapons[this._params[1]],
            this._params[2]
          );
          break;
        case 10:
          result = self.$gameParty.hasItem(
            self.$dataArmors[this._params[1]],
            this._params[2]
          );
          break;
        case 11:
          result = Input_default.isPressed(this._params[1]);
          break;
        case 12:
          try {
            result = !!eval(this._params[1]);
          } catch (error) {
            error.eventCommand = "conditional_branch_script";
            error.content = this._params[1];
            throw error;
          }
          break;
        case 13:
          result = self.$gamePlayer.vehicle() === self.$gameMap.vehicle(this._params[1]);
          break;
      }
      this._branch[this._indent] = result;
      if (this._branch[this._indent] === false) {
        this.skipBranch();
      }
      return true;
    }
    // Else
    command411() {
      if (this._branch[this._indent] !== false) {
        this.skipBranch();
      }
      return true;
    }
    // Loop
    command112() {
      return true;
    }
    // Repeat Above
    command413() {
      do {
        this._index--;
      } while (this.currentCommand().indent !== this._indent);
      return true;
    }
    // Break Loop
    command113() {
      let depth = 0;
      while (this._index < this._list.length - 1) {
        this._index++;
        const command2 = this.currentCommand();
        if (command2.code === 112)
          depth++;
        if (command2.code === 413) {
          if (depth > 0)
            depth--;
          else
            break;
        }
      }
      return true;
    }
    // Exit Event Processing
    command115() {
      this._index = this._list.length;
      return true;
    }
    // Common Event
    command117() {
      const commonEvent = self.$dataCommonEvents[this._params[0]];
      if (commonEvent) {
        const eventId = this.isOnCurrentMap() ? this._eventId : 0;
        this.setupChild(commonEvent.list, eventId);
      }
      return true;
    }
    setupChild(list, eventId) {
      this._childInterpreter = new _Game_Interpreter(this._depth + 1);
      this._childInterpreter.setup(list, eventId);
      this._childInterpreter.setEventInfo({
        eventType: "common_event",
        commonEventId: this._params[0]
      });
    }
    // Label
    command118() {
      return true;
    }
    // Jump to Label
    command119() {
      const labelName = this._params[0];
      for (let i = 0; i < this._list.length; i++) {
        const command2 = this._list[i];
        if (command2.code === 118 && command2.parameters[0] === labelName) {
          this.jumpTo(i);
          return;
        }
      }
      return true;
    }
    jumpTo(index2) {
      const lastIndex = this._index;
      const startIndex = Math.min(index2, lastIndex);
      const endIndex = Math.max(index2, lastIndex);
      let indent = this._indent;
      for (let i = startIndex; i <= endIndex; i++) {
        const newIndent = this._list[i].indent;
        if (newIndent !== indent) {
          this._branch[indent] = null;
          indent = newIndent;
        }
      }
      this._index = index2;
    }
    // Control Switches
    command121() {
      for (let i = this._params[0]; i <= this._params[1]; i++) {
        self.$gameSwitches.setValue(i, this._params[2] === 0);
      }
      return true;
    }
    // Control Variables
    command122() {
      let value = 0;
      switch (this._params[3]) {
        case 0:
          value = this._params[4];
          break;
        case 1:
          value = self.$gameVariables.value(this._params[4]);
          break;
        case 2:
          value = this._params[5] - this._params[4] + 1;
          for (let i = this._params[0]; i <= this._params[1]; i++) {
            this.operateVariable(
              i,
              this._params[2],
              this._params[4] + Math.randomInt(value)
            );
          }
          return true;
          break;
        case 3:
          value = this.gameDataOperand(
            this._params[4],
            this._params[5],
            this._params[6]
          );
          break;
        case 4:
          try {
            value = eval(this._params[4]);
          } catch (error) {
            error.eventCommand = "control_variables";
            error.content = this._params[4];
            throw error;
          }
          break;
      }
      for (let i = this._params[0]; i <= this._params[1]; i++) {
        this.operateVariable(i, this._params[2], value);
      }
      return true;
    }
    gameDataOperand(type, param1, param2) {
      switch (type) {
        case 0:
          return self.$gameParty.numItems(self.$dataItems[param1]);
        case 1:
          return self.$gameParty.numItems(self.$dataWeapons[param1]);
        case 2:
          return self.$gameParty.numItems(self.$dataArmors[param1]);
        case 3:
          const actor2 = self.$gameActors.actor(param1);
          if (actor2) {
            switch (param2) {
              case 0:
                return actor2.level;
              case 1:
                return actor2.currentExp();
              case 2:
                return actor2.hp;
              case 3:
                return actor2.mp;
              default:
                if (param2 >= 4 && param2 <= 11) {
                  return actor2.param(param2 - 4);
                }
            }
          }
          break;
        case 4:
          const enemy2 = self.$gameTroop.members()[param1];
          if (enemy2) {
            switch (param2) {
              case 0:
                return enemy2.hp;
              case 1:
                return enemy2.mp;
              default:
                if (param2 >= 2 && param2 <= 9) {
                  return enemy2.param(param2 - 2);
                }
            }
          }
          break;
        case 5:
          const character2 = this.character(param1);
          if (character2) {
            switch (param2) {
              case 0:
                return character2.x;
              case 1:
                return character2.y;
              case 2:
                return character2.direction();
              case 3:
                return character2.screenX();
              case 4:
                return character2.screenY();
            }
          }
          break;
        case 6:
          const actor_party = self.$gameParty.members()[param1];
          return actor_party ? actor_party.actorId() : 0;
        case 7:
          switch (param1) {
            case 0:
              return self.$gameMap.mapId();
            case 1:
              return self.$gameParty.size();
            case 2:
              return self.$gameParty.gold();
            case 3:
              return self.$gameParty.steps();
            case 4:
              return self.$gameSystem.playtime();
            case 5:
              return self.$gameTimer.seconds();
            case 6:
              return self.$gameSystem.saveCount();
            case 7:
              return self.$gameSystem.battleCount();
            case 8:
              return self.$gameSystem.winCount();
            case 9:
              return self.$gameSystem.escapeCount();
          }
          break;
      }
      return 0;
    }
    operateVariable(variableId, operationType, value3) {
      try {
        let oldValue = self.$gameVariables.value(variableId);
        switch (operationType) {
          case 0:
            self.$gameVariables.setValue(variableId, oldValue = value3);
            break;
          case 1:
            self.$gameVariables.setValue(variableId, oldValue + value3);
            break;
          case 2:
            self.$gameVariables.setValue(variableId, oldValue - value3);
            break;
          case 3:
            self.$gameVariables.setValue(variableId, oldValue * value3);
            break;
          case 4:
            self.$gameVariables.setValue(variableId, oldValue / value3);
            break;
          case 5:
            self.$gameVariables.setValue(variableId, oldValue % value3);
            break;
        }
      } catch (e) {
        self.$gameVariables.setValue(variableId, 0);
      }
    }
    // Control Self Switch
    command123() {
      if (this._eventId > 0) {
        const key = [this._mapId, this._eventId, this._params[0]];
        self.$gameSelfSwitches.setValue(key, this._params[1] === 0);
      }
      return true;
    }
    // Control Timer
    command124() {
      if (this._params[0] === 0) {
        self.$gameTimer.start(this._params[1] * 60);
      } else {
        self.$gameTimer.stop();
      }
      return true;
    }
    // Change Gold
    command125() {
      const value3 = this.operateValue(
        this._params[0],
        this._params[1],
        this._params[2]
      );
      self.$gameParty.gainGold(value3);
      return true;
    }
    // Change Items
    command126() {
      const value3 = this.operateValue(
        this._params[1],
        this._params[2],
        this._params[3]
      );
      self.$gameParty.gainItem(self.$dataItems[this._params[0]], value3);
      return true;
    }
    // Change Weapons
    command127() {
      const value3 = this.operateValue(
        this._params[1],
        this._params[2],
        this._params[3]
      );
      self.$gameParty.gainItem(
        self.$dataWeapons[this._params[0]],
        value3,
        this._params[4]
      );
      return true;
    }
    // Change Armors
    command128() {
      const value3 = this.operateValue(
        this._params[1],
        this._params[2],
        this._params[3]
      );
      self.$gameParty.gainItem(
        self.$dataArmors[this._params[0]],
        value3,
        this._params[4]
      );
      return true;
    }
    // Change Party Member
    command129() {
      const actor2 = self.$gameActors.actor(this._params[0]);
      if (actor2) {
        if (this._params[1] === 0) {
          if (this._params[2]) {
            self.$gameActors.actor(this._params[0]).setup(this._params[0]);
          }
          self.$gameParty.addActor(this._params[0]);
        } else {
          self.$gameParty.removeActor(this._params[0]);
        }
      }
      return true;
    }
    // Change Battle BGM
    command132() {
      self.$gameSystem.setBattleBgm(this._params[0]);
      return true;
    }
    // Change Victory ME
    command133() {
      self.$gameSystem.setVictoryMe(this._params[0]);
      return true;
    }
    // Change Save Access
    command134() {
      if (this._params[0] === 0) {
        self.$gameSystem.disableSave();
      } else {
        self.$gameSystem.enableSave();
      }
      return true;
    }
    // Change Menu Access
    command135() {
      if (this._params[0] === 0) {
        self.$gameSystem.disableMenu();
      } else {
        self.$gameSystem.enableMenu();
      }
      return true;
    }
    // Change Encounter Disable
    command136() {
      if (this._params[0] === 0) {
        self.$gameSystem.disableEncounter();
      } else {
        self.$gameSystem.enableEncounter();
      }
      self.$gamePlayer.makeEncounterCount();
      return true;
    }
    // Change Formation Access
    command137() {
      if (this._params[0] === 0) {
        self.$gameSystem.disableFormation();
      } else {
        self.$gameSystem.enableFormation();
      }
      return true;
    }
    // Change Window Color
    command138() {
      self.$gameSystem.setWindowTone(this._params[0]);
      return true;
    }
    // Change Defeat ME
    command139() {
      self.$gameSystem.setDefeatMe(this._params[0]);
      return true;
    }
    // Change Vehicle BGM
    command140() {
      const vehicle = self.$gameMap.vehicle(this._params[0]);
      if (vehicle) {
        vehicle.setBgm(this._params[1]);
      }
      return true;
    }
    // Transfer Player
    command201() {
      if (!self.$gameParty.inBattle() && !self.$gameMessage.isBusy()) {
        let mapId;
        let x;
        let y;
        if (this._params[0] === 0) {
          mapId = this._params[1];
          x = this._params[2];
          y = this._params[3];
        } else {
          mapId = self.$gameVariables.value(this._params[1]);
          x = self.$gameVariables.value(this._params[2]);
          y = self.$gameVariables.value(this._params[3]);
        }
        self.$gamePlayer.reserveTransfer(
          mapId,
          x,
          y,
          this._params[4],
          this._params[5]
        );
        this.setWaitMode("transfer");
        this._index++;
      }
      return false;
    }
    // Set Vehicle Location
    command202() {
      let mapId;
      let x;
      let y;
      if (this._params[1] === 0) {
        mapId = this._params[2];
        x = this._params[3];
        y = this._params[4];
      } else {
        mapId = self.$gameVariables.value(this._params[2]);
        x = self.$gameVariables.value(this._params[3]);
        y = self.$gameVariables.value(this._params[4]);
      }
      const vehicle = self.$gameMap.vehicle(this._params[0]);
      if (vehicle) {
        vehicle.setLocation(mapId, x, y);
      }
      return true;
    }
    // Set Event Location
    command203() {
      const character2 = this.character(this._params[0]);
      if (character2) {
        if (this._params[1] === 0) {
          character2.locate(this._params[2], this._params[3]);
        } else if (this._params[1] === 1) {
          const x = self.$gameVariables.value(this._params[2]);
          const y = self.$gameVariables.value(this._params[3]);
          character2.locate(x, y);
        } else {
          const character22 = this.character(this._params[2]);
          if (character22) {
            character2.swap(character22);
          }
        }
        if (this._params[4] > 0) {
          character2.setDirection(this._params[4]);
        }
      }
      return true;
    }
    // Scroll Map
    command204() {
      if (!self.$gameParty.inBattle()) {
        if (self.$gameMap.isScrolling()) {
          this.setWaitMode("scroll");
          return false;
        }
        self.$gameMap.startScroll(
          this._params[0],
          this._params[1],
          this._params[2]
        );
      }
      return true;
    }
    // Set Movement Route
    command205() {
      self.$gameMap.refreshIfNeeded();
      this._character = this.character(this._params[0]);
      if (this._character) {
        this._character.forceMoveRoute(this._params[1]);
        const eventInfo = JsonEx_default.makeDeepCopy(this._eventInfo);
        eventInfo.line = this._index + 1;
        this._character.setCallerEventInfo(eventInfo);
        if (this._params[1].wait) {
          this.setWaitMode("route");
        }
      }
      return true;
    }
    // Getting On and Off Vehicles
    command206() {
      self.$gamePlayer.getOnOffVehicle();
      return true;
    }
    // Change Transparency
    command211() {
      self.$gamePlayer.setTransparent(this._params[0] === 0);
      return true;
    }
    // Show Animation
    command212() {
      this._character = this.character(this._params[0]);
      if (this._character) {
        this._character.requestAnimation(this._params[1]);
        if (this._params[2]) {
          this.setWaitMode("animation");
        }
      }
      return true;
    }
    // Show Balloon Icon
    command213() {
      this._character = this.character(this._params[0]);
      if (this._character) {
        this._character.requestBalloon(this._params[1]);
        if (this._params[2]) {
          this.setWaitMode("balloon");
        }
      }
      return true;
    }
    // Erase Event
    command214() {
      if (this.isOnCurrentMap() && this._eventId > 0) {
        self.$gameMap.eraseEvent(this._eventId);
      }
      return true;
    }
    // Change Player Followers
    command216() {
      if (this._params[0] === 0) {
        self.$gamePlayer.showFollowers();
      } else {
        self.$gamePlayer.hideFollowers();
      }
      self.$gamePlayer.refresh();
      return true;
    }
    // Gather Followers
    command217() {
      if (!self.$gameParty.inBattle()) {
        self.$gamePlayer.gatherFollowers();
        this.setWaitMode("gather");
      }
      return true;
    }
    // Fadeout Screen
    command221() {
      if (!self.$gameMessage.isBusy()) {
        self.$gameScreen.startFadeOut(this.fadeSpeed());
        this.wait(this.fadeSpeed());
        this._index++;
      }
      return false;
    }
    // Fadein Screen
    command222() {
      if (!self.$gameMessage.isBusy()) {
        self.$gameScreen.startFadeIn(this.fadeSpeed());
        this.wait(this.fadeSpeed());
        this._index++;
      }
      return false;
    }
    // Tint Screen
    command223() {
      self.$gameScreen.startTint(this._params[0], this._params[1]);
      if (this._params[2]) {
        this.wait(this._params[1]);
      }
      return true;
    }
    // Flash Screen
    command224() {
      self.$gameScreen.startFlash(this._params[0], this._params[1]);
      if (this._params[2]) {
        this.wait(this._params[1]);
      }
      return true;
    }
    // Shake Screen
    command225() {
      self.$gameScreen.startShake(
        this._params[0],
        this._params[1],
        this._params[2]
      );
      if (this._params[3]) {
        this.wait(this._params[2]);
      }
      return true;
    }
    // Wait
    command230() {
      this.wait(this._params[0]);
      return true;
    }
    // Show Picture
    command231() {
      let x;
      let y;
      if (this._params[3] === 0) {
        x = this._params[4];
        y = this._params[5];
      } else {
        x = self.$gameVariables.value(this._params[4]);
        y = self.$gameVariables.value(this._params[5]);
      }
      self.$gameScreen.showPicture(
        this._params[0],
        this._params[1],
        this._params[2],
        x,
        y,
        this._params[6],
        this._params[7],
        this._params[8],
        this._params[9]
      );
      return true;
    }
    // Move Picture
    command232() {
      let x;
      let y;
      if (this._params[3] === 0) {
        x = this._params[4];
        y = this._params[5];
      } else {
        x = self.$gameVariables.value(this._params[4]);
        y = self.$gameVariables.value(this._params[5]);
      }
      self.$gameScreen.movePicture(
        this._params[0],
        this._params[2],
        x,
        y,
        this._params[6],
        this._params[7],
        this._params[8],
        this._params[9],
        this._params[10]
      );
      if (this._params[11]) {
        this.wait(this._params[10]);
      }
      return true;
    }
    // Rotate Picture
    command233() {
      self.$gameScreen.rotatePicture(this._params[0], this._params[1]);
      return true;
    }
    // Tint Picture
    command234() {
      self.$gameScreen.tintPicture(
        this._params[0],
        this._params[1],
        this._params[2]
      );
      if (this._params[3]) {
        this.wait(this._params[2]);
      }
      return true;
    }
    // Erase Picture
    command235() {
      self.$gameScreen.erasePicture(this._params[0]);
      return true;
    }
    // Set Weather Effect
    command236() {
      if (!self.$gameParty.inBattle()) {
        self.$gameScreen.changeWeather(
          this._params[0],
          this._params[1],
          this._params[2]
        );
        if (this._params[3]) {
          this.wait(this._params[2]);
        }
      }
      return true;
    }
    // Play BGM
    command241() {
      AudioManager_default.playBgm(this._params[0]);
      return true;
    }
    // Fadeout BGM
    command242() {
      AudioManager_default.fadeOutBgm(this._params[0]);
      return true;
    }
    // Save BGM
    command243() {
      self.$gameSystem.saveBgm();
      return true;
    }
    // Resume BGM
    command244() {
      self.$gameSystem.replayBgm();
      return true;
    }
    // Play BGS
    command245() {
      AudioManager_default.playBgs(this._params[0]);
      return true;
    }
    // Fadeout BGS
    command246() {
      AudioManager_default.fadeOutBgs(this._params[0]);
      return true;
    }
    // Play ME
    command249() {
      AudioManager_default.playMe(this._params[0]);
      return true;
    }
    // Play SE
    command250() {
      AudioManager_default.playSe(this._params[0]);
      return true;
    }
    // Stop SE
    command251() {
      AudioManager_default.stopSe();
      return true;
    }
    // Play Movie
    command261() {
      if (!self.$gameMessage.isBusy()) {
        const name = this._params[0];
        if (name.length > 0) {
          const ext = this.videoFileExt();
          Graphics_default.playVideo(`movies/${name}${ext}`);
          this.setWaitMode("video");
        }
        this._index++;
      }
      return false;
    }
    videoFileExt() {
      if (Graphics_default.canPlayVideoType("video/webm") && !Utils_default.isMobileDevice()) {
        return ".webm";
      } else {
        return ".mp4";
      }
    }
    // Change Map Name Display
    command281() {
      if (this._params[0] === 0) {
        self.$gameMap.enableNameDisplay();
      } else {
        self.$gameMap.disableNameDisplay();
      }
      return true;
    }
    // Change Tileset
    command282() {
      const tileset = self.$dataTilesets[this._params[0]];
      if (!this._imageReservationId) {
        this._imageReservationId = Utils_default.generateRuntimeId();
      }
      const allReady = tileset.tilesetNames.map(function(tilesetName) {
        return ImageManager_default.reserveTileset(
          tilesetName,
          0,
          this._imageReservationId
        );
      }, this).every((bitmap) => bitmap.isReady());
      if (allReady) {
        self.$gameMap.changeTileset(this._params[0]);
        ImageManager_default.releaseReservation(this._imageReservationId);
        this._imageReservationId = null;
        return true;
      } else {
        return false;
      }
    }
    // Change Battle Back
    command283() {
      self.$gameMap.changeBattleback(this._params[0], this._params[1]);
      return true;
    }
    // Change Parallax
    command284() {
      self.$gameMap.changeParallax(
        this._params[0],
        this._params[1],
        this._params[2],
        this._params[3],
        this._params[4]
      );
      return true;
    }
    // Get Location Info
    command285() {
      let x;
      let y;
      let value3;
      if (this._params[2] === 0) {
        x = this._params[3];
        y = this._params[4];
      } else {
        x = self.$gameVariables.value(this._params[3]);
        y = self.$gameVariables.value(this._params[4]);
      }
      switch (this._params[1]) {
        case 0:
          value3 = self.$gameMap.terrainTag(x, y);
          break;
        case 1:
          value3 = self.$gameMap.eventIdXy(x, y);
          break;
        case 2:
        case 3:
        case 4:
        case 5:
          value3 = self.$gameMap.tileId(x, y, this._params[1] - 2);
          break;
        default:
          value3 = self.$gameMap.regionId(x, y);
          break;
      }
      self.$gameVariables.setValue(this._params[0], value3);
      return true;
    }
    // Battle Processing
    command301() {
      if (!self.$gameParty.inBattle()) {
        let troopId;
        if (this._params[0] === 0) {
          troopId = this._params[1];
        } else if (this._params[0] === 1) {
          troopId = self.$gameVariables.value(this._params[1]);
        } else {
          troopId = self.$gamePlayer.makeEncounterTroopId();
        }
        if (self.$dataTroops[troopId]) {
          BattleManager_default.setup(troopId, this._params[2], this._params[3]);
          BattleManager_default.setEventCallback((n) => {
            this._branch[this._indent] = n;
          });
          self.$gamePlayer.makeEncounterCount();
          SceneManager_default.push(Scene_Battle_default);
        }
      }
      return true;
    }
    // If Win
    command601() {
      if (this._branch[this._indent] !== 0) {
        this.skipBranch();
      }
      return true;
    }
    // If Escape
    command602() {
      if (this._branch[this._indent] !== 1) {
        this.skipBranch();
      }
      return true;
    }
    // If Lose
    command603() {
      if (this._branch[this._indent] !== 2) {
        this.skipBranch();
      }
      return true;
    }
    // Shop Processing
    command302() {
      if (!self.$gameParty.inBattle()) {
        const goods = [this._params];
        while (this.nextEventCode() === 605) {
          this._index++;
          goods.push(this.currentCommand().parameters);
        }
        SceneManager_default.push(Scene_Shop_default);
        SceneManager_default.prepareNextScene(goods, this._params[4]);
      }
      return true;
    }
    // Name Input Processing
    command303() {
      if (!self.$gameParty.inBattle()) {
        if (self.$dataActors[this._params[0]]) {
          SceneManager_default.push(Scene_Name_default);
          SceneManager_default.prepareNextScene(this._params[0], this._params[1]);
        }
      }
      return true;
    }
    // Change HP
    command311() {
      const value3 = this.operateValue(
        this._params[2],
        this._params[3],
        this._params[4]
      );
      this.iterateActorEx(this._params[0], this._params[1], (actor2) => {
        this.changeHp(actor2, value3, this._params[5]);
      });
      return true;
    }
    // Change MP
    command312() {
      const value3 = this.operateValue(
        this._params[2],
        this._params[3],
        this._params[4]
      );
      this.iterateActorEx(this._params[0], this._params[1], (actor2) => {
        actor2.gainMp(value3);
      });
      return true;
    }
    // Change TP
    command326() {
      const value3 = this.operateValue(
        this._params[2],
        this._params[3],
        this._params[4]
      );
      this.iterateActorEx(this._params[0], this._params[1], (actor2) => {
        actor2.gainTp(value3);
      });
      return true;
    }
    // Change State
    command313() {
      this.iterateActorEx(this._params[0], this._params[1], (actor2) => {
        const alreadyDead = actor2.isDead();
        if (this._params[2] === 0) {
          actor2.addState(this._params[3]);
        } else {
          actor2.removeState(this._params[3]);
        }
        if (actor2.isDead() && !alreadyDead) {
          actor2.performCollapse();
        }
        actor2.clearResult();
      });
      return true;
    }
    // Recover All
    command314() {
      this.iterateActorEx(this._params[0], this._params[1], (actor2) => {
        actor2.recoverAll();
      });
      return true;
    }
    // Change EXP
    command315() {
      const value3 = this.operateValue(
        this._params[2],
        this._params[3],
        this._params[4]
      );
      this.iterateActorEx(this._params[0], this._params[1], (actor2) => {
        actor2.changeExp(actor2.currentExp() + value3, this._params[5]);
      });
      return true;
    }
    // Change Level
    command316() {
      const value3 = this.operateValue(
        this._params[2],
        this._params[3],
        this._params[4]
      );
      this.iterateActorEx(this._params[0], this._params[1], (actor2) => {
        actor2.changeLevel(actor2.level + value3, this._params[5]);
      });
      return true;
    }
    // Change Parameter
    command317() {
      const value3 = this.operateValue(
        this._params[3],
        this._params[4],
        this._params[5]
      );
      this.iterateActorEx(this._params[0], this._params[1], (actor2) => {
        actor2.addParam(this._params[2], value3);
      });
      return true;
    }
    // Change Skill
    command318() {
      this.iterateActorEx(this._params[0], this._params[1], (actor2) => {
        if (this._params[2] === 0) {
          actor2.learnSkill(this._params[3]);
        } else {
          actor2.forgetSkill(this._params[3]);
        }
      });
      return true;
    }
    // Change Equipment
    command319() {
      const actor2 = self.$gameActors.actor(this._params[0]);
      if (actor2) {
        actor2.changeEquipById(this._params[1], this._params[2]);
      }
      return true;
    }
    // Change Name
    command320() {
      const actor2 = self.$gameActors.actor(this._params[0]);
      if (actor2) {
        actor2.setName(this._params[1]);
      }
      return true;
    }
    // Change Class
    command321() {
      const actor2 = self.$gameActors.actor(this._params[0]);
      if (actor2 && self.$dataClasses[this._params[1]]) {
        actor2.changeClass(this._params[1], this._params[2]);
      }
      return true;
    }
    // Change Actor Images
    command322() {
      const actor2 = self.$gameActors.actor(this._params[0]);
      if (actor2) {
        actor2.setCharacterImage(this._params[1], this._params[2]);
        actor2.setFaceImage(this._params[3], this._params[4]);
        actor2.setBattlerImage(this._params[5]);
      }
      self.$gamePlayer.refresh();
      return true;
    }
    // Change Vehicle Image
    command323() {
      const vehicle = self.$gameMap.vehicle(this._params[0]);
      if (vehicle) {
        vehicle.setImage(this._params[1], this._params[2]);
      }
      return true;
    }
    // Change Nickname
    command324() {
      const actor2 = self.$gameActors.actor(this._params[0]);
      if (actor2) {
        actor2.setNickname(this._params[1]);
      }
      return true;
    }
    // Change Profile
    command325() {
      const actor2 = self.$gameActors.actor(this._params[0]);
      if (actor2) {
        actor2.setProfile(this._params[1]);
      }
      return true;
    }
    // Change Enemy HP
    command331() {
      const value3 = this.operateValue(
        this._params[1],
        this._params[2],
        this._params[3]
      );
      this.iterateEnemyIndex(this._params[0], (enemy2) => {
        this.changeHp(enemy2, value3, this._params[4]);
      });
      return true;
    }
    // Change Enemy MP
    command332() {
      const value3 = this.operateValue(
        this._params[1],
        this._params[2],
        this._params[3]
      );
      this.iterateEnemyIndex(this._params[0], (enemy2) => {
        enemy2.gainMp(value3);
      });
      return true;
    }
    // Change Enemy TP
    command342() {
      const value3 = this.operateValue(
        this._params[1],
        this._params[2],
        this._params[3]
      );
      this.iterateEnemyIndex(this._params[0], (enemy2) => {
        enemy2.gainTp(value3);
      });
      return true;
    }
    // Change Enemy State
    command333() {
      this.iterateEnemyIndex(this._params[0], (enemy2) => {
        const alreadyDead = enemy2.isDead();
        if (this._params[1] === 0) {
          enemy2.addState(this._params[2]);
        } else {
          enemy2.removeState(this._params[2]);
        }
        if (enemy2.isDead() && !alreadyDead) {
          enemy2.performCollapse();
        }
        enemy2.clearResult();
      });
      return true;
    }
    // Enemy Recover All
    command334() {
      this.iterateEnemyIndex(this._params[0], (enemy2) => {
        enemy2.recoverAll();
      });
      return true;
    }
    // Enemy Appear
    command335() {
      this.iterateEnemyIndex(this._params[0], (enemy2) => {
        enemy2.appear();
        self.$gameTroop.makeUniqueNames();
      });
      return true;
    }
    // Enemy Transform
    command336() {
      this.iterateEnemyIndex(this._params[0], (enemy2) => {
        enemy2.transform(this._params[1]);
        self.$gameTroop.makeUniqueNames();
      });
      return true;
    }
    // Show Battle Animation
    command337() {
      if (this._params[2] == true) {
        this.iterateEnemyIndex(-1, (enemy2) => {
          if (enemy2.isAlive()) {
            enemy2.startAnimation(this._params[1], false, 0);
          }
        });
      } else {
        this.iterateEnemyIndex(this._params[0], (enemy2) => {
          if (enemy2.isAlive()) {
            enemy2.startAnimation(this._params[1], false, 0);
          }
        });
      }
      return true;
    }
    // Force Action
    command339() {
      this.iterateBattler(this._params[0], this._params[1], (battler) => {
        if (!battler.isDeathStateAffected()) {
          battler.forceAction(this._params[2], this._params[3]);
          BattleManager_default.forceAction(battler);
          this.setWaitMode("action");
        }
      });
      return true;
    }
    // Abort Battle
    command340() {
      BattleManager_default.abort();
      return true;
    }
    // Open Menu Screen
    command351() {
      if (!self.$gameParty.inBattle()) {
        SceneManager_default.push(Scene_Menu_default);
        Window_MenuCommand_default.initCommandPosition();
      }
      return true;
    }
    // Open Save Screen
    command352() {
      if (!self.$gameParty.inBattle()) {
        SceneManager_default.push(Scene_Save_default);
      }
      return true;
    }
    // Game Over
    command353() {
      SceneManager_default.goto(Scene_Gameover_default);
      return true;
    }
    // Return to Title Screen
    command354() {
      SceneManager_default.goto(Scene_Title_default);
      return true;
    }
    // Script
    command355() {
      const startLine = this._index + 1;
      let script = `${this.currentCommand().parameters[0]}
`;
      while (this.nextEventCode() === 655) {
        this._index++;
        script += `${this.currentCommand().parameters[0]}
`;
      }
      const endLine = this._index + 1;
      try {
        eval(script);
      } catch (error) {
        error.line = `${startLine}-${endLine}`;
        error.eventCommand = "script";
        error.content = script;
        throw error;
      }
      return true;
    }
    // Plugin Command
    command356() {
      const args = this._params[0].split(" ");
      const command2 = args.shift();
      try {
        this.pluginCommand(command2, args);
      } catch (error) {
        error.eventCommand = "plugin_command";
        error.content = this._params[0];
        throw error;
      }
      return true;
    }
    pluginCommand(command2, args) {
    }
    static requestImagesByPluginCommand(command2, args) {
    }
    static requestImagesForCommand({ parameters, code }) {
      const params2 = parameters;
      switch (code) {
        case 101:
          ImageManager_default.requestFace(params2[0]);
          break;
        case 129:
          const actor2 = self.$gameActors.actor(params2[0]);
          if (actor2 && params2[1] === 0) {
            const name2 = actor2.characterName();
            ImageManager_default.requestCharacter(name2);
          }
          break;
        case 205:
          if (params2[1]) {
            params2[1].list.forEach(({ parameters: parameters2, code: code2 }) => {
              const params3 = parameters2;
              if (code2 === Game_Character_default.ROUTE_CHANGE_IMAGE) {
                ImageManager_default.requestCharacter(params3[0]);
              }
            });
          }
          break;
        case 212:
        case 337:
          if (params2[1]) {
            const animation = self.$dataAnimations[params2[1]];
            const name1 = animation.animation1Name;
            const name2 = animation.animation2Name;
            const hue1 = animation.animation1Hue;
            const hue2 = animation.animation2Hue;
            ImageManager_default.requestAnimation(name1, hue1);
            ImageManager_default.requestAnimation(name2, hue2);
          }
          break;
        case 216:
          if (params2[0] === 0) {
            self.$gamePlayer.followers().forEach((follower) => {
              const name2 = follower.characterName();
              ImageManager_default.requestCharacter(name2);
            });
          }
          break;
        case 231:
          ImageManager_default.requestPicture(params2[1]);
          break;
        case 282:
          const tileset = self.$dataTilesets[params2[0]];
          tileset.tilesetNames.forEach((tilesetName) => {
            ImageManager_default.requestTileset(tilesetName);
          });
          break;
        case 283:
          if (self.$gameParty.inBattle()) {
            ImageManager_default.requestBattleback1(params2[0]);
            ImageManager_default.requestBattleback2(params2[1]);
          }
          break;
        case 284:
          if (!self.$gameParty.inBattle()) {
            ImageManager_default.requestParallax(params2[0]);
          }
          break;
        case 322:
          ImageManager_default.requestCharacter(params2[1]);
          ImageManager_default.requestFace(params2[3]);
          ImageManager_default.requestSvActor(params2[5]);
          break;
        case 323:
          const vehicle = self.$gameMap.vehicle(params2[0]);
          if (vehicle) {
            ImageManager_default.requestCharacter(params2[1]);
          }
          break;
        case 336:
          const enemy2 = self.$dataEnemies[params2[1]];
          const name = enemy2.battlerName;
          const hue = enemy2.battlerHue;
          if (self.$gameSystem.isSideView()) {
            ImageManager_default.requestSvEnemy(name, hue);
          } else {
            ImageManager_default.requestEnemy(name, hue);
          }
          break;
        case 356:
          const args = params2[0].split(" ");
          const commandName = args.shift();
          _Game_Interpreter.requestImagesByPluginCommand(commandName, args);
          break;
      }
    }
    static requestImagesByChildEvent({ parameters }, commonList) {
      const params2 = parameters;
      const commonEvent = self.$dataCommonEvents[params2[0]];
      if (commonEvent) {
        if (!commonList) {
          commonList = [];
        }
        if (!commonList.contains(params2[0])) {
          commonList.push(params2[0]);
          _Game_Interpreter.requestImages(commonEvent.list, commonList);
        }
      }
    }
    static requestImages(list, commonList) {
      if (!list) {
        return;
      }
      const len = list.length;
      for (let i = 0; i < len; i += 1) {
        const command2 = list[i];
        if (command2.code === 117) {
          _Game_Interpreter.requestImagesByChildEvent(command2, commonList);
        } else {
          _Game_Interpreter.requestImagesForCommand(command2);
        }
      }
    }
  };
  var Game_Interpreter_default = _Game_Interpreter;

  // src-www/js/rpg_objects/Game_Troop.js
  var Game_Troop = class extends Game_Unit_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
      this._interpreter = new Game_Interpreter_default();
      this.clear();
    }
    isEventRunning() {
      return this._interpreter.isRunning();
    }
    updateInterpreter() {
      this._interpreter.update();
    }
    turnCount() {
      return this._turnCount;
    }
    members() {
      return this._enemies;
    }
    clear() {
      this._interpreter.clear();
      this._troopId = 0;
      this._eventFlags = {};
      this._enemies = [];
      this._turnCount = 0;
      this._namesCount = {};
    }
    troop() {
      return self.$dataTroops[this._troopId];
    }
    setup(troopId) {
      this.clear();
      this._troopId = troopId;
      this._enemies = [];
      this.troop().members.forEach(function(member) {
        if (self.$dataEnemies[member.enemyId]) {
          const enemyId = member.enemyId;
          const x = member.x;
          const y = member.y;
          const enemy2 = new Game_Enemy_default(enemyId, x, y);
          if (member.hidden) {
            enemy2.hide();
          }
          this._enemies.push(enemy2);
        }
      }, this);
      this.makeUniqueNames();
    }
    makeUniqueNames() {
      const table = this.letterTable();
      this.members().forEach(function(enemy2) {
        if (enemy2.isAlive() && enemy2.isLetterEmpty()) {
          const name = enemy2.originalName();
          const n = this._namesCount[name] || 0;
          enemy2.setLetter(table[n % table.length]);
          this._namesCount[name] = n + 1;
        }
      }, this);
      this.members().forEach(function(enemy2) {
        const name = enemy2.originalName();
        if (this._namesCount[name] >= 2) {
          enemy2.setPlural(true);
        }
      }, this);
    }
    letterTable() {
      return self.$gameSystem.isCJK() ? Game_Troop.LETTER_TABLE_FULL : Game_Troop.LETTER_TABLE_HALF;
    }
    enemyNames() {
      const names = [];
      this.members().forEach((enemy2) => {
        const name = enemy2.originalName();
        if (enemy2.isAlive() && !names.contains(name)) {
          names.push(name);
        }
      });
      return names;
    }
    meetsConditions({ conditions }) {
      const c = conditions;
      if (!c.turnEnding && !c.turnValid && !c.enemyValid && !c.actorValid && !c.switchValid) {
        return false;
      }
      if (c.turnEnding) {
        if (!BattleManager_default.isTurnEnd()) {
          return false;
        }
      }
      if (c.turnValid) {
        const n = this._turnCount;
        const a2 = c.turnA;
        const b2 = c.turnB;
        if (b2 === 0 && n !== a2) {
          return false;
        }
        if (b2 > 0 && (n < 1 || n < a2 || n % b2 !== a2 % b2)) {
          return false;
        }
      }
      if (c.enemyValid) {
        const enemy2 = self.$gameTroop.members()[c.enemyIndex];
        if (!enemy2 || enemy2.hpRate() * 100 > c.enemyHp) {
          return false;
        }
      }
      if (c.actorValid) {
        const actor2 = self.$gameActors.actor(c.actorId);
        if (!actor2 || actor2.hpRate() * 100 > c.actorHp) {
          return false;
        }
      }
      if (c.switchValid) {
        if (!self.$gameSwitches.value(c.switchId)) {
          return false;
        }
      }
      return true;
    }
    setupBattleEvent() {
      if (!this._interpreter.isRunning()) {
        if (this._interpreter.setupReservedCommonEvent()) {
          return;
        }
        const pages = this.troop().pages;
        for (let i = 0; i < pages.length; i++) {
          const page = pages[i];
          if (this.meetsConditions(page) && !this._eventFlags[i]) {
            this._interpreter.setup(page.list);
            this._interpreter.setEventInfo({
              eventType: "battle_event",
              troopId: this._troopId,
              page: i + 1
            });
            if (page.span <= 1) {
              this._eventFlags[i] = true;
            }
            break;
          }
        }
      }
    }
    increaseTurn() {
      const pages = this.troop().pages;
      pages.forEach(({ span }, i) => {
        if (span === 1) {
          this._eventFlags[i] = false;
        }
      });
      this._turnCount++;
    }
    expTotal() {
      return this.deadMembers().reduce((r, enemy2) => r + enemy2.exp(), 0);
    }
    goldTotal() {
      return this.deadMembers().reduce((r, enemy2) => r + enemy2.gold(), 0) * this.goldRate();
    }
    goldRate() {
      return self.$gameParty.hasGoldDouble() ? 2 : 1;
    }
    makeDropItems() {
      return this.deadMembers().reduce(
        (r, enemy2) => r.concat(enemy2.makeDropItems()),
        []
      );
    }
  };
  Game_Troop.LETTER_TABLE_HALF = [
    " A",
    " B",
    " C",
    " D",
    " E",
    " F",
    " G",
    " H",
    " I",
    " J",
    " K",
    " L",
    " M",
    " N",
    " O",
    " P",
    " Q",
    " R",
    " S",
    " T",
    " U",
    " V",
    " W",
    " X",
    " Y",
    " Z"
  ];
  Game_Troop.LETTER_TABLE_FULL = [
    "\uFF21",
    "\uFF22",
    "\uFF23",
    "\uFF24",
    "\uFF25",
    "\uFF26",
    "\uFF27",
    "\uFF28",
    "\uFF29",
    "\uFF2A",
    "\uFF2B",
    "\uFF2C",
    "\uFF2D",
    "\uFF2E",
    "\uFF2F",
    "\uFF30",
    "\uFF31",
    "\uFF32",
    "\uFF33",
    "\uFF34",
    "\uFF35",
    "\uFF36",
    "\uFF37",
    "\uFF38",
    "\uFF39",
    "\uFF3A"
  ];
  var Game_Troop_default = Game_Troop;

  // src-www/js/rpg_objects/Game_CommonEvent.js
  var Game_CommonEvent = class {
    constructor(...args) {
      this.initialize(...args);
    }
    initialize(commonEventId) {
      this._commonEventId = commonEventId;
      this.refresh();
    }
    event() {
      return self.$dataCommonEvents[this._commonEventId];
    }
    list() {
      return this.event().list;
    }
    refresh() {
      if (this.isActive()) {
        if (!this._interpreter) {
          this._interpreter = new Game_Interpreter_default();
        }
      } else {
        this._interpreter = null;
      }
    }
    isActive() {
      const event = this.event();
      return event.trigger === 2 && self.$gameSwitches.value(event.switchId);
    }
    update() {
      if (this._interpreter) {
        if (!this._interpreter.isRunning()) {
          this._interpreter.setup(this.list());
          this._interpreter.setEventInfo({
            eventType: "common_event",
            commonEventId: this._commonEventId
          });
        }
        this._interpreter.update();
      }
    }
  };
  var Game_CommonEvent_default = Game_CommonEvent;

  // src-www/js/rpg_objects/Game_Vehicle.js
  var Game_Vehicle = class extends Game_Character_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(type) {
      super.initialize();
      this._type = type;
      this.resetDirection();
      this.initMoveSpeed();
      this.loadSystemSettings();
    }
    initMembers() {
      super.initMembers();
      this._type = "";
      this._mapId = 0;
      this._altitude = 0;
      this._driving = false;
      this._bgm = null;
    }
    isBoat() {
      return this._type === "boat";
    }
    isShip() {
      return this._type === "ship";
    }
    isAirship() {
      return this._type === "airship";
    }
    resetDirection() {
      this.setDirection(4);
    }
    initMoveSpeed() {
      if (this.isBoat()) {
        this.setMoveSpeed(4);
      } else if (this.isShip()) {
        this.setMoveSpeed(5);
      } else if (this.isAirship()) {
        this.setMoveSpeed(6);
      }
    }
    vehicle() {
      if (this.isBoat()) {
        return self.$dataSystem.boat;
      } else if (this.isShip()) {
        return self.$dataSystem.ship;
      } else if (this.isAirship()) {
        return self.$dataSystem.airship;
      } else {
        return null;
      }
    }
    loadSystemSettings() {
      const vehicle = this.vehicle();
      this._mapId = vehicle.startMapId;
      this.setPosition(vehicle.startX, vehicle.startY);
      this.setImage(vehicle.characterName, vehicle.characterIndex);
    }
    refresh() {
      if (this._driving) {
        this._mapId = self.$gameMap.mapId();
        this.syncWithPlayer();
      } else if (this._mapId === self.$gameMap.mapId()) {
        this.locate(this.x, this.y);
      }
      if (this.isAirship()) {
        this.setPriorityType(this._driving ? 2 : 0);
      } else {
        this.setPriorityType(1);
      }
      this.setWalkAnime(this._driving);
      this.setStepAnime(this._driving);
      this.setTransparent(this._mapId !== self.$gameMap.mapId());
    }
    setLocation(mapId, x, y) {
      this._mapId = mapId;
      this.setPosition(x, y);
      this.refresh();
    }
    pos(x, y) {
      if (this._mapId === self.$gameMap.mapId()) {
        return Game_Character_default.prototype.pos.call(this, x, y);
      } else {
        return false;
      }
    }
    isMapPassable(x, y, d) {
      const x2 = self.$gameMap.roundXWithDirection(x, d);
      const y2 = self.$gameMap.roundYWithDirection(y, d);
      if (this.isBoat()) {
        return self.$gameMap.isBoatPassable(x2, y2);
      } else if (this.isShip()) {
        return self.$gameMap.isShipPassable(x2, y2);
      } else if (this.isAirship()) {
        return true;
      } else {
        return false;
      }
    }
    getOn() {
      this._driving = true;
      this.setWalkAnime(true);
      this.setStepAnime(true);
      self.$gameSystem.saveWalkingBgm();
      this.playBgm();
    }
    getOff() {
      this._driving = false;
      this.setWalkAnime(false);
      this.setStepAnime(false);
      this.resetDirection();
      self.$gameSystem.replayWalkingBgm();
    }
    setBgm(bgm) {
      this._bgm = bgm;
    }
    playBgm() {
      AudioManager_default.playBgm(this._bgm || this.vehicle().bgm);
    }
    syncWithPlayer() {
      this.copyPosition(self.$gamePlayer);
      this.refreshBushDepth();
    }
    screenY() {
      return Game_Character_default.prototype.screenY.call(this) - this._altitude;
    }
    shadowX() {
      return this.screenX();
    }
    shadowY() {
      return this.screenY() + this._altitude;
    }
    shadowOpacity() {
      return 255 * this._altitude / this.maxAltitude();
    }
    canMove() {
      if (this.isAirship()) {
        return this.isHighest();
      } else {
        return true;
      }
    }
    update() {
      super.update();
      if (this.isAirship()) {
        this.updateAirship();
      }
    }
    updateAirship() {
      this.updateAirshipAltitude();
      this.setStepAnime(this.isHighest());
      this.setPriorityType(this.isLowest() ? 0 : 2);
    }
    updateAirshipAltitude() {
      if (this._driving && !this.isHighest()) {
        this._altitude++;
      }
      if (!this._driving && !this.isLowest()) {
        this._altitude--;
      }
    }
    maxAltitude() {
      return 48;
    }
    isLowest() {
      return this._altitude <= 0;
    }
    isHighest() {
      return this._altitude >= this.maxAltitude();
    }
    isTakeoffOk() {
      return self.$gamePlayer.areFollowersGathered();
    }
    isLandOk(x, y, d) {
      if (this.isAirship()) {
        if (!self.$gameMap.isAirshipLandOk(x, y)) {
          return false;
        }
        if (self.$gameMap.eventsXy(x, y).length > 0) {
          return false;
        }
      } else {
        const x2 = self.$gameMap.roundXWithDirection(x, d);
        const y2 = self.$gameMap.roundYWithDirection(y, d);
        if (!self.$gameMap.isValid(x2, y2)) {
          return false;
        }
        if (!self.$gameMap.isPassable(x2, y2, this.reverseDir(d))) {
          return false;
        }
        if (this.isCollidedWithCharacters(x2, y2)) {
          return false;
        }
      }
      return true;
    }
  };
  var Game_Vehicle_default = Game_Vehicle;

  // src-www/js/rpg_objects/Game_Event.js
  var Game_Event = class extends Game_Character_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(mapId, eventId) {
      super.initialize();
      this._mapId = mapId;
      this._eventId = eventId;
      this.locate(this.event().x, this.event().y);
      this.refresh();
    }
    initMembers() {
      super.initMembers();
      this._moveType = 0;
      this._trigger = 0;
      this._starting = false;
      this._erased = false;
      this._pageIndex = -2;
      this._originalPattern = 1;
      this._originalDirection = 2;
      this._prelockDirection = 0;
      this._locked = false;
    }
    eventId() {
      return this._eventId;
    }
    event() {
      return self.$dataMap.events[this._eventId];
    }
    page() {
      return this.event().pages[this._pageIndex];
    }
    list() {
      return this.page().list;
    }
    isCollidedWithCharacters(x, y) {
      return Game_Character_default.prototype.isCollidedWithCharacters.call(this, x, y) || this.isCollidedWithPlayerCharacters(x, y);
    }
    isCollidedWithEvents(x, y) {
      const events = self.$gameMap.eventsXyNt(x, y);
      return events.length > 0;
    }
    isCollidedWithPlayerCharacters(x, y) {
      return this.isNormalPriority() && self.$gamePlayer.isCollided(x, y);
    }
    lock() {
      if (!this._locked) {
        this._prelockDirection = this.direction();
        this.turnTowardPlayer();
        this._locked = true;
      }
    }
    unlock() {
      if (this._locked) {
        this._locked = false;
        this.setDirection(this._prelockDirection);
      }
    }
    updateStop() {
      if (this._locked) {
        this.resetStopCount();
      }
      super.updateStop();
      if (!this.isMoveRouteForcing()) {
        this.updateSelfMovement();
      }
    }
    updateSelfMovement() {
      if (!this._locked && this.isNearTheScreen() && this.checkStop(this.stopCountThreshold())) {
        switch (this._moveType) {
          case 1:
            this.moveTypeRandom();
            break;
          case 2:
            this.moveTypeTowardPlayer();
            break;
          case 3:
            this.moveTypeCustom();
            break;
        }
      }
    }
    stopCountThreshold() {
      return 30 * (5 - this.moveFrequency());
    }
    moveTypeRandom() {
      switch (Math.randomInt(6)) {
        case 0:
        case 1:
          this.moveRandom();
          break;
        case 2:
        case 3:
        case 4:
          this.moveForward();
          break;
        case 5:
          this.resetStopCount();
          break;
      }
    }
    moveTypeTowardPlayer() {
      if (this.isNearThePlayer()) {
        switch (Math.randomInt(6)) {
          case 0:
          case 1:
          case 2:
          case 3:
            this.moveTowardPlayer();
            break;
          case 4:
            this.moveRandom();
            break;
          case 5:
            this.moveForward();
            break;
        }
      } else {
        this.moveRandom();
      }
    }
    isNearThePlayer() {
      const sx = Math.abs(this.deltaXFrom(self.$gamePlayer.x));
      const sy = Math.abs(this.deltaYFrom(self.$gamePlayer.y));
      return sx + sy < 20;
    }
    moveTypeCustom() {
      this.updateRoutineMove();
    }
    isStarting() {
      return this._starting;
    }
    clearStartingFlag() {
      this._starting = false;
    }
    isTriggerIn(triggers) {
      return triggers.contains(this._trigger);
    }
    start() {
      const list = this.list();
      if (list && list.length > 1) {
        this._starting = true;
        if (this.isTriggerIn([0, 1, 2])) {
          this.lock();
        }
      }
    }
    erase() {
      this._erased = true;
      this.refresh();
    }
    refresh() {
      const newPageIndex = this._erased ? -1 : this.findProperPageIndex();
      if (this._pageIndex !== newPageIndex) {
        this._pageIndex = newPageIndex;
        this.setupPage();
      }
    }
    findProperPageIndex() {
      const pages = this.event().pages;
      for (let i = pages.length - 1; i >= 0; i--) {
        const page = pages[i];
        if (this.meetsConditions(page)) {
          return i;
        }
      }
      return -1;
    }
    meetsConditions({ conditions }) {
      const c = conditions;
      if (c.switch1Valid) {
        if (!self.$gameSwitches.value(c.switch1Id)) {
          return false;
        }
      }
      if (c.switch2Valid) {
        if (!self.$gameSwitches.value(c.switch2Id)) {
          return false;
        }
      }
      if (c.variableValid) {
        if (self.$gameVariables.value(c.variableId) < c.variableValue) {
          return false;
        }
      }
      if (c.selfSwitchValid) {
        const key = [this._mapId, this._eventId, c.selfSwitchCh];
        if (self.$gameSelfSwitches.value(key) !== true) {
          return false;
        }
      }
      if (c.itemValid) {
        const item2 = self.$dataItems[c.itemId];
        if (!self.$gameParty.hasItem(item2)) {
          return false;
        }
      }
      if (c.actorValid) {
        const actor2 = self.$gameActors.actor(c.actorId);
        if (!self.$gameParty.members().contains(actor2)) {
          return false;
        }
      }
      return true;
    }
    setupPage() {
      if (this._pageIndex >= 0) {
        this.setupPageSettings();
      } else {
        this.clearPageSettings();
      }
      this.refreshBushDepth();
      this.clearStartingFlag();
      this.checkEventTriggerAuto();
    }
    clearPageSettings() {
      this.setImage("", 0);
      this._moveType = 0;
      this._trigger = null;
      this._interpreter = null;
      this.setThrough(true);
    }
    setupPageSettings() {
      const page = this.page();
      const image = page.image;
      if (image.tileId > 0) {
        this.setTileImage(image.tileId);
      } else {
        this.setImage(image.characterName, image.characterIndex);
      }
      if (this._originalDirection !== image.direction) {
        this._originalDirection = image.direction;
        this._prelockDirection = 0;
        this.setDirectionFix(false);
        this.setDirection(image.direction);
      }
      if (this._originalPattern !== image.pattern) {
        this._originalPattern = image.pattern;
        this.setPattern(image.pattern);
      }
      this.setMoveSpeed(page.moveSpeed);
      this.setMoveFrequency(page.moveFrequency);
      this.setPriorityType(page.priorityType);
      this.setWalkAnime(page.walkAnime);
      this.setStepAnime(page.stepAnime);
      this.setDirectionFix(page.directionFix);
      this.setThrough(page.through);
      this.setMoveRoute(page.moveRoute);
      this._moveType = page.moveType;
      this._trigger = page.trigger;
      if (this._trigger === 4) {
        this._interpreter = new Game_Interpreter_default();
      } else {
        this._interpreter = null;
      }
    }
    isOriginalPattern() {
      return this.pattern() === this._originalPattern;
    }
    resetPattern() {
      this.setPattern(this._originalPattern);
    }
    checkEventTriggerTouch(x, y) {
      if (!self.$gameMap.isEventRunning()) {
        if (this._trigger === 2 && self.$gamePlayer.pos(x, y)) {
          if (!this.isJumping() && this.isNormalPriority()) {
            this.start();
          }
        }
      }
    }
    checkEventTriggerAuto() {
      if (this._trigger === 3) {
        this.start();
      }
    }
    update() {
      super.update();
      this.checkEventTriggerAuto();
      this.updateParallel();
    }
    updateParallel() {
      if (this._interpreter) {
        if (!this._interpreter.isRunning()) {
          this._interpreter.setup(this.list(), this._eventId);
          this._interpreter.setEventInfo(this.getEventInfo());
        }
        this._interpreter.update();
      }
    }
    locate(x, y) {
      super.locate(x, y);
      this._prelockDirection = 0;
    }
    forceMoveRoute(moveRoute) {
      super.forceMoveRoute(moveRoute);
      this._prelockDirection = 0;
    }
    getEventInfo() {
      return {
        eventType: "map_event",
        mapId: this._mapId,
        mapEventId: this._eventId,
        page: this._pageIndex + 1
      };
    }
  };
  var Game_Event_default = Game_Event;

  // src-www/js/rpg_objects/Game_Map.js
  var Game_Map = class {
    constructor(...args) {
      this.initialize(...args);
    }
    initialize() {
      this._interpreter = new Game_Interpreter_default();
      this._mapId = 0;
      this._tilesetId = 0;
      this._events = [];
      this._commonEvents = [];
      this._vehicles = [];
      this._displayX = 0;
      this._displayY = 0;
      this._nameDisplay = true;
      this._scrollDirection = 2;
      this._scrollRest = 0;
      this._scrollSpeed = 4;
      this._parallaxName = "";
      this._parallaxZero = false;
      this._parallaxLoopX = false;
      this._parallaxLoopY = false;
      this._parallaxSx = 0;
      this._parallaxSy = 0;
      this._parallaxX = 0;
      this._parallaxY = 0;
      this._battleback1Name = null;
      this._battleback2Name = null;
      this.createVehicles();
    }
    setup(mapId) {
      if (!self.$dataMap) {
        throw new Error("The map data is not available");
      }
      this._mapId = mapId;
      this._tilesetId = self.$dataMap.tilesetId;
      this._displayX = 0;
      this._displayY = 0;
      this.refereshVehicles();
      this.setupEvents();
      this.setupScroll();
      this.setupParallax();
      this.setupBattleback();
      this._needsRefresh = false;
    }
    isEventRunning() {
      return this._interpreter.isRunning() || this.isAnyEventStarting();
    }
    tileWidth() {
      return 48;
    }
    tileHeight() {
      return 48;
    }
    mapId() {
      return this._mapId;
    }
    tilesetId() {
      return this._tilesetId;
    }
    displayX() {
      return this._displayX;
    }
    displayY() {
      return this._displayY;
    }
    parallaxName() {
      return this._parallaxName;
    }
    battleback1Name() {
      return this._battleback1Name;
    }
    battleback2Name() {
      return this._battleback2Name;
    }
    requestRefresh(mapId) {
      this._needsRefresh = true;
    }
    isNameDisplayEnabled() {
      return this._nameDisplay;
    }
    disableNameDisplay() {
      this._nameDisplay = false;
    }
    enableNameDisplay() {
      this._nameDisplay = true;
    }
    createVehicles() {
      this._vehicles = [];
      this._vehicles[0] = new Game_Vehicle_default("boat");
      this._vehicles[1] = new Game_Vehicle_default("ship");
      this._vehicles[2] = new Game_Vehicle_default("airship");
    }
    refereshVehicles() {
      this._vehicles.forEach((vehicle) => {
        vehicle.refresh();
      });
    }
    vehicles() {
      return this._vehicles;
    }
    vehicle(type) {
      if (type === 0 || type === "boat") {
        return this.boat();
      } else if (type === 1 || type === "ship") {
        return this.ship();
      } else if (type === 2 || type === "airship") {
        return this.airship();
      } else {
        return null;
      }
    }
    boat() {
      return this._vehicles[0];
    }
    ship() {
      return this._vehicles[1];
    }
    airship() {
      return this._vehicles[2];
    }
    setupEvents() {
      this._events = [];
      for (let i = 0; i < self.$dataMap.events.length; i++) {
        if (self.$dataMap.events[i]) {
          this._events[i] = new Game_Event_default(this._mapId, i);
        }
      }
      this._commonEvents = this.parallelCommonEvents().map(
        ({ id }) => new Game_CommonEvent_default(id)
      );
      this.refreshTileEvents();
    }
    events() {
      return this._events.filter((event) => !!event);
    }
    event(eventId) {
      return this._events[eventId];
    }
    eraseEvent(eventId) {
      this._events[eventId].erase();
    }
    parallelCommonEvents() {
      return self.$dataCommonEvents.filter(
        (commonEvent) => commonEvent && commonEvent.trigger === 2
      );
    }
    setupScroll() {
      this._scrollDirection = 2;
      this._scrollRest = 0;
      this._scrollSpeed = 4;
    }
    setupParallax() {
      this._parallaxName = self.$dataMap.parallaxName || "";
      this._parallaxZero = ImageManager_default.isZeroParallax(this._parallaxName);
      this._parallaxLoopX = self.$dataMap.parallaxLoopX;
      this._parallaxLoopY = self.$dataMap.parallaxLoopY;
      this._parallaxSx = self.$dataMap.parallaxSx;
      this._parallaxSy = self.$dataMap.parallaxSy;
      this._parallaxX = 0;
      this._parallaxY = 0;
    }
    setupBattleback() {
      if (self.$dataMap.specifyBattleback) {
        this._battleback1Name = self.$dataMap.battleback1Name;
        this._battleback2Name = self.$dataMap.battleback2Name;
      } else {
        this._battleback1Name = null;
        this._battleback2Name = null;
      }
    }
    setDisplayPos(x, y) {
      if (this.isLoopHorizontal()) {
        this._displayX = x.mod(this.width());
        this._parallaxX = x;
      } else {
        const endX = this.width() - this.screenTileX();
        this._displayX = endX < 0 ? endX / 2 : x.clamp(0, endX);
        this._parallaxX = this._displayX;
      }
      if (this.isLoopVertical()) {
        this._displayY = y.mod(this.height());
        this._parallaxY = y;
      } else {
        const endY = this.height() - this.screenTileY();
        this._displayY = endY < 0 ? endY / 2 : y.clamp(0, endY);
        this._parallaxY = this._displayY;
      }
    }
    parallaxOx() {
      if (this._parallaxZero) {
        return this._parallaxX * this.tileWidth();
      } else if (this._parallaxLoopX) {
        return this._parallaxX * this.tileWidth() / 2;
      } else {
        return 0;
      }
    }
    parallaxOy() {
      if (this._parallaxZero) {
        return this._parallaxY * this.tileHeight();
      } else if (this._parallaxLoopY) {
        return this._parallaxY * this.tileHeight() / 2;
      } else {
        return 0;
      }
    }
    tileset() {
      return self.$dataTilesets[this._tilesetId];
    }
    tilesetFlags() {
      const tileset = this.tileset();
      if (tileset) {
        return tileset.flags;
      } else {
        return [];
      }
    }
    displayName() {
      return self.$dataMap.displayName;
    }
    width() {
      return self.$dataMap.width;
    }
    height() {
      return self.$dataMap.height;
    }
    data() {
      return self.$dataMap.data;
    }
    isLoopHorizontal() {
      return self.$dataMap.scrollType === 2 || self.$dataMap.scrollType === 3;
    }
    isLoopVertical() {
      return self.$dataMap.scrollType === 1 || self.$dataMap.scrollType === 3;
    }
    isDashDisabled() {
      return self.$dataMap.disableDashing;
    }
    encounterList() {
      return self.$dataMap.encounterList;
    }
    encounterStep() {
      return self.$dataMap.encounterStep;
    }
    isOverworld() {
      return this.tileset() && this.tileset().mode === 0;
    }
    screenTileX() {
      return Graphics_default.width / this.tileWidth();
    }
    screenTileY() {
      return Graphics_default.height / this.tileHeight();
    }
    adjustX(x) {
      if (this.isLoopHorizontal() && x < this._displayX - (this.width() - this.screenTileX()) / 2) {
        return x - this._displayX + self.$dataMap.width;
      } else {
        return x - this._displayX;
      }
    }
    adjustY(y) {
      if (this.isLoopVertical() && y < this._displayY - (this.height() - this.screenTileY()) / 2) {
        return y - this._displayY + self.$dataMap.height;
      } else {
        return y - this._displayY;
      }
    }
    roundX(x) {
      return this.isLoopHorizontal() ? x.mod(this.width()) : x;
    }
    roundY(y) {
      return this.isLoopVertical() ? y.mod(this.height()) : y;
    }
    xWithDirection(x, d) {
      return x + (d === 6 ? 1 : d === 4 ? -1 : 0);
    }
    yWithDirection(y, d) {
      return y + (d === 2 ? 1 : d === 8 ? -1 : 0);
    }
    roundXWithDirection(x, d) {
      return this.roundX(x + (d === 6 ? 1 : d === 4 ? -1 : 0));
    }
    roundYWithDirection(y, d) {
      return this.roundY(y + (d === 2 ? 1 : d === 8 ? -1 : 0));
    }
    deltaX(x1, x2) {
      let result2 = x1 - x2;
      if (this.isLoopHorizontal() && Math.abs(result2) > this.width() / 2) {
        if (result2 < 0) {
          result2 += this.width();
        } else {
          result2 -= this.width();
        }
      }
      return result2;
    }
    deltaY(y1, y2) {
      let result2 = y1 - y2;
      if (this.isLoopVertical() && Math.abs(result2) > this.height() / 2) {
        if (result2 < 0) {
          result2 += this.height();
        } else {
          result2 -= this.height();
        }
      }
      return result2;
    }
    distance(x1, y1, x2, y2) {
      return Math.abs(this.deltaX(x1, x2)) + Math.abs(this.deltaY(y1, y2));
    }
    canvasToMapX(x) {
      const tileWidth = this.tileWidth();
      const originX = this._displayX * tileWidth;
      const mapX = Math.floor((originX + x) / tileWidth);
      return this.roundX(mapX);
    }
    canvasToMapY(y) {
      const tileHeight = this.tileHeight();
      const originY = this._displayY * tileHeight;
      const mapY = Math.floor((originY + y) / tileHeight);
      return this.roundY(mapY);
    }
    autoplay() {
      if (self.$dataMap.autoplayBgm) {
        if (self.$gamePlayer.isInVehicle()) {
          self.$gameSystem.saveWalkingBgm2();
        } else {
          AudioManager_default.playBgm(self.$dataMap.bgm);
        }
      }
      if (self.$dataMap.autoplayBgs) {
        AudioManager_default.playBgs(self.$dataMap.bgs);
      }
    }
    refreshIfNeeded() {
      if (this._needsRefresh) {
        this.refresh();
      }
    }
    refresh() {
      this.events().forEach((event) => {
        event.refresh();
      });
      this._commonEvents.forEach((event) => {
        event.refresh();
      });
      this.refreshTileEvents();
      this._needsRefresh = false;
    }
    refreshTileEvents() {
      this.tileEvents = this.events().filter((event) => event.isTile());
    }
    eventsXy(x, y) {
      return this.events().filter((event) => event.pos(x, y));
    }
    eventsXyNt(x, y) {
      return this.events().filter((event) => event.posNt(x, y));
    }
    tileEventsXy(x, y) {
      return this.tileEvents.filter((event) => event.posNt(x, y));
    }
    eventIdXy(x, y) {
      const list = this.eventsXy(x, y);
      return list.length === 0 ? 0 : list[0].eventId();
    }
    scrollDown(distance) {
      if (this.isLoopVertical()) {
        this._displayY += distance;
        this._displayY %= self.$dataMap.height;
        if (this._parallaxLoopY) {
          this._parallaxY += distance;
        }
      } else if (this.height() >= this.screenTileY()) {
        const lastY = this._displayY;
        this._displayY = Math.min(
          this._displayY + distance,
          this.height() - this.screenTileY()
        );
        this._parallaxY += this._displayY - lastY;
      }
    }
    scrollLeft(distance) {
      if (this.isLoopHorizontal()) {
        this._displayX += self.$dataMap.width - distance;
        this._displayX %= self.$dataMap.width;
        if (this._parallaxLoopX) {
          this._parallaxX -= distance;
        }
      } else if (this.width() >= this.screenTileX()) {
        const lastX = this._displayX;
        this._displayX = Math.max(this._displayX - distance, 0);
        this._parallaxX += this._displayX - lastX;
      }
    }
    scrollRight(distance) {
      if (this.isLoopHorizontal()) {
        this._displayX += distance;
        this._displayX %= self.$dataMap.width;
        if (this._parallaxLoopX) {
          this._parallaxX += distance;
        }
      } else if (this.width() >= this.screenTileX()) {
        const lastX = this._displayX;
        this._displayX = Math.min(
          this._displayX + distance,
          this.width() - this.screenTileX()
        );
        this._parallaxX += this._displayX - lastX;
      }
    }
    scrollUp(distance) {
      if (this.isLoopVertical()) {
        this._displayY += self.$dataMap.height - distance;
        this._displayY %= self.$dataMap.height;
        if (this._parallaxLoopY) {
          this._parallaxY -= distance;
        }
      } else if (this.height() >= this.screenTileY()) {
        const lastY = this._displayY;
        this._displayY = Math.max(this._displayY - distance, 0);
        this._parallaxY += this._displayY - lastY;
      }
    }
    isValid(x, y) {
      return x >= 0 && x < this.width() && y >= 0 && y < this.height();
    }
    checkPassage(x, y, bit) {
      const flags = this.tilesetFlags();
      const tiles = this.allTiles(x, y);
      for (let i = 0; i < tiles.length; i++) {
        const flag = flags[tiles[i]];
        if ((flag & 16) !== 0)
          continue;
        if ((flag & bit) === 0)
          return true;
        if ((flag & bit) === bit)
          return false;
      }
      return false;
    }
    tileId(x, y, z) {
      const width = self.$dataMap.width;
      const height = self.$dataMap.height;
      return self.$dataMap.data[(z * height + y) * width + x] || 0;
    }
    layeredTiles(x, y) {
      const tiles = [];
      for (let i = 0; i < 4; i++) {
        tiles.push(this.tileId(x, y, 3 - i));
      }
      return tiles;
    }
    allTiles(x, y) {
      const tiles = this.tileEventsXy(x, y).map((event) => event.tileId());
      return tiles.concat(this.layeredTiles(x, y));
    }
    autotileType(x, y, z) {
      const tileId = this.tileId(x, y, z);
      return tileId >= 2048 ? Math.floor((tileId - 2048) / 48) : -1;
    }
    isPassable(x, y, d) {
      return this.checkPassage(x, y, 1 << d / 2 - 1 & 15);
    }
    isBoatPassable(x, y) {
      return this.checkPassage(x, y, 512);
    }
    isShipPassable(x, y) {
      return this.checkPassage(x, y, 1024);
    }
    isAirshipLandOk(x, y) {
      return this.checkPassage(x, y, 2048) && this.checkPassage(x, y, 15);
    }
    checkLayeredTilesFlags(x, y, bit) {
      const flags = this.tilesetFlags();
      return this.layeredTiles(x, y).some(
        (tileId) => (flags[tileId] & bit) !== 0
      );
    }
    isLadder(x, y) {
      return this.isValid(x, y) && this.checkLayeredTilesFlags(x, y, 32);
    }
    isBush(x, y) {
      return this.isValid(x, y) && this.checkLayeredTilesFlags(x, y, 64);
    }
    isCounter(x, y) {
      return this.isValid(x, y) && this.checkLayeredTilesFlags(x, y, 128);
    }
    isDamageFloor(x, y) {
      return this.isValid(x, y) && this.checkLayeredTilesFlags(x, y, 256);
    }
    terrainTag(x, y) {
      if (this.isValid(x, y)) {
        const flags = this.tilesetFlags();
        const tiles = this.layeredTiles(x, y);
        for (let i = 0; i < tiles.length; i++) {
          const tag = flags[tiles[i]] >> 12;
          if (tag > 0) {
            return tag;
          }
        }
      }
      return 0;
    }
    regionId(x, y) {
      return this.isValid(x, y) ? this.tileId(x, y, 5) : 0;
    }
    startScroll(direction, distance, speed) {
      this._scrollDirection = direction;
      this._scrollRest = distance;
      this._scrollSpeed = speed;
    }
    isScrolling() {
      return this._scrollRest > 0;
    }
    update(sceneActive) {
      this.refreshIfNeeded();
      if (sceneActive) {
        this.updateInterpreter();
      }
      this.updateScroll();
      this.updateEvents();
      this.updateVehicles();
      this.updateParallax();
    }
    updateScroll() {
      if (this.isScrolling()) {
        const lastX = this._displayX;
        const lastY = this._displayY;
        this.doScroll(this._scrollDirection, this.scrollDistance());
        if (this._displayX === lastX && this._displayY === lastY) {
          this._scrollRest = 0;
        } else {
          this._scrollRest -= this.scrollDistance();
        }
      }
    }
    scrollDistance() {
      return Math.pow(2, this._scrollSpeed) / 256;
    }
    doScroll(direction, distance) {
      switch (direction) {
        case 2:
          this.scrollDown(distance);
          break;
        case 4:
          this.scrollLeft(distance);
          break;
        case 6:
          this.scrollRight(distance);
          break;
        case 8:
          this.scrollUp(distance);
          break;
      }
    }
    updateEvents() {
      this.events().forEach((event) => {
        event.update();
      });
      this._commonEvents.forEach((event) => {
        event.update();
      });
    }
    updateVehicles() {
      this._vehicles.forEach((vehicle) => {
        vehicle.update();
      });
    }
    updateParallax() {
      if (this._parallaxLoopX) {
        this._parallaxX += this._parallaxSx / this.tileWidth() / 2;
      }
      if (this._parallaxLoopY) {
        this._parallaxY += this._parallaxSy / this.tileHeight() / 2;
      }
    }
    changeTileset(tilesetId) {
      this._tilesetId = tilesetId;
      this.refresh();
    }
    changeBattleback(battleback1Name, battleback2Name) {
      this._battleback1Name = battleback1Name;
      this._battleback2Name = battleback2Name;
    }
    changeParallax(name, loopX, loopY, sx, sy) {
      this._parallaxName = name;
      this._parallaxZero = ImageManager_default.isZeroParallax(this._parallaxName);
      if (this._parallaxLoopX && !loopX) {
        this._parallaxX = 0;
      }
      if (this._parallaxLoopY && !loopY) {
        this._parallaxY = 0;
      }
      this._parallaxLoopX = loopX;
      this._parallaxLoopY = loopY;
      this._parallaxSx = sx;
      this._parallaxSy = sy;
    }
    updateInterpreter() {
      for (; ; ) {
        this._interpreter.update();
        if (this._interpreter.isRunning()) {
          return;
        }
        if (this._interpreter.eventId() > 0) {
          this.unlockEvent(this._interpreter.eventId());
          this._interpreter.clear();
        }
        if (!this.setupStartingEvent()) {
          return;
        }
      }
    }
    unlockEvent(eventId) {
      if (this._events[eventId]) {
        this._events[eventId].unlock();
      }
    }
    setupStartingEvent() {
      this.refreshIfNeeded();
      if (this._interpreter.setupReservedCommonEvent()) {
        return true;
      }
      if (this.setupTestEvent()) {
        return true;
      }
      if (this.setupStartingMapEvent()) {
        return true;
      }
      if (this.setupAutorunCommonEvent()) {
        return true;
      }
      return false;
    }
    setupTestEvent() {
      if (self.$testEvent) {
        this._interpreter.setup(self.$testEvent, 0);
        this._interpreter.setEventInfo({
          eventType: "test_event"
        });
        self.$testEvent = null;
        return true;
      }
      return false;
    }
    setupStartingMapEvent() {
      const events = this.events();
      for (const event of events) {
        if (event.isStarting()) {
          event.clearStartingFlag();
          this._interpreter.setup(event.list(), event.eventId());
          this._interpreter.setEventInfo(event.getEventInfo());
          return true;
        }
      }
      return false;
    }
    setupAutorunCommonEvent() {
      for (let i = 0; i < self.$dataCommonEvents.length; i++) {
        const event = self.$dataCommonEvents[i];
        if (event && event.trigger === 1 && self.$gameSwitches.value(event.switchId)) {
          this._interpreter.setup(event.list);
          this._interpreter.setEventInfo({
            eventType: "common_event",
            commonEventId: i
          });
          return true;
        }
      }
      return false;
    }
    isAnyEventStarting() {
      return this.events().some((event) => event.isStarting());
    }
  };
  var Game_Map_default = Game_Map;

  // src-www/js/rpg_objects/Game_Follower.js
  var Game_Follower = class extends Game_Character_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize(memberIndex) {
      super.initialize();
      this._memberIndex = memberIndex;
      this.setTransparent(self.$dataSystem.optTransparent);
      this.setThrough(true);
    }
    refresh() {
      const characterName = this.isVisible() ? this.actor().characterName() : "";
      const characterIndex = this.isVisible() ? this.actor().characterIndex() : 0;
      this.setImage(characterName, characterIndex);
    }
    actor() {
      return self.$gameParty.battleMembers()[this._memberIndex];
    }
    isVisible() {
      return this.actor() && self.$gamePlayer.followers().isVisible();
    }
    update() {
      super.update();
      this.setMoveSpeed(self.$gamePlayer.realMoveSpeed());
      this.setOpacity(self.$gamePlayer.opacity());
      this.setBlendMode(self.$gamePlayer.blendMode());
      this.setWalkAnime(self.$gamePlayer.hasWalkAnime());
      this.setStepAnime(self.$gamePlayer.hasStepAnime());
      this.setDirectionFix(self.$gamePlayer.isDirectionFixed());
      this.setTransparent(self.$gamePlayer.isTransparent());
    }
    chaseCharacter({ x, y }) {
      const sx = this.deltaXFrom(x);
      const sy = this.deltaYFrom(y);
      if (sx !== 0 && sy !== 0) {
        this.moveDiagonally(sx > 0 ? 4 : 6, sy > 0 ? 8 : 2);
      } else if (sx !== 0) {
        this.moveStraight(sx > 0 ? 4 : 6);
      } else if (sy !== 0) {
        this.moveStraight(sy > 0 ? 8 : 2);
      }
      this.setMoveSpeed(self.$gamePlayer.realMoveSpeed());
    }
  };
  var Game_Follower_default = Game_Follower;

  // src-www/js/rpg_objects/Game_Followers.js
  var Game_Followers = class {
    constructor(...args) {
      this.initialize(...args);
    }
    initialize() {
      this._visible = self.$dataSystem.optFollowers;
      this._gathering = false;
      this._data = [];
      for (let i = 1; i < self.$gameParty.maxBattleMembers(); i++) {
        this._data.push(new Game_Follower_default(i));
      }
    }
    isVisible() {
      return this._visible;
    }
    show() {
      this._visible = true;
    }
    hide() {
      this._visible = false;
    }
    follower(index2) {
      return this._data[index2];
    }
    forEach(callback, thisObject) {
      this._data.forEach(callback, thisObject);
    }
    reverseEach(callback, thisObject) {
      this._data.reverse();
      this._data.forEach(callback, thisObject);
      this._data.reverse();
    }
    refresh() {
      this.forEach((follower) => follower.refresh(), this);
    }
    update() {
      if (this.areGathering()) {
        if (!this.areMoving()) {
          this.updateMove();
        }
        if (this.areGathered()) {
          this._gathering = false;
        }
      }
      this.forEach((follower) => {
        follower.update();
      }, this);
    }
    updateMove() {
      for (let i = this._data.length - 1; i >= 0; i--) {
        const precedingCharacter = i > 0 ? this._data[i - 1] : self.$gamePlayer;
        this._data[i].chaseCharacter(precedingCharacter);
      }
    }
    jumpAll() {
      if (self.$gamePlayer.isJumping()) {
        for (const follower of this._data) {
          const sx = self.$gamePlayer.deltaXFrom(follower.x);
          const sy = self.$gamePlayer.deltaYFrom(follower.y);
          follower.jump(sx, sy);
        }
      }
    }
    synchronize(x, y, d) {
      this.forEach((follower) => {
        follower.locate(x, y);
        follower.setDirection(d);
      }, this);
    }
    gather() {
      this._gathering = true;
    }
    areGathering() {
      return this._gathering;
    }
    visibleFollowers() {
      return this._data.filter((follower) => follower.isVisible(), this);
    }
    areMoving() {
      return this.visibleFollowers().some(
        (follower) => follower.isMoving(),
        this
      );
    }
    areGathered() {
      return this.visibleFollowers().every(
        (follower) => !follower.isMoving() && follower.pos(self.$gamePlayer.x, self.$gamePlayer.y),
        this
      );
    }
    isSomeoneCollided(x, y) {
      return this.visibleFollowers().some((follower) => follower.pos(x, y), this);
    }
  };
  var Game_Followers_default = Game_Followers;

  // src-www/js/rpg_objects/Game_Player.js
  var Game_Player = class extends Game_Character_default {
    constructor(...args) {
      super(...args);
      this.initialize(...args);
    }
    initialize() {
      super.initialize();
      this.setTransparent(self.$dataSystem.optTransparent);
    }
    initMembers() {
      super.initMembers();
      this._vehicleType = "walk";
      this._vehicleGettingOn = false;
      this._vehicleGettingOff = false;
      this._dashing = false;
      this._needsMapReload = false;
      this._transferring = false;
      this._newMapId = 0;
      this._newX = 0;
      this._newY = 0;
      this._newDirection = 0;
      this._fadeType = 0;
      this._followers = new Game_Followers_default();
      this._encounterCount = 0;
    }
    clearTransferInfo() {
      this._transferring = false;
      this._newMapId = 0;
      this._newX = 0;
      this._newY = 0;
      this._newDirection = 0;
    }
    followers() {
      return this._followers;
    }
    refresh() {
      const actor2 = self.$gameParty.leader();
      const characterName = actor2 ? actor2.characterName() : "";
      const characterIndex = actor2 ? actor2.characterIndex() : 0;
      this.setImage(characterName, characterIndex);
      this._followers.refresh();
    }
    isStopping() {
      if (this._vehicleGettingOn || this._vehicleGettingOff) {
        return false;
      }
      return Game_Character_default.prototype.isStopping.call(this);
    }
    reserveTransfer(mapId, x, y, d, fadeType) {
      this._transferring = true;
      this._newMapId = mapId;
      this._newX = x;
      this._newY = y;
      this._newDirection = d;
      this._fadeType = fadeType;
    }
    requestMapReload() {
      this._needsMapReload = true;
    }
    isTransferring() {
      return this._transferring;
    }
    newMapId() {
      return this._newMapId;
    }
    fadeType() {
      return this._fadeType;
    }
    performTransfer() {
      if (this.isTransferring()) {
        this.setDirection(this._newDirection);
        if (this._newMapId !== self.$gameMap.mapId() || this._needsMapReload) {
          self.$gameMap.setup(this._newMapId);
          this._needsMapReload = false;
        }
        this.locate(this._newX, this._newY);
        this.refresh();
        DataManager2.autoSaveGame();
        this.clearTransferInfo();
      }
    }
    isMapPassable(x, y, d) {
      const vehicle = this.vehicle();
      if (vehicle) {
        return vehicle.isMapPassable(x, y, d);
      } else {
        return Game_Character_default.prototype.isMapPassable.call(this, x, y, d);
      }
    }
    vehicle() {
      return self.$gameMap.vehicle(this._vehicleType);
    }
    isInBoat() {
      return this._vehicleType === "boat";
    }
    isInShip() {
      return this._vehicleType === "ship";
    }
    isInAirship() {
      return this._vehicleType === "airship";
    }
    isInVehicle() {
      return this.isInBoat() || this.isInShip() || this.isInAirship();
    }
    isNormal() {
      return this._vehicleType === "walk" && !this.isMoveRouteForcing();
    }
    isDashing() {
      return this._dashing;
    }
    isDebugThrough() {
      return Input_default.isPressed("control") && self.$gameTemp.isPlaytest();
    }
    isCollided(x, y) {
      if (this.isThrough()) {
        return false;
      } else {
        return this.pos(x, y) || this._followers.isSomeoneCollided(x, y);
      }
    }
    centerX() {
      return (Graphics_default.width / self.$gameMap.tileWidth() - 1) / 2;
    }
    centerY() {
      return (Graphics_default.height / self.$gameMap.tileHeight() - 1) / 2;
    }
    center(x, y) {
      return self.$gameMap.setDisplayPos(x - this.centerX(), y - this.centerY());
    }
    locate(x, y) {
      super.locate(x, y);
      this.center(x, y);
      this.makeEncounterCount();
      if (this.isInVehicle()) {
        this.vehicle().refresh();
      }
      this._followers.synchronize(x, y, this.direction());
    }
    increaseSteps() {
      super.increaseSteps();
      if (this.isNormal()) {
        self.$gameParty.increaseSteps();
      }
    }
    makeEncounterCount() {
      const n = self.$gameMap.encounterStep();
      this._encounterCount = Math.randomInt(n) + Math.randomInt(n) + 1;
    }
    makeEncounterTroopId() {
      const encounterList = [];
      let weightSum = 0;
      self.$gameMap.encounterList().forEach(function(encounter) {
        if (this.meetsEncounterConditions(encounter)) {
          encounterList.push(encounter);
          weightSum += encounter.weight;
        }
      }, this);
      if (weightSum > 0) {
        let value3 = Math.randomInt(weightSum);
        for (let i = 0; i < encounterList.length; i++) {
          value3 -= encounterList[i].weight;
          if (value3 < 0) {
            return encounterList[i].troopId;
          }
        }
      }
      return 0;
    }
    meetsEncounterConditions({ regionSet }) {
      return regionSet.length === 0 || regionSet.contains(this.regionId());
    }
    executeEncounter() {
      if (!self.$gameMap.isEventRunning() && this._encounterCount <= 0) {
        this.makeEncounterCount();
        const troopId = this.makeEncounterTroopId();
        if (self.$dataTroops[troopId]) {
          BattleManager_default.setup(troopId, true, false);
          BattleManager_default.onEncounter();
          return true;
        } else {
          return false;
        }
      } else {
        return false;
      }
    }
    startMapEvent(x, y, triggers, normal) {
      if (!self.$gameMap.isEventRunning()) {
        self.$gameMap.eventsXy(x, y).forEach((event) => {
          if (event.isTriggerIn(triggers) && event.isNormalPriority() === normal) {
            event.start();
          }
        });
      }
    }
    moveByInput() {
      if (!this.isMoving() && this.canMove()) {
        let direction = this.getInputDirection();
        if (direction > 0) {
          self.$gameTemp.clearDestination();
        } else if (self.$gameTemp.isDestinationValid()) {
          const x = self.$gameTemp.destinationX();
          const y = self.$gameTemp.destinationY();
          direction = this.findDirectionTo(x, y);
        }
        if (direction > 0) {
          this.executeMove(direction);
        }
      }
    }
    canMove() {
      if (self.$gameMap.isEventRunning() || self.$gameMessage.isBusy()) {
        return false;
      }
      if (this.isMoveRouteForcing() || this.areFollowersGathering()) {
        return false;
      }
      if (this._vehicleGettingOn || this._vehicleGettingOff) {
        return false;
      }
      if (this.isInVehicle() && !this.vehicle().canMove()) {
        return false;
      }
      return true;
    }
    getInputDirection() {
      return Input_default.dir4;
    }
    executeMove(direction) {
      this.moveStraight(direction);
    }
    update(sceneActive) {
      const lastScrolledX = this.scrolledX();
      const lastScrolledY = this.scrolledY();
      const wasMoving = this.isMoving();
      this.updateDashing();
      if (sceneActive) {
        this.moveByInput();
      }
      super.update();
      this.updateScroll(lastScrolledX, lastScrolledY);
      this.updateVehicle();
      if (!this.isMoving()) {
        this.updateNonmoving(wasMoving);
      }
      this._followers.update();
    }
    updateDashing() {
      if (this.isMoving()) {
        return;
      }
      if (this.canMove() && !this.isInVehicle() && !self.$gameMap.isDashDisabled()) {
        this._dashing = this.isDashButtonPressed() || self.$gameTemp.isDestinationValid();
      } else {
        this._dashing = false;
      }
    }
    isDashButtonPressed() {
      const shift = Input_default.isPressed("shift");
      if (ConfigManager_default.alwaysDash) {
        return !shift;
      } else {
        return shift;
      }
    }
    updateScroll(lastScrolledX, lastScrolledY) {
      const x1 = lastScrolledX;
      const y1 = lastScrolledY;
      const x2 = this.scrolledX();
      const y2 = this.scrolledY();
      if (y2 > y1 && y2 > this.centerY()) {
        self.$gameMap.scrollDown(y2 - y1);
      }
      if (x2 < x1 && x2 < this.centerX()) {
        self.$gameMap.scrollLeft(x1 - x2);
      }
      if (x2 > x1 && x2 > this.centerX()) {
        self.$gameMap.scrollRight(x2 - x1);
      }
      if (y2 < y1 && y2 < this.centerY()) {
        self.$gameMap.scrollUp(y1 - y2);
      }
    }
    updateVehicle() {
      if (this.isInVehicle() && !this.areFollowersGathering()) {
        if (this._vehicleGettingOn) {
          this.updateVehicleGetOn();
        } else if (this._vehicleGettingOff) {
          this.updateVehicleGetOff();
        } else {
          this.vehicle().syncWithPlayer();
        }
      }
    }
    updateVehicleGetOn() {
      if (!this.areFollowersGathering() && !this.isMoving()) {
        this.setDirection(this.vehicle().direction());
        this.setMoveSpeed(this.vehicle().moveSpeed());
        this._vehicleGettingOn = false;
        this.setTransparent(true);
        if (this.isInAirship()) {
          this.setThrough(true);
        }
        this.vehicle().getOn();
      }
    }
    updateVehicleGetOff() {
      if (!this.areFollowersGathering() && this.vehicle().isLowest()) {
        this._vehicleGettingOff = false;
        this._vehicleType = "walk";
        this.setTransparent(false);
      }
    }
    updateNonmoving(wasMoving) {
      if (!self.$gameMap.isEventRunning()) {
        if (wasMoving) {
          self.$gameParty.onPlayerWalk();
          this.checkEventTriggerHere([1, 2]);
          if (self.$gameMap.setupStartingEvent()) {
            return;
          }
        }
        if (this.triggerAction()) {
          return;
        }
        if (wasMoving) {
          this.updateEncounterCount();
        } else {
          self.$gameTemp.clearDestination();
        }
      }
    }
    triggerAction() {
      if (this.canMove()) {
        if (this.triggerButtonAction()) {
          return true;
        }
        if (this.triggerTouchAction()) {
          return true;
        }
      }
      return false;
    }
    triggerButtonAction() {
      if (Input_default.isTriggered("ok")) {
        if (this.getOnOffVehicle()) {
          return true;
        }
        this.checkEventTriggerHere([0]);
        if (self.$gameMap.setupStartingEvent()) {
          return true;
        }
        this.checkEventTriggerThere([0, 1, 2]);
        if (self.$gameMap.setupStartingEvent()) {
          return true;
        }
      }
      return false;
    }
    triggerTouchAction() {
      if (self.$gameTemp.isDestinationValid()) {
        const direction = this.direction();
        const x1 = this.x;
        const y1 = this.y;
        const x2 = self.$gameMap.roundXWithDirection(x1, direction);
        const y2 = self.$gameMap.roundYWithDirection(y1, direction);
        const x3 = self.$gameMap.roundXWithDirection(x2, direction);
        const y3 = self.$gameMap.roundYWithDirection(y2, direction);
        const destX = self.$gameTemp.destinationX();
        const destY = self.$gameTemp.destinationY();
        if (destX === x1 && destY === y1) {
          return this.triggerTouchActionD1(x1, y1);
        } else if (destX === x2 && destY === y2) {
          return this.triggerTouchActionD2(x2, y2);
        } else if (destX === x3 && destY === y3) {
          return this.triggerTouchActionD3(x2, y2);
        }
      }
      return false;
    }
    triggerTouchActionD1(x1, y1) {
      if (self.$gameMap.airship().pos(x1, y1)) {
        if (TouchInput_default.isTriggered() && this.getOnOffVehicle()) {
          return true;
        }
      }
      this.checkEventTriggerHere([0]);
      return self.$gameMap.setupStartingEvent();
    }
    triggerTouchActionD2(x2, y2) {
      if (self.$gameMap.boat().pos(x2, y2) || self.$gameMap.ship().pos(x2, y2)) {
        if (TouchInput_default.isTriggered() && this.getOnVehicle()) {
          return true;
        }
      }
      if (this.isInBoat() || this.isInShip()) {
        if (TouchInput_default.isTriggered() && this.getOffVehicle()) {
          return true;
        }
      }
      this.checkEventTriggerThere([0, 1, 2]);
      return self.$gameMap.setupStartingEvent();
    }
    triggerTouchActionD3(x2, y2) {
      if (self.$gameMap.isCounter(x2, y2)) {
        this.checkEventTriggerThere([0, 1, 2]);
      }
      return self.$gameMap.setupStartingEvent();
    }
    updateEncounterCount() {
      if (this.canEncounter()) {
        this._encounterCount -= this.encounterProgressValue();
      }
    }
    canEncounter() {
      return !self.$gameParty.hasEncounterNone() && self.$gameSystem.isEncounterEnabled() && !this.isInAirship() && !this.isMoveRouteForcing() && !this.isDebugThrough();
    }
    encounterProgressValue() {
      let value3 = self.$gameMap.isBush(this.x, this.y) ? 2 : 1;
      if (self.$gameParty.hasEncounterHalf()) {
        value3 *= 0.5;
      }
      if (this.isInShip()) {
        value3 *= 0.5;
      }
      return value3;
    }
    checkEventTriggerHere(triggers) {
      if (this.canStartLocalEvents()) {
        this.startMapEvent(this.x, this.y, triggers, false);
      }
    }
    checkEventTriggerThere(triggers) {
      if (this.canStartLocalEvents()) {
        const direction = this.direction();
        const x1 = this.x;
        const y1 = this.y;
        const x2 = self.$gameMap.roundXWithDirection(x1, direction);
        const y2 = self.$gameMap.roundYWithDirection(y1, direction);
        this.startMapEvent(x2, y2, triggers, true);
        if (!self.$gameMap.isAnyEventStarting() && self.$gameMap.isCounter(x2, y2)) {
          const x3 = self.$gameMap.roundXWithDirection(x2, direction);
          const y3 = self.$gameMap.roundYWithDirection(y2, direction);
          this.startMapEvent(x3, y3, triggers, true);
        }
      }
    }
    checkEventTriggerTouch(x, y) {
      if (this.canStartLocalEvents()) {
        this.startMapEvent(x, y, [1, 2], true);
      }
    }
    canStartLocalEvents() {
      return !this.isInAirship();
    }
    getOnOffVehicle() {
      if (this.isInVehicle()) {
        return this.getOffVehicle();
      } else {
        return this.getOnVehicle();
      }
    }
    getOnVehicle() {
      const direction = this.direction();
      const x1 = this.x;
      const y1 = this.y;
      const x2 = self.$gameMap.roundXWithDirection(x1, direction);
      const y2 = self.$gameMap.roundYWithDirection(y1, direction);
      if (self.$gameMap.airship().pos(x1, y1)) {
        this._vehicleType = "airship";
      } else if (self.$gameMap.ship().pos(x2, y2)) {
        this._vehicleType = "ship";
      } else if (self.$gameMap.boat().pos(x2, y2)) {
        this._vehicleType = "boat";
      }
      if (this.isInVehicle()) {
        this._vehicleGettingOn = true;
        if (!this.isInAirship()) {
          this.forceMoveForward();
        }
        this.gatherFollowers();
      }
      return this._vehicleGettingOn;
    }
    getOffVehicle() {
      if (this.vehicle().isLandOk(this.x, this.y, this.direction())) {
        if (this.isInAirship()) {
          this.setDirection(2);
        }
        this._followers.synchronize(this.x, this.y, this.direction());
        this.vehicle().getOff();
        if (!this.isInAirship()) {
          this.forceMoveForward();
          this.setTransparent(false);
        }
        this._vehicleGettingOff = true;
        this.setMoveSpeed(4);
        this.setThrough(false);
        this.makeEncounterCount();
        this.gatherFollowers();
      }
      return this._vehicleGettingOff;
    }
    forceMoveForward() {
      this.setThrough(true);
      this.moveForward();
      this.setThrough(false);
    }
    isOnDamageFloor() {
      return self.$gameMap.isDamageFloor(this.x, this.y) && !this.isInAirship();
    }
    moveStraight(d) {
      if (this.canPass(this.x, this.y, d)) {
        this._followers.updateMove();
      }
      super.moveStraight(d);
    }
    moveDiagonally(horz, vert) {
      if (this.canPassDiagonally(this.x, this.y, horz, vert)) {
        this._followers.updateMove();
      }
      super.moveDiagonally(horz, vert);
    }
    jump(xPlus, yPlus) {
      super.jump(xPlus, yPlus);
      this._followers.jumpAll();
    }
    showFollowers() {
      this._followers.show();
    }
    hideFollowers() {
      this._followers.hide();
    }
    gatherFollowers() {
      this._followers.gather();
    }
    areFollowersGathering() {
      return this._followers.areGathering();
    }
    areFollowersGathered() {
      return this._followers.areGathered();
    }
  };
  var Game_Player_default = Game_Player;

  // src-www/js/rpg_managers/DataManager.js
  var DataManager2 = class {
    constructor() {
      throw new Error("This is a static class");
    }
    static loadDatabase() {
      const test = this.isBattleTest() || this.isEventTest();
      const prefix = test ? "Test_" : "";
      for (let i = 0; i < this._databaseFiles.length; i++) {
        const name = this._databaseFiles[i].name;
        const src = this._databaseFiles[i].src;
        this.loadDataFile(name, prefix + src);
      }
      if (this.isEventTest()) {
        this.loadDataFile("$testEvent", `${prefix}Event.json`);
      }
    }
    static loadDataFile(name, src) {
      const url2 = `../data/${src}`;
      self[name] = null;
      fetch(url2).then((response) => response.json()).then((json) => {
        self[name] = json;
        DataManager2.onLoad(self[name]);
      }).catch(function(err) {
        console.error(err);
        DataManager2._errorUrl = DataManager2._errorUrl || src;
      });
    }
    static isDatabaseLoaded() {
      this.checkError();
      for (let i = 0; i < this._databaseFiles.length; i++) {
        if (!self[this._databaseFiles[i].name]) {
          return false;
        }
      }
      return true;
    }
    static loadMapData(mapId) {
      if (mapId > 0) {
        const filename = "Map%1.json".format(mapId.padZero(3));
        this._mapLoader = ResourceHandler_default.createLoader(
          `data/${filename}`,
          this.loadDataFile.bind(this, "$dataMap", filename)
        );
        this.loadDataFile("$dataMap", filename);
      } else {
        this.makeEmptyMap();
      }
    }
    static isMapLoaded() {
      this.checkError();
      return !!self.$dataMap;
    }
    static onLoad(object) {
      let array;
      if (object === self.$dataMap) {
        this.extractMetadata(object);
        array = object.events;
      } else {
        array = object;
      }
      if (Array.isArray(array)) {
        for (const data of array) {
          if (data && data.note !== void 0) {
            this.extractMetadata(data);
          }
        }
      }
      if (object === self.$dataSystem) {
        Scene_Boot_default.loadSystemImages();
      }
    }
    static setupNewGame() {
      this.createGameObjects();
      this.selectSavefileForNewGame();
      self.$gameParty.setupStartingMembers();
      self.$gamePlayer.reserveTransfer(
        self.$dataSystem.startMapId,
        self.$dataSystem.startX,
        self.$dataSystem.startY
      );
      Graphics_default.frameCount = 0;
      SceneManager_default.resetFrameCount();
    }
    static setupBattleTest() {
      this.createGameObjects();
      self.$gameParty.setupBattleTest();
      BattleManager_default.setup(self.$dataSystem.testTroopId, true, false);
      BattleManager_default.setBattleTest(true);
      BattleManager_default.playBattleBgm();
    }
    static setupEventTest() {
      this.createGameObjects();
      this.selectSavefileForNewGame();
      self.$gameParty.setupStartingMembers();
      self.$gamePlayer.reserveTransfer(-1, 8, 6);
      self.$gamePlayer.setTransparent(false);
    }
    static loadGlobalInfo() {
      return this._globalInfo;
    }
    static async loadGlobalInfoAsync() {
      let json;
      try {
        json = await StorageManagerShim_default.load(0);
      } catch (e) {
        console.error(e);
        return [];
      }
      if (json) {
        this._globalInfo = JSON.parse(json);
        for (let i = 1; i <= this.maxSavefiles(); i++) {
          const exists = await StorageManagerShim_default.exists(i);
          if (!exists) {
            delete this._globalInfo[i];
          }
        }
      } else {
        this._globalInfo = [];
      }
    }
    static saveGlobalInfo(info) {
      this._globalInfo = info;
      StorageManagerShim_default.save(0, JSON.stringify(info));
    }
    static isThisGameFile(savefileId) {
      const globalInfo = this.loadGlobalInfo();
      if (globalInfo && globalInfo[savefileId]) {
        if (StorageManagerShim_default.isLocalMode()) {
          return true;
        } else {
          const savefile = globalInfo[savefileId];
          return savefile.globalId === this._globalId && savefile.title === self.$dataSystem.gameTitle;
        }
      } else {
        return false;
      }
    }
    static isAnySavefileExists() {
      const globalInfo = this.loadGlobalInfo();
      if (globalInfo) {
        for (let i = 1; i < globalInfo.length; i++) {
          const result2 = this.isThisGameFile(i);
          if (result2) {
            return true;
          }
        }
      }
      return false;
    }
    static latestSavefileId() {
      const globalInfo = this.loadGlobalInfo();
      let savefileId = 1;
      let timestamp = 0;
      if (globalInfo) {
        for (let i = 1; i < globalInfo.length; i++) {
          if (this.isThisGameFile(i) && globalInfo[i].timestamp > timestamp) {
            timestamp = globalInfo[i].timestamp;
            savefileId = i;
          }
        }
      }
      return savefileId;
    }
    static loadAllSavefileImages() {
      const globalInfo = this.loadGlobalInfo();
      if (globalInfo) {
        for (let i = 1; i < globalInfo.length; i++) {
          if (this.isThisGameFile(i)) {
            const info = globalInfo[i];
            this.loadSavefileImages(info);
          }
        }
      }
    }
    static async saveGame(savefileId) {
      try {
        await StorageManagerShim_default.backup(savefileId);
        return await this.saveGameWithoutRescue(savefileId);
      } catch (e) {
        console.error(e);
        return false;
      }
    }
    static async loadGame(savefileId) {
      try {
        return await this.loadGameWithoutRescue(savefileId);
      } catch (e) {
        console.error(e);
        return false;
      }
    }
    static loadSavefileInfo(savefileId) {
      const globalInfo = this.loadGlobalInfo();
      return globalInfo && globalInfo[savefileId] ? globalInfo[savefileId] : null;
    }
    static lastAccessedSavefileId() {
      return this._lastAccessedId;
    }
    static async saveGameWithoutRescue(savefileId) {
      const json = JsonEx_default.stringify(this.makeSaveContents());
      if (json.length >= 2e5) {
        console.warn(
          "[DataManager.saveGameWithoutRescue] Save data length %i is larger than suggested 200000.",
          json.length
        );
      }
      await StorageManagerShim_default.save(savefileId, json);
      this._lastAccessedId = savefileId;
      const globalInfo = this.loadGlobalInfo() || [];
      globalInfo[savefileId] = this.makeSavefileInfo();
      await this.saveGlobalInfo(globalInfo);
      return true;
    }
    static async loadGameWithoutRescue(savefileId) {
      if (this.isThisGameFile(savefileId)) {
        const json = await StorageManagerShim_default.load(savefileId);
        this.createGameObjects();
        this.extractSaveContents(JsonEx_default.parse(json));
        this._lastAccessedId = savefileId;
        return true;
      } else {
        return false;
      }
    }
    static selectSavefileForNewGame() {
      const globalInfo = this.loadGlobalInfo();
      this._lastAccessedId = 1;
      if (globalInfo) {
        const numSavefiles = Math.max(0, globalInfo.length - 1);
        if (numSavefiles < this.maxSavefiles()) {
          this._lastAccessedId = numSavefiles + 1;
        } else {
          let timestamp = Number.MAX_VALUE;
          for (let i = 1; i < globalInfo.length; i++) {
            if (!globalInfo[i]) {
              this._lastAccessedId = i;
              break;
            }
            if (globalInfo[i].timestamp < timestamp) {
              timestamp = globalInfo[i].timestamp;
              this._lastAccessedId = i;
            }
          }
        }
      }
    }
    static makeSavefileInfo() {
      const info = {};
      info.globalId = this._globalId;
      info.title = self.$dataSystem.gameTitle;
      info.characters = self.$gameParty.charactersForSavefile();
      info.faces = self.$gameParty.facesForSavefile();
      info.playtime = self.$gameSystem.playtimeText();
      info.timestamp = Date.now();
      return info;
    }
    static setAutoSaveFileId(autoSaveFileId) {
      this._autoSaveFileId = autoSaveFileId;
    }
    static isAutoSaveFileId(saveFileId) {
      return this._autoSaveFileId !== 0 && this._autoSaveFileId === saveFileId;
    }
    static autoSaveGame() {
      if (this._autoSaveFileId !== 0 && !this.isEventTest() && self.$gameSystem.isSaveEnabled()) {
        self.$gameSystem.onBeforeSave();
        if (this.saveGame(this._autoSaveFileId)) {
          StorageManagerShim_default.cleanBackup(this._autoSaveFileId);
        }
      }
    }
    static makeEmptyMap() {
      self.$dataMap = {};
      self.$dataMap.data = [];
      self.$dataMap.events = [];
      self.$dataMap.width = 100;
      self.$dataMap.height = 100;
      self.$dataMap.scrollType = 3;
    }
    static extractMetadata(data) {
      const re = /<([^<>:]+)(:?)([^>]*)>/g;
      data.meta = {};
      for (; ; ) {
        const match = re.exec(data.note);
        if (match) {
          if (match[2] === ":") {
            data.meta[match[1]] = match[3];
          } else {
            data.meta[match[1]] = true;
          }
        } else {
          break;
        }
      }
    }
    static checkError() {
      if (DataManager2._errorUrl) {
        throw new Error(`Failed to load: ${DataManager2._errorUrl}`);
      }
    }
    static isBattleTest() {
      return Utils_default.isOptionValid("btest");
    }
    static isEventTest() {
      return Utils_default.isOptionValid("etest");
    }
    static isSkill(item2) {
      return item2 && self.$dataSkills.contains(item2);
    }
    static isItem(item2) {
      return item2 && self.$dataItems.contains(item2);
    }
    static isWeapon(item2) {
      return item2 && self.$dataWeapons.contains(item2);
    }
    static isArmor(item2) {
      return item2 && self.$dataArmors.contains(item2);
    }
    static createGameObjects() {
      self.$gameTemp = new Game_Temp_default();
      self.$gameSystem = new Game_System_default();
      self.$gameScreen = new Game_Screen_default();
      self.$gameTimer = new Game_Timer_default();
      self.$gameMessage = new Game_Message_default();
      self.$gameSwitches = new Game_Switches_default();
      self.$gameVariables = new Game_Variables_default();
      self.$gameSelfSwitches = new Game_SelfSwitches_default();
      self.$gameActors = new Game_Actors_default();
      self.$gameParty = new Game_Party_default();
      self.$gameTroop = new Game_Troop_default();
      self.$gameMap = new Game_Map_default();
      self.$gamePlayer = new Game_Player_default();
    }
    static loadSavefileImages({ characters, faces }) {
      if (characters) {
        for (let i = 0; i < characters.length; i++) {
          ImageManager_default.reserveCharacter(characters[i][0]);
        }
      }
      if (faces) {
        for (let j = 0; j < faces.length; j++) {
          ImageManager_default.reserveFace(faces[j][0]);
        }
      }
    }
    static maxSavefiles() {
      return 20;
    }
    static makeSaveContents() {
      const contents = {};
      contents.system = self.$gameSystem;
      contents.screen = self.$gameScreen;
      contents.timer = self.$gameTimer;
      contents.switches = self.$gameSwitches;
      contents.variables = self.$gameVariables;
      contents.selfSwitches = self.$gameSelfSwitches;
      contents.actors = self.$gameActors;
      contents.party = self.$gameParty;
      contents.map = self.$gameMap;
      contents.player = self.$gamePlayer;
      return contents;
    }
    static extractSaveContents(contents) {
      self.$gameSystem = contents.system;
      self.$gameScreen = contents.screen;
      self.$gameTimer = contents.timer;
      self.$gameSwitches = contents.switches;
      self.$gameVariables = contents.variables;
      self.$gameSelfSwitches = contents.selfSwitches;
      self.$gameActors = contents.actors;
      self.$gameParty = contents.party;
      self.$gameMap = contents.map;
      self.$gamePlayer = contents.player;
    }
  };
  DataManager2._globalId = "RPGMV";
  DataManager2._lastAccessedId = 1;
  DataManager2._errorUrl = null;
  DataManager2._autoSaveFileId = 0;
  DataManager2._databaseFiles = [
    {
      name: "$dataActors",
      src: "Actors.json"
    },
    {
      name: "$dataClasses",
      src: "Classes.json"
    },
    {
      name: "$dataSkills",
      src: "Skills.json"
    },
    {
      name: "$dataItems",
      src: "Items.json"
    },
    {
      name: "$dataWeapons",
      src: "Weapons.json"
    },
    {
      name: "$dataArmors",
      src: "Armors.json"
    },
    {
      name: "$dataEnemies",
      src: "Enemies.json"
    },
    {
      name: "$dataTroops",
      src: "Troops.json"
    },
    {
      name: "$dataStates",
      src: "States.json"
    },
    {
      name: "$dataAnimations",
      src: "Animations.json"
    },
    {
      name: "$dataTilesets",
      src: "Tilesets.json"
    },
    {
      name: "$dataCommonEvents",
      src: "CommonEvents.json"
    },
    {
      name: "$dataSystem",
      src: "System.json"
    },
    {
      name: "$dataMapInfos",
      src: "MapInfos.json"
    }
  ];
  var $dataActors = null;
  var $dataClasses = null;
  var $dataSkills = null;
  var $dataItems = null;
  var $dataWeapons = null;
  var $dataArmors = null;
  var $dataEnemies = null;
  var $dataTroops = null;
  var $dataStates = null;
  var $dataAnimations = null;
  var $dataTilesets = null;
  var $dataCommonEvents = null;
  var $dataSystem = null;
  var $dataMapInfos = null;
  var $dataMap = null;
  var $gameTemp = null;
  var $gameSystem = null;
  var $gameScreen = null;
  var $gameTimer = null;
  var $gameMessage = null;
  var $gameSwitches = null;
  var $gameVariables = null;
  var $gameSelfSwitches = null;
  var $gameActors = null;
  var $gameParty = null;
  var $gameTroop = null;
  var $gameMap = null;
  var $gamePlayer = null;
  var $testEvent = null;

  // src-www/js/Render_Thread.js
  self.PIXI = pixi_webworker_exports;
  self.$dataActors = $dataActors;
  self.$dataClasses = $dataClasses;
  self.$dataSkills = $dataSkills;
  self.$dataItems = $dataItems;
  self.$dataWeapons = $dataWeapons;
  self.$dataArmors = $dataArmors;
  self.$dataEnemies = $dataEnemies;
  self.$dataTroops = $dataTroops;
  self.$dataStates = $dataStates;
  self.$dataAnimations = $dataAnimations;
  self.$dataTilesets = $dataTilesets;
  self.$dataCommonEvents = $dataCommonEvents;
  self.$dataSystem = $dataSystem;
  self.$dataMapInfos = $dataMapInfos;
  self.$dataMap = $dataMap;
  self.$gameTemp = $gameTemp;
  self.$gameSystem = $gameSystem;
  self.$gameScreen = $gameScreen;
  self.$gameTimer = $gameTimer;
  self.$gameMessage = $gameMessage;
  self.$gameSwitches = $gameSwitches;
  self.$gameVariables = $gameVariables;
  self.$gameSelfSwitches = $gameSelfSwitches;
  self.$gameActors = $gameActors;
  self.$gameParty = $gameParty;
  self.$gameTroop = $gameTroop;
  self.$gameMap = $gameMap;
  self.$gamePlayer = $gamePlayer;
  self.$testEvent = $testEvent;
  self.Game_Temp = Game_Temp_default;
  self.Game_System = Game_System_default;
  self.Game_Timer = Game_Timer_default;
  self.Game_Message = Game_Message_default;
  self.Game_Switches = Game_Switches_default;
  self.Game_Variables = Game_Variables_default;
  self.Game_SelfSwitches = Game_SelfSwitches_default;
  self.Game_Screen = Game_Screen_default;
  self.Game_Picture = Game_Picture_default;
  self.Game_Item = Game_Item_default;
  self.Game_Action = Game_Action_default;
  self.Game_ActionResult = Game_ActionResult_default;
  self.Game_BattlerBase = Game_BattlerBase_default;
  self.Game_Battler = Game_Battler_default;
  self.Game_Actor = Game_Actor_default;
  self.Game_Enemy = Game_Enemy_default;
  self.Game_Actors = Game_Actors_default;
  self.Game_Unit = Game_Unit_default;
  self.Game_Party = Game_Party_default;
  self.Game_Troop = Game_Troop_default;
  self.Game_Map = Game_Map_default;
  self.Game_CommonEvent = Game_CommonEvent_default;
  self.Game_CharacterBase = Game_CharacterBase_default;
  self.Game_Character = Game_Character_default;
  self.Game_Player = Game_Player_default;
  self.Game_Follower = Game_Follower_default;
  self.Game_Followers = Game_Followers_default;
  self.Game_Vehicle = Game_Vehicle_default;
  self.Game_Event = Game_Event_default;
  self.Game_Interpreter = Game_Interpreter_default;
  self.Scene_Base = Scene_Base_default;
  self.Scene_Boot = Scene_Boot_default;
  self.Scene_Title = Scene_Title_default;
  self.Scene_Map = Scene_Map_default;
  self.Scene_MenuBase = Scene_MenuBase_default;
  self.Scene_Menu = Scene_Menu_default;
  self.Scene_ItemBase = Scene_ItemBase_default;
  self.Scene_Item = Scene_Item_default;
  self.Scene_Skill = Scene_Skill_default;
  self.Scene_Equip = Scene_Equip_default;
  self.Scene_Status = Scene_Status_default;
  self.Scene_Options = Scene_Options_default;
  self.Scene_File = Scene_File_default;
  self.Scene_Save = Scene_Save_default;
  self.Scene_Load = Scene_Load_default;
  self.Scene_GameEnd = Scene_GameEnd_default;
  self.Scene_Shop = Scene_Shop_default;
  self.Scene_Name = Scene_Name_default;
  self.Scene_Debug = Scene_Debug_default;
  self.Scene_Battle = Scene_Battle_default;
  self.Scene_Gameover = Scene_Gameover_default;
  self.Sprite_Base = Sprite_Base_default;
  self.Sprite_Button = Sprite_Button_default;
  self.Sprite_Character = Sprite_Character_default;
  self.Sprite_Battler = Sprite_Battler_default;
  self.Sprite_Actor = Sprite_Actor_default;
  self.Sprite_Enemy = Sprite_Enemy_default;
  self.Sprite_Animation = Sprite_Animation_default;
  self.Sprite_Damage = Sprite_Damage_default;
  self.Sprite_StateIcon = Sprite_StateIcon_default;
  self.Sprite_StateOverlay = Sprite_StateOverlay_default;
  self.Sprite_Weapon = Sprite_Weapon_default;
  self.Sprite_Balloon = Sprite_Balloon_default;
  self.Sprite_Picture = Sprite_Picture_default;
  self.Sprite_Timer = Sprite_Timer_default;
  self.Sprite_Destination = Sprite_Destination_default;
  self.Spriteset_Base = Spriteset_Base_default;
  self.Spriteset_Map = Spriteset_Map_default;
  self.Spriteset_Battle = Spriteset_Battle_default;
  self.Window_Base = Window_Base_default;
  self.Window_Selectable = Window_Selectable_default;
  self.Window_Command = Window_Command_default;
  self.Window_HorzCommand = Window_HorzCommand_default;
  self.Window_Help = Window_Help_default;
  self.Window_Gold = Window_Gold_default;
  self.Window_MenuCommand = Window_MenuCommand_default;
  self.Window_MenuStatus = Window_MenuStatus_default;
  self.Window_MenuActor = Window_MenuActor_default;
  self.Window_ItemCategory = Window_ItemCategory_default;
  self.Window_ItemList = Window_ItemList_default;
  self.Window_SkillType = Window_SkillType_default;
  self.Window_SkillStatus = Window_SkillStatus_default;
  self.Window_SkillList = Window_SkillList_default;
  self.Window_EquipStatus = Window_EquipStatus_default;
  self.Window_EquipCommand = Window_EquipCommand_default;
  self.Window_EquipSlot = Window_EquipSlot_default;
  self.Window_EquipItem = Window_EquipItem_default;
  self.Window_Status = Window_Status_default;
  self.Window_Options = Window_Options_default;
  self.Window_SavefileList = Window_SavefileList_default;
  self.Window_ShopCommand = Window_ShopCommand_default;
  self.Window_ShopBuy = Window_ShopBuy_default;
  self.Window_ShopSell = Window_ShopSell_default;
  self.Window_ShopNumber = Window_ShopNumber_default;
  self.Window_ShopStatus = Window_ShopStatus_default;
  self.Window_NameEdit = Window_NameEdit_default;
  self.Window_NameInput = Window_NameInput_default;
  self.Window_ChoiceList = Window_ChoiceList_default;
  self.Window_NumberInput = Window_NumberInput_default;
  self.Window_EventItem = Window_EventItem_default;
  self.Window_Message = Window_Message_default;
  self.Window_ScrollText = Window_ScrollText_default;
  self.Window_MapName = Window_MapName_default;
  self.Window_BattleLog = Window_BattleLog_default;
  self.Window_PartyCommand = Window_PartyCommand_default;
  self.Window_ActorCommand = Window_ActorCommand_default;
  self.Window_BattleStatus = Window_BattleStatus_default;
  self.Window_BattleActor = Window_BattleActor_default;
  self.Window_BattleEnemy = Window_BattleEnemy_default;
  self.Window_BattleSkill = Window_BattleSkill_default;
  self.Window_BattleItem = Window_BattleItem_default;
  self.Window_TitleCommand = Window_TitleCommand_default;
  self.Window_GameEnd = Window_GameEnd_default;
  self.Window_DebugRange = Window_DebugRange_default;
  self.Window_DebugEdit = Window_DebugEdit_default;
  self.ProgressWatcher = ProgressWatcher_default;
  self.Utils = Utils_default;
  self.CacheEntry = CacheEntry_default;
  self.CacheMap = CacheMap_default;
  self.ImageCache = ImageCache_default;
  self.RequestQueue = RequestQueue_default;
  self.Point = Point_default;
  self.Rectangle = Rectangle_default;
  self.Bitmap = Bitmap_default;
  self.Graphics = Graphics_default;
  self.Input = Input_default;
  self.TouchInput = TouchInput_default;
  self.Sprite = Sprite_default;
  self.Tilemap = Tilemap_default;
  self.TilingSprite = TilingSprite_default;
  self.ScreenSprite = ScreenSprite_default;
  self.WindowSkinCache = WindowSkinCache_default;
  self.Window = Window_default;
  self.WindowLayer = WindowLayer_default;
  self.ToneFilter = ToneFilter_default;
  self.ToneSprite = ToneSprite_default;
  self.Stage = Stage_default;
  self.WebAudio = WebAudio_default;
  self.JsonEx = JsonEx_default;
  self.ResourceHandler = ResourceHandler_default;
  self.DataManager = DataManager2;
  self.ConfigManager = ConfigManager_default;
  self.StorageManager = StorageManagerShim_default;
  self.ImageManager = ImageManager_default;
  self.AudioManager = AudioManager_default;
  self.SoundManager = SoundManager_default;
  self.TextManager = TextManager_default;
  self.SceneManager = SceneManager_default;
  self.BattleManager = BattleManager_default;
  self.PluginManager = PluginManager_default;
  var Render_Thread = class {
    constructor() {
      throw new Error("This is a static class");
    }
    static _setupPixiSettings() {
      settings.SCALE_MODE = SCALE_MODES.NEAREST;
      settings.ROUND_PIXELS = true;
      settings.GC_MAX_IDLE = 600;
      settings.MIPMAP_TEXTURES = MIPMAP_MODES.OFF;
      settings.RESOLUTION = window.devicePixelRatio;
      if (Utils_default.isMobileSafari()) {
        settings.PRECISION_FRAGMENT = PRECISION.HIGH;
      }
    }
    static async updateWindowData(payload) {
      console.log("updateWindowData", payload);
      this.initWindowAndDocument();
      Object.entries(payload).forEach(
        ([key, value3]) => self.window[key] = value3
      );
      return true;
    }
    static async updatePluginData(payload) {
      console.log("updatePluginData", payload);
      this.initWindowAndDocument();
      self.$plugins = payload;
      return true;
    }
    static initWindowAndDocument() {
      if (!self.window) {
        self.window = WindowShim_default;
      }
      if (!self.document) {
        self.document = DocumentShim_default;
      }
    }
    static async receiveEvent(payload) {
      if (payload.shimType === "window") {
        self.window.triggerEvent(payload);
      } else {
        self.document.triggerEvent(payload);
      }
      return true;
    }
    static async start() {
      this.initWindowAndDocument();
      this._setupPixiSettings();
      SceneManager_default.run(Scene_Boot_default);
      return true;
    }
    static receiveCanvas(offscreenCanvas) {
      self.Graphics._canvas = offscreenCanvas;
      return true;
    }
  };
  var messenger = new WorkerMessenger({ worker: self });
  ChildHandshake(messenger, Render_Thread).then((connection) => {
    const localHandle = connection.localHandle();
    localHandle.emit("ping", "Oh, hi!");
  });
})();
/*!
 * @pixi/webworker - v7.0.5
 * Compiled Mon, 12 Dec 2022 15:56:40 UTC
 *
 * @pixi/webworker is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! https://mths.be/punycode v1.3.2 by @mathias */
//# sourceMappingURL=Render_Thread.js.map
