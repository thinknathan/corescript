(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/eventemitter3/index.js
  var require_eventemitter3 = __commonJS({
    "node_modules/eventemitter3/index.js"(exports, module) {
      "use strict";
      var has = Object.prototype.hasOwnProperty;
      var prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__)
          prefix = false;
      }
      function EE(fn, context3, once) {
        this.fn = fn;
        this.context = context3;
        this.once = once || false;
      }
      function addListener(emitter, event, fn, context3, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context3 || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt])
          emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn)
          emitter._events[evt].push(listener);
        else
          emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0)
          emitter._events = new Events();
        else
          delete emitter._events[evt];
      }
      function EventEmitter() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter.prototype.eventNames = function eventNames() {
        var names = [], events, name;
        if (this._eventsCount === 0)
          return names;
        for (name in events = this._events) {
          if (has.call(events, name))
            names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      };
      EventEmitter.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers)
          return [];
        if (handlers.fn)
          return [handlers.fn];
        for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
          ee[i] = handlers[i].fn;
        }
        return ee;
      };
      EventEmitter.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners)
          return 0;
        if (listeners.fn)
          return 1;
        return listeners.length;
      };
      EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return false;
        var listeners = this._events[evt], len = arguments.length, args, i;
        if (listeners.fn) {
          if (listeners.once)
            this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i = 1, args = new Array(len - 1); i < len; i++) {
            args[i - 1] = arguments[i];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j;
          for (i = 0; i < length; i++) {
            if (listeners[i].once)
              this.removeListener(event, listeners[i].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i].fn.call(listeners[i].context);
                break;
              case 2:
                listeners[i].fn.call(listeners[i].context, a1);
                break;
              case 3:
                listeners[i].fn.call(listeners[i].context, a1, a2);
                break;
              case 4:
                listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                break;
              default:
                if (!args)
                  for (j = 1, args = new Array(len - 1); j < len; j++) {
                    args[j - 1] = arguments[j];
                  }
                listeners[i].fn.apply(listeners[i].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter.prototype.on = function on(event, fn, context3) {
        return addListener(this, event, fn, context3, false);
      };
      EventEmitter.prototype.once = function once(event, fn, context3) {
        return addListener(this, event, fn, context3, true);
      };
      EventEmitter.prototype.removeListener = function removeListener(event, fn, context3, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context3 || listeners.context === context3)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i = 0, events = [], length = listeners.length; i < length; i++) {
            if (listeners[i].fn !== fn || once && !listeners[i].once || context3 && listeners[i].context !== context3) {
              events.push(listeners[i]);
            }
          }
          if (events.length)
            this._events[evt] = events.length === 1 ? events[0] : events;
          else
            clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt])
            clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
      EventEmitter.prototype.addListener = EventEmitter.prototype.on;
      EventEmitter.prefixed = prefix;
      EventEmitter.EventEmitter = EventEmitter;
      if ("undefined" !== typeof module) {
        module.exports = EventEmitter;
      }
    }
  });

  // node_modules/earcut/src/earcut.js
  var require_earcut = __commonJS({
    "node_modules/earcut/src/earcut.js"(exports, module) {
      "use strict";
      module.exports = earcut;
      module.exports.default = earcut;
      function earcut(data, holeIndices, dim) {
        dim = dim || 2;
        var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev)
          return triangles;
        var minX, minY, maxX, maxY, x, y, invSize;
        if (hasHoles)
          outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        if (data.length > 80 * dim) {
          minX = maxX = data[0];
          minY = maxY = data[1];
          for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX)
              minX = x;
            if (y < minY)
              minY = y;
            if (x > maxX)
              maxX = x;
            if (y > maxY)
              maxY = y;
          }
          invSize = Math.max(maxX - minX, maxY - minY);
          invSize = invSize !== 0 ? 32767 / invSize : 0;
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
        return triangles;
      }
      function linkedList(data, start, end, dim, clockwise) {
        var i, last;
        if (clockwise === signedArea(data, start, end, dim) > 0) {
          for (i = start; i < end; i += dim)
            last = insertNode(i, data[i], data[i + 1], last);
        } else {
          for (i = end - dim; i >= start; i -= dim)
            last = insertNode(i, data[i], data[i + 1], last);
        }
        if (last && equals(last, last.next)) {
          removeNode(last);
          last = last.next;
        }
        return last;
      }
      function filterPoints(start, end) {
        if (!start)
          return start;
        if (!end)
          end = start;
        var p = start, again;
        do {
          again = false;
          if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next)
              break;
            again = true;
          } else {
            p = p.next;
          }
        } while (again || p !== end);
        return end;
      }
      function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear)
          return;
        if (!pass && invSize)
          indexCurve(ear, minX, minY, invSize);
        var stop = ear, prev, next;
        while (ear.prev !== ear.next) {
          prev = ear.prev;
          next = ear.next;
          if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);
            removeNode(ear);
            ear = next.next;
            stop = next.next;
            continue;
          }
          ear = next;
          if (ear === stop) {
            if (!pass) {
              earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            } else if (pass === 1) {
              ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
              earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            } else if (pass === 2) {
              splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }
            break;
          }
        }
      }
      function isEar(ear) {
        var a = ear.prev, b = ear, c = ear.next;
        if (area(a, b, c) >= 0)
          return false;
        var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
        var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
        var p = c.next;
        while (p !== a) {
          if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
            return false;
          p = p.next;
        }
        return true;
      }
      function isEarHashed(ear, minX, minY, invSize) {
        var a = ear.prev, b = ear, c = ear.next;
        if (area(a, b, c) >= 0)
          return false;
        var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
        var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
        var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
        var p = ear.prevZ, n = ear.nextZ;
        while (p && p.z >= minZ && n && n.z <= maxZ) {
          if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
            return false;
          p = p.prevZ;
          if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
            return false;
          n = n.nextZ;
        }
        while (p && p.z >= minZ) {
          if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
            return false;
          p = p.prevZ;
        }
        while (n && n.z <= maxZ) {
          if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
            return false;
          n = n.nextZ;
        }
        return true;
      }
      function cureLocalIntersections(start, triangles, dim) {
        var p = start;
        do {
          var a = p.prev, b = p.next.next;
          if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim | 0);
            triangles.push(p.i / dim | 0);
            triangles.push(b.i / dim | 0);
            removeNode(p);
            removeNode(p.next);
            p = start = b;
          }
          p = p.next;
        } while (p !== start);
        return filterPoints(p);
      }
      function splitEarcut(start, triangles, dim, minX, minY, invSize) {
        var a = start;
        do {
          var b = a.next.next;
          while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
              var c = splitPolygon(a, b);
              a = filterPoints(a, a.next);
              c = filterPoints(c, c.next);
              earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
              earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
              return;
            }
            b = b.next;
          }
          a = a.next;
        } while (a !== start);
      }
      function eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [], i, len, start, end, list;
        for (i = 0, len = holeIndices.length; i < len; i++) {
          start = holeIndices[i] * dim;
          end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
          list = linkedList(data, start, end, dim, false);
          if (list === list.next)
            list.steiner = true;
          queue.push(getLeftmost(list));
        }
        queue.sort(compareX);
        for (i = 0; i < queue.length; i++) {
          outerNode = eliminateHole(queue[i], outerNode);
        }
        return outerNode;
      }
      function compareX(a, b) {
        return a.x - b.x;
      }
      function eliminateHole(hole, outerNode) {
        var bridge = findHoleBridge(hole, outerNode);
        if (!bridge) {
          return outerNode;
        }
        var bridgeReverse = splitPolygon(bridge, hole);
        filterPoints(bridgeReverse, bridgeReverse.next);
        return filterPoints(bridge, bridge.next);
      }
      function findHoleBridge(hole, outerNode) {
        var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
        do {
          if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
              qx = x;
              m = p.x < p.next.x ? p : p.next;
              if (x === hx)
                return m;
            }
          }
          p = p.next;
        } while (p !== outerNode);
        if (!m)
          return null;
        var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan2;
        p = m;
        do {
          if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan2 = Math.abs(hy - p.y) / (hx - p.x);
            if (locallyInside(p, hole) && (tan2 < tanMin || tan2 === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
              m = p;
              tanMin = tan2;
            }
          }
          p = p.next;
        } while (p !== stop);
        return m;
      }
      function sectorContainsSector(m, p) {
        return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
      }
      function indexCurve(start, minX, minY, invSize) {
        var p = start;
        do {
          if (p.z === 0)
            p.z = zOrder(p.x, p.y, minX, minY, invSize);
          p.prevZ = p.prev;
          p.nextZ = p.next;
          p = p.next;
        } while (p !== start);
        p.prevZ.nextZ = null;
        p.prevZ = null;
        sortLinked(p);
      }
      function sortLinked(list) {
        var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
        do {
          p = list;
          list = null;
          tail = null;
          numMerges = 0;
          while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
              pSize++;
              q = q.nextZ;
              if (!q)
                break;
            }
            qSize = inSize;
            while (pSize > 0 || qSize > 0 && q) {
              if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                e = p;
                p = p.nextZ;
                pSize--;
              } else {
                e = q;
                q = q.nextZ;
                qSize--;
              }
              if (tail)
                tail.nextZ = e;
              else
                list = e;
              e.prevZ = tail;
              tail = e;
            }
            p = q;
          }
          tail.nextZ = null;
          inSize *= 2;
        } while (numMerges > 1);
        return list;
      }
      function zOrder(x, y, minX, minY, invSize) {
        x = (x - minX) * invSize | 0;
        y = (y - minY) * invSize | 0;
        x = (x | x << 8) & 16711935;
        x = (x | x << 4) & 252645135;
        x = (x | x << 2) & 858993459;
        x = (x | x << 1) & 1431655765;
        y = (y | y << 8) & 16711935;
        y = (y | y << 4) & 252645135;
        y = (y | y << 2) & 858993459;
        y = (y | y << 1) & 1431655765;
        return x | y << 1;
      }
      function getLeftmost(start) {
        var p = start, leftmost = start;
        do {
          if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
            leftmost = p;
          p = p.next;
        } while (p !== start);
        return leftmost;
      }
      function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
      }
      function isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
        (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
        (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
        equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
      }
      function area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
      }
      function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
      }
      function intersects(p1, q1, p2, q2) {
        var o1 = sign2(area(p1, q1, p2));
        var o2 = sign2(area(p1, q1, q2));
        var o3 = sign2(area(p2, q2, p1));
        var o4 = sign2(area(p2, q2, q1));
        if (o1 !== o2 && o3 !== o4)
          return true;
        if (o1 === 0 && onSegment(p1, p2, q1))
          return true;
        if (o2 === 0 && onSegment(p1, q2, q1))
          return true;
        if (o3 === 0 && onSegment(p2, p1, q2))
          return true;
        if (o4 === 0 && onSegment(p2, q1, q2))
          return true;
        return false;
      }
      function onSegment(p, q, r) {
        return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
      }
      function sign2(num) {
        return num > 0 ? 1 : num < 0 ? -1 : 0;
      }
      function intersectsPolygon(a, b) {
        var p = a;
        do {
          if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
            return true;
          p = p.next;
        } while (p !== a);
        return false;
      }
      function locallyInside(a, b) {
        return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
      }
      function middleInside(a, b) {
        var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
        do {
          if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
            inside = !inside;
          p = p.next;
        } while (p !== a);
        return inside;
      }
      function splitPolygon(a, b) {
        var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
        a.next = b;
        b.prev = a;
        a2.next = an;
        an.prev = a2;
        b2.next = a2;
        a2.prev = b2;
        bp.next = b2;
        b2.prev = bp;
        return b2;
      }
      function insertNode(i, x, y, last) {
        var p = new Node(i, x, y);
        if (!last) {
          p.prev = p;
          p.next = p;
        } else {
          p.next = last.next;
          p.prev = last;
          last.next.prev = p;
          last.next = p;
        }
        return p;
      }
      function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        if (p.prevZ)
          p.prevZ.nextZ = p.nextZ;
        if (p.nextZ)
          p.nextZ.prevZ = p.prevZ;
      }
      function Node(i, x, y) {
        this.i = i;
        this.x = x;
        this.y = y;
        this.prev = null;
        this.next = null;
        this.z = 0;
        this.prevZ = null;
        this.nextZ = null;
        this.steiner = false;
      }
      earcut.deviation = function(data, holeIndices, dim, triangles) {
        var hasHoles = holeIndices && holeIndices.length;
        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
        if (hasHoles) {
          for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
          }
        }
        var trianglesArea = 0;
        for (i = 0; i < triangles.length; i += 3) {
          var a = triangles[i] * dim;
          var b = triangles[i + 1] * dim;
          var c = triangles[i + 2] * dim;
          trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1])
          );
        }
        return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
      };
      function signedArea(data, start, end, dim) {
        var sum = 0;
        for (var i = start, j = end - dim; i < end; i += dim) {
          sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
          j = i;
        }
        return sum;
      }
      earcut.flatten = function(data) {
        var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
        for (var i = 0; i < data.length; i++) {
          for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++)
              result.vertices.push(data[i][j][d]);
          }
          if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
          }
        }
        return result;
      };
    }
  });

  // node_modules/punycode/punycode.js
  var require_punycode = __commonJS({
    "node_modules/punycode/punycode.js"(exports, module) {
      (function(root) {
        var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
        var freeModule = typeof module == "object" && module && !module.nodeType && module;
        var freeGlobal = typeof global == "object" && global;
        if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
          root = freeGlobal;
        }
        var punycode2, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
          "overflow": "Overflow: input needs wider integers to process",
          "not-basic": "Illegal input >= 0x80 (not a basic code point)",
          "invalid-input": "Invalid input"
        }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
        function error(type) {
          throw RangeError(errors[type]);
        }
        function map4(array, fn) {
          var length = array.length;
          var result = [];
          while (length--) {
            result[length] = fn(array[length]);
          }
          return result;
        }
        function mapDomain(string, fn) {
          var parts = string.split("@");
          var result = "";
          if (parts.length > 1) {
            result = parts[0] + "@";
            string = parts[1];
          }
          string = string.replace(regexSeparators, ".");
          var labels = string.split(".");
          var encoded = map4(labels, fn).join(".");
          return result + encoded;
        }
        function ucs2decode(string) {
          var output = [], counter = 0, length = string.length, value, extra;
          while (counter < length) {
            value = string.charCodeAt(counter++);
            if (value >= 55296 && value <= 56319 && counter < length) {
              extra = string.charCodeAt(counter++);
              if ((extra & 64512) == 56320) {
                output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
              } else {
                output.push(value);
                counter--;
              }
            } else {
              output.push(value);
            }
          }
          return output;
        }
        function ucs2encode(array) {
          return map4(array, function(value) {
            var output = "";
            if (value > 65535) {
              value -= 65536;
              output += stringFromCharCode(value >>> 10 & 1023 | 55296);
              value = 56320 | value & 1023;
            }
            output += stringFromCharCode(value);
            return output;
          }).join("");
        }
        function basicToDigit(codePoint) {
          if (codePoint - 48 < 10) {
            return codePoint - 22;
          }
          if (codePoint - 65 < 26) {
            return codePoint - 65;
          }
          if (codePoint - 97 < 26) {
            return codePoint - 97;
          }
          return base;
        }
        function digitToBasic(digit, flag) {
          return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
        }
        function adapt(delta, numPoints, firstTime) {
          var k = 0;
          delta = firstTime ? floor(delta / damp) : delta >> 1;
          delta += floor(delta / numPoints);
          for (; delta > baseMinusTMin * tMax >> 1; k += base) {
            delta = floor(delta / baseMinusTMin);
          }
          return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
        }
        function decode2(input) {
          var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;
          basic = input.lastIndexOf(delimiter);
          if (basic < 0) {
            basic = 0;
          }
          for (j = 0; j < basic; ++j) {
            if (input.charCodeAt(j) >= 128) {
              error("not-basic");
            }
            output.push(input.charCodeAt(j));
          }
          for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
            for (oldi = i, w = 1, k = base; ; k += base) {
              if (index >= inputLength) {
                error("invalid-input");
              }
              digit = basicToDigit(input.charCodeAt(index++));
              if (digit >= base || digit > floor((maxInt - i) / w)) {
                error("overflow");
              }
              i += digit * w;
              t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (digit < t) {
                break;
              }
              baseMinusT = base - t;
              if (w > floor(maxInt / baseMinusT)) {
                error("overflow");
              }
              w *= baseMinusT;
            }
            out = output.length + 1;
            bias = adapt(i - oldi, out, oldi == 0);
            if (floor(i / out) > maxInt - n) {
              error("overflow");
            }
            n += floor(i / out);
            i %= out;
            output.splice(i++, 0, n);
          }
          return ucs2encode(output);
        }
        function encode2(input) {
          var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
          input = ucs2decode(input);
          inputLength = input.length;
          n = initialN;
          delta = 0;
          bias = initialBias;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < 128) {
              output.push(stringFromCharCode(currentValue));
            }
          }
          handledCPCount = basicLength = output.length;
          if (basicLength) {
            output.push(delimiter);
          }
          while (handledCPCount < inputLength) {
            for (m = maxInt, j = 0; j < inputLength; ++j) {
              currentValue = input[j];
              if (currentValue >= n && currentValue < m) {
                m = currentValue;
              }
            }
            handledCPCountPlusOne = handledCPCount + 1;
            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
              error("overflow");
            }
            delta += (m - n) * handledCPCountPlusOne;
            n = m;
            for (j = 0; j < inputLength; ++j) {
              currentValue = input[j];
              if (currentValue < n && ++delta > maxInt) {
                error("overflow");
              }
              if (currentValue == n) {
                for (q = delta, k = base; ; k += base) {
                  t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (q < t) {
                    break;
                  }
                  qMinusT = q - t;
                  baseMinusT = base - t;
                  output.push(
                    stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                  );
                  q = floor(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }
            ++delta;
            ++n;
          }
          return output.join("");
        }
        function toUnicode(input) {
          return mapDomain(input, function(string) {
            return regexPunycode.test(string) ? decode2(string.slice(4).toLowerCase()) : string;
          });
        }
        function toASCII(input) {
          return mapDomain(input, function(string) {
            return regexNonASCII.test(string) ? "xn--" + encode2(string) : string;
          });
        }
        punycode2 = {
          /**
           * A string representing the current Punycode.js version number.
           * @memberOf punycode
           * @type String
           */
          "version": "1.3.2",
          /**
           * An object of methods to convert from JavaScript's internal character
           * representation (UCS-2) to Unicode code points, and back.
           * @see <https://mathiasbynens.be/notes/javascript-encoding>
           * @memberOf punycode
           * @type Object
           */
          "ucs2": {
            "decode": ucs2decode,
            "encode": ucs2encode
          },
          "decode": decode2,
          "encode": encode2,
          "toASCII": toASCII,
          "toUnicode": toUnicode
        };
        if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
          define("punycode", function() {
            return punycode2;
          });
        } else if (freeExports && freeModule) {
          if (module.exports == freeExports) {
            freeModule.exports = punycode2;
          } else {
            for (key in punycode2) {
              punycode2.hasOwnProperty(key) && (freeExports[key] = punycode2[key]);
            }
          }
        } else {
          root.punycode = punycode2;
        }
      })(exports);
    }
  });

  // node_modules/url/util.js
  var require_util = __commonJS({
    "node_modules/url/util.js"(exports, module) {
      "use strict";
      module.exports = {
        isString: function(arg) {
          return typeof arg === "string";
        },
        isObject: function(arg) {
          return typeof arg === "object" && arg !== null;
        },
        isNull: function(arg) {
          return arg === null;
        },
        isNullOrUndefined: function(arg) {
          return arg == null;
        }
      };
    }
  });

  // node_modules/querystring/decode.js
  var require_decode = __commonJS({
    "node_modules/querystring/decode.js"(exports, module) {
      "use strict";
      function hasOwnProperty2(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      module.exports = function(qs, sep, eq, options) {
        sep = sep || "&";
        eq = eq || "=";
        var obj = {};
        if (typeof qs !== "string" || qs.length === 0) {
          return obj;
        }
        var regexp = /\+/g;
        qs = qs.split(sep);
        var maxKeys = 1e3;
        if (options && typeof options.maxKeys === "number") {
          maxKeys = options.maxKeys;
        }
        var len = qs.length;
        if (maxKeys > 0 && len > maxKeys) {
          len = maxKeys;
        }
        for (var i = 0; i < len; ++i) {
          var x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v;
          if (idx >= 0) {
            kstr = x.substr(0, idx);
            vstr = x.substr(idx + 1);
          } else {
            kstr = x;
            vstr = "";
          }
          k = decodeURIComponent(kstr);
          v = decodeURIComponent(vstr);
          if (!hasOwnProperty2(obj, k)) {
            obj[k] = v;
          } else if (Array.isArray(obj[k])) {
            obj[k].push(v);
          } else {
            obj[k] = [obj[k], v];
          }
        }
        return obj;
      };
    }
  });

  // node_modules/querystring/encode.js
  var require_encode = __commonJS({
    "node_modules/querystring/encode.js"(exports, module) {
      "use strict";
      var stringifyPrimitive2 = function(v) {
        switch (typeof v) {
          case "string":
            return v;
          case "boolean":
            return v ? "true" : "false";
          case "number":
            return isFinite(v) ? v : "";
          default:
            return "";
        }
      };
      module.exports = function(obj, sep, eq, name) {
        sep = sep || "&";
        eq = eq || "=";
        if (obj === null) {
          obj = void 0;
        }
        if (typeof obj === "object") {
          return Object.keys(obj).map(function(k) {
            var ks = encodeURIComponent(stringifyPrimitive2(k)) + eq;
            if (Array.isArray(obj[k])) {
              return obj[k].map(function(v) {
                return ks + encodeURIComponent(stringifyPrimitive2(v));
              }).join(sep);
            } else {
              return ks + encodeURIComponent(stringifyPrimitive2(obj[k]));
            }
          }).join(sep);
        }
        if (!name)
          return "";
        return encodeURIComponent(stringifyPrimitive2(name)) + eq + encodeURIComponent(stringifyPrimitive2(obj));
      };
    }
  });

  // node_modules/querystring/index.js
  var require_querystring = __commonJS({
    "node_modules/querystring/index.js"(exports) {
      "use strict";
      exports.decode = exports.parse = require_decode();
      exports.encode = exports.stringify = require_encode();
    }
  });

  // node_modules/url/url.js
  var require_url = __commonJS({
    "node_modules/url/url.js"(exports) {
      "use strict";
      var punycode2 = require_punycode();
      var util2 = require_util();
      exports.parse = urlParse2;
      exports.resolve = urlResolve2;
      exports.resolveObject = urlResolveObject;
      exports.format = urlFormat2;
      exports.Url = Url2;
      function Url2() {
        this.protocol = null;
        this.slashes = null;
        this.auth = null;
        this.host = null;
        this.port = null;
        this.hostname = null;
        this.hash = null;
        this.search = null;
        this.query = null;
        this.pathname = null;
        this.path = null;
        this.href = null;
      }
      var protocolPattern2 = /^([a-z0-9.+-]+:)/i;
      var portPattern2 = /:[0-9]*$/;
      var simplePathPattern2 = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
      var delims2 = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
      var unwise2 = ["{", "}", "|", "\\", "^", "`"].concat(delims2);
      var autoEscape2 = ["'"].concat(unwise2);
      var nonHostChars2 = ["%", "/", "?", ";", "#"].concat(autoEscape2);
      var hostEndingChars2 = ["/", "?", "#"];
      var hostnameMaxLen2 = 255;
      var hostnamePartPattern2 = /^[+a-z0-9A-Z_-]{0,63}$/;
      var hostnamePartStart2 = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
      var unsafeProtocol2 = {
        "javascript": true,
        "javascript:": true
      };
      var hostlessProtocol2 = {
        "javascript": true,
        "javascript:": true
      };
      var slashedProtocol2 = {
        "http": true,
        "https": true,
        "ftp": true,
        "gopher": true,
        "file": true,
        "http:": true,
        "https:": true,
        "ftp:": true,
        "gopher:": true,
        "file:": true
      };
      var querystring2 = require_querystring();
      function urlParse2(url3, parseQueryString, slashesDenoteHost) {
        if (url3 && util2.isObject(url3) && url3 instanceof Url2)
          return url3;
        var u = new Url2();
        u.parse(url3, parseQueryString, slashesDenoteHost);
        return u;
      }
      Url2.prototype.parse = function(url3, parseQueryString, slashesDenoteHost) {
        if (!util2.isString(url3)) {
          throw new TypeError("Parameter 'url' must be a string, not " + typeof url3);
        }
        var queryIndex = url3.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url3.indexOf("#") ? "?" : "#", uSplit = url3.split(splitter), slashRegex = /\\/g;
        uSplit[0] = uSplit[0].replace(slashRegex, "/");
        url3 = uSplit.join(splitter);
        var rest = url3;
        rest = rest.trim();
        if (!slashesDenoteHost && url3.split("#").length === 1) {
          var simplePath = simplePathPattern2.exec(rest);
          if (simplePath) {
            this.path = rest;
            this.href = rest;
            this.pathname = simplePath[1];
            if (simplePath[2]) {
              this.search = simplePath[2];
              if (parseQueryString) {
                this.query = querystring2.parse(this.search.substr(1));
              } else {
                this.query = this.search.substr(1);
              }
            } else if (parseQueryString) {
              this.search = "";
              this.query = {};
            }
            return this;
          }
        }
        var proto = protocolPattern2.exec(rest);
        if (proto) {
          proto = proto[0];
          var lowerProto = proto.toLowerCase();
          this.protocol = lowerProto;
          rest = rest.substr(proto.length);
        }
        if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
          var slashes = rest.substr(0, 2) === "//";
          if (slashes && !(proto && hostlessProtocol2[proto])) {
            rest = rest.substr(2);
            this.slashes = true;
          }
        }
        if (!hostlessProtocol2[proto] && (slashes || proto && !slashedProtocol2[proto])) {
          var hostEnd = -1;
          for (var i = 0; i < hostEndingChars2.length; i++) {
            var hec = rest.indexOf(hostEndingChars2[i]);
            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
              hostEnd = hec;
          }
          var auth, atSign;
          if (hostEnd === -1) {
            atSign = rest.lastIndexOf("@");
          } else {
            atSign = rest.lastIndexOf("@", hostEnd);
          }
          if (atSign !== -1) {
            auth = rest.slice(0, atSign);
            rest = rest.slice(atSign + 1);
            this.auth = decodeURIComponent(auth);
          }
          hostEnd = -1;
          for (var i = 0; i < nonHostChars2.length; i++) {
            var hec = rest.indexOf(nonHostChars2[i]);
            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
              hostEnd = hec;
          }
          if (hostEnd === -1)
            hostEnd = rest.length;
          this.host = rest.slice(0, hostEnd);
          rest = rest.slice(hostEnd);
          this.parseHost();
          this.hostname = this.hostname || "";
          var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
          if (!ipv6Hostname) {
            var hostparts = this.hostname.split(/\./);
            for (var i = 0, l = hostparts.length; i < l; i++) {
              var part = hostparts[i];
              if (!part)
                continue;
              if (!part.match(hostnamePartPattern2)) {
                var newpart = "";
                for (var j = 0, k = part.length; j < k; j++) {
                  if (part.charCodeAt(j) > 127) {
                    newpart += "x";
                  } else {
                    newpart += part[j];
                  }
                }
                if (!newpart.match(hostnamePartPattern2)) {
                  var validParts = hostparts.slice(0, i);
                  var notHost = hostparts.slice(i + 1);
                  var bit = part.match(hostnamePartStart2);
                  if (bit) {
                    validParts.push(bit[1]);
                    notHost.unshift(bit[2]);
                  }
                  if (notHost.length) {
                    rest = "/" + notHost.join(".") + rest;
                  }
                  this.hostname = validParts.join(".");
                  break;
                }
              }
            }
          }
          if (this.hostname.length > hostnameMaxLen2) {
            this.hostname = "";
          } else {
            this.hostname = this.hostname.toLowerCase();
          }
          if (!ipv6Hostname) {
            this.hostname = punycode2.toASCII(this.hostname);
          }
          var p = this.port ? ":" + this.port : "";
          var h = this.hostname || "";
          this.host = h + p;
          this.href += this.host;
          if (ipv6Hostname) {
            this.hostname = this.hostname.substr(1, this.hostname.length - 2);
            if (rest[0] !== "/") {
              rest = "/" + rest;
            }
          }
        }
        if (!unsafeProtocol2[lowerProto]) {
          for (var i = 0, l = autoEscape2.length; i < l; i++) {
            var ae = autoEscape2[i];
            if (rest.indexOf(ae) === -1)
              continue;
            var esc = encodeURIComponent(ae);
            if (esc === ae) {
              esc = escape(ae);
            }
            rest = rest.split(ae).join(esc);
          }
        }
        var hash = rest.indexOf("#");
        if (hash !== -1) {
          this.hash = rest.substr(hash);
          rest = rest.slice(0, hash);
        }
        var qm = rest.indexOf("?");
        if (qm !== -1) {
          this.search = rest.substr(qm);
          this.query = rest.substr(qm + 1);
          if (parseQueryString) {
            this.query = querystring2.parse(this.query);
          }
          rest = rest.slice(0, qm);
        } else if (parseQueryString) {
          this.search = "";
          this.query = {};
        }
        if (rest)
          this.pathname = rest;
        if (slashedProtocol2[lowerProto] && this.hostname && !this.pathname) {
          this.pathname = "/";
        }
        if (this.pathname || this.search) {
          var p = this.pathname || "";
          var s = this.search || "";
          this.path = p + s;
        }
        this.href = this.format();
        return this;
      };
      function urlFormat2(obj) {
        if (util2.isString(obj))
          obj = urlParse2(obj);
        if (!(obj instanceof Url2))
          return Url2.prototype.format.call(obj);
        return obj.format();
      }
      Url2.prototype.format = function() {
        var auth = this.auth || "";
        if (auth) {
          auth = encodeURIComponent(auth);
          auth = auth.replace(/%3A/i, ":");
          auth += "@";
        }
        var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
        if (this.host) {
          host = auth + this.host;
        } else if (this.hostname) {
          host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
          if (this.port) {
            host += ":" + this.port;
          }
        }
        if (this.query && util2.isObject(this.query) && Object.keys(this.query).length) {
          query = querystring2.stringify(this.query);
        }
        var search = this.search || query && "?" + query || "";
        if (protocol && protocol.substr(-1) !== ":")
          protocol += ":";
        if (this.slashes || (!protocol || slashedProtocol2[protocol]) && host !== false) {
          host = "//" + (host || "");
          if (pathname && pathname.charAt(0) !== "/")
            pathname = "/" + pathname;
        } else if (!host) {
          host = "";
        }
        if (hash && hash.charAt(0) !== "#")
          hash = "#" + hash;
        if (search && search.charAt(0) !== "?")
          search = "?" + search;
        pathname = pathname.replace(/[?#]/g, function(match) {
          return encodeURIComponent(match);
        });
        search = search.replace("#", "%23");
        return protocol + host + pathname + search + hash;
      };
      function urlResolve2(source, relative) {
        return urlParse2(source, false, true).resolve(relative);
      }
      Url2.prototype.resolve = function(relative) {
        return this.resolveObject(urlParse2(relative, false, true)).format();
      };
      function urlResolveObject(source, relative) {
        if (!source)
          return relative;
        return urlParse2(source, false, true).resolveObject(relative);
      }
      Url2.prototype.resolveObject = function(relative) {
        if (util2.isString(relative)) {
          var rel = new Url2();
          rel.parse(relative, false, true);
          relative = rel;
        }
        var result = new Url2();
        var tkeys = Object.keys(this);
        for (var tk = 0; tk < tkeys.length; tk++) {
          var tkey = tkeys[tk];
          result[tkey] = this[tkey];
        }
        result.hash = relative.hash;
        if (relative.href === "") {
          result.href = result.format();
          return result;
        }
        if (relative.slashes && !relative.protocol) {
          var rkeys = Object.keys(relative);
          for (var rk = 0; rk < rkeys.length; rk++) {
            var rkey = rkeys[rk];
            if (rkey !== "protocol")
              result[rkey] = relative[rkey];
          }
          if (slashedProtocol2[result.protocol] && result.hostname && !result.pathname) {
            result.path = result.pathname = "/";
          }
          result.href = result.format();
          return result;
        }
        if (relative.protocol && relative.protocol !== result.protocol) {
          if (!slashedProtocol2[relative.protocol]) {
            var keys = Object.keys(relative);
            for (var v = 0; v < keys.length; v++) {
              var k = keys[v];
              result[k] = relative[k];
            }
            result.href = result.format();
            return result;
          }
          result.protocol = relative.protocol;
          if (!relative.host && !hostlessProtocol2[relative.protocol]) {
            var relPath = (relative.pathname || "").split("/");
            while (relPath.length && !(relative.host = relPath.shift()))
              ;
            if (!relative.host)
              relative.host = "";
            if (!relative.hostname)
              relative.hostname = "";
            if (relPath[0] !== "")
              relPath.unshift("");
            if (relPath.length < 2)
              relPath.unshift("");
            result.pathname = relPath.join("/");
          } else {
            result.pathname = relative.pathname;
          }
          result.search = relative.search;
          result.query = relative.query;
          result.host = relative.host || "";
          result.auth = relative.auth;
          result.hostname = relative.hostname || relative.host;
          result.port = relative.port;
          if (result.pathname || result.search) {
            var p = result.pathname || "";
            var s = result.search || "";
            result.path = p + s;
          }
          result.slashes = result.slashes || relative.slashes;
          result.href = result.format();
          return result;
        }
        var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol2[result.protocol];
        if (psychotic) {
          result.hostname = "";
          result.port = null;
          if (result.host) {
            if (srcPath[0] === "")
              srcPath[0] = result.host;
            else
              srcPath.unshift(result.host);
          }
          result.host = "";
          if (relative.protocol) {
            relative.hostname = null;
            relative.port = null;
            if (relative.host) {
              if (relPath[0] === "")
                relPath[0] = relative.host;
              else
                relPath.unshift(relative.host);
            }
            relative.host = null;
          }
          mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
        }
        if (isRelAbs) {
          result.host = relative.host || relative.host === "" ? relative.host : result.host;
          result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
          result.search = relative.search;
          result.query = relative.query;
          srcPath = relPath;
        } else if (relPath.length) {
          if (!srcPath)
            srcPath = [];
          srcPath.pop();
          srcPath = srcPath.concat(relPath);
          result.search = relative.search;
          result.query = relative.query;
        } else if (!util2.isNullOrUndefined(relative.search)) {
          if (psychotic) {
            result.hostname = result.host = srcPath.shift();
            var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
            if (authInHost) {
              result.auth = authInHost.shift();
              result.host = result.hostname = authInHost.shift();
            }
          }
          result.search = relative.search;
          result.query = relative.query;
          if (!util2.isNull(result.pathname) || !util2.isNull(result.search)) {
            result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
          }
          result.href = result.format();
          return result;
        }
        if (!srcPath.length) {
          result.pathname = null;
          if (result.search) {
            result.path = "/" + result.search;
          } else {
            result.path = null;
          }
          result.href = result.format();
          return result;
        }
        var last = srcPath.slice(-1)[0];
        var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
        var up = 0;
        for (var i = srcPath.length; i >= 0; i--) {
          last = srcPath[i];
          if (last === ".") {
            srcPath.splice(i, 1);
          } else if (last === "..") {
            srcPath.splice(i, 1);
            up++;
          } else if (up) {
            srcPath.splice(i, 1);
            up--;
          }
        }
        if (!mustEndAbs && !removeAllDots) {
          for (; up--; up) {
            srcPath.unshift("..");
          }
        }
        if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
          srcPath.unshift("");
        }
        if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
          srcPath.push("");
        }
        var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
        if (psychotic) {
          result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
          var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
          }
        }
        mustEndAbs = mustEndAbs || result.host && srcPath.length;
        if (mustEndAbs && !isAbsolute) {
          srcPath.unshift("");
        }
        if (!srcPath.length) {
          result.pathname = null;
          result.path = null;
        } else {
          result.pathname = srcPath.join("/");
        }
        if (!util2.isNull(result.pathname) || !util2.isNull(result.search)) {
          result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.auth = relative.auth || result.auth;
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      };
      Url2.prototype.parseHost = function() {
        var host = this.host;
        var port = portPattern2.exec(host);
        if (port) {
          port = port[0];
          if (port !== ":") {
            this.port = port.substr(1);
          }
          host = host.substr(0, host.length - port.length);
        }
        if (host)
          this.hostname = host;
      };
    }
  });

  // src-www/js/libs/pixi-build.js
  var pixi_build_exports = {};
  __export(pixi_build_exports, {
    ALPHA_MODES: () => ALPHA_MODES,
    AbstractBatchRenderer: () => AbstractBatchRenderer,
    AbstractMultiResource: () => AbstractMultiResource,
    AbstractRenderer: () => AbstractRenderer,
    Application: () => Application,
    ArrayResource: () => ArrayResource,
    Attribute: () => Attribute,
    BLEND_MODES: () => BLEND_MODES,
    BUFFER_BITS: () => BUFFER_BITS,
    BUFFER_TYPE: () => BUFFER_TYPE,
    BaseImageResource: () => BaseImageResource,
    BaseRenderTexture: () => BaseRenderTexture,
    BaseTexture: () => BaseTexture,
    BatchDrawCall: () => BatchDrawCall,
    BatchGeometry: () => BatchGeometry,
    BatchPluginFactory: () => BatchPluginFactory,
    BatchRenderer: () => BatchRenderer,
    BatchShaderGenerator: () => BatchShaderGenerator,
    BatchSystem: () => BatchSystem,
    BatchTextureArray: () => BatchTextureArray,
    BitmapFont: () => BitmapFont,
    BitmapFontData: () => BitmapFontData,
    BitmapFontLoader: () => BitmapFontLoader,
    BitmapText: () => BitmapText,
    Bounds: () => Bounds,
    Buffer: () => Buffer2,
    BufferResource: () => BufferResource,
    CLEAR_MODES: () => CLEAR_MODES,
    CanvasExtract: () => CanvasExtract,
    CanvasGraphicsRenderer: () => CanvasGraphicsRenderer,
    CanvasMeshRenderer: () => CanvasMeshRenderer,
    CanvasRenderer: () => CanvasRenderer,
    CanvasResource: () => CanvasResource,
    CanvasSpriteRenderer: () => CanvasSpriteRenderer,
    Circle: () => Circle,
    Container: () => Container,
    ContextSystem: () => ContextSystem,
    CubeResource: () => CubeResource,
    DEG_TO_RAD: () => DEG_TO_RAD,
    DRAW_MODES: () => DRAW_MODES,
    DisplayObject: () => DisplayObject,
    ENV: () => ENV,
    Ellipse: () => Ellipse,
    Extract: () => Extract,
    FORMATS: () => FORMATS,
    FillStyle: () => FillStyle,
    Filter: () => Filter,
    FilterState: () => FilterState,
    FilterSystem: () => FilterSystem,
    Framebuffer: () => Framebuffer,
    FramebufferSystem: () => FramebufferSystem,
    GC_MODES: () => GC_MODES,
    GLFramebuffer: () => GLFramebuffer,
    GLProgram: () => GLProgram,
    GLTexture: () => GLTexture,
    GRAPHICS_CURVES: () => GRAPHICS_CURVES,
    Geometry: () => Geometry,
    GeometrySystem: () => GeometrySystem,
    Graphics: () => Graphics,
    GraphicsData: () => GraphicsData,
    GraphicsGeometry: () => GraphicsGeometry,
    IGLUniformData: () => IGLUniformData,
    INSTALLED: () => INSTALLED,
    ImageBitmapResource: () => ImageBitmapResource,
    ImageResource: () => ImageResource,
    LINE_CAP: () => LINE_CAP,
    LINE_JOIN: () => LINE_JOIN,
    LineStyle: () => LineStyle,
    MASK_TYPES: () => MASK_TYPES,
    MIPMAP_MODES: () => MIPMAP_MODES,
    MSAA_QUALITY: () => MSAA_QUALITY,
    MaskData: () => MaskData,
    MaskSystem: () => MaskSystem,
    Matrix: () => Matrix,
    Mesh: () => Mesh,
    MeshBatchUvs: () => MeshBatchUvs,
    MeshGeometry: () => MeshGeometry,
    MeshMaterial: () => MeshMaterial,
    NineSlicePlane: () => NineSlicePlane,
    ObjectRenderer: () => ObjectRenderer,
    ObservablePoint: () => ObservablePoint,
    PI_2: () => PI_2,
    PRECISION: () => PRECISION,
    PlaneGeometry: () => PlaneGeometry,
    Point: () => Point,
    Polygon: () => Polygon,
    Program: () => Program,
    ProjectionSystem: () => ProjectionSystem,
    Quad: () => Quad,
    QuadUv: () => QuadUv,
    RAD_TO_DEG: () => RAD_TO_DEG,
    RENDERER_TYPE: () => RENDERER_TYPE,
    Rectangle: () => Rectangle,
    RenderTexture: () => RenderTexture,
    RenderTexturePool: () => RenderTexturePool,
    RenderTextureSystem: () => RenderTextureSystem,
    Renderer: () => Renderer,
    Resource: () => Resource,
    RopeGeometry: () => RopeGeometry,
    RoundedRectangle: () => RoundedRectangle,
    Runner: () => Runner,
    SAMPLER_TYPES: () => SAMPLER_TYPES,
    SCALE_MODES: () => SCALE_MODES,
    SHAPES: () => SHAPES,
    SVGResource: () => SVGResource,
    ScissorSystem: () => ScissorSystem,
    Shader: () => Shader,
    ShaderSystem: () => ShaderSystem,
    SimpleMesh: () => SimpleMesh,
    SimplePlane: () => SimplePlane,
    SimpleRope: () => SimpleRope,
    Sprite: () => Sprite,
    SpriteMaskFilter: () => SpriteMaskFilter,
    State: () => State,
    StateSystem: () => StateSystem,
    StencilSystem: () => StencilSystem,
    System: () => System,
    TARGETS: () => TARGETS,
    TEXT_GRADIENT: () => TEXT_GRADIENT,
    TYPES: () => TYPES,
    TemporaryDisplayObject: () => TemporaryDisplayObject,
    Text: () => Text,
    TextMetrics: () => TextMetrics,
    TextStyle: () => TextStyle,
    Texture: () => Texture,
    TextureGCSystem: () => TextureGCSystem,
    TextureMatrix: () => TextureMatrix,
    TextureSystem: () => TextureSystem,
    TextureUvs: () => TextureUvs,
    Ticker: () => Ticker,
    TickerPlugin: () => TickerPlugin,
    TilingSprite: () => TilingSprite,
    TilingSpriteRenderer: () => TilingSpriteRenderer,
    Transform: () => Transform,
    UPDATE_PRIORITY: () => UPDATE_PRIORITY,
    UniformGroup: () => UniformGroup,
    VideoResource: () => VideoResource,
    ViewableBuffer: () => ViewableBuffer,
    WRAP_MODES: () => WRAP_MODES,
    autoDetectRenderer: () => autoDetectRenderer,
    autoDetectResource: () => autoDetectResource,
    canUseNewCanvasBlendModes: () => canUseNewCanvasBlendModes,
    canvasUtils: () => canvasUtils,
    checkMaxIfStatementsInShader: () => checkMaxIfStatementsInShader,
    createUBOElements: () => createUBOElements,
    defaultFilterVertex: () => defaultFilterVertex,
    defaultVertex: () => defaultVertex$1,
    filters: () => filters,
    generateProgram: () => generateProgram,
    generateUniformBufferSync: () => generateUniformBufferSync,
    getTestContext: () => getTestContext,
    getUBOData: () => getUBOData,
    graphicsUtils: () => graphicsUtils,
    groupD8: () => groupD8,
    isMobile: () => isMobile2,
    resources: () => resources,
    settings: () => settings,
    systems: () => systems,
    uniformParsers: () => uniformParsers,
    utils: () => utils_exports
  });

  // node_modules/@pixi/constants/dist/esm/constants.js
  var ENV;
  (function(ENV6) {
    ENV6[ENV6["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
    ENV6[ENV6["WEBGL"] = 1] = "WEBGL";
    ENV6[ENV6["WEBGL2"] = 2] = "WEBGL2";
  })(ENV || (ENV = {}));
  var RENDERER_TYPE;
  (function(RENDERER_TYPE6) {
    RENDERER_TYPE6[RENDERER_TYPE6["UNKNOWN"] = 0] = "UNKNOWN";
    RENDERER_TYPE6[RENDERER_TYPE6["WEBGL"] = 1] = "WEBGL";
    RENDERER_TYPE6[RENDERER_TYPE6["CANVAS"] = 2] = "CANVAS";
  })(RENDERER_TYPE || (RENDERER_TYPE = {}));
  var BUFFER_BITS;
  (function(BUFFER_BITS6) {
    BUFFER_BITS6[BUFFER_BITS6["COLOR"] = 16384] = "COLOR";
    BUFFER_BITS6[BUFFER_BITS6["DEPTH"] = 256] = "DEPTH";
    BUFFER_BITS6[BUFFER_BITS6["STENCIL"] = 1024] = "STENCIL";
  })(BUFFER_BITS || (BUFFER_BITS = {}));
  var BLEND_MODES;
  (function(BLEND_MODES6) {
    BLEND_MODES6[BLEND_MODES6["NORMAL"] = 0] = "NORMAL";
    BLEND_MODES6[BLEND_MODES6["ADD"] = 1] = "ADD";
    BLEND_MODES6[BLEND_MODES6["MULTIPLY"] = 2] = "MULTIPLY";
    BLEND_MODES6[BLEND_MODES6["SCREEN"] = 3] = "SCREEN";
    BLEND_MODES6[BLEND_MODES6["OVERLAY"] = 4] = "OVERLAY";
    BLEND_MODES6[BLEND_MODES6["DARKEN"] = 5] = "DARKEN";
    BLEND_MODES6[BLEND_MODES6["LIGHTEN"] = 6] = "LIGHTEN";
    BLEND_MODES6[BLEND_MODES6["COLOR_DODGE"] = 7] = "COLOR_DODGE";
    BLEND_MODES6[BLEND_MODES6["COLOR_BURN"] = 8] = "COLOR_BURN";
    BLEND_MODES6[BLEND_MODES6["HARD_LIGHT"] = 9] = "HARD_LIGHT";
    BLEND_MODES6[BLEND_MODES6["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
    BLEND_MODES6[BLEND_MODES6["DIFFERENCE"] = 11] = "DIFFERENCE";
    BLEND_MODES6[BLEND_MODES6["EXCLUSION"] = 12] = "EXCLUSION";
    BLEND_MODES6[BLEND_MODES6["HUE"] = 13] = "HUE";
    BLEND_MODES6[BLEND_MODES6["SATURATION"] = 14] = "SATURATION";
    BLEND_MODES6[BLEND_MODES6["COLOR"] = 15] = "COLOR";
    BLEND_MODES6[BLEND_MODES6["LUMINOSITY"] = 16] = "LUMINOSITY";
    BLEND_MODES6[BLEND_MODES6["NORMAL_NPM"] = 17] = "NORMAL_NPM";
    BLEND_MODES6[BLEND_MODES6["ADD_NPM"] = 18] = "ADD_NPM";
    BLEND_MODES6[BLEND_MODES6["SCREEN_NPM"] = 19] = "SCREEN_NPM";
    BLEND_MODES6[BLEND_MODES6["NONE"] = 20] = "NONE";
    BLEND_MODES6[BLEND_MODES6["SRC_OVER"] = 0] = "SRC_OVER";
    BLEND_MODES6[BLEND_MODES6["SRC_IN"] = 21] = "SRC_IN";
    BLEND_MODES6[BLEND_MODES6["SRC_OUT"] = 22] = "SRC_OUT";
    BLEND_MODES6[BLEND_MODES6["SRC_ATOP"] = 23] = "SRC_ATOP";
    BLEND_MODES6[BLEND_MODES6["DST_OVER"] = 24] = "DST_OVER";
    BLEND_MODES6[BLEND_MODES6["DST_IN"] = 25] = "DST_IN";
    BLEND_MODES6[BLEND_MODES6["DST_OUT"] = 26] = "DST_OUT";
    BLEND_MODES6[BLEND_MODES6["DST_ATOP"] = 27] = "DST_ATOP";
    BLEND_MODES6[BLEND_MODES6["ERASE"] = 26] = "ERASE";
    BLEND_MODES6[BLEND_MODES6["SUBTRACT"] = 28] = "SUBTRACT";
    BLEND_MODES6[BLEND_MODES6["XOR"] = 29] = "XOR";
  })(BLEND_MODES || (BLEND_MODES = {}));
  var DRAW_MODES;
  (function(DRAW_MODES6) {
    DRAW_MODES6[DRAW_MODES6["POINTS"] = 0] = "POINTS";
    DRAW_MODES6[DRAW_MODES6["LINES"] = 1] = "LINES";
    DRAW_MODES6[DRAW_MODES6["LINE_LOOP"] = 2] = "LINE_LOOP";
    DRAW_MODES6[DRAW_MODES6["LINE_STRIP"] = 3] = "LINE_STRIP";
    DRAW_MODES6[DRAW_MODES6["TRIANGLES"] = 4] = "TRIANGLES";
    DRAW_MODES6[DRAW_MODES6["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
    DRAW_MODES6[DRAW_MODES6["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
  })(DRAW_MODES || (DRAW_MODES = {}));
  var FORMATS;
  (function(FORMATS6) {
    FORMATS6[FORMATS6["RGBA"] = 6408] = "RGBA";
    FORMATS6[FORMATS6["RGB"] = 6407] = "RGB";
    FORMATS6[FORMATS6["RG"] = 33319] = "RG";
    FORMATS6[FORMATS6["RED"] = 6403] = "RED";
    FORMATS6[FORMATS6["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
    FORMATS6[FORMATS6["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
    FORMATS6[FORMATS6["RG_INTEGER"] = 33320] = "RG_INTEGER";
    FORMATS6[FORMATS6["RED_INTEGER"] = 36244] = "RED_INTEGER";
    FORMATS6[FORMATS6["ALPHA"] = 6406] = "ALPHA";
    FORMATS6[FORMATS6["LUMINANCE"] = 6409] = "LUMINANCE";
    FORMATS6[FORMATS6["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
    FORMATS6[FORMATS6["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
    FORMATS6[FORMATS6["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
  })(FORMATS || (FORMATS = {}));
  var TARGETS;
  (function(TARGETS6) {
    TARGETS6[TARGETS6["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
    TARGETS6[TARGETS6["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  })(TARGETS || (TARGETS = {}));
  var TYPES;
  (function(TYPES6) {
    TYPES6[TYPES6["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    TYPES6[TYPES6["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    TYPES6[TYPES6["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
    TYPES6[TYPES6["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
    TYPES6[TYPES6["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
    TYPES6[TYPES6["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
    TYPES6[TYPES6["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
    TYPES6[TYPES6["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
    TYPES6[TYPES6["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
    TYPES6[TYPES6["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
    TYPES6[TYPES6["BYTE"] = 5120] = "BYTE";
    TYPES6[TYPES6["SHORT"] = 5122] = "SHORT";
    TYPES6[TYPES6["INT"] = 5124] = "INT";
    TYPES6[TYPES6["FLOAT"] = 5126] = "FLOAT";
    TYPES6[TYPES6["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
    TYPES6[TYPES6["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
  })(TYPES || (TYPES = {}));
  var SAMPLER_TYPES;
  (function(SAMPLER_TYPES6) {
    SAMPLER_TYPES6[SAMPLER_TYPES6["FLOAT"] = 0] = "FLOAT";
    SAMPLER_TYPES6[SAMPLER_TYPES6["INT"] = 1] = "INT";
    SAMPLER_TYPES6[SAMPLER_TYPES6["UINT"] = 2] = "UINT";
  })(SAMPLER_TYPES || (SAMPLER_TYPES = {}));
  var SCALE_MODES;
  (function(SCALE_MODES6) {
    SCALE_MODES6[SCALE_MODES6["NEAREST"] = 0] = "NEAREST";
    SCALE_MODES6[SCALE_MODES6["LINEAR"] = 1] = "LINEAR";
  })(SCALE_MODES || (SCALE_MODES = {}));
  var WRAP_MODES;
  (function(WRAP_MODES6) {
    WRAP_MODES6[WRAP_MODES6["CLAMP"] = 33071] = "CLAMP";
    WRAP_MODES6[WRAP_MODES6["REPEAT"] = 10497] = "REPEAT";
    WRAP_MODES6[WRAP_MODES6["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
  })(WRAP_MODES || (WRAP_MODES = {}));
  var MIPMAP_MODES;
  (function(MIPMAP_MODES6) {
    MIPMAP_MODES6[MIPMAP_MODES6["OFF"] = 0] = "OFF";
    MIPMAP_MODES6[MIPMAP_MODES6["POW2"] = 1] = "POW2";
    MIPMAP_MODES6[MIPMAP_MODES6["ON"] = 2] = "ON";
    MIPMAP_MODES6[MIPMAP_MODES6["ON_MANUAL"] = 3] = "ON_MANUAL";
  })(MIPMAP_MODES || (MIPMAP_MODES = {}));
  var ALPHA_MODES;
  (function(ALPHA_MODES6) {
    ALPHA_MODES6[ALPHA_MODES6["NPM"] = 0] = "NPM";
    ALPHA_MODES6[ALPHA_MODES6["UNPACK"] = 1] = "UNPACK";
    ALPHA_MODES6[ALPHA_MODES6["PMA"] = 2] = "PMA";
    ALPHA_MODES6[ALPHA_MODES6["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
    ALPHA_MODES6[ALPHA_MODES6["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
    ALPHA_MODES6[ALPHA_MODES6["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
    ALPHA_MODES6[ALPHA_MODES6["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
  })(ALPHA_MODES || (ALPHA_MODES = {}));
  var CLEAR_MODES;
  (function(CLEAR_MODES6) {
    CLEAR_MODES6[CLEAR_MODES6["NO"] = 0] = "NO";
    CLEAR_MODES6[CLEAR_MODES6["YES"] = 1] = "YES";
    CLEAR_MODES6[CLEAR_MODES6["AUTO"] = 2] = "AUTO";
    CLEAR_MODES6[CLEAR_MODES6["BLEND"] = 0] = "BLEND";
    CLEAR_MODES6[CLEAR_MODES6["CLEAR"] = 1] = "CLEAR";
    CLEAR_MODES6[CLEAR_MODES6["BLIT"] = 2] = "BLIT";
  })(CLEAR_MODES || (CLEAR_MODES = {}));
  var GC_MODES;
  (function(GC_MODES6) {
    GC_MODES6[GC_MODES6["AUTO"] = 0] = "AUTO";
    GC_MODES6[GC_MODES6["MANUAL"] = 1] = "MANUAL";
  })(GC_MODES || (GC_MODES = {}));
  var PRECISION;
  (function(PRECISION6) {
    PRECISION6["LOW"] = "lowp";
    PRECISION6["MEDIUM"] = "mediump";
    PRECISION6["HIGH"] = "highp";
  })(PRECISION || (PRECISION = {}));
  var MASK_TYPES;
  (function(MASK_TYPES6) {
    MASK_TYPES6[MASK_TYPES6["NONE"] = 0] = "NONE";
    MASK_TYPES6[MASK_TYPES6["SCISSOR"] = 1] = "SCISSOR";
    MASK_TYPES6[MASK_TYPES6["STENCIL"] = 2] = "STENCIL";
    MASK_TYPES6[MASK_TYPES6["SPRITE"] = 3] = "SPRITE";
  })(MASK_TYPES || (MASK_TYPES = {}));
  var MSAA_QUALITY;
  (function(MSAA_QUALITY6) {
    MSAA_QUALITY6[MSAA_QUALITY6["NONE"] = 0] = "NONE";
    MSAA_QUALITY6[MSAA_QUALITY6["LOW"] = 2] = "LOW";
    MSAA_QUALITY6[MSAA_QUALITY6["MEDIUM"] = 4] = "MEDIUM";
    MSAA_QUALITY6[MSAA_QUALITY6["HIGH"] = 8] = "HIGH";
  })(MSAA_QUALITY || (MSAA_QUALITY = {}));
  var BUFFER_TYPE;
  (function(BUFFER_TYPE6) {
    BUFFER_TYPE6[BUFFER_TYPE6["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
    BUFFER_TYPE6[BUFFER_TYPE6["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
    BUFFER_TYPE6[BUFFER_TYPE6["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
  })(BUFFER_TYPE || (BUFFER_TYPE = {}));

  // node_modules/@pixi/math/dist/esm/math.js
  var PI_2 = Math.PI * 2;
  var RAD_TO_DEG = 180 / Math.PI;
  var DEG_TO_RAD = Math.PI / 180;
  var SHAPES;
  (function(SHAPES3) {
    SHAPES3[SHAPES3["POLY"] = 0] = "POLY";
    SHAPES3[SHAPES3["RECT"] = 1] = "RECT";
    SHAPES3[SHAPES3["CIRC"] = 2] = "CIRC";
    SHAPES3[SHAPES3["ELIP"] = 3] = "ELIP";
    SHAPES3[SHAPES3["RREC"] = 4] = "RREC";
  })(SHAPES || (SHAPES = {}));
  var Point = (
    /** @class */
    function() {
      function Point3(x, y) {
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        this.x = 0;
        this.y = 0;
        this.x = x;
        this.y = y;
      }
      Point3.prototype.clone = function() {
        return new Point3(this.x, this.y);
      };
      Point3.prototype.copyFrom = function(p) {
        this.set(p.x, p.y);
        return this;
      };
      Point3.prototype.copyTo = function(p) {
        p.set(this.x, this.y);
        return p;
      };
      Point3.prototype.equals = function(p) {
        return p.x === this.x && p.y === this.y;
      };
      Point3.prototype.set = function(x, y) {
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = x;
        }
        this.x = x;
        this.y = y;
        return this;
      };
      Point3.prototype.toString = function() {
        return "[@pixi/math:Point x=" + this.x + " y=" + this.y + "]";
      };
      return Point3;
    }()
  );
  var tempPoints = [new Point(), new Point(), new Point(), new Point()];
  var Rectangle = (
    /** @class */
    function() {
      function Rectangle3(x, y, width, height) {
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        if (width === void 0) {
          width = 0;
        }
        if (height === void 0) {
          height = 0;
        }
        this.x = Number(x);
        this.y = Number(y);
        this.width = Number(width);
        this.height = Number(height);
        this.type = SHAPES.RECT;
      }
      Object.defineProperty(Rectangle3.prototype, "left", {
        /** Returns the left edge of the rectangle. */
        get: function() {
          return this.x;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Rectangle3.prototype, "right", {
        /** Returns the right edge of the rectangle. */
        get: function() {
          return this.x + this.width;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Rectangle3.prototype, "top", {
        /** Returns the top edge of the rectangle. */
        get: function() {
          return this.y;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Rectangle3.prototype, "bottom", {
        /** Returns the bottom edge of the rectangle. */
        get: function() {
          return this.y + this.height;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Rectangle3, "EMPTY", {
        /** A constant empty rectangle. */
        get: function() {
          return new Rectangle3(0, 0, 0, 0);
        },
        enumerable: false,
        configurable: true
      });
      Rectangle3.prototype.clone = function() {
        return new Rectangle3(this.x, this.y, this.width, this.height);
      };
      Rectangle3.prototype.copyFrom = function(rectangle) {
        this.x = rectangle.x;
        this.y = rectangle.y;
        this.width = rectangle.width;
        this.height = rectangle.height;
        return this;
      };
      Rectangle3.prototype.copyTo = function(rectangle) {
        rectangle.x = this.x;
        rectangle.y = this.y;
        rectangle.width = this.width;
        rectangle.height = this.height;
        return rectangle;
      };
      Rectangle3.prototype.contains = function(x, y) {
        if (this.width <= 0 || this.height <= 0) {
          return false;
        }
        if (x >= this.x && x < this.x + this.width) {
          if (y >= this.y && y < this.y + this.height) {
            return true;
          }
        }
        return false;
      };
      Rectangle3.prototype.intersects = function(other, transform) {
        if (!transform) {
          var x0_1 = this.x < other.x ? other.x : this.x;
          var x1_1 = this.right > other.right ? other.right : this.right;
          if (x1_1 <= x0_1) {
            return false;
          }
          var y0_1 = this.y < other.y ? other.y : this.y;
          var y1_1 = this.bottom > other.bottom ? other.bottom : this.bottom;
          return y1_1 > y0_1;
        }
        var x0 = this.left;
        var x1 = this.right;
        var y0 = this.top;
        var y1 = this.bottom;
        if (x1 <= x0 || y1 <= y0) {
          return false;
        }
        var lt = tempPoints[0].set(other.left, other.top);
        var lb = tempPoints[1].set(other.left, other.bottom);
        var rt = tempPoints[2].set(other.right, other.top);
        var rb = tempPoints[3].set(other.right, other.bottom);
        if (rt.x <= lt.x || lb.y <= lt.y) {
          return false;
        }
        var s = Math.sign(transform.a * transform.d - transform.b * transform.c);
        if (s === 0) {
          return false;
        }
        transform.apply(lt, lt);
        transform.apply(lb, lb);
        transform.apply(rt, rt);
        transform.apply(rb, rb);
        if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {
          return false;
        }
        var nx = s * (lb.y - lt.y);
        var ny = s * (lt.x - lb.x);
        var n00 = nx * x0 + ny * y0;
        var n10 = nx * x1 + ny * y0;
        var n01 = nx * x0 + ny * y1;
        var n11 = nx * x1 + ny * y1;
        if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
          return false;
        }
        var mx = s * (lt.y - rt.y);
        var my = s * (rt.x - lt.x);
        var m00 = mx * x0 + my * y0;
        var m10 = mx * x1 + my * y0;
        var m01 = mx * x0 + my * y1;
        var m11 = mx * x1 + my * y1;
        if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
          return false;
        }
        return true;
      };
      Rectangle3.prototype.pad = function(paddingX, paddingY) {
        if (paddingX === void 0) {
          paddingX = 0;
        }
        if (paddingY === void 0) {
          paddingY = paddingX;
        }
        this.x -= paddingX;
        this.y -= paddingY;
        this.width += paddingX * 2;
        this.height += paddingY * 2;
        return this;
      };
      Rectangle3.prototype.fit = function(rectangle) {
        var x1 = Math.max(this.x, rectangle.x);
        var x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
        var y1 = Math.max(this.y, rectangle.y);
        var y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
        this.x = x1;
        this.width = Math.max(x2 - x1, 0);
        this.y = y1;
        this.height = Math.max(y2 - y1, 0);
        return this;
      };
      Rectangle3.prototype.ceil = function(resolution, eps) {
        if (resolution === void 0) {
          resolution = 1;
        }
        if (eps === void 0) {
          eps = 1e-3;
        }
        var x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
        var y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
        this.x = Math.floor((this.x + eps) * resolution) / resolution;
        this.y = Math.floor((this.y + eps) * resolution) / resolution;
        this.width = x2 - this.x;
        this.height = y2 - this.y;
        return this;
      };
      Rectangle3.prototype.enlarge = function(rectangle) {
        var x1 = Math.min(this.x, rectangle.x);
        var x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
        var y1 = Math.min(this.y, rectangle.y);
        var y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
        this.x = x1;
        this.width = x2 - x1;
        this.y = y1;
        this.height = y2 - y1;
        return this;
      };
      Rectangle3.prototype.toString = function() {
        return "[@pixi/math:Rectangle x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
      };
      return Rectangle3;
    }()
  );
  var Circle = (
    /** @class */
    function() {
      function Circle2(x, y, radius) {
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        if (radius === void 0) {
          radius = 0;
        }
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.type = SHAPES.CIRC;
      }
      Circle2.prototype.clone = function() {
        return new Circle2(this.x, this.y, this.radius);
      };
      Circle2.prototype.contains = function(x, y) {
        if (this.radius <= 0) {
          return false;
        }
        var r2 = this.radius * this.radius;
        var dx = this.x - x;
        var dy = this.y - y;
        dx *= dx;
        dy *= dy;
        return dx + dy <= r2;
      };
      Circle2.prototype.getBounds = function() {
        return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
      };
      Circle2.prototype.toString = function() {
        return "[@pixi/math:Circle x=" + this.x + " y=" + this.y + " radius=" + this.radius + "]";
      };
      return Circle2;
    }()
  );
  var Ellipse = (
    /** @class */
    function() {
      function Ellipse2(x, y, halfWidth, halfHeight) {
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        if (halfWidth === void 0) {
          halfWidth = 0;
        }
        if (halfHeight === void 0) {
          halfHeight = 0;
        }
        this.x = x;
        this.y = y;
        this.width = halfWidth;
        this.height = halfHeight;
        this.type = SHAPES.ELIP;
      }
      Ellipse2.prototype.clone = function() {
        return new Ellipse2(this.x, this.y, this.width, this.height);
      };
      Ellipse2.prototype.contains = function(x, y) {
        if (this.width <= 0 || this.height <= 0) {
          return false;
        }
        var normx = (x - this.x) / this.width;
        var normy = (y - this.y) / this.height;
        normx *= normx;
        normy *= normy;
        return normx + normy <= 1;
      };
      Ellipse2.prototype.getBounds = function() {
        return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
      };
      Ellipse2.prototype.toString = function() {
        return "[@pixi/math:Ellipse x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
      };
      return Ellipse2;
    }()
  );
  var Polygon = (
    /** @class */
    function() {
      function Polygon2() {
        var arguments$1 = arguments;
        var points = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          points[_i] = arguments$1[_i];
        }
        var flat = Array.isArray(points[0]) ? points[0] : points;
        if (typeof flat[0] !== "number") {
          var p = [];
          for (var i = 0, il = flat.length; i < il; i++) {
            p.push(flat[i].x, flat[i].y);
          }
          flat = p;
        }
        this.points = flat;
        this.type = SHAPES.POLY;
        this.closeStroke = true;
      }
      Polygon2.prototype.clone = function() {
        var points = this.points.slice();
        var polygon = new Polygon2(points);
        polygon.closeStroke = this.closeStroke;
        return polygon;
      };
      Polygon2.prototype.contains = function(x, y) {
        var inside = false;
        var length = this.points.length / 2;
        for (var i = 0, j = length - 1; i < length; j = i++) {
          var xi = this.points[i * 2];
          var yi = this.points[i * 2 + 1];
          var xj = this.points[j * 2];
          var yj = this.points[j * 2 + 1];
          var intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;
          if (intersect) {
            inside = !inside;
          }
        }
        return inside;
      };
      Polygon2.prototype.toString = function() {
        return "[@pixi/math:Polygon" + ("closeStroke=" + this.closeStroke) + ("points=" + this.points.reduce(function(pointsDesc, currentPoint) {
          return pointsDesc + ", " + currentPoint;
        }, "") + "]");
      };
      return Polygon2;
    }()
  );
  var RoundedRectangle = (
    /** @class */
    function() {
      function RoundedRectangle2(x, y, width, height, radius) {
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        if (width === void 0) {
          width = 0;
        }
        if (height === void 0) {
          height = 0;
        }
        if (radius === void 0) {
          radius = 20;
        }
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.radius = radius;
        this.type = SHAPES.RREC;
      }
      RoundedRectangle2.prototype.clone = function() {
        return new RoundedRectangle2(this.x, this.y, this.width, this.height, this.radius);
      };
      RoundedRectangle2.prototype.contains = function(x, y) {
        if (this.width <= 0 || this.height <= 0) {
          return false;
        }
        if (x >= this.x && x <= this.x + this.width) {
          if (y >= this.y && y <= this.y + this.height) {
            var radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
            if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius) {
              return true;
            }
            var dx = x - (this.x + radius);
            var dy = y - (this.y + radius);
            var radius2 = radius * radius;
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dx = x - (this.x + this.width - radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dy = y - (this.y + this.height - radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dx = x - (this.x + radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
          }
        }
        return false;
      };
      RoundedRectangle2.prototype.toString = function() {
        return "[@pixi/math:RoundedRectangle x=" + this.x + " y=" + this.y + ("width=" + this.width + " height=" + this.height + " radius=" + this.radius + "]");
      };
      return RoundedRectangle2;
    }()
  );
  var ObservablePoint = (
    /** @class */
    function() {
      function ObservablePoint3(cb, scope, x, y) {
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        this._x = x;
        this._y = y;
        this.cb = cb;
        this.scope = scope;
      }
      ObservablePoint3.prototype.clone = function(cb, scope) {
        if (cb === void 0) {
          cb = this.cb;
        }
        if (scope === void 0) {
          scope = this.scope;
        }
        return new ObservablePoint3(cb, scope, this._x, this._y);
      };
      ObservablePoint3.prototype.set = function(x, y) {
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = x;
        }
        if (this._x !== x || this._y !== y) {
          this._x = x;
          this._y = y;
          this.cb.call(this.scope);
        }
        return this;
      };
      ObservablePoint3.prototype.copyFrom = function(p) {
        if (this._x !== p.x || this._y !== p.y) {
          this._x = p.x;
          this._y = p.y;
          this.cb.call(this.scope);
        }
        return this;
      };
      ObservablePoint3.prototype.copyTo = function(p) {
        p.set(this._x, this._y);
        return p;
      };
      ObservablePoint3.prototype.equals = function(p) {
        return p.x === this._x && p.y === this._y;
      };
      ObservablePoint3.prototype.toString = function() {
        return "[@pixi/math:ObservablePoint x=0 y=0 scope=" + this.scope + "]";
      };
      Object.defineProperty(ObservablePoint3.prototype, "x", {
        /** Position of the observable point on the x axis. */
        get: function() {
          return this._x;
        },
        set: function(value) {
          if (this._x !== value) {
            this._x = value;
            this.cb.call(this.scope);
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ObservablePoint3.prototype, "y", {
        /** Position of the observable point on the y axis. */
        get: function() {
          return this._y;
        },
        set: function(value) {
          if (this._y !== value) {
            this._y = value;
            this.cb.call(this.scope);
          }
        },
        enumerable: false,
        configurable: true
      });
      return ObservablePoint3;
    }()
  );
  var Matrix = (
    /** @class */
    function() {
      function Matrix3(a, b, c, d, tx, ty) {
        if (a === void 0) {
          a = 1;
        }
        if (b === void 0) {
          b = 0;
        }
        if (c === void 0) {
          c = 0;
        }
        if (d === void 0) {
          d = 1;
        }
        if (tx === void 0) {
          tx = 0;
        }
        if (ty === void 0) {
          ty = 0;
        }
        this.array = null;
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
      }
      Matrix3.prototype.fromArray = function(array) {
        this.a = array[0];
        this.b = array[1];
        this.c = array[3];
        this.d = array[4];
        this.tx = array[2];
        this.ty = array[5];
      };
      Matrix3.prototype.set = function(a, b, c, d, tx, ty) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
        return this;
      };
      Matrix3.prototype.toArray = function(transpose, out) {
        if (!this.array) {
          this.array = new Float32Array(9);
        }
        var array = out || this.array;
        if (transpose) {
          array[0] = this.a;
          array[1] = this.b;
          array[2] = 0;
          array[3] = this.c;
          array[4] = this.d;
          array[5] = 0;
          array[6] = this.tx;
          array[7] = this.ty;
          array[8] = 1;
        } else {
          array[0] = this.a;
          array[1] = this.c;
          array[2] = this.tx;
          array[3] = this.b;
          array[4] = this.d;
          array[5] = this.ty;
          array[6] = 0;
          array[7] = 0;
          array[8] = 1;
        }
        return array;
      };
      Matrix3.prototype.apply = function(pos, newPos) {
        newPos = newPos || new Point();
        var x = pos.x;
        var y = pos.y;
        newPos.x = this.a * x + this.c * y + this.tx;
        newPos.y = this.b * x + this.d * y + this.ty;
        return newPos;
      };
      Matrix3.prototype.applyInverse = function(pos, newPos) {
        newPos = newPos || new Point();
        var id = 1 / (this.a * this.d + this.c * -this.b);
        var x = pos.x;
        var y = pos.y;
        newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id;
        newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id;
        return newPos;
      };
      Matrix3.prototype.translate = function(x, y) {
        this.tx += x;
        this.ty += y;
        return this;
      };
      Matrix3.prototype.scale = function(x, y) {
        this.a *= x;
        this.d *= y;
        this.c *= x;
        this.b *= y;
        this.tx *= x;
        this.ty *= y;
        return this;
      };
      Matrix3.prototype.rotate = function(angle) {
        var cos = Math.cos(angle);
        var sin = Math.sin(angle);
        var a1 = this.a;
        var c1 = this.c;
        var tx1 = this.tx;
        this.a = a1 * cos - this.b * sin;
        this.b = a1 * sin + this.b * cos;
        this.c = c1 * cos - this.d * sin;
        this.d = c1 * sin + this.d * cos;
        this.tx = tx1 * cos - this.ty * sin;
        this.ty = tx1 * sin + this.ty * cos;
        return this;
      };
      Matrix3.prototype.append = function(matrix) {
        var a1 = this.a;
        var b1 = this.b;
        var c1 = this.c;
        var d1 = this.d;
        this.a = matrix.a * a1 + matrix.b * c1;
        this.b = matrix.a * b1 + matrix.b * d1;
        this.c = matrix.c * a1 + matrix.d * c1;
        this.d = matrix.c * b1 + matrix.d * d1;
        this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
        this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
        return this;
      };
      Matrix3.prototype.setTransform = function(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
        this.a = Math.cos(rotation + skewY) * scaleX;
        this.b = Math.sin(rotation + skewY) * scaleX;
        this.c = -Math.sin(rotation - skewX) * scaleY;
        this.d = Math.cos(rotation - skewX) * scaleY;
        this.tx = x - (pivotX * this.a + pivotY * this.c);
        this.ty = y - (pivotX * this.b + pivotY * this.d);
        return this;
      };
      Matrix3.prototype.prepend = function(matrix) {
        var tx1 = this.tx;
        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
          var a1 = this.a;
          var c1 = this.c;
          this.a = a1 * matrix.a + this.b * matrix.c;
          this.b = a1 * matrix.b + this.b * matrix.d;
          this.c = c1 * matrix.a + this.d * matrix.c;
          this.d = c1 * matrix.b + this.d * matrix.d;
        }
        this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
        this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
        return this;
      };
      Matrix3.prototype.decompose = function(transform) {
        var a = this.a;
        var b = this.b;
        var c = this.c;
        var d = this.d;
        var pivot = transform.pivot;
        var skewX = -Math.atan2(-c, d);
        var skewY = Math.atan2(b, a);
        var delta = Math.abs(skewX + skewY);
        if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {
          transform.rotation = skewY;
          transform.skew.x = transform.skew.y = 0;
        } else {
          transform.rotation = 0;
          transform.skew.x = skewX;
          transform.skew.y = skewY;
        }
        transform.scale.x = Math.sqrt(a * a + b * b);
        transform.scale.y = Math.sqrt(c * c + d * d);
        transform.position.x = this.tx + (pivot.x * a + pivot.y * c);
        transform.position.y = this.ty + (pivot.x * b + pivot.y * d);
        return transform;
      };
      Matrix3.prototype.invert = function() {
        var a1 = this.a;
        var b1 = this.b;
        var c1 = this.c;
        var d1 = this.d;
        var tx1 = this.tx;
        var n = a1 * d1 - b1 * c1;
        this.a = d1 / n;
        this.b = -b1 / n;
        this.c = -c1 / n;
        this.d = a1 / n;
        this.tx = (c1 * this.ty - d1 * tx1) / n;
        this.ty = -(a1 * this.ty - b1 * tx1) / n;
        return this;
      };
      Matrix3.prototype.identity = function() {
        this.a = 1;
        this.b = 0;
        this.c = 0;
        this.d = 1;
        this.tx = 0;
        this.ty = 0;
        return this;
      };
      Matrix3.prototype.clone = function() {
        var matrix = new Matrix3();
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
      };
      Matrix3.prototype.copyTo = function(matrix) {
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
      };
      Matrix3.prototype.copyFrom = function(matrix) {
        this.a = matrix.a;
        this.b = matrix.b;
        this.c = matrix.c;
        this.d = matrix.d;
        this.tx = matrix.tx;
        this.ty = matrix.ty;
        return this;
      };
      Matrix3.prototype.toString = function() {
        return "[@pixi/math:Matrix a=" + this.a + " b=" + this.b + " c=" + this.c + " d=" + this.d + " tx=" + this.tx + " ty=" + this.ty + "]";
      };
      Object.defineProperty(Matrix3, "IDENTITY", {
        /**
         * A default (identity) matrix
         * @readonly
         */
        get: function() {
          return new Matrix3();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Matrix3, "TEMP_MATRIX", {
        /**
         * A temp matrix
         * @readonly
         */
        get: function() {
          return new Matrix3();
        },
        enumerable: false,
        configurable: true
      });
      return Matrix3;
    }()
  );
  var ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
  var uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
  var vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
  var vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
  var rotationCayley = [];
  var rotationMatrices = [];
  var signum = Math.sign;
  function init() {
    for (var i = 0; i < 16; i++) {
      var row = [];
      rotationCayley.push(row);
      for (var j = 0; j < 16; j++) {
        var _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);
        var _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);
        var _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);
        var _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);
        for (var k = 0; k < 16; k++) {
          if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {
            row.push(k);
            break;
          }
        }
      }
    }
    for (var i = 0; i < 16; i++) {
      var mat = new Matrix();
      mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);
      rotationMatrices.push(mat);
    }
  }
  init();
  var groupD8 = {
    /**
     * | Rotation | Direction |
     * |----------|-----------|
     * | 0       | East      |
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */
    E: 0,
    /**
     * | Rotation | Direction |
     * |----------|-----------|
     * | 45     | Southeast |
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */
    SE: 1,
    /**
     * | Rotation | Direction |
     * |----------|-----------|
     * | 90     | South     |
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */
    S: 2,
    /**
     * | Rotation | Direction |
     * |----------|-----------|
     * | 135    | Southwest |
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */
    SW: 3,
    /**
     * | Rotation | Direction |
     * |----------|-----------|
     * | 180     | West      |
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */
    W: 4,
    /**
     * | Rotation    | Direction    |
     * |-------------|--------------|
     * | -135/225 | Northwest    |
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */
    NW: 5,
    /**
     * | Rotation    | Direction    |
     * |-------------|--------------|
     * | -90/270  | North        |
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */
    N: 6,
    /**
     * | Rotation    | Direction    |
     * |-------------|--------------|
     * | -45/315  | Northeast    |
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */
    NE: 7,
    /**
     * Reflection about Y-axis.
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */
    MIRROR_VERTICAL: 8,
    /**
     * Reflection about the main diagonal.
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */
    MAIN_DIAGONAL: 10,
    /**
     * Reflection about X-axis.
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */
    MIRROR_HORIZONTAL: 12,
    /**
     * Reflection about reverse diagonal.
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */
    REVERSE_DIAGONAL: 14,
    /**
     * @memberof PIXI.groupD8
     * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
     * @returns {PIXI.GD8Symmetry} The X-component of the U-axis
     *    after rotating the axes.
     */
    uX: function(ind) {
      return ux[ind];
    },
    /**
     * @memberof PIXI.groupD8
     * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
     * @returns {PIXI.GD8Symmetry} The Y-component of the U-axis
     *    after rotating the axes.
     */
    uY: function(ind) {
      return uy[ind];
    },
    /**
     * @memberof PIXI.groupD8
     * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
     * @returns {PIXI.GD8Symmetry} The X-component of the V-axis
     *    after rotating the axes.
     */
    vX: function(ind) {
      return vx[ind];
    },
    /**
     * @memberof PIXI.groupD8
     * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
     * @returns {PIXI.GD8Symmetry} The Y-component of the V-axis
     *    after rotating the axes.
     */
    vY: function(ind) {
      return vy[ind];
    },
    /**
     * @memberof PIXI.groupD8
     * @param {PIXI.GD8Symmetry} rotation - symmetry whose opposite
     *   is needed. Only rotations have opposite symmetries while
     *   reflections don't.
     * @returns {PIXI.GD8Symmetry} The opposite symmetry of `rotation`
     */
    inv: function(rotation) {
      if (rotation & 8) {
        return rotation & 15;
      }
      return -rotation & 7;
    },
    /**
     * Composes the two D8 operations.
     *
     * Taking `^` as reflection:
     *
     * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
     * |-------|-----|-----|-----|-----|------|-------|-------|-------|
     * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
     * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
     * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
     * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
     * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
     * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
     * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
     * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
     *
     * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
     * @memberof PIXI.groupD8
     * @param {PIXI.GD8Symmetry} rotationSecond - Second operation, which
     *   is the row in the above cayley table.
     * @param {PIXI.GD8Symmetry} rotationFirst - First operation, which
     *   is the column in the above cayley table.
     * @returns {PIXI.GD8Symmetry} Composed operation
     */
    add: function(rotationSecond, rotationFirst) {
      return rotationCayley[rotationSecond][rotationFirst];
    },
    /**
     * Reverse of `add`.
     * @memberof PIXI.groupD8
     * @param {PIXI.GD8Symmetry} rotationSecond - Second operation
     * @param {PIXI.GD8Symmetry} rotationFirst - First operation
     * @returns {PIXI.GD8Symmetry} Result
     */
    sub: function(rotationSecond, rotationFirst) {
      return rotationCayley[rotationSecond][groupD8.inv(rotationFirst)];
    },
    /**
     * Adds 180 degrees to rotation, which is a commutative
     * operation.
     * @memberof PIXI.groupD8
     * @param {number} rotation - The number to rotate.
     * @returns {number} Rotated number
     */
    rotate180: function(rotation) {
      return rotation ^ 4;
    },
    /**
     * Checks if the rotation angle is vertical, i.e. south
     * or north. It doesn't work for reflections.
     * @memberof PIXI.groupD8
     * @param {PIXI.GD8Symmetry} rotation - The number to check.
     * @returns {boolean} Whether or not the direction is vertical
     */
    isVertical: function(rotation) {
      return (rotation & 3) === 2;
    },
    /**
     * Approximates the vector `V(dx,dy)` into one of the
     * eight directions provided by `groupD8`.
     * @memberof PIXI.groupD8
     * @param {number} dx - X-component of the vector
     * @param {number} dy - Y-component of the vector
     * @returns {PIXI.GD8Symmetry} Approximation of the vector into
     *  one of the eight symmetries.
     */
    byDirection: function(dx, dy) {
      if (Math.abs(dx) * 2 <= Math.abs(dy)) {
        if (dy >= 0) {
          return groupD8.S;
        }
        return groupD8.N;
      } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
        if (dx > 0) {
          return groupD8.E;
        }
        return groupD8.W;
      } else if (dy > 0) {
        if (dx > 0) {
          return groupD8.SE;
        }
        return groupD8.SW;
      } else if (dx > 0) {
        return groupD8.NE;
      }
      return groupD8.NW;
    },
    /**
     * Helps sprite to compensate texture packer rotation.
     * @memberof PIXI.groupD8
     * @param {PIXI.Matrix} matrix - sprite world matrix
     * @param {PIXI.GD8Symmetry} rotation - The rotation factor to use.
     * @param {number} tx - sprite anchoring
     * @param {number} ty - sprite anchoring
     */
    matrixAppendRotationInv: function(matrix, rotation, tx, ty) {
      if (tx === void 0) {
        tx = 0;
      }
      if (ty === void 0) {
        ty = 0;
      }
      var mat = rotationMatrices[groupD8.inv(rotation)];
      mat.tx = tx;
      mat.ty = ty;
      matrix.append(mat);
    }
  };
  var Transform = (
    /** @class */
    function() {
      function Transform2() {
        this.worldTransform = new Matrix();
        this.localTransform = new Matrix();
        this.position = new ObservablePoint(this.onChange, this, 0, 0);
        this.scale = new ObservablePoint(this.onChange, this, 1, 1);
        this.pivot = new ObservablePoint(this.onChange, this, 0, 0);
        this.skew = new ObservablePoint(this.updateSkew, this, 0, 0);
        this._rotation = 0;
        this._cx = 1;
        this._sx = 0;
        this._cy = 0;
        this._sy = 1;
        this._localID = 0;
        this._currentLocalID = 0;
        this._worldID = 0;
        this._parentID = 0;
      }
      Transform2.prototype.onChange = function() {
        this._localID++;
      };
      Transform2.prototype.updateSkew = function() {
        this._cx = Math.cos(this._rotation + this.skew.y);
        this._sx = Math.sin(this._rotation + this.skew.y);
        this._cy = -Math.sin(this._rotation - this.skew.x);
        this._sy = Math.cos(this._rotation - this.skew.x);
        this._localID++;
      };
      Transform2.prototype.toString = function() {
        return "[@pixi/math:Transform " + ("position=(" + this.position.x + ", " + this.position.y + ") ") + ("rotation=" + this.rotation + " ") + ("scale=(" + this.scale.x + ", " + this.scale.y + ") ") + ("skew=(" + this.skew.x + ", " + this.skew.y + ") ") + "]";
      };
      Transform2.prototype.updateLocalTransform = function() {
        var lt = this.localTransform;
        if (this._localID !== this._currentLocalID) {
          lt.a = this._cx * this.scale.x;
          lt.b = this._sx * this.scale.x;
          lt.c = this._cy * this.scale.y;
          lt.d = this._sy * this.scale.y;
          lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
          lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
          this._currentLocalID = this._localID;
          this._parentID = -1;
        }
      };
      Transform2.prototype.updateTransform = function(parentTransform) {
        var lt = this.localTransform;
        if (this._localID !== this._currentLocalID) {
          lt.a = this._cx * this.scale.x;
          lt.b = this._sx * this.scale.x;
          lt.c = this._cy * this.scale.y;
          lt.d = this._sy * this.scale.y;
          lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
          lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
          this._currentLocalID = this._localID;
          this._parentID = -1;
        }
        if (this._parentID !== parentTransform._worldID) {
          var pt = parentTransform.worldTransform;
          var wt = this.worldTransform;
          wt.a = lt.a * pt.a + lt.b * pt.c;
          wt.b = lt.a * pt.b + lt.b * pt.d;
          wt.c = lt.c * pt.a + lt.d * pt.c;
          wt.d = lt.c * pt.b + lt.d * pt.d;
          wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
          wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
          this._parentID = parentTransform._worldID;
          this._worldID++;
        }
      };
      Transform2.prototype.setFromMatrix = function(matrix) {
        matrix.decompose(this);
        this._localID++;
      };
      Object.defineProperty(Transform2.prototype, "rotation", {
        /** The rotation of the object in radians. */
        get: function() {
          return this._rotation;
        },
        set: function(value) {
          if (this._rotation !== value) {
            this._rotation = value;
            this.updateSkew();
          }
        },
        enumerable: false,
        configurable: true
      });
      Transform2.IDENTITY = new Transform2();
      return Transform2;
    }()
  );

  // node_modules/@pixi/runner/dist/esm/runner.js
  var Runner = (
    /** @class */
    function() {
      function Runner3(name) {
        this.items = [];
        this._name = name;
        this._aliasCount = 0;
      }
      Runner3.prototype.emit = function(a0, a1, a2, a3, a4, a5, a6, a7) {
        if (arguments.length > 8) {
          throw new Error("max arguments reached");
        }
        var _a2 = this, name = _a2.name, items = _a2.items;
        this._aliasCount++;
        for (var i = 0, len = items.length; i < len; i++) {
          items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);
        }
        if (items === this.items) {
          this._aliasCount--;
        }
        return this;
      };
      Runner3.prototype.ensureNonAliasedItems = function() {
        if (this._aliasCount > 0 && this.items.length > 1) {
          this._aliasCount = 0;
          this.items = this.items.slice(0);
        }
      };
      Runner3.prototype.add = function(item) {
        if (item[this._name]) {
          this.ensureNonAliasedItems();
          this.remove(item);
          this.items.push(item);
        }
        return this;
      };
      Runner3.prototype.remove = function(item) {
        var index = this.items.indexOf(item);
        if (index !== -1) {
          this.ensureNonAliasedItems();
          this.items.splice(index, 1);
        }
        return this;
      };
      Runner3.prototype.contains = function(item) {
        return this.items.indexOf(item) !== -1;
      };
      Runner3.prototype.removeAll = function() {
        this.ensureNonAliasedItems();
        this.items.length = 0;
        return this;
      };
      Runner3.prototype.destroy = function() {
        this.removeAll();
        this.items = null;
        this._name = null;
      };
      Object.defineProperty(Runner3.prototype, "empty", {
        /**
         * `true` if there are no this Runner contains no listeners
         * @readonly
         */
        get: function() {
          return this.items.length === 0;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Runner3.prototype, "name", {
        /**
         * The name of the runner.
         * @readonly
         */
        get: function() {
          return this._name;
        },
        enumerable: false,
        configurable: true
      });
      return Runner3;
    }()
  );
  Object.defineProperties(Runner.prototype, {
    /**
     * Alias for `emit`
     * @memberof PIXI.Runner#
     * @method dispatch
     * @see PIXI.Runner#emit
     */
    dispatch: { value: Runner.prototype.emit },
    /**
     * Alias for `emit`
     * @memberof PIXI.Runner#
     * @method run
     * @see PIXI.Runner#emit
     */
    run: { value: Runner.prototype.emit }
  });

  // node_modules/ismobilejs/esm/isMobile.js
  var appleIphone = /iPhone/i;
  var appleIpod = /iPod/i;
  var appleTablet = /iPad/i;
  var appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
  var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
  var androidTablet = /Android/i;
  var amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
  var amazonTablet = /Silk/i;
  var windowsPhone = /Windows Phone/i;
  var windowsTablet = /\bWindows(?:.+)ARM\b/i;
  var otherBlackBerry = /BlackBerry/i;
  var otherBlackBerry10 = /BB10/i;
  var otherOpera = /Opera Mini/i;
  var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
  var otherFirefox = /Mobile(?:.+)Firefox\b/i;
  var isAppleTabletOnIos13 = function(navigator2) {
    return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && navigator2.maxTouchPoints > 1 && typeof MSStream === "undefined";
  };
  function createMatch(userAgent) {
    return function(regex) {
      return regex.test(userAgent);
    };
  }
  function isMobile(param) {
    var nav = {
      userAgent: "",
      platform: "",
      maxTouchPoints: 0
    };
    if (!param && typeof navigator !== "undefined") {
      nav = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        maxTouchPoints: navigator.maxTouchPoints || 0
      };
    } else if (typeof param === "string") {
      nav.userAgent = param;
    } else if (param && param.userAgent) {
      nav = {
        userAgent: param.userAgent,
        platform: param.platform,
        maxTouchPoints: param.maxTouchPoints || 0
      };
    }
    var userAgent = nav.userAgent;
    var tmp = userAgent.split("[FBAN");
    if (typeof tmp[1] !== "undefined") {
      userAgent = tmp[0];
    }
    tmp = userAgent.split("Twitter");
    if (typeof tmp[1] !== "undefined") {
      userAgent = tmp[0];
    }
    var match = createMatch(userAgent);
    var result = {
      apple: {
        phone: match(appleIphone) && !match(windowsPhone),
        ipod: match(appleIpod),
        tablet: !match(appleIphone) && (match(appleTablet) || isAppleTabletOnIos13(nav)) && !match(windowsPhone),
        universal: match(appleUniversal),
        device: (match(appleIphone) || match(appleIpod) || match(appleTablet) || match(appleUniversal) || isAppleTabletOnIos13(nav)) && !match(windowsPhone)
      },
      amazon: {
        phone: match(amazonPhone),
        tablet: !match(amazonPhone) && match(amazonTablet),
        device: match(amazonPhone) || match(amazonTablet)
      },
      android: {
        phone: !match(windowsPhone) && match(amazonPhone) || !match(windowsPhone) && match(androidPhone),
        tablet: !match(windowsPhone) && !match(amazonPhone) && !match(androidPhone) && (match(amazonTablet) || match(androidTablet)),
        device: !match(windowsPhone) && (match(amazonPhone) || match(amazonTablet) || match(androidPhone) || match(androidTablet)) || match(/\bokhttp\b/i)
      },
      windows: {
        phone: match(windowsPhone),
        tablet: match(windowsTablet),
        device: match(windowsPhone) || match(windowsTablet)
      },
      other: {
        blackberry: match(otherBlackBerry),
        blackberry10: match(otherBlackBerry10),
        opera: match(otherOpera),
        firefox: match(otherFirefox),
        chrome: match(otherChrome),
        device: match(otherBlackBerry) || match(otherBlackBerry10) || match(otherOpera) || match(otherFirefox) || match(otherChrome)
      },
      any: false,
      phone: false,
      tablet: false
    };
    result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
    result.phone = result.apple.phone || result.android.phone || result.windows.phone;
    result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
    return result;
  }

  // node_modules/@pixi/settings/dist/esm/settings.js
  var isMobile2 = isMobile(globalThis.navigator);
  function maxRecommendedTextures(max) {
    var allowMax = true;
    if (isMobile2.tablet || isMobile2.phone) {
      if (isMobile2.apple.device) {
        var match = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
        if (match) {
          var majorVersion = parseInt(match[1], 10);
          if (majorVersion < 11) {
            allowMax = false;
          }
        }
      }
      if (isMobile2.android.device) {
        var match = navigator.userAgent.match(/Android\s([0-9.]*)/);
        if (match) {
          var majorVersion = parseInt(match[1], 10);
          if (majorVersion < 7) {
            allowMax = false;
          }
        }
      }
    }
    return allowMax ? max : 4;
  }
  function canUploadSameBuffer() {
    return !isMobile2.apple.device;
  }
  var ENV2;
  (function(ENV6) {
    ENV6[ENV6["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
    ENV6[ENV6["WEBGL"] = 1] = "WEBGL";
    ENV6[ENV6["WEBGL2"] = 2] = "WEBGL2";
  })(ENV2 || (ENV2 = {}));
  var RENDERER_TYPE2;
  (function(RENDERER_TYPE6) {
    RENDERER_TYPE6[RENDERER_TYPE6["UNKNOWN"] = 0] = "UNKNOWN";
    RENDERER_TYPE6[RENDERER_TYPE6["WEBGL"] = 1] = "WEBGL";
    RENDERER_TYPE6[RENDERER_TYPE6["CANVAS"] = 2] = "CANVAS";
  })(RENDERER_TYPE2 || (RENDERER_TYPE2 = {}));
  var BUFFER_BITS2;
  (function(BUFFER_BITS6) {
    BUFFER_BITS6[BUFFER_BITS6["COLOR"] = 16384] = "COLOR";
    BUFFER_BITS6[BUFFER_BITS6["DEPTH"] = 256] = "DEPTH";
    BUFFER_BITS6[BUFFER_BITS6["STENCIL"] = 1024] = "STENCIL";
  })(BUFFER_BITS2 || (BUFFER_BITS2 = {}));
  var BLEND_MODES2;
  (function(BLEND_MODES6) {
    BLEND_MODES6[BLEND_MODES6["NORMAL"] = 0] = "NORMAL";
    BLEND_MODES6[BLEND_MODES6["ADD"] = 1] = "ADD";
    BLEND_MODES6[BLEND_MODES6["MULTIPLY"] = 2] = "MULTIPLY";
    BLEND_MODES6[BLEND_MODES6["SCREEN"] = 3] = "SCREEN";
    BLEND_MODES6[BLEND_MODES6["OVERLAY"] = 4] = "OVERLAY";
    BLEND_MODES6[BLEND_MODES6["DARKEN"] = 5] = "DARKEN";
    BLEND_MODES6[BLEND_MODES6["LIGHTEN"] = 6] = "LIGHTEN";
    BLEND_MODES6[BLEND_MODES6["COLOR_DODGE"] = 7] = "COLOR_DODGE";
    BLEND_MODES6[BLEND_MODES6["COLOR_BURN"] = 8] = "COLOR_BURN";
    BLEND_MODES6[BLEND_MODES6["HARD_LIGHT"] = 9] = "HARD_LIGHT";
    BLEND_MODES6[BLEND_MODES6["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
    BLEND_MODES6[BLEND_MODES6["DIFFERENCE"] = 11] = "DIFFERENCE";
    BLEND_MODES6[BLEND_MODES6["EXCLUSION"] = 12] = "EXCLUSION";
    BLEND_MODES6[BLEND_MODES6["HUE"] = 13] = "HUE";
    BLEND_MODES6[BLEND_MODES6["SATURATION"] = 14] = "SATURATION";
    BLEND_MODES6[BLEND_MODES6["COLOR"] = 15] = "COLOR";
    BLEND_MODES6[BLEND_MODES6["LUMINOSITY"] = 16] = "LUMINOSITY";
    BLEND_MODES6[BLEND_MODES6["NORMAL_NPM"] = 17] = "NORMAL_NPM";
    BLEND_MODES6[BLEND_MODES6["ADD_NPM"] = 18] = "ADD_NPM";
    BLEND_MODES6[BLEND_MODES6["SCREEN_NPM"] = 19] = "SCREEN_NPM";
    BLEND_MODES6[BLEND_MODES6["NONE"] = 20] = "NONE";
    BLEND_MODES6[BLEND_MODES6["SRC_OVER"] = 0] = "SRC_OVER";
    BLEND_MODES6[BLEND_MODES6["SRC_IN"] = 21] = "SRC_IN";
    BLEND_MODES6[BLEND_MODES6["SRC_OUT"] = 22] = "SRC_OUT";
    BLEND_MODES6[BLEND_MODES6["SRC_ATOP"] = 23] = "SRC_ATOP";
    BLEND_MODES6[BLEND_MODES6["DST_OVER"] = 24] = "DST_OVER";
    BLEND_MODES6[BLEND_MODES6["DST_IN"] = 25] = "DST_IN";
    BLEND_MODES6[BLEND_MODES6["DST_OUT"] = 26] = "DST_OUT";
    BLEND_MODES6[BLEND_MODES6["DST_ATOP"] = 27] = "DST_ATOP";
    BLEND_MODES6[BLEND_MODES6["ERASE"] = 26] = "ERASE";
    BLEND_MODES6[BLEND_MODES6["SUBTRACT"] = 28] = "SUBTRACT";
    BLEND_MODES6[BLEND_MODES6["XOR"] = 29] = "XOR";
  })(BLEND_MODES2 || (BLEND_MODES2 = {}));
  var DRAW_MODES2;
  (function(DRAW_MODES6) {
    DRAW_MODES6[DRAW_MODES6["POINTS"] = 0] = "POINTS";
    DRAW_MODES6[DRAW_MODES6["LINES"] = 1] = "LINES";
    DRAW_MODES6[DRAW_MODES6["LINE_LOOP"] = 2] = "LINE_LOOP";
    DRAW_MODES6[DRAW_MODES6["LINE_STRIP"] = 3] = "LINE_STRIP";
    DRAW_MODES6[DRAW_MODES6["TRIANGLES"] = 4] = "TRIANGLES";
    DRAW_MODES6[DRAW_MODES6["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
    DRAW_MODES6[DRAW_MODES6["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
  })(DRAW_MODES2 || (DRAW_MODES2 = {}));
  var FORMATS2;
  (function(FORMATS6) {
    FORMATS6[FORMATS6["RGBA"] = 6408] = "RGBA";
    FORMATS6[FORMATS6["RGB"] = 6407] = "RGB";
    FORMATS6[FORMATS6["RG"] = 33319] = "RG";
    FORMATS6[FORMATS6["RED"] = 6403] = "RED";
    FORMATS6[FORMATS6["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
    FORMATS6[FORMATS6["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
    FORMATS6[FORMATS6["RG_INTEGER"] = 33320] = "RG_INTEGER";
    FORMATS6[FORMATS6["RED_INTEGER"] = 36244] = "RED_INTEGER";
    FORMATS6[FORMATS6["ALPHA"] = 6406] = "ALPHA";
    FORMATS6[FORMATS6["LUMINANCE"] = 6409] = "LUMINANCE";
    FORMATS6[FORMATS6["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
    FORMATS6[FORMATS6["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
    FORMATS6[FORMATS6["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
  })(FORMATS2 || (FORMATS2 = {}));
  var TARGETS2;
  (function(TARGETS6) {
    TARGETS6[TARGETS6["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
    TARGETS6[TARGETS6["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  })(TARGETS2 || (TARGETS2 = {}));
  var TYPES2;
  (function(TYPES6) {
    TYPES6[TYPES6["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    TYPES6[TYPES6["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    TYPES6[TYPES6["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
    TYPES6[TYPES6["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
    TYPES6[TYPES6["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
    TYPES6[TYPES6["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
    TYPES6[TYPES6["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
    TYPES6[TYPES6["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
    TYPES6[TYPES6["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
    TYPES6[TYPES6["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
    TYPES6[TYPES6["BYTE"] = 5120] = "BYTE";
    TYPES6[TYPES6["SHORT"] = 5122] = "SHORT";
    TYPES6[TYPES6["INT"] = 5124] = "INT";
    TYPES6[TYPES6["FLOAT"] = 5126] = "FLOAT";
    TYPES6[TYPES6["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
    TYPES6[TYPES6["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
  })(TYPES2 || (TYPES2 = {}));
  var SAMPLER_TYPES2;
  (function(SAMPLER_TYPES6) {
    SAMPLER_TYPES6[SAMPLER_TYPES6["FLOAT"] = 0] = "FLOAT";
    SAMPLER_TYPES6[SAMPLER_TYPES6["INT"] = 1] = "INT";
    SAMPLER_TYPES6[SAMPLER_TYPES6["UINT"] = 2] = "UINT";
  })(SAMPLER_TYPES2 || (SAMPLER_TYPES2 = {}));
  var SCALE_MODES2;
  (function(SCALE_MODES6) {
    SCALE_MODES6[SCALE_MODES6["NEAREST"] = 0] = "NEAREST";
    SCALE_MODES6[SCALE_MODES6["LINEAR"] = 1] = "LINEAR";
  })(SCALE_MODES2 || (SCALE_MODES2 = {}));
  var WRAP_MODES2;
  (function(WRAP_MODES6) {
    WRAP_MODES6[WRAP_MODES6["CLAMP"] = 33071] = "CLAMP";
    WRAP_MODES6[WRAP_MODES6["REPEAT"] = 10497] = "REPEAT";
    WRAP_MODES6[WRAP_MODES6["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
  })(WRAP_MODES2 || (WRAP_MODES2 = {}));
  var MIPMAP_MODES2;
  (function(MIPMAP_MODES6) {
    MIPMAP_MODES6[MIPMAP_MODES6["OFF"] = 0] = "OFF";
    MIPMAP_MODES6[MIPMAP_MODES6["POW2"] = 1] = "POW2";
    MIPMAP_MODES6[MIPMAP_MODES6["ON"] = 2] = "ON";
    MIPMAP_MODES6[MIPMAP_MODES6["ON_MANUAL"] = 3] = "ON_MANUAL";
  })(MIPMAP_MODES2 || (MIPMAP_MODES2 = {}));
  var ALPHA_MODES2;
  (function(ALPHA_MODES6) {
    ALPHA_MODES6[ALPHA_MODES6["NPM"] = 0] = "NPM";
    ALPHA_MODES6[ALPHA_MODES6["UNPACK"] = 1] = "UNPACK";
    ALPHA_MODES6[ALPHA_MODES6["PMA"] = 2] = "PMA";
    ALPHA_MODES6[ALPHA_MODES6["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
    ALPHA_MODES6[ALPHA_MODES6["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
    ALPHA_MODES6[ALPHA_MODES6["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
    ALPHA_MODES6[ALPHA_MODES6["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
  })(ALPHA_MODES2 || (ALPHA_MODES2 = {}));
  var CLEAR_MODES2;
  (function(CLEAR_MODES6) {
    CLEAR_MODES6[CLEAR_MODES6["NO"] = 0] = "NO";
    CLEAR_MODES6[CLEAR_MODES6["YES"] = 1] = "YES";
    CLEAR_MODES6[CLEAR_MODES6["AUTO"] = 2] = "AUTO";
    CLEAR_MODES6[CLEAR_MODES6["BLEND"] = 0] = "BLEND";
    CLEAR_MODES6[CLEAR_MODES6["CLEAR"] = 1] = "CLEAR";
    CLEAR_MODES6[CLEAR_MODES6["BLIT"] = 2] = "BLIT";
  })(CLEAR_MODES2 || (CLEAR_MODES2 = {}));
  var GC_MODES2;
  (function(GC_MODES6) {
    GC_MODES6[GC_MODES6["AUTO"] = 0] = "AUTO";
    GC_MODES6[GC_MODES6["MANUAL"] = 1] = "MANUAL";
  })(GC_MODES2 || (GC_MODES2 = {}));
  var PRECISION2;
  (function(PRECISION6) {
    PRECISION6["LOW"] = "lowp";
    PRECISION6["MEDIUM"] = "mediump";
    PRECISION6["HIGH"] = "highp";
  })(PRECISION2 || (PRECISION2 = {}));
  var MASK_TYPES2;
  (function(MASK_TYPES6) {
    MASK_TYPES6[MASK_TYPES6["NONE"] = 0] = "NONE";
    MASK_TYPES6[MASK_TYPES6["SCISSOR"] = 1] = "SCISSOR";
    MASK_TYPES6[MASK_TYPES6["STENCIL"] = 2] = "STENCIL";
    MASK_TYPES6[MASK_TYPES6["SPRITE"] = 3] = "SPRITE";
  })(MASK_TYPES2 || (MASK_TYPES2 = {}));
  var MSAA_QUALITY2;
  (function(MSAA_QUALITY6) {
    MSAA_QUALITY6[MSAA_QUALITY6["NONE"] = 0] = "NONE";
    MSAA_QUALITY6[MSAA_QUALITY6["LOW"] = 2] = "LOW";
    MSAA_QUALITY6[MSAA_QUALITY6["MEDIUM"] = 4] = "MEDIUM";
    MSAA_QUALITY6[MSAA_QUALITY6["HIGH"] = 8] = "HIGH";
  })(MSAA_QUALITY2 || (MSAA_QUALITY2 = {}));
  var BUFFER_TYPE2;
  (function(BUFFER_TYPE6) {
    BUFFER_TYPE6[BUFFER_TYPE6["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
    BUFFER_TYPE6[BUFFER_TYPE6["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
    BUFFER_TYPE6[BUFFER_TYPE6["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
  })(BUFFER_TYPE2 || (BUFFER_TYPE2 = {}));
  var settings = {
    /**
     * If set to true WebGL will attempt make textures mimpaped by default.
     * Mipmapping will only succeed if the base texture uploaded has power of two dimensions.
     * @static
     * @name MIPMAP_TEXTURES
     * @memberof PIXI.settings
     * @type {PIXI.MIPMAP_MODES}
     * @default PIXI.MIPMAP_MODES.POW2
     */
    MIPMAP_TEXTURES: MIPMAP_MODES2.POW2,
    /**
     * Default anisotropic filtering level of textures.
     * Usually from 0 to 16
     * @static
     * @name ANISOTROPIC_LEVEL
     * @memberof PIXI.settings
     * @type {number}
     * @default 0
     */
    ANISOTROPIC_LEVEL: 0,
    /**
     * Default resolution / device pixel ratio of the renderer.
     * @static
     * @name RESOLUTION
     * @memberof PIXI.settings
     * @type {number}
     * @default 1
     */
    RESOLUTION: 1,
    /**
     * Default filter resolution.
     * @static
     * @name FILTER_RESOLUTION
     * @memberof PIXI.settings
     * @type {number}
     * @default 1
     */
    FILTER_RESOLUTION: 1,
    /**
     * Default filter samples.
     * @static
     * @name FILTER_MULTISAMPLE
     * @memberof PIXI.settings
     * @type {PIXI.MSAA_QUALITY}
     * @default PIXI.MSAA_QUALITY.NONE
     */
    FILTER_MULTISAMPLE: MSAA_QUALITY2.NONE,
    /**
     * The maximum textures that this device supports.
     * @static
     * @name SPRITE_MAX_TEXTURES
     * @memberof PIXI.settings
     * @type {number}
     * @default 32
     */
    SPRITE_MAX_TEXTURES: maxRecommendedTextures(32),
    // TODO: maybe change to SPRITE.BATCH_SIZE: 2000
    // TODO: maybe add PARTICLE.BATCH_SIZE: 15000
    /**
     * The default sprite batch size.
     *
     * The default aims to balance desktop and mobile devices.
     * @static
     * @name SPRITE_BATCH_SIZE
     * @memberof PIXI.settings
     * @type {number}
     * @default 4096
     */
    SPRITE_BATCH_SIZE: 4096,
    /**
     * The default render options if none are supplied to {@link PIXI.Renderer}
     * or {@link PIXI.CanvasRenderer}.
     * @static
     * @name RENDER_OPTIONS
     * @memberof PIXI.settings
     * @type {object}
     * @property {HTMLCanvasElement} [view=null] -
     * @property {boolean} [antialias=false] -
     * @property {boolean} [autoDensity=false] -
     * @property {boolean} [useContextAlpha=true]  -
     * @property {number} [backgroundColor=0x000000] -
     * @property {number} [backgroundAlpha=1] -
     * @property {boolean} [clearBeforeRender=true] -
     * @property {boolean} [preserveDrawingBuffer=false] -
     * @property {number} [width=800] -
     * @property {number} [height=600] -
     * @property {boolean} [legacy=false] -
     */
    RENDER_OPTIONS: {
      view: null,
      antialias: false,
      autoDensity: false,
      backgroundColor: 0,
      backgroundAlpha: 1,
      useContextAlpha: true,
      clearBeforeRender: true,
      preserveDrawingBuffer: false,
      width: 800,
      height: 600,
      legacy: false
    },
    /**
     * Default Garbage Collection mode.
     * @static
     * @name GC_MODE
     * @memberof PIXI.settings
     * @type {PIXI.GC_MODES}
     * @default PIXI.GC_MODES.AUTO
     */
    GC_MODE: GC_MODES2.AUTO,
    /**
     * Default Garbage Collection max idle.
     * @static
     * @name GC_MAX_IDLE
     * @memberof PIXI.settings
     * @type {number}
     * @default 3600
     */
    GC_MAX_IDLE: 60 * 60,
    /**
     * Default Garbage Collection maximum check count.
     * @static
     * @name GC_MAX_CHECK_COUNT
     * @memberof PIXI.settings
     * @type {number}
     * @default 600
     */
    GC_MAX_CHECK_COUNT: 60 * 10,
    /**
     * Default wrap modes that are supported by pixi.
     * @static
     * @name WRAP_MODE
     * @memberof PIXI.settings
     * @type {PIXI.WRAP_MODES}
     * @default PIXI.WRAP_MODES.CLAMP
     */
    WRAP_MODE: WRAP_MODES2.CLAMP,
    /**
     * Default scale mode for textures.
     * @static
     * @name SCALE_MODE
     * @memberof PIXI.settings
     * @type {PIXI.SCALE_MODES}
     * @default PIXI.SCALE_MODES.LINEAR
     */
    SCALE_MODE: SCALE_MODES2.LINEAR,
    /**
     * Default specify float precision in vertex shader.
     * @static
     * @name PRECISION_VERTEX
     * @memberof PIXI.settings
     * @type {PIXI.PRECISION}
     * @default PIXI.PRECISION.HIGH
     */
    PRECISION_VERTEX: PRECISION2.HIGH,
    /**
     * Default specify float precision in fragment shader.
     * iOS is best set at highp due to https://github.com/pixijs/pixi.js/issues/3742
     * @static
     * @name PRECISION_FRAGMENT
     * @memberof PIXI.settings
     * @type {PIXI.PRECISION}
     * @default PIXI.PRECISION.MEDIUM
     */
    PRECISION_FRAGMENT: isMobile2.apple.device ? PRECISION2.HIGH : PRECISION2.MEDIUM,
    /**
     * Can we upload the same buffer in a single frame?
     * @static
     * @name CAN_UPLOAD_SAME_BUFFER
     * @memberof PIXI.settings
     * @type {boolean}
     */
    CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer(),
    /**
     * Enables bitmap creation before image load. This feature is experimental.
     * @static
     * @name CREATE_IMAGE_BITMAP
     * @memberof PIXI.settings
     * @type {boolean}
     * @default false
     */
    CREATE_IMAGE_BITMAP: false,
    /**
     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
     * Advantages can include sharper image quality (like text) and faster rendering on canvas.
     * The main disadvantage is movement of objects may appear less smooth.
     * @static
     * @constant
     * @memberof PIXI.settings
     * @type {boolean}
     * @default false
     */
    ROUND_PIXELS: false
  };

  // node_modules/@pixi/ticker/dist/esm/ticker.js
  settings.TARGET_FPMS = 0.06;
  var UPDATE_PRIORITY;
  (function(UPDATE_PRIORITY3) {
    UPDATE_PRIORITY3[UPDATE_PRIORITY3["INTERACTION"] = 50] = "INTERACTION";
    UPDATE_PRIORITY3[UPDATE_PRIORITY3["HIGH"] = 25] = "HIGH";
    UPDATE_PRIORITY3[UPDATE_PRIORITY3["NORMAL"] = 0] = "NORMAL";
    UPDATE_PRIORITY3[UPDATE_PRIORITY3["LOW"] = -25] = "LOW";
    UPDATE_PRIORITY3[UPDATE_PRIORITY3["UTILITY"] = -50] = "UTILITY";
  })(UPDATE_PRIORITY || (UPDATE_PRIORITY = {}));
  var TickerListener = (
    /** @class */
    function() {
      function TickerListener3(fn, context3, priority, once) {
        if (context3 === void 0) {
          context3 = null;
        }
        if (priority === void 0) {
          priority = 0;
        }
        if (once === void 0) {
          once = false;
        }
        this.next = null;
        this.previous = null;
        this._destroyed = false;
        this.fn = fn;
        this.context = context3;
        this.priority = priority;
        this.once = once;
      }
      TickerListener3.prototype.match = function(fn, context3) {
        if (context3 === void 0) {
          context3 = null;
        }
        return this.fn === fn && this.context === context3;
      };
      TickerListener3.prototype.emit = function(deltaTime) {
        if (this.fn) {
          if (this.context) {
            this.fn.call(this.context, deltaTime);
          } else {
            this.fn(deltaTime);
          }
        }
        var redirect = this.next;
        if (this.once) {
          this.destroy(true);
        }
        if (this._destroyed) {
          this.next = null;
        }
        return redirect;
      };
      TickerListener3.prototype.connect = function(previous) {
        this.previous = previous;
        if (previous.next) {
          previous.next.previous = this;
        }
        this.next = previous.next;
        previous.next = this;
      };
      TickerListener3.prototype.destroy = function(hard) {
        if (hard === void 0) {
          hard = false;
        }
        this._destroyed = true;
        this.fn = null;
        this.context = null;
        if (this.previous) {
          this.previous.next = this.next;
        }
        if (this.next) {
          this.next.previous = this.previous;
        }
        var redirect = this.next;
        this.next = hard ? null : redirect;
        this.previous = null;
        return redirect;
      };
      return TickerListener3;
    }()
  );
  var Ticker = (
    /** @class */
    function() {
      function Ticker3() {
        var _this = this;
        this.autoStart = false;
        this.deltaTime = 1;
        this.lastTime = -1;
        this.speed = 1;
        this.started = false;
        this._requestId = null;
        this._maxElapsedMS = 100;
        this._minElapsedMS = 0;
        this._protected = false;
        this._lastFrame = -1;
        this._head = new TickerListener(null, null, Infinity);
        this.deltaMS = 1 / settings.TARGET_FPMS;
        this.elapsedMS = 1 / settings.TARGET_FPMS;
        this._tick = function(time) {
          _this._requestId = null;
          if (_this.started) {
            _this.update(time);
            if (_this.started && _this._requestId === null && _this._head.next) {
              _this._requestId = requestAnimationFrame(_this._tick);
            }
          }
        };
      }
      Ticker3.prototype._requestIfNeeded = function() {
        if (this._requestId === null && this._head.next) {
          this.lastTime = performance.now();
          this._lastFrame = this.lastTime;
          this._requestId = requestAnimationFrame(this._tick);
        }
      };
      Ticker3.prototype._cancelIfNeeded = function() {
        if (this._requestId !== null) {
          cancelAnimationFrame(this._requestId);
          this._requestId = null;
        }
      };
      Ticker3.prototype._startIfPossible = function() {
        if (this.started) {
          this._requestIfNeeded();
        } else if (this.autoStart) {
          this.start();
        }
      };
      Ticker3.prototype.add = function(fn, context3, priority) {
        if (priority === void 0) {
          priority = UPDATE_PRIORITY.NORMAL;
        }
        return this._addListener(new TickerListener(fn, context3, priority));
      };
      Ticker3.prototype.addOnce = function(fn, context3, priority) {
        if (priority === void 0) {
          priority = UPDATE_PRIORITY.NORMAL;
        }
        return this._addListener(new TickerListener(fn, context3, priority, true));
      };
      Ticker3.prototype._addListener = function(listener) {
        var current = this._head.next;
        var previous = this._head;
        if (!current) {
          listener.connect(previous);
        } else {
          while (current) {
            if (listener.priority > current.priority) {
              listener.connect(previous);
              break;
            }
            previous = current;
            current = current.next;
          }
          if (!listener.previous) {
            listener.connect(previous);
          }
        }
        this._startIfPossible();
        return this;
      };
      Ticker3.prototype.remove = function(fn, context3) {
        var listener = this._head.next;
        while (listener) {
          if (listener.match(fn, context3)) {
            listener = listener.destroy();
          } else {
            listener = listener.next;
          }
        }
        if (!this._head.next) {
          this._cancelIfNeeded();
        }
        return this;
      };
      Object.defineProperty(Ticker3.prototype, "count", {
        /**
         * The number of listeners on this ticker, calculated by walking through linked list
         * @readonly
         * @member {number}
         */
        get: function() {
          if (!this._head) {
            return 0;
          }
          var count = 0;
          var current = this._head;
          while (current = current.next) {
            count++;
          }
          return count;
        },
        enumerable: false,
        configurable: true
      });
      Ticker3.prototype.start = function() {
        if (!this.started) {
          this.started = true;
          this._requestIfNeeded();
        }
      };
      Ticker3.prototype.stop = function() {
        if (this.started) {
          this.started = false;
          this._cancelIfNeeded();
        }
      };
      Ticker3.prototype.destroy = function() {
        if (!this._protected) {
          this.stop();
          var listener = this._head.next;
          while (listener) {
            listener = listener.destroy(true);
          }
          this._head.destroy();
          this._head = null;
        }
      };
      Ticker3.prototype.update = function(currentTime) {
        if (currentTime === void 0) {
          currentTime = performance.now();
        }
        var elapsedMS;
        if (currentTime > this.lastTime) {
          elapsedMS = this.elapsedMS = currentTime - this.lastTime;
          if (elapsedMS > this._maxElapsedMS) {
            elapsedMS = this._maxElapsedMS;
          }
          elapsedMS *= this.speed;
          if (this._minElapsedMS) {
            var delta = currentTime - this._lastFrame | 0;
            if (delta < this._minElapsedMS) {
              return;
            }
            this._lastFrame = currentTime - delta % this._minElapsedMS;
          }
          this.deltaMS = elapsedMS;
          this.deltaTime = this.deltaMS * settings.TARGET_FPMS;
          var head = this._head;
          var listener = head.next;
          while (listener) {
            listener = listener.emit(this.deltaTime);
          }
          if (!head.next) {
            this._cancelIfNeeded();
          }
        } else {
          this.deltaTime = this.deltaMS = this.elapsedMS = 0;
        }
        this.lastTime = currentTime;
      };
      Object.defineProperty(Ticker3.prototype, "FPS", {
        /**
         * The frames per second at which this ticker is running.
         * The default is approximately 60 in most modern browsers.
         * **Note:** This does not factor in the value of
         * {@link PIXI.Ticker#speed}, which is specific
         * to scaling {@link PIXI.Ticker#deltaTime}.
         * @member {number}
         * @readonly
         */
        get: function() {
          return 1e3 / this.elapsedMS;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Ticker3.prototype, "minFPS", {
        /**
         * Manages the maximum amount of milliseconds allowed to
         * elapse between invoking {@link PIXI.Ticker#update}.
         * This value is used to cap {@link PIXI.Ticker#deltaTime},
         * but does not effect the measured value of {@link PIXI.Ticker#FPS}.
         * When setting this property it is clamped to a value between
         * `0` and `PIXI.settings.TARGET_FPMS * 1000`.
         * @member {number}
         * @default 10
         */
        get: function() {
          return 1e3 / this._maxElapsedMS;
        },
        set: function(fps) {
          var minFPS = Math.min(this.maxFPS, fps);
          var minFPMS = Math.min(Math.max(0, minFPS) / 1e3, settings.TARGET_FPMS);
          this._maxElapsedMS = 1 / minFPMS;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Ticker3.prototype, "maxFPS", {
        /**
         * Manages the minimum amount of milliseconds required to
         * elapse between invoking {@link PIXI.Ticker#update}.
         * This will effect the measured value of {@link PIXI.Ticker#FPS}.
         * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
         * Otherwise it will be at least `minFPS`
         * @member {number}
         * @default 0
         */
        get: function() {
          if (this._minElapsedMS) {
            return Math.round(1e3 / this._minElapsedMS);
          }
          return 0;
        },
        set: function(fps) {
          if (fps === 0) {
            this._minElapsedMS = 0;
          } else {
            var maxFPS = Math.max(this.minFPS, fps);
            this._minElapsedMS = 1 / (maxFPS / 1e3);
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Ticker3, "shared", {
        /**
         * The shared ticker instance used by {@link PIXI.AnimatedSprite} and by
         * {@link PIXI.VideoResource} to update animation frames / video textures.
         *
         * It may also be used by {@link PIXI.Application} if created with the `sharedTicker` option property set to true.
         *
         * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
         * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
         * @example
         * let ticker = PIXI.Ticker.shared;
         * // Set this to prevent starting this ticker when listeners are added.
         * // By default this is true only for the PIXI.Ticker.shared instance.
         * ticker.autoStart = false;
         * // FYI, call this to ensure the ticker is stopped. It should be stopped
         * // if you have not attempted to render anything yet.
         * ticker.stop();
         * // Call this when you are ready for a running shared ticker.
         * ticker.start();
         * @example
         * // You may use the shared ticker to render...
         * let renderer = PIXI.autoDetectRenderer();
         * let stage = new PIXI.Container();
         * document.body.appendChild(renderer.view);
         * ticker.add(function (time) {
         *     renderer.render(stage);
         * });
         * @example
         * // Or you can just update it manually.
         * ticker.autoStart = false;
         * ticker.stop();
         * function animate(time) {
         *     ticker.update(time);
         *     renderer.render(stage);
         *     requestAnimationFrame(animate);
         * }
         * animate(performance.now());
         * @member {PIXI.Ticker}
         * @static
         */
        get: function() {
          if (!Ticker3._shared) {
            var shared = Ticker3._shared = new Ticker3();
            shared.autoStart = true;
            shared._protected = true;
          }
          return Ticker3._shared;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Ticker3, "system", {
        /**
         * The system ticker instance used by {@link PIXI.InteractionManager} and by
         * {@link PIXI.BasePrepare} for core timing functionality that shouldn't usually need to be paused,
         * unlike the `shared` ticker which drives visual animations and rendering which may want to be paused.
         *
         * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
         * @member {PIXI.Ticker}
         * @static
         */
        get: function() {
          if (!Ticker3._system) {
            var system = Ticker3._system = new Ticker3();
            system.autoStart = true;
            system._protected = true;
          }
          return Ticker3._system;
        },
        enumerable: false,
        configurable: true
      });
      return Ticker3;
    }()
  );
  var TickerPlugin = (
    /** @class */
    function() {
      function TickerPlugin2() {
      }
      TickerPlugin2.init = function(options) {
        var _this = this;
        options = Object.assign({
          autoStart: true,
          sharedTicker: false
        }, options);
        Object.defineProperty(this, "ticker", {
          set: function(ticker) {
            if (this._ticker) {
              this._ticker.remove(this.render, this);
            }
            this._ticker = ticker;
            if (ticker) {
              ticker.add(this.render, this, UPDATE_PRIORITY.LOW);
            }
          },
          get: function() {
            return this._ticker;
          }
        });
        this.stop = function() {
          _this._ticker.stop();
        };
        this.start = function() {
          _this._ticker.start();
        };
        this._ticker = null;
        this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();
        if (options.autoStart) {
          this.start();
        }
      };
      TickerPlugin2.destroy = function() {
        if (this._ticker) {
          var oldTicker = this._ticker;
          this.ticker = null;
          oldTicker.destroy();
        }
      };
      return TickerPlugin2;
    }()
  );

  // node_modules/@pixi/utils/dist/esm/utils.js
  var utils_exports = {};
  __export(utils_exports, {
    BaseTextureCache: () => BaseTextureCache,
    CanvasRenderTarget: () => CanvasRenderTarget,
    DATA_URI: () => DATA_URI,
    EventEmitter: () => import_eventemitter3.default,
    ProgramCache: () => ProgramCache,
    TextureCache: () => TextureCache,
    clearTextureCache: () => clearTextureCache,
    correctBlendMode: () => correctBlendMode,
    createIndicesForQuads: () => createIndicesForQuads,
    decomposeDataUri: () => decomposeDataUri,
    deprecation: () => deprecation,
    destroyTextureCache: () => destroyTextureCache,
    determineCrossOrigin: () => determineCrossOrigin,
    earcut: () => import_earcut.default,
    getBufferType: () => getBufferType,
    getResolutionOfUrl: () => getResolutionOfUrl,
    hex2rgb: () => hex2rgb,
    hex2string: () => hex2string,
    interleaveTypedArrays: () => interleaveTypedArrays,
    isMobile: () => isMobile2,
    isPow2: () => isPow2,
    isWebGLSupported: () => isWebGLSupported,
    log2: () => log2,
    nextPow2: () => nextPow2,
    premultiplyBlendMode: () => premultiplyBlendMode,
    premultiplyRgba: () => premultiplyRgba,
    premultiplyTint: () => premultiplyTint,
    premultiplyTintToRgba: () => premultiplyTintToRgba,
    removeItems: () => removeItems,
    rgb2hex: () => rgb2hex,
    sayHello: () => sayHello,
    sign: () => sign,
    skipHello: () => skipHello,
    string2hex: () => string2hex,
    trimCanvas: () => trimCanvas,
    uid: () => uid,
    url: () => url
  });
  var import_eventemitter3 = __toESM(require_eventemitter3());
  var import_earcut = __toESM(require_earcut());
  var import_url = __toESM(require_url());
  var url = {
    parse: import_url.parse,
    format: import_url.format,
    resolve: import_url.resolve
  };
  settings.RETINA_PREFIX = /@([0-9\.]+)x/;
  settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;
  var saidHello = false;
  var VERSION = "6.4.2";
  function skipHello() {
    saidHello = true;
  }
  function sayHello(type) {
    var _a2;
    if (saidHello) {
      return;
    }
    if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
      var args = [
        "\n %c %c %c PixiJS " + VERSION + " - \u2730 " + type + " \u2730  %c  %c  http://www.pixijs.com/  %c %c \u2665%c\u2665%c\u2665 \n\n",
        "background: #ff66a5; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "color: #ff66a5; background: #030307; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "background: #ffc3dc; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;"
      ];
      (_a2 = globalThis.console).log.apply(_a2, args);
    } else if (globalThis.console) {
      globalThis.console.log("PixiJS " + VERSION + " - " + type + " - http://www.pixijs.com/");
    }
    saidHello = true;
  }
  var supported;
  function isWebGLSupported() {
    if (typeof supported === "undefined") {
      supported = function supported3() {
        var contextOptions = {
          stencil: true,
          failIfMajorPerformanceCaveat: settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
        };
        try {
          if (!globalThis.WebGLRenderingContext) {
            return false;
          }
          var canvas = document.createElement("canvas");
          var gl = canvas.getContext("webgl", contextOptions) || canvas.getContext("experimental-webgl", contextOptions);
          var success = !!(gl && gl.getContextAttributes().stencil);
          if (gl) {
            var loseContext = gl.getExtension("WEBGL_lose_context");
            if (loseContext) {
              loseContext.loseContext();
            }
          }
          gl = null;
          return success;
        } catch (e) {
          return false;
        }
      }();
    }
    return supported;
  }
  var aliceblue = "#f0f8ff";
  var antiquewhite = "#faebd7";
  var aqua = "#00ffff";
  var aquamarine = "#7fffd4";
  var azure = "#f0ffff";
  var beige = "#f5f5dc";
  var bisque = "#ffe4c4";
  var black = "#000000";
  var blanchedalmond = "#ffebcd";
  var blue = "#0000ff";
  var blueviolet = "#8a2be2";
  var brown = "#a52a2a";
  var burlywood = "#deb887";
  var cadetblue = "#5f9ea0";
  var chartreuse = "#7fff00";
  var chocolate = "#d2691e";
  var coral = "#ff7f50";
  var cornflowerblue = "#6495ed";
  var cornsilk = "#fff8dc";
  var crimson = "#dc143c";
  var cyan = "#00ffff";
  var darkblue = "#00008b";
  var darkcyan = "#008b8b";
  var darkgoldenrod = "#b8860b";
  var darkgray = "#a9a9a9";
  var darkgreen = "#006400";
  var darkgrey = "#a9a9a9";
  var darkkhaki = "#bdb76b";
  var darkmagenta = "#8b008b";
  var darkolivegreen = "#556b2f";
  var darkorange = "#ff8c00";
  var darkorchid = "#9932cc";
  var darkred = "#8b0000";
  var darksalmon = "#e9967a";
  var darkseagreen = "#8fbc8f";
  var darkslateblue = "#483d8b";
  var darkslategray = "#2f4f4f";
  var darkslategrey = "#2f4f4f";
  var darkturquoise = "#00ced1";
  var darkviolet = "#9400d3";
  var deeppink = "#ff1493";
  var deepskyblue = "#00bfff";
  var dimgray = "#696969";
  var dimgrey = "#696969";
  var dodgerblue = "#1e90ff";
  var firebrick = "#b22222";
  var floralwhite = "#fffaf0";
  var forestgreen = "#228b22";
  var fuchsia = "#ff00ff";
  var gainsboro = "#dcdcdc";
  var ghostwhite = "#f8f8ff";
  var goldenrod = "#daa520";
  var gold = "#ffd700";
  var gray = "#808080";
  var green = "#008000";
  var greenyellow = "#adff2f";
  var grey = "#808080";
  var honeydew = "#f0fff0";
  var hotpink = "#ff69b4";
  var indianred = "#cd5c5c";
  var indigo = "#4b0082";
  var ivory = "#fffff0";
  var khaki = "#f0e68c";
  var lavenderblush = "#fff0f5";
  var lavender = "#e6e6fa";
  var lawngreen = "#7cfc00";
  var lemonchiffon = "#fffacd";
  var lightblue = "#add8e6";
  var lightcoral = "#f08080";
  var lightcyan = "#e0ffff";
  var lightgoldenrodyellow = "#fafad2";
  var lightgray = "#d3d3d3";
  var lightgreen = "#90ee90";
  var lightgrey = "#d3d3d3";
  var lightpink = "#ffb6c1";
  var lightsalmon = "#ffa07a";
  var lightseagreen = "#20b2aa";
  var lightskyblue = "#87cefa";
  var lightslategray = "#778899";
  var lightslategrey = "#778899";
  var lightsteelblue = "#b0c4de";
  var lightyellow = "#ffffe0";
  var lime = "#00ff00";
  var limegreen = "#32cd32";
  var linen = "#faf0e6";
  var magenta = "#ff00ff";
  var maroon = "#800000";
  var mediumaquamarine = "#66cdaa";
  var mediumblue = "#0000cd";
  var mediumorchid = "#ba55d3";
  var mediumpurple = "#9370db";
  var mediumseagreen = "#3cb371";
  var mediumslateblue = "#7b68ee";
  var mediumspringgreen = "#00fa9a";
  var mediumturquoise = "#48d1cc";
  var mediumvioletred = "#c71585";
  var midnightblue = "#191970";
  var mintcream = "#f5fffa";
  var mistyrose = "#ffe4e1";
  var moccasin = "#ffe4b5";
  var navajowhite = "#ffdead";
  var navy = "#000080";
  var oldlace = "#fdf5e6";
  var olive = "#808000";
  var olivedrab = "#6b8e23";
  var orange = "#ffa500";
  var orangered = "#ff4500";
  var orchid = "#da70d6";
  var palegoldenrod = "#eee8aa";
  var palegreen = "#98fb98";
  var paleturquoise = "#afeeee";
  var palevioletred = "#db7093";
  var papayawhip = "#ffefd5";
  var peachpuff = "#ffdab9";
  var peru = "#cd853f";
  var pink = "#ffc0cb";
  var plum = "#dda0dd";
  var powderblue = "#b0e0e6";
  var purple = "#800080";
  var rebeccapurple = "#663399";
  var red = "#ff0000";
  var rosybrown = "#bc8f8f";
  var royalblue = "#4169e1";
  var saddlebrown = "#8b4513";
  var salmon = "#fa8072";
  var sandybrown = "#f4a460";
  var seagreen = "#2e8b57";
  var seashell = "#fff5ee";
  var sienna = "#a0522d";
  var silver = "#c0c0c0";
  var skyblue = "#87ceeb";
  var slateblue = "#6a5acd";
  var slategray = "#708090";
  var slategrey = "#708090";
  var snow = "#fffafa";
  var springgreen = "#00ff7f";
  var steelblue = "#4682b4";
  var tan = "#d2b48c";
  var teal = "#008080";
  var thistle = "#d8bfd8";
  var tomato = "#ff6347";
  var turquoise = "#40e0d0";
  var violet = "#ee82ee";
  var wheat = "#f5deb3";
  var white = "#ffffff";
  var whitesmoke = "#f5f5f5";
  var yellow = "#ffff00";
  var yellowgreen = "#9acd32";
  var cssColorNames = {
    aliceblue,
    antiquewhite,
    aqua,
    aquamarine,
    azure,
    beige,
    bisque,
    black,
    blanchedalmond,
    blue,
    blueviolet,
    brown,
    burlywood,
    cadetblue,
    chartreuse,
    chocolate,
    coral,
    cornflowerblue,
    cornsilk,
    crimson,
    cyan,
    darkblue,
    darkcyan,
    darkgoldenrod,
    darkgray,
    darkgreen,
    darkgrey,
    darkkhaki,
    darkmagenta,
    darkolivegreen,
    darkorange,
    darkorchid,
    darkred,
    darksalmon,
    darkseagreen,
    darkslateblue,
    darkslategray,
    darkslategrey,
    darkturquoise,
    darkviolet,
    deeppink,
    deepskyblue,
    dimgray,
    dimgrey,
    dodgerblue,
    firebrick,
    floralwhite,
    forestgreen,
    fuchsia,
    gainsboro,
    ghostwhite,
    goldenrod,
    gold,
    gray,
    green,
    greenyellow,
    grey,
    honeydew,
    hotpink,
    indianred,
    indigo,
    ivory,
    khaki,
    lavenderblush,
    lavender,
    lawngreen,
    lemonchiffon,
    lightblue,
    lightcoral,
    lightcyan,
    lightgoldenrodyellow,
    lightgray,
    lightgreen,
    lightgrey,
    lightpink,
    lightsalmon,
    lightseagreen,
    lightskyblue,
    lightslategray,
    lightslategrey,
    lightsteelblue,
    lightyellow,
    lime,
    limegreen,
    linen,
    magenta,
    maroon,
    mediumaquamarine,
    mediumblue,
    mediumorchid,
    mediumpurple,
    mediumseagreen,
    mediumslateblue,
    mediumspringgreen,
    mediumturquoise,
    mediumvioletred,
    midnightblue,
    mintcream,
    mistyrose,
    moccasin,
    navajowhite,
    navy,
    oldlace,
    olive,
    olivedrab,
    orange,
    orangered,
    orchid,
    palegoldenrod,
    palegreen,
    paleturquoise,
    palevioletred,
    papayawhip,
    peachpuff,
    peru,
    pink,
    plum,
    powderblue,
    purple,
    rebeccapurple,
    red,
    rosybrown,
    royalblue,
    saddlebrown,
    salmon,
    sandybrown,
    seagreen,
    seashell,
    sienna,
    silver,
    skyblue,
    slateblue,
    slategray,
    slategrey,
    snow,
    springgreen,
    steelblue,
    tan,
    teal,
    thistle,
    tomato,
    turquoise,
    violet,
    wheat,
    white,
    whitesmoke,
    yellow,
    yellowgreen
  };
  function hex2rgb(hex, out) {
    if (out === void 0) {
      out = [];
    }
    out[0] = (hex >> 16 & 255) / 255;
    out[1] = (hex >> 8 & 255) / 255;
    out[2] = (hex & 255) / 255;
    return out;
  }
  function hex2string(hex) {
    var hexString = hex.toString(16);
    hexString = "000000".substring(0, 6 - hexString.length) + hexString;
    return "#" + hexString;
  }
  function string2hex(string) {
    if (typeof string === "string") {
      string = cssColorNames[string.toLowerCase()] || string;
      if (string[0] === "#") {
        string = string.slice(1);
      }
    }
    return parseInt(string, 16);
  }
  function rgb2hex(rgb) {
    return (rgb[0] * 255 << 16) + (rgb[1] * 255 << 8) + (rgb[2] * 255 | 0);
  }
  function mapPremultipliedBlendModes() {
    var pm = [];
    var npm = [];
    for (var i = 0; i < 32; i++) {
      pm[i] = i;
      npm[i] = i;
    }
    pm[BLEND_MODES.NORMAL_NPM] = BLEND_MODES.NORMAL;
    pm[BLEND_MODES.ADD_NPM] = BLEND_MODES.ADD;
    pm[BLEND_MODES.SCREEN_NPM] = BLEND_MODES.SCREEN;
    npm[BLEND_MODES.NORMAL] = BLEND_MODES.NORMAL_NPM;
    npm[BLEND_MODES.ADD] = BLEND_MODES.ADD_NPM;
    npm[BLEND_MODES.SCREEN] = BLEND_MODES.SCREEN_NPM;
    var array = [];
    array.push(npm);
    array.push(pm);
    return array;
  }
  var premultiplyBlendMode = mapPremultipliedBlendModes();
  function correctBlendMode(blendMode, premultiplied) {
    return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];
  }
  function premultiplyRgba(rgb, alpha, out, premultiply) {
    out = out || new Float32Array(4);
    if (premultiply || premultiply === void 0) {
      out[0] = rgb[0] * alpha;
      out[1] = rgb[1] * alpha;
      out[2] = rgb[2] * alpha;
    } else {
      out[0] = rgb[0];
      out[1] = rgb[1];
      out[2] = rgb[2];
    }
    out[3] = alpha;
    return out;
  }
  function premultiplyTint(tint, alpha) {
    if (alpha === 1) {
      return (alpha * 255 << 24) + tint;
    }
    if (alpha === 0) {
      return 0;
    }
    var R = tint >> 16 & 255;
    var G = tint >> 8 & 255;
    var B = tint & 255;
    R = R * alpha + 0.5 | 0;
    G = G * alpha + 0.5 | 0;
    B = B * alpha + 0.5 | 0;
    return (alpha * 255 << 24) + (R << 16) + (G << 8) + B;
  }
  function premultiplyTintToRgba(tint, alpha, out, premultiply) {
    out = out || new Float32Array(4);
    out[0] = (tint >> 16 & 255) / 255;
    out[1] = (tint >> 8 & 255) / 255;
    out[2] = (tint & 255) / 255;
    if (premultiply || premultiply === void 0) {
      out[0] *= alpha;
      out[1] *= alpha;
      out[2] *= alpha;
    }
    out[3] = alpha;
    return out;
  }
  function createIndicesForQuads(size, outBuffer) {
    if (outBuffer === void 0) {
      outBuffer = null;
    }
    var totalIndices = size * 6;
    outBuffer = outBuffer || new Uint16Array(totalIndices);
    if (outBuffer.length !== totalIndices) {
      throw new Error("Out buffer length is incorrect, got " + outBuffer.length + " and expected " + totalIndices);
    }
    for (var i = 0, j = 0; i < totalIndices; i += 6, j += 4) {
      outBuffer[i + 0] = j + 0;
      outBuffer[i + 1] = j + 1;
      outBuffer[i + 2] = j + 2;
      outBuffer[i + 3] = j + 0;
      outBuffer[i + 4] = j + 2;
      outBuffer[i + 5] = j + 3;
    }
    return outBuffer;
  }
  function getBufferType(array) {
    if (array.BYTES_PER_ELEMENT === 4) {
      if (array instanceof Float32Array) {
        return "Float32Array";
      } else if (array instanceof Uint32Array) {
        return "Uint32Array";
      }
      return "Int32Array";
    } else if (array.BYTES_PER_ELEMENT === 2) {
      if (array instanceof Uint16Array) {
        return "Uint16Array";
      }
    } else if (array.BYTES_PER_ELEMENT === 1) {
      if (array instanceof Uint8Array) {
        return "Uint8Array";
      }
    }
    return null;
  }
  var map = { Float32Array, Uint32Array, Int32Array, Uint8Array };
  function interleaveTypedArrays(arrays, sizes) {
    var outSize = 0;
    var stride = 0;
    var views = {};
    for (var i = 0; i < arrays.length; i++) {
      stride += sizes[i];
      outSize += arrays[i].length;
    }
    var buffer = new ArrayBuffer(outSize * 4);
    var out = null;
    var littleOffset = 0;
    for (var i = 0; i < arrays.length; i++) {
      var size = sizes[i];
      var array = arrays[i];
      var type = getBufferType(array);
      if (!views[type]) {
        views[type] = new map[type](buffer);
      }
      out = views[type];
      for (var j = 0; j < array.length; j++) {
        var indexStart = (j / size | 0) * stride + littleOffset;
        var index = j % size;
        out[indexStart + index] = array[j];
      }
      littleOffset += size;
    }
    return new Float32Array(buffer);
  }
  function nextPow2(v) {
    v += v === 0 ? 1 : 0;
    --v;
    v |= v >>> 1;
    v |= v >>> 2;
    v |= v >>> 4;
    v |= v >>> 8;
    v |= v >>> 16;
    return v + 1;
  }
  function isPow2(v) {
    return !(v & v - 1) && !!v;
  }
  function log2(v) {
    var r = (v > 65535 ? 1 : 0) << 4;
    v >>>= r;
    var shift = (v > 255 ? 1 : 0) << 3;
    v >>>= shift;
    r |= shift;
    shift = (v > 15 ? 1 : 0) << 2;
    v >>>= shift;
    r |= shift;
    shift = (v > 3 ? 1 : 0) << 1;
    v >>>= shift;
    r |= shift;
    return r | v >> 1;
  }
  function removeItems(arr, startIdx, removeCount) {
    var length = arr.length;
    var i;
    if (startIdx >= length || removeCount === 0) {
      return;
    }
    removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
    var len = length - removeCount;
    for (i = startIdx; i < len; ++i) {
      arr[i] = arr[i + removeCount];
    }
    arr.length = len;
  }
  function sign(n) {
    if (n === 0) {
      return 0;
    }
    return n < 0 ? -1 : 1;
  }
  var nextUid = 0;
  function uid() {
    return ++nextUid;
  }
  var warnings = {};
  function deprecation(version, message, ignoreDepth) {
    if (ignoreDepth === void 0) {
      ignoreDepth = 3;
    }
    if (warnings[message]) {
      return;
    }
    var stack = new Error().stack;
    if (typeof stack === "undefined") {
      console.warn("PixiJS Deprecation Warning: ", message + "\nDeprecated since v" + version);
    } else {
      stack = stack.split("\n").splice(ignoreDepth).join("\n");
      if (console.groupCollapsed) {
        console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", message + "\nDeprecated since v" + version);
        console.warn(stack);
        console.groupEnd();
      } else {
        console.warn("PixiJS Deprecation Warning: ", message + "\nDeprecated since v" + version);
        console.warn(stack);
      }
    }
    warnings[message] = true;
  }
  var ProgramCache = {};
  var TextureCache = /* @__PURE__ */ Object.create(null);
  var BaseTextureCache = /* @__PURE__ */ Object.create(null);
  function destroyTextureCache() {
    var key;
    for (key in TextureCache) {
      TextureCache[key].destroy();
    }
    for (key in BaseTextureCache) {
      BaseTextureCache[key].destroy();
    }
  }
  function clearTextureCache() {
    var key;
    for (key in TextureCache) {
      delete TextureCache[key];
    }
    for (key in BaseTextureCache) {
      delete BaseTextureCache[key];
    }
  }
  var CanvasRenderTarget = (
    /** @class */
    function() {
      function CanvasRenderTarget2(width, height, resolution) {
        this.canvas = document.createElement("canvas");
        this.context = this.canvas.getContext("2d");
        this.resolution = resolution || settings.RESOLUTION;
        this.resize(width, height);
      }
      CanvasRenderTarget2.prototype.clear = function() {
        this.context.setTransform(1, 0, 0, 1, 0, 0);
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
      };
      CanvasRenderTarget2.prototype.resize = function(desiredWidth, desiredHeight) {
        this.canvas.width = Math.round(desiredWidth * this.resolution);
        this.canvas.height = Math.round(desiredHeight * this.resolution);
      };
      CanvasRenderTarget2.prototype.destroy = function() {
        this.context = null;
        this.canvas = null;
      };
      Object.defineProperty(CanvasRenderTarget2.prototype, "width", {
        /**
         * The width of the canvas buffer in pixels.
         * @member {number}
         */
        get: function() {
          return this.canvas.width;
        },
        set: function(val) {
          this.canvas.width = Math.round(val);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CanvasRenderTarget2.prototype, "height", {
        /**
         * The height of the canvas buffer in pixels.
         * @member {number}
         */
        get: function() {
          return this.canvas.height;
        },
        set: function(val) {
          this.canvas.height = Math.round(val);
        },
        enumerable: false,
        configurable: true
      });
      return CanvasRenderTarget2;
    }()
  );
  function trimCanvas(canvas) {
    var width = canvas.width;
    var height = canvas.height;
    var context3 = canvas.getContext("2d");
    var imageData = context3.getImageData(0, 0, width, height);
    var pixels = imageData.data;
    var len = pixels.length;
    var bound = {
      top: null,
      left: null,
      right: null,
      bottom: null
    };
    var data = null;
    var i;
    var x;
    var y;
    for (i = 0; i < len; i += 4) {
      if (pixels[i + 3] !== 0) {
        x = i / 4 % width;
        y = ~~(i / 4 / width);
        if (bound.top === null) {
          bound.top = y;
        }
        if (bound.left === null) {
          bound.left = x;
        } else if (x < bound.left) {
          bound.left = x;
        }
        if (bound.right === null) {
          bound.right = x + 1;
        } else if (bound.right < x) {
          bound.right = x + 1;
        }
        if (bound.bottom === null) {
          bound.bottom = y;
        } else if (bound.bottom < y) {
          bound.bottom = y;
        }
      }
    }
    if (bound.top !== null) {
      width = bound.right - bound.left;
      height = bound.bottom - bound.top + 1;
      data = context3.getImageData(bound.left, bound.top, width, height);
    }
    return {
      height,
      width,
      data
    };
  }
  var DATA_URI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;
  function decomposeDataUri(dataUri) {
    var dataUriMatch = DATA_URI.exec(dataUri);
    if (dataUriMatch) {
      return {
        mediaType: dataUriMatch[1] ? dataUriMatch[1].toLowerCase() : void 0,
        subType: dataUriMatch[2] ? dataUriMatch[2].toLowerCase() : void 0,
        charset: dataUriMatch[3] ? dataUriMatch[3].toLowerCase() : void 0,
        encoding: dataUriMatch[4] ? dataUriMatch[4].toLowerCase() : void 0,
        data: dataUriMatch[5]
      };
    }
    return void 0;
  }
  var tempAnchor;
  function determineCrossOrigin(url$1, loc) {
    if (loc === void 0) {
      loc = globalThis.location;
    }
    if (url$1.indexOf("data:") === 0) {
      return "";
    }
    loc = loc || globalThis.location;
    if (!tempAnchor) {
      tempAnchor = document.createElement("a");
    }
    tempAnchor.href = url$1;
    var parsedUrl = url.parse(tempAnchor.href);
    var samePort = !parsedUrl.port && loc.port === "" || parsedUrl.port === loc.port;
    if (parsedUrl.hostname !== loc.hostname || !samePort || parsedUrl.protocol !== loc.protocol) {
      return "anonymous";
    }
    return "";
  }
  function getResolutionOfUrl(url3, defaultValue3) {
    var resolution = settings.RETINA_PREFIX.exec(url3);
    if (resolution) {
      return parseFloat(resolution[1]);
    }
    return defaultValue3 !== void 0 ? defaultValue3 : 1;
  }

  // node_modules/@pixi/display/dist/esm/display.js
  settings.SORTABLE_CHILDREN = false;
  var Bounds = (
    /** @class */
    function() {
      function Bounds3() {
        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;
        this.rect = null;
        this.updateID = -1;
      }
      Bounds3.prototype.isEmpty = function() {
        return this.minX > this.maxX || this.minY > this.maxY;
      };
      Bounds3.prototype.clear = function() {
        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;
      };
      Bounds3.prototype.getRectangle = function(rect) {
        if (this.minX > this.maxX || this.minY > this.maxY) {
          return Rectangle.EMPTY;
        }
        rect = rect || new Rectangle(0, 0, 1, 1);
        rect.x = this.minX;
        rect.y = this.minY;
        rect.width = this.maxX - this.minX;
        rect.height = this.maxY - this.minY;
        return rect;
      };
      Bounds3.prototype.addPoint = function(point) {
        this.minX = Math.min(this.minX, point.x);
        this.maxX = Math.max(this.maxX, point.x);
        this.minY = Math.min(this.minY, point.y);
        this.maxY = Math.max(this.maxY, point.y);
      };
      Bounds3.prototype.addPointMatrix = function(matrix, point) {
        var a = matrix.a, b = matrix.b, c = matrix.c, d = matrix.d, tx = matrix.tx, ty = matrix.ty;
        var x = a * point.x + c * point.y + tx;
        var y = b * point.x + d * point.y + ty;
        this.minX = Math.min(this.minX, x);
        this.maxX = Math.max(this.maxX, x);
        this.minY = Math.min(this.minY, y);
        this.maxY = Math.max(this.maxY, y);
      };
      Bounds3.prototype.addQuad = function(vertices) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        var x = vertices[0];
        var y = vertices[1];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = vertices[2];
        y = vertices[3];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = vertices[4];
        y = vertices[5];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = vertices[6];
        y = vertices[7];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      };
      Bounds3.prototype.addFrame = function(transform, x0, y0, x1, y1) {
        this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);
      };
      Bounds3.prototype.addFrameMatrix = function(matrix, x0, y0, x1, y1) {
        var a = matrix.a;
        var b = matrix.b;
        var c = matrix.c;
        var d = matrix.d;
        var tx = matrix.tx;
        var ty = matrix.ty;
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        var x = a * x0 + c * y0 + tx;
        var y = b * x0 + d * y0 + ty;
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = a * x1 + c * y0 + tx;
        y = b * x1 + d * y0 + ty;
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = a * x0 + c * y1 + tx;
        y = b * x0 + d * y1 + ty;
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = a * x1 + c * y1 + tx;
        y = b * x1 + d * y1 + ty;
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      };
      Bounds3.prototype.addVertexData = function(vertexData, beginOffset, endOffset) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        for (var i = beginOffset; i < endOffset; i += 2) {
          var x = vertexData[i];
          var y = vertexData[i + 1];
          minX = x < minX ? x : minX;
          minY = y < minY ? y : minY;
          maxX = x > maxX ? x : maxX;
          maxY = y > maxY ? y : maxY;
        }
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      };
      Bounds3.prototype.addVertices = function(transform, vertices, beginOffset, endOffset) {
        this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);
      };
      Bounds3.prototype.addVerticesMatrix = function(matrix, vertices, beginOffset, endOffset, padX, padY) {
        if (padX === void 0) {
          padX = 0;
        }
        if (padY === void 0) {
          padY = padX;
        }
        var a = matrix.a;
        var b = matrix.b;
        var c = matrix.c;
        var d = matrix.d;
        var tx = matrix.tx;
        var ty = matrix.ty;
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        for (var i = beginOffset; i < endOffset; i += 2) {
          var rawX = vertices[i];
          var rawY = vertices[i + 1];
          var x = a * rawX + c * rawY + tx;
          var y = d * rawY + b * rawX + ty;
          minX = Math.min(minX, x - padX);
          maxX = Math.max(maxX, x + padX);
          minY = Math.min(minY, y - padY);
          maxY = Math.max(maxY, y + padY);
        }
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      };
      Bounds3.prototype.addBounds = function(bounds) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        this.minX = bounds.minX < minX ? bounds.minX : minX;
        this.minY = bounds.minY < minY ? bounds.minY : minY;
        this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;
        this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
      };
      Bounds3.prototype.addBoundsMask = function(bounds, mask) {
        var _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;
        var _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;
        var _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;
        var _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;
        if (_minX <= _maxX && _minY <= _maxY) {
          var minX = this.minX;
          var minY = this.minY;
          var maxX = this.maxX;
          var maxY = this.maxY;
          this.minX = _minX < minX ? _minX : minX;
          this.minY = _minY < minY ? _minY : minY;
          this.maxX = _maxX > maxX ? _maxX : maxX;
          this.maxY = _maxY > maxY ? _maxY : maxY;
        }
      };
      Bounds3.prototype.addBoundsMatrix = function(bounds, matrix) {
        this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
      };
      Bounds3.prototype.addBoundsArea = function(bounds, area) {
        var _minX = bounds.minX > area.x ? bounds.minX : area.x;
        var _minY = bounds.minY > area.y ? bounds.minY : area.y;
        var _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : area.x + area.width;
        var _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : area.y + area.height;
        if (_minX <= _maxX && _minY <= _maxY) {
          var minX = this.minX;
          var minY = this.minY;
          var maxX = this.maxX;
          var maxY = this.maxY;
          this.minX = _minX < minX ? _minX : minX;
          this.minY = _minY < minY ? _minY : minY;
          this.maxX = _maxX > maxX ? _maxX : maxX;
          this.maxY = _maxY > maxY ? _maxY : maxY;
        }
      };
      Bounds3.prototype.pad = function(paddingX, paddingY) {
        if (paddingX === void 0) {
          paddingX = 0;
        }
        if (paddingY === void 0) {
          paddingY = paddingX;
        }
        if (!this.isEmpty()) {
          this.minX -= paddingX;
          this.maxX += paddingX;
          this.minY -= paddingY;
          this.maxY += paddingY;
        }
      };
      Bounds3.prototype.addFramePad = function(x0, y0, x1, y1, padX, padY) {
        x0 -= padX;
        y0 -= padY;
        x1 += padX;
        y1 += padY;
        this.minX = this.minX < x0 ? this.minX : x0;
        this.maxX = this.maxX > x1 ? this.maxX : x1;
        this.minY = this.minY < y0 ? this.minY : y0;
        this.maxY = this.maxY > y1 ? this.maxY : y1;
      };
      return Bounds3;
    }()
  );
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) {
        if (b2.hasOwnProperty(p)) {
          d2[p] = b2[p];
        }
      }
    };
    return extendStatics(d, b);
  };
  function __extends(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var DisplayObject = (
    /** @class */
    function(_super) {
      __extends(DisplayObject3, _super);
      function DisplayObject3() {
        var _this = _super.call(this) || this;
        _this.tempDisplayObjectParent = null;
        _this.transform = new Transform();
        _this.alpha = 1;
        _this.visible = true;
        _this.renderable = true;
        _this.cullable = false;
        _this.cullArea = null;
        _this.parent = null;
        _this.worldAlpha = 1;
        _this._lastSortedIndex = 0;
        _this._zIndex = 0;
        _this.filterArea = null;
        _this.filters = null;
        _this._enabledFilters = null;
        _this._bounds = new Bounds();
        _this._localBounds = null;
        _this._boundsID = 0;
        _this._boundsRect = null;
        _this._localBoundsRect = null;
        _this._mask = null;
        _this._maskRefCount = 0;
        _this._destroyed = false;
        _this.isSprite = false;
        _this.isMask = false;
        return _this;
      }
      DisplayObject3.mixin = function(source) {
        var keys = Object.keys(source);
        for (var i = 0; i < keys.length; ++i) {
          var propertyName = keys[i];
          Object.defineProperty(DisplayObject3.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
        }
      };
      Object.defineProperty(DisplayObject3.prototype, "destroyed", {
        /**
         * Fired when this DisplayObject is added to a Container.
         * @instance
         * @event added
         * @param {PIXI.Container} container - The container added to.
         */
        /**
         * Fired when this DisplayObject is removed from a Container.
         * @instance
         * @event removed
         * @param {PIXI.Container} container - The container removed from.
         */
        /**
         * Fired when this DisplayObject is destroyed. This event is emitted once
         * destroy is finished.
         * @instance
         * @event destroyed
         */
        /** Readonly flag for destroyed display objects. */
        get: function() {
          return this._destroyed;
        },
        enumerable: false,
        configurable: true
      });
      DisplayObject3.prototype._recursivePostUpdateTransform = function() {
        if (this.parent) {
          this.parent._recursivePostUpdateTransform();
          this.transform.updateTransform(this.parent.transform);
        } else {
          this.transform.updateTransform(this._tempDisplayObjectParent.transform);
        }
      };
      DisplayObject3.prototype.updateTransform = function() {
        this._boundsID++;
        this.transform.updateTransform(this.parent.transform);
        this.worldAlpha = this.alpha * this.parent.worldAlpha;
      };
      DisplayObject3.prototype.getBounds = function(skipUpdate, rect) {
        if (!skipUpdate) {
          if (!this.parent) {
            this.parent = this._tempDisplayObjectParent;
            this.updateTransform();
            this.parent = null;
          } else {
            this._recursivePostUpdateTransform();
            this.updateTransform();
          }
        }
        if (this._bounds.updateID !== this._boundsID) {
          this.calculateBounds();
          this._bounds.updateID = this._boundsID;
        }
        if (!rect) {
          if (!this._boundsRect) {
            this._boundsRect = new Rectangle();
          }
          rect = this._boundsRect;
        }
        return this._bounds.getRectangle(rect);
      };
      DisplayObject3.prototype.getLocalBounds = function(rect) {
        if (!rect) {
          if (!this._localBoundsRect) {
            this._localBoundsRect = new Rectangle();
          }
          rect = this._localBoundsRect;
        }
        if (!this._localBounds) {
          this._localBounds = new Bounds();
        }
        var transformRef = this.transform;
        var parentRef = this.parent;
        this.parent = null;
        this.transform = this._tempDisplayObjectParent.transform;
        var worldBounds = this._bounds;
        var worldBoundsID = this._boundsID;
        this._bounds = this._localBounds;
        var bounds = this.getBounds(false, rect);
        this.parent = parentRef;
        this.transform = transformRef;
        this._bounds = worldBounds;
        this._bounds.updateID += this._boundsID - worldBoundsID;
        return bounds;
      };
      DisplayObject3.prototype.toGlobal = function(position, point, skipUpdate) {
        if (skipUpdate === void 0) {
          skipUpdate = false;
        }
        if (!skipUpdate) {
          this._recursivePostUpdateTransform();
          if (!this.parent) {
            this.parent = this._tempDisplayObjectParent;
            this.displayObjectUpdateTransform();
            this.parent = null;
          } else {
            this.displayObjectUpdateTransform();
          }
        }
        return this.worldTransform.apply(position, point);
      };
      DisplayObject3.prototype.toLocal = function(position, from, point, skipUpdate) {
        if (from) {
          position = from.toGlobal(position, point, skipUpdate);
        }
        if (!skipUpdate) {
          this._recursivePostUpdateTransform();
          if (!this.parent) {
            this.parent = this._tempDisplayObjectParent;
            this.displayObjectUpdateTransform();
            this.parent = null;
          } else {
            this.displayObjectUpdateTransform();
          }
        }
        return this.worldTransform.applyInverse(position, point);
      };
      DisplayObject3.prototype.setParent = function(container) {
        if (!container || !container.addChild) {
          throw new Error("setParent: Argument must be a Container");
        }
        container.addChild(this);
        return container;
      };
      DisplayObject3.prototype.setTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, pivotX, pivotY) {
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        if (scaleX === void 0) {
          scaleX = 1;
        }
        if (scaleY === void 0) {
          scaleY = 1;
        }
        if (rotation === void 0) {
          rotation = 0;
        }
        if (skewX === void 0) {
          skewX = 0;
        }
        if (skewY === void 0) {
          skewY = 0;
        }
        if (pivotX === void 0) {
          pivotX = 0;
        }
        if (pivotY === void 0) {
          pivotY = 0;
        }
        this.position.x = x;
        this.position.y = y;
        this.scale.x = !scaleX ? 1 : scaleX;
        this.scale.y = !scaleY ? 1 : scaleY;
        this.rotation = rotation;
        this.skew.x = skewX;
        this.skew.y = skewY;
        this.pivot.x = pivotX;
        this.pivot.y = pivotY;
        return this;
      };
      DisplayObject3.prototype.destroy = function(_options) {
        if (this.parent) {
          this.parent.removeChild(this);
        }
        this._destroyed = true;
        this.transform = null;
        this.parent = null;
        this._bounds = null;
        this.mask = null;
        this.cullArea = null;
        this.filters = null;
        this.filterArea = null;
        this.hitArea = null;
        this.interactive = false;
        this.interactiveChildren = false;
        this.emit("destroyed");
        this.removeAllListeners();
      };
      Object.defineProperty(DisplayObject3.prototype, "_tempDisplayObjectParent", {
        /**
         * @protected
         * @member {PIXI.Container}
         */
        get: function() {
          if (this.tempDisplayObjectParent === null) {
            this.tempDisplayObjectParent = new TemporaryDisplayObject();
          }
          return this.tempDisplayObjectParent;
        },
        enumerable: false,
        configurable: true
      });
      DisplayObject3.prototype.enableTempParent = function() {
        var myParent = this.parent;
        this.parent = this._tempDisplayObjectParent;
        return myParent;
      };
      DisplayObject3.prototype.disableTempParent = function(cacheParent) {
        this.parent = cacheParent;
      };
      Object.defineProperty(DisplayObject3.prototype, "x", {
        /**
         * The position of the displayObject on the x axis relative to the local coordinates of the parent.
         * An alias to position.x
         */
        get: function() {
          return this.position.x;
        },
        set: function(value) {
          this.transform.position.x = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject3.prototype, "y", {
        /**
         * The position of the displayObject on the y axis relative to the local coordinates of the parent.
         * An alias to position.y
         */
        get: function() {
          return this.position.y;
        },
        set: function(value) {
          this.transform.position.y = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject3.prototype, "worldTransform", {
        /**
         * Current transform of the object based on world (parent) factors.
         * @readonly
         */
        get: function() {
          return this.transform.worldTransform;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject3.prototype, "localTransform", {
        /**
         * Current transform of the object based on local factors: position, scale, other stuff.
         * @readonly
         */
        get: function() {
          return this.transform.localTransform;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject3.prototype, "position", {
        /**
         * The coordinate of the object relative to the local coordinates of the parent.
         * @since 4.0.0
         */
        get: function() {
          return this.transform.position;
        },
        set: function(value) {
          this.transform.position.copyFrom(value);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject3.prototype, "scale", {
        /**
         * The scale factors of this object along the local coordinate axes.
         *
         * The default scale is (1, 1).
         * @since 4.0.0
         */
        get: function() {
          return this.transform.scale;
        },
        set: function(value) {
          this.transform.scale.copyFrom(value);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject3.prototype, "pivot", {
        /**
         * The center of rotation, scaling, and skewing for this display object in its local space. The `position`
         * is the projection of `pivot` in the parent's local space.
         *
         * By default, the pivot is the origin (0, 0).
         * @since 4.0.0
         */
        get: function() {
          return this.transform.pivot;
        },
        set: function(value) {
          this.transform.pivot.copyFrom(value);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject3.prototype, "skew", {
        /**
         * The skew factor for the object in radians.
         * @since 4.0.0
         */
        get: function() {
          return this.transform.skew;
        },
        set: function(value) {
          this.transform.skew.copyFrom(value);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject3.prototype, "rotation", {
        /**
         * The rotation of the object in radians.
         * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
         */
        get: function() {
          return this.transform.rotation;
        },
        set: function(value) {
          this.transform.rotation = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject3.prototype, "angle", {
        /**
         * The angle of the object in degrees.
         * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
         */
        get: function() {
          return this.transform.rotation * RAD_TO_DEG;
        },
        set: function(value) {
          this.transform.rotation = value * DEG_TO_RAD;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject3.prototype, "zIndex", {
        /**
         * The zIndex of the displayObject.
         *
         * If a container has the sortableChildren property set to true, children will be automatically
         * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,
         * and thus rendered on top of other display objects within the same container.
         * @see PIXI.Container#sortableChildren
         */
        get: function() {
          return this._zIndex;
        },
        set: function(value) {
          this._zIndex = value;
          if (this.parent) {
            this.parent.sortDirty = true;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject3.prototype, "worldVisible", {
        /**
         * Indicates if the object is globally visible.
         * @readonly
         */
        get: function() {
          var item = this;
          do {
            if (!item.visible) {
              return false;
            }
            item = item.parent;
          } while (item);
          return true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject3.prototype, "mask", {
        /**
         * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
         * object to the shape of the mask applied to it. In PixiJS a regular mask must be a
         * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it
         * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.
         * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.
         * To remove a mask, set this property to `null`.
         *
         * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.
         * @example
         * const graphics = new PIXI.Graphics();
         * graphics.beginFill(0xFF3300);
         * graphics.drawRect(50, 250, 100, 100);
         * graphics.endFill();
         *
         * const sprite = new PIXI.Sprite(texture);
         * sprite.mask = graphics;
         * @todo At the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.
         */
        get: function() {
          return this._mask;
        },
        set: function(value) {
          if (this._mask === value) {
            return;
          }
          if (this._mask) {
            var maskObject = this._mask.maskObject || this._mask;
            maskObject._maskRefCount--;
            if (maskObject._maskRefCount === 0) {
              maskObject.renderable = true;
              maskObject.isMask = false;
            }
          }
          this._mask = value;
          if (this._mask) {
            var maskObject = this._mask.maskObject || this._mask;
            if (maskObject._maskRefCount === 0) {
              maskObject.renderable = false;
              maskObject.isMask = true;
            }
            maskObject._maskRefCount++;
          }
        },
        enumerable: false,
        configurable: true
      });
      return DisplayObject3;
    }(import_eventemitter3.default)
  );
  var TemporaryDisplayObject = (
    /** @class */
    function(_super) {
      __extends(TemporaryDisplayObject3, _super);
      function TemporaryDisplayObject3() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.sortDirty = null;
        return _this;
      }
      return TemporaryDisplayObject3;
    }(DisplayObject)
  );
  DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;
  var ENV3;
  (function(ENV6) {
    ENV6[ENV6["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
    ENV6[ENV6["WEBGL"] = 1] = "WEBGL";
    ENV6[ENV6["WEBGL2"] = 2] = "WEBGL2";
  })(ENV3 || (ENV3 = {}));
  var RENDERER_TYPE3;
  (function(RENDERER_TYPE6) {
    RENDERER_TYPE6[RENDERER_TYPE6["UNKNOWN"] = 0] = "UNKNOWN";
    RENDERER_TYPE6[RENDERER_TYPE6["WEBGL"] = 1] = "WEBGL";
    RENDERER_TYPE6[RENDERER_TYPE6["CANVAS"] = 2] = "CANVAS";
  })(RENDERER_TYPE3 || (RENDERER_TYPE3 = {}));
  var BUFFER_BITS3;
  (function(BUFFER_BITS6) {
    BUFFER_BITS6[BUFFER_BITS6["COLOR"] = 16384] = "COLOR";
    BUFFER_BITS6[BUFFER_BITS6["DEPTH"] = 256] = "DEPTH";
    BUFFER_BITS6[BUFFER_BITS6["STENCIL"] = 1024] = "STENCIL";
  })(BUFFER_BITS3 || (BUFFER_BITS3 = {}));
  var BLEND_MODES3;
  (function(BLEND_MODES6) {
    BLEND_MODES6[BLEND_MODES6["NORMAL"] = 0] = "NORMAL";
    BLEND_MODES6[BLEND_MODES6["ADD"] = 1] = "ADD";
    BLEND_MODES6[BLEND_MODES6["MULTIPLY"] = 2] = "MULTIPLY";
    BLEND_MODES6[BLEND_MODES6["SCREEN"] = 3] = "SCREEN";
    BLEND_MODES6[BLEND_MODES6["OVERLAY"] = 4] = "OVERLAY";
    BLEND_MODES6[BLEND_MODES6["DARKEN"] = 5] = "DARKEN";
    BLEND_MODES6[BLEND_MODES6["LIGHTEN"] = 6] = "LIGHTEN";
    BLEND_MODES6[BLEND_MODES6["COLOR_DODGE"] = 7] = "COLOR_DODGE";
    BLEND_MODES6[BLEND_MODES6["COLOR_BURN"] = 8] = "COLOR_BURN";
    BLEND_MODES6[BLEND_MODES6["HARD_LIGHT"] = 9] = "HARD_LIGHT";
    BLEND_MODES6[BLEND_MODES6["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
    BLEND_MODES6[BLEND_MODES6["DIFFERENCE"] = 11] = "DIFFERENCE";
    BLEND_MODES6[BLEND_MODES6["EXCLUSION"] = 12] = "EXCLUSION";
    BLEND_MODES6[BLEND_MODES6["HUE"] = 13] = "HUE";
    BLEND_MODES6[BLEND_MODES6["SATURATION"] = 14] = "SATURATION";
    BLEND_MODES6[BLEND_MODES6["COLOR"] = 15] = "COLOR";
    BLEND_MODES6[BLEND_MODES6["LUMINOSITY"] = 16] = "LUMINOSITY";
    BLEND_MODES6[BLEND_MODES6["NORMAL_NPM"] = 17] = "NORMAL_NPM";
    BLEND_MODES6[BLEND_MODES6["ADD_NPM"] = 18] = "ADD_NPM";
    BLEND_MODES6[BLEND_MODES6["SCREEN_NPM"] = 19] = "SCREEN_NPM";
    BLEND_MODES6[BLEND_MODES6["NONE"] = 20] = "NONE";
    BLEND_MODES6[BLEND_MODES6["SRC_OVER"] = 0] = "SRC_OVER";
    BLEND_MODES6[BLEND_MODES6["SRC_IN"] = 21] = "SRC_IN";
    BLEND_MODES6[BLEND_MODES6["SRC_OUT"] = 22] = "SRC_OUT";
    BLEND_MODES6[BLEND_MODES6["SRC_ATOP"] = 23] = "SRC_ATOP";
    BLEND_MODES6[BLEND_MODES6["DST_OVER"] = 24] = "DST_OVER";
    BLEND_MODES6[BLEND_MODES6["DST_IN"] = 25] = "DST_IN";
    BLEND_MODES6[BLEND_MODES6["DST_OUT"] = 26] = "DST_OUT";
    BLEND_MODES6[BLEND_MODES6["DST_ATOP"] = 27] = "DST_ATOP";
    BLEND_MODES6[BLEND_MODES6["ERASE"] = 26] = "ERASE";
    BLEND_MODES6[BLEND_MODES6["SUBTRACT"] = 28] = "SUBTRACT";
    BLEND_MODES6[BLEND_MODES6["XOR"] = 29] = "XOR";
  })(BLEND_MODES3 || (BLEND_MODES3 = {}));
  var DRAW_MODES3;
  (function(DRAW_MODES6) {
    DRAW_MODES6[DRAW_MODES6["POINTS"] = 0] = "POINTS";
    DRAW_MODES6[DRAW_MODES6["LINES"] = 1] = "LINES";
    DRAW_MODES6[DRAW_MODES6["LINE_LOOP"] = 2] = "LINE_LOOP";
    DRAW_MODES6[DRAW_MODES6["LINE_STRIP"] = 3] = "LINE_STRIP";
    DRAW_MODES6[DRAW_MODES6["TRIANGLES"] = 4] = "TRIANGLES";
    DRAW_MODES6[DRAW_MODES6["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
    DRAW_MODES6[DRAW_MODES6["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
  })(DRAW_MODES3 || (DRAW_MODES3 = {}));
  var FORMATS3;
  (function(FORMATS6) {
    FORMATS6[FORMATS6["RGBA"] = 6408] = "RGBA";
    FORMATS6[FORMATS6["RGB"] = 6407] = "RGB";
    FORMATS6[FORMATS6["RG"] = 33319] = "RG";
    FORMATS6[FORMATS6["RED"] = 6403] = "RED";
    FORMATS6[FORMATS6["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
    FORMATS6[FORMATS6["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
    FORMATS6[FORMATS6["RG_INTEGER"] = 33320] = "RG_INTEGER";
    FORMATS6[FORMATS6["RED_INTEGER"] = 36244] = "RED_INTEGER";
    FORMATS6[FORMATS6["ALPHA"] = 6406] = "ALPHA";
    FORMATS6[FORMATS6["LUMINANCE"] = 6409] = "LUMINANCE";
    FORMATS6[FORMATS6["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
    FORMATS6[FORMATS6["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
    FORMATS6[FORMATS6["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
  })(FORMATS3 || (FORMATS3 = {}));
  var TARGETS3;
  (function(TARGETS6) {
    TARGETS6[TARGETS6["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
    TARGETS6[TARGETS6["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  })(TARGETS3 || (TARGETS3 = {}));
  var TYPES3;
  (function(TYPES6) {
    TYPES6[TYPES6["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    TYPES6[TYPES6["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    TYPES6[TYPES6["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
    TYPES6[TYPES6["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
    TYPES6[TYPES6["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
    TYPES6[TYPES6["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
    TYPES6[TYPES6["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
    TYPES6[TYPES6["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
    TYPES6[TYPES6["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
    TYPES6[TYPES6["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
    TYPES6[TYPES6["BYTE"] = 5120] = "BYTE";
    TYPES6[TYPES6["SHORT"] = 5122] = "SHORT";
    TYPES6[TYPES6["INT"] = 5124] = "INT";
    TYPES6[TYPES6["FLOAT"] = 5126] = "FLOAT";
    TYPES6[TYPES6["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
    TYPES6[TYPES6["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
  })(TYPES3 || (TYPES3 = {}));
  var SAMPLER_TYPES3;
  (function(SAMPLER_TYPES6) {
    SAMPLER_TYPES6[SAMPLER_TYPES6["FLOAT"] = 0] = "FLOAT";
    SAMPLER_TYPES6[SAMPLER_TYPES6["INT"] = 1] = "INT";
    SAMPLER_TYPES6[SAMPLER_TYPES6["UINT"] = 2] = "UINT";
  })(SAMPLER_TYPES3 || (SAMPLER_TYPES3 = {}));
  var SCALE_MODES3;
  (function(SCALE_MODES6) {
    SCALE_MODES6[SCALE_MODES6["NEAREST"] = 0] = "NEAREST";
    SCALE_MODES6[SCALE_MODES6["LINEAR"] = 1] = "LINEAR";
  })(SCALE_MODES3 || (SCALE_MODES3 = {}));
  var WRAP_MODES3;
  (function(WRAP_MODES6) {
    WRAP_MODES6[WRAP_MODES6["CLAMP"] = 33071] = "CLAMP";
    WRAP_MODES6[WRAP_MODES6["REPEAT"] = 10497] = "REPEAT";
    WRAP_MODES6[WRAP_MODES6["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
  })(WRAP_MODES3 || (WRAP_MODES3 = {}));
  var MIPMAP_MODES3;
  (function(MIPMAP_MODES6) {
    MIPMAP_MODES6[MIPMAP_MODES6["OFF"] = 0] = "OFF";
    MIPMAP_MODES6[MIPMAP_MODES6["POW2"] = 1] = "POW2";
    MIPMAP_MODES6[MIPMAP_MODES6["ON"] = 2] = "ON";
    MIPMAP_MODES6[MIPMAP_MODES6["ON_MANUAL"] = 3] = "ON_MANUAL";
  })(MIPMAP_MODES3 || (MIPMAP_MODES3 = {}));
  var ALPHA_MODES3;
  (function(ALPHA_MODES6) {
    ALPHA_MODES6[ALPHA_MODES6["NPM"] = 0] = "NPM";
    ALPHA_MODES6[ALPHA_MODES6["UNPACK"] = 1] = "UNPACK";
    ALPHA_MODES6[ALPHA_MODES6["PMA"] = 2] = "PMA";
    ALPHA_MODES6[ALPHA_MODES6["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
    ALPHA_MODES6[ALPHA_MODES6["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
    ALPHA_MODES6[ALPHA_MODES6["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
    ALPHA_MODES6[ALPHA_MODES6["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
  })(ALPHA_MODES3 || (ALPHA_MODES3 = {}));
  var CLEAR_MODES3;
  (function(CLEAR_MODES6) {
    CLEAR_MODES6[CLEAR_MODES6["NO"] = 0] = "NO";
    CLEAR_MODES6[CLEAR_MODES6["YES"] = 1] = "YES";
    CLEAR_MODES6[CLEAR_MODES6["AUTO"] = 2] = "AUTO";
    CLEAR_MODES6[CLEAR_MODES6["BLEND"] = 0] = "BLEND";
    CLEAR_MODES6[CLEAR_MODES6["CLEAR"] = 1] = "CLEAR";
    CLEAR_MODES6[CLEAR_MODES6["BLIT"] = 2] = "BLIT";
  })(CLEAR_MODES3 || (CLEAR_MODES3 = {}));
  var GC_MODES3;
  (function(GC_MODES6) {
    GC_MODES6[GC_MODES6["AUTO"] = 0] = "AUTO";
    GC_MODES6[GC_MODES6["MANUAL"] = 1] = "MANUAL";
  })(GC_MODES3 || (GC_MODES3 = {}));
  var PRECISION3;
  (function(PRECISION6) {
    PRECISION6["LOW"] = "lowp";
    PRECISION6["MEDIUM"] = "mediump";
    PRECISION6["HIGH"] = "highp";
  })(PRECISION3 || (PRECISION3 = {}));
  var MASK_TYPES3;
  (function(MASK_TYPES6) {
    MASK_TYPES6[MASK_TYPES6["NONE"] = 0] = "NONE";
    MASK_TYPES6[MASK_TYPES6["SCISSOR"] = 1] = "SCISSOR";
    MASK_TYPES6[MASK_TYPES6["STENCIL"] = 2] = "STENCIL";
    MASK_TYPES6[MASK_TYPES6["SPRITE"] = 3] = "SPRITE";
  })(MASK_TYPES3 || (MASK_TYPES3 = {}));
  var MSAA_QUALITY3;
  (function(MSAA_QUALITY6) {
    MSAA_QUALITY6[MSAA_QUALITY6["NONE"] = 0] = "NONE";
    MSAA_QUALITY6[MSAA_QUALITY6["LOW"] = 2] = "LOW";
    MSAA_QUALITY6[MSAA_QUALITY6["MEDIUM"] = 4] = "MEDIUM";
    MSAA_QUALITY6[MSAA_QUALITY6["HIGH"] = 8] = "HIGH";
  })(MSAA_QUALITY3 || (MSAA_QUALITY3 = {}));
  var BUFFER_TYPE3;
  (function(BUFFER_TYPE6) {
    BUFFER_TYPE6[BUFFER_TYPE6["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
    BUFFER_TYPE6[BUFFER_TYPE6["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
    BUFFER_TYPE6[BUFFER_TYPE6["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
  })(BUFFER_TYPE3 || (BUFFER_TYPE3 = {}));
  function sortChildren(a, b) {
    if (a.zIndex === b.zIndex) {
      return a._lastSortedIndex - b._lastSortedIndex;
    }
    return a.zIndex - b.zIndex;
  }
  var Container = (
    /** @class */
    function(_super) {
      __extends(Container3, _super);
      function Container3() {
        var _this = _super.call(this) || this;
        _this.children = [];
        _this.sortableChildren = settings.SORTABLE_CHILDREN;
        _this.sortDirty = false;
        return _this;
      }
      Container3.prototype.onChildrenChange = function(_length) {
      };
      Container3.prototype.addChild = function() {
        var arguments$1 = arguments;
        var children = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          children[_i] = arguments$1[_i];
        }
        if (children.length > 1) {
          for (var i = 0; i < children.length; i++) {
            this.addChild(children[i]);
          }
        } else {
          var child = children[0];
          if (child.parent) {
            child.parent.removeChild(child);
          }
          child.parent = this;
          this.sortDirty = true;
          child.transform._parentID = -1;
          this.children.push(child);
          this._boundsID++;
          this.onChildrenChange(this.children.length - 1);
          this.emit("childAdded", child, this, this.children.length - 1);
          child.emit("added", this);
        }
        return children[0];
      };
      Container3.prototype.addChildAt = function(child, index) {
        if (index < 0 || index > this.children.length) {
          throw new Error(child + "addChildAt: The index " + index + " supplied is out of bounds " + this.children.length);
        }
        if (child.parent) {
          child.parent.removeChild(child);
        }
        child.parent = this;
        this.sortDirty = true;
        child.transform._parentID = -1;
        this.children.splice(index, 0, child);
        this._boundsID++;
        this.onChildrenChange(index);
        child.emit("added", this);
        this.emit("childAdded", child, this, index);
        return child;
      };
      Container3.prototype.swapChildren = function(child, child2) {
        if (child === child2) {
          return;
        }
        var index1 = this.getChildIndex(child);
        var index2 = this.getChildIndex(child2);
        this.children[index1] = child2;
        this.children[index2] = child;
        this.onChildrenChange(index1 < index2 ? index1 : index2);
      };
      Container3.prototype.getChildIndex = function(child) {
        var index = this.children.indexOf(child);
        if (index === -1) {
          throw new Error("The supplied DisplayObject must be a child of the caller");
        }
        return index;
      };
      Container3.prototype.setChildIndex = function(child, index) {
        if (index < 0 || index >= this.children.length) {
          throw new Error("The index " + index + " supplied is out of bounds " + this.children.length);
        }
        var currentIndex = this.getChildIndex(child);
        removeItems(this.children, currentIndex, 1);
        this.children.splice(index, 0, child);
        this.onChildrenChange(index);
      };
      Container3.prototype.getChildAt = function(index) {
        if (index < 0 || index >= this.children.length) {
          throw new Error("getChildAt: Index (" + index + ") does not exist.");
        }
        return this.children[index];
      };
      Container3.prototype.removeChild = function() {
        var arguments$1 = arguments;
        var children = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          children[_i] = arguments$1[_i];
        }
        if (children.length > 1) {
          for (var i = 0; i < children.length; i++) {
            this.removeChild(children[i]);
          }
        } else {
          var child = children[0];
          var index = this.children.indexOf(child);
          if (index === -1) {
            return null;
          }
          child.parent = null;
          child.transform._parentID = -1;
          removeItems(this.children, index, 1);
          this._boundsID++;
          this.onChildrenChange(index);
          child.emit("removed", this);
          this.emit("childRemoved", child, this, index);
        }
        return children[0];
      };
      Container3.prototype.removeChildAt = function(index) {
        var child = this.getChildAt(index);
        child.parent = null;
        child.transform._parentID = -1;
        removeItems(this.children, index, 1);
        this._boundsID++;
        this.onChildrenChange(index);
        child.emit("removed", this);
        this.emit("childRemoved", child, this, index);
        return child;
      };
      Container3.prototype.removeChildren = function(beginIndex, endIndex) {
        if (beginIndex === void 0) {
          beginIndex = 0;
        }
        if (endIndex === void 0) {
          endIndex = this.children.length;
        }
        var begin = beginIndex;
        var end = endIndex;
        var range = end - begin;
        var removed;
        if (range > 0 && range <= end) {
          removed = this.children.splice(begin, range);
          for (var i = 0; i < removed.length; ++i) {
            removed[i].parent = null;
            if (removed[i].transform) {
              removed[i].transform._parentID = -1;
            }
          }
          this._boundsID++;
          this.onChildrenChange(beginIndex);
          for (var i = 0; i < removed.length; ++i) {
            removed[i].emit("removed", this);
            this.emit("childRemoved", removed[i], this, i);
          }
          return removed;
        } else if (range === 0 && this.children.length === 0) {
          return [];
        }
        throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
      };
      Container3.prototype.sortChildren = function() {
        var sortRequired = false;
        for (var i = 0, j = this.children.length; i < j; ++i) {
          var child = this.children[i];
          child._lastSortedIndex = i;
          if (!sortRequired && child.zIndex !== 0) {
            sortRequired = true;
          }
        }
        if (sortRequired && this.children.length > 1) {
          this.children.sort(sortChildren);
        }
        this.sortDirty = false;
      };
      Container3.prototype.updateTransform = function() {
        if (this.sortableChildren && this.sortDirty) {
          this.sortChildren();
        }
        this._boundsID++;
        this.transform.updateTransform(this.parent.transform);
        this.worldAlpha = this.alpha * this.parent.worldAlpha;
        for (var i = 0, j = this.children.length; i < j; ++i) {
          var child = this.children[i];
          if (child.visible) {
            child.updateTransform();
          }
        }
      };
      Container3.prototype.calculateBounds = function() {
        this._bounds.clear();
        this._calculateBounds();
        for (var i = 0; i < this.children.length; i++) {
          var child = this.children[i];
          if (!child.visible || !child.renderable) {
            continue;
          }
          child.calculateBounds();
          if (child._mask) {
            var maskObject = child._mask.maskObject || child._mask;
            maskObject.calculateBounds();
            this._bounds.addBoundsMask(child._bounds, maskObject._bounds);
          } else if (child.filterArea) {
            this._bounds.addBoundsArea(child._bounds, child.filterArea);
          } else {
            this._bounds.addBounds(child._bounds);
          }
        }
        this._bounds.updateID = this._boundsID;
      };
      Container3.prototype.getLocalBounds = function(rect, skipChildrenUpdate) {
        if (skipChildrenUpdate === void 0) {
          skipChildrenUpdate = false;
        }
        var result = _super.prototype.getLocalBounds.call(this, rect);
        if (!skipChildrenUpdate) {
          for (var i = 0, j = this.children.length; i < j; ++i) {
            var child = this.children[i];
            if (child.visible) {
              child.updateTransform();
            }
          }
        }
        return result;
      };
      Container3.prototype._calculateBounds = function() {
      };
      Container3.prototype._renderWithCulling = function(renderer) {
        var sourceFrame = renderer.renderTexture.sourceFrame;
        if (!(sourceFrame.width > 0 && sourceFrame.height > 0)) {
          return;
        }
        var bounds;
        var transform;
        if (this.cullArea) {
          bounds = this.cullArea;
          transform = this.worldTransform;
        } else if (this._render !== Container3.prototype._render) {
          bounds = this.getBounds(true);
        }
        if (bounds && sourceFrame.intersects(bounds, transform)) {
          this._render(renderer);
        } else if (this.cullArea) {
          return;
        }
        for (var i = 0, j = this.children.length; i < j; ++i) {
          var child = this.children[i];
          var childCullable = child.cullable;
          child.cullable = childCullable || !this.cullArea;
          child.render(renderer);
          child.cullable = childCullable;
        }
      };
      Container3.prototype.render = function(renderer) {
        if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
          return;
        }
        if (this._mask || this.filters && this.filters.length) {
          this.renderAdvanced(renderer);
        } else if (this.cullable) {
          this._renderWithCulling(renderer);
        } else {
          this._render(renderer);
          for (var i = 0, j = this.children.length; i < j; ++i) {
            this.children[i].render(renderer);
          }
        }
      };
      Container3.prototype.renderAdvanced = function(renderer) {
        var filters2 = this.filters;
        var mask = this._mask;
        if (filters2) {
          if (!this._enabledFilters) {
            this._enabledFilters = [];
          }
          this._enabledFilters.length = 0;
          for (var i = 0; i < filters2.length; i++) {
            if (filters2[i].enabled) {
              this._enabledFilters.push(filters2[i]);
            }
          }
        }
        var flush = filters2 && this._enabledFilters && this._enabledFilters.length || mask && (!mask.isMaskData || mask.enabled && (mask.autoDetect || mask.type !== MASK_TYPES3.NONE));
        if (flush) {
          renderer.batch.flush();
        }
        if (filters2 && this._enabledFilters && this._enabledFilters.length) {
          renderer.filter.push(this, this._enabledFilters);
        }
        if (mask) {
          renderer.mask.push(this, this._mask);
        }
        if (this.cullable) {
          this._renderWithCulling(renderer);
        } else {
          this._render(renderer);
          for (var i = 0, j = this.children.length; i < j; ++i) {
            this.children[i].render(renderer);
          }
        }
        if (flush) {
          renderer.batch.flush();
        }
        if (mask) {
          renderer.mask.pop(this);
        }
        if (filters2 && this._enabledFilters && this._enabledFilters.length) {
          renderer.filter.pop();
        }
      };
      Container3.prototype._render = function(_renderer) {
      };
      Container3.prototype.destroy = function(options) {
        _super.prototype.destroy.call(this);
        this.sortDirty = false;
        var destroyChildren = typeof options === "boolean" ? options : options && options.children;
        var oldChildren = this.removeChildren(0, this.children.length);
        if (destroyChildren) {
          for (var i = 0; i < oldChildren.length; ++i) {
            oldChildren[i].destroy(options);
          }
        }
      };
      Object.defineProperty(Container3.prototype, "width", {
        /** The width of the Container, setting this will actually modify the scale to achieve the value set. */
        get: function() {
          return this.scale.x * this.getLocalBounds().width;
        },
        set: function(value) {
          var width = this.getLocalBounds().width;
          if (width !== 0) {
            this.scale.x = value / width;
          } else {
            this.scale.x = 1;
          }
          this._width = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Container3.prototype, "height", {
        /** The height of the Container, setting this will actually modify the scale to achieve the value set. */
        get: function() {
          return this.scale.y * this.getLocalBounds().height;
        },
        set: function(value) {
          var height = this.getLocalBounds().height;
          if (height !== 0) {
            this.scale.y = value / height;
          } else {
            this.scale.y = 1;
          }
          this._height = value;
        },
        enumerable: false,
        configurable: true
      });
      return Container3;
    }(DisplayObject)
  );
  Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;

  // node_modules/@pixi/core/dist/esm/core.js
  settings.PREFER_ENV = isMobile2.any ? ENV.WEBGL : ENV.WEBGL2;
  settings.STRICT_TEXTURE_CACHE = false;
  var INSTALLED = [];
  function autoDetectResource(source, options) {
    if (!source) {
      return null;
    }
    var extension = "";
    if (typeof source === "string") {
      var result = /\.(\w{3,4})(?:$|\?|#)/i.exec(source);
      if (result) {
        extension = result[1].toLowerCase();
      }
    }
    for (var i = INSTALLED.length - 1; i >= 0; --i) {
      var ResourcePlugin = INSTALLED[i];
      if (ResourcePlugin.test && ResourcePlugin.test(source, extension)) {
        return new ResourcePlugin(source, options);
      }
    }
    throw new Error("Unrecognized source type to auto-detect Resource");
  }
  var extendStatics2 = function(d, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) {
        if (b2.hasOwnProperty(p)) {
          d2[p] = b2[p];
        }
      }
    };
    return extendStatics2(d, b);
  };
  function __extends2(d, b) {
    extendStatics2(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var __assign = function() {
    __assign = Object.assign || function __assign3(t) {
      var arguments$1 = arguments;
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments$1[i];
        for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p)) {
            t[p] = s[p];
          }
        }
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  function __rest(s, e) {
    var t = {};
    for (var p in s) {
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) {
        t[p] = s[p];
      }
    }
    if (s != null && typeof Object.getOwnPropertySymbols === "function") {
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0) {
          t[p[i]] = s[p[i]];
        }
      }
    }
    return t;
  }
  var Resource = (
    /** @class */
    function() {
      function Resource3(width, height) {
        if (width === void 0) {
          width = 0;
        }
        if (height === void 0) {
          height = 0;
        }
        this._width = width;
        this._height = height;
        this.destroyed = false;
        this.internal = false;
        this.onResize = new Runner("setRealSize");
        this.onUpdate = new Runner("update");
        this.onError = new Runner("onError");
      }
      Resource3.prototype.bind = function(baseTexture) {
        this.onResize.add(baseTexture);
        this.onUpdate.add(baseTexture);
        this.onError.add(baseTexture);
        if (this._width || this._height) {
          this.onResize.emit(this._width, this._height);
        }
      };
      Resource3.prototype.unbind = function(baseTexture) {
        this.onResize.remove(baseTexture);
        this.onUpdate.remove(baseTexture);
        this.onError.remove(baseTexture);
      };
      Resource3.prototype.resize = function(width, height) {
        if (width !== this._width || height !== this._height) {
          this._width = width;
          this._height = height;
          this.onResize.emit(width, height);
        }
      };
      Object.defineProperty(Resource3.prototype, "valid", {
        /**
         * Has been validated
         * @readonly
         */
        get: function() {
          return !!this._width && !!this._height;
        },
        enumerable: false,
        configurable: true
      });
      Resource3.prototype.update = function() {
        if (!this.destroyed) {
          this.onUpdate.emit();
        }
      };
      Resource3.prototype.load = function() {
        return Promise.resolve(this);
      };
      Object.defineProperty(Resource3.prototype, "width", {
        /**
         * The width of the resource.
         * @readonly
         */
        get: function() {
          return this._width;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Resource3.prototype, "height", {
        /**
         * The height of the resource.
         * @readonly
         */
        get: function() {
          return this._height;
        },
        enumerable: false,
        configurable: true
      });
      Resource3.prototype.style = function(_renderer, _baseTexture, _glTexture) {
        return false;
      };
      Resource3.prototype.dispose = function() {
      };
      Resource3.prototype.destroy = function() {
        if (!this.destroyed) {
          this.destroyed = true;
          this.dispose();
          this.onError.removeAll();
          this.onError = null;
          this.onResize.removeAll();
          this.onResize = null;
          this.onUpdate.removeAll();
          this.onUpdate = null;
        }
      };
      Resource3.test = function(_source, _extension) {
        return false;
      };
      return Resource3;
    }()
  );
  var BufferResource = (
    /** @class */
    function(_super) {
      __extends2(BufferResource3, _super);
      function BufferResource3(source, options) {
        var _this = this;
        var _a2 = options || {}, width = _a2.width, height = _a2.height;
        if (!width || !height) {
          throw new Error("BufferResource width or height invalid");
        }
        _this = _super.call(this, width, height) || this;
        _this.data = source;
        return _this;
      }
      BufferResource3.prototype.upload = function(renderer, baseTexture, glTexture) {
        var gl = renderer.gl;
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
        var width = baseTexture.realWidth;
        var height = baseTexture.realHeight;
        if (glTexture.width === width && glTexture.height === height) {
          gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
        } else {
          glTexture.width = width;
          glTexture.height = height;
          gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
        }
        return true;
      };
      BufferResource3.prototype.dispose = function() {
        this.data = null;
      };
      BufferResource3.test = function(source) {
        return source instanceof Float32Array || source instanceof Uint8Array || source instanceof Uint32Array;
      };
      return BufferResource3;
    }(Resource)
  );
  var defaultBufferOptions = {
    scaleMode: SCALE_MODES.NEAREST,
    format: FORMATS.RGBA,
    alphaMode: ALPHA_MODES.NPM
  };
  var BaseTexture = (
    /** @class */
    function(_super) {
      __extends2(BaseTexture3, _super);
      function BaseTexture3(resource, options) {
        if (resource === void 0) {
          resource = null;
        }
        if (options === void 0) {
          options = null;
        }
        var _this = _super.call(this) || this;
        options = options || {};
        var alphaMode = options.alphaMode, mipmap = options.mipmap, anisotropicLevel = options.anisotropicLevel, scaleMode = options.scaleMode, width = options.width, height = options.height, wrapMode = options.wrapMode, format3 = options.format, type = options.type, target = options.target, resolution = options.resolution, resourceOptions = options.resourceOptions;
        if (resource && !(resource instanceof Resource)) {
          resource = autoDetectResource(resource, resourceOptions);
          resource.internal = true;
        }
        _this.resolution = resolution || settings.RESOLUTION;
        _this.width = Math.round((width || 0) * _this.resolution) / _this.resolution;
        _this.height = Math.round((height || 0) * _this.resolution) / _this.resolution;
        _this._mipmap = mipmap !== void 0 ? mipmap : settings.MIPMAP_TEXTURES;
        _this.anisotropicLevel = anisotropicLevel !== void 0 ? anisotropicLevel : settings.ANISOTROPIC_LEVEL;
        _this._wrapMode = wrapMode || settings.WRAP_MODE;
        _this._scaleMode = scaleMode !== void 0 ? scaleMode : settings.SCALE_MODE;
        _this.format = format3 || FORMATS.RGBA;
        _this.type = type || TYPES.UNSIGNED_BYTE;
        _this.target = target || TARGETS.TEXTURE_2D;
        _this.alphaMode = alphaMode !== void 0 ? alphaMode : ALPHA_MODES.UNPACK;
        _this.uid = uid();
        _this.touched = 0;
        _this.isPowerOfTwo = false;
        _this._refreshPOT();
        _this._glTextures = {};
        _this.dirtyId = 0;
        _this.dirtyStyleId = 0;
        _this.cacheId = null;
        _this.valid = width > 0 && height > 0;
        _this.textureCacheIds = [];
        _this.destroyed = false;
        _this.resource = null;
        _this._batchEnabled = 0;
        _this._batchLocation = 0;
        _this.parentTextureArray = null;
        _this.setResource(resource);
        return _this;
      }
      Object.defineProperty(BaseTexture3.prototype, "realWidth", {
        /**
         * Pixel width of the source of this texture
         * @readonly
         */
        get: function() {
          return Math.round(this.width * this.resolution);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture3.prototype, "realHeight", {
        /**
         * Pixel height of the source of this texture
         * @readonly
         */
        get: function() {
          return Math.round(this.height * this.resolution);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture3.prototype, "mipmap", {
        /**
         * Mipmap mode of the texture, affects downscaled images
         * @default PIXI.settings.MIPMAP_TEXTURES
         */
        get: function() {
          return this._mipmap;
        },
        set: function(value) {
          if (this._mipmap !== value) {
            this._mipmap = value;
            this.dirtyStyleId++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture3.prototype, "scaleMode", {
        /**
         * The scale mode to apply when scaling this texture
         * @default PIXI.settings.SCALE_MODE
         */
        get: function() {
          return this._scaleMode;
        },
        set: function(value) {
          if (this._scaleMode !== value) {
            this._scaleMode = value;
            this.dirtyStyleId++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture3.prototype, "wrapMode", {
        /**
         * How the texture wraps
         * @default PIXI.settings.WRAP_MODE
         */
        get: function() {
          return this._wrapMode;
        },
        set: function(value) {
          if (this._wrapMode !== value) {
            this._wrapMode = value;
            this.dirtyStyleId++;
          }
        },
        enumerable: false,
        configurable: true
      });
      BaseTexture3.prototype.setStyle = function(scaleMode, mipmap) {
        var dirty;
        if (scaleMode !== void 0 && scaleMode !== this.scaleMode) {
          this.scaleMode = scaleMode;
          dirty = true;
        }
        if (mipmap !== void 0 && mipmap !== this.mipmap) {
          this.mipmap = mipmap;
          dirty = true;
        }
        if (dirty) {
          this.dirtyStyleId++;
        }
        return this;
      };
      BaseTexture3.prototype.setSize = function(desiredWidth, desiredHeight, resolution) {
        resolution = resolution || this.resolution;
        return this.setRealSize(desiredWidth * resolution, desiredHeight * resolution, resolution);
      };
      BaseTexture3.prototype.setRealSize = function(realWidth, realHeight, resolution) {
        this.resolution = resolution || this.resolution;
        this.width = Math.round(realWidth) / this.resolution;
        this.height = Math.round(realHeight) / this.resolution;
        this._refreshPOT();
        this.update();
        return this;
      };
      BaseTexture3.prototype._refreshPOT = function() {
        this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);
      };
      BaseTexture3.prototype.setResolution = function(resolution) {
        var oldResolution = this.resolution;
        if (oldResolution === resolution) {
          return this;
        }
        this.resolution = resolution;
        if (this.valid) {
          this.width = Math.round(this.width * oldResolution) / resolution;
          this.height = Math.round(this.height * oldResolution) / resolution;
          this.emit("update", this);
        }
        this._refreshPOT();
        return this;
      };
      BaseTexture3.prototype.setResource = function(resource) {
        if (this.resource === resource) {
          return this;
        }
        if (this.resource) {
          throw new Error("Resource can be set only once");
        }
        resource.bind(this);
        this.resource = resource;
        return this;
      };
      BaseTexture3.prototype.update = function() {
        if (!this.valid) {
          if (this.width > 0 && this.height > 0) {
            this.valid = true;
            this.emit("loaded", this);
            this.emit("update", this);
          }
        } else {
          this.dirtyId++;
          this.dirtyStyleId++;
          this.emit("update", this);
        }
      };
      BaseTexture3.prototype.onError = function(event) {
        this.emit("error", this, event);
      };
      BaseTexture3.prototype.destroy = function() {
        if (this.resource) {
          this.resource.unbind(this);
          if (this.resource.internal) {
            this.resource.destroy();
          }
          this.resource = null;
        }
        if (this.cacheId) {
          delete BaseTextureCache[this.cacheId];
          delete TextureCache[this.cacheId];
          this.cacheId = null;
        }
        this.dispose();
        BaseTexture3.removeFromCache(this);
        this.textureCacheIds = null;
        this.destroyed = true;
      };
      BaseTexture3.prototype.dispose = function() {
        this.emit("dispose", this);
      };
      BaseTexture3.prototype.castToBaseTexture = function() {
        return this;
      };
      BaseTexture3.from = function(source, options, strict) {
        if (strict === void 0) {
          strict = settings.STRICT_TEXTURE_CACHE;
        }
        var isFrame = typeof source === "string";
        var cacheId = null;
        if (isFrame) {
          cacheId = source;
        } else {
          if (!source._pixiId) {
            var prefix = options && options.pixiIdPrefix || "pixiid";
            source._pixiId = prefix + "_" + uid();
          }
          cacheId = source._pixiId;
        }
        var baseTexture = BaseTextureCache[cacheId];
        if (isFrame && strict && !baseTexture) {
          throw new Error('The cacheId "' + cacheId + '" does not exist in BaseTextureCache.');
        }
        if (!baseTexture) {
          baseTexture = new BaseTexture3(source, options);
          baseTexture.cacheId = cacheId;
          BaseTexture3.addToCache(baseTexture, cacheId);
        }
        return baseTexture;
      };
      BaseTexture3.fromBuffer = function(buffer, width, height, options) {
        buffer = buffer || new Float32Array(width * height * 4);
        var resource = new BufferResource(buffer, { width, height });
        var type = buffer instanceof Float32Array ? TYPES.FLOAT : TYPES.UNSIGNED_BYTE;
        return new BaseTexture3(resource, Object.assign(defaultBufferOptions, options || { width, height, type }));
      };
      BaseTexture3.addToCache = function(baseTexture, id) {
        if (id) {
          if (baseTexture.textureCacheIds.indexOf(id) === -1) {
            baseTexture.textureCacheIds.push(id);
          }
          if (BaseTextureCache[id]) {
            console.warn("BaseTexture added to the cache with an id [" + id + "] that already had an entry");
          }
          BaseTextureCache[id] = baseTexture;
        }
      };
      BaseTexture3.removeFromCache = function(baseTexture) {
        if (typeof baseTexture === "string") {
          var baseTextureFromCache = BaseTextureCache[baseTexture];
          if (baseTextureFromCache) {
            var index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
            if (index > -1) {
              baseTextureFromCache.textureCacheIds.splice(index, 1);
            }
            delete BaseTextureCache[baseTexture];
            return baseTextureFromCache;
          }
        } else if (baseTexture && baseTexture.textureCacheIds) {
          for (var i = 0; i < baseTexture.textureCacheIds.length; ++i) {
            delete BaseTextureCache[baseTexture.textureCacheIds[i]];
          }
          baseTexture.textureCacheIds.length = 0;
          return baseTexture;
        }
        return null;
      };
      BaseTexture3._globalBatch = 0;
      return BaseTexture3;
    }(import_eventemitter3.default)
  );
  var AbstractMultiResource = (
    /** @class */
    function(_super) {
      __extends2(AbstractMultiResource3, _super);
      function AbstractMultiResource3(length, options) {
        var _this = this;
        var _a2 = options || {}, width = _a2.width, height = _a2.height;
        _this = _super.call(this, width, height) || this;
        _this.items = [];
        _this.itemDirtyIds = [];
        for (var i = 0; i < length; i++) {
          var partTexture = new BaseTexture();
          _this.items.push(partTexture);
          _this.itemDirtyIds.push(-2);
        }
        _this.length = length;
        _this._load = null;
        _this.baseTexture = null;
        return _this;
      }
      AbstractMultiResource3.prototype.initFromArray = function(resources3, options) {
        for (var i = 0; i < this.length; i++) {
          if (!resources3[i]) {
            continue;
          }
          if (resources3[i].castToBaseTexture) {
            this.addBaseTextureAt(resources3[i].castToBaseTexture(), i);
          } else if (resources3[i] instanceof Resource) {
            this.addResourceAt(resources3[i], i);
          } else {
            this.addResourceAt(autoDetectResource(resources3[i], options), i);
          }
        }
      };
      AbstractMultiResource3.prototype.dispose = function() {
        for (var i = 0, len = this.length; i < len; i++) {
          this.items[i].destroy();
        }
        this.items = null;
        this.itemDirtyIds = null;
        this._load = null;
      };
      AbstractMultiResource3.prototype.addResourceAt = function(resource, index) {
        if (!this.items[index]) {
          throw new Error("Index " + index + " is out of bounds");
        }
        if (resource.valid && !this.valid) {
          this.resize(resource.width, resource.height);
        }
        this.items[index].setResource(resource);
        return this;
      };
      AbstractMultiResource3.prototype.bind = function(baseTexture) {
        if (this.baseTexture !== null) {
          throw new Error("Only one base texture per TextureArray is allowed");
        }
        _super.prototype.bind.call(this, baseTexture);
        for (var i = 0; i < this.length; i++) {
          this.items[i].parentTextureArray = baseTexture;
          this.items[i].on("update", baseTexture.update, baseTexture);
        }
      };
      AbstractMultiResource3.prototype.unbind = function(baseTexture) {
        _super.prototype.unbind.call(this, baseTexture);
        for (var i = 0; i < this.length; i++) {
          this.items[i].parentTextureArray = null;
          this.items[i].off("update", baseTexture.update, baseTexture);
        }
      };
      AbstractMultiResource3.prototype.load = function() {
        var _this = this;
        if (this._load) {
          return this._load;
        }
        var resources3 = this.items.map(function(item) {
          return item.resource;
        }).filter(function(item) {
          return item;
        });
        var promises = resources3.map(function(item) {
          return item.load();
        });
        this._load = Promise.all(promises).then(function() {
          var _a2 = _this.items[0], realWidth = _a2.realWidth, realHeight = _a2.realHeight;
          _this.resize(realWidth, realHeight);
          return Promise.resolve(_this);
        });
        return this._load;
      };
      return AbstractMultiResource3;
    }(Resource)
  );
  var ArrayResource = (
    /** @class */
    function(_super) {
      __extends2(ArrayResource3, _super);
      function ArrayResource3(source, options) {
        var _this = this;
        var _a2 = options || {}, width = _a2.width, height = _a2.height;
        var urls;
        var length;
        if (Array.isArray(source)) {
          urls = source;
          length = source.length;
        } else {
          length = source;
        }
        _this = _super.call(this, length, { width, height }) || this;
        if (urls) {
          _this.initFromArray(urls, options);
        }
        return _this;
      }
      ArrayResource3.prototype.addBaseTextureAt = function(baseTexture, index) {
        if (baseTexture.resource) {
          this.addResourceAt(baseTexture.resource, index);
        } else {
          throw new Error("ArrayResource does not support RenderTexture");
        }
        return this;
      };
      ArrayResource3.prototype.bind = function(baseTexture) {
        _super.prototype.bind.call(this, baseTexture);
        baseTexture.target = TARGETS.TEXTURE_2D_ARRAY;
      };
      ArrayResource3.prototype.upload = function(renderer, texture, glTexture) {
        var _a2 = this, length = _a2.length, itemDirtyIds = _a2.itemDirtyIds, items = _a2.items;
        var gl = renderer.gl;
        if (glTexture.dirtyId < 0) {
          gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, glTexture.internalFormat, this._width, this._height, length, 0, texture.format, glTexture.type, null);
        }
        for (var i = 0; i < length; i++) {
          var item = items[i];
          if (itemDirtyIds[i] < item.dirtyId) {
            itemDirtyIds[i] = item.dirtyId;
            if (item.valid) {
              gl.texSubImage3D(
                gl.TEXTURE_2D_ARRAY,
                0,
                0,
                // xoffset
                0,
                // yoffset
                i,
                // zoffset
                item.resource.width,
                item.resource.height,
                1,
                texture.format,
                glTexture.type,
                item.resource.source
              );
            }
          }
        }
        return true;
      };
      return ArrayResource3;
    }(AbstractMultiResource)
  );
  var BaseImageResource = (
    /** @class */
    function(_super) {
      __extends2(BaseImageResource3, _super);
      function BaseImageResource3(source) {
        var _this = this;
        var sourceAny = source;
        var width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.width;
        var height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.height;
        _this = _super.call(this, width, height) || this;
        _this.source = source;
        _this.noSubImage = false;
        return _this;
      }
      BaseImageResource3.crossOrigin = function(element, url3, crossorigin) {
        if (crossorigin === void 0 && url3.indexOf("data:") !== 0) {
          element.crossOrigin = determineCrossOrigin(url3);
        } else if (crossorigin !== false) {
          element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
        }
      };
      BaseImageResource3.prototype.upload = function(renderer, baseTexture, glTexture, source) {
        var gl = renderer.gl;
        var width = baseTexture.realWidth;
        var height = baseTexture.realHeight;
        source = source || this.source;
        if (source instanceof HTMLImageElement) {
          if (!source.complete || source.naturalWidth === 0) {
            return false;
          }
        } else if (source instanceof HTMLVideoElement) {
          if (source.readyState <= 1) {
            return false;
          }
        }
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
        if (!this.noSubImage && baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height) {
          gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, glTexture.type, source);
        } else {
          glTexture.width = width;
          glTexture.height = height;
          gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.format, glTexture.type, source);
        }
        return true;
      };
      BaseImageResource3.prototype.update = function() {
        if (this.destroyed) {
          return;
        }
        var source = this.source;
        var width = source.naturalWidth || source.videoWidth || source.width;
        var height = source.naturalHeight || source.videoHeight || source.height;
        this.resize(width, height);
        _super.prototype.update.call(this);
      };
      BaseImageResource3.prototype.dispose = function() {
        this.source = null;
      };
      return BaseImageResource3;
    }(Resource)
  );
  var CanvasResource = (
    /** @class */
    function(_super) {
      __extends2(CanvasResource3, _super);
      function CanvasResource3(source) {
        return _super.call(this, source) || this;
      }
      CanvasResource3.test = function(source) {
        var OffscreenCanvas2 = globalThis.OffscreenCanvas;
        if (OffscreenCanvas2 && source instanceof OffscreenCanvas2) {
          return true;
        }
        return globalThis.HTMLCanvasElement && source instanceof HTMLCanvasElement;
      };
      return CanvasResource3;
    }(BaseImageResource)
  );
  var CubeResource = (
    /** @class */
    function(_super) {
      __extends2(CubeResource3, _super);
      function CubeResource3(source, options) {
        var _this = this;
        var _a2 = options || {}, width = _a2.width, height = _a2.height, autoLoad = _a2.autoLoad, linkBaseTexture = _a2.linkBaseTexture;
        if (source && source.length !== CubeResource3.SIDES) {
          throw new Error("Invalid length. Got " + source.length + ", expected 6");
        }
        _this = _super.call(this, 6, { width, height }) || this;
        for (var i = 0; i < CubeResource3.SIDES; i++) {
          _this.items[i].target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i;
        }
        _this.linkBaseTexture = linkBaseTexture !== false;
        if (source) {
          _this.initFromArray(source, options);
        }
        if (autoLoad !== false) {
          _this.load();
        }
        return _this;
      }
      CubeResource3.prototype.bind = function(baseTexture) {
        _super.prototype.bind.call(this, baseTexture);
        baseTexture.target = TARGETS.TEXTURE_CUBE_MAP;
      };
      CubeResource3.prototype.addBaseTextureAt = function(baseTexture, index, linkBaseTexture) {
        if (!this.items[index]) {
          throw new Error("Index " + index + " is out of bounds");
        }
        if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0) {
          if (baseTexture.resource) {
            this.addResourceAt(baseTexture.resource, index);
          } else {
            throw new Error("CubeResource does not support copying of renderTexture.");
          }
        } else {
          baseTexture.target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index;
          baseTexture.parentTextureArray = this.baseTexture;
          this.items[index] = baseTexture;
        }
        if (baseTexture.valid && !this.valid) {
          this.resize(baseTexture.realWidth, baseTexture.realHeight);
        }
        this.items[index] = baseTexture;
        return this;
      };
      CubeResource3.prototype.upload = function(renderer, _baseTexture, glTexture) {
        var dirty = this.itemDirtyIds;
        for (var i = 0; i < CubeResource3.SIDES; i++) {
          var side = this.items[i];
          if (dirty[i] < side.dirtyId) {
            if (side.valid && side.resource) {
              side.resource.upload(renderer, side, glTexture);
              dirty[i] = side.dirtyId;
            } else if (dirty[i] < -1) {
              renderer.gl.texImage2D(side.target, 0, glTexture.internalFormat, _baseTexture.realWidth, _baseTexture.realHeight, 0, _baseTexture.format, glTexture.type, null);
              dirty[i] = -1;
            }
          }
        }
        return true;
      };
      CubeResource3.test = function(source) {
        return Array.isArray(source) && source.length === CubeResource3.SIDES;
      };
      CubeResource3.SIDES = 6;
      return CubeResource3;
    }(AbstractMultiResource)
  );
  var ImageResource = (
    /** @class */
    function(_super) {
      __extends2(ImageResource3, _super);
      function ImageResource3(source, options) {
        var _this = this;
        options = options || {};
        if (!(source instanceof HTMLImageElement)) {
          var imageElement = new Image();
          BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);
          imageElement.src = source;
          source = imageElement;
        }
        _this = _super.call(this, source) || this;
        if (!source.complete && !!_this._width && !!_this._height) {
          _this._width = 0;
          _this._height = 0;
        }
        _this.url = source.src;
        _this._process = null;
        _this.preserveBitmap = false;
        _this.createBitmap = (options.createBitmap !== void 0 ? options.createBitmap : settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap;
        _this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;
        _this.bitmap = null;
        _this._load = null;
        if (options.autoLoad !== false) {
          _this.load();
        }
        return _this;
      }
      ImageResource3.prototype.load = function(createBitmap) {
        var _this = this;
        if (this._load) {
          return this._load;
        }
        if (createBitmap !== void 0) {
          this.createBitmap = createBitmap;
        }
        this._load = new Promise(function(resolve3, reject) {
          var source = _this.source;
          _this.url = source.src;
          var completed = function() {
            if (_this.destroyed) {
              return;
            }
            source.onload = null;
            source.onerror = null;
            _this.resize(source.width, source.height);
            _this._load = null;
            if (_this.createBitmap) {
              resolve3(_this.process());
            } else {
              resolve3(_this);
            }
          };
          if (source.complete && source.src) {
            completed();
          } else {
            source.onload = completed;
            source.onerror = function(event) {
              reject(event);
              _this.onError.emit(event);
            };
          }
        });
        return this._load;
      };
      ImageResource3.prototype.process = function() {
        var _this = this;
        var source = this.source;
        if (this._process !== null) {
          return this._process;
        }
        if (this.bitmap !== null || !globalThis.createImageBitmap) {
          return Promise.resolve(this);
        }
        var createImageBitmap = globalThis.createImageBitmap;
        var cors = !source.crossOrigin || source.crossOrigin === "anonymous";
        this._process = fetch(source.src, {
          mode: cors ? "cors" : "no-cors"
        }).then(function(r) {
          return r.blob();
        }).then(function(blob) {
          return createImageBitmap(blob, 0, 0, source.width, source.height, {
            premultiplyAlpha: _this.alphaMode === ALPHA_MODES.UNPACK ? "premultiply" : "none"
          });
        }).then(function(bitmap) {
          if (_this.destroyed) {
            return Promise.reject();
          }
          _this.bitmap = bitmap;
          _this.update();
          _this._process = null;
          return Promise.resolve(_this);
        });
        return this._process;
      };
      ImageResource3.prototype.upload = function(renderer, baseTexture, glTexture) {
        if (typeof this.alphaMode === "number") {
          baseTexture.alphaMode = this.alphaMode;
        }
        if (!this.createBitmap) {
          return _super.prototype.upload.call(this, renderer, baseTexture, glTexture);
        }
        if (!this.bitmap) {
          this.process();
          if (!this.bitmap) {
            return false;
          }
        }
        _super.prototype.upload.call(this, renderer, baseTexture, glTexture, this.bitmap);
        if (!this.preserveBitmap) {
          var flag = true;
          var glTextures = baseTexture._glTextures;
          for (var key in glTextures) {
            var otherTex = glTextures[key];
            if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {
              flag = false;
              break;
            }
          }
          if (flag) {
            if (this.bitmap.close) {
              this.bitmap.close();
            }
            this.bitmap = null;
          }
        }
        return true;
      };
      ImageResource3.prototype.dispose = function() {
        this.source.onload = null;
        this.source.onerror = null;
        _super.prototype.dispose.call(this);
        if (this.bitmap) {
          this.bitmap.close();
          this.bitmap = null;
        }
        this._process = null;
        this._load = null;
      };
      ImageResource3.test = function(source) {
        return typeof source === "string" || source instanceof HTMLImageElement;
      };
      return ImageResource3;
    }(BaseImageResource)
  );
  var SVGResource = (
    /** @class */
    function(_super) {
      __extends2(SVGResource3, _super);
      function SVGResource3(sourceBase64, options) {
        var _this = this;
        options = options || {};
        _this = _super.call(this, document.createElement("canvas")) || this;
        _this._width = 0;
        _this._height = 0;
        _this.svg = sourceBase64;
        _this.scale = options.scale || 1;
        _this._overrideWidth = options.width;
        _this._overrideHeight = options.height;
        _this._resolve = null;
        _this._crossorigin = options.crossorigin;
        _this._load = null;
        if (options.autoLoad !== false) {
          _this.load();
        }
        return _this;
      }
      SVGResource3.prototype.load = function() {
        var _this = this;
        if (this._load) {
          return this._load;
        }
        this._load = new Promise(function(resolve3) {
          _this._resolve = function() {
            _this.resize(_this.source.width, _this.source.height);
            resolve3(_this);
          };
          if (SVGResource3.SVG_XML.test(_this.svg.trim())) {
            if (!btoa) {
              throw new Error("Your browser doesn't support base64 conversions.");
            }
            _this.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(_this.svg)));
          }
          _this._loadSvg();
        });
        return this._load;
      };
      SVGResource3.prototype._loadSvg = function() {
        var _this = this;
        var tempImage = new Image();
        BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin);
        tempImage.src = this.svg;
        tempImage.onerror = function(event) {
          if (!_this._resolve) {
            return;
          }
          tempImage.onerror = null;
          _this.onError.emit(event);
        };
        tempImage.onload = function() {
          if (!_this._resolve) {
            return;
          }
          var svgWidth = tempImage.width;
          var svgHeight = tempImage.height;
          if (!svgWidth || !svgHeight) {
            throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
          }
          var width = svgWidth * _this.scale;
          var height = svgHeight * _this.scale;
          if (_this._overrideWidth || _this._overrideHeight) {
            width = _this._overrideWidth || _this._overrideHeight / svgHeight * svgWidth;
            height = _this._overrideHeight || _this._overrideWidth / svgWidth * svgHeight;
          }
          width = Math.round(width);
          height = Math.round(height);
          var canvas = _this.source;
          canvas.width = width;
          canvas.height = height;
          canvas._pixiId = "canvas_" + uid();
          canvas.getContext("2d").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);
          _this._resolve();
          _this._resolve = null;
        };
      };
      SVGResource3.getSize = function(svgString) {
        var sizeMatch = SVGResource3.SVG_SIZE.exec(svgString);
        var size = {};
        if (sizeMatch) {
          size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
          size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
        }
        return size;
      };
      SVGResource3.prototype.dispose = function() {
        _super.prototype.dispose.call(this);
        this._resolve = null;
        this._crossorigin = null;
      };
      SVGResource3.test = function(source, extension) {
        return extension === "svg" || typeof source === "string" && /^data:image\/svg\+xml(;(charset=utf8|utf8))?;base64/.test(source) || typeof source === "string" && SVGResource3.SVG_XML.test(source);
      };
      SVGResource3.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m;
      SVGResource3.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
      return SVGResource3;
    }(BaseImageResource)
  );
  var VideoResource = (
    /** @class */
    function(_super) {
      __extends2(VideoResource3, _super);
      function VideoResource3(source, options) {
        var _this = this;
        options = options || {};
        if (!(source instanceof HTMLVideoElement)) {
          var videoElement = document.createElement("video");
          videoElement.setAttribute("preload", "auto");
          videoElement.setAttribute("webkit-playsinline", "");
          videoElement.setAttribute("playsinline", "");
          if (typeof source === "string") {
            source = [source];
          }
          var firstSrc = source[0].src || source[0];
          BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);
          for (var i = 0; i < source.length; ++i) {
            var sourceElement = document.createElement("source");
            var _a2 = source[i], src = _a2.src, mime = _a2.mime;
            src = src || source[i];
            var baseSrc = src.split("?").shift().toLowerCase();
            var ext = baseSrc.slice(baseSrc.lastIndexOf(".") + 1);
            mime = mime || VideoResource3.MIME_TYPES[ext] || "video/" + ext;
            sourceElement.src = src;
            sourceElement.type = mime;
            videoElement.appendChild(sourceElement);
          }
          source = videoElement;
        }
        _this = _super.call(this, source) || this;
        _this.noSubImage = true;
        _this._autoUpdate = true;
        _this._isConnectedToTicker = false;
        _this._updateFPS = options.updateFPS || 0;
        _this._msToNextUpdate = 0;
        _this.autoPlay = options.autoPlay !== false;
        _this._load = null;
        _this._resolve = null;
        _this._onCanPlay = _this._onCanPlay.bind(_this);
        _this._onError = _this._onError.bind(_this);
        if (options.autoLoad !== false) {
          _this.load();
        }
        return _this;
      }
      VideoResource3.prototype.update = function(_deltaTime) {
        if (!this.destroyed) {
          var elapsedMS = Ticker.shared.elapsedMS * this.source.playbackRate;
          this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
          if (!this._updateFPS || this._msToNextUpdate <= 0) {
            _super.prototype.update.call(this);
            this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
          }
        }
      };
      VideoResource3.prototype.load = function() {
        var _this = this;
        if (this._load) {
          return this._load;
        }
        var source = this.source;
        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {
          source.complete = true;
        }
        source.addEventListener("play", this._onPlayStart.bind(this));
        source.addEventListener("pause", this._onPlayStop.bind(this));
        if (!this._isSourceReady()) {
          source.addEventListener("canplay", this._onCanPlay);
          source.addEventListener("canplaythrough", this._onCanPlay);
          source.addEventListener("error", this._onError, true);
        } else {
          this._onCanPlay();
        }
        this._load = new Promise(function(resolve3) {
          if (_this.valid) {
            resolve3(_this);
          } else {
            _this._resolve = resolve3;
            source.load();
          }
        });
        return this._load;
      };
      VideoResource3.prototype._onError = function(event) {
        this.source.removeEventListener("error", this._onError, true);
        this.onError.emit(event);
      };
      VideoResource3.prototype._isSourcePlaying = function() {
        var source = this.source;
        return source.currentTime > 0 && source.paused === false && source.ended === false && source.readyState > 2;
      };
      VideoResource3.prototype._isSourceReady = function() {
        var source = this.source;
        return source.readyState === 3 || source.readyState === 4;
      };
      VideoResource3.prototype._onPlayStart = function() {
        if (!this.valid) {
          this._onCanPlay();
        }
        if (this.autoUpdate && !this._isConnectedToTicker) {
          Ticker.shared.add(this.update, this);
          this._isConnectedToTicker = true;
        }
      };
      VideoResource3.prototype._onPlayStop = function() {
        if (this._isConnectedToTicker) {
          Ticker.shared.remove(this.update, this);
          this._isConnectedToTicker = false;
        }
      };
      VideoResource3.prototype._onCanPlay = function() {
        var source = this.source;
        source.removeEventListener("canplay", this._onCanPlay);
        source.removeEventListener("canplaythrough", this._onCanPlay);
        var valid = this.valid;
        this.resize(source.videoWidth, source.videoHeight);
        if (!valid && this._resolve) {
          this._resolve(this);
          this._resolve = null;
        }
        if (this._isSourcePlaying()) {
          this._onPlayStart();
        } else if (this.autoPlay) {
          source.play();
        }
      };
      VideoResource3.prototype.dispose = function() {
        if (this._isConnectedToTicker) {
          Ticker.shared.remove(this.update, this);
          this._isConnectedToTicker = false;
        }
        var source = this.source;
        if (source) {
          source.removeEventListener("error", this._onError, true);
          source.pause();
          source.src = "";
          source.load();
        }
        _super.prototype.dispose.call(this);
      };
      Object.defineProperty(VideoResource3.prototype, "autoUpdate", {
        /** Should the base texture automatically update itself, set to true by default. */
        get: function() {
          return this._autoUpdate;
        },
        set: function(value) {
          if (value !== this._autoUpdate) {
            this._autoUpdate = value;
            if (!this._autoUpdate && this._isConnectedToTicker) {
              Ticker.shared.remove(this.update, this);
              this._isConnectedToTicker = false;
            } else if (this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying()) {
              Ticker.shared.add(this.update, this);
              this._isConnectedToTicker = true;
            }
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(VideoResource3.prototype, "updateFPS", {
        /**
         * How many times a second to update the texture from the video. Leave at 0 to update at every render.
         * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
         */
        get: function() {
          return this._updateFPS;
        },
        set: function(value) {
          if (value !== this._updateFPS) {
            this._updateFPS = value;
          }
        },
        enumerable: false,
        configurable: true
      });
      VideoResource3.test = function(source, extension) {
        return globalThis.HTMLVideoElement && source instanceof HTMLVideoElement || VideoResource3.TYPES.indexOf(extension) > -1;
      };
      VideoResource3.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"];
      VideoResource3.MIME_TYPES = {
        ogv: "video/ogg",
        mov: "video/quicktime",
        m4v: "video/mp4"
      };
      return VideoResource3;
    }(BaseImageResource)
  );
  var ImageBitmapResource = (
    /** @class */
    function(_super) {
      __extends2(ImageBitmapResource3, _super);
      function ImageBitmapResource3(source) {
        return _super.call(this, source) || this;
      }
      ImageBitmapResource3.test = function(source) {
        return !!globalThis.createImageBitmap && source instanceof ImageBitmap;
      };
      return ImageBitmapResource3;
    }(BaseImageResource)
  );
  INSTALLED.push(ImageResource, ImageBitmapResource, CanvasResource, VideoResource, SVGResource, BufferResource, CubeResource, ArrayResource);
  var _resources = {
    __proto__: null,
    Resource,
    BaseImageResource,
    INSTALLED,
    autoDetectResource,
    AbstractMultiResource,
    ArrayResource,
    BufferResource,
    CanvasResource,
    CubeResource,
    ImageResource,
    SVGResource,
    VideoResource,
    ImageBitmapResource
  };
  var DepthResource = (
    /** @class */
    function(_super) {
      __extends2(DepthResource3, _super);
      function DepthResource3() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      DepthResource3.prototype.upload = function(renderer, baseTexture, glTexture) {
        var gl = renderer.gl;
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
        var width = baseTexture.realWidth;
        var height = baseTexture.realHeight;
        if (glTexture.width === width && glTexture.height === height) {
          gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
        } else {
          glTexture.width = width;
          glTexture.height = height;
          gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
        }
        return true;
      };
      return DepthResource3;
    }(BufferResource)
  );
  var Framebuffer = (
    /** @class */
    function() {
      function Framebuffer3(width, height) {
        this.width = Math.round(width || 100);
        this.height = Math.round(height || 100);
        this.stencil = false;
        this.depth = false;
        this.dirtyId = 0;
        this.dirtyFormat = 0;
        this.dirtySize = 0;
        this.depthTexture = null;
        this.colorTextures = [];
        this.glFramebuffers = {};
        this.disposeRunner = new Runner("disposeFramebuffer");
        this.multisample = MSAA_QUALITY.NONE;
      }
      Object.defineProperty(Framebuffer3.prototype, "colorTexture", {
        /**
         * Reference to the colorTexture.
         * @readonly
         */
        get: function() {
          return this.colorTextures[0];
        },
        enumerable: false,
        configurable: true
      });
      Framebuffer3.prototype.addColorTexture = function(index, texture) {
        if (index === void 0) {
          index = 0;
        }
        this.colorTextures[index] = texture || new BaseTexture(null, {
          scaleMode: SCALE_MODES.NEAREST,
          resolution: 1,
          mipmap: MIPMAP_MODES.OFF,
          width: this.width,
          height: this.height
        });
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
      };
      Framebuffer3.prototype.addDepthTexture = function(texture) {
        this.depthTexture = texture || new BaseTexture(new DepthResource(null, { width: this.width, height: this.height }), {
          scaleMode: SCALE_MODES.NEAREST,
          resolution: 1,
          width: this.width,
          height: this.height,
          mipmap: MIPMAP_MODES.OFF,
          format: FORMATS.DEPTH_COMPONENT,
          type: TYPES.UNSIGNED_SHORT
        });
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
      };
      Framebuffer3.prototype.enableDepth = function() {
        this.depth = true;
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
      };
      Framebuffer3.prototype.enableStencil = function() {
        this.stencil = true;
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
      };
      Framebuffer3.prototype.resize = function(width, height) {
        width = Math.round(width);
        height = Math.round(height);
        if (width === this.width && height === this.height) {
          return;
        }
        this.width = width;
        this.height = height;
        this.dirtyId++;
        this.dirtySize++;
        for (var i = 0; i < this.colorTextures.length; i++) {
          var texture = this.colorTextures[i];
          var resolution = texture.resolution;
          texture.setSize(width / resolution, height / resolution);
        }
        if (this.depthTexture) {
          var resolution = this.depthTexture.resolution;
          this.depthTexture.setSize(width / resolution, height / resolution);
        }
      };
      Framebuffer3.prototype.dispose = function() {
        this.disposeRunner.emit(this, false);
      };
      Framebuffer3.prototype.destroyDepthTexture = function() {
        if (this.depthTexture) {
          this.depthTexture.destroy();
          this.depthTexture = null;
          ++this.dirtyId;
          ++this.dirtyFormat;
        }
      };
      return Framebuffer3;
    }()
  );
  var BaseRenderTexture = (
    /** @class */
    function(_super) {
      __extends2(BaseRenderTexture3, _super);
      function BaseRenderTexture3(options) {
        if (options === void 0) {
          options = {};
        }
        var _this = this;
        if (typeof options === "number") {
          var width = arguments[0];
          var height = arguments[1];
          var scaleMode = arguments[2];
          var resolution = arguments[3];
          options = { width, height, scaleMode, resolution };
        }
        options.width = options.width || 100;
        options.height = options.height || 100;
        options.multisample = options.multisample !== void 0 ? options.multisample : MSAA_QUALITY.NONE;
        _this = _super.call(this, null, options) || this;
        _this.mipmap = MIPMAP_MODES.OFF;
        _this.valid = true;
        _this.clearColor = [0, 0, 0, 0];
        _this.framebuffer = new Framebuffer(_this.realWidth, _this.realHeight).addColorTexture(0, _this);
        _this.framebuffer.multisample = options.multisample;
        _this.maskStack = [];
        _this.filterStack = [{}];
        return _this;
      }
      BaseRenderTexture3.prototype.resize = function(desiredWidth, desiredHeight) {
        this.framebuffer.resize(desiredWidth * this.resolution, desiredHeight * this.resolution);
        this.setRealSize(this.framebuffer.width, this.framebuffer.height);
      };
      BaseRenderTexture3.prototype.dispose = function() {
        this.framebuffer.dispose();
        _super.prototype.dispose.call(this);
      };
      BaseRenderTexture3.prototype.destroy = function() {
        _super.prototype.destroy.call(this);
        this.framebuffer.destroyDepthTexture();
        this.framebuffer = null;
      };
      return BaseRenderTexture3;
    }(BaseTexture)
  );
  var TextureUvs = (
    /** @class */
    function() {
      function TextureUvs3() {
        this.x0 = 0;
        this.y0 = 0;
        this.x1 = 1;
        this.y1 = 0;
        this.x2 = 1;
        this.y2 = 1;
        this.x3 = 0;
        this.y3 = 1;
        this.uvsFloat32 = new Float32Array(8);
      }
      TextureUvs3.prototype.set = function(frame, baseFrame, rotate) {
        var tw = baseFrame.width;
        var th = baseFrame.height;
        if (rotate) {
          var w2 = frame.width / 2 / tw;
          var h2 = frame.height / 2 / th;
          var cX = frame.x / tw + w2;
          var cY = frame.y / th + h2;
          rotate = groupD8.add(rotate, groupD8.NW);
          this.x0 = cX + w2 * groupD8.uX(rotate);
          this.y0 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          this.x1 = cX + w2 * groupD8.uX(rotate);
          this.y1 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          this.x2 = cX + w2 * groupD8.uX(rotate);
          this.y2 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          this.x3 = cX + w2 * groupD8.uX(rotate);
          this.y3 = cY + h2 * groupD8.uY(rotate);
        } else {
          this.x0 = frame.x / tw;
          this.y0 = frame.y / th;
          this.x1 = (frame.x + frame.width) / tw;
          this.y1 = frame.y / th;
          this.x2 = (frame.x + frame.width) / tw;
          this.y2 = (frame.y + frame.height) / th;
          this.x3 = frame.x / tw;
          this.y3 = (frame.y + frame.height) / th;
        }
        this.uvsFloat32[0] = this.x0;
        this.uvsFloat32[1] = this.y0;
        this.uvsFloat32[2] = this.x1;
        this.uvsFloat32[3] = this.y1;
        this.uvsFloat32[4] = this.x2;
        this.uvsFloat32[5] = this.y2;
        this.uvsFloat32[6] = this.x3;
        this.uvsFloat32[7] = this.y3;
      };
      TextureUvs3.prototype.toString = function() {
        return "[@pixi/core:TextureUvs " + ("x0=" + this.x0 + " y0=" + this.y0 + " ") + ("x1=" + this.x1 + " y1=" + this.y1 + " x2=" + this.x2 + " ") + ("y2=" + this.y2 + " x3=" + this.x3 + " y3=" + this.y3) + "]";
      };
      return TextureUvs3;
    }()
  );
  var DEFAULT_UVS = new TextureUvs();
  function removeAllHandlers(tex) {
    tex.destroy = function _emptyDestroy() {
    };
    tex.on = function _emptyOn() {
    };
    tex.once = function _emptyOnce() {
    };
    tex.emit = function _emptyEmit() {
    };
  }
  var Texture = (
    /** @class */
    function(_super) {
      __extends2(Texture3, _super);
      function Texture3(baseTexture, frame, orig, trim, rotate, anchor) {
        var _this = _super.call(this) || this;
        _this.noFrame = false;
        if (!frame) {
          _this.noFrame = true;
          frame = new Rectangle(0, 0, 1, 1);
        }
        if (baseTexture instanceof Texture3) {
          baseTexture = baseTexture.baseTexture;
        }
        _this.baseTexture = baseTexture;
        _this._frame = frame;
        _this.trim = trim;
        _this.valid = false;
        _this._uvs = DEFAULT_UVS;
        _this.uvMatrix = null;
        _this.orig = orig || frame;
        _this._rotate = Number(rotate || 0);
        if (rotate === true) {
          _this._rotate = 2;
        } else if (_this._rotate % 2 !== 0) {
          throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
        }
        _this.defaultAnchor = anchor ? new Point(anchor.x, anchor.y) : new Point(0, 0);
        _this._updateID = 0;
        _this.textureCacheIds = [];
        if (!baseTexture.valid) {
          baseTexture.once("loaded", _this.onBaseTextureUpdated, _this);
        } else if (_this.noFrame) {
          if (baseTexture.valid) {
            _this.onBaseTextureUpdated(baseTexture);
          }
        } else {
          _this.frame = frame;
        }
        if (_this.noFrame) {
          baseTexture.on("update", _this.onBaseTextureUpdated, _this);
        }
        return _this;
      }
      Texture3.prototype.update = function() {
        if (this.baseTexture.resource) {
          this.baseTexture.resource.update();
        }
      };
      Texture3.prototype.onBaseTextureUpdated = function(baseTexture) {
        if (this.noFrame) {
          if (!this.baseTexture.valid) {
            return;
          }
          this._frame.width = baseTexture.width;
          this._frame.height = baseTexture.height;
          this.valid = true;
          this.updateUvs();
        } else {
          this.frame = this._frame;
        }
        this.emit("update", this);
      };
      Texture3.prototype.destroy = function(destroyBase) {
        if (this.baseTexture) {
          if (destroyBase) {
            var resource = this.baseTexture.resource;
            if (resource && resource.url && TextureCache[resource.url]) {
              Texture3.removeFromCache(resource.url);
            }
            this.baseTexture.destroy();
          }
          this.baseTexture.off("loaded", this.onBaseTextureUpdated, this);
          this.baseTexture.off("update", this.onBaseTextureUpdated, this);
          this.baseTexture = null;
        }
        this._frame = null;
        this._uvs = null;
        this.trim = null;
        this.orig = null;
        this.valid = false;
        Texture3.removeFromCache(this);
        this.textureCacheIds = null;
      };
      Texture3.prototype.clone = function() {
        var clonedFrame = this._frame.clone();
        var clonedOrig = this._frame === this.orig ? clonedFrame : this.orig.clone();
        var clonedTexture = new Texture3(this.baseTexture, !this.noFrame && clonedFrame, clonedOrig, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);
        if (this.noFrame) {
          clonedTexture._frame = clonedFrame;
        }
        return clonedTexture;
      };
      Texture3.prototype.updateUvs = function() {
        if (this._uvs === DEFAULT_UVS) {
          this._uvs = new TextureUvs();
        }
        this._uvs.set(this._frame, this.baseTexture, this.rotate);
        this._updateID++;
      };
      Texture3.from = function(source, options, strict) {
        if (options === void 0) {
          options = {};
        }
        if (strict === void 0) {
          strict = settings.STRICT_TEXTURE_CACHE;
        }
        var isFrame = typeof source === "string";
        var cacheId = null;
        if (isFrame) {
          cacheId = source;
        } else if (source instanceof BaseTexture) {
          if (!source.cacheId) {
            var prefix = options && options.pixiIdPrefix || "pixiid";
            source.cacheId = prefix + "-" + uid();
            BaseTexture.addToCache(source, source.cacheId);
          }
          cacheId = source.cacheId;
        } else {
          if (!source._pixiId) {
            var prefix = options && options.pixiIdPrefix || "pixiid";
            source._pixiId = prefix + "_" + uid();
          }
          cacheId = source._pixiId;
        }
        var texture = TextureCache[cacheId];
        if (isFrame && strict && !texture) {
          throw new Error('The cacheId "' + cacheId + '" does not exist in TextureCache.');
        }
        if (!texture && !(source instanceof BaseTexture)) {
          if (!options.resolution) {
            options.resolution = getResolutionOfUrl(source);
          }
          texture = new Texture3(new BaseTexture(source, options));
          texture.baseTexture.cacheId = cacheId;
          BaseTexture.addToCache(texture.baseTexture, cacheId);
          Texture3.addToCache(texture, cacheId);
        } else if (!texture && source instanceof BaseTexture) {
          texture = new Texture3(source);
          Texture3.addToCache(texture, cacheId);
        }
        return texture;
      };
      Texture3.fromURL = function(url3, options) {
        var resourceOptions = Object.assign({ autoLoad: false }, options === null || options === void 0 ? void 0 : options.resourceOptions);
        var texture = Texture3.from(url3, Object.assign({ resourceOptions }, options), false);
        var resource = texture.baseTexture.resource;
        if (texture.baseTexture.valid) {
          return Promise.resolve(texture);
        }
        return resource.load().then(function() {
          return Promise.resolve(texture);
        });
      };
      Texture3.fromBuffer = function(buffer, width, height, options) {
        return new Texture3(BaseTexture.fromBuffer(buffer, width, height, options));
      };
      Texture3.fromLoader = function(source, imageUrl, name, options) {
        var baseTexture = new BaseTexture(source, Object.assign({
          scaleMode: settings.SCALE_MODE,
          resolution: getResolutionOfUrl(imageUrl)
        }, options));
        var resource = baseTexture.resource;
        if (resource instanceof ImageResource) {
          resource.url = imageUrl;
        }
        var texture = new Texture3(baseTexture);
        if (!name) {
          name = imageUrl;
        }
        BaseTexture.addToCache(texture.baseTexture, name);
        Texture3.addToCache(texture, name);
        if (name !== imageUrl) {
          BaseTexture.addToCache(texture.baseTexture, imageUrl);
          Texture3.addToCache(texture, imageUrl);
        }
        if (texture.baseTexture.valid) {
          return Promise.resolve(texture);
        }
        return new Promise(function(resolve3) {
          texture.baseTexture.once("loaded", function() {
            return resolve3(texture);
          });
        });
      };
      Texture3.addToCache = function(texture, id) {
        if (id) {
          if (texture.textureCacheIds.indexOf(id) === -1) {
            texture.textureCacheIds.push(id);
          }
          if (TextureCache[id]) {
            console.warn("Texture added to the cache with an id [" + id + "] that already had an entry");
          }
          TextureCache[id] = texture;
        }
      };
      Texture3.removeFromCache = function(texture) {
        if (typeof texture === "string") {
          var textureFromCache = TextureCache[texture];
          if (textureFromCache) {
            var index = textureFromCache.textureCacheIds.indexOf(texture);
            if (index > -1) {
              textureFromCache.textureCacheIds.splice(index, 1);
            }
            delete TextureCache[texture];
            return textureFromCache;
          }
        } else if (texture && texture.textureCacheIds) {
          for (var i = 0; i < texture.textureCacheIds.length; ++i) {
            if (TextureCache[texture.textureCacheIds[i]] === texture) {
              delete TextureCache[texture.textureCacheIds[i]];
            }
          }
          texture.textureCacheIds.length = 0;
          return texture;
        }
        return null;
      };
      Object.defineProperty(Texture3.prototype, "resolution", {
        /**
         * Returns resolution of baseTexture
         * @readonly
         */
        get: function() {
          return this.baseTexture.resolution;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Texture3.prototype, "frame", {
        /**
         * The frame specifies the region of the base texture that this texture uses.
         * Please call `updateUvs()` after you change coordinates of `frame` manually.
         */
        get: function() {
          return this._frame;
        },
        set: function(frame) {
          this._frame = frame;
          this.noFrame = false;
          var x = frame.x, y = frame.y, width = frame.width, height = frame.height;
          var xNotFit = x + width > this.baseTexture.width;
          var yNotFit = y + height > this.baseTexture.height;
          if (xNotFit || yNotFit) {
            var relationship = xNotFit && yNotFit ? "and" : "or";
            var errorX = "X: " + x + " + " + width + " = " + (x + width) + " > " + this.baseTexture.width;
            var errorY = "Y: " + y + " + " + height + " = " + (y + height) + " > " + this.baseTexture.height;
            throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + (errorX + " " + relationship + " " + errorY));
          }
          this.valid = width && height && this.baseTexture.valid;
          if (!this.trim && !this.rotate) {
            this.orig = frame;
          }
          if (this.valid) {
            this.updateUvs();
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Texture3.prototype, "rotate", {
        /**
         * Indicates whether the texture is rotated inside the atlas
         * set to 2 to compensate for texture packer rotation
         * set to 6 to compensate for spine packer rotation
         * can be used to rotate or mirror sprites
         * See {@link PIXI.groupD8} for explanation
         */
        get: function() {
          return this._rotate;
        },
        set: function(rotate) {
          this._rotate = rotate;
          if (this.valid) {
            this.updateUvs();
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Texture3.prototype, "width", {
        /** The width of the Texture in pixels. */
        get: function() {
          return this.orig.width;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Texture3.prototype, "height", {
        /** The height of the Texture in pixels. */
        get: function() {
          return this.orig.height;
        },
        enumerable: false,
        configurable: true
      });
      Texture3.prototype.castToBaseTexture = function() {
        return this.baseTexture;
      };
      Object.defineProperty(Texture3, "EMPTY", {
        /** An empty texture, used often to not have to create multiple empty textures. Can not be destroyed. */
        get: function() {
          if (!Texture3._EMPTY) {
            Texture3._EMPTY = new Texture3(new BaseTexture());
            removeAllHandlers(Texture3._EMPTY);
            removeAllHandlers(Texture3._EMPTY.baseTexture);
          }
          return Texture3._EMPTY;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Texture3, "WHITE", {
        /** A white texture of 16x16 size, used for graphics and other things Can not be destroyed. */
        get: function() {
          if (!Texture3._WHITE) {
            var canvas = document.createElement("canvas");
            var context3 = canvas.getContext("2d");
            canvas.width = 16;
            canvas.height = 16;
            context3.fillStyle = "white";
            context3.fillRect(0, 0, 16, 16);
            Texture3._WHITE = new Texture3(new BaseTexture(new CanvasResource(canvas)));
            removeAllHandlers(Texture3._WHITE);
            removeAllHandlers(Texture3._WHITE.baseTexture);
          }
          return Texture3._WHITE;
        },
        enumerable: false,
        configurable: true
      });
      return Texture3;
    }(import_eventemitter3.default)
  );
  var RenderTexture = (
    /** @class */
    function(_super) {
      __extends2(RenderTexture3, _super);
      function RenderTexture3(baseRenderTexture, frame) {
        var _this = _super.call(this, baseRenderTexture, frame) || this;
        _this.valid = true;
        _this.filterFrame = null;
        _this.filterPoolKey = null;
        _this.updateUvs();
        return _this;
      }
      Object.defineProperty(RenderTexture3.prototype, "framebuffer", {
        /**
         * Shortcut to `this.baseTexture.framebuffer`, saves baseTexture cast.
         * @readonly
         */
        get: function() {
          return this.baseTexture.framebuffer;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(RenderTexture3.prototype, "multisample", {
        /**
         * Shortcut to `this.framebuffer.multisample`.
         * @default PIXI.MSAA_QUALITY.NONE
         */
        get: function() {
          return this.framebuffer.multisample;
        },
        set: function(value) {
          this.framebuffer.multisample = value;
        },
        enumerable: false,
        configurable: true
      });
      RenderTexture3.prototype.resize = function(desiredWidth, desiredHeight, resizeBaseTexture) {
        if (resizeBaseTexture === void 0) {
          resizeBaseTexture = true;
        }
        var resolution = this.baseTexture.resolution;
        var width = Math.round(desiredWidth * resolution) / resolution;
        var height = Math.round(desiredHeight * resolution) / resolution;
        this.valid = width > 0 && height > 0;
        this._frame.width = this.orig.width = width;
        this._frame.height = this.orig.height = height;
        if (resizeBaseTexture) {
          this.baseTexture.resize(width, height);
        }
        this.updateUvs();
      };
      RenderTexture3.prototype.setResolution = function(resolution) {
        var baseTexture = this.baseTexture;
        if (baseTexture.resolution === resolution) {
          return;
        }
        baseTexture.setResolution(resolution);
        this.resize(baseTexture.width, baseTexture.height, false);
      };
      RenderTexture3.create = function(options) {
        var arguments$1 = arguments;
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          rest[_i - 1] = arguments$1[_i];
        }
        if (typeof options === "number") {
          deprecation("6.0.0", "Arguments (width, height, scaleMode, resolution) have been deprecated.");
          options = {
            width: options,
            height: rest[0],
            scaleMode: rest[1],
            resolution: rest[2]
          };
        }
        return new RenderTexture3(new BaseRenderTexture(options));
      };
      return RenderTexture3;
    }(Texture)
  );
  var RenderTexturePool = (
    /** @class */
    function() {
      function RenderTexturePool3(textureOptions) {
        this.texturePool = {};
        this.textureOptions = textureOptions || {};
        this.enableFullScreen = false;
        this._pixelsWidth = 0;
        this._pixelsHeight = 0;
      }
      RenderTexturePool3.prototype.createTexture = function(realWidth, realHeight, multisample) {
        if (multisample === void 0) {
          multisample = MSAA_QUALITY.NONE;
        }
        var baseRenderTexture = new BaseRenderTexture(Object.assign({
          width: realWidth,
          height: realHeight,
          resolution: 1,
          multisample
        }, this.textureOptions));
        return new RenderTexture(baseRenderTexture);
      };
      RenderTexturePool3.prototype.getOptimalTexture = function(minWidth, minHeight, resolution, multisample) {
        if (resolution === void 0) {
          resolution = 1;
        }
        if (multisample === void 0) {
          multisample = MSAA_QUALITY.NONE;
        }
        var key;
        minWidth = Math.ceil(minWidth * resolution - 1e-6);
        minHeight = Math.ceil(minHeight * resolution - 1e-6);
        if (!this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight) {
          minWidth = nextPow2(minWidth);
          minHeight = nextPow2(minHeight);
          key = ((minWidth & 65535) << 16 | minHeight & 65535) >>> 0;
          if (multisample > 1) {
            key += multisample * 4294967296;
          }
        } else {
          key = multisample > 1 ? -multisample : -1;
        }
        if (!this.texturePool[key]) {
          this.texturePool[key] = [];
        }
        var renderTexture = this.texturePool[key].pop();
        if (!renderTexture) {
          renderTexture = this.createTexture(minWidth, minHeight, multisample);
        }
        renderTexture.filterPoolKey = key;
        renderTexture.setResolution(resolution);
        return renderTexture;
      };
      RenderTexturePool3.prototype.getFilterTexture = function(input, resolution, multisample) {
        var filterTexture = this.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY.NONE);
        filterTexture.filterFrame = input.filterFrame;
        return filterTexture;
      };
      RenderTexturePool3.prototype.returnTexture = function(renderTexture) {
        var key = renderTexture.filterPoolKey;
        renderTexture.filterFrame = null;
        this.texturePool[key].push(renderTexture);
      };
      RenderTexturePool3.prototype.returnFilterTexture = function(renderTexture) {
        this.returnTexture(renderTexture);
      };
      RenderTexturePool3.prototype.clear = function(destroyTextures) {
        destroyTextures = destroyTextures !== false;
        if (destroyTextures) {
          for (var i in this.texturePool) {
            var textures = this.texturePool[i];
            if (textures) {
              for (var j = 0; j < textures.length; j++) {
                textures[j].destroy(true);
              }
            }
          }
        }
        this.texturePool = {};
      };
      RenderTexturePool3.prototype.setScreenSize = function(size) {
        if (size.width === this._pixelsWidth && size.height === this._pixelsHeight) {
          return;
        }
        this.enableFullScreen = size.width > 0 && size.height > 0;
        for (var i in this.texturePool) {
          if (!(Number(i) < 0)) {
            continue;
          }
          var textures = this.texturePool[i];
          if (textures) {
            for (var j = 0; j < textures.length; j++) {
              textures[j].destroy(true);
            }
          }
          this.texturePool[i] = [];
        }
        this._pixelsWidth = size.width;
        this._pixelsHeight = size.height;
      };
      RenderTexturePool3.SCREEN_KEY = -1;
      return RenderTexturePool3;
    }()
  );
  var Attribute = (
    /** @class */
    function() {
      function Attribute3(buffer, size, normalized, type, stride, start, instance) {
        if (size === void 0) {
          size = 0;
        }
        if (normalized === void 0) {
          normalized = false;
        }
        if (type === void 0) {
          type = TYPES.FLOAT;
        }
        this.buffer = buffer;
        this.size = size;
        this.normalized = normalized;
        this.type = type;
        this.stride = stride;
        this.start = start;
        this.instance = instance;
      }
      Attribute3.prototype.destroy = function() {
        this.buffer = null;
      };
      Attribute3.from = function(buffer, size, normalized, type, stride) {
        return new Attribute3(buffer, size, normalized, type, stride);
      };
      return Attribute3;
    }()
  );
  var UID$4 = 0;
  var Buffer2 = (
    /** @class */
    function() {
      function Buffer4(data, _static, index) {
        if (_static === void 0) {
          _static = true;
        }
        if (index === void 0) {
          index = false;
        }
        this.data = data || new Float32Array(1);
        this._glBuffers = {};
        this._updateID = 0;
        this.index = index;
        this.static = _static;
        this.id = UID$4++;
        this.disposeRunner = new Runner("disposeBuffer");
      }
      Buffer4.prototype.update = function(data) {
        if (data instanceof Array) {
          data = new Float32Array(data);
        }
        this.data = data || this.data;
        this._updateID++;
      };
      Buffer4.prototype.dispose = function() {
        this.disposeRunner.emit(this, false);
      };
      Buffer4.prototype.destroy = function() {
        this.dispose();
        this.data = null;
      };
      Object.defineProperty(Buffer4.prototype, "index", {
        get: function() {
          return this.type === BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
        },
        /**
         * Flags whether this is an index buffer.
         *
         * Index buffers are of type `ELEMENT_ARRAY_BUFFER`. Note that setting this property to false will make
         * the buffer of type `ARRAY_BUFFER`.
         *
         * For backwards compatibility.
         */
        set: function(value) {
          this.type = value ? BUFFER_TYPE.ELEMENT_ARRAY_BUFFER : BUFFER_TYPE.ARRAY_BUFFER;
        },
        enumerable: false,
        configurable: true
      });
      Buffer4.from = function(data) {
        if (data instanceof Array) {
          data = new Float32Array(data);
        }
        return new Buffer4(data);
      };
      return Buffer4;
    }()
  );
  var map$1 = {
    Float32Array,
    Uint32Array,
    Int32Array,
    Uint8Array
  };
  function interleaveTypedArrays2(arrays, sizes) {
    var outSize = 0;
    var stride = 0;
    var views = {};
    for (var i = 0; i < arrays.length; i++) {
      stride += sizes[i];
      outSize += arrays[i].length;
    }
    var buffer = new ArrayBuffer(outSize * 4);
    var out = null;
    var littleOffset = 0;
    for (var i = 0; i < arrays.length; i++) {
      var size = sizes[i];
      var array = arrays[i];
      var type = getBufferType(array);
      if (!views[type]) {
        views[type] = new map$1[type](buffer);
      }
      out = views[type];
      for (var j = 0; j < array.length; j++) {
        var indexStart = (j / size | 0) * stride + littleOffset;
        var index = j % size;
        out[indexStart + index] = array[j];
      }
      littleOffset += size;
    }
    return new Float32Array(buffer);
  }
  var byteSizeMap$1 = { 5126: 4, 5123: 2, 5121: 1 };
  var UID$3 = 0;
  var map2 = {
    Float32Array,
    Uint32Array,
    Int32Array,
    Uint8Array,
    Uint16Array
  };
  var Geometry = (
    /** @class */
    function() {
      function Geometry3(buffers, attributes) {
        if (buffers === void 0) {
          buffers = [];
        }
        if (attributes === void 0) {
          attributes = {};
        }
        this.buffers = buffers;
        this.indexBuffer = null;
        this.attributes = attributes;
        this.glVertexArrayObjects = {};
        this.id = UID$3++;
        this.instanced = false;
        this.instanceCount = 1;
        this.disposeRunner = new Runner("disposeGeometry");
        this.refCount = 0;
      }
      Geometry3.prototype.addAttribute = function(id, buffer, size, normalized, type, stride, start, instance) {
        if (size === void 0) {
          size = 0;
        }
        if (normalized === void 0) {
          normalized = false;
        }
        if (instance === void 0) {
          instance = false;
        }
        if (!buffer) {
          throw new Error("You must pass a buffer when creating an attribute");
        }
        if (!(buffer instanceof Buffer2)) {
          if (buffer instanceof Array) {
            buffer = new Float32Array(buffer);
          }
          buffer = new Buffer2(buffer);
        }
        var ids = id.split("|");
        if (ids.length > 1) {
          for (var i = 0; i < ids.length; i++) {
            this.addAttribute(ids[i], buffer, size, normalized, type);
          }
          return this;
        }
        var bufferIndex = this.buffers.indexOf(buffer);
        if (bufferIndex === -1) {
          this.buffers.push(buffer);
          bufferIndex = this.buffers.length - 1;
        }
        this.attributes[id] = new Attribute(bufferIndex, size, normalized, type, stride, start, instance);
        this.instanced = this.instanced || instance;
        return this;
      };
      Geometry3.prototype.getAttribute = function(id) {
        return this.attributes[id];
      };
      Geometry3.prototype.getBuffer = function(id) {
        return this.buffers[this.getAttribute(id).buffer];
      };
      Geometry3.prototype.addIndex = function(buffer) {
        if (!(buffer instanceof Buffer2)) {
          if (buffer instanceof Array) {
            buffer = new Uint16Array(buffer);
          }
          buffer = new Buffer2(buffer);
        }
        buffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
        this.indexBuffer = buffer;
        if (this.buffers.indexOf(buffer) === -1) {
          this.buffers.push(buffer);
        }
        return this;
      };
      Geometry3.prototype.getIndex = function() {
        return this.indexBuffer;
      };
      Geometry3.prototype.interleave = function() {
        if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer) {
          return this;
        }
        var arrays = [];
        var sizes = [];
        var interleavedBuffer = new Buffer2();
        var i;
        for (i in this.attributes) {
          var attribute = this.attributes[i];
          var buffer = this.buffers[attribute.buffer];
          arrays.push(buffer.data);
          sizes.push(attribute.size * byteSizeMap$1[attribute.type] / 4);
          attribute.buffer = 0;
        }
        interleavedBuffer.data = interleaveTypedArrays2(arrays, sizes);
        for (i = 0; i < this.buffers.length; i++) {
          if (this.buffers[i] !== this.indexBuffer) {
            this.buffers[i].destroy();
          }
        }
        this.buffers = [interleavedBuffer];
        if (this.indexBuffer) {
          this.buffers.push(this.indexBuffer);
        }
        return this;
      };
      Geometry3.prototype.getSize = function() {
        for (var i in this.attributes) {
          var attribute = this.attributes[i];
          var buffer = this.buffers[attribute.buffer];
          return buffer.data.length / (attribute.stride / 4 || attribute.size);
        }
        return 0;
      };
      Geometry3.prototype.dispose = function() {
        this.disposeRunner.emit(this, false);
      };
      Geometry3.prototype.destroy = function() {
        this.dispose();
        this.buffers = null;
        this.indexBuffer = null;
        this.attributes = null;
      };
      Geometry3.prototype.clone = function() {
        var geometry = new Geometry3();
        for (var i = 0; i < this.buffers.length; i++) {
          geometry.buffers[i] = new Buffer2(this.buffers[i].data.slice(0));
        }
        for (var i in this.attributes) {
          var attrib = this.attributes[i];
          geometry.attributes[i] = new Attribute(attrib.buffer, attrib.size, attrib.normalized, attrib.type, attrib.stride, attrib.start, attrib.instance);
        }
        if (this.indexBuffer) {
          geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];
          geometry.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
        }
        return geometry;
      };
      Geometry3.merge = function(geometries) {
        var geometryOut = new Geometry3();
        var arrays = [];
        var sizes = [];
        var offsets = [];
        var geometry;
        for (var i = 0; i < geometries.length; i++) {
          geometry = geometries[i];
          for (var j = 0; j < geometry.buffers.length; j++) {
            sizes[j] = sizes[j] || 0;
            sizes[j] += geometry.buffers[j].data.length;
            offsets[j] = 0;
          }
        }
        for (var i = 0; i < geometry.buffers.length; i++) {
          arrays[i] = new map2[getBufferType(geometry.buffers[i].data)](sizes[i]);
          geometryOut.buffers[i] = new Buffer2(arrays[i]);
        }
        for (var i = 0; i < geometries.length; i++) {
          geometry = geometries[i];
          for (var j = 0; j < geometry.buffers.length; j++) {
            arrays[j].set(geometry.buffers[j].data, offsets[j]);
            offsets[j] += geometry.buffers[j].data.length;
          }
        }
        geometryOut.attributes = geometry.attributes;
        if (geometry.indexBuffer) {
          geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];
          geometryOut.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
          var offset = 0;
          var stride = 0;
          var offset2 = 0;
          var bufferIndexToCount = 0;
          for (var i = 0; i < geometry.buffers.length; i++) {
            if (geometry.buffers[i] !== geometry.indexBuffer) {
              bufferIndexToCount = i;
              break;
            }
          }
          for (var i in geometry.attributes) {
            var attribute = geometry.attributes[i];
            if ((attribute.buffer | 0) === bufferIndexToCount) {
              stride += attribute.size * byteSizeMap$1[attribute.type] / 4;
            }
          }
          for (var i = 0; i < geometries.length; i++) {
            var indexBufferData = geometries[i].indexBuffer.data;
            for (var j = 0; j < indexBufferData.length; j++) {
              geometryOut.indexBuffer.data[j + offset2] += offset;
            }
            offset += geometries[i].buffers[bufferIndexToCount].data.length / stride;
            offset2 += indexBufferData.length;
          }
        }
        return geometryOut;
      };
      return Geometry3;
    }()
  );
  var Quad = (
    /** @class */
    function(_super) {
      __extends2(Quad3, _super);
      function Quad3() {
        var _this = _super.call(this) || this;
        _this.addAttribute("aVertexPosition", new Float32Array([
          0,
          0,
          1,
          0,
          1,
          1,
          0,
          1
        ])).addIndex([0, 1, 3, 2]);
        return _this;
      }
      return Quad3;
    }(Geometry)
  );
  var QuadUv = (
    /** @class */
    function(_super) {
      __extends2(QuadUv3, _super);
      function QuadUv3() {
        var _this = _super.call(this) || this;
        _this.vertices = new Float32Array([
          -1,
          -1,
          1,
          -1,
          1,
          1,
          -1,
          1
        ]);
        _this.uvs = new Float32Array([
          0,
          0,
          1,
          0,
          1,
          1,
          0,
          1
        ]);
        _this.vertexBuffer = new Buffer2(_this.vertices);
        _this.uvBuffer = new Buffer2(_this.uvs);
        _this.addAttribute("aVertexPosition", _this.vertexBuffer).addAttribute("aTextureCoord", _this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);
        return _this;
      }
      QuadUv3.prototype.map = function(targetTextureFrame, destinationFrame) {
        var x = 0;
        var y = 0;
        this.uvs[0] = x;
        this.uvs[1] = y;
        this.uvs[2] = x + destinationFrame.width / targetTextureFrame.width;
        this.uvs[3] = y;
        this.uvs[4] = x + destinationFrame.width / targetTextureFrame.width;
        this.uvs[5] = y + destinationFrame.height / targetTextureFrame.height;
        this.uvs[6] = x;
        this.uvs[7] = y + destinationFrame.height / targetTextureFrame.height;
        x = destinationFrame.x;
        y = destinationFrame.y;
        this.vertices[0] = x;
        this.vertices[1] = y;
        this.vertices[2] = x + destinationFrame.width;
        this.vertices[3] = y;
        this.vertices[4] = x + destinationFrame.width;
        this.vertices[5] = y + destinationFrame.height;
        this.vertices[6] = x;
        this.vertices[7] = y + destinationFrame.height;
        this.invalidate();
        return this;
      };
      QuadUv3.prototype.invalidate = function() {
        this.vertexBuffer._updateID++;
        this.uvBuffer._updateID++;
        return this;
      };
      return QuadUv3;
    }(Geometry)
  );
  var UID$2 = 0;
  var UniformGroup = (
    /** @class */
    function() {
      function UniformGroup3(uniforms, isStatic, isUbo) {
        this.group = true;
        this.syncUniforms = {};
        this.dirtyId = 0;
        this.id = UID$2++;
        this.static = !!isStatic;
        this.ubo = !!isUbo;
        if (uniforms instanceof Buffer2) {
          this.buffer = uniforms;
          this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER;
          this.autoManage = false;
          this.ubo = true;
        } else {
          this.uniforms = uniforms;
          if (this.ubo) {
            this.buffer = new Buffer2(new Float32Array(1));
            this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER;
            this.autoManage = true;
          }
        }
      }
      UniformGroup3.prototype.update = function() {
        this.dirtyId++;
        if (!this.autoManage && this.buffer) {
          this.buffer.update();
        }
      };
      UniformGroup3.prototype.add = function(name, uniforms, _static) {
        if (!this.ubo) {
          this.uniforms[name] = new UniformGroup3(uniforms, _static);
        } else {
          throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
        }
      };
      UniformGroup3.from = function(uniforms, _static, _ubo) {
        return new UniformGroup3(uniforms, _static, _ubo);
      };
      UniformGroup3.uboFrom = function(uniforms, _static) {
        return new UniformGroup3(uniforms, _static !== null && _static !== void 0 ? _static : true, true);
      };
      return UniformGroup3;
    }()
  );
  var FilterState = (
    /** @class */
    function() {
      function FilterState3() {
        this.renderTexture = null;
        this.target = null;
        this.legacy = false;
        this.resolution = 1;
        this.multisample = MSAA_QUALITY.NONE;
        this.sourceFrame = new Rectangle();
        this.destinationFrame = new Rectangle();
        this.bindingSourceFrame = new Rectangle();
        this.bindingDestinationFrame = new Rectangle();
        this.filters = [];
        this.transform = null;
      }
      FilterState3.prototype.clear = function() {
        this.target = null;
        this.filters = null;
        this.renderTexture = null;
      };
      return FilterState3;
    }()
  );
  var tempPoints2 = [new Point(), new Point(), new Point(), new Point()];
  var tempMatrix$2 = new Matrix();
  var FilterSystem = (
    /** @class */
    function() {
      function FilterSystem3(renderer) {
        this.renderer = renderer;
        this.defaultFilterStack = [{}];
        this.texturePool = new RenderTexturePool();
        this.texturePool.setScreenSize(renderer.view);
        this.statePool = [];
        this.quad = new Quad();
        this.quadUv = new QuadUv();
        this.tempRect = new Rectangle();
        this.activeState = {};
        this.globalUniforms = new UniformGroup({
          outputFrame: new Rectangle(),
          inputSize: new Float32Array(4),
          inputPixel: new Float32Array(4),
          inputClamp: new Float32Array(4),
          resolution: 1,
          // legacy variables
          filterArea: new Float32Array(4),
          filterClamp: new Float32Array(4)
        }, true);
        this.forceClear = false;
        this.useMaxPadding = false;
      }
      FilterSystem3.prototype.push = function(target, filters2) {
        var _a2, _b;
        var renderer = this.renderer;
        var filterStack = this.defaultFilterStack;
        var state = this.statePool.pop() || new FilterState();
        var renderTextureSystem = this.renderer.renderTexture;
        var resolution = filters2[0].resolution;
        var multisample = filters2[0].multisample;
        var padding = filters2[0].padding;
        var autoFit = filters2[0].autoFit;
        var legacy = (_a2 = filters2[0].legacy) !== null && _a2 !== void 0 ? _a2 : true;
        for (var i = 1; i < filters2.length; i++) {
          var filter = filters2[i];
          resolution = Math.min(resolution, filter.resolution);
          multisample = Math.min(multisample, filter.multisample);
          padding = this.useMaxPadding ? Math.max(padding, filter.padding) : padding + filter.padding;
          autoFit = autoFit && filter.autoFit;
          legacy = legacy || ((_b = filter.legacy) !== null && _b !== void 0 ? _b : true);
        }
        if (filterStack.length === 1) {
          this.defaultFilterStack[0].renderTexture = renderTextureSystem.current;
        }
        filterStack.push(state);
        state.resolution = resolution;
        state.multisample = multisample;
        state.legacy = legacy;
        state.target = target;
        state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));
        state.sourceFrame.pad(padding);
        var sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);
        if (renderer.projection.transform) {
          this.transformAABB(tempMatrix$2.copyFrom(renderer.projection.transform).invert(), sourceFrameProjected);
        }
        if (autoFit) {
          state.sourceFrame.fit(sourceFrameProjected);
          if (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0) {
            state.sourceFrame.width = 0;
            state.sourceFrame.height = 0;
          }
        } else if (!state.sourceFrame.intersects(sourceFrameProjected)) {
          state.sourceFrame.width = 0;
          state.sourceFrame.height = 0;
        }
        this.roundFrame(state.sourceFrame, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);
        state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution, multisample);
        state.filters = filters2;
        state.destinationFrame.width = state.renderTexture.width;
        state.destinationFrame.height = state.renderTexture.height;
        var destinationFrame = this.tempRect;
        destinationFrame.x = 0;
        destinationFrame.y = 0;
        destinationFrame.width = state.sourceFrame.width;
        destinationFrame.height = state.sourceFrame.height;
        state.renderTexture.filterFrame = state.sourceFrame;
        state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);
        state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);
        state.transform = renderer.projection.transform;
        renderer.projection.transform = null;
        renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame);
        renderer.framebuffer.clear(0, 0, 0, 0);
      };
      FilterSystem3.prototype.pop = function() {
        var filterStack = this.defaultFilterStack;
        var state = filterStack.pop();
        var filters2 = state.filters;
        this.activeState = state;
        var globalUniforms = this.globalUniforms.uniforms;
        globalUniforms.outputFrame = state.sourceFrame;
        globalUniforms.resolution = state.resolution;
        var inputSize = globalUniforms.inputSize;
        var inputPixel = globalUniforms.inputPixel;
        var inputClamp = globalUniforms.inputClamp;
        inputSize[0] = state.destinationFrame.width;
        inputSize[1] = state.destinationFrame.height;
        inputSize[2] = 1 / inputSize[0];
        inputSize[3] = 1 / inputSize[1];
        inputPixel[0] = Math.round(inputSize[0] * state.resolution);
        inputPixel[1] = Math.round(inputSize[1] * state.resolution);
        inputPixel[2] = 1 / inputPixel[0];
        inputPixel[3] = 1 / inputPixel[1];
        inputClamp[0] = 0.5 * inputPixel[2];
        inputClamp[1] = 0.5 * inputPixel[3];
        inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2];
        inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3];
        if (state.legacy) {
          var filterArea = globalUniforms.filterArea;
          filterArea[0] = state.destinationFrame.width;
          filterArea[1] = state.destinationFrame.height;
          filterArea[2] = state.sourceFrame.x;
          filterArea[3] = state.sourceFrame.y;
          globalUniforms.filterClamp = globalUniforms.inputClamp;
        }
        this.globalUniforms.update();
        var lastState = filterStack[filterStack.length - 1];
        this.renderer.framebuffer.blit();
        if (filters2.length === 1) {
          filters2[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES.BLEND, state);
          this.returnFilterTexture(state.renderTexture);
        } else {
          var flip = state.renderTexture;
          var flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
          flop.filterFrame = flip.filterFrame;
          var i = 0;
          for (i = 0; i < filters2.length - 1; ++i) {
            if (i === 1 && state.multisample > 1) {
              flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
              flop.filterFrame = flip.filterFrame;
            }
            filters2[i].apply(this, flip, flop, CLEAR_MODES.CLEAR, state);
            var t = flip;
            flip = flop;
            flop = t;
          }
          filters2[i].apply(this, flip, lastState.renderTexture, CLEAR_MODES.BLEND, state);
          if (i > 1 && state.multisample > 1) {
            this.returnFilterTexture(state.renderTexture);
          }
          this.returnFilterTexture(flip);
          this.returnFilterTexture(flop);
        }
        state.clear();
        this.statePool.push(state);
      };
      FilterSystem3.prototype.bindAndClear = function(filterTexture, clearMode) {
        if (clearMode === void 0) {
          clearMode = CLEAR_MODES.CLEAR;
        }
        var _a2 = this.renderer, renderTextureSystem = _a2.renderTexture, stateSystem = _a2.state;
        if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
          this.renderer.projection.transform = this.activeState.transform;
        } else {
          this.renderer.projection.transform = null;
        }
        if (filterTexture && filterTexture.filterFrame) {
          var destinationFrame = this.tempRect;
          destinationFrame.x = 0;
          destinationFrame.y = 0;
          destinationFrame.width = filterTexture.filterFrame.width;
          destinationFrame.height = filterTexture.filterFrame.height;
          renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);
        } else if (filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
          renderTextureSystem.bind(filterTexture);
        } else {
          this.renderer.renderTexture.bind(filterTexture, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
        }
        var autoClear = stateSystem.stateId & 1 || this.forceClear;
        if (clearMode === CLEAR_MODES.CLEAR || clearMode === CLEAR_MODES.BLIT && autoClear) {
          this.renderer.framebuffer.clear(0, 0, 0, 0);
        }
      };
      FilterSystem3.prototype.applyFilter = function(filter, input, output, clearMode) {
        var renderer = this.renderer;
        renderer.state.set(filter.state);
        this.bindAndClear(output, clearMode);
        filter.uniforms.uSampler = input;
        filter.uniforms.filterGlobals = this.globalUniforms;
        renderer.shader.bind(filter);
        filter.legacy = !!filter.program.attributeData.aTextureCoord;
        if (filter.legacy) {
          this.quadUv.map(input._frame, input.filterFrame);
          renderer.geometry.bind(this.quadUv);
          renderer.geometry.draw(DRAW_MODES.TRIANGLES);
        } else {
          renderer.geometry.bind(this.quad);
          renderer.geometry.draw(DRAW_MODES.TRIANGLE_STRIP);
        }
      };
      FilterSystem3.prototype.calculateSpriteMatrix = function(outputMatrix, sprite) {
        var _a2 = this.activeState, sourceFrame = _a2.sourceFrame, destinationFrame = _a2.destinationFrame;
        var orig = sprite._texture.orig;
        var mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0, destinationFrame.height, sourceFrame.x, sourceFrame.y);
        var worldTransform = sprite.worldTransform.copyTo(Matrix.TEMP_MATRIX);
        worldTransform.invert();
        mappedMatrix.prepend(worldTransform);
        mappedMatrix.scale(1 / orig.width, 1 / orig.height);
        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
        return mappedMatrix;
      };
      FilterSystem3.prototype.destroy = function() {
        this.renderer = null;
        this.texturePool.clear(false);
      };
      FilterSystem3.prototype.getOptimalFilterTexture = function(minWidth, minHeight, resolution, multisample) {
        if (resolution === void 0) {
          resolution = 1;
        }
        if (multisample === void 0) {
          multisample = MSAA_QUALITY.NONE;
        }
        return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);
      };
      FilterSystem3.prototype.getFilterTexture = function(input, resolution, multisample) {
        if (typeof input === "number") {
          var swap = input;
          input = resolution;
          resolution = swap;
        }
        input = input || this.activeState.renderTexture;
        var filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY.NONE);
        filterTexture.filterFrame = input.filterFrame;
        return filterTexture;
      };
      FilterSystem3.prototype.returnFilterTexture = function(renderTexture) {
        this.texturePool.returnTexture(renderTexture);
      };
      FilterSystem3.prototype.emptyPool = function() {
        this.texturePool.clear(true);
      };
      FilterSystem3.prototype.resize = function() {
        this.texturePool.setScreenSize(this.renderer.view);
      };
      FilterSystem3.prototype.transformAABB = function(matrix, rect) {
        var lt = tempPoints2[0];
        var lb = tempPoints2[1];
        var rt = tempPoints2[2];
        var rb = tempPoints2[3];
        lt.set(rect.left, rect.top);
        lb.set(rect.left, rect.bottom);
        rt.set(rect.right, rect.top);
        rb.set(rect.right, rect.bottom);
        matrix.apply(lt, lt);
        matrix.apply(lb, lb);
        matrix.apply(rt, rt);
        matrix.apply(rb, rb);
        var x0 = Math.min(lt.x, lb.x, rt.x, rb.x);
        var y0 = Math.min(lt.y, lb.y, rt.y, rb.y);
        var x1 = Math.max(lt.x, lb.x, rt.x, rb.x);
        var y1 = Math.max(lt.y, lb.y, rt.y, rb.y);
        rect.x = x0;
        rect.y = y0;
        rect.width = x1 - x0;
        rect.height = y1 - y0;
      };
      FilterSystem3.prototype.roundFrame = function(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
        if (frame.width <= 0 || frame.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0) {
          return;
        }
        if (transform) {
          var a = transform.a, b = transform.b, c = transform.c, d = transform.d;
          if ((Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4)) {
            return;
          }
        }
        transform = transform ? tempMatrix$2.copyFrom(transform) : tempMatrix$2.identity();
        transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
        this.transformAABB(transform, frame);
        frame.ceil(resolution);
        this.transformAABB(transform.invert(), frame);
      };
      return FilterSystem3;
    }()
  );
  var ObjectRenderer = (
    /** @class */
    function() {
      function ObjectRenderer3(renderer) {
        this.renderer = renderer;
      }
      ObjectRenderer3.prototype.flush = function() {
      };
      ObjectRenderer3.prototype.destroy = function() {
        this.renderer = null;
      };
      ObjectRenderer3.prototype.start = function() {
      };
      ObjectRenderer3.prototype.stop = function() {
        this.flush();
      };
      ObjectRenderer3.prototype.render = function(_object) {
      };
      return ObjectRenderer3;
    }()
  );
  var BatchSystem = (
    /** @class */
    function() {
      function BatchSystem3(renderer) {
        this.renderer = renderer;
        this.emptyRenderer = new ObjectRenderer(renderer);
        this.currentRenderer = this.emptyRenderer;
      }
      BatchSystem3.prototype.setObjectRenderer = function(objectRenderer) {
        if (this.currentRenderer === objectRenderer) {
          return;
        }
        this.currentRenderer.stop();
        this.currentRenderer = objectRenderer;
        this.currentRenderer.start();
      };
      BatchSystem3.prototype.flush = function() {
        this.setObjectRenderer(this.emptyRenderer);
      };
      BatchSystem3.prototype.reset = function() {
        this.setObjectRenderer(this.emptyRenderer);
      };
      BatchSystem3.prototype.copyBoundTextures = function(arr, maxTextures) {
        var boundTextures = this.renderer.texture.boundTextures;
        for (var i = maxTextures - 1; i >= 0; --i) {
          arr[i] = boundTextures[i] || null;
          if (arr[i]) {
            arr[i]._batchLocation = i;
          }
        }
      };
      BatchSystem3.prototype.boundArray = function(texArray, boundTextures, batchId, maxTextures) {
        var elements = texArray.elements, ids = texArray.ids, count = texArray.count;
        var j = 0;
        for (var i = 0; i < count; i++) {
          var tex = elements[i];
          var loc = tex._batchLocation;
          if (loc >= 0 && loc < maxTextures && boundTextures[loc] === tex) {
            ids[i] = loc;
            continue;
          }
          while (j < maxTextures) {
            var bound = boundTextures[j];
            if (bound && bound._batchEnabled === batchId && bound._batchLocation === j) {
              j++;
              continue;
            }
            ids[i] = j;
            tex._batchLocation = j;
            boundTextures[j] = tex;
            break;
          }
        }
      };
      BatchSystem3.prototype.destroy = function() {
        this.renderer = null;
      };
      return BatchSystem3;
    }()
  );
  var CONTEXT_UID_COUNTER = 0;
  var ContextSystem = (
    /** @class */
    function() {
      function ContextSystem3(renderer) {
        this.renderer = renderer;
        this.webGLVersion = 1;
        this.extensions = {};
        this.supports = {
          uint32Indices: false
        };
        this.handleContextLost = this.handleContextLost.bind(this);
        this.handleContextRestored = this.handleContextRestored.bind(this);
        renderer.view.addEventListener("webglcontextlost", this.handleContextLost, false);
        renderer.view.addEventListener("webglcontextrestored", this.handleContextRestored, false);
      }
      Object.defineProperty(ContextSystem3.prototype, "isLost", {
        /**
         * `true` if the context is lost
         * @readonly
         */
        get: function() {
          return !this.gl || this.gl.isContextLost();
        },
        enumerable: false,
        configurable: true
      });
      ContextSystem3.prototype.contextChange = function(gl) {
        this.gl = gl;
        this.renderer.gl = gl;
        this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
        if (gl.isContextLost() && gl.getExtension("WEBGL_lose_context")) {
          gl.getExtension("WEBGL_lose_context").restoreContext();
        }
      };
      ContextSystem3.prototype.initFromContext = function(gl) {
        this.gl = gl;
        this.validateContext(gl);
        this.renderer.gl = gl;
        this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
        this.renderer.runners.contextChange.emit(gl);
      };
      ContextSystem3.prototype.initFromOptions = function(options) {
        var gl = this.createContext(this.renderer.view, options);
        this.initFromContext(gl);
      };
      ContextSystem3.prototype.createContext = function(canvas, options) {
        var gl;
        if (settings.PREFER_ENV >= ENV.WEBGL2) {
          gl = canvas.getContext("webgl2", options);
        }
        if (gl) {
          this.webGLVersion = 2;
        } else {
          this.webGLVersion = 1;
          gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);
          if (!gl) {
            throw new Error("This browser does not support WebGL. Try using the canvas renderer");
          }
        }
        this.gl = gl;
        this.getExtensions();
        return this.gl;
      };
      ContextSystem3.prototype.getExtensions = function() {
        var gl = this.gl;
        var common = {
          anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
          floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
          s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
          s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
          etc: gl.getExtension("WEBGL_compressed_texture_etc"),
          etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
          pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
          atc: gl.getExtension("WEBGL_compressed_texture_atc"),
          astc: gl.getExtension("WEBGL_compressed_texture_astc")
        };
        if (this.webGLVersion === 1) {
          Object.assign(this.extensions, common, {
            drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
            depthTexture: gl.getExtension("WEBGL_depth_texture"),
            loseContext: gl.getExtension("WEBGL_lose_context"),
            vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
            uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
            // Floats and half-floats
            floatTexture: gl.getExtension("OES_texture_float"),
            floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
            textureHalfFloat: gl.getExtension("OES_texture_half_float"),
            textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear")
          });
        } else if (this.webGLVersion === 2) {
          Object.assign(this.extensions, common, {
            // Floats and half-floats
            colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
          });
        }
      };
      ContextSystem3.prototype.handleContextLost = function(event) {
        event.preventDefault();
      };
      ContextSystem3.prototype.handleContextRestored = function() {
        this.renderer.runners.contextChange.emit(this.gl);
      };
      ContextSystem3.prototype.destroy = function() {
        var view = this.renderer.view;
        this.renderer = null;
        view.removeEventListener("webglcontextlost", this.handleContextLost);
        view.removeEventListener("webglcontextrestored", this.handleContextRestored);
        this.gl.useProgram(null);
        if (this.extensions.loseContext) {
          this.extensions.loseContext.loseContext();
        }
      };
      ContextSystem3.prototype.postrender = function() {
        if (this.renderer.renderingToScreen) {
          this.gl.flush();
        }
      };
      ContextSystem3.prototype.validateContext = function(gl) {
        var attributes = gl.getContextAttributes();
        var isWebGl2 = "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext;
        if (isWebGl2) {
          this.webGLVersion = 2;
        }
        if (attributes && !attributes.stencil) {
          console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
        }
        var hasuint32 = isWebGl2 || !!gl.getExtension("OES_element_index_uint");
        this.supports.uint32Indices = hasuint32;
        if (!hasuint32) {
          console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
        }
      };
      return ContextSystem3;
    }()
  );
  var GLFramebuffer = (
    /** @class */
    function() {
      function GLFramebuffer3(framebuffer) {
        this.framebuffer = framebuffer;
        this.stencil = null;
        this.dirtyId = -1;
        this.dirtyFormat = -1;
        this.dirtySize = -1;
        this.multisample = MSAA_QUALITY.NONE;
        this.msaaBuffer = null;
        this.blitFramebuffer = null;
        this.mipLevel = 0;
      }
      return GLFramebuffer3;
    }()
  );
  var tempRectangle = new Rectangle();
  var FramebufferSystem = (
    /** @class */
    function() {
      function FramebufferSystem3(renderer) {
        this.renderer = renderer;
        this.managedFramebuffers = [];
        this.unknownFramebuffer = new Framebuffer(10, 10);
        this.msaaSamples = null;
      }
      FramebufferSystem3.prototype.contextChange = function() {
        var gl = this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        this.current = this.unknownFramebuffer;
        this.viewport = new Rectangle();
        this.hasMRT = true;
        this.writeDepthTexture = true;
        this.disposeAll(true);
        if (this.renderer.context.webGLVersion === 1) {
          var nativeDrawBuffersExtension_1 = this.renderer.context.extensions.drawBuffers;
          var nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;
          if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
            nativeDrawBuffersExtension_1 = null;
            nativeDepthTextureExtension = null;
          }
          if (nativeDrawBuffersExtension_1) {
            gl.drawBuffers = function(activeTextures) {
              return nativeDrawBuffersExtension_1.drawBuffersWEBGL(activeTextures);
            };
          } else {
            this.hasMRT = false;
            gl.drawBuffers = function() {
            };
          }
          if (!nativeDepthTextureExtension) {
            this.writeDepthTexture = false;
          }
        } else {
          this.msaaSamples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.RGBA8, gl.SAMPLES);
        }
      };
      FramebufferSystem3.prototype.bind = function(framebuffer, frame, mipLevel) {
        if (mipLevel === void 0) {
          mipLevel = 0;
        }
        var gl = this.gl;
        if (framebuffer) {
          var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);
          if (this.current !== framebuffer) {
            this.current = framebuffer;
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);
          }
          if (fbo.mipLevel !== mipLevel) {
            framebuffer.dirtyId++;
            framebuffer.dirtyFormat++;
            fbo.mipLevel = mipLevel;
          }
          if (fbo.dirtyId !== framebuffer.dirtyId) {
            fbo.dirtyId = framebuffer.dirtyId;
            if (fbo.dirtyFormat !== framebuffer.dirtyFormat) {
              fbo.dirtyFormat = framebuffer.dirtyFormat;
              fbo.dirtySize = framebuffer.dirtySize;
              this.updateFramebuffer(framebuffer, mipLevel);
            } else if (fbo.dirtySize !== framebuffer.dirtySize) {
              fbo.dirtySize = framebuffer.dirtySize;
              this.resizeFramebuffer(framebuffer);
            }
          }
          for (var i = 0; i < framebuffer.colorTextures.length; i++) {
            var tex = framebuffer.colorTextures[i];
            this.renderer.texture.unbind(tex.parentTextureArray || tex);
          }
          if (framebuffer.depthTexture) {
            this.renderer.texture.unbind(framebuffer.depthTexture);
          }
          if (frame) {
            var mipWidth = frame.width >> mipLevel;
            var mipHeight = frame.height >> mipLevel;
            var scale = mipWidth / frame.width;
            this.setViewport(frame.x * scale, frame.y * scale, mipWidth, mipHeight);
          } else {
            var mipWidth = framebuffer.width >> mipLevel;
            var mipHeight = framebuffer.height >> mipLevel;
            this.setViewport(0, 0, mipWidth, mipHeight);
          }
        } else {
          if (this.current) {
            this.current = null;
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          }
          if (frame) {
            this.setViewport(frame.x, frame.y, frame.width, frame.height);
          } else {
            this.setViewport(0, 0, this.renderer.width, this.renderer.height);
          }
        }
      };
      FramebufferSystem3.prototype.setViewport = function(x, y, width, height) {
        var v = this.viewport;
        x = Math.round(x);
        y = Math.round(y);
        width = Math.round(width);
        height = Math.round(height);
        if (v.width !== width || v.height !== height || v.x !== x || v.y !== y) {
          v.x = x;
          v.y = y;
          v.width = width;
          v.height = height;
          this.gl.viewport(x, y, width, height);
        }
      };
      Object.defineProperty(FramebufferSystem3.prototype, "size", {
        /**
         * Get the size of the current width and height. Returns object with `width` and `height` values.
         * @readonly
         */
        get: function() {
          if (this.current) {
            return { x: 0, y: 0, width: this.current.width, height: this.current.height };
          }
          return { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
        },
        enumerable: false,
        configurable: true
      });
      FramebufferSystem3.prototype.clear = function(r, g, b, a, mask) {
        if (mask === void 0) {
          mask = BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH;
        }
        var gl = this.gl;
        gl.clearColor(r, g, b, a);
        gl.clear(mask);
      };
      FramebufferSystem3.prototype.initFramebuffer = function(framebuffer) {
        var gl = this.gl;
        var fbo = new GLFramebuffer(gl.createFramebuffer());
        fbo.multisample = this.detectSamples(framebuffer.multisample);
        framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo;
        this.managedFramebuffers.push(framebuffer);
        framebuffer.disposeRunner.add(this);
        return fbo;
      };
      FramebufferSystem3.prototype.resizeFramebuffer = function(framebuffer) {
        var gl = this.gl;
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        if (fbo.msaaBuffer) {
          gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.RGBA8, framebuffer.width, framebuffer.height);
        }
        if (fbo.stencil) {
          gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
          if (fbo.msaaBuffer) {
            gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
          } else {
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
          }
        }
        var colorTextures = framebuffer.colorTextures;
        var count = colorTextures.length;
        if (!gl.drawBuffers) {
          count = Math.min(count, 1);
        }
        for (var i = 0; i < count; i++) {
          var texture = colorTextures[i];
          var parentTexture = texture.parentTextureArray || texture;
          this.renderer.texture.bind(parentTexture, 0);
        }
        if (framebuffer.depthTexture && this.writeDepthTexture) {
          this.renderer.texture.bind(framebuffer.depthTexture, 0);
        }
      };
      FramebufferSystem3.prototype.updateFramebuffer = function(framebuffer, mipLevel) {
        var gl = this.gl;
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        var colorTextures = framebuffer.colorTextures;
        var count = colorTextures.length;
        if (!gl.drawBuffers) {
          count = Math.min(count, 1);
        }
        if (fbo.multisample > 1 && this.canMultisampleFramebuffer(framebuffer)) {
          fbo.msaaBuffer = fbo.msaaBuffer || gl.createRenderbuffer();
          gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.RGBA8, framebuffer.width, framebuffer.height);
          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, fbo.msaaBuffer);
        } else if (fbo.msaaBuffer) {
          gl.deleteRenderbuffer(fbo.msaaBuffer);
          fbo.msaaBuffer = null;
          if (fbo.blitFramebuffer) {
            fbo.blitFramebuffer.dispose();
            fbo.blitFramebuffer = null;
          }
        }
        var activeTextures = [];
        for (var i = 0; i < count; i++) {
          var texture = colorTextures[i];
          var parentTexture = texture.parentTextureArray || texture;
          this.renderer.texture.bind(parentTexture, 0);
          if (i === 0 && fbo.msaaBuffer) {
            continue;
          }
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, texture.target, parentTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
          activeTextures.push(gl.COLOR_ATTACHMENT0 + i);
        }
        if (activeTextures.length > 1) {
          gl.drawBuffers(activeTextures);
        }
        if (framebuffer.depthTexture) {
          var writeDepthTexture = this.writeDepthTexture;
          if (writeDepthTexture) {
            var depthTexture = framebuffer.depthTexture;
            this.renderer.texture.bind(depthTexture, 0);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
          }
        }
        if ((framebuffer.stencil || framebuffer.depth) && !(framebuffer.depthTexture && this.writeDepthTexture)) {
          fbo.stencil = fbo.stencil || gl.createRenderbuffer();
          gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
          if (fbo.msaaBuffer) {
            gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
          } else {
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
          }
          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, fbo.stencil);
        } else if (fbo.stencil) {
          gl.deleteRenderbuffer(fbo.stencil);
          fbo.stencil = null;
        }
      };
      FramebufferSystem3.prototype.canMultisampleFramebuffer = function(framebuffer) {
        return this.renderer.context.webGLVersion !== 1 && framebuffer.colorTextures.length <= 1 && !framebuffer.depthTexture;
      };
      FramebufferSystem3.prototype.detectSamples = function(samples) {
        var msaaSamples = this.msaaSamples;
        var res = MSAA_QUALITY.NONE;
        if (samples <= 1 || msaaSamples === null) {
          return res;
        }
        for (var i = 0; i < msaaSamples.length; i++) {
          if (msaaSamples[i] <= samples) {
            res = msaaSamples[i];
            break;
          }
        }
        if (res === 1) {
          res = MSAA_QUALITY.NONE;
        }
        return res;
      };
      FramebufferSystem3.prototype.blit = function(framebuffer, sourcePixels, destPixels) {
        var _a2 = this, current = _a2.current, renderer = _a2.renderer, gl = _a2.gl, CONTEXT_UID = _a2.CONTEXT_UID;
        if (renderer.context.webGLVersion !== 2) {
          return;
        }
        if (!current) {
          return;
        }
        var fbo = current.glFramebuffers[CONTEXT_UID];
        if (!fbo) {
          return;
        }
        if (!framebuffer) {
          if (!fbo.msaaBuffer) {
            return;
          }
          var colorTexture = current.colorTextures[0];
          if (!colorTexture) {
            return;
          }
          if (!fbo.blitFramebuffer) {
            fbo.blitFramebuffer = new Framebuffer(current.width, current.height);
            fbo.blitFramebuffer.addColorTexture(0, colorTexture);
          }
          framebuffer = fbo.blitFramebuffer;
          if (framebuffer.colorTextures[0] !== colorTexture) {
            framebuffer.colorTextures[0] = colorTexture;
            framebuffer.dirtyId++;
            framebuffer.dirtyFormat++;
          }
          if (framebuffer.width !== current.width || framebuffer.height !== current.height) {
            framebuffer.width = current.width;
            framebuffer.height = current.height;
            framebuffer.dirtyId++;
            framebuffer.dirtySize++;
          }
        }
        if (!sourcePixels) {
          sourcePixels = tempRectangle;
          sourcePixels.width = current.width;
          sourcePixels.height = current.height;
        }
        if (!destPixels) {
          destPixels = sourcePixels;
        }
        var sameSize = sourcePixels.width === destPixels.width && sourcePixels.height === destPixels.height;
        this.bind(framebuffer);
        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo.framebuffer);
        gl.blitFramebuffer(sourcePixels.left, sourcePixels.top, sourcePixels.right, sourcePixels.bottom, destPixels.left, destPixels.top, destPixels.right, destPixels.bottom, gl.COLOR_BUFFER_BIT, sameSize ? gl.NEAREST : gl.LINEAR);
      };
      FramebufferSystem3.prototype.disposeFramebuffer = function(framebuffer, contextLost) {
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        var gl = this.gl;
        if (!fbo) {
          return;
        }
        delete framebuffer.glFramebuffers[this.CONTEXT_UID];
        var index = this.managedFramebuffers.indexOf(framebuffer);
        if (index >= 0) {
          this.managedFramebuffers.splice(index, 1);
        }
        framebuffer.disposeRunner.remove(this);
        if (!contextLost) {
          gl.deleteFramebuffer(fbo.framebuffer);
          if (fbo.msaaBuffer) {
            gl.deleteRenderbuffer(fbo.msaaBuffer);
          }
          if (fbo.stencil) {
            gl.deleteRenderbuffer(fbo.stencil);
          }
        }
        if (fbo.blitFramebuffer) {
          fbo.blitFramebuffer.dispose();
        }
      };
      FramebufferSystem3.prototype.disposeAll = function(contextLost) {
        var list = this.managedFramebuffers;
        this.managedFramebuffers = [];
        for (var i = 0; i < list.length; i++) {
          this.disposeFramebuffer(list[i], contextLost);
        }
      };
      FramebufferSystem3.prototype.forceStencil = function() {
        var framebuffer = this.current;
        if (!framebuffer) {
          return;
        }
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        if (!fbo || fbo.stencil) {
          return;
        }
        framebuffer.stencil = true;
        var w = framebuffer.width;
        var h = framebuffer.height;
        var gl = this.gl;
        var stencil = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);
        if (fbo.msaaBuffer) {
          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, w, h);
        } else {
          gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, w, h);
        }
        fbo.stencil = stencil;
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, stencil);
      };
      FramebufferSystem3.prototype.reset = function() {
        this.current = this.unknownFramebuffer;
        this.viewport = new Rectangle();
      };
      FramebufferSystem3.prototype.destroy = function() {
        this.renderer = null;
      };
      return FramebufferSystem3;
    }()
  );
  var byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
  var GeometrySystem = (
    /** @class */
    function() {
      function GeometrySystem3(renderer) {
        this.renderer = renderer;
        this._activeGeometry = null;
        this._activeVao = null;
        this.hasVao = true;
        this.hasInstance = true;
        this.canUseUInt32ElementIndex = false;
        this.managedGeometries = {};
      }
      GeometrySystem3.prototype.contextChange = function() {
        this.disposeAll(true);
        var gl = this.gl = this.renderer.gl;
        var context3 = this.renderer.context;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        if (context3.webGLVersion !== 2) {
          var nativeVaoExtension_1 = this.renderer.context.extensions.vertexArrayObject;
          if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
            nativeVaoExtension_1 = null;
          }
          if (nativeVaoExtension_1) {
            gl.createVertexArray = function() {
              return nativeVaoExtension_1.createVertexArrayOES();
            };
            gl.bindVertexArray = function(vao) {
              return nativeVaoExtension_1.bindVertexArrayOES(vao);
            };
            gl.deleteVertexArray = function(vao) {
              return nativeVaoExtension_1.deleteVertexArrayOES(vao);
            };
          } else {
            this.hasVao = false;
            gl.createVertexArray = function() {
              return null;
            };
            gl.bindVertexArray = function() {
              return null;
            };
            gl.deleteVertexArray = function() {
              return null;
            };
          }
        }
        if (context3.webGLVersion !== 2) {
          var instanceExt_1 = gl.getExtension("ANGLE_instanced_arrays");
          if (instanceExt_1) {
            gl.vertexAttribDivisor = function(a, b) {
              return instanceExt_1.vertexAttribDivisorANGLE(a, b);
            };
            gl.drawElementsInstanced = function(a, b, c, d, e) {
              return instanceExt_1.drawElementsInstancedANGLE(a, b, c, d, e);
            };
            gl.drawArraysInstanced = function(a, b, c, d) {
              return instanceExt_1.drawArraysInstancedANGLE(a, b, c, d);
            };
          } else {
            this.hasInstance = false;
          }
        }
        this.canUseUInt32ElementIndex = context3.webGLVersion === 2 || !!context3.extensions.uint32ElementIndex;
      };
      GeometrySystem3.prototype.bind = function(geometry, shader) {
        shader = shader || this.renderer.shader.shader;
        var gl = this.gl;
        var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
        var incRefCount = false;
        if (!vaos) {
          this.managedGeometries[geometry.id] = geometry;
          geometry.disposeRunner.add(this);
          geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};
          incRefCount = true;
        }
        var vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);
        this._activeGeometry = geometry;
        if (this._activeVao !== vao) {
          this._activeVao = vao;
          if (this.hasVao) {
            gl.bindVertexArray(vao);
          } else {
            this.activateVao(geometry, shader.program);
          }
        }
        this.updateBuffers();
      };
      GeometrySystem3.prototype.reset = function() {
        this.unbind();
      };
      GeometrySystem3.prototype.updateBuffers = function() {
        var geometry = this._activeGeometry;
        var bufferSystem = this.renderer.buffer;
        for (var i = 0; i < geometry.buffers.length; i++) {
          var buffer = geometry.buffers[i];
          bufferSystem.update(buffer);
        }
      };
      GeometrySystem3.prototype.checkCompatibility = function(geometry, program) {
        var geometryAttributes = geometry.attributes;
        var shaderAttributes = program.attributeData;
        for (var j in shaderAttributes) {
          if (!geometryAttributes[j]) {
            throw new Error('shader and geometry incompatible, geometry missing the "' + j + '" attribute');
          }
        }
      };
      GeometrySystem3.prototype.getSignature = function(geometry, program) {
        var attribs = geometry.attributes;
        var shaderAttributes = program.attributeData;
        var strings = ["g", geometry.id];
        for (var i in attribs) {
          if (shaderAttributes[i]) {
            strings.push(i, shaderAttributes[i].location);
          }
        }
        return strings.join("-");
      };
      GeometrySystem3.prototype.initGeometryVao = function(geometry, shader, incRefCount) {
        if (incRefCount === void 0) {
          incRefCount = true;
        }
        var gl = this.gl;
        var CONTEXT_UID = this.CONTEXT_UID;
        var bufferSystem = this.renderer.buffer;
        var program = shader.program;
        if (!program.glPrograms[CONTEXT_UID]) {
          this.renderer.shader.generateProgram(shader);
        }
        this.checkCompatibility(geometry, program);
        var signature = this.getSignature(geometry, program);
        var vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];
        var vao = vaoObjectHash[signature];
        if (vao) {
          vaoObjectHash[program.id] = vao;
          return vao;
        }
        var buffers = geometry.buffers;
        var attributes = geometry.attributes;
        var tempStride = {};
        var tempStart = {};
        for (var j in buffers) {
          tempStride[j] = 0;
          tempStart[j] = 0;
        }
        for (var j in attributes) {
          if (!attributes[j].size && program.attributeData[j]) {
            attributes[j].size = program.attributeData[j].size;
          } else if (!attributes[j].size) {
            console.warn("PIXI Geometry attribute '" + j + "' size cannot be determined (likely the bound shader does not have the attribute)");
          }
          tempStride[attributes[j].buffer] += attributes[j].size * byteSizeMap[attributes[j].type];
        }
        for (var j in attributes) {
          var attribute = attributes[j];
          var attribSize = attribute.size;
          if (attribute.stride === void 0) {
            if (tempStride[attribute.buffer] === attribSize * byteSizeMap[attribute.type]) {
              attribute.stride = 0;
            } else {
              attribute.stride = tempStride[attribute.buffer];
            }
          }
          if (attribute.start === void 0) {
            attribute.start = tempStart[attribute.buffer];
            tempStart[attribute.buffer] += attribSize * byteSizeMap[attribute.type];
          }
        }
        vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        for (var i = 0; i < buffers.length; i++) {
          var buffer = buffers[i];
          bufferSystem.bind(buffer);
          if (incRefCount) {
            buffer._glBuffers[CONTEXT_UID].refCount++;
          }
        }
        this.activateVao(geometry, program);
        this._activeVao = vao;
        vaoObjectHash[program.id] = vao;
        vaoObjectHash[signature] = vao;
        return vao;
      };
      GeometrySystem3.prototype.disposeGeometry = function(geometry, contextLost) {
        var _a2;
        if (!this.managedGeometries[geometry.id]) {
          return;
        }
        delete this.managedGeometries[geometry.id];
        var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
        var gl = this.gl;
        var buffers = geometry.buffers;
        var bufferSystem = (_a2 = this.renderer) === null || _a2 === void 0 ? void 0 : _a2.buffer;
        geometry.disposeRunner.remove(this);
        if (!vaos) {
          return;
        }
        if (bufferSystem) {
          for (var i = 0; i < buffers.length; i++) {
            var buf = buffers[i]._glBuffers[this.CONTEXT_UID];
            if (buf) {
              buf.refCount--;
              if (buf.refCount === 0 && !contextLost) {
                bufferSystem.dispose(buffers[i], contextLost);
              }
            }
          }
        }
        if (!contextLost) {
          for (var vaoId in vaos) {
            if (vaoId[0] === "g") {
              var vao = vaos[vaoId];
              if (this._activeVao === vao) {
                this.unbind();
              }
              gl.deleteVertexArray(vao);
            }
          }
        }
        delete geometry.glVertexArrayObjects[this.CONTEXT_UID];
      };
      GeometrySystem3.prototype.disposeAll = function(contextLost) {
        var all = Object.keys(this.managedGeometries);
        for (var i = 0; i < all.length; i++) {
          this.disposeGeometry(this.managedGeometries[all[i]], contextLost);
        }
      };
      GeometrySystem3.prototype.activateVao = function(geometry, program) {
        var gl = this.gl;
        var CONTEXT_UID = this.CONTEXT_UID;
        var bufferSystem = this.renderer.buffer;
        var buffers = geometry.buffers;
        var attributes = geometry.attributes;
        if (geometry.indexBuffer) {
          bufferSystem.bind(geometry.indexBuffer);
        }
        var lastBuffer = null;
        for (var j in attributes) {
          var attribute = attributes[j];
          var buffer = buffers[attribute.buffer];
          var glBuffer = buffer._glBuffers[CONTEXT_UID];
          if (program.attributeData[j]) {
            if (lastBuffer !== glBuffer) {
              bufferSystem.bind(buffer);
              lastBuffer = glBuffer;
            }
            var location = program.attributeData[j].location;
            gl.enableVertexAttribArray(location);
            gl.vertexAttribPointer(location, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);
            if (attribute.instance) {
              if (this.hasInstance) {
                gl.vertexAttribDivisor(location, 1);
              } else {
                throw new Error("geometry error, GPU Instancing is not supported on this device");
              }
            }
          }
        }
      };
      GeometrySystem3.prototype.draw = function(type, size, start, instanceCount) {
        var gl = this.gl;
        var geometry = this._activeGeometry;
        if (geometry.indexBuffer) {
          var byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
          var glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
          if (byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex) {
            if (geometry.instanced) {
              gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1);
            } else {
              gl.drawElements(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
            }
          } else {
            console.warn("unsupported index buffer type: uint32");
          }
        } else if (geometry.instanced) {
          gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1);
        } else {
          gl.drawArrays(type, start, size || geometry.getSize());
        }
        return this;
      };
      GeometrySystem3.prototype.unbind = function() {
        this.gl.bindVertexArray(null);
        this._activeVao = null;
        this._activeGeometry = null;
      };
      GeometrySystem3.prototype.destroy = function() {
        this.renderer = null;
      };
      return GeometrySystem3;
    }()
  );
  var MaskData = (
    /** @class */
    function() {
      function MaskData3(maskObject) {
        if (maskObject === void 0) {
          maskObject = null;
        }
        this.type = MASK_TYPES.NONE;
        this.autoDetect = true;
        this.maskObject = maskObject || null;
        this.pooled = false;
        this.isMaskData = true;
        this.resolution = null;
        this.multisample = settings.FILTER_MULTISAMPLE;
        this.enabled = true;
        this._filters = null;
        this._stencilCounter = 0;
        this._scissorCounter = 0;
        this._scissorRect = null;
        this._scissorRectLocal = null;
        this._target = null;
      }
      Object.defineProperty(MaskData3.prototype, "filter", {
        /**
         * The sprite mask filter.
         * If set to `null`, the default sprite mask filter is used.
         * @default null
         */
        get: function() {
          return this._filters ? this._filters[0] : null;
        },
        set: function(value) {
          if (value) {
            if (this._filters) {
              this._filters[0] = value;
            } else {
              this._filters = [value];
            }
          } else {
            this._filters = null;
          }
        },
        enumerable: false,
        configurable: true
      });
      MaskData3.prototype.reset = function() {
        if (this.pooled) {
          this.maskObject = null;
          this.type = MASK_TYPES.NONE;
          this.autoDetect = true;
        }
        this._target = null;
        this._scissorRectLocal = null;
      };
      MaskData3.prototype.copyCountersOrReset = function(maskAbove) {
        if (maskAbove) {
          this._stencilCounter = maskAbove._stencilCounter;
          this._scissorCounter = maskAbove._scissorCounter;
          this._scissorRect = maskAbove._scissorRect;
        } else {
          this._stencilCounter = 0;
          this._scissorCounter = 0;
          this._scissorRect = null;
        }
      };
      return MaskData3;
    }()
  );
  function compileShader(gl, type, src) {
    var shader = gl.createShader(type);
    gl.shaderSource(shader, src);
    gl.compileShader(shader);
    return shader;
  }
  function logPrettyShaderError(gl, shader) {
    var shaderSrc = gl.getShaderSource(shader).split("\n").map(function(line, index) {
      return index + ": " + line;
    });
    var shaderLog = gl.getShaderInfoLog(shader);
    var splitShader = shaderLog.split("\n");
    var dedupe = {};
    var lineNumbers = splitShader.map(function(line) {
      return parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"));
    }).filter(function(n) {
      if (n && !dedupe[n]) {
        dedupe[n] = true;
        return true;
      }
      return false;
    });
    var logArgs = [""];
    lineNumbers.forEach(function(number) {
      shaderSrc[number - 1] = "%c" + shaderSrc[number - 1] + "%c";
      logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
    });
    var fragmentSourceToLog = shaderSrc.join("\n");
    logArgs[0] = fragmentSourceToLog;
    console.error(shaderLog);
    console.groupCollapsed("click to view full shader code");
    console.warn.apply(console, logArgs);
    console.groupEnd();
  }
  function logProgramError(gl, program, vertexShader, fragmentShader) {
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        logPrettyShaderError(gl, vertexShader);
      }
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        logPrettyShaderError(gl, fragmentShader);
      }
      console.error("PixiJS Error: Could not initialize shader.");
      if (gl.getProgramInfoLog(program) !== "") {
        console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
      }
    }
  }
  function booleanArray(size) {
    var array = new Array(size);
    for (var i = 0; i < array.length; i++) {
      array[i] = false;
    }
    return array;
  }
  function defaultValue(type, size) {
    switch (type) {
      case "float":
        return 0;
      case "vec2":
        return new Float32Array(2 * size);
      case "vec3":
        return new Float32Array(3 * size);
      case "vec4":
        return new Float32Array(4 * size);
      case "int":
      case "uint":
      case "sampler2D":
      case "sampler2DArray":
        return 0;
      case "ivec2":
        return new Int32Array(2 * size);
      case "ivec3":
        return new Int32Array(3 * size);
      case "ivec4":
        return new Int32Array(4 * size);
      case "uvec2":
        return new Uint32Array(2 * size);
      case "uvec3":
        return new Uint32Array(3 * size);
      case "uvec4":
        return new Uint32Array(4 * size);
      case "bool":
        return false;
      case "bvec2":
        return booleanArray(2 * size);
      case "bvec3":
        return booleanArray(3 * size);
      case "bvec4":
        return booleanArray(4 * size);
      case "mat2":
        return new Float32Array([
          1,
          0,
          0,
          1
        ]);
      case "mat3":
        return new Float32Array([
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ]);
      case "mat4":
        return new Float32Array([
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
    }
    return null;
  }
  var unknownContext = {};
  var context = unknownContext;
  function getTestContext() {
    if (context === unknownContext || context && context.isContextLost()) {
      var canvas = document.createElement("canvas");
      var gl = void 0;
      if (settings.PREFER_ENV >= ENV.WEBGL2) {
        gl = canvas.getContext("webgl2", {});
      }
      if (!gl) {
        gl = canvas.getContext("webgl", {}) || canvas.getContext("experimental-webgl", {});
        if (!gl) {
          gl = null;
        } else {
          gl.getExtension("WEBGL_draw_buffers");
        }
      }
      context = gl;
    }
    return context;
  }
  var maxFragmentPrecision;
  function getMaxFragmentPrecision() {
    if (!maxFragmentPrecision) {
      maxFragmentPrecision = PRECISION.MEDIUM;
      var gl = getTestContext();
      if (gl) {
        if (gl.getShaderPrecisionFormat) {
          var shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
          maxFragmentPrecision = shaderFragment.precision ? PRECISION.HIGH : PRECISION.MEDIUM;
        }
      }
    }
    return maxFragmentPrecision;
  }
  function setPrecision(src, requestedPrecision, maxSupportedPrecision) {
    if (src.substring(0, 9) !== "precision") {
      var precision = requestedPrecision;
      if (requestedPrecision === PRECISION.HIGH && maxSupportedPrecision !== PRECISION.HIGH) {
        precision = PRECISION.MEDIUM;
      }
      return "precision " + precision + " float;\n" + src;
    } else if (maxSupportedPrecision !== PRECISION.HIGH && src.substring(0, 15) === "precision highp") {
      return src.replace("precision highp", "precision mediump");
    }
    return src;
  }
  var GLSL_TO_SIZE = {
    float: 1,
    vec2: 2,
    vec3: 3,
    vec4: 4,
    int: 1,
    ivec2: 2,
    ivec3: 3,
    ivec4: 4,
    uint: 1,
    uvec2: 2,
    uvec3: 3,
    uvec4: 4,
    bool: 1,
    bvec2: 2,
    bvec3: 3,
    bvec4: 4,
    mat2: 4,
    mat3: 9,
    mat4: 16,
    sampler2D: 1
  };
  function mapSize(type) {
    return GLSL_TO_SIZE[type];
  }
  var GL_TABLE = null;
  var GL_TO_GLSL_TYPES = {
    FLOAT: "float",
    FLOAT_VEC2: "vec2",
    FLOAT_VEC3: "vec3",
    FLOAT_VEC4: "vec4",
    INT: "int",
    INT_VEC2: "ivec2",
    INT_VEC3: "ivec3",
    INT_VEC4: "ivec4",
    UNSIGNED_INT: "uint",
    UNSIGNED_INT_VEC2: "uvec2",
    UNSIGNED_INT_VEC3: "uvec3",
    UNSIGNED_INT_VEC4: "uvec4",
    BOOL: "bool",
    BOOL_VEC2: "bvec2",
    BOOL_VEC3: "bvec3",
    BOOL_VEC4: "bvec4",
    FLOAT_MAT2: "mat2",
    FLOAT_MAT3: "mat3",
    FLOAT_MAT4: "mat4",
    SAMPLER_2D: "sampler2D",
    INT_SAMPLER_2D: "sampler2D",
    UNSIGNED_INT_SAMPLER_2D: "sampler2D",
    SAMPLER_CUBE: "samplerCube",
    INT_SAMPLER_CUBE: "samplerCube",
    UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
    SAMPLER_2D_ARRAY: "sampler2DArray",
    INT_SAMPLER_2D_ARRAY: "sampler2DArray",
    UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
  };
  function mapType(gl, type) {
    if (!GL_TABLE) {
      var typeNames = Object.keys(GL_TO_GLSL_TYPES);
      GL_TABLE = {};
      for (var i = 0; i < typeNames.length; ++i) {
        var tn = typeNames[i];
        GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
      }
    }
    return GL_TABLE[type];
  }
  var uniformParsers = [
    // a float cache layer
    {
      test: function(data) {
        return data.type === "float" && data.size === 1;
      },
      code: function(name) {
        return '\n            if(uv["' + name + '"] !== ud["' + name + '"].value)\n            {\n                ud["' + name + '"].value = uv["' + name + '"]\n                gl.uniform1f(ud["' + name + '"].location, uv["' + name + '"])\n            }\n            ';
      }
    },
    // handling samplers
    {
      test: function(data) {
        return (data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray;
      },
      code: function(name) {
        return 't = syncData.textureCount++;\n\n            renderer.texture.bind(uv["' + name + '"], t);\n\n            if(ud["' + name + '"].value !== t)\n            {\n                ud["' + name + '"].value = t;\n                gl.uniform1i(ud["' + name + '"].location, t);\n; // eslint-disable-line max-len\n            }';
      }
    },
    // uploading pixi matrix object to mat3
    {
      test: function(data, uniform) {
        return data.type === "mat3" && data.size === 1 && uniform.a !== void 0;
      },
      code: function(name) {
        return '\n            gl.uniformMatrix3fv(ud["' + name + '"].location, false, uv["' + name + '"].toArray(true));\n            ';
      },
      codeUbo: function(name) {
        return "\n                var " + name + "_matrix = uv." + name + ".toArray(true);\n\n                data[offset] = " + name + "_matrix[0];\n                data[offset+1] = " + name + "_matrix[1];\n                data[offset+2] = " + name + "_matrix[2];\n        \n                data[offset + 4] = " + name + "_matrix[3];\n                data[offset + 5] = " + name + "_matrix[4];\n                data[offset + 6] = " + name + "_matrix[5];\n        \n                data[offset + 8] = " + name + "_matrix[6];\n                data[offset + 9] = " + name + "_matrix[7];\n                data[offset + 10] = " + name + "_matrix[8];\n            ";
      }
    },
    // uploading a pixi point as a vec2 with caching layer
    {
      test: function(data, uniform) {
        return data.type === "vec2" && data.size === 1 && uniform.x !== void 0;
      },
      code: function(name) {
        return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["' + name + '"].location, v.x, v.y);\n                }';
      },
      codeUbo: function(name) {
        return "\n                v = uv." + name + ";\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            ";
      }
    },
    // caching layer for a vec2
    {
      test: function(data) {
        return data.type === "vec2" && data.size === 1;
      },
      code: function(name) {
        return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["' + name + '"].location, v[0], v[1]);\n                }\n            ';
      }
    },
    // upload a pixi rectangle as a vec4 with caching layer
    {
      test: function(data, uniform) {
        return data.type === "vec4" && data.size === 1 && uniform.width !== void 0;
      },
      code: function(name) {
        return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["' + name + '"].location, v.x, v.y, v.width, v.height)\n                }';
      },
      codeUbo: function(name) {
        return "\n                    v = uv." + name + ";\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                ";
      }
    },
    // a caching layer for vec4 uploading
    {
      test: function(data) {
        return data.type === "vec4" && data.size === 1;
      },
      code: function(name) {
        return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["' + name + '"].location, v[0], v[1], v[2], v[3])\n                }';
      }
    }
  ];
  var GLSL_TO_SINGLE_SETTERS_CACHED = {
    float: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }",
    vec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }",
    vec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }",
    vec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }",
    int: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }",
    ivec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }",
    ivec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }",
    ivec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }",
    uint: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }",
    uvec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }",
    uvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }",
    uvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }",
    bool: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }",
    bvec2: "\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }",
    bvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }",
    bvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }",
    mat2: "gl.uniformMatrix2fv(location, false, v)",
    mat3: "gl.uniformMatrix3fv(location, false, v)",
    mat4: "gl.uniformMatrix4fv(location, false, v)",
    sampler2D: "gl.uniform1i(location, v)",
    samplerCube: "gl.uniform1i(location, v)",
    sampler2DArray: "gl.uniform1i(location, v)"
  };
  var GLSL_TO_ARRAY_SETTERS = {
    float: "gl.uniform1fv(location, v)",
    vec2: "gl.uniform2fv(location, v)",
    vec3: "gl.uniform3fv(location, v)",
    vec4: "gl.uniform4fv(location, v)",
    mat4: "gl.uniformMatrix4fv(location, false, v)",
    mat3: "gl.uniformMatrix3fv(location, false, v)",
    mat2: "gl.uniformMatrix2fv(location, false, v)",
    int: "gl.uniform1iv(location, v)",
    ivec2: "gl.uniform2iv(location, v)",
    ivec3: "gl.uniform3iv(location, v)",
    ivec4: "gl.uniform4iv(location, v)",
    uint: "gl.uniform1uiv(location, v)",
    uvec2: "gl.uniform2uiv(location, v)",
    uvec3: "gl.uniform3uiv(location, v)",
    uvec4: "gl.uniform4uiv(location, v)",
    bool: "gl.uniform1iv(location, v)",
    bvec2: "gl.uniform2iv(location, v)",
    bvec3: "gl.uniform3iv(location, v)",
    bvec4: "gl.uniform4iv(location, v)",
    sampler2D: "gl.uniform1iv(location, v)",
    samplerCube: "gl.uniform1iv(location, v)",
    sampler2DArray: "gl.uniform1iv(location, v)"
  };
  function generateUniformsSync(group, uniformData) {
    var _a2;
    var funcFragments = ["\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    "];
    for (var i in group.uniforms) {
      var data = uniformData[i];
      if (!data) {
        if ((_a2 = group.uniforms[i]) === null || _a2 === void 0 ? void 0 : _a2.group) {
          if (group.uniforms[i].ubo) {
            funcFragments.push("\n                        renderer.shader.syncUniformBufferGroup(uv." + i + ", '" + i + "');\n                    ");
          } else {
            funcFragments.push("\n                        renderer.shader.syncUniformGroup(uv." + i + ", syncData);\n                    ");
          }
        }
        continue;
      }
      var uniform = group.uniforms[i];
      var parsed = false;
      for (var j = 0; j < uniformParsers.length; j++) {
        if (uniformParsers[j].test(data, uniform)) {
          funcFragments.push(uniformParsers[j].code(i, uniform));
          parsed = true;
          break;
        }
      }
      if (!parsed) {
        var templateType = data.size === 1 ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS;
        var template = templateType[data.type].replace("location", 'ud["' + i + '"].location');
        funcFragments.push('\n            cu = ud["' + i + '"];\n            cv = cu.value;\n            v = uv["' + i + '"];\n            ' + template + ";");
      }
    }
    return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
  }
  var fragTemplate = [
    "precision mediump float;",
    "void main(void){",
    "float test = 0.1;",
    "%forloop%",
    "gl_FragColor = vec4(0.0);",
    "}"
  ].join("\n");
  function generateIfTestSrc(maxIfs) {
    var src = "";
    for (var i = 0; i < maxIfs; ++i) {
      if (i > 0) {
        src += "\nelse ";
      }
      if (i < maxIfs - 1) {
        src += "if(test == " + i + ".0){}";
      }
    }
    return src;
  }
  function checkMaxIfStatementsInShader(maxIfs, gl) {
    if (maxIfs === 0) {
      throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
    }
    var shader = gl.createShader(gl.FRAGMENT_SHADER);
    while (true) {
      var fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
      gl.shaderSource(shader, fragmentSrc);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        maxIfs = maxIfs / 2 | 0;
      } else {
        break;
      }
    }
    return maxIfs;
  }
  var unsafeEval;
  function unsafeEvalSupported() {
    if (typeof unsafeEval === "boolean") {
      return unsafeEval;
    }
    try {
      var func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
      unsafeEval = func({ a: "b" }, "a", "b") === true;
    } catch (e) {
      unsafeEval = false;
    }
    return unsafeEval;
  }
  var defaultFragment$2 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}";
  var defaultVertex$3 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n";
  var UID$1 = 0;
  var nameCache = {};
  var Program = (
    /** @class */
    function() {
      function Program3(vertexSrc, fragmentSrc, name) {
        if (name === void 0) {
          name = "pixi-shader";
        }
        this.id = UID$1++;
        this.vertexSrc = vertexSrc || Program3.defaultVertexSrc;
        this.fragmentSrc = fragmentSrc || Program3.defaultFragmentSrc;
        this.vertexSrc = this.vertexSrc.trim();
        this.fragmentSrc = this.fragmentSrc.trim();
        if (this.vertexSrc.substring(0, 8) !== "#version") {
          name = name.replace(/\s+/g, "-");
          if (nameCache[name]) {
            nameCache[name]++;
            name += "-" + nameCache[name];
          } else {
            nameCache[name] = 1;
          }
          this.vertexSrc = "#define SHADER_NAME " + name + "\n" + this.vertexSrc;
          this.fragmentSrc = "#define SHADER_NAME " + name + "\n" + this.fragmentSrc;
          this.vertexSrc = setPrecision(this.vertexSrc, settings.PRECISION_VERTEX, PRECISION.HIGH);
          this.fragmentSrc = setPrecision(this.fragmentSrc, settings.PRECISION_FRAGMENT, getMaxFragmentPrecision());
        }
        this.glPrograms = {};
        this.syncUniforms = null;
      }
      Object.defineProperty(Program3, "defaultVertexSrc", {
        /**
         * The default vertex shader source.
         * @constant
         */
        get: function() {
          return defaultVertex$3;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Program3, "defaultFragmentSrc", {
        /**
         * The default fragment shader source.
         * @constant
         */
        get: function() {
          return defaultFragment$2;
        },
        enumerable: false,
        configurable: true
      });
      Program3.from = function(vertexSrc, fragmentSrc, name) {
        var key = vertexSrc + fragmentSrc;
        var program = ProgramCache[key];
        if (!program) {
          ProgramCache[key] = program = new Program3(vertexSrc, fragmentSrc, name);
        }
        return program;
      };
      return Program3;
    }()
  );
  var Shader = (
    /** @class */
    function() {
      function Shader3(program, uniforms) {
        this.uniformBindCount = 0;
        this.program = program;
        if (uniforms) {
          if (uniforms instanceof UniformGroup) {
            this.uniformGroup = uniforms;
          } else {
            this.uniformGroup = new UniformGroup(uniforms);
          }
        } else {
          this.uniformGroup = new UniformGroup({});
        }
      }
      Shader3.prototype.checkUniformExists = function(name, group) {
        if (group.uniforms[name]) {
          return true;
        }
        for (var i in group.uniforms) {
          var uniform = group.uniforms[i];
          if (uniform.group) {
            if (this.checkUniformExists(name, uniform)) {
              return true;
            }
          }
        }
        return false;
      };
      Shader3.prototype.destroy = function() {
        this.uniformGroup = null;
      };
      Object.defineProperty(Shader3.prototype, "uniforms", {
        /**
         * Shader uniform values, shortcut for `uniformGroup.uniforms`.
         * @readonly
         */
        get: function() {
          return this.uniformGroup.uniforms;
        },
        enumerable: false,
        configurable: true
      });
      Shader3.from = function(vertexSrc, fragmentSrc, uniforms) {
        var program = Program.from(vertexSrc, fragmentSrc);
        return new Shader3(program, uniforms);
      };
      return Shader3;
    }()
  );
  var BLEND$1 = 0;
  var OFFSET$1 = 1;
  var CULLING$1 = 2;
  var DEPTH_TEST$1 = 3;
  var WINDING$1 = 4;
  var DEPTH_MASK$1 = 5;
  var State = (
    /** @class */
    function() {
      function State3() {
        this.data = 0;
        this.blendMode = BLEND_MODES.NORMAL;
        this.polygonOffset = 0;
        this.blend = true;
        this.depthMask = true;
      }
      Object.defineProperty(State3.prototype, "blend", {
        /**
         * Activates blending of the computed fragment color values.
         * @default true
         */
        get: function() {
          return !!(this.data & 1 << BLEND$1);
        },
        set: function(value) {
          if (!!(this.data & 1 << BLEND$1) !== value) {
            this.data ^= 1 << BLEND$1;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State3.prototype, "offsets", {
        /**
         * Activates adding an offset to depth values of polygon's fragments
         * @default false
         */
        get: function() {
          return !!(this.data & 1 << OFFSET$1);
        },
        set: function(value) {
          if (!!(this.data & 1 << OFFSET$1) !== value) {
            this.data ^= 1 << OFFSET$1;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State3.prototype, "culling", {
        /**
         * Activates culling of polygons.
         * @default false
         */
        get: function() {
          return !!(this.data & 1 << CULLING$1);
        },
        set: function(value) {
          if (!!(this.data & 1 << CULLING$1) !== value) {
            this.data ^= 1 << CULLING$1;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State3.prototype, "depthTest", {
        /**
         * Activates depth comparisons and updates to the depth buffer.
         * @default false
         */
        get: function() {
          return !!(this.data & 1 << DEPTH_TEST$1);
        },
        set: function(value) {
          if (!!(this.data & 1 << DEPTH_TEST$1) !== value) {
            this.data ^= 1 << DEPTH_TEST$1;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State3.prototype, "depthMask", {
        /**
         * Enables or disables writing to the depth buffer.
         * @default true
         */
        get: function() {
          return !!(this.data & 1 << DEPTH_MASK$1);
        },
        set: function(value) {
          if (!!(this.data & 1 << DEPTH_MASK$1) !== value) {
            this.data ^= 1 << DEPTH_MASK$1;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State3.prototype, "clockwiseFrontFace", {
        /**
         * Specifies whether or not front or back-facing polygons can be culled.
         * @default false
         */
        get: function() {
          return !!(this.data & 1 << WINDING$1);
        },
        set: function(value) {
          if (!!(this.data & 1 << WINDING$1) !== value) {
            this.data ^= 1 << WINDING$1;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State3.prototype, "blendMode", {
        /**
         * The blend mode to be applied when this state is set. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
         * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
         * @default PIXI.BLEND_MODES.NORMAL
         */
        get: function() {
          return this._blendMode;
        },
        set: function(value) {
          this.blend = value !== BLEND_MODES.NONE;
          this._blendMode = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State3.prototype, "polygonOffset", {
        /**
         * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
         * @default 0
         */
        get: function() {
          return this._polygonOffset;
        },
        set: function(value) {
          this.offsets = !!value;
          this._polygonOffset = value;
        },
        enumerable: false,
        configurable: true
      });
      State3.prototype.toString = function() {
        return "[@pixi/core:State " + ("blendMode=" + this.blendMode + " ") + ("clockwiseFrontFace=" + this.clockwiseFrontFace + " ") + ("culling=" + this.culling + " ") + ("depthMask=" + this.depthMask + " ") + ("polygonOffset=" + this.polygonOffset) + "]";
      };
      State3.for2d = function() {
        var state = new State3();
        state.depthTest = false;
        state.blend = true;
        return state;
      };
      return State3;
    }()
  );
  var defaultVertex$2 = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
  var defaultFragment$1 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n";
  var Filter = (
    /** @class */
    function(_super) {
      __extends2(Filter3, _super);
      function Filter3(vertexSrc, fragmentSrc, uniforms) {
        var _this = this;
        var program = Program.from(vertexSrc || Filter3.defaultVertexSrc, fragmentSrc || Filter3.defaultFragmentSrc);
        _this = _super.call(this, program, uniforms) || this;
        _this.padding = 0;
        _this.resolution = settings.FILTER_RESOLUTION;
        _this.multisample = settings.FILTER_MULTISAMPLE;
        _this.enabled = true;
        _this.autoFit = true;
        _this.state = new State();
        return _this;
      }
      Filter3.prototype.apply = function(filterManager, input, output, clearMode, _currentState) {
        filterManager.applyFilter(this, input, output, clearMode);
      };
      Object.defineProperty(Filter3.prototype, "blendMode", {
        /**
         * Sets the blend mode of the filter.
         * @default PIXI.BLEND_MODES.NORMAL
         */
        get: function() {
          return this.state.blendMode;
        },
        set: function(value) {
          this.state.blendMode = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Filter3.prototype, "resolution", {
        /**
         * The resolution of the filter. Setting this to be lower will lower the quality but
         * increase the performance of the filter.
         */
        get: function() {
          return this._resolution;
        },
        set: function(value) {
          this._resolution = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Filter3, "defaultVertexSrc", {
        /**
         * The default vertex shader source
         * @constant
         */
        get: function() {
          return defaultVertex$2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Filter3, "defaultFragmentSrc", {
        /**
         * The default fragment shader source
         * @constant
         */
        get: function() {
          return defaultFragment$1;
        },
        enumerable: false,
        configurable: true
      });
      return Filter3;
    }(Shader)
  );
  var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n";
  var fragment = "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n";
  var tempMat = new Matrix();
  var TextureMatrix = (
    /** @class */
    function() {
      function TextureMatrix3(texture, clampMargin) {
        this._texture = texture;
        this.mapCoord = new Matrix();
        this.uClampFrame = new Float32Array(4);
        this.uClampOffset = new Float32Array(2);
        this._textureID = -1;
        this._updateID = 0;
        this.clampOffset = 0;
        this.clampMargin = typeof clampMargin === "undefined" ? 0.5 : clampMargin;
        this.isSimple = false;
      }
      Object.defineProperty(TextureMatrix3.prototype, "texture", {
        /** Texture property. */
        get: function() {
          return this._texture;
        },
        set: function(value) {
          this._texture = value;
          this._textureID = -1;
        },
        enumerable: false,
        configurable: true
      });
      TextureMatrix3.prototype.multiplyUvs = function(uvs, out) {
        if (out === void 0) {
          out = uvs;
        }
        var mat = this.mapCoord;
        for (var i = 0; i < uvs.length; i += 2) {
          var x = uvs[i];
          var y = uvs[i + 1];
          out[i] = x * mat.a + y * mat.c + mat.tx;
          out[i + 1] = x * mat.b + y * mat.d + mat.ty;
        }
        return out;
      };
      TextureMatrix3.prototype.update = function(forceUpdate) {
        var tex = this._texture;
        if (!tex || !tex.valid) {
          return false;
        }
        if (!forceUpdate && this._textureID === tex._updateID) {
          return false;
        }
        this._textureID = tex._updateID;
        this._updateID++;
        var uvs = tex._uvs;
        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
        var orig = tex.orig;
        var trim = tex.trim;
        if (trim) {
          tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);
          this.mapCoord.append(tempMat);
        }
        var texBase = tex.baseTexture;
        var frame = this.uClampFrame;
        var margin = this.clampMargin / texBase.resolution;
        var offset = this.clampOffset;
        frame[0] = (tex._frame.x + margin + offset) / texBase.width;
        frame[1] = (tex._frame.y + margin + offset) / texBase.height;
        frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;
        frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;
        this.uClampOffset[0] = offset / texBase.realWidth;
        this.uClampOffset[1] = offset / texBase.realHeight;
        this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0;
        return true;
      };
      return TextureMatrix3;
    }()
  );
  var SpriteMaskFilter = (
    /** @class */
    function(_super) {
      __extends2(SpriteMaskFilter3, _super);
      function SpriteMaskFilter3(vertexSrc, fragmentSrc, uniforms) {
        var _this = this;
        var sprite = null;
        if (typeof vertexSrc !== "string" && fragmentSrc === void 0 && uniforms === void 0) {
          sprite = vertexSrc;
          vertexSrc = void 0;
          fragmentSrc = void 0;
          uniforms = void 0;
        }
        _this = _super.call(this, vertexSrc || vertex, fragmentSrc || fragment, uniforms) || this;
        _this.maskSprite = sprite;
        _this.maskMatrix = new Matrix();
        return _this;
      }
      Object.defineProperty(SpriteMaskFilter3.prototype, "maskSprite", {
        /**
         * Sprite mask
         * @type {PIXI.DisplayObject}
         */
        get: function() {
          return this._maskSprite;
        },
        set: function(value) {
          this._maskSprite = value;
          if (this._maskSprite) {
            this._maskSprite.renderable = false;
          }
        },
        enumerable: false,
        configurable: true
      });
      SpriteMaskFilter3.prototype.apply = function(filterManager, input, output, clearMode) {
        var maskSprite = this._maskSprite;
        var tex = maskSprite._texture;
        if (!tex.valid) {
          return;
        }
        if (!tex.uvMatrix) {
          tex.uvMatrix = new TextureMatrix(tex, 0);
        }
        tex.uvMatrix.update();
        this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0 : 1;
        this.uniforms.mask = tex;
        this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.uvMatrix.mapCoord);
        this.uniforms.alpha = maskSprite.worldAlpha;
        this.uniforms.maskClamp = tex.uvMatrix.uClampFrame;
        filterManager.applyFilter(this, input, output, clearMode);
      };
      return SpriteMaskFilter3;
    }(Filter)
  );
  var MaskSystem = (
    /** @class */
    function() {
      function MaskSystem3(renderer) {
        this.renderer = renderer;
        this.enableScissor = true;
        this.alphaMaskPool = [];
        this.maskDataPool = [];
        this.maskStack = [];
        this.alphaMaskIndex = 0;
      }
      MaskSystem3.prototype.setMaskStack = function(maskStack) {
        this.maskStack = maskStack;
        this.renderer.scissor.setMaskStack(maskStack);
        this.renderer.stencil.setMaskStack(maskStack);
      };
      MaskSystem3.prototype.push = function(target, maskDataOrTarget) {
        var maskData = maskDataOrTarget;
        if (!maskData.isMaskData) {
          var d = this.maskDataPool.pop() || new MaskData();
          d.pooled = true;
          d.maskObject = maskDataOrTarget;
          maskData = d;
        }
        var maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
        maskData.copyCountersOrReset(maskAbove);
        if (maskData.autoDetect) {
          this.detect(maskData);
        }
        maskData._target = target;
        if (maskData.type !== MASK_TYPES.SPRITE) {
          this.maskStack.push(maskData);
        }
        if (maskData.enabled) {
          switch (maskData.type) {
            case MASK_TYPES.SCISSOR:
              this.renderer.scissor.push(maskData);
              break;
            case MASK_TYPES.STENCIL:
              this.renderer.stencil.push(maskData);
              break;
            case MASK_TYPES.SPRITE:
              maskData.copyCountersOrReset(null);
              this.pushSpriteMask(maskData);
              break;
          }
        }
        if (maskData.type === MASK_TYPES.SPRITE) {
          this.maskStack.push(maskData);
        }
      };
      MaskSystem3.prototype.pop = function(target) {
        var maskData = this.maskStack.pop();
        if (!maskData || maskData._target !== target) {
          return;
        }
        if (maskData.enabled) {
          switch (maskData.type) {
            case MASK_TYPES.SCISSOR:
              this.renderer.scissor.pop();
              break;
            case MASK_TYPES.STENCIL:
              this.renderer.stencil.pop(maskData.maskObject);
              break;
            case MASK_TYPES.SPRITE:
              this.popSpriteMask(maskData);
              break;
          }
        }
        maskData.reset();
        if (maskData.pooled) {
          this.maskDataPool.push(maskData);
        }
        if (this.maskStack.length !== 0) {
          var maskCurrent = this.maskStack[this.maskStack.length - 1];
          if (maskCurrent.type === MASK_TYPES.SPRITE && maskCurrent._filters) {
            maskCurrent._filters[0].maskSprite = maskCurrent.maskObject;
          }
        }
      };
      MaskSystem3.prototype.detect = function(maskData) {
        var maskObject = maskData.maskObject;
        if (maskObject.isSprite) {
          maskData.type = MASK_TYPES.SPRITE;
        } else if (this.enableScissor && this.renderer.scissor.testScissor(maskData)) {
          maskData.type = MASK_TYPES.SCISSOR;
        } else {
          maskData.type = MASK_TYPES.STENCIL;
        }
      };
      MaskSystem3.prototype.pushSpriteMask = function(maskData) {
        var _a2, _b;
        var maskObject = maskData.maskObject;
        var target = maskData._target;
        var alphaMaskFilter = maskData._filters;
        if (!alphaMaskFilter) {
          alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];
          if (!alphaMaskFilter) {
            alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()];
          }
        }
        var renderer = this.renderer;
        var renderTextureSystem = renderer.renderTexture;
        var resolution;
        var multisample;
        if (renderTextureSystem.current) {
          var renderTexture = renderTextureSystem.current;
          resolution = maskData.resolution || renderTexture.resolution;
          multisample = (_a2 = maskData.multisample) !== null && _a2 !== void 0 ? _a2 : renderTexture.multisample;
        } else {
          resolution = maskData.resolution || renderer.resolution;
          multisample = (_b = maskData.multisample) !== null && _b !== void 0 ? _b : renderer.multisample;
        }
        alphaMaskFilter[0].resolution = resolution;
        alphaMaskFilter[0].multisample = multisample;
        alphaMaskFilter[0].maskSprite = maskObject;
        var stashFilterArea = target.filterArea;
        target.filterArea = maskObject.getBounds(true);
        renderer.filter.push(target, alphaMaskFilter);
        target.filterArea = stashFilterArea;
        if (!maskData._filters) {
          this.alphaMaskIndex++;
        }
      };
      MaskSystem3.prototype.popSpriteMask = function(maskData) {
        this.renderer.filter.pop();
        if (maskData._filters) {
          maskData._filters[0].maskSprite = null;
        } else {
          this.alphaMaskIndex--;
          this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null;
        }
      };
      MaskSystem3.prototype.destroy = function() {
        this.renderer = null;
      };
      return MaskSystem3;
    }()
  );
  var AbstractMaskSystem = (
    /** @class */
    function() {
      function AbstractMaskSystem3(renderer) {
        this.renderer = renderer;
        this.maskStack = [];
        this.glConst = 0;
      }
      AbstractMaskSystem3.prototype.getStackLength = function() {
        return this.maskStack.length;
      };
      AbstractMaskSystem3.prototype.setMaskStack = function(maskStack) {
        var gl = this.renderer.gl;
        var curStackLen = this.getStackLength();
        this.maskStack = maskStack;
        var newStackLen = this.getStackLength();
        if (newStackLen !== curStackLen) {
          if (newStackLen === 0) {
            gl.disable(this.glConst);
          } else {
            gl.enable(this.glConst);
            this._useCurrent();
          }
        }
      };
      AbstractMaskSystem3.prototype._useCurrent = function() {
      };
      AbstractMaskSystem3.prototype.destroy = function() {
        this.renderer = null;
        this.maskStack = null;
      };
      return AbstractMaskSystem3;
    }()
  );
  var tempMatrix$1 = new Matrix();
  var ScissorSystem = (
    /** @class */
    function(_super) {
      __extends2(ScissorSystem3, _super);
      function ScissorSystem3(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.glConst = WebGLRenderingContext.SCISSOR_TEST;
        return _this;
      }
      ScissorSystem3.prototype.getStackLength = function() {
        var maskData = this.maskStack[this.maskStack.length - 1];
        if (maskData) {
          return maskData._scissorCounter;
        }
        return 0;
      };
      ScissorSystem3.prototype.calcScissorRect = function(maskData) {
        if (maskData._scissorRectLocal) {
          return;
        }
        var prevData = maskData._scissorRect;
        var maskObject = maskData.maskObject;
        var renderer = this.renderer;
        var renderTextureSystem = renderer.renderTexture;
        maskObject.renderable = true;
        var rect = maskObject.getBounds();
        this.roundFrameToPixels(rect, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);
        maskObject.renderable = false;
        if (prevData) {
          rect.fit(prevData);
        }
        maskData._scissorRectLocal = rect;
      };
      ScissorSystem3.isMatrixRotated = function(matrix) {
        if (!matrix) {
          return false;
        }
        var a = matrix.a, b = matrix.b, c = matrix.c, d = matrix.d;
        return (Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4);
      };
      ScissorSystem3.prototype.testScissor = function(maskData) {
        var maskObject = maskData.maskObject;
        if (!maskObject.isFastRect || !maskObject.isFastRect()) {
          return false;
        }
        if (ScissorSystem3.isMatrixRotated(maskObject.worldTransform)) {
          return false;
        }
        if (ScissorSystem3.isMatrixRotated(this.renderer.projection.transform)) {
          return false;
        }
        this.calcScissorRect(maskData);
        var rect = maskData._scissorRectLocal;
        return rect.width > 0 && rect.height > 0;
      };
      ScissorSystem3.prototype.roundFrameToPixels = function(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
        if (ScissorSystem3.isMatrixRotated(transform)) {
          return;
        }
        transform = transform ? tempMatrix$1.copyFrom(transform) : tempMatrix$1.identity();
        transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
        this.renderer.filter.transformAABB(transform, frame);
        frame.fit(bindingDestinationFrame);
        frame.x = Math.round(frame.x * resolution);
        frame.y = Math.round(frame.y * resolution);
        frame.width = Math.round(frame.width * resolution);
        frame.height = Math.round(frame.height * resolution);
      };
      ScissorSystem3.prototype.push = function(maskData) {
        if (!maskData._scissorRectLocal) {
          this.calcScissorRect(maskData);
        }
        var gl = this.renderer.gl;
        if (!maskData._scissorRect) {
          gl.enable(gl.SCISSOR_TEST);
        }
        maskData._scissorCounter++;
        maskData._scissorRect = maskData._scissorRectLocal;
        this._useCurrent();
      };
      ScissorSystem3.prototype.pop = function() {
        var gl = this.renderer.gl;
        if (this.getStackLength() > 0) {
          this._useCurrent();
        } else {
          gl.disable(gl.SCISSOR_TEST);
        }
      };
      ScissorSystem3.prototype._useCurrent = function() {
        var rect = this.maskStack[this.maskStack.length - 1]._scissorRect;
        var y;
        if (this.renderer.renderTexture.current) {
          y = rect.y;
        } else {
          y = this.renderer.height - rect.height - rect.y;
        }
        this.renderer.gl.scissor(rect.x, y, rect.width, rect.height);
      };
      return ScissorSystem3;
    }(AbstractMaskSystem)
  );
  var StencilSystem = (
    /** @class */
    function(_super) {
      __extends2(StencilSystem3, _super);
      function StencilSystem3(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.glConst = WebGLRenderingContext.STENCIL_TEST;
        return _this;
      }
      StencilSystem3.prototype.getStackLength = function() {
        var maskData = this.maskStack[this.maskStack.length - 1];
        if (maskData) {
          return maskData._stencilCounter;
        }
        return 0;
      };
      StencilSystem3.prototype.push = function(maskData) {
        var maskObject = maskData.maskObject;
        var gl = this.renderer.gl;
        var prevMaskCount = maskData._stencilCounter;
        if (prevMaskCount === 0) {
          this.renderer.framebuffer.forceStencil();
          gl.clearStencil(0);
          gl.clear(gl.STENCIL_BUFFER_BIT);
          gl.enable(gl.STENCIL_TEST);
        }
        maskData._stencilCounter++;
        gl.colorMask(false, false, false, false);
        gl.stencilFunc(gl.EQUAL, prevMaskCount, 4294967295);
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
        maskObject.renderable = true;
        maskObject.render(this.renderer);
        this.renderer.batch.flush();
        maskObject.renderable = false;
        this._useCurrent();
      };
      StencilSystem3.prototype.pop = function(maskObject) {
        var gl = this.renderer.gl;
        if (this.getStackLength() === 0) {
          gl.disable(gl.STENCIL_TEST);
        } else {
          gl.colorMask(false, false, false, false);
          gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
          maskObject.renderable = true;
          maskObject.render(this.renderer);
          this.renderer.batch.flush();
          maskObject.renderable = false;
          this._useCurrent();
        }
      };
      StencilSystem3.prototype._useCurrent = function() {
        var gl = this.renderer.gl;
        gl.colorMask(true, true, true, true);
        gl.stencilFunc(gl.EQUAL, this.getStackLength(), 4294967295);
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
      };
      return StencilSystem3;
    }(AbstractMaskSystem)
  );
  var ProjectionSystem = (
    /** @class */
    function() {
      function ProjectionSystem3(renderer) {
        this.renderer = renderer;
        this.destinationFrame = null;
        this.sourceFrame = null;
        this.defaultFrame = null;
        this.projectionMatrix = new Matrix();
        this.transform = null;
      }
      ProjectionSystem3.prototype.update = function(destinationFrame, sourceFrame, resolution, root) {
        this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
        this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;
        this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root);
        if (this.transform) {
          this.projectionMatrix.append(this.transform);
        }
        var renderer = this.renderer;
        renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix;
        renderer.globalUniforms.update();
        if (renderer.shader.shader) {
          renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);
        }
      };
      ProjectionSystem3.prototype.calculateProjection = function(_destinationFrame, sourceFrame, _resolution, root) {
        var pm = this.projectionMatrix;
        var sign2 = !root ? 1 : -1;
        pm.identity();
        pm.a = 1 / sourceFrame.width * 2;
        pm.d = sign2 * (1 / sourceFrame.height * 2);
        pm.tx = -1 - sourceFrame.x * pm.a;
        pm.ty = -sign2 - sourceFrame.y * pm.d;
      };
      ProjectionSystem3.prototype.setTransform = function(_matrix) {
      };
      ProjectionSystem3.prototype.destroy = function() {
        this.renderer = null;
      };
      return ProjectionSystem3;
    }()
  );
  var tempRect = new Rectangle();
  var tempRect2 = new Rectangle();
  var RenderTextureSystem = (
    /** @class */
    function() {
      function RenderTextureSystem3(renderer) {
        this.renderer = renderer;
        this.clearColor = renderer._backgroundColorRgba;
        this.defaultMaskStack = [];
        this.current = null;
        this.sourceFrame = new Rectangle();
        this.destinationFrame = new Rectangle();
        this.viewportFrame = new Rectangle();
      }
      RenderTextureSystem3.prototype.bind = function(renderTexture, sourceFrame, destinationFrame) {
        if (renderTexture === void 0) {
          renderTexture = null;
        }
        var renderer = this.renderer;
        this.current = renderTexture;
        var baseTexture;
        var framebuffer;
        var resolution;
        if (renderTexture) {
          baseTexture = renderTexture.baseTexture;
          resolution = baseTexture.resolution;
          if (!sourceFrame) {
            tempRect.width = renderTexture.frame.width;
            tempRect.height = renderTexture.frame.height;
            sourceFrame = tempRect;
          }
          if (!destinationFrame) {
            tempRect2.x = renderTexture.frame.x;
            tempRect2.y = renderTexture.frame.y;
            tempRect2.width = sourceFrame.width;
            tempRect2.height = sourceFrame.height;
            destinationFrame = tempRect2;
          }
          framebuffer = baseTexture.framebuffer;
        } else {
          resolution = renderer.resolution;
          if (!sourceFrame) {
            tempRect.width = renderer.screen.width;
            tempRect.height = renderer.screen.height;
            sourceFrame = tempRect;
          }
          if (!destinationFrame) {
            destinationFrame = tempRect;
            destinationFrame.width = sourceFrame.width;
            destinationFrame.height = sourceFrame.height;
          }
        }
        var viewportFrame = this.viewportFrame;
        viewportFrame.x = destinationFrame.x * resolution;
        viewportFrame.y = destinationFrame.y * resolution;
        viewportFrame.width = destinationFrame.width * resolution;
        viewportFrame.height = destinationFrame.height * resolution;
        if (!renderTexture) {
          viewportFrame.y = renderer.view.height - (viewportFrame.y + viewportFrame.height);
        }
        viewportFrame.ceil();
        this.renderer.framebuffer.bind(framebuffer, viewportFrame);
        this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer);
        if (renderTexture) {
          this.renderer.mask.setMaskStack(baseTexture.maskStack);
        } else {
          this.renderer.mask.setMaskStack(this.defaultMaskStack);
        }
        this.sourceFrame.copyFrom(sourceFrame);
        this.destinationFrame.copyFrom(destinationFrame);
      };
      RenderTextureSystem3.prototype.clear = function(clearColor, mask) {
        if (this.current) {
          clearColor = clearColor || this.current.baseTexture.clearColor;
        } else {
          clearColor = clearColor || this.clearColor;
        }
        var destinationFrame = this.destinationFrame;
        var baseFrame = this.current ? this.current.baseTexture : this.renderer.screen;
        var clearMask = destinationFrame.width !== baseFrame.width || destinationFrame.height !== baseFrame.height;
        if (clearMask) {
          var _a2 = this.viewportFrame, x = _a2.x, y = _a2.y, width = _a2.width, height = _a2.height;
          x = Math.round(x);
          y = Math.round(y);
          width = Math.round(width);
          height = Math.round(height);
          this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);
          this.renderer.gl.scissor(x, y, width, height);
        }
        this.renderer.framebuffer.clear(clearColor[0], clearColor[1], clearColor[2], clearColor[3], mask);
        if (clearMask) {
          this.renderer.scissor.pop();
        }
      };
      RenderTextureSystem3.prototype.resize = function() {
        this.bind(null);
      };
      RenderTextureSystem3.prototype.reset = function() {
        this.bind(null);
      };
      RenderTextureSystem3.prototype.destroy = function() {
        this.renderer = null;
      };
      return RenderTextureSystem3;
    }()
  );
  function uboUpdate(_ud, _uv, _renderer, _syncData, buffer) {
    _renderer.buffer.update(buffer);
  }
  var UBO_TO_SINGLE_SETTERS = {
    float: "\n        data[offset] = v;\n    ",
    vec2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    ",
    vec3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    ",
    vec4: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    ",
    mat2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    ",
    mat3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    ",
    mat4: "\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    "
  };
  var GLSL_TO_STD40_SIZE = {
    float: 4,
    vec2: 8,
    vec3: 12,
    vec4: 16,
    int: 4,
    ivec2: 8,
    ivec3: 12,
    ivec4: 16,
    uint: 4,
    uvec2: 8,
    uvec3: 12,
    uvec4: 16,
    bool: 4,
    bvec2: 8,
    bvec3: 12,
    bvec4: 16,
    mat2: 16 * 2,
    mat3: 16 * 3,
    mat4: 16 * 4
  };
  function createUBOElements(uniformData) {
    var uboElements = uniformData.map(function(data) {
      return {
        data,
        offset: 0,
        dataLen: 0,
        dirty: 0
      };
    });
    var size = 0;
    var chunkSize = 0;
    var offset = 0;
    for (var i = 0; i < uboElements.length; i++) {
      var uboElement = uboElements[i];
      size = GLSL_TO_STD40_SIZE[uboElement.data.type];
      if (uboElement.data.size > 1) {
        size = Math.max(size, 16) * uboElement.data.size;
      }
      uboElement.dataLen = size;
      if (chunkSize % size !== 0 && chunkSize < 16) {
        var lineUpValue = chunkSize % size % 16;
        chunkSize += lineUpValue;
        offset += lineUpValue;
      }
      if (chunkSize + size > 16) {
        offset = Math.ceil(offset / 16) * 16;
        uboElement.offset = offset;
        offset += size;
        chunkSize = size;
      } else {
        uboElement.offset = offset;
        chunkSize += size;
        offset += size;
      }
    }
    offset = Math.ceil(offset / 16) * 16;
    return { uboElements, size: offset };
  }
  function getUBOData(uniforms, uniformData) {
    var usedUniformDatas = [];
    for (var i in uniforms) {
      if (uniformData[i]) {
        usedUniformDatas.push(uniformData[i]);
      }
    }
    usedUniformDatas.sort(function(a, b) {
      return a.index - b.index;
    });
    return usedUniformDatas;
  }
  function generateUniformBufferSync(group, uniformData) {
    if (!group.autoManage) {
      return { size: 0, syncFunc: uboUpdate };
    }
    var usedUniformDatas = getUBOData(group.uniforms, uniformData);
    var _a2 = createUBOElements(usedUniformDatas), uboElements = _a2.uboElements, size = _a2.size;
    var funcFragments = ["\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    "];
    for (var i = 0; i < uboElements.length; i++) {
      var uboElement = uboElements[i];
      var uniform = group.uniforms[uboElement.data.name];
      var name = uboElement.data.name;
      var parsed = false;
      for (var j = 0; j < uniformParsers.length; j++) {
        var uniformParser = uniformParsers[j];
        if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform)) {
          funcFragments.push("offset = " + uboElement.offset / 4 + ";", uniformParsers[j].codeUbo(uboElement.data.name, uniform));
          parsed = true;
          break;
        }
      }
      if (!parsed) {
        if (uboElement.data.size > 1) {
          var size_1 = mapSize(uboElement.data.type);
          var rowSize = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
          var elementSize = size_1 / rowSize;
          var remainder = (4 - elementSize % 4) % 4;
          funcFragments.push("\n                cv = ud." + name + ".value;\n                v = uv." + name + ";\n                offset = " + uboElement.offset / 4 + ";\n\n                t = 0;\n\n                for(var i=0; i < " + uboElement.data.size * rowSize + "; i++)\n                {\n                    for(var j = 0; j < " + elementSize + "; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += " + remainder + ";\n                }\n\n                ");
        } else {
          var template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];
          funcFragments.push("\n                cv = ud." + name + ".value;\n                v = uv." + name + ";\n                offset = " + uboElement.offset / 4 + ";\n                " + template + ";\n                ");
        }
      }
    }
    funcFragments.push("\n       renderer.buffer.update(buffer);\n    ");
    return {
      size,
      // eslint-disable-next-line no-new-func
      syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", funcFragments.join("\n"))
    };
  }
  var IGLUniformData = (
    /** @class */
    function() {
      function IGLUniformData2() {
      }
      return IGLUniformData2;
    }()
  );
  var GLProgram = (
    /** @class */
    function() {
      function GLProgram3(program, uniformData) {
        this.program = program;
        this.uniformData = uniformData;
        this.uniformGroups = {};
        this.uniformDirtyGroups = {};
        this.uniformBufferBindings = {};
      }
      GLProgram3.prototype.destroy = function() {
        this.uniformData = null;
        this.uniformGroups = null;
        this.uniformDirtyGroups = null;
        this.uniformBufferBindings = null;
        this.program = null;
      };
      return GLProgram3;
    }()
  );
  function getAttributeData(program, gl) {
    var attributes = {};
    var totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (var i = 0; i < totalAttributes; i++) {
      var attribData = gl.getActiveAttrib(program, i);
      if (attribData.name.indexOf("gl_") === 0) {
        continue;
      }
      var type = mapType(gl, attribData.type);
      var data = {
        type,
        name: attribData.name,
        size: mapSize(type),
        location: gl.getAttribLocation(program, attribData.name)
      };
      attributes[attribData.name] = data;
    }
    return attributes;
  }
  function getUniformData(program, gl) {
    var uniforms = {};
    var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (var i = 0; i < totalUniforms; i++) {
      var uniformData = gl.getActiveUniform(program, i);
      var name = uniformData.name.replace(/\[.*?\]$/, "");
      var isArray = !!uniformData.name.match(/\[.*?\]$/);
      var type = mapType(gl, uniformData.type);
      uniforms[name] = {
        name,
        index: i,
        type,
        size: uniformData.size,
        isArray,
        value: defaultValue(type, uniformData.size)
      };
    }
    return uniforms;
  }
  function generateProgram(gl, program) {
    var glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertexSrc);
    var glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragmentSrc);
    var webGLProgram = gl.createProgram();
    gl.attachShader(webGLProgram, glVertShader);
    gl.attachShader(webGLProgram, glFragShader);
    gl.linkProgram(webGLProgram);
    if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
      logProgramError(gl, webGLProgram, glVertShader, glFragShader);
    }
    program.attributeData = getAttributeData(webGLProgram, gl);
    program.uniformData = getUniformData(webGLProgram, gl);
    if (!/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertexSrc)) {
      var keys = Object.keys(program.attributeData);
      keys.sort(function(a, b) {
        return a > b ? 1 : -1;
      });
      for (var i = 0; i < keys.length; i++) {
        program.attributeData[keys[i]].location = i;
        gl.bindAttribLocation(webGLProgram, i, keys[i]);
      }
      gl.linkProgram(webGLProgram);
    }
    gl.deleteShader(glVertShader);
    gl.deleteShader(glFragShader);
    var uniformData = {};
    for (var i in program.uniformData) {
      var data = program.uniformData[i];
      uniformData[i] = {
        location: gl.getUniformLocation(webGLProgram, i),
        value: defaultValue(data.type, data.size)
      };
    }
    var glProgram = new GLProgram(webGLProgram, uniformData);
    return glProgram;
  }
  var UID = 0;
  var defaultSyncData = { textureCount: 0, uboCount: 0 };
  var ShaderSystem = (
    /** @class */
    function() {
      function ShaderSystem3(renderer) {
        this.destroyed = false;
        this.renderer = renderer;
        this.systemCheck();
        this.gl = null;
        this.shader = null;
        this.program = null;
        this.cache = {};
        this._uboCache = {};
        this.id = UID++;
      }
      ShaderSystem3.prototype.systemCheck = function() {
        if (!unsafeEvalSupported()) {
          throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
        }
      };
      ShaderSystem3.prototype.contextChange = function(gl) {
        this.gl = gl;
        this.reset();
      };
      ShaderSystem3.prototype.bind = function(shader, dontSync) {
        shader.uniforms.globals = this.renderer.globalUniforms;
        var program = shader.program;
        var glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(shader);
        this.shader = shader;
        if (this.program !== program) {
          this.program = program;
          this.gl.useProgram(glProgram.program);
        }
        if (!dontSync) {
          defaultSyncData.textureCount = 0;
          defaultSyncData.uboCount = 0;
          this.syncUniformGroup(shader.uniformGroup, defaultSyncData);
        }
        return glProgram;
      };
      ShaderSystem3.prototype.setUniforms = function(uniforms) {
        var shader = this.shader.program;
        var glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];
        shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);
      };
      ShaderSystem3.prototype.syncUniformGroup = function(group, syncData) {
        var glProgram = this.getGlProgram();
        if (!group.static || group.dirtyId !== glProgram.uniformDirtyGroups[group.id]) {
          glProgram.uniformDirtyGroups[group.id] = group.dirtyId;
          this.syncUniforms(group, glProgram, syncData);
        }
      };
      ShaderSystem3.prototype.syncUniforms = function(group, glProgram, syncData) {
        var syncFunc = group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group);
        syncFunc(glProgram.uniformData, group.uniforms, this.renderer, syncData);
      };
      ShaderSystem3.prototype.createSyncGroups = function(group) {
        var id = this.getSignature(group, this.shader.program.uniformData, "u");
        if (!this.cache[id]) {
          this.cache[id] = generateUniformsSync(group, this.shader.program.uniformData);
        }
        group.syncUniforms[this.shader.program.id] = this.cache[id];
        return group.syncUniforms[this.shader.program.id];
      };
      ShaderSystem3.prototype.syncUniformBufferGroup = function(group, name) {
        var glProgram = this.getGlProgram();
        if (!group.static || group.dirtyId !== 0 || !glProgram.uniformGroups[group.id]) {
          group.dirtyId = 0;
          var syncFunc = glProgram.uniformGroups[group.id] || this.createSyncBufferGroup(group, glProgram, name);
          group.buffer.update();
          syncFunc(glProgram.uniformData, group.uniforms, this.renderer, defaultSyncData, group.buffer);
        }
        this.renderer.buffer.bindBufferBase(group.buffer, glProgram.uniformBufferBindings[name]);
      };
      ShaderSystem3.prototype.createSyncBufferGroup = function(group, glProgram, name) {
        var gl = this.renderer.gl;
        this.renderer.buffer.bind(group.buffer);
        var uniformBlockIndex = this.gl.getUniformBlockIndex(glProgram.program, name);
        glProgram.uniformBufferBindings[name] = this.shader.uniformBindCount;
        gl.uniformBlockBinding(glProgram.program, uniformBlockIndex, this.shader.uniformBindCount);
        this.shader.uniformBindCount++;
        var id = this.getSignature(group, this.shader.program.uniformData, "ubo");
        var uboData = this._uboCache[id];
        if (!uboData) {
          uboData = this._uboCache[id] = generateUniformBufferSync(group, this.shader.program.uniformData);
        }
        if (group.autoManage) {
          var data = new Float32Array(uboData.size / 4);
          group.buffer.update(data);
        }
        glProgram.uniformGroups[group.id] = uboData.syncFunc;
        return glProgram.uniformGroups[group.id];
      };
      ShaderSystem3.prototype.getSignature = function(group, uniformData, preFix) {
        var uniforms = group.uniforms;
        var strings = [preFix + "-"];
        for (var i in uniforms) {
          strings.push(i);
          if (uniformData[i]) {
            strings.push(uniformData[i].type);
          }
        }
        return strings.join("-");
      };
      ShaderSystem3.prototype.getGlProgram = function() {
        if (this.shader) {
          return this.shader.program.glPrograms[this.renderer.CONTEXT_UID];
        }
        return null;
      };
      ShaderSystem3.prototype.generateProgram = function(shader) {
        var gl = this.gl;
        var program = shader.program;
        var glProgram = generateProgram(gl, program);
        program.glPrograms[this.renderer.CONTEXT_UID] = glProgram;
        return glProgram;
      };
      ShaderSystem3.prototype.reset = function() {
        this.program = null;
        this.shader = null;
      };
      ShaderSystem3.prototype.destroy = function() {
        this.renderer = null;
        this.destroyed = true;
      };
      return ShaderSystem3;
    }()
  );
  function mapWebGLBlendModesToPixi(gl, array) {
    if (array === void 0) {
      array = [];
    }
    array[BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.ADD] = [gl.ONE, gl.ONE];
    array[BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.NONE] = [0, 0];
    array[BLEND_MODES.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
    array[BLEND_MODES.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];
    array[BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];
    array[BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];
    array[BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];
    array[BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];
    array[BLEND_MODES.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];
    return array;
  }
  var BLEND = 0;
  var OFFSET = 1;
  var CULLING = 2;
  var DEPTH_TEST = 3;
  var WINDING = 4;
  var DEPTH_MASK = 5;
  var StateSystem = (
    /** @class */
    function() {
      function StateSystem3() {
        this.gl = null;
        this.stateId = 0;
        this.polygonOffset = 0;
        this.blendMode = BLEND_MODES.NONE;
        this._blendEq = false;
        this.map = [];
        this.map[BLEND] = this.setBlend;
        this.map[OFFSET] = this.setOffset;
        this.map[CULLING] = this.setCullFace;
        this.map[DEPTH_TEST] = this.setDepthTest;
        this.map[WINDING] = this.setFrontFace;
        this.map[DEPTH_MASK] = this.setDepthMask;
        this.checks = [];
        this.defaultState = new State();
        this.defaultState.blend = true;
      }
      StateSystem3.prototype.contextChange = function(gl) {
        this.gl = gl;
        this.blendModes = mapWebGLBlendModesToPixi(gl);
        this.set(this.defaultState);
        this.reset();
      };
      StateSystem3.prototype.set = function(state) {
        state = state || this.defaultState;
        if (this.stateId !== state.data) {
          var diff = this.stateId ^ state.data;
          var i = 0;
          while (diff) {
            if (diff & 1) {
              this.map[i].call(this, !!(state.data & 1 << i));
            }
            diff = diff >> 1;
            i++;
          }
          this.stateId = state.data;
        }
        for (var i = 0; i < this.checks.length; i++) {
          this.checks[i](this, state);
        }
      };
      StateSystem3.prototype.forceState = function(state) {
        state = state || this.defaultState;
        for (var i = 0; i < this.map.length; i++) {
          this.map[i].call(this, !!(state.data & 1 << i));
        }
        for (var i = 0; i < this.checks.length; i++) {
          this.checks[i](this, state);
        }
        this.stateId = state.data;
      };
      StateSystem3.prototype.setBlend = function(value) {
        this.updateCheck(StateSystem3.checkBlendMode, value);
        this.gl[value ? "enable" : "disable"](this.gl.BLEND);
      };
      StateSystem3.prototype.setOffset = function(value) {
        this.updateCheck(StateSystem3.checkPolygonOffset, value);
        this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
      };
      StateSystem3.prototype.setDepthTest = function(value) {
        this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
      };
      StateSystem3.prototype.setDepthMask = function(value) {
        this.gl.depthMask(value);
      };
      StateSystem3.prototype.setCullFace = function(value) {
        this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
      };
      StateSystem3.prototype.setFrontFace = function(value) {
        this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);
      };
      StateSystem3.prototype.setBlendMode = function(value) {
        if (value === this.blendMode) {
          return;
        }
        this.blendMode = value;
        var mode = this.blendModes[value];
        var gl = this.gl;
        if (mode.length === 2) {
          gl.blendFunc(mode[0], mode[1]);
        } else {
          gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
        }
        if (mode.length === 6) {
          this._blendEq = true;
          gl.blendEquationSeparate(mode[4], mode[5]);
        } else if (this._blendEq) {
          this._blendEq = false;
          gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        }
      };
      StateSystem3.prototype.setPolygonOffset = function(value, scale) {
        this.gl.polygonOffset(value, scale);
      };
      StateSystem3.prototype.reset = function() {
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
        this.forceState(this.defaultState);
        this._blendEq = true;
        this.blendMode = -1;
        this.setBlendMode(0);
      };
      StateSystem3.prototype.updateCheck = function(func, value) {
        var index = this.checks.indexOf(func);
        if (value && index === -1) {
          this.checks.push(func);
        } else if (!value && index !== -1) {
          this.checks.splice(index, 1);
        }
      };
      StateSystem3.checkBlendMode = function(system, state) {
        system.setBlendMode(state.blendMode);
      };
      StateSystem3.checkPolygonOffset = function(system, state) {
        system.setPolygonOffset(1, state.polygonOffset);
      };
      StateSystem3.prototype.destroy = function() {
        this.gl = null;
      };
      return StateSystem3;
    }()
  );
  var TextureGCSystem = (
    /** @class */
    function() {
      function TextureGCSystem3(renderer) {
        this.renderer = renderer;
        this.count = 0;
        this.checkCount = 0;
        this.maxIdle = settings.GC_MAX_IDLE;
        this.checkCountMax = settings.GC_MAX_CHECK_COUNT;
        this.mode = settings.GC_MODE;
      }
      TextureGCSystem3.prototype.postrender = function() {
        if (!this.renderer.renderingToScreen) {
          return;
        }
        this.count++;
        if (this.mode === GC_MODES.MANUAL) {
          return;
        }
        this.checkCount++;
        if (this.checkCount > this.checkCountMax) {
          this.checkCount = 0;
          this.run();
        }
      };
      TextureGCSystem3.prototype.run = function() {
        var tm = this.renderer.texture;
        var managedTextures = tm.managedTextures;
        var wasRemoved = false;
        for (var i = 0; i < managedTextures.length; i++) {
          var texture = managedTextures[i];
          if (!texture.framebuffer && this.count - texture.touched > this.maxIdle) {
            tm.destroyTexture(texture, true);
            managedTextures[i] = null;
            wasRemoved = true;
          }
        }
        if (wasRemoved) {
          var j = 0;
          for (var i = 0; i < managedTextures.length; i++) {
            if (managedTextures[i] !== null) {
              managedTextures[j++] = managedTextures[i];
            }
          }
          managedTextures.length = j;
        }
      };
      TextureGCSystem3.prototype.unload = function(displayObject) {
        var tm = this.renderer.texture;
        var texture = displayObject._texture;
        if (texture && !texture.framebuffer) {
          tm.destroyTexture(texture);
        }
        for (var i = displayObject.children.length - 1; i >= 0; i--) {
          this.unload(displayObject.children[i]);
        }
      };
      TextureGCSystem3.prototype.destroy = function() {
        this.renderer = null;
      };
      return TextureGCSystem3;
    }()
  );
  function mapTypeAndFormatToInternalFormat(gl) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
    var table;
    if ("WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext) {
      table = (_a2 = {}, _a2[TYPES.UNSIGNED_BYTE] = (_b = {}, _b[FORMATS.RGBA] = gl.RGBA8, _b[FORMATS.RGB] = gl.RGB8, _b[FORMATS.RG] = gl.RG8, _b[FORMATS.RED] = gl.R8, _b[FORMATS.RGBA_INTEGER] = gl.RGBA8UI, _b[FORMATS.RGB_INTEGER] = gl.RGB8UI, _b[FORMATS.RG_INTEGER] = gl.RG8UI, _b[FORMATS.RED_INTEGER] = gl.R8UI, _b[FORMATS.ALPHA] = gl.ALPHA, _b[FORMATS.LUMINANCE] = gl.LUMINANCE, _b[FORMATS.LUMINANCE_ALPHA] = gl.LUMINANCE_ALPHA, _b), _a2[TYPES.BYTE] = (_c = {}, _c[FORMATS.RGBA] = gl.RGBA8_SNORM, _c[FORMATS.RGB] = gl.RGB8_SNORM, _c[FORMATS.RG] = gl.RG8_SNORM, _c[FORMATS.RED] = gl.R8_SNORM, _c[FORMATS.RGBA_INTEGER] = gl.RGBA8I, _c[FORMATS.RGB_INTEGER] = gl.RGB8I, _c[FORMATS.RG_INTEGER] = gl.RG8I, _c[FORMATS.RED_INTEGER] = gl.R8I, _c), _a2[TYPES.UNSIGNED_SHORT] = (_d = {}, _d[FORMATS.RGBA_INTEGER] = gl.RGBA16UI, _d[FORMATS.RGB_INTEGER] = gl.RGB16UI, _d[FORMATS.RG_INTEGER] = gl.RG16UI, _d[FORMATS.RED_INTEGER] = gl.R16UI, _d[FORMATS.DEPTH_COMPONENT] = gl.DEPTH_COMPONENT16, _d), _a2[TYPES.SHORT] = (_e = {}, _e[FORMATS.RGBA_INTEGER] = gl.RGBA16I, _e[FORMATS.RGB_INTEGER] = gl.RGB16I, _e[FORMATS.RG_INTEGER] = gl.RG16I, _e[FORMATS.RED_INTEGER] = gl.R16I, _e), _a2[TYPES.UNSIGNED_INT] = (_f = {}, _f[FORMATS.RGBA_INTEGER] = gl.RGBA32UI, _f[FORMATS.RGB_INTEGER] = gl.RGB32UI, _f[FORMATS.RG_INTEGER] = gl.RG32UI, _f[FORMATS.RED_INTEGER] = gl.R32UI, _f[FORMATS.DEPTH_COMPONENT] = gl.DEPTH_COMPONENT24, _f), _a2[TYPES.INT] = (_g = {}, _g[FORMATS.RGBA_INTEGER] = gl.RGBA32I, _g[FORMATS.RGB_INTEGER] = gl.RGB32I, _g[FORMATS.RG_INTEGER] = gl.RG32I, _g[FORMATS.RED_INTEGER] = gl.R32I, _g), _a2[TYPES.FLOAT] = (_h = {}, _h[FORMATS.RGBA] = gl.RGBA32F, _h[FORMATS.RGB] = gl.RGB32F, _h[FORMATS.RG] = gl.RG32F, _h[FORMATS.RED] = gl.R32F, _h[FORMATS.DEPTH_COMPONENT] = gl.DEPTH_COMPONENT32F, _h), _a2[TYPES.HALF_FLOAT] = (_j = {}, _j[FORMATS.RGBA] = gl.RGBA16F, _j[FORMATS.RGB] = gl.RGB16F, _j[FORMATS.RG] = gl.RG16F, _j[FORMATS.RED] = gl.R16F, _j), _a2[TYPES.UNSIGNED_SHORT_5_6_5] = (_k = {}, _k[FORMATS.RGB] = gl.RGB565, _k), _a2[TYPES.UNSIGNED_SHORT_4_4_4_4] = (_l = {}, _l[FORMATS.RGBA] = gl.RGBA4, _l), _a2[TYPES.UNSIGNED_SHORT_5_5_5_1] = (_m = {}, _m[FORMATS.RGBA] = gl.RGB5_A1, _m), _a2[TYPES.UNSIGNED_INT_2_10_10_10_REV] = (_o = {}, _o[FORMATS.RGBA] = gl.RGB10_A2, _o[FORMATS.RGBA_INTEGER] = gl.RGB10_A2UI, _o), _a2[TYPES.UNSIGNED_INT_10F_11F_11F_REV] = (_p = {}, _p[FORMATS.RGB] = gl.R11F_G11F_B10F, _p), _a2[TYPES.UNSIGNED_INT_5_9_9_9_REV] = (_q = {}, _q[FORMATS.RGB] = gl.RGB9_E5, _q), _a2[TYPES.UNSIGNED_INT_24_8] = (_r = {}, _r[FORMATS.DEPTH_STENCIL] = gl.DEPTH24_STENCIL8, _r), _a2[TYPES.FLOAT_32_UNSIGNED_INT_24_8_REV] = (_s = {}, _s[FORMATS.DEPTH_STENCIL] = gl.DEPTH32F_STENCIL8, _s), _a2);
    } else {
      table = (_t = {}, _t[TYPES.UNSIGNED_BYTE] = (_u = {}, _u[FORMATS.RGBA] = gl.RGBA, _u[FORMATS.RGB] = gl.RGB, _u[FORMATS.ALPHA] = gl.ALPHA, _u[FORMATS.LUMINANCE] = gl.LUMINANCE, _u[FORMATS.LUMINANCE_ALPHA] = gl.LUMINANCE_ALPHA, _u), _t[TYPES.UNSIGNED_SHORT_5_6_5] = (_v = {}, _v[FORMATS.RGB] = gl.RGB, _v), _t[TYPES.UNSIGNED_SHORT_4_4_4_4] = (_w = {}, _w[FORMATS.RGBA] = gl.RGBA, _w), _t[TYPES.UNSIGNED_SHORT_5_5_5_1] = (_x = {}, _x[FORMATS.RGBA] = gl.RGBA, _x), _t);
    }
    return table;
  }
  var GLTexture = (
    /** @class */
    function() {
      function GLTexture3(texture) {
        this.texture = texture;
        this.width = -1;
        this.height = -1;
        this.dirtyId = -1;
        this.dirtyStyleId = -1;
        this.mipmap = false;
        this.wrapMode = 33071;
        this.type = TYPES.UNSIGNED_BYTE;
        this.internalFormat = FORMATS.RGBA;
        this.samplerType = 0;
      }
      return GLTexture3;
    }()
  );
  var TextureSystem = (
    /** @class */
    function() {
      function TextureSystem3(renderer) {
        this.renderer = renderer;
        this.boundTextures = [];
        this.currentLocation = -1;
        this.managedTextures = [];
        this._unknownBoundTextures = false;
        this.unknownTexture = new BaseTexture();
        this.hasIntegerTextures = false;
      }
      TextureSystem3.prototype.contextChange = function() {
        var gl = this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        this.webGLVersion = this.renderer.context.webGLVersion;
        this.internalFormats = mapTypeAndFormatToInternalFormat(gl);
        var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        this.boundTextures.length = maxTextures;
        for (var i = 0; i < maxTextures; i++) {
          this.boundTextures[i] = null;
        }
        this.emptyTextures = {};
        var emptyTexture2D = new GLTexture(gl.createTexture());
        gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));
        this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;
        this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture());
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);
        for (var i = 0; i < 6; i++) {
          gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        }
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        for (var i = 0; i < this.boundTextures.length; i++) {
          this.bind(null, i);
        }
      };
      TextureSystem3.prototype.bind = function(texture, location) {
        if (location === void 0) {
          location = 0;
        }
        var gl = this.gl;
        texture = texture === null || texture === void 0 ? void 0 : texture.castToBaseTexture();
        if (texture && texture.valid && !texture.parentTextureArray) {
          texture.touched = this.renderer.textureGC.count;
          var glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);
          if (this.boundTextures[location] !== texture) {
            if (this.currentLocation !== location) {
              this.currentLocation = location;
              gl.activeTexture(gl.TEXTURE0 + location);
            }
            gl.bindTexture(texture.target, glTexture.texture);
          }
          if (glTexture.dirtyId !== texture.dirtyId) {
            if (this.currentLocation !== location) {
              this.currentLocation = location;
              gl.activeTexture(gl.TEXTURE0 + location);
            }
            this.updateTexture(texture);
          }
          this.boundTextures[location] = texture;
        } else {
          if (this.currentLocation !== location) {
            this.currentLocation = location;
            gl.activeTexture(gl.TEXTURE0 + location);
          }
          gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);
          this.boundTextures[location] = null;
        }
      };
      TextureSystem3.prototype.reset = function() {
        this._unknownBoundTextures = true;
        this.hasIntegerTextures = false;
        this.currentLocation = -1;
        for (var i = 0; i < this.boundTextures.length; i++) {
          this.boundTextures[i] = this.unknownTexture;
        }
      };
      TextureSystem3.prototype.unbind = function(texture) {
        var _a2 = this, gl = _a2.gl, boundTextures = _a2.boundTextures;
        if (this._unknownBoundTextures) {
          this._unknownBoundTextures = false;
          for (var i = 0; i < boundTextures.length; i++) {
            if (boundTextures[i] === this.unknownTexture) {
              this.bind(null, i);
            }
          }
        }
        for (var i = 0; i < boundTextures.length; i++) {
          if (boundTextures[i] === texture) {
            if (this.currentLocation !== i) {
              gl.activeTexture(gl.TEXTURE0 + i);
              this.currentLocation = i;
            }
            gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture);
            boundTextures[i] = null;
          }
        }
      };
      TextureSystem3.prototype.ensureSamplerType = function(maxTextures) {
        var _a2 = this, boundTextures = _a2.boundTextures, hasIntegerTextures = _a2.hasIntegerTextures, CONTEXT_UID = _a2.CONTEXT_UID;
        if (!hasIntegerTextures) {
          return;
        }
        for (var i = maxTextures - 1; i >= 0; --i) {
          var tex = boundTextures[i];
          if (tex) {
            var glTexture = tex._glTextures[CONTEXT_UID];
            if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT) {
              this.renderer.texture.unbind(tex);
            }
          }
        }
      };
      TextureSystem3.prototype.initTexture = function(texture) {
        var glTexture = new GLTexture(this.gl.createTexture());
        glTexture.dirtyId = -1;
        texture._glTextures[this.CONTEXT_UID] = glTexture;
        this.managedTextures.push(texture);
        texture.on("dispose", this.destroyTexture, this);
        return glTexture;
      };
      TextureSystem3.prototype.initTextureType = function(texture, glTexture) {
        var _a2, _b;
        glTexture.internalFormat = (_b = (_a2 = this.internalFormats[texture.type]) === null || _a2 === void 0 ? void 0 : _a2[texture.format]) !== null && _b !== void 0 ? _b : texture.format;
        if (this.webGLVersion === 2 && texture.type === TYPES.HALF_FLOAT) {
          glTexture.type = this.gl.HALF_FLOAT;
        } else {
          glTexture.type = texture.type;
        }
      };
      TextureSystem3.prototype.updateTexture = function(texture) {
        var glTexture = texture._glTextures[this.CONTEXT_UID];
        if (!glTexture) {
          return;
        }
        var renderer = this.renderer;
        this.initTextureType(texture, glTexture);
        if (texture.resource && texture.resource.upload(renderer, texture, glTexture)) {
          if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT) {
            this.hasIntegerTextures = true;
          }
        } else {
          var width = texture.realWidth;
          var height = texture.realHeight;
          var gl = renderer.gl;
          if (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) {
            glTexture.width = width;
            glTexture.height = height;
            gl.texImage2D(texture.target, 0, glTexture.internalFormat, width, height, 0, texture.format, glTexture.type, null);
          }
        }
        if (texture.dirtyStyleId !== glTexture.dirtyStyleId) {
          this.updateTextureStyle(texture);
        }
        glTexture.dirtyId = texture.dirtyId;
      };
      TextureSystem3.prototype.destroyTexture = function(texture, skipRemove) {
        var gl = this.gl;
        texture = texture.castToBaseTexture();
        if (texture._glTextures[this.CONTEXT_UID]) {
          this.unbind(texture);
          gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);
          texture.off("dispose", this.destroyTexture, this);
          delete texture._glTextures[this.CONTEXT_UID];
          if (!skipRemove) {
            var i = this.managedTextures.indexOf(texture);
            if (i !== -1) {
              removeItems(this.managedTextures, i, 1);
            }
          }
        }
      };
      TextureSystem3.prototype.updateTextureStyle = function(texture) {
        var glTexture = texture._glTextures[this.CONTEXT_UID];
        if (!glTexture) {
          return;
        }
        if ((texture.mipmap === MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo) {
          glTexture.mipmap = false;
        } else {
          glTexture.mipmap = texture.mipmap >= 1;
        }
        if (this.webGLVersion !== 2 && !texture.isPowerOfTwo) {
          glTexture.wrapMode = WRAP_MODES.CLAMP;
        } else {
          glTexture.wrapMode = texture.wrapMode;
        }
        if (texture.resource && texture.resource.style(this.renderer, texture, glTexture))
          ;
        else {
          this.setStyle(texture, glTexture);
        }
        glTexture.dirtyStyleId = texture.dirtyStyleId;
      };
      TextureSystem3.prototype.setStyle = function(texture, glTexture) {
        var gl = this.gl;
        if (glTexture.mipmap && texture.mipmap !== MIPMAP_MODES.ON_MANUAL) {
          gl.generateMipmap(texture.target);
        }
        gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);
        gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);
        if (glTexture.mipmap) {
          gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
          var anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;
          if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === SCALE_MODES.LINEAR) {
            var level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
            gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
          }
        } else {
          gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
        }
        gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
      };
      TextureSystem3.prototype.destroy = function() {
        this.renderer = null;
      };
      return TextureSystem3;
    }()
  );
  var _systems = {
    __proto__: null,
    FilterSystem,
    BatchSystem,
    ContextSystem,
    FramebufferSystem,
    GeometrySystem,
    MaskSystem,
    ScissorSystem,
    StencilSystem,
    ProjectionSystem,
    RenderTextureSystem,
    ShaderSystem,
    StateSystem,
    TextureGCSystem,
    TextureSystem
  };
  var tempMatrix = new Matrix();
  var AbstractRenderer = (
    /** @class */
    function(_super) {
      __extends2(AbstractRenderer3, _super);
      function AbstractRenderer3(type, options) {
        if (type === void 0) {
          type = RENDERER_TYPE.UNKNOWN;
        }
        var _this = _super.call(this) || this;
        options = Object.assign({}, settings.RENDER_OPTIONS, options);
        _this.options = options;
        _this.type = type;
        _this.screen = new Rectangle(0, 0, options.width, options.height);
        _this.view = options.view || document.createElement("canvas");
        _this.resolution = options.resolution || settings.RESOLUTION;
        _this.useContextAlpha = options.useContextAlpha;
        _this.autoDensity = !!options.autoDensity;
        _this.preserveDrawingBuffer = options.preserveDrawingBuffer;
        _this.clearBeforeRender = options.clearBeforeRender;
        _this._backgroundColor = 0;
        _this._backgroundColorRgba = [0, 0, 0, 1];
        _this._backgroundColorString = "#000000";
        _this.backgroundColor = options.backgroundColor || _this._backgroundColor;
        _this.backgroundAlpha = options.backgroundAlpha;
        if (options.transparent !== void 0) {
          deprecation("6.0.0", "Option transparent is deprecated, please use backgroundAlpha instead.");
          _this.useContextAlpha = options.transparent;
          _this.backgroundAlpha = options.transparent ? 0 : 1;
        }
        _this._lastObjectRendered = null;
        _this.plugins = {};
        return _this;
      }
      AbstractRenderer3.prototype.initPlugins = function(staticMap) {
        for (var o in staticMap) {
          this.plugins[o] = new staticMap[o](this);
        }
      };
      Object.defineProperty(AbstractRenderer3.prototype, "width", {
        /**
         * Same as view.width, actual number of pixels in the canvas by horizontal.
         * @member {number}
         * @readonly
         * @default 800
         */
        get: function() {
          return this.view.width;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractRenderer3.prototype, "height", {
        /**
         * Same as view.height, actual number of pixels in the canvas by vertical.
         * @member {number}
         * @readonly
         * @default 600
         */
        get: function() {
          return this.view.height;
        },
        enumerable: false,
        configurable: true
      });
      AbstractRenderer3.prototype.resize = function(desiredScreenWidth, desiredScreenHeight) {
        this.view.width = Math.round(desiredScreenWidth * this.resolution);
        this.view.height = Math.round(desiredScreenHeight * this.resolution);
        var screenWidth = this.view.width / this.resolution;
        var screenHeight = this.view.height / this.resolution;
        this.screen.width = screenWidth;
        this.screen.height = screenHeight;
        if (this.autoDensity) {
          this.view.style.width = screenWidth + "px";
          this.view.style.height = screenHeight + "px";
        }
        this.emit("resize", screenWidth, screenHeight);
      };
      AbstractRenderer3.prototype.generateTexture = function(displayObject, options, resolution, region) {
        if (options === void 0) {
          options = {};
        }
        if (typeof options === "number") {
          deprecation("6.1.0", "generateTexture options (scaleMode, resolution, region) are now object options.");
          options = { scaleMode: options, resolution, region };
        }
        var manualRegion = options.region, textureOptions = __rest(options, ["region"]);
        region = manualRegion || displayObject.getLocalBounds(null, true);
        if (region.width === 0) {
          region.width = 1;
        }
        if (region.height === 0) {
          region.height = 1;
        }
        var renderTexture = RenderTexture.create(__assign({ width: region.width, height: region.height }, textureOptions));
        tempMatrix.tx = -region.x;
        tempMatrix.ty = -region.y;
        this.render(displayObject, {
          renderTexture,
          clear: false,
          transform: tempMatrix,
          skipUpdateTransform: !!displayObject.parent
        });
        return renderTexture;
      };
      AbstractRenderer3.prototype.destroy = function(removeView) {
        for (var o in this.plugins) {
          this.plugins[o].destroy();
          this.plugins[o] = null;
        }
        if (removeView && this.view.parentNode) {
          this.view.parentNode.removeChild(this.view);
        }
        var thisAny = this;
        thisAny.plugins = null;
        thisAny.type = RENDERER_TYPE.UNKNOWN;
        thisAny.view = null;
        thisAny.screen = null;
        thisAny._tempDisplayObjectParent = null;
        thisAny.options = null;
        this._backgroundColorRgba = null;
        this._backgroundColorString = null;
        this._lastObjectRendered = null;
      };
      Object.defineProperty(AbstractRenderer3.prototype, "backgroundColor", {
        /**
         * The background color to fill if not transparent
         * @member {number}
         */
        get: function() {
          return this._backgroundColor;
        },
        set: function(value) {
          this._backgroundColor = value;
          this._backgroundColorString = hex2string(value);
          hex2rgb(value, this._backgroundColorRgba);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractRenderer3.prototype, "backgroundAlpha", {
        /**
         * The background color alpha. Setting this to 0 will make the canvas transparent.
         * @member {number}
         */
        get: function() {
          return this._backgroundColorRgba[3];
        },
        set: function(value) {
          this._backgroundColorRgba[3] = value;
        },
        enumerable: false,
        configurable: true
      });
      return AbstractRenderer3;
    }(import_eventemitter3.default)
  );
  var GLBuffer = (
    /** @class */
    function() {
      function GLBuffer3(buffer) {
        this.buffer = buffer || null;
        this.updateID = -1;
        this.byteLength = -1;
        this.refCount = 0;
      }
      return GLBuffer3;
    }()
  );
  var BufferSystem = (
    /** @class */
    function() {
      function BufferSystem3(renderer) {
        this.renderer = renderer;
        this.managedBuffers = {};
        this.boundBufferBases = {};
      }
      BufferSystem3.prototype.destroy = function() {
        this.renderer = null;
      };
      BufferSystem3.prototype.contextChange = function() {
        this.disposeAll(true);
        this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID;
      };
      BufferSystem3.prototype.bind = function(buffer) {
        var _a2 = this, gl = _a2.gl, CONTEXT_UID = _a2.CONTEXT_UID;
        var glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
        gl.bindBuffer(buffer.type, glBuffer.buffer);
      };
      BufferSystem3.prototype.bindBufferBase = function(buffer, index) {
        var _a2 = this, gl = _a2.gl, CONTEXT_UID = _a2.CONTEXT_UID;
        if (this.boundBufferBases[index] !== buffer) {
          var glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
          this.boundBufferBases[index] = buffer;
          gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);
        }
      };
      BufferSystem3.prototype.bindBufferRange = function(buffer, index, offset) {
        var _a2 = this, gl = _a2.gl, CONTEXT_UID = _a2.CONTEXT_UID;
        offset = offset || 0;
        var glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
        gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);
      };
      BufferSystem3.prototype.update = function(buffer) {
        var _a2 = this, gl = _a2.gl, CONTEXT_UID = _a2.CONTEXT_UID;
        var glBuffer = buffer._glBuffers[CONTEXT_UID];
        if (buffer._updateID === glBuffer.updateID) {
          return;
        }
        glBuffer.updateID = buffer._updateID;
        gl.bindBuffer(buffer.type, glBuffer.buffer);
        if (glBuffer.byteLength >= buffer.data.byteLength) {
          gl.bufferSubData(buffer.type, 0, buffer.data);
        } else {
          var drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
          glBuffer.byteLength = buffer.data.byteLength;
          gl.bufferData(buffer.type, buffer.data, drawType);
        }
      };
      BufferSystem3.prototype.dispose = function(buffer, contextLost) {
        if (!this.managedBuffers[buffer.id]) {
          return;
        }
        delete this.managedBuffers[buffer.id];
        var glBuffer = buffer._glBuffers[this.CONTEXT_UID];
        var gl = this.gl;
        buffer.disposeRunner.remove(this);
        if (!glBuffer) {
          return;
        }
        if (!contextLost) {
          gl.deleteBuffer(glBuffer.buffer);
        }
        delete buffer._glBuffers[this.CONTEXT_UID];
      };
      BufferSystem3.prototype.disposeAll = function(contextLost) {
        var all = Object.keys(this.managedBuffers);
        for (var i = 0; i < all.length; i++) {
          this.dispose(this.managedBuffers[all[i]], contextLost);
        }
      };
      BufferSystem3.prototype.createGLBuffer = function(buffer) {
        var _a2 = this, CONTEXT_UID = _a2.CONTEXT_UID, gl = _a2.gl;
        buffer._glBuffers[CONTEXT_UID] = new GLBuffer(gl.createBuffer());
        this.managedBuffers[buffer.id] = buffer;
        buffer.disposeRunner.add(this);
        return buffer._glBuffers[CONTEXT_UID];
      };
      return BufferSystem3;
    }()
  );
  var Renderer = (
    /** @class */
    function(_super) {
      __extends2(Renderer2, _super);
      function Renderer2(options) {
        var _this = _super.call(this, RENDERER_TYPE.WEBGL, options) || this;
        options = _this.options;
        _this.gl = null;
        _this.CONTEXT_UID = 0;
        _this.runners = {
          destroy: new Runner("destroy"),
          contextChange: new Runner("contextChange"),
          reset: new Runner("reset"),
          update: new Runner("update"),
          postrender: new Runner("postrender"),
          prerender: new Runner("prerender"),
          resize: new Runner("resize")
        };
        _this.runners.contextChange.add(_this);
        _this.globalUniforms = new UniformGroup({
          projectionMatrix: new Matrix()
        }, true);
        _this.addSystem(MaskSystem, "mask").addSystem(ContextSystem, "context").addSystem(StateSystem, "state").addSystem(ShaderSystem, "shader").addSystem(TextureSystem, "texture").addSystem(BufferSystem, "buffer").addSystem(GeometrySystem, "geometry").addSystem(FramebufferSystem, "framebuffer").addSystem(ScissorSystem, "scissor").addSystem(StencilSystem, "stencil").addSystem(ProjectionSystem, "projection").addSystem(TextureGCSystem, "textureGC").addSystem(FilterSystem, "filter").addSystem(RenderTextureSystem, "renderTexture").addSystem(BatchSystem, "batch");
        _this.initPlugins(Renderer2.__plugins);
        _this.multisample = void 0;
        if (options.context) {
          _this.context.initFromContext(options.context);
        } else {
          _this.context.initFromOptions({
            alpha: !!_this.useContextAlpha,
            antialias: options.antialias,
            premultipliedAlpha: _this.useContextAlpha && _this.useContextAlpha !== "notMultiplied",
            stencil: true,
            preserveDrawingBuffer: options.preserveDrawingBuffer,
            powerPreference: _this.options.powerPreference
          });
        }
        _this.renderingToScreen = true;
        sayHello(_this.context.webGLVersion === 2 ? "WebGL 2" : "WebGL 1");
        _this.resize(_this.options.width, _this.options.height);
        return _this;
      }
      Renderer2.create = function(options) {
        if (isWebGLSupported()) {
          return new Renderer2(options);
        }
        throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.');
      };
      Renderer2.prototype.contextChange = function() {
        var gl = this.gl;
        var samples;
        if (this.context.webGLVersion === 1) {
          var framebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          samples = gl.getParameter(gl.SAMPLES);
          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
        } else {
          var framebuffer = gl.getParameter(gl.DRAW_FRAMEBUFFER_BINDING);
          gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
          samples = gl.getParameter(gl.SAMPLES);
          gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, framebuffer);
        }
        if (samples >= MSAA_QUALITY.HIGH) {
          this.multisample = MSAA_QUALITY.HIGH;
        } else if (samples >= MSAA_QUALITY.MEDIUM) {
          this.multisample = MSAA_QUALITY.MEDIUM;
        } else if (samples >= MSAA_QUALITY.LOW) {
          this.multisample = MSAA_QUALITY.LOW;
        } else {
          this.multisample = MSAA_QUALITY.NONE;
        }
      };
      Renderer2.prototype.addSystem = function(ClassRef, name) {
        var system = new ClassRef(this);
        if (this[name]) {
          throw new Error('Whoops! The name "' + name + '" is already in use');
        }
        this[name] = system;
        for (var i in this.runners) {
          this.runners[i].add(system);
        }
        return this;
      };
      Renderer2.prototype.render = function(displayObject, options) {
        var renderTexture;
        var clear;
        var transform;
        var skipUpdateTransform;
        if (options) {
          if (options instanceof RenderTexture) {
            deprecation("6.0.0", "Renderer#render arguments changed, use options instead.");
            renderTexture = options;
            clear = arguments[2];
            transform = arguments[3];
            skipUpdateTransform = arguments[4];
          } else {
            renderTexture = options.renderTexture;
            clear = options.clear;
            transform = options.transform;
            skipUpdateTransform = options.skipUpdateTransform;
          }
        }
        this.renderingToScreen = !renderTexture;
        this.runners.prerender.emit();
        this.emit("prerender");
        this.projection.transform = transform;
        if (this.context.isLost) {
          return;
        }
        if (!renderTexture) {
          this._lastObjectRendered = displayObject;
        }
        if (!skipUpdateTransform) {
          var cacheParent = displayObject.enableTempParent();
          displayObject.updateTransform();
          displayObject.disableTempParent(cacheParent);
        }
        this.renderTexture.bind(renderTexture);
        this.batch.currentRenderer.start();
        if (clear !== void 0 ? clear : this.clearBeforeRender) {
          this.renderTexture.clear();
        }
        displayObject.render(this);
        this.batch.currentRenderer.flush();
        if (renderTexture) {
          renderTexture.baseTexture.update();
        }
        this.runners.postrender.emit();
        this.projection.transform = null;
        this.emit("postrender");
      };
      Renderer2.prototype.generateTexture = function(displayObject, options, resolution, region) {
        if (options === void 0) {
          options = {};
        }
        var renderTexture = _super.prototype.generateTexture.call(this, displayObject, options, resolution, region);
        this.framebuffer.blit();
        return renderTexture;
      };
      Renderer2.prototype.resize = function(desiredScreenWidth, desiredScreenHeight) {
        _super.prototype.resize.call(this, desiredScreenWidth, desiredScreenHeight);
        this.runners.resize.emit(this.screen.height, this.screen.width);
      };
      Renderer2.prototype.reset = function() {
        this.runners.reset.emit();
        return this;
      };
      Renderer2.prototype.clear = function() {
        this.renderTexture.bind();
        this.renderTexture.clear();
      };
      Renderer2.prototype.destroy = function(removeView) {
        this.runners.destroy.emit();
        for (var r in this.runners) {
          this.runners[r].destroy();
        }
        _super.prototype.destroy.call(this, removeView);
        this.gl = null;
      };
      Object.defineProperty(Renderer2.prototype, "extract", {
        /**
         * Please use `plugins.extract` instead.
         * @member {PIXI.Extract} extract
         * @deprecated since 6.0.0
         * @readonly
         */
        get: function() {
          deprecation("6.0.0", "Renderer#extract has been deprecated, please use Renderer#plugins.extract instead.");
          return this.plugins.extract;
        },
        enumerable: false,
        configurable: true
      });
      Renderer2.registerPlugin = function(pluginName, ctor) {
        Renderer2.__plugins = Renderer2.__plugins || {};
        Renderer2.__plugins[pluginName] = ctor;
      };
      return Renderer2;
    }(AbstractRenderer)
  );
  function autoDetectRenderer(options) {
    return Renderer.create(options);
  }
  var $defaultVertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
  var $defaultFilterVertex = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
  var defaultVertex$1 = $defaultVertex;
  var defaultFilterVertex = $defaultFilterVertex;
  var System = (
    /** @class */
    function() {
      function System2(renderer) {
        deprecation("6.1.0", "System class is deprecated, implemement ISystem interface instead.");
        this.renderer = renderer;
      }
      System2.prototype.destroy = function() {
        this.renderer = null;
      };
      return System2;
    }()
  );
  var BatchDrawCall = (
    /** @class */
    function() {
      function BatchDrawCall3() {
        this.texArray = null;
        this.blend = 0;
        this.type = DRAW_MODES.TRIANGLES;
        this.start = 0;
        this.size = 0;
        this.data = null;
      }
      return BatchDrawCall3;
    }()
  );
  var BatchTextureArray = (
    /** @class */
    function() {
      function BatchTextureArray3() {
        this.elements = [];
        this.ids = [];
        this.count = 0;
      }
      BatchTextureArray3.prototype.clear = function() {
        for (var i = 0; i < this.count; i++) {
          this.elements[i] = null;
        }
        this.count = 0;
      };
      return BatchTextureArray3;
    }()
  );
  var ViewableBuffer = (
    /** @class */
    function() {
      function ViewableBuffer3(sizeOrBuffer) {
        if (typeof sizeOrBuffer === "number") {
          this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
        } else if (sizeOrBuffer instanceof Uint8Array) {
          this.rawBinaryData = sizeOrBuffer.buffer;
        } else {
          this.rawBinaryData = sizeOrBuffer;
        }
        this.uint32View = new Uint32Array(this.rawBinaryData);
        this.float32View = new Float32Array(this.rawBinaryData);
      }
      Object.defineProperty(ViewableBuffer3.prototype, "int8View", {
        /** View on the raw binary data as a `Int8Array`. */
        get: function() {
          if (!this._int8View) {
            this._int8View = new Int8Array(this.rawBinaryData);
          }
          return this._int8View;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ViewableBuffer3.prototype, "uint8View", {
        /** View on the raw binary data as a `Uint8Array`. */
        get: function() {
          if (!this._uint8View) {
            this._uint8View = new Uint8Array(this.rawBinaryData);
          }
          return this._uint8View;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ViewableBuffer3.prototype, "int16View", {
        /**  View on the raw binary data as a `Int16Array`. */
        get: function() {
          if (!this._int16View) {
            this._int16View = new Int16Array(this.rawBinaryData);
          }
          return this._int16View;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ViewableBuffer3.prototype, "uint16View", {
        /** View on the raw binary data as a `Uint16Array`. */
        get: function() {
          if (!this._uint16View) {
            this._uint16View = new Uint16Array(this.rawBinaryData);
          }
          return this._uint16View;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ViewableBuffer3.prototype, "int32View", {
        /** View on the raw binary data as a `Int32Array`. */
        get: function() {
          if (!this._int32View) {
            this._int32View = new Int32Array(this.rawBinaryData);
          }
          return this._int32View;
        },
        enumerable: false,
        configurable: true
      });
      ViewableBuffer3.prototype.view = function(type) {
        return this[type + "View"];
      };
      ViewableBuffer3.prototype.destroy = function() {
        this.rawBinaryData = null;
        this._int8View = null;
        this._uint8View = null;
        this._int16View = null;
        this._uint16View = null;
        this._int32View = null;
        this.uint32View = null;
        this.float32View = null;
      };
      ViewableBuffer3.sizeOf = function(type) {
        switch (type) {
          case "int8":
          case "uint8":
            return 1;
          case "int16":
          case "uint16":
            return 2;
          case "int32":
          case "uint32":
          case "float32":
            return 4;
          default:
            throw new Error(type + " isn't a valid view type");
        }
      };
      return ViewableBuffer3;
    }()
  );
  var AbstractBatchRenderer = (
    /** @class */
    function(_super) {
      __extends2(AbstractBatchRenderer3, _super);
      function AbstractBatchRenderer3(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.shaderGenerator = null;
        _this.geometryClass = null;
        _this.vertexSize = null;
        _this.state = State.for2d();
        _this.size = settings.SPRITE_BATCH_SIZE * 4;
        _this._vertexCount = 0;
        _this._indexCount = 0;
        _this._bufferedElements = [];
        _this._bufferedTextures = [];
        _this._bufferSize = 0;
        _this._shader = null;
        _this._packedGeometries = [];
        _this._packedGeometryPoolSize = 2;
        _this._flushId = 0;
        _this._aBuffers = {};
        _this._iBuffers = {};
        _this.MAX_TEXTURES = 1;
        _this.renderer.on("prerender", _this.onPrerender, _this);
        renderer.runners.contextChange.add(_this);
        _this._dcIndex = 0;
        _this._aIndex = 0;
        _this._iIndex = 0;
        _this._attributeBuffer = null;
        _this._indexBuffer = null;
        _this._tempBoundTextures = [];
        return _this;
      }
      AbstractBatchRenderer3.prototype.contextChange = function() {
        var gl = this.renderer.gl;
        if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
          this.MAX_TEXTURES = 1;
        } else {
          this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), settings.SPRITE_MAX_TEXTURES);
          this.MAX_TEXTURES = checkMaxIfStatementsInShader(this.MAX_TEXTURES, gl);
        }
        this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);
        for (var i = 0; i < this._packedGeometryPoolSize; i++) {
          this._packedGeometries[i] = new this.geometryClass();
        }
        this.initFlushBuffers();
      };
      AbstractBatchRenderer3.prototype.initFlushBuffers = function() {
        var _drawCallPool = AbstractBatchRenderer3._drawCallPool, _textureArrayPool = AbstractBatchRenderer3._textureArrayPool;
        var MAX_SPRITES = this.size / 4;
        var MAX_TA = Math.floor(MAX_SPRITES / this.MAX_TEXTURES) + 1;
        while (_drawCallPool.length < MAX_SPRITES) {
          _drawCallPool.push(new BatchDrawCall());
        }
        while (_textureArrayPool.length < MAX_TA) {
          _textureArrayPool.push(new BatchTextureArray());
        }
        for (var i = 0; i < this.MAX_TEXTURES; i++) {
          this._tempBoundTextures[i] = null;
        }
      };
      AbstractBatchRenderer3.prototype.onPrerender = function() {
        this._flushId = 0;
      };
      AbstractBatchRenderer3.prototype.render = function(element) {
        if (!element._texture.valid) {
          return;
        }
        if (this._vertexCount + element.vertexData.length / 2 > this.size) {
          this.flush();
        }
        this._vertexCount += element.vertexData.length / 2;
        this._indexCount += element.indices.length;
        this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;
        this._bufferedElements[this._bufferSize++] = element;
      };
      AbstractBatchRenderer3.prototype.buildTexturesAndDrawCalls = function() {
        var _a2 = this, textures = _a2._bufferedTextures, MAX_TEXTURES = _a2.MAX_TEXTURES;
        var textureArrays = AbstractBatchRenderer3._textureArrayPool;
        var batch = this.renderer.batch;
        var boundTextures = this._tempBoundTextures;
        var touch = this.renderer.textureGC.count;
        var TICK = ++BaseTexture._globalBatch;
        var countTexArrays = 0;
        var texArray = textureArrays[0];
        var start = 0;
        batch.copyBoundTextures(boundTextures, MAX_TEXTURES);
        for (var i = 0; i < this._bufferSize; ++i) {
          var tex = textures[i];
          textures[i] = null;
          if (tex._batchEnabled === TICK) {
            continue;
          }
          if (texArray.count >= MAX_TEXTURES) {
            batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);
            this.buildDrawCalls(texArray, start, i);
            start = i;
            texArray = textureArrays[++countTexArrays];
            ++TICK;
          }
          tex._batchEnabled = TICK;
          tex.touched = touch;
          texArray.elements[texArray.count++] = tex;
        }
        if (texArray.count > 0) {
          batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);
          this.buildDrawCalls(texArray, start, this._bufferSize);
          ++countTexArrays;
          ++TICK;
        }
        for (var i = 0; i < boundTextures.length; i++) {
          boundTextures[i] = null;
        }
        BaseTexture._globalBatch = TICK;
      };
      AbstractBatchRenderer3.prototype.buildDrawCalls = function(texArray, start, finish) {
        var _a2 = this, elements = _a2._bufferedElements, _attributeBuffer = _a2._attributeBuffer, _indexBuffer = _a2._indexBuffer, vertexSize = _a2.vertexSize;
        var drawCalls = AbstractBatchRenderer3._drawCallPool;
        var dcIndex = this._dcIndex;
        var aIndex = this._aIndex;
        var iIndex = this._iIndex;
        var drawCall = drawCalls[dcIndex];
        drawCall.start = this._iIndex;
        drawCall.texArray = texArray;
        for (var i = start; i < finish; ++i) {
          var sprite = elements[i];
          var tex = sprite._texture.baseTexture;
          var spriteBlendMode = premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];
          elements[i] = null;
          if (start < i && drawCall.blend !== spriteBlendMode) {
            drawCall.size = iIndex - drawCall.start;
            start = i;
            drawCall = drawCalls[++dcIndex];
            drawCall.texArray = texArray;
            drawCall.start = iIndex;
          }
          this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);
          aIndex += sprite.vertexData.length / 2 * vertexSize;
          iIndex += sprite.indices.length;
          drawCall.blend = spriteBlendMode;
        }
        if (start < finish) {
          drawCall.size = iIndex - drawCall.start;
          ++dcIndex;
        }
        this._dcIndex = dcIndex;
        this._aIndex = aIndex;
        this._iIndex = iIndex;
      };
      AbstractBatchRenderer3.prototype.bindAndClearTexArray = function(texArray) {
        var textureSystem = this.renderer.texture;
        for (var j = 0; j < texArray.count; j++) {
          textureSystem.bind(texArray.elements[j], texArray.ids[j]);
          texArray.elements[j] = null;
        }
        texArray.count = 0;
      };
      AbstractBatchRenderer3.prototype.updateGeometry = function() {
        var _a2 = this, packedGeometries = _a2._packedGeometries, attributeBuffer = _a2._attributeBuffer, indexBuffer = _a2._indexBuffer;
        if (!settings.CAN_UPLOAD_SAME_BUFFER) {
          if (this._packedGeometryPoolSize <= this._flushId) {
            this._packedGeometryPoolSize++;
            packedGeometries[this._flushId] = new this.geometryClass();
          }
          packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
          packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
          this.renderer.geometry.bind(packedGeometries[this._flushId]);
          this.renderer.geometry.updateBuffers();
          this._flushId++;
        } else {
          packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
          packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
          this.renderer.geometry.updateBuffers();
        }
      };
      AbstractBatchRenderer3.prototype.drawBatches = function() {
        var dcCount = this._dcIndex;
        var _a2 = this.renderer, gl = _a2.gl, stateSystem = _a2.state;
        var drawCalls = AbstractBatchRenderer3._drawCallPool;
        var curTexArray = null;
        for (var i = 0; i < dcCount; i++) {
          var _b = drawCalls[i], texArray = _b.texArray, type = _b.type, size = _b.size, start = _b.start, blend = _b.blend;
          if (curTexArray !== texArray) {
            curTexArray = texArray;
            this.bindAndClearTexArray(texArray);
          }
          this.state.blendMode = blend;
          stateSystem.set(this.state);
          gl.drawElements(type, size, gl.UNSIGNED_SHORT, start * 2);
        }
      };
      AbstractBatchRenderer3.prototype.flush = function() {
        if (this._vertexCount === 0) {
          return;
        }
        this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);
        this._indexBuffer = this.getIndexBuffer(this._indexCount);
        this._aIndex = 0;
        this._iIndex = 0;
        this._dcIndex = 0;
        this.buildTexturesAndDrawCalls();
        this.updateGeometry();
        this.drawBatches();
        this._bufferSize = 0;
        this._vertexCount = 0;
        this._indexCount = 0;
      };
      AbstractBatchRenderer3.prototype.start = function() {
        this.renderer.state.set(this.state);
        this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES);
        this.renderer.shader.bind(this._shader);
        if (settings.CAN_UPLOAD_SAME_BUFFER) {
          this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
        }
      };
      AbstractBatchRenderer3.prototype.stop = function() {
        this.flush();
      };
      AbstractBatchRenderer3.prototype.destroy = function() {
        for (var i = 0; i < this._packedGeometryPoolSize; i++) {
          if (this._packedGeometries[i]) {
            this._packedGeometries[i].destroy();
          }
        }
        this.renderer.off("prerender", this.onPrerender, this);
        this._aBuffers = null;
        this._iBuffers = null;
        this._packedGeometries = null;
        this._attributeBuffer = null;
        this._indexBuffer = null;
        if (this._shader) {
          this._shader.destroy();
          this._shader = null;
        }
        _super.prototype.destroy.call(this);
      };
      AbstractBatchRenderer3.prototype.getAttributeBuffer = function(size) {
        var roundedP2 = nextPow2(Math.ceil(size / 8));
        var roundedSizeIndex = log2(roundedP2);
        var roundedSize = roundedP2 * 8;
        if (this._aBuffers.length <= roundedSizeIndex) {
          this._iBuffers.length = roundedSizeIndex + 1;
        }
        var buffer = this._aBuffers[roundedSize];
        if (!buffer) {
          this._aBuffers[roundedSize] = buffer = new ViewableBuffer(roundedSize * this.vertexSize * 4);
        }
        return buffer;
      };
      AbstractBatchRenderer3.prototype.getIndexBuffer = function(size) {
        var roundedP2 = nextPow2(Math.ceil(size / 12));
        var roundedSizeIndex = log2(roundedP2);
        var roundedSize = roundedP2 * 12;
        if (this._iBuffers.length <= roundedSizeIndex) {
          this._iBuffers.length = roundedSizeIndex + 1;
        }
        var buffer = this._iBuffers[roundedSizeIndex];
        if (!buffer) {
          this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);
        }
        return buffer;
      };
      AbstractBatchRenderer3.prototype.packInterleavedGeometry = function(element, attributeBuffer, indexBuffer, aIndex, iIndex) {
        var uint32View = attributeBuffer.uint32View, float32View = attributeBuffer.float32View;
        var packedVertices = aIndex / this.vertexSize;
        var uvs = element.uvs;
        var indicies = element.indices;
        var vertexData = element.vertexData;
        var textureId = element._texture.baseTexture._batchLocation;
        var alpha = Math.min(element.worldAlpha, 1);
        var argb = alpha < 1 && element._texture.baseTexture.alphaMode ? premultiplyTint(element._tintRGB, alpha) : element._tintRGB + (alpha * 255 << 24);
        for (var i = 0; i < vertexData.length; i += 2) {
          float32View[aIndex++] = vertexData[i];
          float32View[aIndex++] = vertexData[i + 1];
          float32View[aIndex++] = uvs[i];
          float32View[aIndex++] = uvs[i + 1];
          uint32View[aIndex++] = argb;
          float32View[aIndex++] = textureId;
        }
        for (var i = 0; i < indicies.length; i++) {
          indexBuffer[iIndex++] = packedVertices + indicies[i];
        }
      };
      AbstractBatchRenderer3._drawCallPool = [];
      AbstractBatchRenderer3._textureArrayPool = [];
      return AbstractBatchRenderer3;
    }(ObjectRenderer)
  );
  var BatchShaderGenerator = (
    /** @class */
    function() {
      function BatchShaderGenerator3(vertexSrc, fragTemplate3) {
        this.vertexSrc = vertexSrc;
        this.fragTemplate = fragTemplate3;
        this.programCache = {};
        this.defaultGroupCache = {};
        if (fragTemplate3.indexOf("%count%") < 0) {
          throw new Error('Fragment template must contain "%count%".');
        }
        if (fragTemplate3.indexOf("%forloop%") < 0) {
          throw new Error('Fragment template must contain "%forloop%".');
        }
      }
      BatchShaderGenerator3.prototype.generateShader = function(maxTextures) {
        if (!this.programCache[maxTextures]) {
          var sampleValues = new Int32Array(maxTextures);
          for (var i = 0; i < maxTextures; i++) {
            sampleValues[i] = i;
          }
          this.defaultGroupCache[maxTextures] = UniformGroup.from({ uSamplers: sampleValues }, true);
          var fragmentSrc = this.fragTemplate;
          fragmentSrc = fragmentSrc.replace(/%count%/gi, "" + maxTextures);
          fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));
          this.programCache[maxTextures] = new Program(this.vertexSrc, fragmentSrc);
        }
        var uniforms = {
          tint: new Float32Array([1, 1, 1, 1]),
          translationMatrix: new Matrix(),
          default: this.defaultGroupCache[maxTextures]
        };
        return new Shader(this.programCache[maxTextures], uniforms);
      };
      BatchShaderGenerator3.prototype.generateSampleSrc = function(maxTextures) {
        var src = "";
        src += "\n";
        src += "\n";
        for (var i = 0; i < maxTextures; i++) {
          if (i > 0) {
            src += "\nelse ";
          }
          if (i < maxTextures - 1) {
            src += "if(vTextureId < " + i + ".5)";
          }
          src += "\n{";
          src += "\n	color = texture2D(uSamplers[" + i + "], vTextureCoord);";
          src += "\n}";
        }
        src += "\n";
        src += "\n";
        return src;
      };
      return BatchShaderGenerator3;
    }()
  );
  var BatchGeometry = (
    /** @class */
    function(_super) {
      __extends2(BatchGeometry3, _super);
      function BatchGeometry3(_static) {
        if (_static === void 0) {
          _static = false;
        }
        var _this = _super.call(this) || this;
        _this._buffer = new Buffer2(null, _static, false);
        _this._indexBuffer = new Buffer2(null, _static, true);
        _this.addAttribute("aVertexPosition", _this._buffer, 2, false, TYPES.FLOAT).addAttribute("aTextureCoord", _this._buffer, 2, false, TYPES.FLOAT).addAttribute("aColor", _this._buffer, 4, true, TYPES.UNSIGNED_BYTE).addAttribute("aTextureId", _this._buffer, 1, true, TYPES.FLOAT).addIndex(_this._indexBuffer);
        return _this;
      }
      return BatchGeometry3;
    }(Geometry)
  );
  var defaultVertex = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n";
  var defaultFragment = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n";
  var BatchPluginFactory = (
    /** @class */
    function() {
      function BatchPluginFactory3() {
      }
      BatchPluginFactory3.create = function(options) {
        var _a2 = Object.assign({
          vertex: defaultVertex,
          fragment: defaultFragment,
          geometryClass: BatchGeometry,
          vertexSize: 6
        }, options), vertex6 = _a2.vertex, fragment8 = _a2.fragment, vertexSize = _a2.vertexSize, geometryClass = _a2.geometryClass;
        return (
          /** @class */
          function(_super) {
            __extends2(BatchPlugin, _super);
            function BatchPlugin(renderer) {
              var _this = _super.call(this, renderer) || this;
              _this.shaderGenerator = new BatchShaderGenerator(vertex6, fragment8);
              _this.geometryClass = geometryClass;
              _this.vertexSize = vertexSize;
              return _this;
            }
            return BatchPlugin;
          }(AbstractBatchRenderer)
        );
      };
      Object.defineProperty(BatchPluginFactory3, "defaultVertexSrc", {
        /**
         * The default vertex shader source
         * @readonly
         */
        get: function() {
          return defaultVertex;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BatchPluginFactory3, "defaultFragmentTemplate", {
        /**
         * The default fragment shader source
         * @readonly
         */
        get: function() {
          return defaultFragment;
        },
        enumerable: false,
        configurable: true
      });
      return BatchPluginFactory3;
    }()
  );
  var BatchRenderer = BatchPluginFactory.create();
  var resources = {};
  var _loop_1 = function(name) {
    Object.defineProperty(resources, name, {
      get: function() {
        deprecation("6.0.0", "PIXI.systems." + name + " has moved to PIXI." + name);
        return _resources[name];
      }
    });
  };
  for (name in _resources) {
    _loop_1(name);
  }
  var name;
  var systems = {};
  var _loop_2 = function(name) {
    Object.defineProperty(systems, name, {
      get: function() {
        deprecation("6.0.0", "PIXI.resources." + name + " has moved to PIXI." + name);
        return _systems[name];
      }
    });
  };
  for (name in _systems) {
    _loop_2(name);
  }
  var name;

  // node_modules/@pixi/canvas-display/dist/esm/canvas-display.js
  Container.prototype._renderCanvas = function _renderCanvas(_renderer) {
  };
  Container.prototype.renderCanvas = function renderCanvas(renderer) {
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
      return;
    }
    if (this._mask) {
      renderer.maskManager.pushMask(this._mask);
    }
    this._renderCanvas(renderer);
    for (var i = 0, j = this.children.length; i < j; ++i) {
      this.children[i].renderCanvas(renderer);
    }
    if (this._mask) {
      renderer.maskManager.popMask(renderer);
    }
  };
  DisplayObject.prototype.renderCanvas = function renderCanvas2(_renderer) {
  };

  // node_modules/@pixi/extract/dist/esm/extract.js
  var appleIphone2 = /iPhone/i;
  var appleIpod2 = /iPod/i;
  var appleTablet2 = /iPad/i;
  var appleUniversal2 = /\biOS-universal(?:.+)Mac\b/i;
  var androidPhone2 = /\bAndroid(?:.+)Mobile\b/i;
  var androidTablet2 = /Android/i;
  var amazonPhone2 = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
  var amazonTablet2 = /Silk/i;
  var windowsPhone2 = /Windows Phone/i;
  var windowsTablet2 = /\bWindows(?:.+)ARM\b/i;
  var otherBlackBerry2 = /BlackBerry/i;
  var otherBlackBerry102 = /BB10/i;
  var otherOpera2 = /Opera Mini/i;
  var otherChrome2 = /\b(CriOS|Chrome)(?:.+)Mobile/i;
  var otherFirefox2 = /Mobile(?:.+)Firefox\b/i;
  var isAppleTabletOnIos132 = function(navigator2) {
    return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && navigator2.maxTouchPoints > 1 && typeof MSStream === "undefined";
  };
  function createMatch2(userAgent) {
    return function(regex) {
      return regex.test(userAgent);
    };
  }
  function isMobile$1(param) {
    var nav = {
      userAgent: "",
      platform: "",
      maxTouchPoints: 0
    };
    if (!param && typeof navigator !== "undefined") {
      nav = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        maxTouchPoints: navigator.maxTouchPoints || 0
      };
    } else if (typeof param === "string") {
      nav.userAgent = param;
    } else if (param && param.userAgent) {
      nav = {
        userAgent: param.userAgent,
        platform: param.platform,
        maxTouchPoints: param.maxTouchPoints || 0
      };
    }
    var userAgent = nav.userAgent;
    var tmp = userAgent.split("[FBAN");
    if (typeof tmp[1] !== "undefined") {
      userAgent = tmp[0];
    }
    tmp = userAgent.split("Twitter");
    if (typeof tmp[1] !== "undefined") {
      userAgent = tmp[0];
    }
    var match = createMatch2(userAgent);
    var result = {
      apple: {
        phone: match(appleIphone2) && !match(windowsPhone2),
        ipod: match(appleIpod2),
        tablet: !match(appleIphone2) && (match(appleTablet2) || isAppleTabletOnIos132(nav)) && !match(windowsPhone2),
        universal: match(appleUniversal2),
        device: (match(appleIphone2) || match(appleIpod2) || match(appleTablet2) || match(appleUniversal2) || isAppleTabletOnIos132(nav)) && !match(windowsPhone2)
      },
      amazon: {
        phone: match(amazonPhone2),
        tablet: !match(amazonPhone2) && match(amazonTablet2),
        device: match(amazonPhone2) || match(amazonTablet2)
      },
      android: {
        phone: !match(windowsPhone2) && match(amazonPhone2) || !match(windowsPhone2) && match(androidPhone2),
        tablet: !match(windowsPhone2) && !match(amazonPhone2) && !match(androidPhone2) && (match(amazonTablet2) || match(androidTablet2)),
        device: !match(windowsPhone2) && (match(amazonPhone2) || match(amazonTablet2) || match(androidPhone2) || match(androidTablet2)) || match(/\bokhttp\b/i)
      },
      windows: {
        phone: match(windowsPhone2),
        tablet: match(windowsTablet2),
        device: match(windowsPhone2) || match(windowsTablet2)
      },
      other: {
        blackberry: match(otherBlackBerry2),
        blackberry10: match(otherBlackBerry102),
        opera: match(otherOpera2),
        firefox: match(otherFirefox2),
        chrome: match(otherChrome2),
        device: match(otherBlackBerry2) || match(otherBlackBerry102) || match(otherOpera2) || match(otherFirefox2) || match(otherChrome2)
      },
      any: false,
      phone: false,
      tablet: false
    };
    result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
    result.phone = result.apple.phone || result.android.phone || result.windows.phone;
    result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
    return result;
  }
  var isMobile3 = isMobile$1(globalThis.navigator);
  function maxRecommendedTextures2(max) {
    var allowMax = true;
    if (isMobile3.tablet || isMobile3.phone) {
      if (isMobile3.apple.device) {
        var match = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
        if (match) {
          var majorVersion = parseInt(match[1], 10);
          if (majorVersion < 11) {
            allowMax = false;
          }
        }
      }
      if (isMobile3.android.device) {
        var match = navigator.userAgent.match(/Android\s([0-9.]*)/);
        if (match) {
          var majorVersion = parseInt(match[1], 10);
          if (majorVersion < 7) {
            allowMax = false;
          }
        }
      }
    }
    return allowMax ? max : 4;
  }
  function canUploadSameBuffer2() {
    return !isMobile3.apple.device;
  }
  var ENV$1;
  (function(ENV6) {
    ENV6[ENV6["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
    ENV6[ENV6["WEBGL"] = 1] = "WEBGL";
    ENV6[ENV6["WEBGL2"] = 2] = "WEBGL2";
  })(ENV$1 || (ENV$1 = {}));
  var RENDERER_TYPE$1;
  (function(RENDERER_TYPE6) {
    RENDERER_TYPE6[RENDERER_TYPE6["UNKNOWN"] = 0] = "UNKNOWN";
    RENDERER_TYPE6[RENDERER_TYPE6["WEBGL"] = 1] = "WEBGL";
    RENDERER_TYPE6[RENDERER_TYPE6["CANVAS"] = 2] = "CANVAS";
  })(RENDERER_TYPE$1 || (RENDERER_TYPE$1 = {}));
  var BUFFER_BITS$1;
  (function(BUFFER_BITS6) {
    BUFFER_BITS6[BUFFER_BITS6["COLOR"] = 16384] = "COLOR";
    BUFFER_BITS6[BUFFER_BITS6["DEPTH"] = 256] = "DEPTH";
    BUFFER_BITS6[BUFFER_BITS6["STENCIL"] = 1024] = "STENCIL";
  })(BUFFER_BITS$1 || (BUFFER_BITS$1 = {}));
  var BLEND_MODES$1;
  (function(BLEND_MODES6) {
    BLEND_MODES6[BLEND_MODES6["NORMAL"] = 0] = "NORMAL";
    BLEND_MODES6[BLEND_MODES6["ADD"] = 1] = "ADD";
    BLEND_MODES6[BLEND_MODES6["MULTIPLY"] = 2] = "MULTIPLY";
    BLEND_MODES6[BLEND_MODES6["SCREEN"] = 3] = "SCREEN";
    BLEND_MODES6[BLEND_MODES6["OVERLAY"] = 4] = "OVERLAY";
    BLEND_MODES6[BLEND_MODES6["DARKEN"] = 5] = "DARKEN";
    BLEND_MODES6[BLEND_MODES6["LIGHTEN"] = 6] = "LIGHTEN";
    BLEND_MODES6[BLEND_MODES6["COLOR_DODGE"] = 7] = "COLOR_DODGE";
    BLEND_MODES6[BLEND_MODES6["COLOR_BURN"] = 8] = "COLOR_BURN";
    BLEND_MODES6[BLEND_MODES6["HARD_LIGHT"] = 9] = "HARD_LIGHT";
    BLEND_MODES6[BLEND_MODES6["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
    BLEND_MODES6[BLEND_MODES6["DIFFERENCE"] = 11] = "DIFFERENCE";
    BLEND_MODES6[BLEND_MODES6["EXCLUSION"] = 12] = "EXCLUSION";
    BLEND_MODES6[BLEND_MODES6["HUE"] = 13] = "HUE";
    BLEND_MODES6[BLEND_MODES6["SATURATION"] = 14] = "SATURATION";
    BLEND_MODES6[BLEND_MODES6["COLOR"] = 15] = "COLOR";
    BLEND_MODES6[BLEND_MODES6["LUMINOSITY"] = 16] = "LUMINOSITY";
    BLEND_MODES6[BLEND_MODES6["NORMAL_NPM"] = 17] = "NORMAL_NPM";
    BLEND_MODES6[BLEND_MODES6["ADD_NPM"] = 18] = "ADD_NPM";
    BLEND_MODES6[BLEND_MODES6["SCREEN_NPM"] = 19] = "SCREEN_NPM";
    BLEND_MODES6[BLEND_MODES6["NONE"] = 20] = "NONE";
    BLEND_MODES6[BLEND_MODES6["SRC_OVER"] = 0] = "SRC_OVER";
    BLEND_MODES6[BLEND_MODES6["SRC_IN"] = 21] = "SRC_IN";
    BLEND_MODES6[BLEND_MODES6["SRC_OUT"] = 22] = "SRC_OUT";
    BLEND_MODES6[BLEND_MODES6["SRC_ATOP"] = 23] = "SRC_ATOP";
    BLEND_MODES6[BLEND_MODES6["DST_OVER"] = 24] = "DST_OVER";
    BLEND_MODES6[BLEND_MODES6["DST_IN"] = 25] = "DST_IN";
    BLEND_MODES6[BLEND_MODES6["DST_OUT"] = 26] = "DST_OUT";
    BLEND_MODES6[BLEND_MODES6["DST_ATOP"] = 27] = "DST_ATOP";
    BLEND_MODES6[BLEND_MODES6["ERASE"] = 26] = "ERASE";
    BLEND_MODES6[BLEND_MODES6["SUBTRACT"] = 28] = "SUBTRACT";
    BLEND_MODES6[BLEND_MODES6["XOR"] = 29] = "XOR";
  })(BLEND_MODES$1 || (BLEND_MODES$1 = {}));
  var DRAW_MODES$1;
  (function(DRAW_MODES6) {
    DRAW_MODES6[DRAW_MODES6["POINTS"] = 0] = "POINTS";
    DRAW_MODES6[DRAW_MODES6["LINES"] = 1] = "LINES";
    DRAW_MODES6[DRAW_MODES6["LINE_LOOP"] = 2] = "LINE_LOOP";
    DRAW_MODES6[DRAW_MODES6["LINE_STRIP"] = 3] = "LINE_STRIP";
    DRAW_MODES6[DRAW_MODES6["TRIANGLES"] = 4] = "TRIANGLES";
    DRAW_MODES6[DRAW_MODES6["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
    DRAW_MODES6[DRAW_MODES6["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
  })(DRAW_MODES$1 || (DRAW_MODES$1 = {}));
  var FORMATS$1;
  (function(FORMATS6) {
    FORMATS6[FORMATS6["RGBA"] = 6408] = "RGBA";
    FORMATS6[FORMATS6["RGB"] = 6407] = "RGB";
    FORMATS6[FORMATS6["RG"] = 33319] = "RG";
    FORMATS6[FORMATS6["RED"] = 6403] = "RED";
    FORMATS6[FORMATS6["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
    FORMATS6[FORMATS6["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
    FORMATS6[FORMATS6["RG_INTEGER"] = 33320] = "RG_INTEGER";
    FORMATS6[FORMATS6["RED_INTEGER"] = 36244] = "RED_INTEGER";
    FORMATS6[FORMATS6["ALPHA"] = 6406] = "ALPHA";
    FORMATS6[FORMATS6["LUMINANCE"] = 6409] = "LUMINANCE";
    FORMATS6[FORMATS6["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
    FORMATS6[FORMATS6["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
    FORMATS6[FORMATS6["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
  })(FORMATS$1 || (FORMATS$1 = {}));
  var TARGETS$1;
  (function(TARGETS6) {
    TARGETS6[TARGETS6["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
    TARGETS6[TARGETS6["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  })(TARGETS$1 || (TARGETS$1 = {}));
  var TYPES$1;
  (function(TYPES6) {
    TYPES6[TYPES6["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    TYPES6[TYPES6["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    TYPES6[TYPES6["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
    TYPES6[TYPES6["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
    TYPES6[TYPES6["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
    TYPES6[TYPES6["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
    TYPES6[TYPES6["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
    TYPES6[TYPES6["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
    TYPES6[TYPES6["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
    TYPES6[TYPES6["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
    TYPES6[TYPES6["BYTE"] = 5120] = "BYTE";
    TYPES6[TYPES6["SHORT"] = 5122] = "SHORT";
    TYPES6[TYPES6["INT"] = 5124] = "INT";
    TYPES6[TYPES6["FLOAT"] = 5126] = "FLOAT";
    TYPES6[TYPES6["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
    TYPES6[TYPES6["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
  })(TYPES$1 || (TYPES$1 = {}));
  var SAMPLER_TYPES$1;
  (function(SAMPLER_TYPES6) {
    SAMPLER_TYPES6[SAMPLER_TYPES6["FLOAT"] = 0] = "FLOAT";
    SAMPLER_TYPES6[SAMPLER_TYPES6["INT"] = 1] = "INT";
    SAMPLER_TYPES6[SAMPLER_TYPES6["UINT"] = 2] = "UINT";
  })(SAMPLER_TYPES$1 || (SAMPLER_TYPES$1 = {}));
  var SCALE_MODES$1;
  (function(SCALE_MODES6) {
    SCALE_MODES6[SCALE_MODES6["NEAREST"] = 0] = "NEAREST";
    SCALE_MODES6[SCALE_MODES6["LINEAR"] = 1] = "LINEAR";
  })(SCALE_MODES$1 || (SCALE_MODES$1 = {}));
  var WRAP_MODES$1;
  (function(WRAP_MODES6) {
    WRAP_MODES6[WRAP_MODES6["CLAMP"] = 33071] = "CLAMP";
    WRAP_MODES6[WRAP_MODES6["REPEAT"] = 10497] = "REPEAT";
    WRAP_MODES6[WRAP_MODES6["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
  })(WRAP_MODES$1 || (WRAP_MODES$1 = {}));
  var MIPMAP_MODES$1;
  (function(MIPMAP_MODES6) {
    MIPMAP_MODES6[MIPMAP_MODES6["OFF"] = 0] = "OFF";
    MIPMAP_MODES6[MIPMAP_MODES6["POW2"] = 1] = "POW2";
    MIPMAP_MODES6[MIPMAP_MODES6["ON"] = 2] = "ON";
    MIPMAP_MODES6[MIPMAP_MODES6["ON_MANUAL"] = 3] = "ON_MANUAL";
  })(MIPMAP_MODES$1 || (MIPMAP_MODES$1 = {}));
  var ALPHA_MODES$1;
  (function(ALPHA_MODES6) {
    ALPHA_MODES6[ALPHA_MODES6["NPM"] = 0] = "NPM";
    ALPHA_MODES6[ALPHA_MODES6["UNPACK"] = 1] = "UNPACK";
    ALPHA_MODES6[ALPHA_MODES6["PMA"] = 2] = "PMA";
    ALPHA_MODES6[ALPHA_MODES6["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
    ALPHA_MODES6[ALPHA_MODES6["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
    ALPHA_MODES6[ALPHA_MODES6["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
    ALPHA_MODES6[ALPHA_MODES6["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
  })(ALPHA_MODES$1 || (ALPHA_MODES$1 = {}));
  var CLEAR_MODES$1;
  (function(CLEAR_MODES6) {
    CLEAR_MODES6[CLEAR_MODES6["NO"] = 0] = "NO";
    CLEAR_MODES6[CLEAR_MODES6["YES"] = 1] = "YES";
    CLEAR_MODES6[CLEAR_MODES6["AUTO"] = 2] = "AUTO";
    CLEAR_MODES6[CLEAR_MODES6["BLEND"] = 0] = "BLEND";
    CLEAR_MODES6[CLEAR_MODES6["CLEAR"] = 1] = "CLEAR";
    CLEAR_MODES6[CLEAR_MODES6["BLIT"] = 2] = "BLIT";
  })(CLEAR_MODES$1 || (CLEAR_MODES$1 = {}));
  var GC_MODES$1;
  (function(GC_MODES6) {
    GC_MODES6[GC_MODES6["AUTO"] = 0] = "AUTO";
    GC_MODES6[GC_MODES6["MANUAL"] = 1] = "MANUAL";
  })(GC_MODES$1 || (GC_MODES$1 = {}));
  var PRECISION$1;
  (function(PRECISION6) {
    PRECISION6["LOW"] = "lowp";
    PRECISION6["MEDIUM"] = "mediump";
    PRECISION6["HIGH"] = "highp";
  })(PRECISION$1 || (PRECISION$1 = {}));
  var MASK_TYPES$1;
  (function(MASK_TYPES6) {
    MASK_TYPES6[MASK_TYPES6["NONE"] = 0] = "NONE";
    MASK_TYPES6[MASK_TYPES6["SCISSOR"] = 1] = "SCISSOR";
    MASK_TYPES6[MASK_TYPES6["STENCIL"] = 2] = "STENCIL";
    MASK_TYPES6[MASK_TYPES6["SPRITE"] = 3] = "SPRITE";
  })(MASK_TYPES$1 || (MASK_TYPES$1 = {}));
  var MSAA_QUALITY$1;
  (function(MSAA_QUALITY6) {
    MSAA_QUALITY6[MSAA_QUALITY6["NONE"] = 0] = "NONE";
    MSAA_QUALITY6[MSAA_QUALITY6["LOW"] = 2] = "LOW";
    MSAA_QUALITY6[MSAA_QUALITY6["MEDIUM"] = 4] = "MEDIUM";
    MSAA_QUALITY6[MSAA_QUALITY6["HIGH"] = 8] = "HIGH";
  })(MSAA_QUALITY$1 || (MSAA_QUALITY$1 = {}));
  var BUFFER_TYPE$1;
  (function(BUFFER_TYPE6) {
    BUFFER_TYPE6[BUFFER_TYPE6["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
    BUFFER_TYPE6[BUFFER_TYPE6["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
    BUFFER_TYPE6[BUFFER_TYPE6["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
  })(BUFFER_TYPE$1 || (BUFFER_TYPE$1 = {}));
  var settings2 = {
    /**
     * If set to true WebGL will attempt make textures mimpaped by default.
     * Mipmapping will only succeed if the base texture uploaded has power of two dimensions.
     * @static
     * @name MIPMAP_TEXTURES
     * @memberof PIXI.settings
     * @type {PIXI.MIPMAP_MODES}
     * @default PIXI.MIPMAP_MODES.POW2
     */
    MIPMAP_TEXTURES: MIPMAP_MODES$1.POW2,
    /**
     * Default anisotropic filtering level of textures.
     * Usually from 0 to 16
     * @static
     * @name ANISOTROPIC_LEVEL
     * @memberof PIXI.settings
     * @type {number}
     * @default 0
     */
    ANISOTROPIC_LEVEL: 0,
    /**
     * Default resolution / device pixel ratio of the renderer.
     * @static
     * @name RESOLUTION
     * @memberof PIXI.settings
     * @type {number}
     * @default 1
     */
    RESOLUTION: 1,
    /**
     * Default filter resolution.
     * @static
     * @name FILTER_RESOLUTION
     * @memberof PIXI.settings
     * @type {number}
     * @default 1
     */
    FILTER_RESOLUTION: 1,
    /**
     * Default filter samples.
     * @static
     * @name FILTER_MULTISAMPLE
     * @memberof PIXI.settings
     * @type {PIXI.MSAA_QUALITY}
     * @default PIXI.MSAA_QUALITY.NONE
     */
    FILTER_MULTISAMPLE: MSAA_QUALITY$1.NONE,
    /**
     * The maximum textures that this device supports.
     * @static
     * @name SPRITE_MAX_TEXTURES
     * @memberof PIXI.settings
     * @type {number}
     * @default 32
     */
    SPRITE_MAX_TEXTURES: maxRecommendedTextures2(32),
    // TODO: maybe change to SPRITE.BATCH_SIZE: 2000
    // TODO: maybe add PARTICLE.BATCH_SIZE: 15000
    /**
     * The default sprite batch size.
     *
     * The default aims to balance desktop and mobile devices.
     * @static
     * @name SPRITE_BATCH_SIZE
     * @memberof PIXI.settings
     * @type {number}
     * @default 4096
     */
    SPRITE_BATCH_SIZE: 4096,
    /**
     * The default render options if none are supplied to {@link PIXI.Renderer}
     * or {@link PIXI.CanvasRenderer}.
     * @static
     * @name RENDER_OPTIONS
     * @memberof PIXI.settings
     * @type {object}
     * @property {HTMLCanvasElement} [view=null] -
     * @property {boolean} [antialias=false] -
     * @property {boolean} [autoDensity=false] -
     * @property {boolean} [useContextAlpha=true]  -
     * @property {number} [backgroundColor=0x000000] -
     * @property {number} [backgroundAlpha=1] -
     * @property {boolean} [clearBeforeRender=true] -
     * @property {boolean} [preserveDrawingBuffer=false] -
     * @property {number} [width=800] -
     * @property {number} [height=600] -
     * @property {boolean} [legacy=false] -
     */
    RENDER_OPTIONS: {
      view: null,
      antialias: false,
      autoDensity: false,
      backgroundColor: 0,
      backgroundAlpha: 1,
      useContextAlpha: true,
      clearBeforeRender: true,
      preserveDrawingBuffer: false,
      width: 800,
      height: 600,
      legacy: false
    },
    /**
     * Default Garbage Collection mode.
     * @static
     * @name GC_MODE
     * @memberof PIXI.settings
     * @type {PIXI.GC_MODES}
     * @default PIXI.GC_MODES.AUTO
     */
    GC_MODE: GC_MODES$1.AUTO,
    /**
     * Default Garbage Collection max idle.
     * @static
     * @name GC_MAX_IDLE
     * @memberof PIXI.settings
     * @type {number}
     * @default 3600
     */
    GC_MAX_IDLE: 60 * 60,
    /**
     * Default Garbage Collection maximum check count.
     * @static
     * @name GC_MAX_CHECK_COUNT
     * @memberof PIXI.settings
     * @type {number}
     * @default 600
     */
    GC_MAX_CHECK_COUNT: 60 * 10,
    /**
     * Default wrap modes that are supported by pixi.
     * @static
     * @name WRAP_MODE
     * @memberof PIXI.settings
     * @type {PIXI.WRAP_MODES}
     * @default PIXI.WRAP_MODES.CLAMP
     */
    WRAP_MODE: WRAP_MODES$1.CLAMP,
    /**
     * Default scale mode for textures.
     * @static
     * @name SCALE_MODE
     * @memberof PIXI.settings
     * @type {PIXI.SCALE_MODES}
     * @default PIXI.SCALE_MODES.LINEAR
     */
    SCALE_MODE: SCALE_MODES$1.LINEAR,
    /**
     * Default specify float precision in vertex shader.
     * @static
     * @name PRECISION_VERTEX
     * @memberof PIXI.settings
     * @type {PIXI.PRECISION}
     * @default PIXI.PRECISION.HIGH
     */
    PRECISION_VERTEX: PRECISION$1.HIGH,
    /**
     * Default specify float precision in fragment shader.
     * iOS is best set at highp due to https://github.com/pixijs/pixi.js/issues/3742
     * @static
     * @name PRECISION_FRAGMENT
     * @memberof PIXI.settings
     * @type {PIXI.PRECISION}
     * @default PIXI.PRECISION.MEDIUM
     */
    PRECISION_FRAGMENT: isMobile3.apple.device ? PRECISION$1.HIGH : PRECISION$1.MEDIUM,
    /**
     * Can we upload the same buffer in a single frame?
     * @static
     * @name CAN_UPLOAD_SAME_BUFFER
     * @memberof PIXI.settings
     * @type {boolean}
     */
    CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer2(),
    /**
     * Enables bitmap creation before image load. This feature is experimental.
     * @static
     * @name CREATE_IMAGE_BITMAP
     * @memberof PIXI.settings
     * @type {boolean}
     * @default false
     */
    CREATE_IMAGE_BITMAP: false,
    /**
     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
     * Advantages can include sharper image quality (like text) and faster rendering on canvas.
     * The main disadvantage is movement of objects may appear less smooth.
     * @static
     * @constant
     * @memberof PIXI.settings
     * @type {boolean}
     * @default false
     */
    ROUND_PIXELS: false
  };
  settings2.SORTABLE_CHILDREN = false;
  var Bounds2 = (
    /** @class */
    function() {
      function Bounds3() {
        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;
        this.rect = null;
        this.updateID = -1;
      }
      Bounds3.prototype.isEmpty = function() {
        return this.minX > this.maxX || this.minY > this.maxY;
      };
      Bounds3.prototype.clear = function() {
        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;
      };
      Bounds3.prototype.getRectangle = function(rect) {
        if (this.minX > this.maxX || this.minY > this.maxY) {
          return Rectangle.EMPTY;
        }
        rect = rect || new Rectangle(0, 0, 1, 1);
        rect.x = this.minX;
        rect.y = this.minY;
        rect.width = this.maxX - this.minX;
        rect.height = this.maxY - this.minY;
        return rect;
      };
      Bounds3.prototype.addPoint = function(point) {
        this.minX = Math.min(this.minX, point.x);
        this.maxX = Math.max(this.maxX, point.x);
        this.minY = Math.min(this.minY, point.y);
        this.maxY = Math.max(this.maxY, point.y);
      };
      Bounds3.prototype.addPointMatrix = function(matrix, point) {
        var a = matrix.a, b = matrix.b, c = matrix.c, d = matrix.d, tx = matrix.tx, ty = matrix.ty;
        var x = a * point.x + c * point.y + tx;
        var y = b * point.x + d * point.y + ty;
        this.minX = Math.min(this.minX, x);
        this.maxX = Math.max(this.maxX, x);
        this.minY = Math.min(this.minY, y);
        this.maxY = Math.max(this.maxY, y);
      };
      Bounds3.prototype.addQuad = function(vertices) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        var x = vertices[0];
        var y = vertices[1];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = vertices[2];
        y = vertices[3];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = vertices[4];
        y = vertices[5];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = vertices[6];
        y = vertices[7];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      };
      Bounds3.prototype.addFrame = function(transform, x0, y0, x1, y1) {
        this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);
      };
      Bounds3.prototype.addFrameMatrix = function(matrix, x0, y0, x1, y1) {
        var a = matrix.a;
        var b = matrix.b;
        var c = matrix.c;
        var d = matrix.d;
        var tx = matrix.tx;
        var ty = matrix.ty;
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        var x = a * x0 + c * y0 + tx;
        var y = b * x0 + d * y0 + ty;
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = a * x1 + c * y0 + tx;
        y = b * x1 + d * y0 + ty;
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = a * x0 + c * y1 + tx;
        y = b * x0 + d * y1 + ty;
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = a * x1 + c * y1 + tx;
        y = b * x1 + d * y1 + ty;
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      };
      Bounds3.prototype.addVertexData = function(vertexData, beginOffset, endOffset) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        for (var i = beginOffset; i < endOffset; i += 2) {
          var x = vertexData[i];
          var y = vertexData[i + 1];
          minX = x < minX ? x : minX;
          minY = y < minY ? y : minY;
          maxX = x > maxX ? x : maxX;
          maxY = y > maxY ? y : maxY;
        }
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      };
      Bounds3.prototype.addVertices = function(transform, vertices, beginOffset, endOffset) {
        this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);
      };
      Bounds3.prototype.addVerticesMatrix = function(matrix, vertices, beginOffset, endOffset, padX, padY) {
        if (padX === void 0) {
          padX = 0;
        }
        if (padY === void 0) {
          padY = padX;
        }
        var a = matrix.a;
        var b = matrix.b;
        var c = matrix.c;
        var d = matrix.d;
        var tx = matrix.tx;
        var ty = matrix.ty;
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        for (var i = beginOffset; i < endOffset; i += 2) {
          var rawX = vertices[i];
          var rawY = vertices[i + 1];
          var x = a * rawX + c * rawY + tx;
          var y = d * rawY + b * rawX + ty;
          minX = Math.min(minX, x - padX);
          maxX = Math.max(maxX, x + padX);
          minY = Math.min(minY, y - padY);
          maxY = Math.max(maxY, y + padY);
        }
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      };
      Bounds3.prototype.addBounds = function(bounds) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        this.minX = bounds.minX < minX ? bounds.minX : minX;
        this.minY = bounds.minY < minY ? bounds.minY : minY;
        this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;
        this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
      };
      Bounds3.prototype.addBoundsMask = function(bounds, mask) {
        var _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;
        var _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;
        var _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;
        var _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;
        if (_minX <= _maxX && _minY <= _maxY) {
          var minX = this.minX;
          var minY = this.minY;
          var maxX = this.maxX;
          var maxY = this.maxY;
          this.minX = _minX < minX ? _minX : minX;
          this.minY = _minY < minY ? _minY : minY;
          this.maxX = _maxX > maxX ? _maxX : maxX;
          this.maxY = _maxY > maxY ? _maxY : maxY;
        }
      };
      Bounds3.prototype.addBoundsMatrix = function(bounds, matrix) {
        this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
      };
      Bounds3.prototype.addBoundsArea = function(bounds, area) {
        var _minX = bounds.minX > area.x ? bounds.minX : area.x;
        var _minY = bounds.minY > area.y ? bounds.minY : area.y;
        var _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : area.x + area.width;
        var _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : area.y + area.height;
        if (_minX <= _maxX && _minY <= _maxY) {
          var minX = this.minX;
          var minY = this.minY;
          var maxX = this.maxX;
          var maxY = this.maxY;
          this.minX = _minX < minX ? _minX : minX;
          this.minY = _minY < minY ? _minY : minY;
          this.maxX = _maxX > maxX ? _maxX : maxX;
          this.maxY = _maxY > maxY ? _maxY : maxY;
        }
      };
      Bounds3.prototype.pad = function(paddingX, paddingY) {
        if (paddingX === void 0) {
          paddingX = 0;
        }
        if (paddingY === void 0) {
          paddingY = paddingX;
        }
        if (!this.isEmpty()) {
          this.minX -= paddingX;
          this.maxX += paddingX;
          this.minY -= paddingY;
          this.maxY += paddingY;
        }
      };
      Bounds3.prototype.addFramePad = function(x0, y0, x1, y1, padX, padY) {
        x0 -= padX;
        y0 -= padY;
        x1 += padX;
        y1 += padY;
        this.minX = this.minX < x0 ? this.minX : x0;
        this.maxX = this.maxX > x1 ? this.maxX : x1;
        this.minY = this.minY < y0 ? this.minY : y0;
        this.maxY = this.maxY > y1 ? this.maxY : y1;
      };
      return Bounds3;
    }()
  );
  var extendStatics3 = function(d, b) {
    extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) {
        if (b2.hasOwnProperty(p)) {
          d2[p] = b2[p];
        }
      }
    };
    return extendStatics3(d, b);
  };
  function __extends3(d, b) {
    extendStatics3(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var DisplayObject2 = (
    /** @class */
    function(_super) {
      __extends3(DisplayObject3, _super);
      function DisplayObject3() {
        var _this = _super.call(this) || this;
        _this.tempDisplayObjectParent = null;
        _this.transform = new Transform();
        _this.alpha = 1;
        _this.visible = true;
        _this.renderable = true;
        _this.cullable = false;
        _this.cullArea = null;
        _this.parent = null;
        _this.worldAlpha = 1;
        _this._lastSortedIndex = 0;
        _this._zIndex = 0;
        _this.filterArea = null;
        _this.filters = null;
        _this._enabledFilters = null;
        _this._bounds = new Bounds2();
        _this._localBounds = null;
        _this._boundsID = 0;
        _this._boundsRect = null;
        _this._localBoundsRect = null;
        _this._mask = null;
        _this._maskRefCount = 0;
        _this._destroyed = false;
        _this.isSprite = false;
        _this.isMask = false;
        return _this;
      }
      DisplayObject3.mixin = function(source) {
        var keys = Object.keys(source);
        for (var i = 0; i < keys.length; ++i) {
          var propertyName = keys[i];
          Object.defineProperty(DisplayObject3.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
        }
      };
      Object.defineProperty(DisplayObject3.prototype, "destroyed", {
        /**
         * Fired when this DisplayObject is added to a Container.
         * @instance
         * @event added
         * @param {PIXI.Container} container - The container added to.
         */
        /**
         * Fired when this DisplayObject is removed from a Container.
         * @instance
         * @event removed
         * @param {PIXI.Container} container - The container removed from.
         */
        /**
         * Fired when this DisplayObject is destroyed. This event is emitted once
         * destroy is finished.
         * @instance
         * @event destroyed
         */
        /** Readonly flag for destroyed display objects. */
        get: function() {
          return this._destroyed;
        },
        enumerable: false,
        configurable: true
      });
      DisplayObject3.prototype._recursivePostUpdateTransform = function() {
        if (this.parent) {
          this.parent._recursivePostUpdateTransform();
          this.transform.updateTransform(this.parent.transform);
        } else {
          this.transform.updateTransform(this._tempDisplayObjectParent.transform);
        }
      };
      DisplayObject3.prototype.updateTransform = function() {
        this._boundsID++;
        this.transform.updateTransform(this.parent.transform);
        this.worldAlpha = this.alpha * this.parent.worldAlpha;
      };
      DisplayObject3.prototype.getBounds = function(skipUpdate, rect) {
        if (!skipUpdate) {
          if (!this.parent) {
            this.parent = this._tempDisplayObjectParent;
            this.updateTransform();
            this.parent = null;
          } else {
            this._recursivePostUpdateTransform();
            this.updateTransform();
          }
        }
        if (this._bounds.updateID !== this._boundsID) {
          this.calculateBounds();
          this._bounds.updateID = this._boundsID;
        }
        if (!rect) {
          if (!this._boundsRect) {
            this._boundsRect = new Rectangle();
          }
          rect = this._boundsRect;
        }
        return this._bounds.getRectangle(rect);
      };
      DisplayObject3.prototype.getLocalBounds = function(rect) {
        if (!rect) {
          if (!this._localBoundsRect) {
            this._localBoundsRect = new Rectangle();
          }
          rect = this._localBoundsRect;
        }
        if (!this._localBounds) {
          this._localBounds = new Bounds2();
        }
        var transformRef = this.transform;
        var parentRef = this.parent;
        this.parent = null;
        this.transform = this._tempDisplayObjectParent.transform;
        var worldBounds = this._bounds;
        var worldBoundsID = this._boundsID;
        this._bounds = this._localBounds;
        var bounds = this.getBounds(false, rect);
        this.parent = parentRef;
        this.transform = transformRef;
        this._bounds = worldBounds;
        this._bounds.updateID += this._boundsID - worldBoundsID;
        return bounds;
      };
      DisplayObject3.prototype.toGlobal = function(position, point, skipUpdate) {
        if (skipUpdate === void 0) {
          skipUpdate = false;
        }
        if (!skipUpdate) {
          this._recursivePostUpdateTransform();
          if (!this.parent) {
            this.parent = this._tempDisplayObjectParent;
            this.displayObjectUpdateTransform();
            this.parent = null;
          } else {
            this.displayObjectUpdateTransform();
          }
        }
        return this.worldTransform.apply(position, point);
      };
      DisplayObject3.prototype.toLocal = function(position, from, point, skipUpdate) {
        if (from) {
          position = from.toGlobal(position, point, skipUpdate);
        }
        if (!skipUpdate) {
          this._recursivePostUpdateTransform();
          if (!this.parent) {
            this.parent = this._tempDisplayObjectParent;
            this.displayObjectUpdateTransform();
            this.parent = null;
          } else {
            this.displayObjectUpdateTransform();
          }
        }
        return this.worldTransform.applyInverse(position, point);
      };
      DisplayObject3.prototype.setParent = function(container) {
        if (!container || !container.addChild) {
          throw new Error("setParent: Argument must be a Container");
        }
        container.addChild(this);
        return container;
      };
      DisplayObject3.prototype.setTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, pivotX, pivotY) {
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        if (scaleX === void 0) {
          scaleX = 1;
        }
        if (scaleY === void 0) {
          scaleY = 1;
        }
        if (rotation === void 0) {
          rotation = 0;
        }
        if (skewX === void 0) {
          skewX = 0;
        }
        if (skewY === void 0) {
          skewY = 0;
        }
        if (pivotX === void 0) {
          pivotX = 0;
        }
        if (pivotY === void 0) {
          pivotY = 0;
        }
        this.position.x = x;
        this.position.y = y;
        this.scale.x = !scaleX ? 1 : scaleX;
        this.scale.y = !scaleY ? 1 : scaleY;
        this.rotation = rotation;
        this.skew.x = skewX;
        this.skew.y = skewY;
        this.pivot.x = pivotX;
        this.pivot.y = pivotY;
        return this;
      };
      DisplayObject3.prototype.destroy = function(_options) {
        if (this.parent) {
          this.parent.removeChild(this);
        }
        this._destroyed = true;
        this.transform = null;
        this.parent = null;
        this._bounds = null;
        this.mask = null;
        this.cullArea = null;
        this.filters = null;
        this.filterArea = null;
        this.hitArea = null;
        this.interactive = false;
        this.interactiveChildren = false;
        this.emit("destroyed");
        this.removeAllListeners();
      };
      Object.defineProperty(DisplayObject3.prototype, "_tempDisplayObjectParent", {
        /**
         * @protected
         * @member {PIXI.Container}
         */
        get: function() {
          if (this.tempDisplayObjectParent === null) {
            this.tempDisplayObjectParent = new TemporaryDisplayObject2();
          }
          return this.tempDisplayObjectParent;
        },
        enumerable: false,
        configurable: true
      });
      DisplayObject3.prototype.enableTempParent = function() {
        var myParent = this.parent;
        this.parent = this._tempDisplayObjectParent;
        return myParent;
      };
      DisplayObject3.prototype.disableTempParent = function(cacheParent) {
        this.parent = cacheParent;
      };
      Object.defineProperty(DisplayObject3.prototype, "x", {
        /**
         * The position of the displayObject on the x axis relative to the local coordinates of the parent.
         * An alias to position.x
         */
        get: function() {
          return this.position.x;
        },
        set: function(value) {
          this.transform.position.x = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject3.prototype, "y", {
        /**
         * The position of the displayObject on the y axis relative to the local coordinates of the parent.
         * An alias to position.y
         */
        get: function() {
          return this.position.y;
        },
        set: function(value) {
          this.transform.position.y = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject3.prototype, "worldTransform", {
        /**
         * Current transform of the object based on world (parent) factors.
         * @readonly
         */
        get: function() {
          return this.transform.worldTransform;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject3.prototype, "localTransform", {
        /**
         * Current transform of the object based on local factors: position, scale, other stuff.
         * @readonly
         */
        get: function() {
          return this.transform.localTransform;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject3.prototype, "position", {
        /**
         * The coordinate of the object relative to the local coordinates of the parent.
         * @since 4.0.0
         */
        get: function() {
          return this.transform.position;
        },
        set: function(value) {
          this.transform.position.copyFrom(value);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject3.prototype, "scale", {
        /**
         * The scale factors of this object along the local coordinate axes.
         *
         * The default scale is (1, 1).
         * @since 4.0.0
         */
        get: function() {
          return this.transform.scale;
        },
        set: function(value) {
          this.transform.scale.copyFrom(value);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject3.prototype, "pivot", {
        /**
         * The center of rotation, scaling, and skewing for this display object in its local space. The `position`
         * is the projection of `pivot` in the parent's local space.
         *
         * By default, the pivot is the origin (0, 0).
         * @since 4.0.0
         */
        get: function() {
          return this.transform.pivot;
        },
        set: function(value) {
          this.transform.pivot.copyFrom(value);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject3.prototype, "skew", {
        /**
         * The skew factor for the object in radians.
         * @since 4.0.0
         */
        get: function() {
          return this.transform.skew;
        },
        set: function(value) {
          this.transform.skew.copyFrom(value);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject3.prototype, "rotation", {
        /**
         * The rotation of the object in radians.
         * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
         */
        get: function() {
          return this.transform.rotation;
        },
        set: function(value) {
          this.transform.rotation = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject3.prototype, "angle", {
        /**
         * The angle of the object in degrees.
         * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
         */
        get: function() {
          return this.transform.rotation * RAD_TO_DEG;
        },
        set: function(value) {
          this.transform.rotation = value * DEG_TO_RAD;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject3.prototype, "zIndex", {
        /**
         * The zIndex of the displayObject.
         *
         * If a container has the sortableChildren property set to true, children will be automatically
         * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,
         * and thus rendered on top of other display objects within the same container.
         * @see PIXI.Container#sortableChildren
         */
        get: function() {
          return this._zIndex;
        },
        set: function(value) {
          this._zIndex = value;
          if (this.parent) {
            this.parent.sortDirty = true;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject3.prototype, "worldVisible", {
        /**
         * Indicates if the object is globally visible.
         * @readonly
         */
        get: function() {
          var item = this;
          do {
            if (!item.visible) {
              return false;
            }
            item = item.parent;
          } while (item);
          return true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject3.prototype, "mask", {
        /**
         * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
         * object to the shape of the mask applied to it. In PixiJS a regular mask must be a
         * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it
         * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.
         * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.
         * To remove a mask, set this property to `null`.
         *
         * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.
         * @example
         * const graphics = new PIXI.Graphics();
         * graphics.beginFill(0xFF3300);
         * graphics.drawRect(50, 250, 100, 100);
         * graphics.endFill();
         *
         * const sprite = new PIXI.Sprite(texture);
         * sprite.mask = graphics;
         * @todo At the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.
         */
        get: function() {
          return this._mask;
        },
        set: function(value) {
          if (this._mask === value) {
            return;
          }
          if (this._mask) {
            var maskObject = this._mask.maskObject || this._mask;
            maskObject._maskRefCount--;
            if (maskObject._maskRefCount === 0) {
              maskObject.renderable = true;
              maskObject.isMask = false;
            }
          }
          this._mask = value;
          if (this._mask) {
            var maskObject = this._mask.maskObject || this._mask;
            if (maskObject._maskRefCount === 0) {
              maskObject.renderable = false;
              maskObject.isMask = true;
            }
            maskObject._maskRefCount++;
          }
        },
        enumerable: false,
        configurable: true
      });
      return DisplayObject3;
    }(import_eventemitter3.default)
  );
  var TemporaryDisplayObject2 = (
    /** @class */
    function(_super) {
      __extends3(TemporaryDisplayObject3, _super);
      function TemporaryDisplayObject3() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.sortDirty = null;
        return _this;
      }
      return TemporaryDisplayObject3;
    }(DisplayObject2)
  );
  DisplayObject2.prototype.displayObjectUpdateTransform = DisplayObject2.prototype.updateTransform;
  var ENV4;
  (function(ENV6) {
    ENV6[ENV6["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
    ENV6[ENV6["WEBGL"] = 1] = "WEBGL";
    ENV6[ENV6["WEBGL2"] = 2] = "WEBGL2";
  })(ENV4 || (ENV4 = {}));
  var RENDERER_TYPE4;
  (function(RENDERER_TYPE6) {
    RENDERER_TYPE6[RENDERER_TYPE6["UNKNOWN"] = 0] = "UNKNOWN";
    RENDERER_TYPE6[RENDERER_TYPE6["WEBGL"] = 1] = "WEBGL";
    RENDERER_TYPE6[RENDERER_TYPE6["CANVAS"] = 2] = "CANVAS";
  })(RENDERER_TYPE4 || (RENDERER_TYPE4 = {}));
  var BUFFER_BITS4;
  (function(BUFFER_BITS6) {
    BUFFER_BITS6[BUFFER_BITS6["COLOR"] = 16384] = "COLOR";
    BUFFER_BITS6[BUFFER_BITS6["DEPTH"] = 256] = "DEPTH";
    BUFFER_BITS6[BUFFER_BITS6["STENCIL"] = 1024] = "STENCIL";
  })(BUFFER_BITS4 || (BUFFER_BITS4 = {}));
  var BLEND_MODES4;
  (function(BLEND_MODES6) {
    BLEND_MODES6[BLEND_MODES6["NORMAL"] = 0] = "NORMAL";
    BLEND_MODES6[BLEND_MODES6["ADD"] = 1] = "ADD";
    BLEND_MODES6[BLEND_MODES6["MULTIPLY"] = 2] = "MULTIPLY";
    BLEND_MODES6[BLEND_MODES6["SCREEN"] = 3] = "SCREEN";
    BLEND_MODES6[BLEND_MODES6["OVERLAY"] = 4] = "OVERLAY";
    BLEND_MODES6[BLEND_MODES6["DARKEN"] = 5] = "DARKEN";
    BLEND_MODES6[BLEND_MODES6["LIGHTEN"] = 6] = "LIGHTEN";
    BLEND_MODES6[BLEND_MODES6["COLOR_DODGE"] = 7] = "COLOR_DODGE";
    BLEND_MODES6[BLEND_MODES6["COLOR_BURN"] = 8] = "COLOR_BURN";
    BLEND_MODES6[BLEND_MODES6["HARD_LIGHT"] = 9] = "HARD_LIGHT";
    BLEND_MODES6[BLEND_MODES6["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
    BLEND_MODES6[BLEND_MODES6["DIFFERENCE"] = 11] = "DIFFERENCE";
    BLEND_MODES6[BLEND_MODES6["EXCLUSION"] = 12] = "EXCLUSION";
    BLEND_MODES6[BLEND_MODES6["HUE"] = 13] = "HUE";
    BLEND_MODES6[BLEND_MODES6["SATURATION"] = 14] = "SATURATION";
    BLEND_MODES6[BLEND_MODES6["COLOR"] = 15] = "COLOR";
    BLEND_MODES6[BLEND_MODES6["LUMINOSITY"] = 16] = "LUMINOSITY";
    BLEND_MODES6[BLEND_MODES6["NORMAL_NPM"] = 17] = "NORMAL_NPM";
    BLEND_MODES6[BLEND_MODES6["ADD_NPM"] = 18] = "ADD_NPM";
    BLEND_MODES6[BLEND_MODES6["SCREEN_NPM"] = 19] = "SCREEN_NPM";
    BLEND_MODES6[BLEND_MODES6["NONE"] = 20] = "NONE";
    BLEND_MODES6[BLEND_MODES6["SRC_OVER"] = 0] = "SRC_OVER";
    BLEND_MODES6[BLEND_MODES6["SRC_IN"] = 21] = "SRC_IN";
    BLEND_MODES6[BLEND_MODES6["SRC_OUT"] = 22] = "SRC_OUT";
    BLEND_MODES6[BLEND_MODES6["SRC_ATOP"] = 23] = "SRC_ATOP";
    BLEND_MODES6[BLEND_MODES6["DST_OVER"] = 24] = "DST_OVER";
    BLEND_MODES6[BLEND_MODES6["DST_IN"] = 25] = "DST_IN";
    BLEND_MODES6[BLEND_MODES6["DST_OUT"] = 26] = "DST_OUT";
    BLEND_MODES6[BLEND_MODES6["DST_ATOP"] = 27] = "DST_ATOP";
    BLEND_MODES6[BLEND_MODES6["ERASE"] = 26] = "ERASE";
    BLEND_MODES6[BLEND_MODES6["SUBTRACT"] = 28] = "SUBTRACT";
    BLEND_MODES6[BLEND_MODES6["XOR"] = 29] = "XOR";
  })(BLEND_MODES4 || (BLEND_MODES4 = {}));
  var DRAW_MODES4;
  (function(DRAW_MODES6) {
    DRAW_MODES6[DRAW_MODES6["POINTS"] = 0] = "POINTS";
    DRAW_MODES6[DRAW_MODES6["LINES"] = 1] = "LINES";
    DRAW_MODES6[DRAW_MODES6["LINE_LOOP"] = 2] = "LINE_LOOP";
    DRAW_MODES6[DRAW_MODES6["LINE_STRIP"] = 3] = "LINE_STRIP";
    DRAW_MODES6[DRAW_MODES6["TRIANGLES"] = 4] = "TRIANGLES";
    DRAW_MODES6[DRAW_MODES6["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
    DRAW_MODES6[DRAW_MODES6["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
  })(DRAW_MODES4 || (DRAW_MODES4 = {}));
  var FORMATS4;
  (function(FORMATS6) {
    FORMATS6[FORMATS6["RGBA"] = 6408] = "RGBA";
    FORMATS6[FORMATS6["RGB"] = 6407] = "RGB";
    FORMATS6[FORMATS6["RG"] = 33319] = "RG";
    FORMATS6[FORMATS6["RED"] = 6403] = "RED";
    FORMATS6[FORMATS6["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
    FORMATS6[FORMATS6["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
    FORMATS6[FORMATS6["RG_INTEGER"] = 33320] = "RG_INTEGER";
    FORMATS6[FORMATS6["RED_INTEGER"] = 36244] = "RED_INTEGER";
    FORMATS6[FORMATS6["ALPHA"] = 6406] = "ALPHA";
    FORMATS6[FORMATS6["LUMINANCE"] = 6409] = "LUMINANCE";
    FORMATS6[FORMATS6["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
    FORMATS6[FORMATS6["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
    FORMATS6[FORMATS6["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
  })(FORMATS4 || (FORMATS4 = {}));
  var TARGETS4;
  (function(TARGETS6) {
    TARGETS6[TARGETS6["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
    TARGETS6[TARGETS6["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  })(TARGETS4 || (TARGETS4 = {}));
  var TYPES4;
  (function(TYPES6) {
    TYPES6[TYPES6["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    TYPES6[TYPES6["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    TYPES6[TYPES6["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
    TYPES6[TYPES6["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
    TYPES6[TYPES6["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
    TYPES6[TYPES6["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
    TYPES6[TYPES6["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
    TYPES6[TYPES6["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
    TYPES6[TYPES6["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
    TYPES6[TYPES6["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
    TYPES6[TYPES6["BYTE"] = 5120] = "BYTE";
    TYPES6[TYPES6["SHORT"] = 5122] = "SHORT";
    TYPES6[TYPES6["INT"] = 5124] = "INT";
    TYPES6[TYPES6["FLOAT"] = 5126] = "FLOAT";
    TYPES6[TYPES6["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
    TYPES6[TYPES6["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
  })(TYPES4 || (TYPES4 = {}));
  var SAMPLER_TYPES4;
  (function(SAMPLER_TYPES6) {
    SAMPLER_TYPES6[SAMPLER_TYPES6["FLOAT"] = 0] = "FLOAT";
    SAMPLER_TYPES6[SAMPLER_TYPES6["INT"] = 1] = "INT";
    SAMPLER_TYPES6[SAMPLER_TYPES6["UINT"] = 2] = "UINT";
  })(SAMPLER_TYPES4 || (SAMPLER_TYPES4 = {}));
  var SCALE_MODES4;
  (function(SCALE_MODES6) {
    SCALE_MODES6[SCALE_MODES6["NEAREST"] = 0] = "NEAREST";
    SCALE_MODES6[SCALE_MODES6["LINEAR"] = 1] = "LINEAR";
  })(SCALE_MODES4 || (SCALE_MODES4 = {}));
  var WRAP_MODES4;
  (function(WRAP_MODES6) {
    WRAP_MODES6[WRAP_MODES6["CLAMP"] = 33071] = "CLAMP";
    WRAP_MODES6[WRAP_MODES6["REPEAT"] = 10497] = "REPEAT";
    WRAP_MODES6[WRAP_MODES6["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
  })(WRAP_MODES4 || (WRAP_MODES4 = {}));
  var MIPMAP_MODES4;
  (function(MIPMAP_MODES6) {
    MIPMAP_MODES6[MIPMAP_MODES6["OFF"] = 0] = "OFF";
    MIPMAP_MODES6[MIPMAP_MODES6["POW2"] = 1] = "POW2";
    MIPMAP_MODES6[MIPMAP_MODES6["ON"] = 2] = "ON";
    MIPMAP_MODES6[MIPMAP_MODES6["ON_MANUAL"] = 3] = "ON_MANUAL";
  })(MIPMAP_MODES4 || (MIPMAP_MODES4 = {}));
  var ALPHA_MODES4;
  (function(ALPHA_MODES6) {
    ALPHA_MODES6[ALPHA_MODES6["NPM"] = 0] = "NPM";
    ALPHA_MODES6[ALPHA_MODES6["UNPACK"] = 1] = "UNPACK";
    ALPHA_MODES6[ALPHA_MODES6["PMA"] = 2] = "PMA";
    ALPHA_MODES6[ALPHA_MODES6["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
    ALPHA_MODES6[ALPHA_MODES6["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
    ALPHA_MODES6[ALPHA_MODES6["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
    ALPHA_MODES6[ALPHA_MODES6["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
  })(ALPHA_MODES4 || (ALPHA_MODES4 = {}));
  var CLEAR_MODES4;
  (function(CLEAR_MODES6) {
    CLEAR_MODES6[CLEAR_MODES6["NO"] = 0] = "NO";
    CLEAR_MODES6[CLEAR_MODES6["YES"] = 1] = "YES";
    CLEAR_MODES6[CLEAR_MODES6["AUTO"] = 2] = "AUTO";
    CLEAR_MODES6[CLEAR_MODES6["BLEND"] = 0] = "BLEND";
    CLEAR_MODES6[CLEAR_MODES6["CLEAR"] = 1] = "CLEAR";
    CLEAR_MODES6[CLEAR_MODES6["BLIT"] = 2] = "BLIT";
  })(CLEAR_MODES4 || (CLEAR_MODES4 = {}));
  var GC_MODES4;
  (function(GC_MODES6) {
    GC_MODES6[GC_MODES6["AUTO"] = 0] = "AUTO";
    GC_MODES6[GC_MODES6["MANUAL"] = 1] = "MANUAL";
  })(GC_MODES4 || (GC_MODES4 = {}));
  var PRECISION4;
  (function(PRECISION6) {
    PRECISION6["LOW"] = "lowp";
    PRECISION6["MEDIUM"] = "mediump";
    PRECISION6["HIGH"] = "highp";
  })(PRECISION4 || (PRECISION4 = {}));
  var MASK_TYPES4;
  (function(MASK_TYPES6) {
    MASK_TYPES6[MASK_TYPES6["NONE"] = 0] = "NONE";
    MASK_TYPES6[MASK_TYPES6["SCISSOR"] = 1] = "SCISSOR";
    MASK_TYPES6[MASK_TYPES6["STENCIL"] = 2] = "STENCIL";
    MASK_TYPES6[MASK_TYPES6["SPRITE"] = 3] = "SPRITE";
  })(MASK_TYPES4 || (MASK_TYPES4 = {}));
  var MSAA_QUALITY4;
  (function(MSAA_QUALITY6) {
    MSAA_QUALITY6[MSAA_QUALITY6["NONE"] = 0] = "NONE";
    MSAA_QUALITY6[MSAA_QUALITY6["LOW"] = 2] = "LOW";
    MSAA_QUALITY6[MSAA_QUALITY6["MEDIUM"] = 4] = "MEDIUM";
    MSAA_QUALITY6[MSAA_QUALITY6["HIGH"] = 8] = "HIGH";
  })(MSAA_QUALITY4 || (MSAA_QUALITY4 = {}));
  var BUFFER_TYPE4;
  (function(BUFFER_TYPE6) {
    BUFFER_TYPE6[BUFFER_TYPE6["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
    BUFFER_TYPE6[BUFFER_TYPE6["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
    BUFFER_TYPE6[BUFFER_TYPE6["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
  })(BUFFER_TYPE4 || (BUFFER_TYPE4 = {}));
  function sortChildren2(a, b) {
    if (a.zIndex === b.zIndex) {
      return a._lastSortedIndex - b._lastSortedIndex;
    }
    return a.zIndex - b.zIndex;
  }
  var Container2 = (
    /** @class */
    function(_super) {
      __extends3(Container3, _super);
      function Container3() {
        var _this = _super.call(this) || this;
        _this.children = [];
        _this.sortableChildren = settings2.SORTABLE_CHILDREN;
        _this.sortDirty = false;
        return _this;
      }
      Container3.prototype.onChildrenChange = function(_length) {
      };
      Container3.prototype.addChild = function() {
        var arguments$1 = arguments;
        var children = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          children[_i] = arguments$1[_i];
        }
        if (children.length > 1) {
          for (var i = 0; i < children.length; i++) {
            this.addChild(children[i]);
          }
        } else {
          var child = children[0];
          if (child.parent) {
            child.parent.removeChild(child);
          }
          child.parent = this;
          this.sortDirty = true;
          child.transform._parentID = -1;
          this.children.push(child);
          this._boundsID++;
          this.onChildrenChange(this.children.length - 1);
          this.emit("childAdded", child, this, this.children.length - 1);
          child.emit("added", this);
        }
        return children[0];
      };
      Container3.prototype.addChildAt = function(child, index) {
        if (index < 0 || index > this.children.length) {
          throw new Error(child + "addChildAt: The index " + index + " supplied is out of bounds " + this.children.length);
        }
        if (child.parent) {
          child.parent.removeChild(child);
        }
        child.parent = this;
        this.sortDirty = true;
        child.transform._parentID = -1;
        this.children.splice(index, 0, child);
        this._boundsID++;
        this.onChildrenChange(index);
        child.emit("added", this);
        this.emit("childAdded", child, this, index);
        return child;
      };
      Container3.prototype.swapChildren = function(child, child2) {
        if (child === child2) {
          return;
        }
        var index1 = this.getChildIndex(child);
        var index2 = this.getChildIndex(child2);
        this.children[index1] = child2;
        this.children[index2] = child;
        this.onChildrenChange(index1 < index2 ? index1 : index2);
      };
      Container3.prototype.getChildIndex = function(child) {
        var index = this.children.indexOf(child);
        if (index === -1) {
          throw new Error("The supplied DisplayObject must be a child of the caller");
        }
        return index;
      };
      Container3.prototype.setChildIndex = function(child, index) {
        if (index < 0 || index >= this.children.length) {
          throw new Error("The index " + index + " supplied is out of bounds " + this.children.length);
        }
        var currentIndex = this.getChildIndex(child);
        removeItems(this.children, currentIndex, 1);
        this.children.splice(index, 0, child);
        this.onChildrenChange(index);
      };
      Container3.prototype.getChildAt = function(index) {
        if (index < 0 || index >= this.children.length) {
          throw new Error("getChildAt: Index (" + index + ") does not exist.");
        }
        return this.children[index];
      };
      Container3.prototype.removeChild = function() {
        var arguments$1 = arguments;
        var children = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          children[_i] = arguments$1[_i];
        }
        if (children.length > 1) {
          for (var i = 0; i < children.length; i++) {
            this.removeChild(children[i]);
          }
        } else {
          var child = children[0];
          var index = this.children.indexOf(child);
          if (index === -1) {
            return null;
          }
          child.parent = null;
          child.transform._parentID = -1;
          removeItems(this.children, index, 1);
          this._boundsID++;
          this.onChildrenChange(index);
          child.emit("removed", this);
          this.emit("childRemoved", child, this, index);
        }
        return children[0];
      };
      Container3.prototype.removeChildAt = function(index) {
        var child = this.getChildAt(index);
        child.parent = null;
        child.transform._parentID = -1;
        removeItems(this.children, index, 1);
        this._boundsID++;
        this.onChildrenChange(index);
        child.emit("removed", this);
        this.emit("childRemoved", child, this, index);
        return child;
      };
      Container3.prototype.removeChildren = function(beginIndex, endIndex) {
        if (beginIndex === void 0) {
          beginIndex = 0;
        }
        if (endIndex === void 0) {
          endIndex = this.children.length;
        }
        var begin = beginIndex;
        var end = endIndex;
        var range = end - begin;
        var removed;
        if (range > 0 && range <= end) {
          removed = this.children.splice(begin, range);
          for (var i = 0; i < removed.length; ++i) {
            removed[i].parent = null;
            if (removed[i].transform) {
              removed[i].transform._parentID = -1;
            }
          }
          this._boundsID++;
          this.onChildrenChange(beginIndex);
          for (var i = 0; i < removed.length; ++i) {
            removed[i].emit("removed", this);
            this.emit("childRemoved", removed[i], this, i);
          }
          return removed;
        } else if (range === 0 && this.children.length === 0) {
          return [];
        }
        throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
      };
      Container3.prototype.sortChildren = function() {
        var sortRequired = false;
        for (var i = 0, j = this.children.length; i < j; ++i) {
          var child = this.children[i];
          child._lastSortedIndex = i;
          if (!sortRequired && child.zIndex !== 0) {
            sortRequired = true;
          }
        }
        if (sortRequired && this.children.length > 1) {
          this.children.sort(sortChildren2);
        }
        this.sortDirty = false;
      };
      Container3.prototype.updateTransform = function() {
        if (this.sortableChildren && this.sortDirty) {
          this.sortChildren();
        }
        this._boundsID++;
        this.transform.updateTransform(this.parent.transform);
        this.worldAlpha = this.alpha * this.parent.worldAlpha;
        for (var i = 0, j = this.children.length; i < j; ++i) {
          var child = this.children[i];
          if (child.visible) {
            child.updateTransform();
          }
        }
      };
      Container3.prototype.calculateBounds = function() {
        this._bounds.clear();
        this._calculateBounds();
        for (var i = 0; i < this.children.length; i++) {
          var child = this.children[i];
          if (!child.visible || !child.renderable) {
            continue;
          }
          child.calculateBounds();
          if (child._mask) {
            var maskObject = child._mask.maskObject || child._mask;
            maskObject.calculateBounds();
            this._bounds.addBoundsMask(child._bounds, maskObject._bounds);
          } else if (child.filterArea) {
            this._bounds.addBoundsArea(child._bounds, child.filterArea);
          } else {
            this._bounds.addBounds(child._bounds);
          }
        }
        this._bounds.updateID = this._boundsID;
      };
      Container3.prototype.getLocalBounds = function(rect, skipChildrenUpdate) {
        if (skipChildrenUpdate === void 0) {
          skipChildrenUpdate = false;
        }
        var result = _super.prototype.getLocalBounds.call(this, rect);
        if (!skipChildrenUpdate) {
          for (var i = 0, j = this.children.length; i < j; ++i) {
            var child = this.children[i];
            if (child.visible) {
              child.updateTransform();
            }
          }
        }
        return result;
      };
      Container3.prototype._calculateBounds = function() {
      };
      Container3.prototype._renderWithCulling = function(renderer) {
        var sourceFrame = renderer.renderTexture.sourceFrame;
        if (!(sourceFrame.width > 0 && sourceFrame.height > 0)) {
          return;
        }
        var bounds;
        var transform;
        if (this.cullArea) {
          bounds = this.cullArea;
          transform = this.worldTransform;
        } else if (this._render !== Container3.prototype._render) {
          bounds = this.getBounds(true);
        }
        if (bounds && sourceFrame.intersects(bounds, transform)) {
          this._render(renderer);
        } else if (this.cullArea) {
          return;
        }
        for (var i = 0, j = this.children.length; i < j; ++i) {
          var child = this.children[i];
          var childCullable = child.cullable;
          child.cullable = childCullable || !this.cullArea;
          child.render(renderer);
          child.cullable = childCullable;
        }
      };
      Container3.prototype.render = function(renderer) {
        if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
          return;
        }
        if (this._mask || this.filters && this.filters.length) {
          this.renderAdvanced(renderer);
        } else if (this.cullable) {
          this._renderWithCulling(renderer);
        } else {
          this._render(renderer);
          for (var i = 0, j = this.children.length; i < j; ++i) {
            this.children[i].render(renderer);
          }
        }
      };
      Container3.prototype.renderAdvanced = function(renderer) {
        var filters2 = this.filters;
        var mask = this._mask;
        if (filters2) {
          if (!this._enabledFilters) {
            this._enabledFilters = [];
          }
          this._enabledFilters.length = 0;
          for (var i = 0; i < filters2.length; i++) {
            if (filters2[i].enabled) {
              this._enabledFilters.push(filters2[i]);
            }
          }
        }
        var flush = filters2 && this._enabledFilters && this._enabledFilters.length || mask && (!mask.isMaskData || mask.enabled && (mask.autoDetect || mask.type !== MASK_TYPES4.NONE));
        if (flush) {
          renderer.batch.flush();
        }
        if (filters2 && this._enabledFilters && this._enabledFilters.length) {
          renderer.filter.push(this, this._enabledFilters);
        }
        if (mask) {
          renderer.mask.push(this, this._mask);
        }
        if (this.cullable) {
          this._renderWithCulling(renderer);
        } else {
          this._render(renderer);
          for (var i = 0, j = this.children.length; i < j; ++i) {
            this.children[i].render(renderer);
          }
        }
        if (flush) {
          renderer.batch.flush();
        }
        if (mask) {
          renderer.mask.pop(this);
        }
        if (filters2 && this._enabledFilters && this._enabledFilters.length) {
          renderer.filter.pop();
        }
      };
      Container3.prototype._render = function(_renderer) {
      };
      Container3.prototype.destroy = function(options) {
        _super.prototype.destroy.call(this);
        this.sortDirty = false;
        var destroyChildren = typeof options === "boolean" ? options : options && options.children;
        var oldChildren = this.removeChildren(0, this.children.length);
        if (destroyChildren) {
          for (var i = 0; i < oldChildren.length; ++i) {
            oldChildren[i].destroy(options);
          }
        }
      };
      Object.defineProperty(Container3.prototype, "width", {
        /** The width of the Container, setting this will actually modify the scale to achieve the value set. */
        get: function() {
          return this.scale.x * this.getLocalBounds().width;
        },
        set: function(value) {
          var width = this.getLocalBounds().width;
          if (width !== 0) {
            this.scale.x = value / width;
          } else {
            this.scale.x = 1;
          }
          this._width = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Container3.prototype, "height", {
        /** The height of the Container, setting this will actually modify the scale to achieve the value set. */
        get: function() {
          return this.scale.y * this.getLocalBounds().height;
        },
        set: function(value) {
          var height = this.getLocalBounds().height;
          if (height !== 0) {
            this.scale.y = value / height;
          } else {
            this.scale.y = 1;
          }
          this._height = value;
        },
        enumerable: false,
        configurable: true
      });
      return Container3;
    }(DisplayObject2)
  );
  Container2.prototype.containerUpdateTransform = Container2.prototype.updateTransform;
  var TEMP_RECT = new Rectangle();
  var BYTES_PER_PIXEL = 4;
  var Extract = (
    /** @class */
    function() {
      function Extract2(renderer) {
        this.renderer = renderer;
      }
      Extract2.prototype.image = function(target, format3, quality) {
        var image = new Image();
        image.src = this.base64(target, format3, quality);
        return image;
      };
      Extract2.prototype.base64 = function(target, format3, quality) {
        return this.canvas(target).toDataURL(format3, quality);
      };
      Extract2.prototype.canvas = function(target) {
        var renderer = this.renderer;
        var resolution;
        var frame;
        var flipY = false;
        var renderTexture;
        var generated = false;
        if (target) {
          if (target instanceof RenderTexture) {
            renderTexture = target;
          } else {
            renderTexture = this.renderer.generateTexture(target);
            generated = true;
          }
        }
        if (renderTexture) {
          resolution = renderTexture.baseTexture.resolution;
          frame = renderTexture.frame;
          flipY = false;
          renderer.renderTexture.bind(renderTexture);
        } else {
          resolution = this.renderer.resolution;
          flipY = true;
          frame = TEMP_RECT;
          frame.width = this.renderer.width;
          frame.height = this.renderer.height;
          renderer.renderTexture.bind(null);
        }
        var width = Math.floor(frame.width * resolution + 1e-4);
        var height = Math.floor(frame.height * resolution + 1e-4);
        var canvasBuffer = new CanvasRenderTarget(width, height, 1);
        var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
        var gl = renderer.gl;
        gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);
        var canvasData = canvasBuffer.context.getImageData(0, 0, width, height);
        Extract2.arrayPostDivide(webglPixels, canvasData.data);
        canvasBuffer.context.putImageData(canvasData, 0, 0);
        if (flipY) {
          var target_1 = new CanvasRenderTarget(canvasBuffer.width, canvasBuffer.height, 1);
          target_1.context.scale(1, -1);
          target_1.context.drawImage(canvasBuffer.canvas, 0, -height);
          canvasBuffer.destroy();
          canvasBuffer = target_1;
        }
        if (generated) {
          renderTexture.destroy(true);
        }
        return canvasBuffer.canvas;
      };
      Extract2.prototype.pixels = function(target, options) {
        var renderer = this.renderer;
        var resolution;
        var frame;
        var renderTexture;
        var generated = false;
        if (target) {
          if (target instanceof RenderTexture) {
            renderTexture = target;
          } else if (target instanceof DisplayObject2) {
            renderTexture = this.renderer.generateTexture(target);
            generated = true;
          }
        }
        if (renderTexture) {
          if (options) {
            resolution = options.resolution;
            frame = renderTexture.frame;
            renderer.renderTexture.bind(renderTexture);
          } else {
            resolution = renderTexture.baseTexture.resolution;
            frame = renderTexture.frame;
            renderer.renderTexture.bind(renderTexture);
          }
        } else if (options) {
          resolution = options.resolution;
          frame = TEMP_RECT;
          frame.width = options.width;
          frame.height = options.height;
          renderer.renderTexture.bind(null);
        } else {
          resolution = renderer.resolution;
          frame = TEMP_RECT;
          frame.width = renderer.width;
          frame.height = renderer.height;
          renderer.renderTexture.bind(null);
        }
        var width = frame.width * resolution;
        var height = frame.height * resolution;
        var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
        var gl = renderer.gl;
        gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);
        if (generated) {
          renderTexture.destroy(true);
        }
        Extract2.arrayPostDivide(webglPixels, webglPixels);
        return webglPixels;
      };
      Extract2.prototype.destroy = function() {
        this.renderer = null;
      };
      Extract2.arrayPostDivide = function(pixels, out) {
        for (var i = 0; i < pixels.length; i += 4) {
          var alpha = out[i + 3] = pixels[i + 3];
          if (alpha !== 0) {
            out[i] = Math.round(Math.min(pixels[i] * 255 / alpha, 255));
            out[i + 1] = Math.round(Math.min(pixels[i + 1] * 255 / alpha, 255));
            out[i + 2] = Math.round(Math.min(pixels[i + 2] * 255 / alpha, 255));
          } else {
            out[i] = pixels[i];
            out[i + 1] = pixels[i + 1];
            out[i + 2] = pixels[i + 2];
          }
        }
      };
      return Extract2;
    }()
  );

  // node_modules/@pixi/mesh/dist/esm/mesh.js
  var extendStatics4 = function(d, b) {
    extendStatics4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) {
        if (b2.hasOwnProperty(p)) {
          d2[p] = b2[p];
        }
      }
    };
    return extendStatics4(d, b);
  };
  function __extends4(d, b) {
    extendStatics4(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var MeshBatchUvs = (
    /** @class */
    function() {
      function MeshBatchUvs2(uvBuffer, uvMatrix) {
        this.uvBuffer = uvBuffer;
        this.uvMatrix = uvMatrix;
        this.data = null;
        this._bufferUpdateId = -1;
        this._textureUpdateId = -1;
        this._updateID = 0;
      }
      MeshBatchUvs2.prototype.update = function(forceUpdate) {
        if (!forceUpdate && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID) {
          return;
        }
        this._bufferUpdateId = this.uvBuffer._updateID;
        this._textureUpdateId = this.uvMatrix._updateID;
        var data = this.uvBuffer.data;
        if (!this.data || this.data.length !== data.length) {
          this.data = new Float32Array(data.length);
        }
        this.uvMatrix.multiplyUvs(data, this.data);
        this._updateID++;
      };
      return MeshBatchUvs2;
    }()
  );
  var tempPoint = new Point();
  var tempPolygon = new Polygon();
  var Mesh = (
    /** @class */
    function(_super) {
      __extends4(Mesh2, _super);
      function Mesh2(geometry, shader, state, drawMode) {
        if (drawMode === void 0) {
          drawMode = DRAW_MODES.TRIANGLES;
        }
        var _this = _super.call(this) || this;
        _this.geometry = geometry;
        _this.shader = shader;
        _this.state = state || State.for2d();
        _this.drawMode = drawMode;
        _this.start = 0;
        _this.size = 0;
        _this.uvs = null;
        _this.indices = null;
        _this.vertexData = new Float32Array(1);
        _this.vertexDirty = -1;
        _this._transformID = -1;
        _this._roundPixels = settings.ROUND_PIXELS;
        _this.batchUvs = null;
        return _this;
      }
      Object.defineProperty(Mesh2.prototype, "geometry", {
        /**
         * Includes vertex positions, face indices, normals, colors, UVs, and
         * custom attributes within buffers, reducing the cost of passing all
         * this data to the GPU. Can be shared between multiple Mesh objects.
         */
        get: function() {
          return this._geometry;
        },
        set: function(value) {
          if (this._geometry === value) {
            return;
          }
          if (this._geometry) {
            this._geometry.refCount--;
            if (this._geometry.refCount === 0) {
              this._geometry.dispose();
            }
          }
          this._geometry = value;
          if (this._geometry) {
            this._geometry.refCount++;
          }
          this.vertexDirty = -1;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "uvBuffer", {
        /**
         * To change mesh uv's, change its uvBuffer data and increment its _updateID.
         * @readonly
         */
        get: function() {
          return this.geometry.buffers[1];
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "verticesBuffer", {
        /**
         * To change mesh vertices, change its uvBuffer data and increment its _updateID.
         * Incrementing _updateID is optional because most of Mesh objects do it anyway.
         * @readonly
         */
        get: function() {
          return this.geometry.buffers[0];
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "material", {
        get: function() {
          return this.shader;
        },
        /** Alias for {@link PIXI.Mesh#shader}. */
        set: function(value) {
          this.shader = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "blendMode", {
        get: function() {
          return this.state.blendMode;
        },
        /**
         * The blend mode to be applied to the Mesh. Apply a value of
         * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
         * @default PIXI.BLEND_MODES.NORMAL;
         */
        set: function(value) {
          this.state.blendMode = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "roundPixels", {
        get: function() {
          return this._roundPixels;
        },
        /**
         * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
         * Advantages can include sharper image quality (like text) and faster rendering on canvas.
         * The main disadvantage is movement of objects may appear less smooth.
         * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
         * @default false
         */
        set: function(value) {
          if (this._roundPixels !== value) {
            this._transformID = -1;
          }
          this._roundPixels = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "tint", {
        /**
         * The multiply tint applied to the Mesh. This is a hex value. A value of
         * `0xFFFFFF` will remove any tint effect.
         *
         * Null for non-MeshMaterial shaders
         * @default 0xFFFFFF
         */
        get: function() {
          return "tint" in this.shader ? this.shader.tint : null;
        },
        set: function(value) {
          this.shader.tint = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "texture", {
        /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */
        get: function() {
          return "texture" in this.shader ? this.shader.texture : null;
        },
        set: function(value) {
          this.shader.texture = value;
        },
        enumerable: false,
        configurable: true
      });
      Mesh2.prototype._render = function(renderer) {
        var vertices = this.geometry.buffers[0].data;
        var shader = this.shader;
        if (shader.batchable && this.drawMode === DRAW_MODES.TRIANGLES && vertices.length < Mesh2.BATCHABLE_SIZE * 2) {
          this._renderToBatch(renderer);
        } else {
          this._renderDefault(renderer);
        }
      };
      Mesh2.prototype._renderDefault = function(renderer) {
        var shader = this.shader;
        shader.alpha = this.worldAlpha;
        if (shader.update) {
          shader.update();
        }
        renderer.batch.flush();
        shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);
        renderer.shader.bind(shader);
        renderer.state.set(this.state);
        renderer.geometry.bind(this.geometry, shader);
        renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
      };
      Mesh2.prototype._renderToBatch = function(renderer) {
        var geometry = this.geometry;
        var shader = this.shader;
        if (shader.uvMatrix) {
          shader.uvMatrix.update();
          this.calculateUvs();
        }
        this.calculateVertices();
        this.indices = geometry.indexBuffer.data;
        this._tintRGB = shader._tintRGB;
        this._texture = shader.texture;
        var pluginName = this.material.pluginName;
        renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);
        renderer.plugins[pluginName].render(this);
      };
      Mesh2.prototype.calculateVertices = function() {
        var geometry = this.geometry;
        var verticesBuffer = geometry.buffers[0];
        var vertices = verticesBuffer.data;
        var vertexDirtyId = verticesBuffer._updateID;
        if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID) {
          return;
        }
        this._transformID = this.transform._worldID;
        if (this.vertexData.length !== vertices.length) {
          this.vertexData = new Float32Array(vertices.length);
        }
        var wt = this.transform.worldTransform;
        var a = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var vertexData = this.vertexData;
        for (var i = 0; i < vertexData.length / 2; i++) {
          var x = vertices[i * 2];
          var y = vertices[i * 2 + 1];
          vertexData[i * 2] = a * x + c * y + tx;
          vertexData[i * 2 + 1] = b * x + d * y + ty;
        }
        if (this._roundPixels) {
          var resolution = settings.RESOLUTION;
          for (var i = 0; i < vertexData.length; ++i) {
            vertexData[i] = Math.round((vertexData[i] * resolution | 0) / resolution);
          }
        }
        this.vertexDirty = vertexDirtyId;
      };
      Mesh2.prototype.calculateUvs = function() {
        var geomUvs = this.geometry.buffers[1];
        var shader = this.shader;
        if (!shader.uvMatrix.isSimple) {
          if (!this.batchUvs) {
            this.batchUvs = new MeshBatchUvs(geomUvs, shader.uvMatrix);
          }
          this.batchUvs.update();
          this.uvs = this.batchUvs.data;
        } else {
          this.uvs = geomUvs.data;
        }
      };
      Mesh2.prototype._calculateBounds = function() {
        this.calculateVertices();
        this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
      };
      Mesh2.prototype.containsPoint = function(point) {
        if (!this.getBounds().contains(point.x, point.y)) {
          return false;
        }
        this.worldTransform.applyInverse(point, tempPoint);
        var vertices = this.geometry.getBuffer("aVertexPosition").data;
        var points = tempPolygon.points;
        var indices2 = this.geometry.getIndex().data;
        var len = indices2.length;
        var step = this.drawMode === 4 ? 3 : 1;
        for (var i = 0; i + 2 < len; i += step) {
          var ind0 = indices2[i] * 2;
          var ind1 = indices2[i + 1] * 2;
          var ind2 = indices2[i + 2] * 2;
          points[0] = vertices[ind0];
          points[1] = vertices[ind0 + 1];
          points[2] = vertices[ind1];
          points[3] = vertices[ind1 + 1];
          points[4] = vertices[ind2];
          points[5] = vertices[ind2 + 1];
          if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {
            return true;
          }
        }
        return false;
      };
      Mesh2.prototype.destroy = function(options) {
        _super.prototype.destroy.call(this, options);
        if (this._cachedTexture) {
          this._cachedTexture.destroy();
          this._cachedTexture = null;
        }
        this.geometry = null;
        this.shader = null;
        this.state = null;
        this.uvs = null;
        this.indices = null;
        this.vertexData = null;
      };
      Mesh2.BATCHABLE_SIZE = 100;
      return Mesh2;
    }(Container)
  );
  var fragment2 = "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n";
  var vertex2 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n";
  var MeshMaterial = (
    /** @class */
    function(_super) {
      __extends4(MeshMaterial2, _super);
      function MeshMaterial2(uSampler, options) {
        var _this = this;
        var uniforms = {
          uSampler,
          alpha: 1,
          uTextureMatrix: Matrix.IDENTITY,
          uColor: new Float32Array([1, 1, 1, 1])
        };
        options = Object.assign({
          tint: 16777215,
          alpha: 1,
          pluginName: "batch"
        }, options);
        if (options.uniforms) {
          Object.assign(uniforms, options.uniforms);
        }
        _this = _super.call(this, options.program || Program.from(vertex2, fragment2), uniforms) || this;
        _this._colorDirty = false;
        _this.uvMatrix = new TextureMatrix(uSampler);
        _this.batchable = options.program === void 0;
        _this.pluginName = options.pluginName;
        _this.tint = options.tint;
        _this.alpha = options.alpha;
        return _this;
      }
      Object.defineProperty(MeshMaterial2.prototype, "texture", {
        /** Reference to the texture being rendered. */
        get: function() {
          return this.uniforms.uSampler;
        },
        set: function(value) {
          if (this.uniforms.uSampler !== value) {
            if (!this.uniforms.uSampler.baseTexture.alphaMode !== !value.baseTexture.alphaMode) {
              this._colorDirty = true;
            }
            this.uniforms.uSampler = value;
            this.uvMatrix.texture = value;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MeshMaterial2.prototype, "alpha", {
        get: function() {
          return this._alpha;
        },
        /**
         * This gets automatically set by the object using this.
         * @default 1
         */
        set: function(value) {
          if (value === this._alpha) {
            return;
          }
          this._alpha = value;
          this._colorDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MeshMaterial2.prototype, "tint", {
        get: function() {
          return this._tint;
        },
        /**
         * Multiply tint for the material.
         * @default 0xFFFFFF
         */
        set: function(value) {
          if (value === this._tint) {
            return;
          }
          this._tint = value;
          this._tintRGB = (value >> 16) + (value & 65280) + ((value & 255) << 16);
          this._colorDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      MeshMaterial2.prototype.update = function() {
        if (this._colorDirty) {
          this._colorDirty = false;
          var baseTexture = this.texture.baseTexture;
          premultiplyTintToRgba(this._tint, this._alpha, this.uniforms.uColor, baseTexture.alphaMode);
        }
        if (this.uvMatrix.update()) {
          this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;
        }
      };
      return MeshMaterial2;
    }(Shader)
  );
  var MeshGeometry = (
    /** @class */
    function(_super) {
      __extends4(MeshGeometry2, _super);
      function MeshGeometry2(vertices, uvs, index) {
        var _this = _super.call(this) || this;
        var verticesBuffer = new Buffer2(vertices);
        var uvsBuffer = new Buffer2(uvs, true);
        var indexBuffer = new Buffer2(index, true, true);
        _this.addAttribute("aVertexPosition", verticesBuffer, 2, false, TYPES.FLOAT).addAttribute("aTextureCoord", uvsBuffer, 2, false, TYPES.FLOAT).addIndex(indexBuffer);
        _this._updateId = -1;
        return _this;
      }
      Object.defineProperty(MeshGeometry2.prototype, "vertexDirtyId", {
        /**
         * If the vertex position is updated.
         * @readonly
         * @private
         */
        get: function() {
          return this.buffers[0]._updateID;
        },
        enumerable: false,
        configurable: true
      });
      return MeshGeometry2;
    }(Geometry)
  );

  // node_modules/@pixi/sprite/dist/esm/sprite.js
  var extendStatics5 = function(d, b) {
    extendStatics5 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) {
        if (b2.hasOwnProperty(p)) {
          d2[p] = b2[p];
        }
      }
    };
    return extendStatics5(d, b);
  };
  function __extends5(d, b) {
    extendStatics5(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var tempPoint2 = new Point();
  var indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
  var Sprite = (
    /** @class */
    function(_super) {
      __extends5(Sprite2, _super);
      function Sprite2(texture) {
        var _this = _super.call(this) || this;
        _this._anchor = new ObservablePoint(_this._onAnchorUpdate, _this, texture ? texture.defaultAnchor.x : 0, texture ? texture.defaultAnchor.y : 0);
        _this._texture = null;
        _this._width = 0;
        _this._height = 0;
        _this._tint = null;
        _this._tintRGB = null;
        _this.tint = 16777215;
        _this.blendMode = BLEND_MODES.NORMAL;
        _this._cachedTint = 16777215;
        _this.uvs = null;
        _this.texture = texture || Texture.EMPTY;
        _this.vertexData = new Float32Array(8);
        _this.vertexTrimmedData = null;
        _this._transformID = -1;
        _this._textureID = -1;
        _this._transformTrimmedID = -1;
        _this._textureTrimmedID = -1;
        _this.indices = indices;
        _this.pluginName = "batch";
        _this.isSprite = true;
        _this._roundPixels = settings.ROUND_PIXELS;
        return _this;
      }
      Sprite2.prototype._onTextureUpdate = function() {
        this._textureID = -1;
        this._textureTrimmedID = -1;
        this._cachedTint = 16777215;
        if (this._width) {
          this.scale.x = sign(this.scale.x) * this._width / this._texture.orig.width;
        }
        if (this._height) {
          this.scale.y = sign(this.scale.y) * this._height / this._texture.orig.height;
        }
      };
      Sprite2.prototype._onAnchorUpdate = function() {
        this._transformID = -1;
        this._transformTrimmedID = -1;
      };
      Sprite2.prototype.calculateVertices = function() {
        var texture = this._texture;
        if (this._transformID === this.transform._worldID && this._textureID === texture._updateID) {
          return;
        }
        if (this._textureID !== texture._updateID) {
          this.uvs = this._texture._uvs.uvsFloat32;
        }
        this._transformID = this.transform._worldID;
        this._textureID = texture._updateID;
        var wt = this.transform.worldTransform;
        var a = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var vertexData = this.vertexData;
        var trim = texture.trim;
        var orig = texture.orig;
        var anchor = this._anchor;
        var w0 = 0;
        var w1 = 0;
        var h0 = 0;
        var h1 = 0;
        if (trim) {
          w1 = trim.x - anchor._x * orig.width;
          w0 = w1 + trim.width;
          h1 = trim.y - anchor._y * orig.height;
          h0 = h1 + trim.height;
        } else {
          w1 = -anchor._x * orig.width;
          w0 = w1 + orig.width;
          h1 = -anchor._y * orig.height;
          h0 = h1 + orig.height;
        }
        vertexData[0] = a * w1 + c * h1 + tx;
        vertexData[1] = d * h1 + b * w1 + ty;
        vertexData[2] = a * w0 + c * h1 + tx;
        vertexData[3] = d * h1 + b * w0 + ty;
        vertexData[4] = a * w0 + c * h0 + tx;
        vertexData[5] = d * h0 + b * w0 + ty;
        vertexData[6] = a * w1 + c * h0 + tx;
        vertexData[7] = d * h0 + b * w1 + ty;
        if (this._roundPixels) {
          var resolution = settings.RESOLUTION;
          for (var i = 0; i < vertexData.length; ++i) {
            vertexData[i] = Math.round((vertexData[i] * resolution | 0) / resolution);
          }
        }
      };
      Sprite2.prototype.calculateTrimmedVertices = function() {
        if (!this.vertexTrimmedData) {
          this.vertexTrimmedData = new Float32Array(8);
        } else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {
          return;
        }
        this._transformTrimmedID = this.transform._worldID;
        this._textureTrimmedID = this._texture._updateID;
        var texture = this._texture;
        var vertexData = this.vertexTrimmedData;
        var orig = texture.orig;
        var anchor = this._anchor;
        var wt = this.transform.worldTransform;
        var a = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var w1 = -anchor._x * orig.width;
        var w0 = w1 + orig.width;
        var h1 = -anchor._y * orig.height;
        var h0 = h1 + orig.height;
        vertexData[0] = a * w1 + c * h1 + tx;
        vertexData[1] = d * h1 + b * w1 + ty;
        vertexData[2] = a * w0 + c * h1 + tx;
        vertexData[3] = d * h1 + b * w0 + ty;
        vertexData[4] = a * w0 + c * h0 + tx;
        vertexData[5] = d * h0 + b * w0 + ty;
        vertexData[6] = a * w1 + c * h0 + tx;
        vertexData[7] = d * h0 + b * w1 + ty;
      };
      Sprite2.prototype._render = function(renderer) {
        this.calculateVertices();
        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
        renderer.plugins[this.pluginName].render(this);
      };
      Sprite2.prototype._calculateBounds = function() {
        var trim = this._texture.trim;
        var orig = this._texture.orig;
        if (!trim || trim.width === orig.width && trim.height === orig.height) {
          this.calculateVertices();
          this._bounds.addQuad(this.vertexData);
        } else {
          this.calculateTrimmedVertices();
          this._bounds.addQuad(this.vertexTrimmedData);
        }
      };
      Sprite2.prototype.getLocalBounds = function(rect) {
        if (this.children.length === 0) {
          if (!this._localBounds) {
            this._localBounds = new Bounds();
          }
          this._localBounds.minX = this._texture.orig.width * -this._anchor._x;
          this._localBounds.minY = this._texture.orig.height * -this._anchor._y;
          this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x);
          this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y);
          if (!rect) {
            if (!this._localBoundsRect) {
              this._localBoundsRect = new Rectangle();
            }
            rect = this._localBoundsRect;
          }
          return this._localBounds.getRectangle(rect);
        }
        return _super.prototype.getLocalBounds.call(this, rect);
      };
      Sprite2.prototype.containsPoint = function(point) {
        this.worldTransform.applyInverse(point, tempPoint2);
        var width = this._texture.orig.width;
        var height = this._texture.orig.height;
        var x1 = -width * this.anchor.x;
        var y1 = 0;
        if (tempPoint2.x >= x1 && tempPoint2.x < x1 + width) {
          y1 = -height * this.anchor.y;
          if (tempPoint2.y >= y1 && tempPoint2.y < y1 + height) {
            return true;
          }
        }
        return false;
      };
      Sprite2.prototype.destroy = function(options) {
        _super.prototype.destroy.call(this, options);
        this._texture.off("update", this._onTextureUpdate, this);
        this._anchor = null;
        var destroyTexture = typeof options === "boolean" ? options : options && options.texture;
        if (destroyTexture) {
          var destroyBaseTexture = typeof options === "boolean" ? options : options && options.baseTexture;
          this._texture.destroy(!!destroyBaseTexture);
        }
        this._texture = null;
      };
      Sprite2.from = function(source, options) {
        var texture = source instanceof Texture ? source : Texture.from(source, options);
        return new Sprite2(texture);
      };
      Object.defineProperty(Sprite2.prototype, "roundPixels", {
        get: function() {
          return this._roundPixels;
        },
        /**
         * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
         *
         * Advantages can include sharper image quality (like text) and faster rendering on canvas.
         * The main disadvantage is movement of objects may appear less smooth.
         *
         * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}.
         * @default false
         */
        set: function(value) {
          if (this._roundPixels !== value) {
            this._transformID = -1;
          }
          this._roundPixels = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sprite2.prototype, "width", {
        /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
        get: function() {
          return Math.abs(this.scale.x) * this._texture.orig.width;
        },
        set: function(value) {
          var s = sign(this.scale.x) || 1;
          this.scale.x = s * value / this._texture.orig.width;
          this._width = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sprite2.prototype, "height", {
        /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */
        get: function() {
          return Math.abs(this.scale.y) * this._texture.orig.height;
        },
        set: function(value) {
          var s = sign(this.scale.y) || 1;
          this.scale.y = s * value / this._texture.orig.height;
          this._height = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sprite2.prototype, "anchor", {
        /**
         * The anchor sets the origin point of the sprite. The default value is taken from the {@link PIXI.Texture|Texture}
         * and passed to the constructor.
         *
         * The default is `(0,0)`, this means the sprite's origin is the top left.
         *
         * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
         *
         * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
         *
         * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
         * @example
         * const sprite = new PIXI.Sprite(texture);
         * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
         */
        get: function() {
          return this._anchor;
        },
        set: function(value) {
          this._anchor.copyFrom(value);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sprite2.prototype, "tint", {
        /**
         * The tint applied to the sprite. This is a hex value.
         *
         * A value of 0xFFFFFF will remove any tint effect.
         * @default 0xFFFFFF
         */
        get: function() {
          return this._tint;
        },
        set: function(value) {
          this._tint = value;
          this._tintRGB = (value >> 16) + (value & 65280) + ((value & 255) << 16);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sprite2.prototype, "texture", {
        /** The texture that the sprite is using. */
        get: function() {
          return this._texture;
        },
        set: function(value) {
          if (this._texture === value) {
            return;
          }
          if (this._texture) {
            this._texture.off("update", this._onTextureUpdate, this);
          }
          this._texture = value || Texture.EMPTY;
          this._cachedTint = 16777215;
          this._textureID = -1;
          this._textureTrimmedID = -1;
          if (value) {
            if (value.baseTexture.valid) {
              this._onTextureUpdate();
            } else {
              value.once("update", this._onTextureUpdate, this);
            }
          }
        },
        enumerable: false,
        configurable: true
      });
      return Sprite2;
    }(Container)
  );

  // node_modules/@pixi/canvas-renderer/dist/esm/canvas-renderer.js
  var extendStatics6 = function(d, b) {
    extendStatics6 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) {
        if (b2.hasOwnProperty(p)) {
          d2[p] = b2[p];
        }
      }
    };
    return extendStatics6(d, b);
  };
  function __extends6(d, b) {
    extendStatics6(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var CanvasMaskManager = (
    /** @class */
    function() {
      function CanvasMaskManager2(renderer) {
        this._foundShapes = [];
        this.renderer = renderer;
      }
      CanvasMaskManager2.prototype.pushMask = function(maskData) {
        var renderer = this.renderer;
        var maskObject = maskData.maskObject || maskData;
        renderer.context.save();
        var foundShapes = this._foundShapes;
        this.recursiveFindShapes(maskObject, foundShapes);
        if (foundShapes.length > 0) {
          var context3 = renderer.context;
          context3.beginPath();
          for (var i = 0; i < foundShapes.length; i++) {
            var shape = foundShapes[i];
            var transform = shape.transform.worldTransform;
            this.renderer.setContextTransform(transform);
            this.renderGraphicsShape(shape);
          }
          foundShapes.length = 0;
          context3.clip();
        }
      };
      CanvasMaskManager2.prototype.recursiveFindShapes = function(container, out) {
        if (container.geometry && container.geometry.graphicsData) {
          out.push(container);
        }
        var children = container.children;
        if (children) {
          for (var i = 0; i < children.length; i++) {
            this.recursiveFindShapes(children[i], out);
          }
        }
      };
      CanvasMaskManager2.prototype.renderGraphicsShape = function(graphics) {
        graphics.finishPoly();
        var context3 = this.renderer.context;
        var graphicsData = graphics.geometry.graphicsData;
        var len = graphicsData.length;
        if (len === 0) {
          return;
        }
        for (var i = 0; i < len; i++) {
          var data = graphicsData[i];
          var shape = data.shape;
          if (shape.type === SHAPES.POLY) {
            var points = shape.points;
            var holes = data.holes;
            var outerArea = void 0;
            var innerArea = void 0;
            var px = void 0;
            var py = void 0;
            context3.moveTo(points[0], points[1]);
            for (var j = 1; j < points.length / 2; j++) {
              context3.lineTo(points[j * 2], points[j * 2 + 1]);
            }
            if (holes.length > 0) {
              outerArea = 0;
              px = points[0];
              py = points[1];
              for (var j = 2; j + 2 < points.length; j += 2) {
                outerArea += (points[j] - px) * (points[j + 3] - py) - (points[j + 2] - px) * (points[j + 1] - py);
              }
              for (var k = 0; k < holes.length; k++) {
                points = holes[k].shape.points;
                if (!points) {
                  continue;
                }
                innerArea = 0;
                px = points[0];
                py = points[1];
                for (var j = 2; j + 2 < points.length; j += 2) {
                  innerArea += (points[j] - px) * (points[j + 3] - py) - (points[j + 2] - px) * (points[j + 1] - py);
                }
                if (innerArea * outerArea < 0) {
                  context3.moveTo(points[0], points[1]);
                  for (var j = 2; j < points.length; j += 2) {
                    context3.lineTo(points[j], points[j + 1]);
                  }
                } else {
                  context3.moveTo(points[points.length - 2], points[points.length - 1]);
                  for (var j = points.length - 4; j >= 0; j -= 2) {
                    context3.lineTo(points[j], points[j + 1]);
                  }
                }
                if (holes[k].shape.closeStroke) {
                  context3.closePath();
                }
              }
            }
            if (points[0] === points[points.length - 2] && points[1] === points[points.length - 1]) {
              context3.closePath();
            }
          } else if (shape.type === SHAPES.RECT) {
            context3.rect(shape.x, shape.y, shape.width, shape.height);
            context3.closePath();
          } else if (shape.type === SHAPES.CIRC) {
            context3.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);
            context3.closePath();
          } else if (shape.type === SHAPES.ELIP) {
            var w = shape.width * 2;
            var h = shape.height * 2;
            var x = shape.x - w / 2;
            var y = shape.y - h / 2;
            var kappa = 0.5522848;
            var ox = w / 2 * kappa;
            var oy = h / 2 * kappa;
            var xe = x + w;
            var ye = y + h;
            var xm = x + w / 2;
            var ym = y + h / 2;
            context3.moveTo(x, ym);
            context3.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
            context3.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
            context3.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
            context3.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
            context3.closePath();
          } else if (shape.type === SHAPES.RREC) {
            var rx = shape.x;
            var ry = shape.y;
            var width = shape.width;
            var height = shape.height;
            var radius = shape.radius;
            var maxRadius = Math.min(width, height) / 2;
            radius = radius > maxRadius ? maxRadius : radius;
            context3.moveTo(rx, ry + radius);
            context3.lineTo(rx, ry + height - radius);
            context3.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
            context3.lineTo(rx + width - radius, ry + height);
            context3.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
            context3.lineTo(rx + width, ry + radius);
            context3.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
            context3.lineTo(rx + radius, ry);
            context3.quadraticCurveTo(rx, ry, rx, ry + radius);
            context3.closePath();
          }
        }
      };
      CanvasMaskManager2.prototype.popMask = function(renderer) {
        renderer.context.restore();
        renderer.invalidateBlendMode();
      };
      CanvasMaskManager2.prototype.destroy = function() {
      };
      return CanvasMaskManager2;
    }()
  );
  function createColoredCanvas(color) {
    var canvas = document.createElement("canvas");
    canvas.width = 6;
    canvas.height = 1;
    var context3 = canvas.getContext("2d");
    context3.fillStyle = color;
    context3.fillRect(0, 0, 6, 1);
    return canvas;
  }
  function canUseNewCanvasBlendModes() {
    if (typeof document === "undefined") {
      return false;
    }
    var magenta2 = createColoredCanvas("#ff00ff");
    var yellow2 = createColoredCanvas("#ffff00");
    var canvas = document.createElement("canvas");
    canvas.width = 6;
    canvas.height = 1;
    var context3 = canvas.getContext("2d");
    context3.globalCompositeOperation = "multiply";
    context3.drawImage(magenta2, 0, 0);
    context3.drawImage(yellow2, 2, 0);
    var imageData = context3.getImageData(2, 0, 1, 1);
    if (!imageData) {
      return false;
    }
    var data = imageData.data;
    return data[0] === 255 && data[1] === 0 && data[2] === 0;
  }
  function mapCanvasBlendModesToPixi(array) {
    if (array === void 0) {
      array = [];
    }
    if (canUseNewCanvasBlendModes()) {
      array[BLEND_MODES.NORMAL] = "source-over";
      array[BLEND_MODES.ADD] = "lighter";
      array[BLEND_MODES.MULTIPLY] = "multiply";
      array[BLEND_MODES.SCREEN] = "screen";
      array[BLEND_MODES.OVERLAY] = "overlay";
      array[BLEND_MODES.DARKEN] = "darken";
      array[BLEND_MODES.LIGHTEN] = "lighten";
      array[BLEND_MODES.COLOR_DODGE] = "color-dodge";
      array[BLEND_MODES.COLOR_BURN] = "color-burn";
      array[BLEND_MODES.HARD_LIGHT] = "hard-light";
      array[BLEND_MODES.SOFT_LIGHT] = "soft-light";
      array[BLEND_MODES.DIFFERENCE] = "difference";
      array[BLEND_MODES.EXCLUSION] = "exclusion";
      array[BLEND_MODES.HUE] = "hue";
      array[BLEND_MODES.SATURATION] = "saturate";
      array[BLEND_MODES.COLOR] = "color";
      array[BLEND_MODES.LUMINOSITY] = "luminosity";
    } else {
      array[BLEND_MODES.NORMAL] = "source-over";
      array[BLEND_MODES.ADD] = "lighter";
      array[BLEND_MODES.MULTIPLY] = "source-over";
      array[BLEND_MODES.SCREEN] = "source-over";
      array[BLEND_MODES.OVERLAY] = "source-over";
      array[BLEND_MODES.DARKEN] = "source-over";
      array[BLEND_MODES.LIGHTEN] = "source-over";
      array[BLEND_MODES.COLOR_DODGE] = "source-over";
      array[BLEND_MODES.COLOR_BURN] = "source-over";
      array[BLEND_MODES.HARD_LIGHT] = "source-over";
      array[BLEND_MODES.SOFT_LIGHT] = "source-over";
      array[BLEND_MODES.DIFFERENCE] = "source-over";
      array[BLEND_MODES.EXCLUSION] = "source-over";
      array[BLEND_MODES.HUE] = "source-over";
      array[BLEND_MODES.SATURATION] = "source-over";
      array[BLEND_MODES.COLOR] = "source-over";
      array[BLEND_MODES.LUMINOSITY] = "source-over";
    }
    array[BLEND_MODES.NORMAL_NPM] = array[BLEND_MODES.NORMAL];
    array[BLEND_MODES.ADD_NPM] = array[BLEND_MODES.ADD];
    array[BLEND_MODES.SCREEN_NPM] = array[BLEND_MODES.SCREEN];
    array[BLEND_MODES.SRC_IN] = "source-in";
    array[BLEND_MODES.SRC_OUT] = "source-out";
    array[BLEND_MODES.SRC_ATOP] = "source-atop";
    array[BLEND_MODES.DST_OVER] = "destination-over";
    array[BLEND_MODES.DST_IN] = "destination-in";
    array[BLEND_MODES.DST_OUT] = "destination-out";
    array[BLEND_MODES.DST_ATOP] = "destination-atop";
    array[BLEND_MODES.XOR] = "xor";
    array[BLEND_MODES.SUBTRACT] = "source-over";
    return array;
  }
  var tempMatrix2 = new Matrix();
  var CanvasRenderer = (
    /** @class */
    function(_super) {
      __extends6(CanvasRenderer2, _super);
      function CanvasRenderer2(options) {
        var _this = _super.call(this, RENDERER_TYPE.CANVAS, options) || this;
        _this.refresh = true;
        _this.maskManager = new CanvasMaskManager(_this);
        _this.smoothProperty = "imageSmoothingEnabled";
        _this.blendModes = mapCanvasBlendModesToPixi();
        _this.renderingToScreen = false;
        _this._activeBlendMode = null;
        _this._projTransform = null;
        _this._outerBlend = false;
        _this.rootContext = _this.view.getContext("2d", { alpha: _this.useContextAlpha });
        _this.context = _this.rootContext;
        if (!_this.rootContext.imageSmoothingEnabled) {
          var rc = _this.rootContext;
          if (rc.webkitImageSmoothingEnabled) {
            _this.smoothProperty = "webkitImageSmoothingEnabled";
          } else if (rc.mozImageSmoothingEnabled) {
            _this.smoothProperty = "mozImageSmoothingEnabled";
          } else if (rc.oImageSmoothingEnabled) {
            _this.smoothProperty = "oImageSmoothingEnabled";
          } else if (rc.msImageSmoothingEnabled) {
            _this.smoothProperty = "msImageSmoothingEnabled";
          }
        }
        _this.initPlugins(CanvasRenderer2.__plugins);
        sayHello("Canvas");
        _this.resize(_this.options.width, _this.options.height);
        return _this;
      }
      CanvasRenderer2.prototype.addSystem = function() {
        return this;
      };
      CanvasRenderer2.prototype.render = function(displayObject, options) {
        if (!this.view) {
          return;
        }
        var renderTexture;
        var clear;
        var transform;
        var skipUpdateTransform;
        if (options) {
          if (options instanceof RenderTexture || options instanceof BaseRenderTexture) {
            deprecation("6.0.0", "CanvasRenderer#render arguments changed, use options instead.");
            renderTexture = options;
            clear = arguments[2];
            transform = arguments[3];
            skipUpdateTransform = arguments[4];
          } else {
            renderTexture = options.renderTexture;
            clear = options.clear;
            transform = options.transform;
            skipUpdateTransform = options.skipUpdateTransform;
          }
        }
        this.renderingToScreen = !renderTexture;
        this.emit("prerender");
        var rootResolution = this.resolution;
        if (renderTexture) {
          renderTexture = renderTexture.castToBaseTexture();
          if (!renderTexture._canvasRenderTarget) {
            renderTexture._canvasRenderTarget = new CanvasRenderTarget(renderTexture.width, renderTexture.height, renderTexture.resolution);
            renderTexture.resource = new CanvasResource(renderTexture._canvasRenderTarget.canvas);
            renderTexture.valid = true;
          }
          this.context = renderTexture._canvasRenderTarget.context;
          this.resolution = renderTexture._canvasRenderTarget.resolution;
        } else {
          this.context = this.rootContext;
        }
        var context3 = this.context;
        this._projTransform = transform || null;
        if (!renderTexture) {
          this._lastObjectRendered = displayObject;
        }
        if (!skipUpdateTransform) {
          var cacheParent = displayObject.enableTempParent();
          displayObject.updateTransform();
          displayObject.disableTempParent(cacheParent);
        }
        context3.save();
        context3.setTransform(1, 0, 0, 1, 0, 0);
        context3.globalAlpha = 1;
        this._activeBlendMode = BLEND_MODES.NORMAL;
        this._outerBlend = false;
        context3.globalCompositeOperation = this.blendModes[BLEND_MODES.NORMAL];
        if (clear !== void 0 ? clear : this.clearBeforeRender) {
          if (this.renderingToScreen) {
            context3.clearRect(0, 0, this.width, this.height);
            if (this.backgroundAlpha > 0) {
              context3.globalAlpha = this.useContextAlpha ? this.backgroundAlpha : 1;
              context3.fillStyle = this._backgroundColorString;
              context3.fillRect(0, 0, this.width, this.height);
              context3.globalAlpha = 1;
            }
          } else {
            renderTexture = renderTexture;
            renderTexture._canvasRenderTarget.clear();
            var clearColor = renderTexture.clearColor;
            if (clearColor[3] > 0) {
              context3.globalAlpha = this.useContextAlpha ? clearColor[3] : 1;
              context3.fillStyle = hex2string(rgb2hex(clearColor));
              context3.fillRect(0, 0, renderTexture.realWidth, renderTexture.realHeight);
              context3.globalAlpha = 1;
            }
          }
        }
        var tempContext = this.context;
        this.context = context3;
        displayObject.renderCanvas(this);
        this.context = tempContext;
        context3.restore();
        this.resolution = rootResolution;
        this._projTransform = null;
        this.emit("postrender");
      };
      CanvasRenderer2.prototype.setContextTransform = function(transform, roundPixels, localResolution) {
        var mat = transform;
        var proj = this._projTransform;
        var resolution = this.resolution;
        localResolution = localResolution || resolution;
        if (proj) {
          mat = tempMatrix2;
          mat.copyFrom(transform);
          mat.prepend(proj);
        }
        if (roundPixels) {
          this.context.setTransform(mat.a * localResolution, mat.b * localResolution, mat.c * localResolution, mat.d * localResolution, mat.tx * resolution | 0, mat.ty * resolution | 0);
        } else {
          this.context.setTransform(mat.a * localResolution, mat.b * localResolution, mat.c * localResolution, mat.d * localResolution, mat.tx * resolution, mat.ty * resolution);
        }
      };
      CanvasRenderer2.prototype.clear = function(clearColor, alpha) {
        if (clearColor === void 0) {
          clearColor = this._backgroundColorString;
        }
        if (alpha === void 0) {
          alpha = this.backgroundAlpha;
        }
        var context3 = this.context;
        context3.clearRect(0, 0, this.width, this.height);
        if (clearColor) {
          context3.globalAlpha = this.useContextAlpha ? alpha : 1;
          context3.fillStyle = clearColor;
          context3.fillRect(0, 0, this.width, this.height);
          context3.globalAlpha = 1;
        }
      };
      CanvasRenderer2.prototype.setBlendMode = function(blendMode, readyForOuterBlend) {
        var outerBlend = blendMode === BLEND_MODES.SRC_IN || blendMode === BLEND_MODES.SRC_OUT || blendMode === BLEND_MODES.DST_IN || blendMode === BLEND_MODES.DST_ATOP;
        if (!readyForOuterBlend && outerBlend) {
          blendMode = BLEND_MODES.NORMAL;
        }
        if (this._activeBlendMode === blendMode) {
          return;
        }
        this._activeBlendMode = blendMode;
        this._outerBlend = outerBlend;
        this.context.globalCompositeOperation = this.blendModes[blendMode];
      };
      CanvasRenderer2.prototype.destroy = function(removeView) {
        _super.prototype.destroy.call(this, removeView);
        this.context = null;
        this.refresh = true;
        this.maskManager.destroy();
        this.maskManager = null;
        this.smoothProperty = null;
      };
      CanvasRenderer2.prototype.resize = function(desiredScreenWidth, desiredScreenHeight) {
        _super.prototype.resize.call(this, desiredScreenWidth, desiredScreenHeight);
        if (this.smoothProperty) {
          this.rootContext[this.smoothProperty] = settings.SCALE_MODE === SCALE_MODES.LINEAR;
        }
      };
      CanvasRenderer2.prototype.invalidateBlendMode = function() {
        this._activeBlendMode = this.blendModes.indexOf(this.context.globalCompositeOperation);
      };
      CanvasRenderer2.registerPlugin = function(pluginName, ctor) {
        CanvasRenderer2.__plugins = CanvasRenderer2.__plugins || {};
        CanvasRenderer2.__plugins[pluginName] = ctor;
      };
      return CanvasRenderer2;
    }(AbstractRenderer)
  );
  var canvasUtils = {
    canvas: null,
    /**
     * Basically this method just needs a sprite and a color and tints the sprite with the given color.
     * @memberof PIXI.canvasUtils
     * @param {PIXI.Sprite} sprite - the sprite to tint
     * @param sprite.texture
     * @param {number} color - the color to use to tint the sprite with
     * @returns {HTMLCanvasElement} The tinted canvas
     */
    getTintedCanvas: function(sprite, color) {
      var texture = sprite.texture;
      color = canvasUtils.roundColor(color);
      var stringColor = "#" + ("00000" + (color | 0).toString(16)).slice(-6);
      texture.tintCache = texture.tintCache || {};
      var cachedCanvas = texture.tintCache[stringColor];
      var canvas;
      if (cachedCanvas) {
        if (cachedCanvas.tintId === texture._updateID) {
          return texture.tintCache[stringColor];
        }
        canvas = texture.tintCache[stringColor];
      } else {
        canvas = document.createElement("canvas");
      }
      canvasUtils.tintMethod(texture, color, canvas);
      canvas.tintId = texture._updateID;
      if (canvasUtils.convertTintToImage) {
        var tintImage = new Image();
        tintImage.src = canvas.toDataURL();
        texture.tintCache[stringColor] = tintImage;
      } else {
        texture.tintCache[stringColor] = canvas;
      }
      return canvas;
    },
    /**
     * Basically this method just needs a sprite and a color and tints the sprite with the given color.
     * @memberof PIXI.canvasUtils
     * @param {PIXI.Texture} texture - the sprite to tint
     * @param {number} color - the color to use to tint the sprite with
     * @returns {HTMLCanvasElement} The tinted canvas
     */
    getTintedPattern: function(texture, color) {
      color = canvasUtils.roundColor(color);
      var stringColor = "#" + ("00000" + (color | 0).toString(16)).slice(-6);
      texture.patternCache = texture.patternCache || {};
      var pattern = texture.patternCache[stringColor];
      if (pattern && pattern.tintId === texture._updateID) {
        return pattern;
      }
      if (!canvasUtils.canvas) {
        canvasUtils.canvas = document.createElement("canvas");
      }
      canvasUtils.tintMethod(texture, color, canvasUtils.canvas);
      pattern = canvasUtils.canvas.getContext("2d").createPattern(canvasUtils.canvas, "repeat");
      pattern.tintId = texture._updateID;
      texture.patternCache[stringColor] = pattern;
      return pattern;
    },
    /**
     * Tint a texture using the 'multiply' operation.
     * @memberof PIXI.canvasUtils
     * @param {PIXI.Texture} texture - the texture to tint
     * @param {number} color - the color to use to tint the sprite with
     * @param {HTMLCanvasElement} canvas - the current canvas
     */
    tintWithMultiply: function(texture, color, canvas) {
      var context3 = canvas.getContext("2d");
      var crop = texture._frame.clone();
      var resolution = texture.baseTexture.resolution;
      crop.x *= resolution;
      crop.y *= resolution;
      crop.width *= resolution;
      crop.height *= resolution;
      canvas.width = Math.ceil(crop.width);
      canvas.height = Math.ceil(crop.height);
      context3.save();
      context3.fillStyle = "#" + ("00000" + (color | 0).toString(16)).slice(-6);
      context3.fillRect(0, 0, crop.width, crop.height);
      context3.globalCompositeOperation = "multiply";
      var source = texture.baseTexture.getDrawableSource();
      context3.drawImage(source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
      context3.globalCompositeOperation = "destination-atop";
      context3.drawImage(source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
      context3.restore();
    },
    /**
     * Tint a texture using the 'overlay' operation.
     * @memberof PIXI.canvasUtils
     * @param {PIXI.Texture} texture - the texture to tint
     * @param {number} color - the color to use to tint the sprite with
     * @param {HTMLCanvasElement} canvas - the current canvas
     */
    tintWithOverlay: function(texture, color, canvas) {
      var context3 = canvas.getContext("2d");
      var crop = texture._frame.clone();
      var resolution = texture.baseTexture.resolution;
      crop.x *= resolution;
      crop.y *= resolution;
      crop.width *= resolution;
      crop.height *= resolution;
      canvas.width = Math.ceil(crop.width);
      canvas.height = Math.ceil(crop.height);
      context3.save();
      context3.globalCompositeOperation = "copy";
      context3.fillStyle = "#" + ("00000" + (color | 0).toString(16)).slice(-6);
      context3.fillRect(0, 0, crop.width, crop.height);
      context3.globalCompositeOperation = "destination-atop";
      context3.drawImage(texture.baseTexture.getDrawableSource(), crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
      context3.restore();
    },
    /**
     * Tint a texture pixel per pixel.
     * @memberof PIXI.canvasUtils
     * @param {PIXI.Texture} texture - the texture to tint
     * @param {number} color - the color to use to tint the sprite with
     * @param {HTMLCanvasElement} canvas - the current canvas
     */
    tintWithPerPixel: function(texture, color, canvas) {
      var context3 = canvas.getContext("2d");
      var crop = texture._frame.clone();
      var resolution = texture.baseTexture.resolution;
      crop.x *= resolution;
      crop.y *= resolution;
      crop.width *= resolution;
      crop.height *= resolution;
      canvas.width = Math.ceil(crop.width);
      canvas.height = Math.ceil(crop.height);
      context3.save();
      context3.globalCompositeOperation = "copy";
      context3.drawImage(texture.baseTexture.getDrawableSource(), crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
      context3.restore();
      var rgbValues = hex2rgb(color);
      var r = rgbValues[0];
      var g = rgbValues[1];
      var b = rgbValues[2];
      var pixelData = context3.getImageData(0, 0, crop.width, crop.height);
      var pixels = pixelData.data;
      for (var i = 0; i < pixels.length; i += 4) {
        pixels[i + 0] *= r;
        pixels[i + 1] *= g;
        pixels[i + 2] *= b;
      }
      context3.putImageData(pixelData, 0, 0);
    },
    /**
     * Rounds the specified color according to the canvasUtils.cacheStepsPerColorChannel.
     * @memberof PIXI.canvasUtils
     * @param {number} color - the color to round, should be a hex color
     * @returns {number} The rounded color.
     */
    roundColor: function(color) {
      var step = canvasUtils.cacheStepsPerColorChannel;
      var rgbValues = hex2rgb(color);
      rgbValues[0] = Math.min(255, rgbValues[0] / step * step);
      rgbValues[1] = Math.min(255, rgbValues[1] / step * step);
      rgbValues[2] = Math.min(255, rgbValues[2] / step * step);
      return rgb2hex(rgbValues);
    },
    /**
     * Number of steps which will be used as a cap when rounding colors.
     * @memberof PIXI.canvasUtils
     * @type {number}
     */
    cacheStepsPerColorChannel: 8,
    /**
     * Tint cache boolean flag.
     * @memberof PIXI.canvasUtils
     * @type {boolean}
     */
    convertTintToImage: false,
    /**
     * Whether or not the Canvas BlendModes are supported, consequently the ability to tint using the multiply method.
     * @memberof PIXI.canvasUtils
     * @type {boolean}
     */
    canUseMultiply: canUseNewCanvasBlendModes(),
    /**
     * The tinting method that will be used.
     * @memberof PIXI.canvasUtils
     * @type {Function}
     */
    tintMethod: null
  };
  canvasUtils.tintMethod = canvasUtils.canUseMultiply ? canvasUtils.tintWithMultiply : canvasUtils.tintWithPerPixel;
  var parentCreate = Renderer.create;
  Renderer.create = function create(options) {
    var forceCanvas = options && options.forceCanvas;
    if (!forceCanvas) {
      try {
        return parentCreate(options);
      } catch (err) {
      }
    }
    return new CanvasRenderer(options);
  };
  BaseTexture.prototype.getDrawableSource = function getDrawableSource() {
    var resource = this.resource;
    return resource ? resource.bitmap || resource.source : null;
  };
  BaseRenderTexture.prototype._canvasRenderTarget = null;
  Texture.prototype.patternCache = null;
  Texture.prototype.tintCache = null;

  // node_modules/@pixi/canvas-extract/dist/esm/canvas-extract.js
  var TEMP_RECT2 = new Rectangle();
  var CanvasExtract = (
    /** @class */
    function() {
      function CanvasExtract2(renderer) {
        this.renderer = renderer;
      }
      CanvasExtract2.prototype.image = function(target, format3, quality) {
        var image = new Image();
        image.src = this.base64(target, format3, quality);
        return image;
      };
      CanvasExtract2.prototype.base64 = function(target, format3, quality) {
        return this.canvas(target).toDataURL(format3, quality);
      };
      CanvasExtract2.prototype.canvas = function(target) {
        var renderer = this.renderer;
        var context3;
        var resolution;
        var frame;
        var renderTexture;
        if (target) {
          if (target instanceof RenderTexture) {
            renderTexture = target;
          } else {
            renderTexture = renderer.generateTexture(target);
          }
        }
        if (renderTexture) {
          context3 = renderTexture.baseTexture._canvasRenderTarget.context;
          resolution = renderTexture.baseTexture._canvasRenderTarget.resolution;
          frame = renderTexture.frame;
        } else {
          context3 = renderer.rootContext;
          resolution = renderer.resolution;
          frame = TEMP_RECT2;
          frame.width = this.renderer.width;
          frame.height = this.renderer.height;
        }
        var width = Math.floor(frame.width * resolution + 1e-4);
        var height = Math.floor(frame.height * resolution + 1e-4);
        var canvasBuffer = new CanvasRenderTarget(width, height, 1);
        var canvasData = context3.getImageData(frame.x * resolution, frame.y * resolution, width, height);
        canvasBuffer.context.putImageData(canvasData, 0, 0);
        return canvasBuffer.canvas;
      };
      CanvasExtract2.prototype.pixels = function(target) {
        var renderer = this.renderer;
        var context3;
        var resolution;
        var frame;
        var renderTexture;
        if (target) {
          if (target instanceof RenderTexture) {
            renderTexture = target;
          } else {
            renderTexture = renderer.generateTexture(target);
          }
        }
        if (renderTexture) {
          context3 = renderTexture.baseTexture._canvasRenderTarget.context;
          resolution = renderTexture.baseTexture._canvasRenderTarget.resolution;
          frame = renderTexture.frame;
        } else {
          context3 = renderer.rootContext;
          resolution = renderer.resolution;
          frame = TEMP_RECT2;
          frame.width = renderer.width;
          frame.height = renderer.height;
        }
        var x = frame.x * resolution;
        var y = frame.y * resolution;
        var width = frame.width * resolution;
        var height = frame.height * resolution;
        return context3.getImageData(x, y, width, height).data;
      };
      CanvasExtract2.prototype.destroy = function() {
        this.renderer = null;
      };
      return CanvasExtract2;
    }()
  );

  // node_modules/@pixi/app/dist/esm/app.js
  var Application = (
    /** @class */
    function() {
      function Application2(options) {
        var _this = this;
        this.stage = new Container();
        options = Object.assign({
          forceCanvas: false
        }, options);
        this.renderer = autoDetectRenderer(options);
        Application2._plugins.forEach(function(plugin) {
          plugin.init.call(_this, options);
        });
      }
      Application2.registerPlugin = function(plugin) {
        Application2._plugins.push(plugin);
      };
      Application2.prototype.render = function() {
        this.renderer.render(this.stage);
      };
      Object.defineProperty(Application2.prototype, "view", {
        /**
         * Reference to the renderer's canvas element.
         * @member {HTMLCanvasElement}
         * @readonly
         */
        get: function() {
          return this.renderer.view;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Application2.prototype, "screen", {
        /**
         * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.
         * @member {PIXI.Rectangle}
         * @readonly
         */
        get: function() {
          return this.renderer.screen;
        },
        enumerable: false,
        configurable: true
      });
      Application2.prototype.destroy = function(removeView, stageOptions) {
        var _this = this;
        var plugins = Application2._plugins.slice(0);
        plugins.reverse();
        plugins.forEach(function(plugin) {
          plugin.destroy.call(_this);
        });
        this.stage.destroy(stageOptions);
        this.stage = null;
        this.renderer.destroy(removeView);
        this.renderer = null;
      };
      Application2._plugins = [];
      return Application2;
    }()
  );
  var ResizePlugin = (
    /** @class */
    function() {
      function ResizePlugin2() {
      }
      ResizePlugin2.init = function(options) {
        var _this = this;
        Object.defineProperty(
          this,
          "resizeTo",
          /**
           * The HTML element or window to automatically resize the
           * renderer's view element to match width and height.
           * @member {Window|HTMLElement}
           * @name resizeTo
           * @memberof PIXI.Application#
           */
          {
            set: function(dom) {
              globalThis.removeEventListener("resize", this.queueResize);
              this._resizeTo = dom;
              if (dom) {
                globalThis.addEventListener("resize", this.queueResize);
                this.resize();
              }
            },
            get: function() {
              return this._resizeTo;
            }
          }
        );
        this.queueResize = function() {
          if (!_this._resizeTo) {
            return;
          }
          _this.cancelResize();
          _this._resizeId = requestAnimationFrame(function() {
            return _this.resize();
          });
        };
        this.cancelResize = function() {
          if (_this._resizeId) {
            cancelAnimationFrame(_this._resizeId);
            _this._resizeId = null;
          }
        };
        this.resize = function() {
          if (!_this._resizeTo) {
            return;
          }
          _this.cancelResize();
          var width;
          var height;
          if (_this._resizeTo === globalThis.window) {
            width = globalThis.innerWidth;
            height = globalThis.innerHeight;
          } else {
            var _a2 = _this._resizeTo, clientWidth = _a2.clientWidth, clientHeight = _a2.clientHeight;
            width = clientWidth;
            height = clientHeight;
          }
          _this.renderer.resize(width, height);
        };
        this._resizeId = null;
        this._resizeTo = null;
        this.resizeTo = options.resizeTo || null;
      };
      ResizePlugin2.destroy = function() {
        globalThis.removeEventListener("resize", this.queueResize);
        this.cancelResize();
        this.cancelResize = null;
        this.queueResize = null;
        this.resizeTo = null;
        this.resize = null;
      };
      return ResizePlugin2;
    }()
  );
  Application.registerPlugin(ResizePlugin);

  // node_modules/@pixi/graphics/dist/esm/graphics.js
  var LINE_JOIN;
  (function(LINE_JOIN2) {
    LINE_JOIN2["MITER"] = "miter";
    LINE_JOIN2["BEVEL"] = "bevel";
    LINE_JOIN2["ROUND"] = "round";
  })(LINE_JOIN || (LINE_JOIN = {}));
  var LINE_CAP;
  (function(LINE_CAP2) {
    LINE_CAP2["BUTT"] = "butt";
    LINE_CAP2["ROUND"] = "round";
    LINE_CAP2["SQUARE"] = "square";
  })(LINE_CAP || (LINE_CAP = {}));
  var GRAPHICS_CURVES = {
    adaptive: true,
    maxLength: 10,
    minSegments: 8,
    maxSegments: 2048,
    epsilon: 1e-4,
    _segmentsCount: function(length, defaultSegments) {
      if (defaultSegments === void 0) {
        defaultSegments = 20;
      }
      if (!this.adaptive || !length || isNaN(length)) {
        return defaultSegments;
      }
      var result = Math.ceil(length / this.maxLength);
      if (result < this.minSegments) {
        result = this.minSegments;
      } else if (result > this.maxSegments) {
        result = this.maxSegments;
      }
      return result;
    }
  };
  var FillStyle = (
    /** @class */
    function() {
      function FillStyle2() {
        this.color = 16777215;
        this.alpha = 1;
        this.texture = Texture.WHITE;
        this.matrix = null;
        this.visible = false;
        this.reset();
      }
      FillStyle2.prototype.clone = function() {
        var obj = new FillStyle2();
        obj.color = this.color;
        obj.alpha = this.alpha;
        obj.texture = this.texture;
        obj.matrix = this.matrix;
        obj.visible = this.visible;
        return obj;
      };
      FillStyle2.prototype.reset = function() {
        this.color = 16777215;
        this.alpha = 1;
        this.texture = Texture.WHITE;
        this.matrix = null;
        this.visible = false;
      };
      FillStyle2.prototype.destroy = function() {
        this.texture = null;
        this.matrix = null;
      };
      return FillStyle2;
    }()
  );
  var extendStatics7 = function(d, b) {
    extendStatics7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) {
        if (b2.hasOwnProperty(p)) {
          d2[p] = b2[p];
        }
      }
    };
    return extendStatics7(d, b);
  };
  function __extends7(d, b) {
    extendStatics7(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  function fixOrientation(points, hole) {
    var _a2, _b;
    if (hole === void 0) {
      hole = false;
    }
    var m = points.length;
    if (m < 6) {
      return;
    }
    var area = 0;
    for (var i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2) {
      var x2 = points[i];
      var y2 = points[i + 1];
      area += (x2 - x1) * (y2 + y1);
      x1 = x2;
      y1 = y2;
    }
    if (!hole && area > 0 || hole && area <= 0) {
      var n = m / 2;
      for (var i = n + n % 2; i < m; i += 2) {
        var i1 = m - i - 2;
        var i2 = m - i - 1;
        var i3 = i;
        var i4 = i + 1;
        _a2 = [points[i3], points[i1]], points[i1] = _a2[0], points[i3] = _a2[1];
        _b = [points[i4], points[i2]], points[i2] = _b[0], points[i4] = _b[1];
      }
    }
  }
  var buildPoly = {
    build: function(graphicsData) {
      graphicsData.points = graphicsData.shape.points.slice();
    },
    triangulate: function(graphicsData, graphicsGeometry) {
      var points = graphicsData.points;
      var holes = graphicsData.holes;
      var verts = graphicsGeometry.points;
      var indices2 = graphicsGeometry.indices;
      if (points.length >= 6) {
        fixOrientation(points, false);
        var holeArray = [];
        for (var i = 0; i < holes.length; i++) {
          var hole = holes[i];
          fixOrientation(hole.points, true);
          holeArray.push(points.length / 2);
          points = points.concat(hole.points);
        }
        var triangles = (0, import_earcut.default)(points, holeArray, 2);
        if (!triangles) {
          return;
        }
        var vertPos = verts.length / 2;
        for (var i = 0; i < triangles.length; i += 3) {
          indices2.push(triangles[i] + vertPos);
          indices2.push(triangles[i + 1] + vertPos);
          indices2.push(triangles[i + 2] + vertPos);
        }
        for (var i = 0; i < points.length; i++) {
          verts.push(points[i]);
        }
      }
    }
  };
  var buildCircle = {
    build: function(graphicsData) {
      var points = graphicsData.points;
      var x;
      var y;
      var dx;
      var dy;
      var rx;
      var ry;
      if (graphicsData.type === SHAPES.CIRC) {
        var circle = graphicsData.shape;
        x = circle.x;
        y = circle.y;
        rx = ry = circle.radius;
        dx = dy = 0;
      } else if (graphicsData.type === SHAPES.ELIP) {
        var ellipse = graphicsData.shape;
        x = ellipse.x;
        y = ellipse.y;
        rx = ellipse.width;
        ry = ellipse.height;
        dx = dy = 0;
      } else {
        var roundedRect = graphicsData.shape;
        var halfWidth = roundedRect.width / 2;
        var halfHeight = roundedRect.height / 2;
        x = roundedRect.x + halfWidth;
        y = roundedRect.y + halfHeight;
        rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
        dx = halfWidth - rx;
        dy = halfHeight - ry;
      }
      if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {
        points.length = 0;
        return;
      }
      var n = Math.ceil(2.3 * Math.sqrt(rx + ry));
      var m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
      points.length = m;
      if (m === 0) {
        return;
      }
      if (n === 0) {
        points.length = 8;
        points[0] = points[6] = x + dx;
        points[1] = points[3] = y + dy;
        points[2] = points[4] = x - dx;
        points[5] = points[7] = y - dy;
        return;
      }
      var j1 = 0;
      var j2 = n * 4 + (dx ? 2 : 0) + 2;
      var j3 = j2;
      var j4 = m;
      {
        var x0 = dx + rx;
        var y0 = dy;
        var x1 = x + x0;
        var x2 = x - x0;
        var y1 = y + y0;
        points[j1++] = x1;
        points[j1++] = y1;
        points[--j2] = y1;
        points[--j2] = x2;
        if (dy) {
          var y2 = y - y0;
          points[j3++] = x2;
          points[j3++] = y2;
          points[--j4] = y2;
          points[--j4] = x1;
        }
      }
      for (var i = 1; i < n; i++) {
        var a = Math.PI / 2 * (i / n);
        var x0 = dx + Math.cos(a) * rx;
        var y0 = dy + Math.sin(a) * ry;
        var x1 = x + x0;
        var x2 = x - x0;
        var y1 = y + y0;
        var y2 = y - y0;
        points[j1++] = x1;
        points[j1++] = y1;
        points[--j2] = y1;
        points[--j2] = x2;
        points[j3++] = x2;
        points[j3++] = y2;
        points[--j4] = y2;
        points[--j4] = x1;
      }
      {
        var x0 = dx;
        var y0 = dy + ry;
        var x1 = x + x0;
        var x2 = x - x0;
        var y1 = y + y0;
        var y2 = y - y0;
        points[j1++] = x1;
        points[j1++] = y1;
        points[--j4] = y2;
        points[--j4] = x1;
        if (dx) {
          points[j1++] = x2;
          points[j1++] = y1;
          points[--j4] = y2;
          points[--j4] = x2;
        }
      }
    },
    triangulate: function(graphicsData, graphicsGeometry) {
      var points = graphicsData.points;
      var verts = graphicsGeometry.points;
      var indices2 = graphicsGeometry.indices;
      var vertPos = verts.length / 2;
      var center = vertPos;
      var x;
      var y;
      if (graphicsData.type !== SHAPES.RREC) {
        var circle = graphicsData.shape;
        x = circle.x;
        y = circle.y;
      } else {
        var roundedRect = graphicsData.shape;
        x = roundedRect.x + roundedRect.width / 2;
        y = roundedRect.y + roundedRect.height / 2;
      }
      var matrix = graphicsData.matrix;
      verts.push(graphicsData.matrix ? matrix.a * x + matrix.c * y + matrix.tx : x, graphicsData.matrix ? matrix.b * x + matrix.d * y + matrix.ty : y);
      vertPos++;
      verts.push(points[0], points[1]);
      for (var i = 2; i < points.length; i += 2) {
        verts.push(points[i], points[i + 1]);
        indices2.push(vertPos++, center, vertPos);
      }
      indices2.push(center + 1, center, vertPos);
    }
  };
  var buildRectangle = {
    build: function(graphicsData) {
      var rectData = graphicsData.shape;
      var x = rectData.x;
      var y = rectData.y;
      var width = rectData.width;
      var height = rectData.height;
      var points = graphicsData.points;
      points.length = 0;
      points.push(x, y, x + width, y, x + width, y + height, x, y + height);
    },
    triangulate: function(graphicsData, graphicsGeometry) {
      var points = graphicsData.points;
      var verts = graphicsGeometry.points;
      var vertPos = verts.length / 2;
      verts.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]);
      graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);
    }
  };
  function getPt(n1, n2, perc) {
    var diff = n2 - n1;
    return n1 + diff * perc;
  }
  function quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY, out) {
    if (out === void 0) {
      out = [];
    }
    var n = 20;
    var points = out;
    var xa = 0;
    var ya = 0;
    var xb = 0;
    var yb = 0;
    var x = 0;
    var y = 0;
    for (var i = 0, j = 0; i <= n; ++i) {
      j = i / n;
      xa = getPt(fromX, cpX, j);
      ya = getPt(fromY, cpY, j);
      xb = getPt(cpX, toX, j);
      yb = getPt(cpY, toY, j);
      x = getPt(xa, xb, j);
      y = getPt(ya, yb, j);
      if (i === 0 && points[points.length - 2] === x && points[points.length - 1] === y) {
        continue;
      }
      points.push(x, y);
    }
    return points;
  }
  var buildRoundedRectangle = {
    build: function(graphicsData) {
      if (Graphics.nextRoundedRectBehavior) {
        buildCircle.build(graphicsData);
        return;
      }
      var rrectData = graphicsData.shape;
      var points = graphicsData.points;
      var x = rrectData.x;
      var y = rrectData.y;
      var width = rrectData.width;
      var height = rrectData.height;
      var radius = Math.max(0, Math.min(rrectData.radius, Math.min(width, height) / 2));
      points.length = 0;
      if (!radius) {
        points.push(x, y, x + width, y, x + width, y + height, x, y + height);
      } else {
        quadraticBezierCurve(x, y + radius, x, y, x + radius, y, points);
        quadraticBezierCurve(x + width - radius, y, x + width, y, x + width, y + radius, points);
        quadraticBezierCurve(x + width, y + height - radius, x + width, y + height, x + width - radius, y + height, points);
        quadraticBezierCurve(x + radius, y + height, x, y + height, x, y + height - radius, points);
      }
    },
    triangulate: function(graphicsData, graphicsGeometry) {
      if (Graphics.nextRoundedRectBehavior) {
        buildCircle.triangulate(graphicsData, graphicsGeometry);
        return;
      }
      var points = graphicsData.points;
      var verts = graphicsGeometry.points;
      var indices2 = graphicsGeometry.indices;
      var vecPos = verts.length / 2;
      var triangles = (0, import_earcut.default)(points, null, 2);
      for (var i = 0, j = triangles.length; i < j; i += 3) {
        indices2.push(triangles[i] + vecPos);
        indices2.push(triangles[i + 1] + vecPos);
        indices2.push(triangles[i + 2] + vecPos);
      }
      for (var i = 0, j = points.length; i < j; i++) {
        verts.push(points[i], points[++i]);
      }
    }
  };
  function square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {
    var ix = x - nx * innerWeight;
    var iy = y - ny * innerWeight;
    var ox = x + nx * outerWeight;
    var oy = y + ny * outerWeight;
    var exx;
    var eyy;
    if (clockwise) {
      exx = ny;
      eyy = -nx;
    } else {
      exx = -ny;
      eyy = nx;
    }
    var eix = ix + exx;
    var eiy = iy + eyy;
    var eox = ox + exx;
    var eoy = oy + eyy;
    verts.push(eix, eiy);
    verts.push(eox, eoy);
    return 2;
  }
  function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
    var cx2p0x = sx - cx;
    var cy2p0y = sy - cy;
    var angle0 = Math.atan2(cx2p0x, cy2p0y);
    var angle1 = Math.atan2(ex - cx, ey - cy);
    if (clockwise && angle0 < angle1) {
      angle0 += Math.PI * 2;
    } else if (!clockwise && angle0 > angle1) {
      angle1 += Math.PI * 2;
    }
    var startAngle = angle0;
    var angleDiff = angle1 - angle0;
    var absAngleDiff = Math.abs(angleDiff);
    var radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
    var segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
    var angleInc = angleDiff / segCount;
    startAngle += angleInc;
    if (clockwise) {
      verts.push(cx, cy);
      verts.push(sx, sy);
      for (var i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
        verts.push(cx, cy);
        verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
      }
      verts.push(cx, cy);
      verts.push(ex, ey);
    } else {
      verts.push(sx, sy);
      verts.push(cx, cy);
      for (var i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
        verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
        verts.push(cx, cy);
      }
      verts.push(ex, ey);
      verts.push(cx, cy);
    }
    return segCount * 2;
  }
  function buildNonNativeLine(graphicsData, graphicsGeometry) {
    var shape = graphicsData.shape;
    var points = graphicsData.points || shape.points.slice();
    var eps = graphicsGeometry.closePointEps;
    if (points.length === 0) {
      return;
    }
    var style = graphicsData.lineStyle;
    var firstPoint = new Point(points[0], points[1]);
    var lastPoint = new Point(points[points.length - 2], points[points.length - 1]);
    var closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
    var closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
    if (closedShape) {
      points = points.slice();
      if (closedPath) {
        points.pop();
        points.pop();
        lastPoint.set(points[points.length - 2], points[points.length - 1]);
      }
      var midPointX = (firstPoint.x + lastPoint.x) * 0.5;
      var midPointY = (lastPoint.y + firstPoint.y) * 0.5;
      points.unshift(midPointX, midPointY);
      points.push(midPointX, midPointY);
    }
    var verts = graphicsGeometry.points;
    var length = points.length / 2;
    var indexCount = points.length;
    var indexStart = verts.length / 2;
    var width = style.width / 2;
    var widthSquared = width * width;
    var miterLimitSquared = style.miterLimit * style.miterLimit;
    var x0 = points[0];
    var y0 = points[1];
    var x1 = points[2];
    var y1 = points[3];
    var x2 = 0;
    var y2 = 0;
    var perpx = -(y0 - y1);
    var perpy = x0 - x1;
    var perp1x = 0;
    var perp1y = 0;
    var dist = Math.sqrt(perpx * perpx + perpy * perpy);
    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;
    var ratio = style.alignment;
    var innerWeight = (1 - ratio) * 2;
    var outerWeight = ratio * 2;
    if (!closedShape) {
      if (style.cap === LINE_CAP.ROUND) {
        indexCount += round(x0 - perpx * (innerWeight - outerWeight) * 0.5, y0 - perpy * (innerWeight - outerWeight) * 0.5, x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight, verts, true) + 2;
      } else if (style.cap === LINE_CAP.SQUARE) {
        indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);
      }
    }
    verts.push(x0 - perpx * innerWeight, y0 - perpy * innerWeight);
    verts.push(x0 + perpx * outerWeight, y0 + perpy * outerWeight);
    for (var i = 1; i < length - 1; ++i) {
      x0 = points[(i - 1) * 2];
      y0 = points[(i - 1) * 2 + 1];
      x1 = points[i * 2];
      y1 = points[i * 2 + 1];
      x2 = points[(i + 1) * 2];
      y2 = points[(i + 1) * 2 + 1];
      perpx = -(y0 - y1);
      perpy = x0 - x1;
      dist = Math.sqrt(perpx * perpx + perpy * perpy);
      perpx /= dist;
      perpy /= dist;
      perpx *= width;
      perpy *= width;
      perp1x = -(y1 - y2);
      perp1y = x1 - x2;
      dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
      perp1x /= dist;
      perp1y /= dist;
      perp1x *= width;
      perp1y *= width;
      var dx0 = x1 - x0;
      var dy0 = y0 - y1;
      var dx1 = x1 - x2;
      var dy1 = y2 - y1;
      var cross = dy0 * dx1 - dy1 * dx0;
      var clockwise = cross < 0;
      if (Math.abs(cross) < 0.1) {
        verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
        verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
        continue;
      }
      var c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0);
      var c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
      var px = (dx0 * c2 - dx1 * c1) / cross;
      var py = (dy1 * c1 - dy0 * c2) / cross;
      var pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
      var imx = x1 + (px - x1) * innerWeight;
      var imy = y1 + (py - y1) * innerWeight;
      var omx = x1 - (px - x1) * outerWeight;
      var omy = y1 - (py - y1) * outerWeight;
      var smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
      var insideWeight = clockwise ? innerWeight : outerWeight;
      var smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
      var insideMiterOk = pdist <= smallerInsideDiagonalSq;
      if (insideMiterOk) {
        if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared) {
          if (clockwise) {
            verts.push(imx, imy);
            verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
            verts.push(imx, imy);
            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
            verts.push(omx, omy);
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
            verts.push(omx, omy);
          }
          indexCount += 2;
        } else if (style.join === LINE_JOIN.ROUND) {
          if (clockwise) {
            verts.push(imx, imy);
            verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
            indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;
            verts.push(imx, imy);
            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
            verts.push(omx, omy);
            indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
            verts.push(omx, omy);
          }
        } else {
          verts.push(imx, imy);
          verts.push(omx, omy);
        }
      } else {
        verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
        verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
        if (style.join === LINE_JOIN.ROUND) {
          if (clockwise) {
            indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;
          } else {
            indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;
          }
        } else if (style.join === LINE_JOIN.MITER && pdist / widthSquared <= miterLimitSquared) {
          if (clockwise) {
            verts.push(omx, omy);
            verts.push(omx, omy);
          } else {
            verts.push(imx, imy);
            verts.push(imx, imy);
          }
          indexCount += 2;
        }
        verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
        verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        indexCount += 2;
      }
    }
    x0 = points[(length - 2) * 2];
    y0 = points[(length - 2) * 2 + 1];
    x1 = points[(length - 1) * 2];
    y1 = points[(length - 1) * 2 + 1];
    perpx = -(y0 - y1);
    perpy = x0 - x1;
    dist = Math.sqrt(perpx * perpx + perpy * perpy);
    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;
    verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
    verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
    if (!closedShape) {
      if (style.cap === LINE_CAP.ROUND) {
        indexCount += round(x1 - perpx * (innerWeight - outerWeight) * 0.5, y1 - perpy * (innerWeight - outerWeight) * 0.5, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight, verts, false) + 2;
      } else if (style.cap === LINE_CAP.SQUARE) {
        indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);
      }
    }
    var indices2 = graphicsGeometry.indices;
    var eps2 = GRAPHICS_CURVES.epsilon * GRAPHICS_CURVES.epsilon;
    for (var i = indexStart; i < indexCount + indexStart - 2; ++i) {
      x0 = verts[i * 2];
      y0 = verts[i * 2 + 1];
      x1 = verts[(i + 1) * 2];
      y1 = verts[(i + 1) * 2 + 1];
      x2 = verts[(i + 2) * 2];
      y2 = verts[(i + 2) * 2 + 1];
      if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
        continue;
      }
      indices2.push(i, i + 1, i + 2);
    }
  }
  function buildNativeLine(graphicsData, graphicsGeometry) {
    var i = 0;
    var shape = graphicsData.shape;
    var points = graphicsData.points || shape.points;
    var closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
    if (points.length === 0) {
      return;
    }
    var verts = graphicsGeometry.points;
    var indices2 = graphicsGeometry.indices;
    var length = points.length / 2;
    var startIndex = verts.length / 2;
    var currentIndex = startIndex;
    verts.push(points[0], points[1]);
    for (i = 1; i < length; i++) {
      verts.push(points[i * 2], points[i * 2 + 1]);
      indices2.push(currentIndex, currentIndex + 1);
      currentIndex++;
    }
    if (closedShape) {
      indices2.push(currentIndex, startIndex);
    }
  }
  function buildLine(graphicsData, graphicsGeometry) {
    if (graphicsData.lineStyle.native) {
      buildNativeLine(graphicsData, graphicsGeometry);
    } else {
      buildNonNativeLine(graphicsData, graphicsGeometry);
    }
  }
  var ArcUtils = (
    /** @class */
    function() {
      function ArcUtils2() {
      }
      ArcUtils2.curveTo = function(x1, y1, x2, y2, radius, points) {
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        var a1 = fromY - y1;
        var b1 = fromX - x1;
        var a2 = y2 - y1;
        var b2 = x2 - x1;
        var mm = Math.abs(a1 * b2 - b1 * a2);
        if (mm < 1e-8 || radius === 0) {
          if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
            points.push(x1, y1);
          }
          return null;
        }
        var dd = a1 * a1 + b1 * b1;
        var cc = a2 * a2 + b2 * b2;
        var tt = a1 * a2 + b1 * b2;
        var k1 = radius * Math.sqrt(dd) / mm;
        var k2 = radius * Math.sqrt(cc) / mm;
        var j1 = k1 * tt / dd;
        var j2 = k2 * tt / cc;
        var cx = k1 * b2 + k2 * b1;
        var cy = k1 * a2 + k2 * a1;
        var px = b1 * (k2 + j1);
        var py = a1 * (k2 + j1);
        var qx = b2 * (k1 + j2);
        var qy = a2 * (k1 + j2);
        var startAngle = Math.atan2(py - cy, px - cx);
        var endAngle = Math.atan2(qy - cy, qx - cx);
        return {
          cx: cx + x1,
          cy: cy + y1,
          radius,
          startAngle,
          endAngle,
          anticlockwise: b1 * a2 > b2 * a1
        };
      };
      ArcUtils2.arc = function(_startX, _startY, cx, cy, radius, startAngle, endAngle, _anticlockwise, points) {
        var sweep = endAngle - startAngle;
        var n = GRAPHICS_CURVES._segmentsCount(Math.abs(sweep) * radius, Math.ceil(Math.abs(sweep) / PI_2) * 40);
        var theta = sweep / (n * 2);
        var theta2 = theta * 2;
        var cTheta = Math.cos(theta);
        var sTheta = Math.sin(theta);
        var segMinus = n - 1;
        var remainder = segMinus % 1 / segMinus;
        for (var i = 0; i <= segMinus; ++i) {
          var real = i + remainder * i;
          var angle = theta + startAngle + theta2 * real;
          var c = Math.cos(angle);
          var s = -Math.sin(angle);
          points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);
        }
      };
      return ArcUtils2;
    }()
  );
  var BezierUtils = (
    /** @class */
    function() {
      function BezierUtils2() {
      }
      BezierUtils2.curveLength = function(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
        var n = 10;
        var result = 0;
        var t = 0;
        var t2 = 0;
        var t3 = 0;
        var nt = 0;
        var nt2 = 0;
        var nt3 = 0;
        var x = 0;
        var y = 0;
        var dx = 0;
        var dy = 0;
        var prevX = fromX;
        var prevY = fromY;
        for (var i = 1; i <= n; ++i) {
          t = i / n;
          t2 = t * t;
          t3 = t2 * t;
          nt = 1 - t;
          nt2 = nt * nt;
          nt3 = nt2 * nt;
          x = nt3 * fromX + 3 * nt2 * t * cpX + 3 * nt * t2 * cpX2 + t3 * toX;
          y = nt3 * fromY + 3 * nt2 * t * cpY + 3 * nt * t2 * cpY2 + t3 * toY;
          dx = prevX - x;
          dy = prevY - y;
          prevX = x;
          prevY = y;
          result += Math.sqrt(dx * dx + dy * dy);
        }
        return result;
      };
      BezierUtils2.curveTo = function(cpX, cpY, cpX2, cpY2, toX, toY, points) {
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        points.length -= 2;
        var n = GRAPHICS_CURVES._segmentsCount(BezierUtils2.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));
        var dt = 0;
        var dt2 = 0;
        var dt3 = 0;
        var t2 = 0;
        var t3 = 0;
        points.push(fromX, fromY);
        for (var i = 1, j = 0; i <= n; ++i) {
          j = i / n;
          dt = 1 - j;
          dt2 = dt * dt;
          dt3 = dt2 * dt;
          t2 = j * j;
          t3 = t2 * j;
          points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
        }
      };
      return BezierUtils2;
    }()
  );
  var QuadraticUtils = (
    /** @class */
    function() {
      function QuadraticUtils2() {
      }
      QuadraticUtils2.curveLength = function(fromX, fromY, cpX, cpY, toX, toY) {
        var ax = fromX - 2 * cpX + toX;
        var ay = fromY - 2 * cpY + toY;
        var bx = 2 * cpX - 2 * fromX;
        var by = 2 * cpY - 2 * fromY;
        var a = 4 * (ax * ax + ay * ay);
        var b = 4 * (ax * bx + ay * by);
        var c = bx * bx + by * by;
        var s = 2 * Math.sqrt(a + b + c);
        var a2 = Math.sqrt(a);
        var a32 = 2 * a * a2;
        var c2 = 2 * Math.sqrt(c);
        var ba = b / a2;
        return (a32 * s + a2 * b * (s - c2) + (4 * c * a - b * b) * Math.log((2 * a2 + ba + s) / (ba + c2))) / (4 * a32);
      };
      QuadraticUtils2.curveTo = function(cpX, cpY, toX, toY, points) {
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        var n = GRAPHICS_CURVES._segmentsCount(QuadraticUtils2.curveLength(fromX, fromY, cpX, cpY, toX, toY));
        var xa = 0;
        var ya = 0;
        for (var i = 1; i <= n; ++i) {
          var j = i / n;
          xa = fromX + (cpX - fromX) * j;
          ya = fromY + (cpY - fromY) * j;
          points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);
        }
      };
      return QuadraticUtils2;
    }()
  );
  var BatchPart = (
    /** @class */
    function() {
      function BatchPart2() {
        this.reset();
      }
      BatchPart2.prototype.begin = function(style, startIndex, attribStart) {
        this.reset();
        this.style = style;
        this.start = startIndex;
        this.attribStart = attribStart;
      };
      BatchPart2.prototype.end = function(endIndex, endAttrib) {
        this.attribSize = endAttrib - this.attribStart;
        this.size = endIndex - this.start;
      };
      BatchPart2.prototype.reset = function() {
        this.style = null;
        this.size = 0;
        this.start = 0;
        this.attribStart = 0;
        this.attribSize = 0;
      };
      return BatchPart2;
    }()
  );
  var _a;
  var FILL_COMMANDS = (_a = {}, _a[SHAPES.POLY] = buildPoly, _a[SHAPES.CIRC] = buildCircle, _a[SHAPES.ELIP] = buildCircle, _a[SHAPES.RECT] = buildRectangle, _a[SHAPES.RREC] = buildRoundedRectangle, _a);
  var BATCH_POOL = [];
  var DRAW_CALL_POOL = [];
  var GraphicsData = (
    /** @class */
    function() {
      function GraphicsData2(shape, fillStyle, lineStyle, matrix) {
        if (fillStyle === void 0) {
          fillStyle = null;
        }
        if (lineStyle === void 0) {
          lineStyle = null;
        }
        if (matrix === void 0) {
          matrix = null;
        }
        this.points = [];
        this.holes = [];
        this.shape = shape;
        this.lineStyle = lineStyle;
        this.fillStyle = fillStyle;
        this.matrix = matrix;
        this.type = shape.type;
      }
      GraphicsData2.prototype.clone = function() {
        return new GraphicsData2(this.shape, this.fillStyle, this.lineStyle, this.matrix);
      };
      GraphicsData2.prototype.destroy = function() {
        this.shape = null;
        this.holes.length = 0;
        this.holes = null;
        this.points.length = 0;
        this.points = null;
        this.lineStyle = null;
        this.fillStyle = null;
      };
      return GraphicsData2;
    }()
  );
  var tmpPoint = new Point();
  var tmpBounds = new Bounds();
  var GraphicsGeometry = (
    /** @class */
    function(_super) {
      __extends7(GraphicsGeometry2, _super);
      function GraphicsGeometry2() {
        var _this = _super.call(this) || this;
        _this.closePointEps = 1e-4;
        _this.boundsPadding = 0;
        _this.uvsFloat32 = null;
        _this.indicesUint16 = null;
        _this.batchable = false;
        _this.points = [];
        _this.colors = [];
        _this.uvs = [];
        _this.indices = [];
        _this.textureIds = [];
        _this.graphicsData = [];
        _this.drawCalls = [];
        _this.batchDirty = -1;
        _this.batches = [];
        _this.dirty = 0;
        _this.cacheDirty = -1;
        _this.clearDirty = 0;
        _this.shapeIndex = 0;
        _this._bounds = new Bounds();
        _this.boundsDirty = -1;
        return _this;
      }
      Object.defineProperty(GraphicsGeometry2.prototype, "bounds", {
        /**
         * Get the current bounds of the graphic geometry.
         * @readonly
         */
        get: function() {
          if (this.boundsDirty !== this.dirty) {
            this.boundsDirty = this.dirty;
            this.calculateBounds();
          }
          return this._bounds;
        },
        enumerable: false,
        configurable: true
      });
      GraphicsGeometry2.prototype.invalidate = function() {
        this.boundsDirty = -1;
        this.dirty++;
        this.batchDirty++;
        this.shapeIndex = 0;
        this.points.length = 0;
        this.colors.length = 0;
        this.uvs.length = 0;
        this.indices.length = 0;
        this.textureIds.length = 0;
        for (var i = 0; i < this.drawCalls.length; i++) {
          this.drawCalls[i].texArray.clear();
          DRAW_CALL_POOL.push(this.drawCalls[i]);
        }
        this.drawCalls.length = 0;
        for (var i = 0; i < this.batches.length; i++) {
          var batchPart = this.batches[i];
          batchPart.reset();
          BATCH_POOL.push(batchPart);
        }
        this.batches.length = 0;
      };
      GraphicsGeometry2.prototype.clear = function() {
        if (this.graphicsData.length > 0) {
          this.invalidate();
          this.clearDirty++;
          this.graphicsData.length = 0;
        }
        return this;
      };
      GraphicsGeometry2.prototype.drawShape = function(shape, fillStyle, lineStyle, matrix) {
        if (fillStyle === void 0) {
          fillStyle = null;
        }
        if (lineStyle === void 0) {
          lineStyle = null;
        }
        if (matrix === void 0) {
          matrix = null;
        }
        var data = new GraphicsData(shape, fillStyle, lineStyle, matrix);
        this.graphicsData.push(data);
        this.dirty++;
        return this;
      };
      GraphicsGeometry2.prototype.drawHole = function(shape, matrix) {
        if (matrix === void 0) {
          matrix = null;
        }
        if (!this.graphicsData.length) {
          return null;
        }
        var data = new GraphicsData(shape, null, null, matrix);
        var lastShape = this.graphicsData[this.graphicsData.length - 1];
        data.lineStyle = lastShape.lineStyle;
        lastShape.holes.push(data);
        this.dirty++;
        return this;
      };
      GraphicsGeometry2.prototype.destroy = function() {
        _super.prototype.destroy.call(this);
        for (var i = 0; i < this.graphicsData.length; ++i) {
          this.graphicsData[i].destroy();
        }
        this.points.length = 0;
        this.points = null;
        this.colors.length = 0;
        this.colors = null;
        this.uvs.length = 0;
        this.uvs = null;
        this.indices.length = 0;
        this.indices = null;
        this.indexBuffer.destroy();
        this.indexBuffer = null;
        this.graphicsData.length = 0;
        this.graphicsData = null;
        this.drawCalls.length = 0;
        this.drawCalls = null;
        this.batches.length = 0;
        this.batches = null;
        this._bounds = null;
      };
      GraphicsGeometry2.prototype.containsPoint = function(point) {
        var graphicsData = this.graphicsData;
        for (var i = 0; i < graphicsData.length; ++i) {
          var data = graphicsData[i];
          if (!data.fillStyle.visible) {
            continue;
          }
          if (data.shape) {
            if (data.matrix) {
              data.matrix.applyInverse(point, tmpPoint);
            } else {
              tmpPoint.copyFrom(point);
            }
            if (data.shape.contains(tmpPoint.x, tmpPoint.y)) {
              var hitHole = false;
              if (data.holes) {
                for (var i_1 = 0; i_1 < data.holes.length; i_1++) {
                  var hole = data.holes[i_1];
                  if (hole.shape.contains(tmpPoint.x, tmpPoint.y)) {
                    hitHole = true;
                    break;
                  }
                }
              }
              if (!hitHole) {
                return true;
              }
            }
          }
        }
        return false;
      };
      GraphicsGeometry2.prototype.updateBatches = function(allow32Indices) {
        if (!this.graphicsData.length) {
          this.batchable = true;
          return;
        }
        if (!this.validateBatching()) {
          return;
        }
        this.cacheDirty = this.dirty;
        var uvs = this.uvs;
        var graphicsData = this.graphicsData;
        var batchPart = null;
        var currentStyle = null;
        if (this.batches.length > 0) {
          batchPart = this.batches[this.batches.length - 1];
          currentStyle = batchPart.style;
        }
        for (var i = this.shapeIndex; i < graphicsData.length; i++) {
          this.shapeIndex++;
          var data = graphicsData[i];
          var fillStyle = data.fillStyle;
          var lineStyle = data.lineStyle;
          var command = FILL_COMMANDS[data.type];
          command.build(data);
          if (data.matrix) {
            this.transformPoints(data.points, data.matrix);
          }
          if (fillStyle.visible || lineStyle.visible) {
            this.processHoles(data.holes);
          }
          for (var j = 0; j < 2; j++) {
            var style = j === 0 ? fillStyle : lineStyle;
            if (!style.visible) {
              continue;
            }
            var nextTexture = style.texture.baseTexture;
            var index_1 = this.indices.length;
            var attribIndex = this.points.length / 2;
            nextTexture.wrapMode = WRAP_MODES.REPEAT;
            if (j === 0) {
              this.processFill(data);
            } else {
              this.processLine(data);
            }
            var size = this.points.length / 2 - attribIndex;
            if (size === 0) {
              continue;
            }
            if (batchPart && !this._compareStyles(currentStyle, style)) {
              batchPart.end(index_1, attribIndex);
              batchPart = null;
            }
            if (!batchPart) {
              batchPart = BATCH_POOL.pop() || new BatchPart();
              batchPart.begin(style, index_1, attribIndex);
              this.batches.push(batchPart);
              currentStyle = style;
            }
            this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);
          }
        }
        var index = this.indices.length;
        var attrib = this.points.length / 2;
        if (batchPart) {
          batchPart.end(index, attrib);
        }
        if (this.batches.length === 0) {
          this.batchable = true;
          return;
        }
        if (this.indicesUint16 && this.indices.length === this.indicesUint16.length) {
          this.indicesUint16.set(this.indices);
        } else {
          var need32 = attrib > 65535 && allow32Indices;
          this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);
        }
        this.batchable = this.isBatchable();
        if (this.batchable) {
          this.packBatches();
        } else {
          this.buildDrawCalls();
        }
      };
      GraphicsGeometry2.prototype._compareStyles = function(styleA, styleB) {
        if (!styleA || !styleB) {
          return false;
        }
        if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {
          return false;
        }
        if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {
          return false;
        }
        if (!!styleA.native !== !!styleB.native) {
          return false;
        }
        return true;
      };
      GraphicsGeometry2.prototype.validateBatching = function() {
        if (this.dirty === this.cacheDirty || !this.graphicsData.length) {
          return false;
        }
        for (var i = 0, l = this.graphicsData.length; i < l; i++) {
          var data = this.graphicsData[i];
          var fill = data.fillStyle;
          var line = data.lineStyle;
          if (fill && !fill.texture.baseTexture.valid) {
            return false;
          }
          if (line && !line.texture.baseTexture.valid) {
            return false;
          }
        }
        return true;
      };
      GraphicsGeometry2.prototype.packBatches = function() {
        this.batchDirty++;
        this.uvsFloat32 = new Float32Array(this.uvs);
        var batches = this.batches;
        for (var i = 0, l = batches.length; i < l; i++) {
          var batch = batches[i];
          for (var j = 0; j < batch.size; j++) {
            var index = batch.start + j;
            this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;
          }
        }
      };
      GraphicsGeometry2.prototype.isBatchable = function() {
        if (this.points.length > 65535 * 2) {
          return false;
        }
        var batches = this.batches;
        for (var i = 0; i < batches.length; i++) {
          if (batches[i].style.native) {
            return false;
          }
        }
        return this.points.length < GraphicsGeometry2.BATCHABLE_SIZE * 2;
      };
      GraphicsGeometry2.prototype.buildDrawCalls = function() {
        var TICK = ++BaseTexture._globalBatch;
        for (var i = 0; i < this.drawCalls.length; i++) {
          this.drawCalls[i].texArray.clear();
          DRAW_CALL_POOL.push(this.drawCalls[i]);
        }
        this.drawCalls.length = 0;
        var colors = this.colors;
        var textureIds = this.textureIds;
        var currentGroup = DRAW_CALL_POOL.pop();
        if (!currentGroup) {
          currentGroup = new BatchDrawCall();
          currentGroup.texArray = new BatchTextureArray();
        }
        currentGroup.texArray.count = 0;
        currentGroup.start = 0;
        currentGroup.size = 0;
        currentGroup.type = DRAW_MODES.TRIANGLES;
        var textureCount = 0;
        var currentTexture = null;
        var textureId = 0;
        var native = false;
        var drawMode = DRAW_MODES.TRIANGLES;
        var index = 0;
        this.drawCalls.push(currentGroup);
        for (var i = 0; i < this.batches.length; i++) {
          var data = this.batches[i];
          var MAX_TEXTURES = 8;
          var style = data.style;
          var nextTexture = style.texture.baseTexture;
          if (native !== !!style.native) {
            native = !!style.native;
            drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES;
            currentTexture = null;
            textureCount = MAX_TEXTURES;
            TICK++;
          }
          if (currentTexture !== nextTexture) {
            currentTexture = nextTexture;
            if (nextTexture._batchEnabled !== TICK) {
              if (textureCount === MAX_TEXTURES) {
                TICK++;
                textureCount = 0;
                if (currentGroup.size > 0) {
                  currentGroup = DRAW_CALL_POOL.pop();
                  if (!currentGroup) {
                    currentGroup = new BatchDrawCall();
                    currentGroup.texArray = new BatchTextureArray();
                  }
                  this.drawCalls.push(currentGroup);
                }
                currentGroup.start = index;
                currentGroup.size = 0;
                currentGroup.texArray.count = 0;
                currentGroup.type = drawMode;
              }
              nextTexture.touched = 1;
              nextTexture._batchEnabled = TICK;
              nextTexture._batchLocation = textureCount;
              nextTexture.wrapMode = WRAP_MODES.REPEAT;
              currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;
              textureCount++;
            }
          }
          currentGroup.size += data.size;
          index += data.size;
          textureId = nextTexture._batchLocation;
          this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);
          this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);
        }
        BaseTexture._globalBatch = TICK;
        this.packAttributes();
      };
      GraphicsGeometry2.prototype.packAttributes = function() {
        var verts = this.points;
        var uvs = this.uvs;
        var colors = this.colors;
        var textureIds = this.textureIds;
        var glPoints = new ArrayBuffer(verts.length * 3 * 4);
        var f32 = new Float32Array(glPoints);
        var u32 = new Uint32Array(glPoints);
        var p = 0;
        for (var i = 0; i < verts.length / 2; i++) {
          f32[p++] = verts[i * 2];
          f32[p++] = verts[i * 2 + 1];
          f32[p++] = uvs[i * 2];
          f32[p++] = uvs[i * 2 + 1];
          u32[p++] = colors[i];
          f32[p++] = textureIds[i];
        }
        this._buffer.update(glPoints);
        this._indexBuffer.update(this.indicesUint16);
      };
      GraphicsGeometry2.prototype.processFill = function(data) {
        if (data.holes.length) {
          buildPoly.triangulate(data, this);
        } else {
          var command = FILL_COMMANDS[data.type];
          command.triangulate(data, this);
        }
      };
      GraphicsGeometry2.prototype.processLine = function(data) {
        buildLine(data, this);
        for (var i = 0; i < data.holes.length; i++) {
          buildLine(data.holes[i], this);
        }
      };
      GraphicsGeometry2.prototype.processHoles = function(holes) {
        for (var i = 0; i < holes.length; i++) {
          var hole = holes[i];
          var command = FILL_COMMANDS[hole.type];
          command.build(hole);
          if (hole.matrix) {
            this.transformPoints(hole.points, hole.matrix);
          }
        }
      };
      GraphicsGeometry2.prototype.calculateBounds = function() {
        var bounds = this._bounds;
        var sequenceBounds = tmpBounds;
        var curMatrix = Matrix.IDENTITY;
        this._bounds.clear();
        sequenceBounds.clear();
        for (var i = 0; i < this.graphicsData.length; i++) {
          var data = this.graphicsData[i];
          var shape = data.shape;
          var type = data.type;
          var lineStyle = data.lineStyle;
          var nextMatrix = data.matrix || Matrix.IDENTITY;
          var lineWidth = 0;
          if (lineStyle && lineStyle.visible) {
            lineWidth = lineStyle.width;
            if (type !== SHAPES.POLY || data.fillStyle.visible) {
              lineWidth *= Math.max(0, lineStyle.alignment);
            } else {
              lineWidth *= Math.max(lineStyle.alignment, 1 - lineStyle.alignment);
            }
          }
          if (curMatrix !== nextMatrix) {
            if (!sequenceBounds.isEmpty()) {
              bounds.addBoundsMatrix(sequenceBounds, curMatrix);
              sequenceBounds.clear();
            }
            curMatrix = nextMatrix;
          }
          if (type === SHAPES.RECT || type === SHAPES.RREC) {
            var rect = shape;
            sequenceBounds.addFramePad(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, lineWidth, lineWidth);
          } else if (type === SHAPES.CIRC) {
            var circle = shape;
            sequenceBounds.addFramePad(circle.x, circle.y, circle.x, circle.y, circle.radius + lineWidth, circle.radius + lineWidth);
          } else if (type === SHAPES.ELIP) {
            var ellipse = shape;
            sequenceBounds.addFramePad(ellipse.x, ellipse.y, ellipse.x, ellipse.y, ellipse.width + lineWidth, ellipse.height + lineWidth);
          } else {
            var poly = shape;
            bounds.addVerticesMatrix(curMatrix, poly.points, 0, poly.points.length, lineWidth, lineWidth);
          }
        }
        if (!sequenceBounds.isEmpty()) {
          bounds.addBoundsMatrix(sequenceBounds, curMatrix);
        }
        bounds.pad(this.boundsPadding, this.boundsPadding);
      };
      GraphicsGeometry2.prototype.transformPoints = function(points, matrix) {
        for (var i = 0; i < points.length / 2; i++) {
          var x = points[i * 2];
          var y = points[i * 2 + 1];
          points[i * 2] = matrix.a * x + matrix.c * y + matrix.tx;
          points[i * 2 + 1] = matrix.b * x + matrix.d * y + matrix.ty;
        }
      };
      GraphicsGeometry2.prototype.addColors = function(colors, color, alpha, size, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        var rgb = (color >> 16) + (color & 65280) + ((color & 255) << 16);
        var rgba = premultiplyTint(rgb, alpha);
        colors.length = Math.max(colors.length, offset + size);
        for (var i = 0; i < size; i++) {
          colors[offset + i] = rgba;
        }
      };
      GraphicsGeometry2.prototype.addTextureIds = function(textureIds, id, size, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        textureIds.length = Math.max(textureIds.length, offset + size);
        for (var i = 0; i < size; i++) {
          textureIds[offset + i] = id;
        }
      };
      GraphicsGeometry2.prototype.addUvs = function(verts, uvs, texture, start, size, matrix) {
        if (matrix === void 0) {
          matrix = null;
        }
        var index = 0;
        var uvsStart = uvs.length;
        var frame = texture.frame;
        while (index < size) {
          var x = verts[(start + index) * 2];
          var y = verts[(start + index) * 2 + 1];
          if (matrix) {
            var nx = matrix.a * x + matrix.c * y + matrix.tx;
            y = matrix.b * x + matrix.d * y + matrix.ty;
            x = nx;
          }
          index++;
          uvs.push(x / frame.width, y / frame.height);
        }
        var baseTexture = texture.baseTexture;
        if (frame.width < baseTexture.width || frame.height < baseTexture.height) {
          this.adjustUvs(uvs, texture, uvsStart, size);
        }
      };
      GraphicsGeometry2.prototype.adjustUvs = function(uvs, texture, start, size) {
        var baseTexture = texture.baseTexture;
        var eps = 1e-6;
        var finish = start + size * 2;
        var frame = texture.frame;
        var scaleX = frame.width / baseTexture.width;
        var scaleY = frame.height / baseTexture.height;
        var offsetX = frame.x / frame.width;
        var offsetY = frame.y / frame.height;
        var minX = Math.floor(uvs[start] + eps);
        var minY = Math.floor(uvs[start + 1] + eps);
        for (var i = start + 2; i < finish; i += 2) {
          minX = Math.min(minX, Math.floor(uvs[i] + eps));
          minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));
        }
        offsetX -= minX;
        offsetY -= minY;
        for (var i = start; i < finish; i += 2) {
          uvs[i] = (uvs[i] + offsetX) * scaleX;
          uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;
        }
      };
      GraphicsGeometry2.BATCHABLE_SIZE = 100;
      return GraphicsGeometry2;
    }(BatchGeometry)
  );
  var LineStyle = (
    /** @class */
    function(_super) {
      __extends7(LineStyle2, _super);
      function LineStyle2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.width = 0;
        _this.alignment = 0.5;
        _this.native = false;
        _this.cap = LINE_CAP.BUTT;
        _this.join = LINE_JOIN.MITER;
        _this.miterLimit = 10;
        return _this;
      }
      LineStyle2.prototype.clone = function() {
        var obj = new LineStyle2();
        obj.color = this.color;
        obj.alpha = this.alpha;
        obj.texture = this.texture;
        obj.matrix = this.matrix;
        obj.visible = this.visible;
        obj.width = this.width;
        obj.alignment = this.alignment;
        obj.native = this.native;
        obj.cap = this.cap;
        obj.join = this.join;
        obj.miterLimit = this.miterLimit;
        return obj;
      };
      LineStyle2.prototype.reset = function() {
        _super.prototype.reset.call(this);
        this.color = 0;
        this.alignment = 0.5;
        this.width = 0;
        this.native = false;
      };
      return LineStyle2;
    }(FillStyle)
  );
  var temp = new Float32Array(3);
  var DEFAULT_SHADERS = {};
  var Graphics = (
    /** @class */
    function(_super) {
      __extends7(Graphics2, _super);
      function Graphics2(geometry) {
        if (geometry === void 0) {
          geometry = null;
        }
        var _this = _super.call(this) || this;
        _this.shader = null;
        _this.pluginName = "batch";
        _this.currentPath = null;
        _this.batches = [];
        _this.batchTint = -1;
        _this.batchDirty = -1;
        _this.vertexData = null;
        _this._fillStyle = new FillStyle();
        _this._lineStyle = new LineStyle();
        _this._matrix = null;
        _this._holeMode = false;
        _this.state = State.for2d();
        _this._geometry = geometry || new GraphicsGeometry();
        _this._geometry.refCount++;
        _this._transformID = -1;
        _this.tint = 16777215;
        _this.blendMode = BLEND_MODES.NORMAL;
        return _this;
      }
      Object.defineProperty(Graphics2.prototype, "geometry", {
        /**
         * Includes vertex positions, face indices, normals, colors, UVs, and
         * custom attributes within buffers, reducing the cost of passing all
         * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.
         * @readonly
         */
        get: function() {
          return this._geometry;
        },
        enumerable: false,
        configurable: true
      });
      Graphics2.prototype.clone = function() {
        this.finishPoly();
        return new Graphics2(this._geometry);
      };
      Object.defineProperty(Graphics2.prototype, "blendMode", {
        get: function() {
          return this.state.blendMode;
        },
        /**
         * The blend mode to be applied to the graphic shape. Apply a value of
         * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.  Note that, since each
         * primitive in the GraphicsGeometry list is rendered sequentially, modes
         * such as `PIXI.BLEND_MODES.ADD` and `PIXI.BLEND_MODES.MULTIPLY` will
         * be applied per-primitive.
         * @default PIXI.BLEND_MODES.NORMAL
         */
        set: function(value) {
          this.state.blendMode = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Graphics2.prototype, "tint", {
        /**
         * The tint applied to each graphic shape. This is a hex value. A value of
         * 0xFFFFFF will remove any tint effect.
         * @default 0xFFFFFF
         */
        get: function() {
          return this._tint;
        },
        set: function(value) {
          this._tint = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Graphics2.prototype, "fill", {
        /**
         * The current fill style.
         * @readonly
         */
        get: function() {
          return this._fillStyle;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Graphics2.prototype, "line", {
        /**
         * The current line style.
         * @readonly
         */
        get: function() {
          return this._lineStyle;
        },
        enumerable: false,
        configurable: true
      });
      Graphics2.prototype.lineStyle = function(options, color, alpha, alignment, native) {
        if (options === void 0) {
          options = null;
        }
        if (color === void 0) {
          color = 0;
        }
        if (alpha === void 0) {
          alpha = 1;
        }
        if (alignment === void 0) {
          alignment = 0.5;
        }
        if (native === void 0) {
          native = false;
        }
        if (typeof options === "number") {
          options = { width: options, color, alpha, alignment, native };
        }
        return this.lineTextureStyle(options);
      };
      Graphics2.prototype.lineTextureStyle = function(options) {
        options = Object.assign({
          width: 0,
          texture: Texture.WHITE,
          color: options && options.texture ? 16777215 : 0,
          alpha: 1,
          matrix: null,
          alignment: 0.5,
          native: false,
          cap: LINE_CAP.BUTT,
          join: LINE_JOIN.MITER,
          miterLimit: 10
        }, options);
        if (this.currentPath) {
          this.startPoly();
        }
        var visible = options.width > 0 && options.alpha > 0;
        if (!visible) {
          this._lineStyle.reset();
        } else {
          if (options.matrix) {
            options.matrix = options.matrix.clone();
            options.matrix.invert();
          }
          Object.assign(this._lineStyle, { visible }, options);
        }
        return this;
      };
      Graphics2.prototype.startPoly = function() {
        if (this.currentPath) {
          var points = this.currentPath.points;
          var len = this.currentPath.points.length;
          if (len > 2) {
            this.drawShape(this.currentPath);
            this.currentPath = new Polygon();
            this.currentPath.closeStroke = false;
            this.currentPath.points.push(points[len - 2], points[len - 1]);
          }
        } else {
          this.currentPath = new Polygon();
          this.currentPath.closeStroke = false;
        }
      };
      Graphics2.prototype.finishPoly = function() {
        if (this.currentPath) {
          if (this.currentPath.points.length > 2) {
            this.drawShape(this.currentPath);
            this.currentPath = null;
          } else {
            this.currentPath.points.length = 0;
          }
        }
      };
      Graphics2.prototype.moveTo = function(x, y) {
        this.startPoly();
        this.currentPath.points[0] = x;
        this.currentPath.points[1] = y;
        return this;
      };
      Graphics2.prototype.lineTo = function(x, y) {
        if (!this.currentPath) {
          this.moveTo(0, 0);
        }
        var points = this.currentPath.points;
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        if (fromX !== x || fromY !== y) {
          points.push(x, y);
        }
        return this;
      };
      Graphics2.prototype._initCurve = function(x, y) {
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        if (this.currentPath) {
          if (this.currentPath.points.length === 0) {
            this.currentPath.points = [x, y];
          }
        } else {
          this.moveTo(x, y);
        }
      };
      Graphics2.prototype.quadraticCurveTo = function(cpX, cpY, toX, toY) {
        this._initCurve();
        var points = this.currentPath.points;
        if (points.length === 0) {
          this.moveTo(0, 0);
        }
        QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);
        return this;
      };
      Graphics2.prototype.bezierCurveTo = function(cpX, cpY, cpX2, cpY2, toX, toY) {
        this._initCurve();
        BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);
        return this;
      };
      Graphics2.prototype.arcTo = function(x1, y1, x2, y2, radius) {
        this._initCurve(x1, y1);
        var points = this.currentPath.points;
        var result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);
        if (result) {
          var cx = result.cx, cy = result.cy, radius_1 = result.radius, startAngle = result.startAngle, endAngle = result.endAngle, anticlockwise = result.anticlockwise;
          this.arc(cx, cy, radius_1, startAngle, endAngle, anticlockwise);
        }
        return this;
      };
      Graphics2.prototype.arc = function(cx, cy, radius, startAngle, endAngle, anticlockwise) {
        if (anticlockwise === void 0) {
          anticlockwise = false;
        }
        if (startAngle === endAngle) {
          return this;
        }
        if (!anticlockwise && endAngle <= startAngle) {
          endAngle += PI_2;
        } else if (anticlockwise && startAngle <= endAngle) {
          startAngle += PI_2;
        }
        var sweep = endAngle - startAngle;
        if (sweep === 0) {
          return this;
        }
        var startX = cx + Math.cos(startAngle) * radius;
        var startY = cy + Math.sin(startAngle) * radius;
        var eps = this._geometry.closePointEps;
        var points = this.currentPath ? this.currentPath.points : null;
        if (points) {
          var xDiff = Math.abs(points[points.length - 2] - startX);
          var yDiff = Math.abs(points[points.length - 1] - startY);
          if (xDiff < eps && yDiff < eps)
            ;
          else {
            points.push(startX, startY);
          }
        } else {
          this.moveTo(startX, startY);
          points = this.currentPath.points;
        }
        ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);
        return this;
      };
      Graphics2.prototype.beginFill = function(color, alpha) {
        if (color === void 0) {
          color = 0;
        }
        if (alpha === void 0) {
          alpha = 1;
        }
        return this.beginTextureFill({ texture: Texture.WHITE, color, alpha });
      };
      Graphics2.prototype.beginTextureFill = function(options) {
        options = Object.assign({
          texture: Texture.WHITE,
          color: 16777215,
          alpha: 1,
          matrix: null
        }, options);
        if (this.currentPath) {
          this.startPoly();
        }
        var visible = options.alpha > 0;
        if (!visible) {
          this._fillStyle.reset();
        } else {
          if (options.matrix) {
            options.matrix = options.matrix.clone();
            options.matrix.invert();
          }
          Object.assign(this._fillStyle, { visible }, options);
        }
        return this;
      };
      Graphics2.prototype.endFill = function() {
        this.finishPoly();
        this._fillStyle.reset();
        return this;
      };
      Graphics2.prototype.drawRect = function(x, y, width, height) {
        return this.drawShape(new Rectangle(x, y, width, height));
      };
      Graphics2.prototype.drawRoundedRect = function(x, y, width, height, radius) {
        return this.drawShape(new RoundedRectangle(x, y, width, height, radius));
      };
      Graphics2.prototype.drawCircle = function(x, y, radius) {
        return this.drawShape(new Circle(x, y, radius));
      };
      Graphics2.prototype.drawEllipse = function(x, y, width, height) {
        return this.drawShape(new Ellipse(x, y, width, height));
      };
      Graphics2.prototype.drawPolygon = function() {
        var arguments$1 = arguments;
        var path = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          path[_i] = arguments$1[_i];
        }
        var points;
        var closeStroke = true;
        var poly = path[0];
        if (poly.points) {
          closeStroke = poly.closeStroke;
          points = poly.points;
        } else if (Array.isArray(path[0])) {
          points = path[0];
        } else {
          points = path;
        }
        var shape = new Polygon(points);
        shape.closeStroke = closeStroke;
        this.drawShape(shape);
        return this;
      };
      Graphics2.prototype.drawShape = function(shape) {
        if (!this._holeMode) {
          this._geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);
        } else {
          this._geometry.drawHole(shape, this._matrix);
        }
        return this;
      };
      Graphics2.prototype.clear = function() {
        this._geometry.clear();
        this._lineStyle.reset();
        this._fillStyle.reset();
        this._boundsID++;
        this._matrix = null;
        this._holeMode = false;
        this.currentPath = null;
        return this;
      };
      Graphics2.prototype.isFastRect = function() {
        var data = this._geometry.graphicsData;
        return data.length === 1 && data[0].shape.type === SHAPES.RECT && !data[0].matrix && !data[0].holes.length && !(data[0].lineStyle.visible && data[0].lineStyle.width);
      };
      Graphics2.prototype._render = function(renderer) {
        this.finishPoly();
        var geometry = this._geometry;
        var hasuint32 = renderer.context.supports.uint32Indices;
        geometry.updateBatches(hasuint32);
        if (geometry.batchable) {
          if (this.batchDirty !== geometry.batchDirty) {
            this._populateBatches();
          }
          this._renderBatched(renderer);
        } else {
          renderer.batch.flush();
          this._renderDirect(renderer);
        }
      };
      Graphics2.prototype._populateBatches = function() {
        var geometry = this._geometry;
        var blendMode = this.blendMode;
        var len = geometry.batches.length;
        this.batchTint = -1;
        this._transformID = -1;
        this.batchDirty = geometry.batchDirty;
        this.batches.length = len;
        this.vertexData = new Float32Array(geometry.points);
        for (var i = 0; i < len; i++) {
          var gI = geometry.batches[i];
          var color = gI.style.color;
          var vertexData = new Float32Array(this.vertexData.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
          var uvs = new Float32Array(geometry.uvsFloat32.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
          var indices2 = new Uint16Array(geometry.indicesUint16.buffer, gI.start * 2, gI.size);
          var batch = {
            vertexData,
            blendMode,
            indices: indices2,
            uvs,
            _batchRGB: hex2rgb(color),
            _tintRGB: color,
            _texture: gI.style.texture,
            alpha: gI.style.alpha,
            worldAlpha: 1
          };
          this.batches[i] = batch;
        }
      };
      Graphics2.prototype._renderBatched = function(renderer) {
        if (!this.batches.length) {
          return;
        }
        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
        this.calculateVertices();
        this.calculateTints();
        for (var i = 0, l = this.batches.length; i < l; i++) {
          var batch = this.batches[i];
          batch.worldAlpha = this.worldAlpha * batch.alpha;
          renderer.plugins[this.pluginName].render(batch);
        }
      };
      Graphics2.prototype._renderDirect = function(renderer) {
        var shader = this._resolveDirectShader(renderer);
        var geometry = this._geometry;
        var tint = this.tint;
        var worldAlpha = this.worldAlpha;
        var uniforms = shader.uniforms;
        var drawCalls = geometry.drawCalls;
        uniforms.translationMatrix = this.transform.worldTransform;
        uniforms.tint[0] = (tint >> 16 & 255) / 255 * worldAlpha;
        uniforms.tint[1] = (tint >> 8 & 255) / 255 * worldAlpha;
        uniforms.tint[2] = (tint & 255) / 255 * worldAlpha;
        uniforms.tint[3] = worldAlpha;
        renderer.shader.bind(shader);
        renderer.geometry.bind(geometry, shader);
        renderer.state.set(this.state);
        for (var i = 0, l = drawCalls.length; i < l; i++) {
          this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);
        }
      };
      Graphics2.prototype._renderDrawCallDirect = function(renderer, drawCall) {
        var texArray = drawCall.texArray, type = drawCall.type, size = drawCall.size, start = drawCall.start;
        var groupTextureCount = texArray.count;
        for (var j = 0; j < groupTextureCount; j++) {
          renderer.texture.bind(texArray.elements[j], j);
        }
        renderer.geometry.draw(type, size, start);
      };
      Graphics2.prototype._resolveDirectShader = function(renderer) {
        var shader = this.shader;
        var pluginName = this.pluginName;
        if (!shader) {
          if (!DEFAULT_SHADERS[pluginName]) {
            var MAX_TEXTURES = renderer.plugins[pluginName].MAX_TEXTURES;
            var sampleValues = new Int32Array(MAX_TEXTURES);
            for (var i = 0; i < MAX_TEXTURES; i++) {
              sampleValues[i] = i;
            }
            var uniforms = {
              tint: new Float32Array([1, 1, 1, 1]),
              translationMatrix: new Matrix(),
              default: UniformGroup.from({ uSamplers: sampleValues }, true)
            };
            var program = renderer.plugins[pluginName]._shader.program;
            DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);
          }
          shader = DEFAULT_SHADERS[pluginName];
        }
        return shader;
      };
      Graphics2.prototype._calculateBounds = function() {
        this.finishPoly();
        var geometry = this._geometry;
        if (!geometry.graphicsData.length) {
          return;
        }
        var _a2 = geometry.bounds, minX = _a2.minX, minY = _a2.minY, maxX = _a2.maxX, maxY = _a2.maxY;
        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
      };
      Graphics2.prototype.containsPoint = function(point) {
        this.worldTransform.applyInverse(point, Graphics2._TEMP_POINT);
        return this._geometry.containsPoint(Graphics2._TEMP_POINT);
      };
      Graphics2.prototype.calculateTints = function() {
        if (this.batchTint !== this.tint) {
          this.batchTint = this.tint;
          var tintRGB = hex2rgb(this.tint, temp);
          for (var i = 0; i < this.batches.length; i++) {
            var batch = this.batches[i];
            var batchTint = batch._batchRGB;
            var r = tintRGB[0] * batchTint[0] * 255;
            var g = tintRGB[1] * batchTint[1] * 255;
            var b = tintRGB[2] * batchTint[2] * 255;
            var color = (r << 16) + (g << 8) + (b | 0);
            batch._tintRGB = (color >> 16) + (color & 65280) + ((color & 255) << 16);
          }
        }
      };
      Graphics2.prototype.calculateVertices = function() {
        var wtID = this.transform._worldID;
        if (this._transformID === wtID) {
          return;
        }
        this._transformID = wtID;
        var wt = this.transform.worldTransform;
        var a = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var data = this._geometry.points;
        var vertexData = this.vertexData;
        var count = 0;
        for (var i = 0; i < data.length; i += 2) {
          var x = data[i];
          var y = data[i + 1];
          vertexData[count++] = a * x + c * y + tx;
          vertexData[count++] = d * y + b * x + ty;
        }
      };
      Graphics2.prototype.closePath = function() {
        var currentPath = this.currentPath;
        if (currentPath) {
          currentPath.closeStroke = true;
          this.finishPoly();
        }
        return this;
      };
      Graphics2.prototype.setMatrix = function(matrix) {
        this._matrix = matrix;
        return this;
      };
      Graphics2.prototype.beginHole = function() {
        this.finishPoly();
        this._holeMode = true;
        return this;
      };
      Graphics2.prototype.endHole = function() {
        this.finishPoly();
        this._holeMode = false;
        return this;
      };
      Graphics2.prototype.destroy = function(options) {
        this._geometry.refCount--;
        if (this._geometry.refCount === 0) {
          this._geometry.dispose();
        }
        this._matrix = null;
        this.currentPath = null;
        this._lineStyle.destroy();
        this._lineStyle = null;
        this._fillStyle.destroy();
        this._fillStyle = null;
        this._geometry = null;
        this.shader = null;
        this.vertexData = null;
        this.batches.length = 0;
        this.batches = null;
        _super.prototype.destroy.call(this, options);
      };
      Graphics2.nextRoundedRectBehavior = false;
      Graphics2._TEMP_POINT = new Point();
      return Graphics2;
    }(Container)
  );
  var graphicsUtils = {
    buildPoly,
    buildCircle,
    buildRectangle,
    buildRoundedRectangle,
    buildLine,
    ArcUtils,
    BezierUtils,
    QuadraticUtils,
    BatchPart,
    FILL_COMMANDS,
    BATCH_POOL,
    DRAW_CALL_POOL
  };

  // node_modules/@pixi/mesh-extras/dist/esm/mesh-extras.js
  var extendStatics8 = function(d, b) {
    extendStatics8 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) {
        if (b2.hasOwnProperty(p)) {
          d2[p] = b2[p];
        }
      }
    };
    return extendStatics8(d, b);
  };
  function __extends8(d, b) {
    extendStatics8(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var PlaneGeometry = (
    /** @class */
    function(_super) {
      __extends8(PlaneGeometry2, _super);
      function PlaneGeometry2(width, height, segWidth, segHeight) {
        if (width === void 0) {
          width = 100;
        }
        if (height === void 0) {
          height = 100;
        }
        if (segWidth === void 0) {
          segWidth = 10;
        }
        if (segHeight === void 0) {
          segHeight = 10;
        }
        var _this = _super.call(this) || this;
        _this.segWidth = segWidth;
        _this.segHeight = segHeight;
        _this.width = width;
        _this.height = height;
        _this.build();
        return _this;
      }
      PlaneGeometry2.prototype.build = function() {
        var total = this.segWidth * this.segHeight;
        var verts = [];
        var uvs = [];
        var indices2 = [];
        var segmentsX = this.segWidth - 1;
        var segmentsY = this.segHeight - 1;
        var sizeX = this.width / segmentsX;
        var sizeY = this.height / segmentsY;
        for (var i = 0; i < total; i++) {
          var x = i % this.segWidth;
          var y = i / this.segWidth | 0;
          verts.push(x * sizeX, y * sizeY);
          uvs.push(x / segmentsX, y / segmentsY);
        }
        var totalSub = segmentsX * segmentsY;
        for (var i = 0; i < totalSub; i++) {
          var xpos = i % segmentsX;
          var ypos = i / segmentsX | 0;
          var value = ypos * this.segWidth + xpos;
          var value2 = ypos * this.segWidth + xpos + 1;
          var value3 = (ypos + 1) * this.segWidth + xpos;
          var value4 = (ypos + 1) * this.segWidth + xpos + 1;
          indices2.push(value, value2, value3, value2, value4, value3);
        }
        this.buffers[0].data = new Float32Array(verts);
        this.buffers[1].data = new Float32Array(uvs);
        this.indexBuffer.data = new Uint16Array(indices2);
        this.buffers[0].update();
        this.buffers[1].update();
        this.indexBuffer.update();
      };
      return PlaneGeometry2;
    }(MeshGeometry)
  );
  var RopeGeometry = (
    /** @class */
    function(_super) {
      __extends8(RopeGeometry2, _super);
      function RopeGeometry2(width, points, textureScale) {
        if (width === void 0) {
          width = 200;
        }
        if (textureScale === void 0) {
          textureScale = 0;
        }
        var _this = _super.call(this, new Float32Array(points.length * 4), new Float32Array(points.length * 4), new Uint16Array((points.length - 1) * 6)) || this;
        _this.points = points;
        _this._width = width;
        _this.textureScale = textureScale;
        _this.build();
        return _this;
      }
      Object.defineProperty(RopeGeometry2.prototype, "width", {
        /**
         * The width (i.e., thickness) of the rope.
         * @readonly
         */
        get: function() {
          return this._width;
        },
        enumerable: false,
        configurable: true
      });
      RopeGeometry2.prototype.build = function() {
        var points = this.points;
        if (!points) {
          return;
        }
        var vertexBuffer = this.getBuffer("aVertexPosition");
        var uvBuffer = this.getBuffer("aTextureCoord");
        var indexBuffer = this.getIndex();
        if (points.length < 1) {
          return;
        }
        if (vertexBuffer.data.length / 4 !== points.length) {
          vertexBuffer.data = new Float32Array(points.length * 4);
          uvBuffer.data = new Float32Array(points.length * 4);
          indexBuffer.data = new Uint16Array((points.length - 1) * 6);
        }
        var uvs = uvBuffer.data;
        var indices2 = indexBuffer.data;
        uvs[0] = 0;
        uvs[1] = 0;
        uvs[2] = 0;
        uvs[3] = 1;
        var amount = 0;
        var prev = points[0];
        var textureWidth = this._width * this.textureScale;
        var total = points.length;
        for (var i = 0; i < total; i++) {
          var index = i * 4;
          if (this.textureScale > 0) {
            var dx = prev.x - points[i].x;
            var dy = prev.y - points[i].y;
            var distance = Math.sqrt(dx * dx + dy * dy);
            prev = points[i];
            amount += distance / textureWidth;
          } else {
            amount = i / (total - 1);
          }
          uvs[index] = amount;
          uvs[index + 1] = 0;
          uvs[index + 2] = amount;
          uvs[index + 3] = 1;
        }
        var indexCount = 0;
        for (var i = 0; i < total - 1; i++) {
          var index = i * 2;
          indices2[indexCount++] = index;
          indices2[indexCount++] = index + 1;
          indices2[indexCount++] = index + 2;
          indices2[indexCount++] = index + 2;
          indices2[indexCount++] = index + 1;
          indices2[indexCount++] = index + 3;
        }
        uvBuffer.update();
        indexBuffer.update();
        this.updateVertices();
      };
      RopeGeometry2.prototype.updateVertices = function() {
        var points = this.points;
        if (points.length < 1) {
          return;
        }
        var lastPoint = points[0];
        var nextPoint;
        var perpX = 0;
        var perpY = 0;
        var vertices = this.buffers[0].data;
        var total = points.length;
        for (var i = 0; i < total; i++) {
          var point = points[i];
          var index = i * 4;
          if (i < points.length - 1) {
            nextPoint = points[i + 1];
          } else {
            nextPoint = point;
          }
          perpY = -(nextPoint.x - lastPoint.x);
          perpX = nextPoint.y - lastPoint.y;
          var perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
          var num = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
          perpX /= perpLength;
          perpY /= perpLength;
          perpX *= num;
          perpY *= num;
          vertices[index] = point.x + perpX;
          vertices[index + 1] = point.y + perpY;
          vertices[index + 2] = point.x - perpX;
          vertices[index + 3] = point.y - perpY;
          lastPoint = point;
        }
        this.buffers[0].update();
      };
      RopeGeometry2.prototype.update = function() {
        if (this.textureScale > 0) {
          this.build();
        } else {
          this.updateVertices();
        }
      };
      return RopeGeometry2;
    }(MeshGeometry)
  );
  var SimpleRope = (
    /** @class */
    function(_super) {
      __extends8(SimpleRope2, _super);
      function SimpleRope2(texture, points, textureScale) {
        if (textureScale === void 0) {
          textureScale = 0;
        }
        var _this = this;
        var ropeGeometry = new RopeGeometry(texture.height, points, textureScale);
        var meshMaterial = new MeshMaterial(texture);
        if (textureScale > 0) {
          texture.baseTexture.wrapMode = WRAP_MODES.REPEAT;
        }
        _this = _super.call(this, ropeGeometry, meshMaterial) || this;
        _this.autoUpdate = true;
        return _this;
      }
      SimpleRope2.prototype._render = function(renderer) {
        var geometry = this.geometry;
        if (this.autoUpdate || geometry._width !== this.shader.texture.height) {
          geometry._width = this.shader.texture.height;
          geometry.update();
        }
        _super.prototype._render.call(this, renderer);
      };
      return SimpleRope2;
    }(Mesh)
  );
  var SimplePlane = (
    /** @class */
    function(_super) {
      __extends8(SimplePlane2, _super);
      function SimplePlane2(texture, verticesX, verticesY) {
        var _this = this;
        var planeGeometry = new PlaneGeometry(texture.width, texture.height, verticesX, verticesY);
        var meshMaterial = new MeshMaterial(Texture.WHITE);
        _this = _super.call(this, planeGeometry, meshMaterial) || this;
        _this.texture = texture;
        _this.autoResize = true;
        return _this;
      }
      SimplePlane2.prototype.textureUpdated = function() {
        this._textureID = this.shader.texture._updateID;
        var geometry = this.geometry;
        var _a2 = this.shader.texture, width = _a2.width, height = _a2.height;
        if (this.autoResize && (geometry.width !== width || geometry.height !== height)) {
          geometry.width = this.shader.texture.width;
          geometry.height = this.shader.texture.height;
          geometry.build();
        }
      };
      Object.defineProperty(SimplePlane2.prototype, "texture", {
        get: function() {
          return this.shader.texture;
        },
        set: function(value) {
          if (this.shader.texture === value) {
            return;
          }
          this.shader.texture = value;
          this._textureID = -1;
          if (value.baseTexture.valid) {
            this.textureUpdated();
          } else {
            value.once("update", this.textureUpdated, this);
          }
        },
        enumerable: false,
        configurable: true
      });
      SimplePlane2.prototype._render = function(renderer) {
        if (this._textureID !== this.shader.texture._updateID) {
          this.textureUpdated();
        }
        _super.prototype._render.call(this, renderer);
      };
      SimplePlane2.prototype.destroy = function(options) {
        this.shader.texture.off("update", this.textureUpdated, this);
        _super.prototype.destroy.call(this, options);
      };
      return SimplePlane2;
    }(Mesh)
  );
  var SimpleMesh = (
    /** @class */
    function(_super) {
      __extends8(SimpleMesh2, _super);
      function SimpleMesh2(texture, vertices, uvs, indices2, drawMode) {
        if (texture === void 0) {
          texture = Texture.EMPTY;
        }
        var _this = this;
        var geometry = new MeshGeometry(vertices, uvs, indices2);
        geometry.getBuffer("aVertexPosition").static = false;
        var meshMaterial = new MeshMaterial(texture);
        _this = _super.call(this, geometry, meshMaterial, null, drawMode) || this;
        _this.autoUpdate = true;
        return _this;
      }
      Object.defineProperty(SimpleMesh2.prototype, "vertices", {
        /**
         * Collection of vertices data.
         * @type {Float32Array}
         */
        get: function() {
          return this.geometry.getBuffer("aVertexPosition").data;
        },
        set: function(value) {
          this.geometry.getBuffer("aVertexPosition").data = value;
        },
        enumerable: false,
        configurable: true
      });
      SimpleMesh2.prototype._render = function(renderer) {
        if (this.autoUpdate) {
          this.geometry.getBuffer("aVertexPosition").update();
        }
        _super.prototype._render.call(this, renderer);
      };
      return SimpleMesh2;
    }(Mesh)
  );
  var DEFAULT_BORDER_SIZE = 10;
  var NineSlicePlane = (
    /** @class */
    function(_super) {
      __extends8(NineSlicePlane2, _super);
      function NineSlicePlane2(texture, leftWidth, topHeight, rightWidth, bottomHeight) {
        if (leftWidth === void 0) {
          leftWidth = DEFAULT_BORDER_SIZE;
        }
        if (topHeight === void 0) {
          topHeight = DEFAULT_BORDER_SIZE;
        }
        if (rightWidth === void 0) {
          rightWidth = DEFAULT_BORDER_SIZE;
        }
        if (bottomHeight === void 0) {
          bottomHeight = DEFAULT_BORDER_SIZE;
        }
        var _this = _super.call(this, Texture.WHITE, 4, 4) || this;
        _this._origWidth = texture.orig.width;
        _this._origHeight = texture.orig.height;
        _this._width = _this._origWidth;
        _this._height = _this._origHeight;
        _this._leftWidth = leftWidth;
        _this._rightWidth = rightWidth;
        _this._topHeight = topHeight;
        _this._bottomHeight = bottomHeight;
        _this.texture = texture;
        return _this;
      }
      NineSlicePlane2.prototype.textureUpdated = function() {
        this._textureID = this.shader.texture._updateID;
        this._refresh();
      };
      Object.defineProperty(NineSlicePlane2.prototype, "vertices", {
        get: function() {
          return this.geometry.getBuffer("aVertexPosition").data;
        },
        set: function(value) {
          this.geometry.getBuffer("aVertexPosition").data = value;
        },
        enumerable: false,
        configurable: true
      });
      NineSlicePlane2.prototype.updateHorizontalVertices = function() {
        var vertices = this.vertices;
        var scale = this._getMinScale();
        vertices[9] = vertices[11] = vertices[13] = vertices[15] = this._topHeight * scale;
        vertices[17] = vertices[19] = vertices[21] = vertices[23] = this._height - this._bottomHeight * scale;
        vertices[25] = vertices[27] = vertices[29] = vertices[31] = this._height;
      };
      NineSlicePlane2.prototype.updateVerticalVertices = function() {
        var vertices = this.vertices;
        var scale = this._getMinScale();
        vertices[2] = vertices[10] = vertices[18] = vertices[26] = this._leftWidth * scale;
        vertices[4] = vertices[12] = vertices[20] = vertices[28] = this._width - this._rightWidth * scale;
        vertices[6] = vertices[14] = vertices[22] = vertices[30] = this._width;
      };
      NineSlicePlane2.prototype._getMinScale = function() {
        var w = this._leftWidth + this._rightWidth;
        var scaleW = this._width > w ? 1 : this._width / w;
        var h = this._topHeight + this._bottomHeight;
        var scaleH = this._height > h ? 1 : this._height / h;
        var scale = Math.min(scaleW, scaleH);
        return scale;
      };
      Object.defineProperty(NineSlicePlane2.prototype, "width", {
        /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
        get: function() {
          return this._width;
        },
        set: function(value) {
          this._width = value;
          this._refresh();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NineSlicePlane2.prototype, "height", {
        /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
        get: function() {
          return this._height;
        },
        set: function(value) {
          this._height = value;
          this._refresh();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NineSlicePlane2.prototype, "leftWidth", {
        /** The width of the left column. */
        get: function() {
          return this._leftWidth;
        },
        set: function(value) {
          this._leftWidth = value;
          this._refresh();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NineSlicePlane2.prototype, "rightWidth", {
        /** The width of the right column. */
        get: function() {
          return this._rightWidth;
        },
        set: function(value) {
          this._rightWidth = value;
          this._refresh();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NineSlicePlane2.prototype, "topHeight", {
        /** The height of the top row. */
        get: function() {
          return this._topHeight;
        },
        set: function(value) {
          this._topHeight = value;
          this._refresh();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NineSlicePlane2.prototype, "bottomHeight", {
        /** The height of the bottom row. */
        get: function() {
          return this._bottomHeight;
        },
        set: function(value) {
          this._bottomHeight = value;
          this._refresh();
        },
        enumerable: false,
        configurable: true
      });
      NineSlicePlane2.prototype._refresh = function() {
        var texture = this.texture;
        var uvs = this.geometry.buffers[1].data;
        this._origWidth = texture.orig.width;
        this._origHeight = texture.orig.height;
        var _uvw = 1 / this._origWidth;
        var _uvh = 1 / this._origHeight;
        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
        this.updateHorizontalVertices();
        this.updateVerticalVertices();
        this.geometry.buffers[0].update();
        this.geometry.buffers[1].update();
      };
      return NineSlicePlane2;
    }(SimplePlane)
  );

  // node_modules/@pixi/mixin-cache-as-bitmap/dist/esm/mixin-cache-as-bitmap.js
  var ENV5;
  (function(ENV6) {
    ENV6[ENV6["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
    ENV6[ENV6["WEBGL"] = 1] = "WEBGL";
    ENV6[ENV6["WEBGL2"] = 2] = "WEBGL2";
  })(ENV5 || (ENV5 = {}));
  var RENDERER_TYPE5;
  (function(RENDERER_TYPE6) {
    RENDERER_TYPE6[RENDERER_TYPE6["UNKNOWN"] = 0] = "UNKNOWN";
    RENDERER_TYPE6[RENDERER_TYPE6["WEBGL"] = 1] = "WEBGL";
    RENDERER_TYPE6[RENDERER_TYPE6["CANVAS"] = 2] = "CANVAS";
  })(RENDERER_TYPE5 || (RENDERER_TYPE5 = {}));
  var BUFFER_BITS5;
  (function(BUFFER_BITS6) {
    BUFFER_BITS6[BUFFER_BITS6["COLOR"] = 16384] = "COLOR";
    BUFFER_BITS6[BUFFER_BITS6["DEPTH"] = 256] = "DEPTH";
    BUFFER_BITS6[BUFFER_BITS6["STENCIL"] = 1024] = "STENCIL";
  })(BUFFER_BITS5 || (BUFFER_BITS5 = {}));
  var BLEND_MODES5;
  (function(BLEND_MODES6) {
    BLEND_MODES6[BLEND_MODES6["NORMAL"] = 0] = "NORMAL";
    BLEND_MODES6[BLEND_MODES6["ADD"] = 1] = "ADD";
    BLEND_MODES6[BLEND_MODES6["MULTIPLY"] = 2] = "MULTIPLY";
    BLEND_MODES6[BLEND_MODES6["SCREEN"] = 3] = "SCREEN";
    BLEND_MODES6[BLEND_MODES6["OVERLAY"] = 4] = "OVERLAY";
    BLEND_MODES6[BLEND_MODES6["DARKEN"] = 5] = "DARKEN";
    BLEND_MODES6[BLEND_MODES6["LIGHTEN"] = 6] = "LIGHTEN";
    BLEND_MODES6[BLEND_MODES6["COLOR_DODGE"] = 7] = "COLOR_DODGE";
    BLEND_MODES6[BLEND_MODES6["COLOR_BURN"] = 8] = "COLOR_BURN";
    BLEND_MODES6[BLEND_MODES6["HARD_LIGHT"] = 9] = "HARD_LIGHT";
    BLEND_MODES6[BLEND_MODES6["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
    BLEND_MODES6[BLEND_MODES6["DIFFERENCE"] = 11] = "DIFFERENCE";
    BLEND_MODES6[BLEND_MODES6["EXCLUSION"] = 12] = "EXCLUSION";
    BLEND_MODES6[BLEND_MODES6["HUE"] = 13] = "HUE";
    BLEND_MODES6[BLEND_MODES6["SATURATION"] = 14] = "SATURATION";
    BLEND_MODES6[BLEND_MODES6["COLOR"] = 15] = "COLOR";
    BLEND_MODES6[BLEND_MODES6["LUMINOSITY"] = 16] = "LUMINOSITY";
    BLEND_MODES6[BLEND_MODES6["NORMAL_NPM"] = 17] = "NORMAL_NPM";
    BLEND_MODES6[BLEND_MODES6["ADD_NPM"] = 18] = "ADD_NPM";
    BLEND_MODES6[BLEND_MODES6["SCREEN_NPM"] = 19] = "SCREEN_NPM";
    BLEND_MODES6[BLEND_MODES6["NONE"] = 20] = "NONE";
    BLEND_MODES6[BLEND_MODES6["SRC_OVER"] = 0] = "SRC_OVER";
    BLEND_MODES6[BLEND_MODES6["SRC_IN"] = 21] = "SRC_IN";
    BLEND_MODES6[BLEND_MODES6["SRC_OUT"] = 22] = "SRC_OUT";
    BLEND_MODES6[BLEND_MODES6["SRC_ATOP"] = 23] = "SRC_ATOP";
    BLEND_MODES6[BLEND_MODES6["DST_OVER"] = 24] = "DST_OVER";
    BLEND_MODES6[BLEND_MODES6["DST_IN"] = 25] = "DST_IN";
    BLEND_MODES6[BLEND_MODES6["DST_OUT"] = 26] = "DST_OUT";
    BLEND_MODES6[BLEND_MODES6["DST_ATOP"] = 27] = "DST_ATOP";
    BLEND_MODES6[BLEND_MODES6["ERASE"] = 26] = "ERASE";
    BLEND_MODES6[BLEND_MODES6["SUBTRACT"] = 28] = "SUBTRACT";
    BLEND_MODES6[BLEND_MODES6["XOR"] = 29] = "XOR";
  })(BLEND_MODES5 || (BLEND_MODES5 = {}));
  var DRAW_MODES5;
  (function(DRAW_MODES6) {
    DRAW_MODES6[DRAW_MODES6["POINTS"] = 0] = "POINTS";
    DRAW_MODES6[DRAW_MODES6["LINES"] = 1] = "LINES";
    DRAW_MODES6[DRAW_MODES6["LINE_LOOP"] = 2] = "LINE_LOOP";
    DRAW_MODES6[DRAW_MODES6["LINE_STRIP"] = 3] = "LINE_STRIP";
    DRAW_MODES6[DRAW_MODES6["TRIANGLES"] = 4] = "TRIANGLES";
    DRAW_MODES6[DRAW_MODES6["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
    DRAW_MODES6[DRAW_MODES6["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
  })(DRAW_MODES5 || (DRAW_MODES5 = {}));
  var FORMATS5;
  (function(FORMATS6) {
    FORMATS6[FORMATS6["RGBA"] = 6408] = "RGBA";
    FORMATS6[FORMATS6["RGB"] = 6407] = "RGB";
    FORMATS6[FORMATS6["RG"] = 33319] = "RG";
    FORMATS6[FORMATS6["RED"] = 6403] = "RED";
    FORMATS6[FORMATS6["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
    FORMATS6[FORMATS6["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
    FORMATS6[FORMATS6["RG_INTEGER"] = 33320] = "RG_INTEGER";
    FORMATS6[FORMATS6["RED_INTEGER"] = 36244] = "RED_INTEGER";
    FORMATS6[FORMATS6["ALPHA"] = 6406] = "ALPHA";
    FORMATS6[FORMATS6["LUMINANCE"] = 6409] = "LUMINANCE";
    FORMATS6[FORMATS6["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
    FORMATS6[FORMATS6["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
    FORMATS6[FORMATS6["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
  })(FORMATS5 || (FORMATS5 = {}));
  var TARGETS5;
  (function(TARGETS6) {
    TARGETS6[TARGETS6["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
    TARGETS6[TARGETS6["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
    TARGETS6[TARGETS6["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  })(TARGETS5 || (TARGETS5 = {}));
  var TYPES5;
  (function(TYPES6) {
    TYPES6[TYPES6["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    TYPES6[TYPES6["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    TYPES6[TYPES6["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
    TYPES6[TYPES6["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
    TYPES6[TYPES6["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
    TYPES6[TYPES6["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
    TYPES6[TYPES6["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
    TYPES6[TYPES6["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
    TYPES6[TYPES6["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
    TYPES6[TYPES6["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
    TYPES6[TYPES6["BYTE"] = 5120] = "BYTE";
    TYPES6[TYPES6["SHORT"] = 5122] = "SHORT";
    TYPES6[TYPES6["INT"] = 5124] = "INT";
    TYPES6[TYPES6["FLOAT"] = 5126] = "FLOAT";
    TYPES6[TYPES6["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
    TYPES6[TYPES6["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
  })(TYPES5 || (TYPES5 = {}));
  var SAMPLER_TYPES5;
  (function(SAMPLER_TYPES6) {
    SAMPLER_TYPES6[SAMPLER_TYPES6["FLOAT"] = 0] = "FLOAT";
    SAMPLER_TYPES6[SAMPLER_TYPES6["INT"] = 1] = "INT";
    SAMPLER_TYPES6[SAMPLER_TYPES6["UINT"] = 2] = "UINT";
  })(SAMPLER_TYPES5 || (SAMPLER_TYPES5 = {}));
  var SCALE_MODES5;
  (function(SCALE_MODES6) {
    SCALE_MODES6[SCALE_MODES6["NEAREST"] = 0] = "NEAREST";
    SCALE_MODES6[SCALE_MODES6["LINEAR"] = 1] = "LINEAR";
  })(SCALE_MODES5 || (SCALE_MODES5 = {}));
  var WRAP_MODES5;
  (function(WRAP_MODES6) {
    WRAP_MODES6[WRAP_MODES6["CLAMP"] = 33071] = "CLAMP";
    WRAP_MODES6[WRAP_MODES6["REPEAT"] = 10497] = "REPEAT";
    WRAP_MODES6[WRAP_MODES6["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
  })(WRAP_MODES5 || (WRAP_MODES5 = {}));
  var MIPMAP_MODES5;
  (function(MIPMAP_MODES6) {
    MIPMAP_MODES6[MIPMAP_MODES6["OFF"] = 0] = "OFF";
    MIPMAP_MODES6[MIPMAP_MODES6["POW2"] = 1] = "POW2";
    MIPMAP_MODES6[MIPMAP_MODES6["ON"] = 2] = "ON";
    MIPMAP_MODES6[MIPMAP_MODES6["ON_MANUAL"] = 3] = "ON_MANUAL";
  })(MIPMAP_MODES5 || (MIPMAP_MODES5 = {}));
  var ALPHA_MODES5;
  (function(ALPHA_MODES6) {
    ALPHA_MODES6[ALPHA_MODES6["NPM"] = 0] = "NPM";
    ALPHA_MODES6[ALPHA_MODES6["UNPACK"] = 1] = "UNPACK";
    ALPHA_MODES6[ALPHA_MODES6["PMA"] = 2] = "PMA";
    ALPHA_MODES6[ALPHA_MODES6["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
    ALPHA_MODES6[ALPHA_MODES6["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
    ALPHA_MODES6[ALPHA_MODES6["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
    ALPHA_MODES6[ALPHA_MODES6["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
  })(ALPHA_MODES5 || (ALPHA_MODES5 = {}));
  var CLEAR_MODES5;
  (function(CLEAR_MODES6) {
    CLEAR_MODES6[CLEAR_MODES6["NO"] = 0] = "NO";
    CLEAR_MODES6[CLEAR_MODES6["YES"] = 1] = "YES";
    CLEAR_MODES6[CLEAR_MODES6["AUTO"] = 2] = "AUTO";
    CLEAR_MODES6[CLEAR_MODES6["BLEND"] = 0] = "BLEND";
    CLEAR_MODES6[CLEAR_MODES6["CLEAR"] = 1] = "CLEAR";
    CLEAR_MODES6[CLEAR_MODES6["BLIT"] = 2] = "BLIT";
  })(CLEAR_MODES5 || (CLEAR_MODES5 = {}));
  var GC_MODES5;
  (function(GC_MODES6) {
    GC_MODES6[GC_MODES6["AUTO"] = 0] = "AUTO";
    GC_MODES6[GC_MODES6["MANUAL"] = 1] = "MANUAL";
  })(GC_MODES5 || (GC_MODES5 = {}));
  var PRECISION5;
  (function(PRECISION6) {
    PRECISION6["LOW"] = "lowp";
    PRECISION6["MEDIUM"] = "mediump";
    PRECISION6["HIGH"] = "highp";
  })(PRECISION5 || (PRECISION5 = {}));
  var MASK_TYPES5;
  (function(MASK_TYPES6) {
    MASK_TYPES6[MASK_TYPES6["NONE"] = 0] = "NONE";
    MASK_TYPES6[MASK_TYPES6["SCISSOR"] = 1] = "SCISSOR";
    MASK_TYPES6[MASK_TYPES6["STENCIL"] = 2] = "STENCIL";
    MASK_TYPES6[MASK_TYPES6["SPRITE"] = 3] = "SPRITE";
  })(MASK_TYPES5 || (MASK_TYPES5 = {}));
  var MSAA_QUALITY5;
  (function(MSAA_QUALITY6) {
    MSAA_QUALITY6[MSAA_QUALITY6["NONE"] = 0] = "NONE";
    MSAA_QUALITY6[MSAA_QUALITY6["LOW"] = 2] = "LOW";
    MSAA_QUALITY6[MSAA_QUALITY6["MEDIUM"] = 4] = "MEDIUM";
    MSAA_QUALITY6[MSAA_QUALITY6["HIGH"] = 8] = "HIGH";
  })(MSAA_QUALITY5 || (MSAA_QUALITY5 = {}));
  var BUFFER_TYPE5;
  (function(BUFFER_TYPE6) {
    BUFFER_TYPE6[BUFFER_TYPE6["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
    BUFFER_TYPE6[BUFFER_TYPE6["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
    BUFFER_TYPE6[BUFFER_TYPE6["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
  })(BUFFER_TYPE5 || (BUFFER_TYPE5 = {}));
  var _tempMatrix = new Matrix();
  DisplayObject.prototype._cacheAsBitmap = false;
  DisplayObject.prototype._cacheData = null;
  DisplayObject.prototype._cacheAsBitmapResolution = null;
  DisplayObject.prototype._cacheAsBitmapMultisample = MSAA_QUALITY5.NONE;
  var CacheData = (
    /** @class */
    function() {
      function CacheData2() {
        this.textureCacheId = null;
        this.originalRender = null;
        this.originalRenderCanvas = null;
        this.originalCalculateBounds = null;
        this.originalGetLocalBounds = null;
        this.originalUpdateTransform = null;
        this.originalDestroy = null;
        this.originalMask = null;
        this.originalFilterArea = null;
        this.originalContainsPoint = null;
        this.sprite = null;
      }
      return CacheData2;
    }()
  );
  Object.defineProperties(DisplayObject.prototype, {
    /**
     * The resolution to use for cacheAsBitmap. By default this will use the renderer's resolution
     * but can be overriden for performance. Lower values will reduce memory usage at the expense
     * of render quality. A falsey value of `null` or `0` will default to the renderer's resolution.
     * If `cacheAsBitmap` is set to `true`, this will re-render with the new resolution.
     * @member {number} cacheAsBitmapResolution
     * @memberof PIXI.DisplayObject#
     * @default null
     */
    cacheAsBitmapResolution: {
      get: function() {
        return this._cacheAsBitmapResolution;
      },
      set: function(resolution) {
        if (resolution === this._cacheAsBitmapResolution) {
          return;
        }
        this._cacheAsBitmapResolution = resolution;
        if (this.cacheAsBitmap) {
          this.cacheAsBitmap = false;
          this.cacheAsBitmap = true;
        }
      }
    },
    /**
     * The number of samples to use for cacheAsBitmap. If set to `null`, the renderer's
     * sample count is used.
     * If `cacheAsBitmap` is set to `true`, this will re-render with the new number of samples.
     * @member {number} cacheAsBitmapMultisample
     * @memberof PIXI.DisplayObject#
     * @default PIXI.MSAA_QUALITY.NONE
     */
    cacheAsBitmapMultisample: {
      get: function() {
        return this._cacheAsBitmapMultisample;
      },
      set: function(multisample) {
        if (multisample === this._cacheAsBitmapMultisample) {
          return;
        }
        this._cacheAsBitmapMultisample = multisample;
        if (this.cacheAsBitmap) {
          this.cacheAsBitmap = false;
          this.cacheAsBitmap = true;
        }
      }
    },
    /**
     * Set this to true if you want this display object to be cached as a bitmap.
     * This basically takes a snap shot of the display object as it is at that moment. It can
     * provide a performance benefit for complex static displayObjects.
     * To remove simply set this property to `false`
     *
     * IMPORTANT GOTCHA - Make sure that all your textures are preloaded BEFORE setting this property to true
     * as it will take a snapshot of what is currently there. If the textures have not loaded then they will not appear.
     * @member {boolean}
     * @memberof PIXI.DisplayObject#
     */
    cacheAsBitmap: {
      get: function() {
        return this._cacheAsBitmap;
      },
      set: function(value) {
        if (this._cacheAsBitmap === value) {
          return;
        }
        this._cacheAsBitmap = value;
        var data;
        if (value) {
          if (!this._cacheData) {
            this._cacheData = new CacheData();
          }
          data = this._cacheData;
          data.originalRender = this.render;
          data.originalRenderCanvas = this.renderCanvas;
          data.originalUpdateTransform = this.updateTransform;
          data.originalCalculateBounds = this.calculateBounds;
          data.originalGetLocalBounds = this.getLocalBounds;
          data.originalDestroy = this.destroy;
          data.originalContainsPoint = this.containsPoint;
          data.originalMask = this._mask;
          data.originalFilterArea = this.filterArea;
          this.render = this._renderCached;
          this.renderCanvas = this._renderCachedCanvas;
          this.destroy = this._cacheAsBitmapDestroy;
        } else {
          data = this._cacheData;
          if (data.sprite) {
            this._destroyCachedDisplayObject();
          }
          this.render = data.originalRender;
          this.renderCanvas = data.originalRenderCanvas;
          this.calculateBounds = data.originalCalculateBounds;
          this.getLocalBounds = data.originalGetLocalBounds;
          this.destroy = data.originalDestroy;
          this.updateTransform = data.originalUpdateTransform;
          this.containsPoint = data.originalContainsPoint;
          this._mask = data.originalMask;
          this.filterArea = data.originalFilterArea;
        }
      }
    }
  });
  DisplayObject.prototype._renderCached = function _renderCached(renderer) {
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
      return;
    }
    this._initCachedDisplayObject(renderer);
    this._cacheData.sprite.transform._worldID = this.transform._worldID;
    this._cacheData.sprite.worldAlpha = this.worldAlpha;
    this._cacheData.sprite._render(renderer);
  };
  DisplayObject.prototype._initCachedDisplayObject = function _initCachedDisplayObject(renderer) {
    var _a2;
    if (this._cacheData && this._cacheData.sprite) {
      return;
    }
    var cacheAlpha = this.alpha;
    this.alpha = 1;
    renderer.batch.flush();
    var bounds = this.getLocalBounds(null, true).clone();
    if (this.filters && this.filters.length) {
      var padding = this.filters[0].padding;
      bounds.pad(padding);
    }
    bounds.ceil(settings.RESOLUTION);
    var cachedRenderTexture = renderer.renderTexture.current;
    var cachedSourceFrame = renderer.renderTexture.sourceFrame.clone();
    var cachedDestinationFrame = renderer.renderTexture.destinationFrame.clone();
    var cachedProjectionTransform = renderer.projection.transform;
    var renderTexture = RenderTexture.create({
      width: bounds.width,
      height: bounds.height,
      resolution: this.cacheAsBitmapResolution || renderer.resolution,
      multisample: (_a2 = this.cacheAsBitmapMultisample) !== null && _a2 !== void 0 ? _a2 : renderer.multisample
    });
    var textureCacheId = "cacheAsBitmap_" + uid();
    this._cacheData.textureCacheId = textureCacheId;
    BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
    Texture.addToCache(renderTexture, textureCacheId);
    var m = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-bounds.x, -bounds.y);
    this.render = this._cacheData.originalRender;
    renderer.render(this, { renderTexture, clear: true, transform: m, skipUpdateTransform: false });
    renderer.framebuffer.blit();
    renderer.projection.transform = cachedProjectionTransform;
    renderer.renderTexture.bind(cachedRenderTexture, cachedSourceFrame, cachedDestinationFrame);
    this.render = this._renderCached;
    this.updateTransform = this.displayObjectUpdateTransform;
    this.calculateBounds = this._calculateCachedBounds;
    this.getLocalBounds = this._getCachedLocalBounds;
    this._mask = null;
    this.filterArea = null;
    this.alpha = cacheAlpha;
    var cachedSprite = new Sprite(renderTexture);
    cachedSprite.transform.worldTransform = this.transform.worldTransform;
    cachedSprite.anchor.x = -(bounds.x / bounds.width);
    cachedSprite.anchor.y = -(bounds.y / bounds.height);
    cachedSprite.alpha = cacheAlpha;
    cachedSprite._bounds = this._bounds;
    this._cacheData.sprite = cachedSprite;
    this.transform._parentID = -1;
    if (!this.parent) {
      this.enableTempParent();
      this.updateTransform();
      this.disableTempParent(null);
    } else {
      this.updateTransform();
    }
    this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
  };
  DisplayObject.prototype._renderCachedCanvas = function _renderCachedCanvas(renderer) {
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
      return;
    }
    this._initCachedDisplayObjectCanvas(renderer);
    this._cacheData.sprite.worldAlpha = this.worldAlpha;
    this._cacheData.sprite._renderCanvas(renderer);
  };
  DisplayObject.prototype._initCachedDisplayObjectCanvas = function _initCachedDisplayObjectCanvas(renderer) {
    if (this._cacheData && this._cacheData.sprite) {
      return;
    }
    var bounds = this.getLocalBounds(null, true);
    var cacheAlpha = this.alpha;
    this.alpha = 1;
    var cachedRenderTarget = renderer.context;
    var cachedProjectionTransform = renderer._projTransform;
    bounds.ceil(settings.RESOLUTION);
    var renderTexture = RenderTexture.create({ width: bounds.width, height: bounds.height });
    var textureCacheId = "cacheAsBitmap_" + uid();
    this._cacheData.textureCacheId = textureCacheId;
    BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
    Texture.addToCache(renderTexture, textureCacheId);
    var m = _tempMatrix;
    this.transform.localTransform.copyTo(m);
    m.invert();
    m.tx -= bounds.x;
    m.ty -= bounds.y;
    this.renderCanvas = this._cacheData.originalRenderCanvas;
    renderer.render(this, { renderTexture, clear: true, transform: m, skipUpdateTransform: false });
    renderer.context = cachedRenderTarget;
    renderer._projTransform = cachedProjectionTransform;
    this.renderCanvas = this._renderCachedCanvas;
    this.updateTransform = this.displayObjectUpdateTransform;
    this.calculateBounds = this._calculateCachedBounds;
    this.getLocalBounds = this._getCachedLocalBounds;
    this._mask = null;
    this.filterArea = null;
    this.alpha = cacheAlpha;
    var cachedSprite = new Sprite(renderTexture);
    cachedSprite.transform.worldTransform = this.transform.worldTransform;
    cachedSprite.anchor.x = -(bounds.x / bounds.width);
    cachedSprite.anchor.y = -(bounds.y / bounds.height);
    cachedSprite.alpha = cacheAlpha;
    cachedSprite._bounds = this._bounds;
    this._cacheData.sprite = cachedSprite;
    this.transform._parentID = -1;
    if (!this.parent) {
      this.parent = renderer._tempDisplayObjectParent;
      this.updateTransform();
      this.parent = null;
    } else {
      this.updateTransform();
    }
    this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
  };
  DisplayObject.prototype._calculateCachedBounds = function _calculateCachedBounds() {
    this._bounds.clear();
    this._cacheData.sprite.transform._worldID = this.transform._worldID;
    this._cacheData.sprite._calculateBounds();
    this._bounds.updateID = this._boundsID;
  };
  DisplayObject.prototype._getCachedLocalBounds = function _getCachedLocalBounds() {
    return this._cacheData.sprite.getLocalBounds(null);
  };
  DisplayObject.prototype._destroyCachedDisplayObject = function _destroyCachedDisplayObject() {
    this._cacheData.sprite._texture.destroy(true);
    this._cacheData.sprite = null;
    BaseTexture.removeFromCache(this._cacheData.textureCacheId);
    Texture.removeFromCache(this._cacheData.textureCacheId);
    this._cacheData.textureCacheId = null;
  };
  DisplayObject.prototype._cacheAsBitmapDestroy = function _cacheAsBitmapDestroy(options) {
    this.cacheAsBitmap = false;
    this.destroy(options);
  };

  // node_modules/@pixi/sprite-tiling/dist/esm/sprite-tiling.js
  var extendStatics9 = function(d, b) {
    extendStatics9 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) {
        if (b2.hasOwnProperty(p)) {
          d2[p] = b2[p];
        }
      }
    };
    return extendStatics9(d, b);
  };
  function __extends9(d, b) {
    extendStatics9(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var tempPoint3 = new Point();
  var TilingSprite = (
    /** @class */
    function(_super) {
      __extends9(TilingSprite2, _super);
      function TilingSprite2(texture, width, height) {
        if (width === void 0) {
          width = 100;
        }
        if (height === void 0) {
          height = 100;
        }
        var _this = _super.call(this, texture) || this;
        _this.tileTransform = new Transform();
        _this._width = width;
        _this._height = height;
        _this.uvMatrix = _this.texture.uvMatrix || new TextureMatrix(texture);
        _this.pluginName = "tilingSprite";
        _this.uvRespectAnchor = false;
        return _this;
      }
      Object.defineProperty(TilingSprite2.prototype, "clampMargin", {
        /**
         * Changes frame clamping in corresponding textureTransform, shortcut
         * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
         * @default 0.5
         * @member {number}
         */
        get: function() {
          return this.uvMatrix.clampMargin;
        },
        set: function(value) {
          this.uvMatrix.clampMargin = value;
          this.uvMatrix.update(true);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TilingSprite2.prototype, "tileScale", {
        /** The scaling of the image that is being tiled. */
        get: function() {
          return this.tileTransform.scale;
        },
        set: function(value) {
          this.tileTransform.scale.copyFrom(value);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TilingSprite2.prototype, "tilePosition", {
        /** The offset of the image that is being tiled. */
        get: function() {
          return this.tileTransform.position;
        },
        set: function(value) {
          this.tileTransform.position.copyFrom(value);
        },
        enumerable: false,
        configurable: true
      });
      TilingSprite2.prototype._onTextureUpdate = function() {
        if (this.uvMatrix) {
          this.uvMatrix.texture = this._texture;
        }
        this._cachedTint = 16777215;
      };
      TilingSprite2.prototype._render = function(renderer) {
        var texture = this._texture;
        if (!texture || !texture.valid) {
          return;
        }
        this.tileTransform.updateLocalTransform();
        this.uvMatrix.update();
        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
        renderer.plugins[this.pluginName].render(this);
      };
      TilingSprite2.prototype._calculateBounds = function() {
        var minX = this._width * -this._anchor._x;
        var minY = this._height * -this._anchor._y;
        var maxX = this._width * (1 - this._anchor._x);
        var maxY = this._height * (1 - this._anchor._y);
        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
      };
      TilingSprite2.prototype.getLocalBounds = function(rect) {
        if (this.children.length === 0) {
          this._bounds.minX = this._width * -this._anchor._x;
          this._bounds.minY = this._height * -this._anchor._y;
          this._bounds.maxX = this._width * (1 - this._anchor._x);
          this._bounds.maxY = this._height * (1 - this._anchor._y);
          if (!rect) {
            if (!this._localBoundsRect) {
              this._localBoundsRect = new Rectangle();
            }
            rect = this._localBoundsRect;
          }
          return this._bounds.getRectangle(rect);
        }
        return _super.prototype.getLocalBounds.call(this, rect);
      };
      TilingSprite2.prototype.containsPoint = function(point) {
        this.worldTransform.applyInverse(point, tempPoint3);
        var width = this._width;
        var height = this._height;
        var x1 = -width * this.anchor._x;
        if (tempPoint3.x >= x1 && tempPoint3.x < x1 + width) {
          var y1 = -height * this.anchor._y;
          if (tempPoint3.y >= y1 && tempPoint3.y < y1 + height) {
            return true;
          }
        }
        return false;
      };
      TilingSprite2.prototype.destroy = function(options) {
        _super.prototype.destroy.call(this, options);
        this.tileTransform = null;
        this.uvMatrix = null;
      };
      TilingSprite2.from = function(source, options) {
        var texture = source instanceof Texture ? source : Texture.from(source, options);
        return new TilingSprite2(texture, options.width, options.height);
      };
      Object.defineProperty(TilingSprite2.prototype, "width", {
        /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
        get: function() {
          return this._width;
        },
        set: function(value) {
          this._width = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TilingSprite2.prototype, "height", {
        /** The height of the TilingSprite, setting this will actually modify the scale to achieve the value set. */
        get: function() {
          return this._height;
        },
        set: function(value) {
          this._height = value;
        },
        enumerable: false,
        configurable: true
      });
      return TilingSprite2;
    }(Sprite)
  );
  var fragmentSimpleSrc = "#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n";
  var gl1VertexSrc = "#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";
  var gl1FragmentSrc = "#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n";
  var gl2VertexSrc = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";
  var gl2FragmentSrc = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n";
  var tempMat2 = new Matrix();
  var TilingSpriteRenderer = (
    /** @class */
    function(_super) {
      __extends9(TilingSpriteRenderer2, _super);
      function TilingSpriteRenderer2(renderer) {
        var _this = _super.call(this, renderer) || this;
        renderer.runners.contextChange.add(_this);
        _this.quad = new QuadUv();
        _this.state = State.for2d();
        return _this;
      }
      TilingSpriteRenderer2.prototype.contextChange = function() {
        var renderer = this.renderer;
        var uniforms = { globals: renderer.globalUniforms };
        this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, uniforms);
        this.shader = renderer.context.webGLVersion > 1 ? Shader.from(gl2VertexSrc, gl2FragmentSrc, uniforms) : Shader.from(gl1VertexSrc, gl1FragmentSrc, uniforms);
      };
      TilingSpriteRenderer2.prototype.render = function(ts) {
        var renderer = this.renderer;
        var quad = this.quad;
        var vertices = quad.vertices;
        vertices[0] = vertices[6] = ts._width * -ts.anchor.x;
        vertices[1] = vertices[3] = ts._height * -ts.anchor.y;
        vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x);
        vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y);
        var anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0;
        var anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;
        vertices = quad.uvs;
        vertices[0] = vertices[6] = -anchorX;
        vertices[1] = vertices[3] = -anchorY;
        vertices[2] = vertices[4] = 1 - anchorX;
        vertices[5] = vertices[7] = 1 - anchorY;
        quad.invalidate();
        var tex = ts._texture;
        var baseTex = tex.baseTexture;
        var lt = ts.tileTransform.localTransform;
        var uv = ts.uvMatrix;
        var isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;
        if (isSimple) {
          if (!baseTex._glTextures[renderer.CONTEXT_UID]) {
            if (baseTex.wrapMode === WRAP_MODES.CLAMP) {
              baseTex.wrapMode = WRAP_MODES.REPEAT;
            }
          } else {
            isSimple = baseTex.wrapMode !== WRAP_MODES.CLAMP;
          }
        }
        var shader = isSimple ? this.simpleShader : this.shader;
        var w = tex.width;
        var h = tex.height;
        var W = ts._width;
        var H = ts._height;
        tempMat2.set(lt.a * w / W, lt.b * w / H, lt.c * h / W, lt.d * h / H, lt.tx / W, lt.ty / H);
        tempMat2.invert();
        if (isSimple) {
          tempMat2.prepend(uv.mapCoord);
        } else {
          shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);
          shader.uniforms.uClampFrame = uv.uClampFrame;
          shader.uniforms.uClampOffset = uv.uClampOffset;
        }
        shader.uniforms.uTransform = tempMat2.toArray(true);
        shader.uniforms.uColor = premultiplyTintToRgba(ts.tint, ts.worldAlpha, shader.uniforms.uColor, baseTex.alphaMode);
        shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);
        shader.uniforms.uSampler = tex;
        renderer.shader.bind(shader);
        renderer.geometry.bind(quad);
        this.state.blendMode = correctBlendMode(ts.blendMode, baseTex.alphaMode);
        renderer.state.set(this.state);
        renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
      };
      return TilingSpriteRenderer2;
    }(ObjectRenderer)
  );

  // node_modules/@pixi/canvas-sprite/dist/esm/canvas-sprite.js
  var canvasRenderWorldTransform = new Matrix();
  var CanvasSpriteRenderer = (
    /** @class */
    function() {
      function CanvasSpriteRenderer2(renderer) {
        this.renderer = renderer;
      }
      CanvasSpriteRenderer2.prototype.render = function(sprite) {
        var texture = sprite._texture;
        var renderer = this.renderer;
        var context3 = renderer.context;
        if (!texture.valid) {
          return;
        }
        var width = texture._frame.width;
        var height = texture._frame.height;
        var wt = sprite.transform.worldTransform;
        var dx = 0;
        var dy = 0;
        var source = texture.baseTexture.getDrawableSource();
        if (texture.orig.width <= 0 || texture.orig.height <= 0 || !texture.valid || !source) {
          return;
        }
        renderer.setBlendMode(sprite.blendMode, true);
        renderer.context.globalAlpha = sprite.worldAlpha;
        var smoothingEnabled = texture.baseTexture.scaleMode === SCALE_MODES.LINEAR;
        if (renderer.smoothProperty && renderer.context[renderer.smoothProperty] !== smoothingEnabled) {
          context3[renderer.smoothProperty] = smoothingEnabled;
        }
        if (texture.trim) {
          dx = texture.trim.width / 2 + texture.trim.x - sprite.anchor.x * texture.orig.width;
          dy = texture.trim.height / 2 + texture.trim.y - sprite.anchor.y * texture.orig.height;
        } else {
          dx = (0.5 - sprite.anchor.x) * texture.orig.width;
          dy = (0.5 - sprite.anchor.y) * texture.orig.height;
        }
        if (texture.rotate) {
          wt.copyTo(canvasRenderWorldTransform);
          wt = canvasRenderWorldTransform;
          groupD8.matrixAppendRotationInv(wt, texture.rotate, dx, dy);
          dx = 0;
          dy = 0;
        }
        dx -= width / 2;
        dy -= height / 2;
        renderer.setContextTransform(wt, sprite.roundPixels, 1);
        if (sprite.roundPixels) {
          dx = dx | 0;
          dy = dy | 0;
        }
        var resolution = texture.baseTexture.resolution;
        var outerBlend = renderer._outerBlend;
        if (outerBlend) {
          context3.save();
          context3.beginPath();
          context3.rect(dx * renderer.resolution, dy * renderer.resolution, width * renderer.resolution, height * renderer.resolution);
          context3.clip();
        }
        if (sprite.tint !== 16777215) {
          if (sprite._cachedTint !== sprite.tint || sprite._tintedCanvas.tintId !== sprite._texture._updateID) {
            sprite._cachedTint = sprite.tint;
            sprite._tintedCanvas = canvasUtils.getTintedCanvas(sprite, sprite.tint);
          }
          context3.drawImage(sprite._tintedCanvas, 0, 0, Math.floor(width * resolution), Math.floor(height * resolution), Math.floor(dx * renderer.resolution), Math.floor(dy * renderer.resolution), Math.floor(width * renderer.resolution), Math.floor(height * renderer.resolution));
        } else {
          context3.drawImage(source, texture._frame.x * resolution, texture._frame.y * resolution, Math.floor(width * resolution), Math.floor(height * resolution), Math.floor(dx * renderer.resolution), Math.floor(dy * renderer.resolution), Math.floor(width * renderer.resolution), Math.floor(height * renderer.resolution));
        }
        if (outerBlend) {
          context3.restore();
        }
        renderer.setBlendMode(BLEND_MODES.NORMAL);
      };
      CanvasSpriteRenderer2.prototype.destroy = function() {
        this.renderer = null;
      };
      return CanvasSpriteRenderer2;
    }()
  );
  Sprite.prototype._tintedCanvas = null;
  Sprite.prototype._renderCanvas = function _renderCanvas2(renderer) {
    renderer.plugins.sprite.render(this);
  };

  // node_modules/@pixi/text/dist/esm/text.js
  var extendStatics10 = function(d, b) {
    extendStatics10 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) {
        if (b2.hasOwnProperty(p)) {
          d2[p] = b2[p];
        }
      }
    };
    return extendStatics10(d, b);
  };
  function __extends10(d, b) {
    extendStatics10(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var TEXT_GRADIENT;
  (function(TEXT_GRADIENT2) {
    TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_VERTICAL"] = 0] = "LINEAR_VERTICAL";
    TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_HORIZONTAL"] = 1] = "LINEAR_HORIZONTAL";
  })(TEXT_GRADIENT || (TEXT_GRADIENT = {}));
  var defaultStyle = {
    align: "left",
    breakWords: false,
    dropShadow: false,
    dropShadowAlpha: 1,
    dropShadowAngle: Math.PI / 6,
    dropShadowBlur: 0,
    dropShadowColor: "black",
    dropShadowDistance: 5,
    fill: "black",
    fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,
    fillGradientStops: [],
    fontFamily: "Arial",
    fontSize: 26,
    fontStyle: "normal",
    fontVariant: "normal",
    fontWeight: "normal",
    letterSpacing: 0,
    lineHeight: 0,
    lineJoin: "miter",
    miterLimit: 10,
    padding: 0,
    stroke: "black",
    strokeThickness: 0,
    textBaseline: "alphabetic",
    trim: false,
    whiteSpace: "pre",
    wordWrap: false,
    wordWrapWidth: 100,
    leading: 0
  };
  var genericFontFamilies = [
    "serif",
    "sans-serif",
    "monospace",
    "cursive",
    "fantasy",
    "system-ui"
  ];
  var TextStyle = (
    /** @class */
    function() {
      function TextStyle2(style) {
        this.styleID = 0;
        this.reset();
        deepCopyProperties(this, style, style);
      }
      TextStyle2.prototype.clone = function() {
        var clonedProperties = {};
        deepCopyProperties(clonedProperties, this, defaultStyle);
        return new TextStyle2(clonedProperties);
      };
      TextStyle2.prototype.reset = function() {
        deepCopyProperties(this, defaultStyle, defaultStyle);
      };
      Object.defineProperty(TextStyle2.prototype, "align", {
        /**
         * Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
         *
         * @member {string}
         */
        get: function() {
          return this._align;
        },
        set: function(align) {
          if (this._align !== align) {
            this._align = align;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "breakWords", {
        /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */
        get: function() {
          return this._breakWords;
        },
        set: function(breakWords) {
          if (this._breakWords !== breakWords) {
            this._breakWords = breakWords;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "dropShadow", {
        /** Set a drop shadow for the text. */
        get: function() {
          return this._dropShadow;
        },
        set: function(dropShadow) {
          if (this._dropShadow !== dropShadow) {
            this._dropShadow = dropShadow;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "dropShadowAlpha", {
        /** Set alpha for the drop shadow. */
        get: function() {
          return this._dropShadowAlpha;
        },
        set: function(dropShadowAlpha) {
          if (this._dropShadowAlpha !== dropShadowAlpha) {
            this._dropShadowAlpha = dropShadowAlpha;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "dropShadowAngle", {
        /** Set a angle of the drop shadow. */
        get: function() {
          return this._dropShadowAngle;
        },
        set: function(dropShadowAngle) {
          if (this._dropShadowAngle !== dropShadowAngle) {
            this._dropShadowAngle = dropShadowAngle;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "dropShadowBlur", {
        /** Set a shadow blur radius. */
        get: function() {
          return this._dropShadowBlur;
        },
        set: function(dropShadowBlur) {
          if (this._dropShadowBlur !== dropShadowBlur) {
            this._dropShadowBlur = dropShadowBlur;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "dropShadowColor", {
        /** A fill style to be used on the dropshadow e.g 'red', '#00FF00'. */
        get: function() {
          return this._dropShadowColor;
        },
        set: function(dropShadowColor) {
          var outputColor = getColor(dropShadowColor);
          if (this._dropShadowColor !== outputColor) {
            this._dropShadowColor = outputColor;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "dropShadowDistance", {
        /** Set a distance of the drop shadow. */
        get: function() {
          return this._dropShadowDistance;
        },
        set: function(dropShadowDistance) {
          if (this._dropShadowDistance !== dropShadowDistance) {
            this._dropShadowDistance = dropShadowDistance;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "fill", {
        /**
         * A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'.
         *
         * Can be an array to create a gradient eg ['#000000','#FFFFFF']
         * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}
         *
         * @member {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
         */
        get: function() {
          return this._fill;
        },
        set: function(fill) {
          var outputColor = getColor(fill);
          if (this._fill !== outputColor) {
            this._fill = outputColor;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "fillGradientType", {
        /**
         * If fill is an array of colours to create a gradient, this can change the type/direction of the gradient.
         *
         * @see PIXI.TEXT_GRADIENT
         */
        get: function() {
          return this._fillGradientType;
        },
        set: function(fillGradientType) {
          if (this._fillGradientType !== fillGradientType) {
            this._fillGradientType = fillGradientType;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "fillGradientStops", {
        /**
         * If fill is an array of colours to create a gradient, this array can set the stop points
         * (numbers between 0 and 1) for the color, overriding the default behaviour of evenly spacing them.
         */
        get: function() {
          return this._fillGradientStops;
        },
        set: function(fillGradientStops) {
          if (!areArraysEqual(this._fillGradientStops, fillGradientStops)) {
            this._fillGradientStops = fillGradientStops;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "fontFamily", {
        /** The font family. */
        get: function() {
          return this._fontFamily;
        },
        set: function(fontFamily) {
          if (this.fontFamily !== fontFamily) {
            this._fontFamily = fontFamily;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "fontSize", {
        /**
         * The font size
         * (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em')
         */
        get: function() {
          return this._fontSize;
        },
        set: function(fontSize) {
          if (this._fontSize !== fontSize) {
            this._fontSize = fontSize;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "fontStyle", {
        /**
         * The font style
         * ('normal', 'italic' or 'oblique')
         *
         * @member {string}
         */
        get: function() {
          return this._fontStyle;
        },
        set: function(fontStyle) {
          if (this._fontStyle !== fontStyle) {
            this._fontStyle = fontStyle;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "fontVariant", {
        /**
         * The font variant
         * ('normal' or 'small-caps')
         *
         * @member {string}
         */
        get: function() {
          return this._fontVariant;
        },
        set: function(fontVariant) {
          if (this._fontVariant !== fontVariant) {
            this._fontVariant = fontVariant;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "fontWeight", {
        /**
         * The font weight
         * ('normal', 'bold', 'bolder', 'lighter' and '100', '200', '300', '400', '500', '600', '700', 800' or '900')
         *
         * @member {string}
         */
        get: function() {
          return this._fontWeight;
        },
        set: function(fontWeight) {
          if (this._fontWeight !== fontWeight) {
            this._fontWeight = fontWeight;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "letterSpacing", {
        /** The amount of spacing between letters, default is 0. */
        get: function() {
          return this._letterSpacing;
        },
        set: function(letterSpacing) {
          if (this._letterSpacing !== letterSpacing) {
            this._letterSpacing = letterSpacing;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "lineHeight", {
        /** The line height, a number that represents the vertical space that a letter uses. */
        get: function() {
          return this._lineHeight;
        },
        set: function(lineHeight) {
          if (this._lineHeight !== lineHeight) {
            this._lineHeight = lineHeight;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "leading", {
        /** The space between lines. */
        get: function() {
          return this._leading;
        },
        set: function(leading) {
          if (this._leading !== leading) {
            this._leading = leading;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "lineJoin", {
        /**
         * The lineJoin property sets the type of corner created, it can resolve spiked text issues.
         * Default is 'miter' (creates a sharp corner).
         *
         * @member {string}
         */
        get: function() {
          return this._lineJoin;
        },
        set: function(lineJoin) {
          if (this._lineJoin !== lineJoin) {
            this._lineJoin = lineJoin;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "miterLimit", {
        /**
         * The miter limit to use when using the 'miter' lineJoin mode.
         *
         * This can reduce or increase the spikiness of rendered text.
         */
        get: function() {
          return this._miterLimit;
        },
        set: function(miterLimit) {
          if (this._miterLimit !== miterLimit) {
            this._miterLimit = miterLimit;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "padding", {
        /**
         * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
         * by adding padding to all sides of the text.
         */
        get: function() {
          return this._padding;
        },
        set: function(padding) {
          if (this._padding !== padding) {
            this._padding = padding;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "stroke", {
        /**
         * A canvas fillstyle that will be used on the text stroke
         * e.g 'blue', '#FCFF00'
         */
        get: function() {
          return this._stroke;
        },
        set: function(stroke) {
          var outputColor = getColor(stroke);
          if (this._stroke !== outputColor) {
            this._stroke = outputColor;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "strokeThickness", {
        /**
         * A number that represents the thickness of the stroke.
         *
         * @default 0
         */
        get: function() {
          return this._strokeThickness;
        },
        set: function(strokeThickness) {
          if (this._strokeThickness !== strokeThickness) {
            this._strokeThickness = strokeThickness;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "textBaseline", {
        /**
         * The baseline of the text that is rendered.
         *
         * @member {string}
         */
        get: function() {
          return this._textBaseline;
        },
        set: function(textBaseline) {
          if (this._textBaseline !== textBaseline) {
            this._textBaseline = textBaseline;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "trim", {
        /** Trim transparent borders. */
        get: function() {
          return this._trim;
        },
        set: function(trim) {
          if (this._trim !== trim) {
            this._trim = trim;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "whiteSpace", {
        /**
         * How newlines and spaces should be handled.
         * Default is 'pre' (preserve, preserve).
         *
         *  value       | New lines     |   Spaces
         *  ---         | ---           |   ---
         * 'normal'     | Collapse      |   Collapse
         * 'pre'        | Preserve      |   Preserve
         * 'pre-line'   | Preserve      |   Collapse
         *
         * @member {string}
         */
        get: function() {
          return this._whiteSpace;
        },
        set: function(whiteSpace) {
          if (this._whiteSpace !== whiteSpace) {
            this._whiteSpace = whiteSpace;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "wordWrap", {
        /** Indicates if word wrap should be used. */
        get: function() {
          return this._wordWrap;
        },
        set: function(wordWrap) {
          if (this._wordWrap !== wordWrap) {
            this._wordWrap = wordWrap;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "wordWrapWidth", {
        /** The width at which text will wrap, it needs wordWrap to be set to true. */
        get: function() {
          return this._wordWrapWidth;
        },
        set: function(wordWrapWidth) {
          if (this._wordWrapWidth !== wordWrapWidth) {
            this._wordWrapWidth = wordWrapWidth;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      TextStyle2.prototype.toFontString = function() {
        var fontSizeString = typeof this.fontSize === "number" ? this.fontSize + "px" : this.fontSize;
        var fontFamilies = this.fontFamily;
        if (!Array.isArray(this.fontFamily)) {
          fontFamilies = this.fontFamily.split(",");
        }
        for (var i = fontFamilies.length - 1; i >= 0; i--) {
          var fontFamily = fontFamilies[i].trim();
          if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && genericFontFamilies.indexOf(fontFamily) < 0) {
            fontFamily = '"' + fontFamily + '"';
          }
          fontFamilies[i] = fontFamily;
        }
        return this.fontStyle + " " + this.fontVariant + " " + this.fontWeight + " " + fontSizeString + " " + fontFamilies.join(",");
      };
      return TextStyle2;
    }()
  );
  function getSingleColor(color) {
    if (typeof color === "number") {
      return hex2string(color);
    } else if (typeof color === "string") {
      if (color.indexOf("0x") === 0) {
        color = color.replace("0x", "#");
      }
    }
    return color;
  }
  function getColor(color) {
    if (!Array.isArray(color)) {
      return getSingleColor(color);
    } else {
      for (var i = 0; i < color.length; ++i) {
        color[i] = getSingleColor(color[i]);
      }
      return color;
    }
  }
  function areArraysEqual(array1, array2) {
    if (!Array.isArray(array1) || !Array.isArray(array2)) {
      return false;
    }
    if (array1.length !== array2.length) {
      return false;
    }
    for (var i = 0; i < array1.length; ++i) {
      if (array1[i] !== array2[i]) {
        return false;
      }
    }
    return true;
  }
  function deepCopyProperties(target, source, propertyObj) {
    for (var prop in propertyObj) {
      if (Array.isArray(source[prop])) {
        target[prop] = source[prop].slice();
      } else {
        target[prop] = source[prop];
      }
    }
  }
  var TextMetrics = (
    /** @class */
    function() {
      function TextMetrics2(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
        this.text = text;
        this.style = style;
        this.width = width;
        this.height = height;
        this.lines = lines;
        this.lineWidths = lineWidths;
        this.lineHeight = lineHeight;
        this.maxLineWidth = maxLineWidth;
        this.fontProperties = fontProperties;
      }
      TextMetrics2.measureText = function(text, style, wordWrap, canvas) {
        if (canvas === void 0) {
          canvas = TextMetrics2._canvas;
        }
        wordWrap = wordWrap === void 0 || wordWrap === null ? style.wordWrap : wordWrap;
        var font = style.toFontString();
        var fontProperties = TextMetrics2.measureFont(font);
        if (fontProperties.fontSize === 0) {
          fontProperties.fontSize = style.fontSize;
          fontProperties.ascent = style.fontSize;
        }
        var context3 = canvas.getContext("2d");
        context3.font = font;
        var outputText = wordWrap ? TextMetrics2.wordWrap(text, style, canvas) : text;
        var lines = outputText.split(/(?:\r\n|\r|\n)/);
        var lineWidths = new Array(lines.length);
        var maxLineWidth = 0;
        for (var i = 0; i < lines.length; i++) {
          var lineWidth = context3.measureText(lines[i]).width + (lines[i].length - 1) * style.letterSpacing;
          lineWidths[i] = lineWidth;
          maxLineWidth = Math.max(maxLineWidth, lineWidth);
        }
        var width = maxLineWidth + style.strokeThickness;
        if (style.dropShadow) {
          width += style.dropShadowDistance;
        }
        var lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;
        var height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness) + (lines.length - 1) * (lineHeight + style.leading);
        if (style.dropShadow) {
          height += style.dropShadowDistance;
        }
        return new TextMetrics2(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);
      };
      TextMetrics2.wordWrap = function(text, style, canvas) {
        if (canvas === void 0) {
          canvas = TextMetrics2._canvas;
        }
        var context3 = canvas.getContext("2d");
        var width = 0;
        var line = "";
        var lines = "";
        var cache = /* @__PURE__ */ Object.create(null);
        var letterSpacing = style.letterSpacing, whiteSpace = style.whiteSpace;
        var collapseSpaces = TextMetrics2.collapseSpaces(whiteSpace);
        var collapseNewlines = TextMetrics2.collapseNewlines(whiteSpace);
        var canPrependSpaces = !collapseSpaces;
        var wordWrapWidth = style.wordWrapWidth + letterSpacing;
        var tokens = TextMetrics2.tokenize(text);
        for (var i = 0; i < tokens.length; i++) {
          var token = tokens[i];
          if (TextMetrics2.isNewline(token)) {
            if (!collapseNewlines) {
              lines += TextMetrics2.addLine(line);
              canPrependSpaces = !collapseSpaces;
              line = "";
              width = 0;
              continue;
            }
            token = " ";
          }
          if (collapseSpaces) {
            var currIsBreakingSpace = TextMetrics2.isBreakingSpace(token);
            var lastIsBreakingSpace = TextMetrics2.isBreakingSpace(line[line.length - 1]);
            if (currIsBreakingSpace && lastIsBreakingSpace) {
              continue;
            }
          }
          var tokenWidth = TextMetrics2.getFromCache(token, letterSpacing, cache, context3);
          if (tokenWidth > wordWrapWidth) {
            if (line !== "") {
              lines += TextMetrics2.addLine(line);
              line = "";
              width = 0;
            }
            if (TextMetrics2.canBreakWords(token, style.breakWords)) {
              var characters = TextMetrics2.wordWrapSplit(token);
              for (var j = 0; j < characters.length; j++) {
                var char = characters[j];
                var k = 1;
                while (characters[j + k]) {
                  var nextChar = characters[j + k];
                  var lastChar = char[char.length - 1];
                  if (!TextMetrics2.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {
                    char += nextChar;
                  } else {
                    break;
                  }
                  k++;
                }
                j += char.length - 1;
                var characterWidth = TextMetrics2.getFromCache(char, letterSpacing, cache, context3);
                if (characterWidth + width > wordWrapWidth) {
                  lines += TextMetrics2.addLine(line);
                  canPrependSpaces = false;
                  line = "";
                  width = 0;
                }
                line += char;
                width += characterWidth;
              }
            } else {
              if (line.length > 0) {
                lines += TextMetrics2.addLine(line);
                line = "";
                width = 0;
              }
              var isLastToken = i === tokens.length - 1;
              lines += TextMetrics2.addLine(token, !isLastToken);
              canPrependSpaces = false;
              line = "";
              width = 0;
            }
          } else {
            if (tokenWidth + width > wordWrapWidth) {
              canPrependSpaces = false;
              lines += TextMetrics2.addLine(line);
              line = "";
              width = 0;
            }
            if (line.length > 0 || !TextMetrics2.isBreakingSpace(token) || canPrependSpaces) {
              line += token;
              width += tokenWidth;
            }
          }
        }
        lines += TextMetrics2.addLine(line, false);
        return lines;
      };
      TextMetrics2.addLine = function(line, newLine) {
        if (newLine === void 0) {
          newLine = true;
        }
        line = TextMetrics2.trimRight(line);
        line = newLine ? line + "\n" : line;
        return line;
      };
      TextMetrics2.getFromCache = function(key, letterSpacing, cache, context3) {
        var width = cache[key];
        if (typeof width !== "number") {
          var spacing = key.length * letterSpacing;
          width = context3.measureText(key).width + spacing;
          cache[key] = width;
        }
        return width;
      };
      TextMetrics2.collapseSpaces = function(whiteSpace) {
        return whiteSpace === "normal" || whiteSpace === "pre-line";
      };
      TextMetrics2.collapseNewlines = function(whiteSpace) {
        return whiteSpace === "normal";
      };
      TextMetrics2.trimRight = function(text) {
        if (typeof text !== "string") {
          return "";
        }
        for (var i = text.length - 1; i >= 0; i--) {
          var char = text[i];
          if (!TextMetrics2.isBreakingSpace(char)) {
            break;
          }
          text = text.slice(0, -1);
        }
        return text;
      };
      TextMetrics2.isNewline = function(char) {
        if (typeof char !== "string") {
          return false;
        }
        return TextMetrics2._newlines.indexOf(char.charCodeAt(0)) >= 0;
      };
      TextMetrics2.isBreakingSpace = function(char, _nextChar) {
        if (typeof char !== "string") {
          return false;
        }
        return TextMetrics2._breakingSpaces.indexOf(char.charCodeAt(0)) >= 0;
      };
      TextMetrics2.tokenize = function(text) {
        var tokens = [];
        var token = "";
        if (typeof text !== "string") {
          return tokens;
        }
        for (var i = 0; i < text.length; i++) {
          var char = text[i];
          var nextChar = text[i + 1];
          if (TextMetrics2.isBreakingSpace(char, nextChar) || TextMetrics2.isNewline(char)) {
            if (token !== "") {
              tokens.push(token);
              token = "";
            }
            tokens.push(char);
            continue;
          }
          token += char;
        }
        if (token !== "") {
          tokens.push(token);
        }
        return tokens;
      };
      TextMetrics2.canBreakWords = function(_token, breakWords) {
        return breakWords;
      };
      TextMetrics2.canBreakChars = function(_char, _nextChar, _token, _index, _breakWords) {
        return true;
      };
      TextMetrics2.wordWrapSplit = function(token) {
        return token.split("");
      };
      TextMetrics2.measureFont = function(font) {
        if (TextMetrics2._fonts[font]) {
          return TextMetrics2._fonts[font];
        }
        var properties = {
          ascent: 0,
          descent: 0,
          fontSize: 0
        };
        var canvas = TextMetrics2._canvas;
        var context3 = TextMetrics2._context;
        context3.font = font;
        var metricsString = TextMetrics2.METRICS_STRING + TextMetrics2.BASELINE_SYMBOL;
        var width = Math.ceil(context3.measureText(metricsString).width);
        var baseline = Math.ceil(context3.measureText(TextMetrics2.BASELINE_SYMBOL).width);
        var height = Math.ceil(TextMetrics2.HEIGHT_MULTIPLIER * baseline);
        baseline = baseline * TextMetrics2.BASELINE_MULTIPLIER | 0;
        canvas.width = width;
        canvas.height = height;
        context3.fillStyle = "#f00";
        context3.fillRect(0, 0, width, height);
        context3.font = font;
        context3.textBaseline = "alphabetic";
        context3.fillStyle = "#000";
        context3.fillText(metricsString, 0, baseline);
        var imagedata = context3.getImageData(0, 0, width, height).data;
        var pixels = imagedata.length;
        var line = width * 4;
        var i = 0;
        var idx = 0;
        var stop = false;
        for (i = 0; i < baseline; ++i) {
          for (var j = 0; j < line; j += 4) {
            if (imagedata[idx + j] !== 255) {
              stop = true;
              break;
            }
          }
          if (!stop) {
            idx += line;
          } else {
            break;
          }
        }
        properties.ascent = baseline - i;
        idx = pixels - line;
        stop = false;
        for (i = height; i > baseline; --i) {
          for (var j = 0; j < line; j += 4) {
            if (imagedata[idx + j] !== 255) {
              stop = true;
              break;
            }
          }
          if (!stop) {
            idx -= line;
          } else {
            break;
          }
        }
        properties.descent = i - baseline;
        properties.fontSize = properties.ascent + properties.descent;
        TextMetrics2._fonts[font] = properties;
        return properties;
      };
      TextMetrics2.clearMetrics = function(font) {
        if (font === void 0) {
          font = "";
        }
        if (font) {
          delete TextMetrics2._fonts[font];
        } else {
          TextMetrics2._fonts = {};
        }
      };
      Object.defineProperty(TextMetrics2, "_canvas", {
        /**
         * Cached canvas element for measuring text
         * TODO: this should be private, but isn't because of backward compat, will fix later.
         * @ignore
         */
        get: function() {
          if (!TextMetrics2.__canvas) {
            var canvas = void 0;
            try {
              var c = new OffscreenCanvas(0, 0);
              var context3 = c.getContext("2d");
              if (context3 && context3.measureText) {
                TextMetrics2.__canvas = c;
                return c;
              }
              canvas = document.createElement("canvas");
            } catch (ex) {
              canvas = document.createElement("canvas");
            }
            canvas.width = canvas.height = 10;
            TextMetrics2.__canvas = canvas;
          }
          return TextMetrics2.__canvas;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextMetrics2, "_context", {
        /**
         * TODO: this should be private, but isn't because of backward compat, will fix later.
         * @ignore
         */
        get: function() {
          if (!TextMetrics2.__context) {
            TextMetrics2.__context = TextMetrics2._canvas.getContext("2d");
          }
          return TextMetrics2.__context;
        },
        enumerable: false,
        configurable: true
      });
      return TextMetrics2;
    }()
  );
  TextMetrics._fonts = {};
  TextMetrics.METRICS_STRING = "|\xC9q\xC5";
  TextMetrics.BASELINE_SYMBOL = "M";
  TextMetrics.BASELINE_MULTIPLIER = 1.4;
  TextMetrics.HEIGHT_MULTIPLIER = 2;
  TextMetrics._newlines = [
    10,
    13
  ];
  TextMetrics._breakingSpaces = [
    9,
    32,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8200,
    8201,
    8202,
    8287,
    12288
  ];
  var defaultDestroyOptions = {
    texture: true,
    children: false,
    baseTexture: true
  };
  var Text = (
    /** @class */
    function(_super) {
      __extends10(Text2, _super);
      function Text2(text, style, canvas) {
        var _this = this;
        var ownCanvas = false;
        if (!canvas) {
          canvas = document.createElement("canvas");
          ownCanvas = true;
        }
        canvas.width = 3;
        canvas.height = 3;
        var texture = Texture.from(canvas);
        texture.orig = new Rectangle();
        texture.trim = new Rectangle();
        _this = _super.call(this, texture) || this;
        _this._ownCanvas = ownCanvas;
        _this.canvas = canvas;
        _this.context = _this.canvas.getContext("2d");
        _this._resolution = settings.RESOLUTION;
        _this._autoResolution = true;
        _this._text = null;
        _this._style = null;
        _this._styleListener = null;
        _this._font = "";
        _this.text = text;
        _this.style = style;
        _this.localStyleID = -1;
        return _this;
      }
      Text2.prototype.updateText = function(respectDirty) {
        var style = this._style;
        if (this.localStyleID !== style.styleID) {
          this.dirty = true;
          this.localStyleID = style.styleID;
        }
        if (!this.dirty && respectDirty) {
          return;
        }
        this._font = this._style.toFontString();
        var context3 = this.context;
        var measured = TextMetrics.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas);
        var width = measured.width;
        var height = measured.height;
        var lines = measured.lines;
        var lineHeight = measured.lineHeight;
        var lineWidths = measured.lineWidths;
        var maxLineWidth = measured.maxLineWidth;
        var fontProperties = measured.fontProperties;
        this.canvas.width = Math.ceil(Math.ceil(Math.max(1, width) + style.padding * 2) * this._resolution);
        this.canvas.height = Math.ceil(Math.ceil(Math.max(1, height) + style.padding * 2) * this._resolution);
        context3.scale(this._resolution, this._resolution);
        context3.clearRect(0, 0, this.canvas.width, this.canvas.height);
        context3.font = this._font;
        context3.lineWidth = style.strokeThickness;
        context3.textBaseline = style.textBaseline;
        context3.lineJoin = style.lineJoin;
        context3.miterLimit = style.miterLimit;
        var linePositionX;
        var linePositionY;
        var passesCount = style.dropShadow ? 2 : 1;
        for (var i = 0; i < passesCount; ++i) {
          var isShadowPass = style.dropShadow && i === 0;
          var dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;
          var dsOffsetShadow = dsOffsetText * this._resolution;
          if (isShadowPass) {
            context3.fillStyle = "black";
            context3.strokeStyle = "black";
            var dropShadowColor = style.dropShadowColor;
            var rgb = hex2rgb(typeof dropShadowColor === "number" ? dropShadowColor : string2hex(dropShadowColor));
            var dropShadowBlur = style.dropShadowBlur * this._resolution;
            var dropShadowDistance = style.dropShadowDistance * this._resolution;
            context3.shadowColor = "rgba(" + rgb[0] * 255 + "," + rgb[1] * 255 + "," + rgb[2] * 255 + "," + style.dropShadowAlpha + ")";
            context3.shadowBlur = dropShadowBlur;
            context3.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
            context3.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance + dsOffsetShadow;
          } else {
            context3.fillStyle = this._generateFillStyle(style, lines, measured);
            context3.strokeStyle = style.stroke;
            context3.shadowColor = "black";
            context3.shadowBlur = 0;
            context3.shadowOffsetX = 0;
            context3.shadowOffsetY = 0;
          }
          var linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
          if (!Text2.nextLineHeightBehavior || lineHeight - fontProperties.fontSize < 0) {
            linePositionYShift = 0;
          }
          for (var i_1 = 0; i_1 < lines.length; i_1++) {
            linePositionX = style.strokeThickness / 2;
            linePositionY = style.strokeThickness / 2 + i_1 * lineHeight + fontProperties.ascent + linePositionYShift;
            if (style.align === "right") {
              linePositionX += maxLineWidth - lineWidths[i_1];
            } else if (style.align === "center") {
              linePositionX += (maxLineWidth - lineWidths[i_1]) / 2;
            }
            if (style.stroke && style.strokeThickness) {
              this.drawLetterSpacing(lines[i_1], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText, true);
            }
            if (style.fill) {
              this.drawLetterSpacing(lines[i_1], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText);
            }
          }
        }
        this.updateTexture();
      };
      Text2.prototype.drawLetterSpacing = function(text, x, y, isStroke) {
        if (isStroke === void 0) {
          isStroke = false;
        }
        var style = this._style;
        var letterSpacing = style.letterSpacing;
        var supportLetterSpacing = Text2.experimentalLetterSpacing && ("letterSpacing" in CanvasRenderingContext2D.prototype || "textLetterSpacing" in CanvasRenderingContext2D.prototype);
        if (letterSpacing === 0 || supportLetterSpacing) {
          if (supportLetterSpacing) {
            this.context.letterSpacing = letterSpacing;
            this.context.textLetterSpacing = letterSpacing;
          }
          if (isStroke) {
            this.context.strokeText(text, x, y);
          } else {
            this.context.fillText(text, x, y);
          }
          return;
        }
        var currentPosition = x;
        var stringArray = Array.from ? Array.from(text) : text.split("");
        var previousWidth = this.context.measureText(text).width;
        var currentWidth = 0;
        for (var i = 0; i < stringArray.length; ++i) {
          var currentChar = stringArray[i];
          if (isStroke) {
            this.context.strokeText(currentChar, currentPosition, y);
          } else {
            this.context.fillText(currentChar, currentPosition, y);
          }
          var textStr = "";
          for (var j = i + 1; j < stringArray.length; ++j) {
            textStr += stringArray[j];
          }
          currentWidth = this.context.measureText(textStr).width;
          currentPosition += previousWidth - currentWidth + letterSpacing;
          previousWidth = currentWidth;
        }
      };
      Text2.prototype.updateTexture = function() {
        var canvas = this.canvas;
        if (this._style.trim) {
          var trimmed = trimCanvas(canvas);
          if (trimmed.data) {
            canvas.width = trimmed.width;
            canvas.height = trimmed.height;
            this.context.putImageData(trimmed.data, 0, 0);
          }
        }
        var texture = this._texture;
        var style = this._style;
        var padding = style.trim ? 0 : style.padding;
        var baseTexture = texture.baseTexture;
        texture.trim.width = texture._frame.width = canvas.width / this._resolution;
        texture.trim.height = texture._frame.height = canvas.height / this._resolution;
        texture.trim.x = -padding;
        texture.trim.y = -padding;
        texture.orig.width = texture._frame.width - padding * 2;
        texture.orig.height = texture._frame.height - padding * 2;
        this._onTextureUpdate();
        baseTexture.setRealSize(canvas.width, canvas.height, this._resolution);
        texture.updateUvs();
        this.dirty = false;
      };
      Text2.prototype._render = function(renderer) {
        if (this._autoResolution && this._resolution !== renderer.resolution) {
          this._resolution = renderer.resolution;
          this.dirty = true;
        }
        this.updateText(true);
        _super.prototype._render.call(this, renderer);
      };
      Text2.prototype.updateTransform = function() {
        this.updateText(true);
        _super.prototype.updateTransform.call(this);
      };
      Text2.prototype.getBounds = function(skipUpdate, rect) {
        this.updateText(true);
        if (this._textureID === -1) {
          skipUpdate = false;
        }
        return _super.prototype.getBounds.call(this, skipUpdate, rect);
      };
      Text2.prototype.getLocalBounds = function(rect) {
        this.updateText(true);
        return _super.prototype.getLocalBounds.call(this, rect);
      };
      Text2.prototype._calculateBounds = function() {
        this.calculateVertices();
        this._bounds.addQuad(this.vertexData);
      };
      Text2.prototype._generateFillStyle = function(style, lines, metrics) {
        var fillStyle = style.fill;
        if (!Array.isArray(fillStyle)) {
          return fillStyle;
        } else if (fillStyle.length === 1) {
          return fillStyle[0];
        }
        var gradient;
        var dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
        var padding = style.padding || 0;
        var width = this.canvas.width / this._resolution - dropShadowCorrection - padding * 2;
        var height = this.canvas.height / this._resolution - dropShadowCorrection - padding * 2;
        var fill = fillStyle.slice();
        var fillGradientStops = style.fillGradientStops.slice();
        if (!fillGradientStops.length) {
          var lengthPlus1 = fill.length + 1;
          for (var i = 1; i < lengthPlus1; ++i) {
            fillGradientStops.push(i / lengthPlus1);
          }
        }
        fill.unshift(fillStyle[0]);
        fillGradientStops.unshift(0);
        fill.push(fillStyle[fillStyle.length - 1]);
        fillGradientStops.push(1);
        if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
          gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);
          var textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
          for (var i = 0; i < lines.length; i++) {
            var lastLineBottom = metrics.lineHeight * (i - 1) + textHeight;
            var thisLineTop = metrics.lineHeight * i;
            var thisLineGradientStart = thisLineTop;
            if (i > 0 && lastLineBottom > thisLineTop) {
              thisLineGradientStart = (thisLineTop + lastLineBottom) / 2;
            }
            var thisLineBottom = thisLineTop + textHeight;
            var nextLineTop = metrics.lineHeight * (i + 1);
            var thisLineGradientEnd = thisLineBottom;
            if (i + 1 < lines.length && nextLineTop < thisLineBottom) {
              thisLineGradientEnd = (thisLineBottom + nextLineTop) / 2;
            }
            var gradStopLineHeight = (thisLineGradientEnd - thisLineGradientStart) / height;
            for (var j = 0; j < fill.length; j++) {
              var lineStop = 0;
              if (typeof fillGradientStops[j] === "number") {
                lineStop = fillGradientStops[j];
              } else {
                lineStop = j / fill.length;
              }
              var globalStop = Math.min(1, Math.max(0, thisLineGradientStart / height + lineStop * gradStopLineHeight));
              globalStop = Number(globalStop.toFixed(5));
              gradient.addColorStop(globalStop, fill[j]);
            }
          }
        } else {
          gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);
          var totalIterations = fill.length + 1;
          var currentIteration = 1;
          for (var i = 0; i < fill.length; i++) {
            var stop = void 0;
            if (typeof fillGradientStops[i] === "number") {
              stop = fillGradientStops[i];
            } else {
              stop = currentIteration / totalIterations;
            }
            gradient.addColorStop(stop, fill[i]);
            currentIteration++;
          }
        }
        return gradient;
      };
      Text2.prototype.destroy = function(options) {
        if (typeof options === "boolean") {
          options = { children: options };
        }
        options = Object.assign({}, defaultDestroyOptions, options);
        _super.prototype.destroy.call(this, options);
        if (this._ownCanvas) {
          this.canvas.height = this.canvas.width = 0;
        }
        this.context = null;
        this.canvas = null;
        this._style = null;
      };
      Object.defineProperty(Text2.prototype, "width", {
        /** The width of the Text, setting this will actually modify the scale to achieve the value set. */
        get: function() {
          this.updateText(true);
          return Math.abs(this.scale.x) * this._texture.orig.width;
        },
        set: function(value) {
          this.updateText(true);
          var s = sign(this.scale.x) || 1;
          this.scale.x = s * value / this._texture.orig.width;
          this._width = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Text2.prototype, "height", {
        /** The height of the Text, setting this will actually modify the scale to achieve the value set. */
        get: function() {
          this.updateText(true);
          return Math.abs(this.scale.y) * this._texture.orig.height;
        },
        set: function(value) {
          this.updateText(true);
          var s = sign(this.scale.y) || 1;
          this.scale.y = s * value / this._texture.orig.height;
          this._height = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Text2.prototype, "style", {
        /**
         * Set the style of the text.
         *
         * Set up an event listener to listen for changes on the style object and mark the text as dirty.
         */
        get: function() {
          return this._style;
        },
        set: function(style) {
          style = style || {};
          if (style instanceof TextStyle) {
            this._style = style;
          } else {
            this._style = new TextStyle(style);
          }
          this.localStyleID = -1;
          this.dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Text2.prototype, "text", {
        /** Set the copy for the text object. To split a line you can use '\n'. */
        get: function() {
          return this._text;
        },
        set: function(text) {
          text = String(text === null || text === void 0 ? "" : text);
          if (this._text === text) {
            return;
          }
          this._text = text;
          this.dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Text2.prototype, "resolution", {
        /**
         * The resolution / device pixel ratio of the canvas.
         *
         * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
         * @default 1
         */
        get: function() {
          return this._resolution;
        },
        set: function(value) {
          this._autoResolution = false;
          if (this._resolution === value) {
            return;
          }
          this._resolution = value;
          this.dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Text2.nextLineHeightBehavior = false;
      Text2.experimentalLetterSpacing = false;
      return Text2;
    }(Sprite)
  );

  // node_modules/@pixi/loaders/dist/esm/loaders.js
  var SignalBinding = (
    /** @class */
    function() {
      function SignalBinding2(fn, once, thisArg) {
        if (once === void 0) {
          once = false;
        }
        this._fn = fn;
        this._once = once;
        this._thisArg = thisArg;
        this._next = this._prev = this._owner = null;
      }
      SignalBinding2.prototype.detach = function() {
        if (this._owner === null) {
          return false;
        }
        this._owner.detach(this);
        return true;
      };
      return SignalBinding2;
    }()
  );
  function _addSignalBinding(self2, node) {
    if (!self2._head) {
      self2._head = node;
      self2._tail = node;
    } else {
      self2._tail._next = node;
      node._prev = self2._tail;
      self2._tail = node;
    }
    node._owner = self2;
    return node;
  }
  var Signal = (
    /** @class */
    function() {
      function Signal2() {
        this._head = this._tail = void 0;
      }
      Signal2.prototype.handlers = function(exists) {
        if (exists === void 0) {
          exists = false;
        }
        var node = this._head;
        if (exists) {
          return !!node;
        }
        var ee = [];
        while (node) {
          ee.push(node);
          node = node._next;
        }
        return ee;
      };
      Signal2.prototype.has = function(node) {
        if (!(node instanceof SignalBinding)) {
          throw new Error("MiniSignal#has(): First arg must be a SignalBinding object.");
        }
        return node._owner === this;
      };
      Signal2.prototype.dispatch = function() {
        var arguments$1 = arguments;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments$1[_i];
        }
        var node = this._head;
        if (!node) {
          return false;
        }
        while (node) {
          if (node._once) {
            this.detach(node);
          }
          node._fn.apply(node._thisArg, args);
          node = node._next;
        }
        return true;
      };
      Signal2.prototype.add = function(fn, thisArg) {
        if (thisArg === void 0) {
          thisArg = null;
        }
        if (typeof fn !== "function") {
          throw new Error("MiniSignal#add(): First arg must be a Function.");
        }
        return _addSignalBinding(this, new SignalBinding(fn, false, thisArg));
      };
      Signal2.prototype.once = function(fn, thisArg) {
        if (thisArg === void 0) {
          thisArg = null;
        }
        if (typeof fn !== "function") {
          throw new Error("MiniSignal#once(): First arg must be a Function.");
        }
        return _addSignalBinding(this, new SignalBinding(fn, true, thisArg));
      };
      Signal2.prototype.detach = function(node) {
        if (!(node instanceof SignalBinding)) {
          throw new Error("MiniSignal#detach(): First arg must be a SignalBinding object.");
        }
        if (node._owner !== this) {
          return this;
        }
        if (node._prev) {
          node._prev._next = node._next;
        }
        if (node._next) {
          node._next._prev = node._prev;
        }
        if (node === this._head) {
          this._head = node._next;
          if (node._next === null) {
            this._tail = null;
          }
        } else if (node === this._tail) {
          this._tail = node._prev;
          this._tail._next = null;
        }
        node._owner = null;
        return this;
      };
      Signal2.prototype.detachAll = function() {
        var node = this._head;
        if (!node) {
          return this;
        }
        this._head = this._tail = null;
        while (node) {
          node._owner = null;
          node = node._next;
        }
        return this;
      };
      return Signal2;
    }()
  );
  function parseUri(str, opts) {
    opts = opts || {};
    var o = {
      // eslint-disable-next-line max-len
      key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
      q: {
        name: "queryKey",
        parser: /(?:^|&)([^&=]*)=?([^&]*)/g
      },
      parser: {
        // eslint-disable-next-line max-len
        strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
        // eslint-disable-next-line max-len
        loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
      }
    };
    var m = o.parser[opts.strictMode ? "strict" : "loose"].exec(str);
    var uri = {};
    var i = 14;
    while (i--) {
      uri[o.key[i]] = m[i] || "";
    }
    uri[o.q.name] = {};
    uri[o.key[12]].replace(o.q.parser, function(_t0, t1, t2) {
      if (t1) {
        uri[o.q.name][t1] = t2;
      }
    });
    return uri;
  }
  var useXdr;
  var tempAnchor2 = null;
  var STATUS_NONE = 0;
  var STATUS_OK = 200;
  var STATUS_EMPTY = 204;
  var STATUS_IE_BUG_EMPTY = 1223;
  var STATUS_TYPE_OK = 2;
  function _noop$1() {
  }
  function setExtMap(map4, extname, val) {
    if (extname && extname.indexOf(".") === 0) {
      extname = extname.substring(1);
    }
    if (!extname) {
      return;
    }
    map4[extname] = val;
  }
  function reqType(xhr) {
    return xhr.toString().replace("object ", "");
  }
  var LoaderResource = (
    /** @class */
    function() {
      function LoaderResource2(name, url3, options) {
        this._dequeue = _noop$1;
        this._onLoadBinding = null;
        this._elementTimer = 0;
        this._boundComplete = null;
        this._boundOnError = null;
        this._boundOnProgress = null;
        this._boundOnTimeout = null;
        this._boundXhrOnError = null;
        this._boundXhrOnTimeout = null;
        this._boundXhrOnAbort = null;
        this._boundXhrOnLoad = null;
        if (typeof name !== "string" || typeof url3 !== "string") {
          throw new Error("Both name and url are required for constructing a resource.");
        }
        options = options || {};
        this._flags = 0;
        this._setFlag(LoaderResource2.STATUS_FLAGS.DATA_URL, url3.indexOf("data:") === 0);
        this.name = name;
        this.url = url3;
        this.extension = this._getExtension();
        this.data = null;
        this.crossOrigin = options.crossOrigin === true ? "anonymous" : options.crossOrigin;
        this.timeout = options.timeout || 0;
        this.loadType = options.loadType || this._determineLoadType();
        this.xhrType = options.xhrType;
        this.metadata = options.metadata || {};
        this.error = null;
        this.xhr = null;
        this.children = [];
        this.type = LoaderResource2.TYPE.UNKNOWN;
        this.progressChunk = 0;
        this._dequeue = _noop$1;
        this._onLoadBinding = null;
        this._elementTimer = 0;
        this._boundComplete = this.complete.bind(this);
        this._boundOnError = this._onError.bind(this);
        this._boundOnProgress = this._onProgress.bind(this);
        this._boundOnTimeout = this._onTimeout.bind(this);
        this._boundXhrOnError = this._xhrOnError.bind(this);
        this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this);
        this._boundXhrOnAbort = this._xhrOnAbort.bind(this);
        this._boundXhrOnLoad = this._xhrOnLoad.bind(this);
        this.onStart = new Signal();
        this.onProgress = new Signal();
        this.onComplete = new Signal();
        this.onAfterMiddleware = new Signal();
      }
      LoaderResource2.setExtensionLoadType = function(extname, loadType) {
        setExtMap(LoaderResource2._loadTypeMap, extname, loadType);
      };
      LoaderResource2.setExtensionXhrType = function(extname, xhrType) {
        setExtMap(LoaderResource2._xhrTypeMap, extname, xhrType);
      };
      Object.defineProperty(LoaderResource2.prototype, "isDataUrl", {
        /**
         * When the resource starts to load.
         * @memberof PIXI.LoaderResource
         * @callback OnStartSignal
         * @param {PIXI.Resource} resource - The resource that the event happened on.
         */
        /**
         * When the resource reports loading progress.
         * @memberof PIXI.LoaderResource
         * @callback OnProgressSignal
         * @param {PIXI.Resource} resource - The resource that the event happened on.
         * @param {number} percentage - The progress of the load in the range [0, 1].
         */
        /**
         * When the resource finishes loading.
         * @memberof PIXI.LoaderResource
         * @callback OnCompleteSignal
         * @param {PIXI.Resource} resource - The resource that the event happened on.
         */
        /**
         * @memberof PIXI.LoaderResource
         * @typedef {object} IMetadata
         * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The
         *      element to use for loading, instead of creating one.
         * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This
         *      is useful if you want to pass in a `loadElement` that you already added load sources to.
         * @property {string|string[]} [mimeType] - The mime type to use for the source element
         *      of a video/audio elment. If the urls are an array, you can pass this as an array as well
         *      where each index is the mime type to use for the corresponding url index.
         */
        /**
         * Stores whether or not this url is a data url.
         * @readonly
         * @member {boolean}
         */
        get: function() {
          return this._hasFlag(LoaderResource2.STATUS_FLAGS.DATA_URL);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(LoaderResource2.prototype, "isComplete", {
        /**
         * Describes if this resource has finished loading. Is true when the resource has completely
         * loaded.
         * @readonly
         * @member {boolean}
         */
        get: function() {
          return this._hasFlag(LoaderResource2.STATUS_FLAGS.COMPLETE);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(LoaderResource2.prototype, "isLoading", {
        /**
         * Describes if this resource is currently loading. Is true when the resource starts loading,
         * and is false again when complete.
         * @readonly
         * @member {boolean}
         */
        get: function() {
          return this._hasFlag(LoaderResource2.STATUS_FLAGS.LOADING);
        },
        enumerable: false,
        configurable: true
      });
      LoaderResource2.prototype.complete = function() {
        this._clearEvents();
        this._finish();
      };
      LoaderResource2.prototype.abort = function(message) {
        if (this.error) {
          return;
        }
        this.error = new Error(message);
        this._clearEvents();
        if (this.xhr) {
          this.xhr.abort();
        } else if (this.xdr) {
          this.xdr.abort();
        } else if (this.data) {
          if (this.data.src) {
            this.data.src = LoaderResource2.EMPTY_GIF;
          } else {
            while (this.data.firstChild) {
              this.data.removeChild(this.data.firstChild);
            }
          }
        }
        this._finish();
      };
      LoaderResource2.prototype.load = function(cb) {
        var _this = this;
        if (this.isLoading) {
          return;
        }
        if (this.isComplete) {
          if (cb) {
            setTimeout(function() {
              return cb(_this);
            }, 1);
          }
          return;
        } else if (cb) {
          this.onComplete.once(cb);
        }
        this._setFlag(LoaderResource2.STATUS_FLAGS.LOADING, true);
        this.onStart.dispatch(this);
        if (this.crossOrigin === false || typeof this.crossOrigin !== "string") {
          this.crossOrigin = this._determineCrossOrigin(this.url);
        }
        switch (this.loadType) {
          case LoaderResource2.LOAD_TYPE.IMAGE:
            this.type = LoaderResource2.TYPE.IMAGE;
            this._loadElement("image");
            break;
          case LoaderResource2.LOAD_TYPE.AUDIO:
            this.type = LoaderResource2.TYPE.AUDIO;
            this._loadSourceElement("audio");
            break;
          case LoaderResource2.LOAD_TYPE.VIDEO:
            this.type = LoaderResource2.TYPE.VIDEO;
            this._loadSourceElement("video");
            break;
          case LoaderResource2.LOAD_TYPE.XHR:
          default:
            if (typeof useXdr === "undefined") {
              useXdr = !!(globalThis.XDomainRequest && !("withCredentials" in new XMLHttpRequest()));
            }
            if (useXdr && this.crossOrigin) {
              this._loadXdr();
            } else {
              this._loadXhr();
            }
            break;
        }
      };
      LoaderResource2.prototype._hasFlag = function(flag) {
        return (this._flags & flag) !== 0;
      };
      LoaderResource2.prototype._setFlag = function(flag, value) {
        this._flags = value ? this._flags | flag : this._flags & ~flag;
      };
      LoaderResource2.prototype._clearEvents = function() {
        clearTimeout(this._elementTimer);
        if (this.data && this.data.removeEventListener) {
          this.data.removeEventListener("error", this._boundOnError, false);
          this.data.removeEventListener("load", this._boundComplete, false);
          this.data.removeEventListener("progress", this._boundOnProgress, false);
          this.data.removeEventListener("canplaythrough", this._boundComplete, false);
        }
        if (this.xhr) {
          if (this.xhr.removeEventListener) {
            this.xhr.removeEventListener("error", this._boundXhrOnError, false);
            this.xhr.removeEventListener("timeout", this._boundXhrOnTimeout, false);
            this.xhr.removeEventListener("abort", this._boundXhrOnAbort, false);
            this.xhr.removeEventListener("progress", this._boundOnProgress, false);
            this.xhr.removeEventListener("load", this._boundXhrOnLoad, false);
          } else {
            this.xhr.onerror = null;
            this.xhr.ontimeout = null;
            this.xhr.onprogress = null;
            this.xhr.onload = null;
          }
        }
      };
      LoaderResource2.prototype._finish = function() {
        if (this.isComplete) {
          throw new Error("Complete called again for an already completed resource.");
        }
        this._setFlag(LoaderResource2.STATUS_FLAGS.COMPLETE, true);
        this._setFlag(LoaderResource2.STATUS_FLAGS.LOADING, false);
        this.onComplete.dispatch(this);
      };
      LoaderResource2.prototype._loadElement = function(type) {
        if (this.metadata.loadElement) {
          this.data = this.metadata.loadElement;
        } else if (type === "image" && typeof globalThis.Image !== "undefined") {
          this.data = new Image();
        } else {
          this.data = document.createElement(type);
        }
        if (this.crossOrigin) {
          this.data.crossOrigin = this.crossOrigin;
        }
        if (!this.metadata.skipSource) {
          this.data.src = this.url;
        }
        this.data.addEventListener("error", this._boundOnError, false);
        this.data.addEventListener("load", this._boundComplete, false);
        this.data.addEventListener("progress", this._boundOnProgress, false);
        if (this.timeout) {
          this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);
        }
      };
      LoaderResource2.prototype._loadSourceElement = function(type) {
        if (this.metadata.loadElement) {
          this.data = this.metadata.loadElement;
        } else if (type === "audio" && typeof globalThis.Audio !== "undefined") {
          this.data = new Audio();
        } else {
          this.data = document.createElement(type);
        }
        if (this.data === null) {
          this.abort("Unsupported element: " + type);
          return;
        }
        if (this.crossOrigin) {
          this.data.crossOrigin = this.crossOrigin;
        }
        if (!this.metadata.skipSource) {
          if (navigator.isCocoonJS) {
            this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
          } else if (Array.isArray(this.url)) {
            var mimeTypes = this.metadata.mimeType;
            for (var i = 0; i < this.url.length; ++i) {
              this.data.appendChild(this._createSource(type, this.url[i], Array.isArray(mimeTypes) ? mimeTypes[i] : mimeTypes));
            }
          } else {
            var mimeTypes = this.metadata.mimeType;
            this.data.appendChild(this._createSource(type, this.url, Array.isArray(mimeTypes) ? mimeTypes[0] : mimeTypes));
          }
        }
        this.data.addEventListener("error", this._boundOnError, false);
        this.data.addEventListener("load", this._boundComplete, false);
        this.data.addEventListener("progress", this._boundOnProgress, false);
        this.data.addEventListener("canplaythrough", this._boundComplete, false);
        this.data.load();
        if (this.timeout) {
          this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);
        }
      };
      LoaderResource2.prototype._loadXhr = function() {
        if (typeof this.xhrType !== "string") {
          this.xhrType = this._determineXhrType();
        }
        var xhr = this.xhr = new XMLHttpRequest();
        if (this.crossOrigin === "use-credentials") {
          xhr.withCredentials = true;
        }
        xhr.open("GET", this.url, true);
        xhr.timeout = this.timeout;
        if (this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.JSON || this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT) {
          xhr.responseType = LoaderResource2.XHR_RESPONSE_TYPE.TEXT;
        } else {
          xhr.responseType = this.xhrType;
        }
        xhr.addEventListener("error", this._boundXhrOnError, false);
        xhr.addEventListener("timeout", this._boundXhrOnTimeout, false);
        xhr.addEventListener("abort", this._boundXhrOnAbort, false);
        xhr.addEventListener("progress", this._boundOnProgress, false);
        xhr.addEventListener("load", this._boundXhrOnLoad, false);
        xhr.send();
      };
      LoaderResource2.prototype._loadXdr = function() {
        if (typeof this.xhrType !== "string") {
          this.xhrType = this._determineXhrType();
        }
        var xdr = this.xhr = new globalThis.XDomainRequest();
        xdr.timeout = this.timeout || 5e3;
        xdr.onerror = this._boundXhrOnError;
        xdr.ontimeout = this._boundXhrOnTimeout;
        xdr.onprogress = this._boundOnProgress;
        xdr.onload = this._boundXhrOnLoad;
        xdr.open("GET", this.url, true);
        setTimeout(function() {
          return xdr.send();
        }, 1);
      };
      LoaderResource2.prototype._createSource = function(type, url3, mime) {
        if (!mime) {
          mime = type + "/" + this._getExtension(url3);
        }
        var source = document.createElement("source");
        source.src = url3;
        source.type = mime;
        return source;
      };
      LoaderResource2.prototype._onError = function(event) {
        this.abort("Failed to load element using: " + event.target.nodeName);
      };
      LoaderResource2.prototype._onProgress = function(event) {
        if (event && event.lengthComputable) {
          this.onProgress.dispatch(this, event.loaded / event.total);
        }
      };
      LoaderResource2.prototype._onTimeout = function() {
        this.abort("Load timed out.");
      };
      LoaderResource2.prototype._xhrOnError = function() {
        var xhr = this.xhr;
        this.abort(reqType(xhr) + " Request failed. Status: " + xhr.status + ', text: "' + xhr.statusText + '"');
      };
      LoaderResource2.prototype._xhrOnTimeout = function() {
        var xhr = this.xhr;
        this.abort(reqType(xhr) + " Request timed out.");
      };
      LoaderResource2.prototype._xhrOnAbort = function() {
        var xhr = this.xhr;
        this.abort(reqType(xhr) + " Request was aborted by the user.");
      };
      LoaderResource2.prototype._xhrOnLoad = function() {
        var xhr = this.xhr;
        var text = "";
        var status = typeof xhr.status === "undefined" ? STATUS_OK : xhr.status;
        if (xhr.responseType === "" || xhr.responseType === "text" || typeof xhr.responseType === "undefined") {
          text = xhr.responseText;
        }
        if (status === STATUS_NONE && (text.length > 0 || xhr.responseType === LoaderResource2.XHR_RESPONSE_TYPE.BUFFER)) {
          status = STATUS_OK;
        } else if (status === STATUS_IE_BUG_EMPTY) {
          status = STATUS_EMPTY;
        }
        var statusType = status / 100 | 0;
        if (statusType === STATUS_TYPE_OK) {
          if (this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.TEXT) {
            this.data = text;
            this.type = LoaderResource2.TYPE.TEXT;
          } else if (this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.JSON) {
            try {
              this.data = JSON.parse(text);
              this.type = LoaderResource2.TYPE.JSON;
            } catch (e) {
              this.abort("Error trying to parse loaded json: " + e);
              return;
            }
          } else if (this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT) {
            try {
              if (globalThis.DOMParser) {
                var domparser = new DOMParser();
                this.data = domparser.parseFromString(text, "text/xml");
              } else {
                var div = document.createElement("div");
                div.innerHTML = text;
                this.data = div;
              }
              this.type = LoaderResource2.TYPE.XML;
            } catch (e$1) {
              this.abort("Error trying to parse loaded xml: " + e$1);
              return;
            }
          } else {
            this.data = xhr.response || text;
          }
        } else {
          this.abort("[" + xhr.status + "] " + xhr.statusText + ": " + xhr.responseURL);
          return;
        }
        this.complete();
      };
      LoaderResource2.prototype._determineCrossOrigin = function(url3, loc) {
        if (url3.indexOf("data:") === 0) {
          return "";
        }
        if (globalThis.origin !== globalThis.location.origin) {
          return "anonymous";
        }
        loc = loc || globalThis.location;
        if (!tempAnchor2) {
          tempAnchor2 = document.createElement("a");
        }
        tempAnchor2.href = url3;
        var parsedUrl = parseUri(tempAnchor2.href, { strictMode: true });
        var samePort = !parsedUrl.port && loc.port === "" || parsedUrl.port === loc.port;
        var protocol = parsedUrl.protocol ? parsedUrl.protocol + ":" : "";
        if (parsedUrl.host !== loc.hostname || !samePort || protocol !== loc.protocol) {
          return "anonymous";
        }
        return "";
      };
      LoaderResource2.prototype._determineXhrType = function() {
        return LoaderResource2._xhrTypeMap[this.extension] || LoaderResource2.XHR_RESPONSE_TYPE.TEXT;
      };
      LoaderResource2.prototype._determineLoadType = function() {
        return LoaderResource2._loadTypeMap[this.extension] || LoaderResource2.LOAD_TYPE.XHR;
      };
      LoaderResource2.prototype._getExtension = function(url3) {
        if (url3 === void 0) {
          url3 = this.url;
        }
        var ext = "";
        if (this.isDataUrl) {
          var slashIndex = url3.indexOf("/");
          ext = url3.substring(slashIndex + 1, url3.indexOf(";", slashIndex));
        } else {
          var queryStart = url3.indexOf("?");
          var hashStart = url3.indexOf("#");
          var index = Math.min(queryStart > -1 ? queryStart : url3.length, hashStart > -1 ? hashStart : url3.length);
          url3 = url3.substring(0, index);
          ext = url3.substring(url3.lastIndexOf(".") + 1);
        }
        return ext.toLowerCase();
      };
      LoaderResource2.prototype._getMimeFromXhrType = function(type) {
        switch (type) {
          case LoaderResource2.XHR_RESPONSE_TYPE.BUFFER:
            return "application/octet-binary";
          case LoaderResource2.XHR_RESPONSE_TYPE.BLOB:
            return "application/blob";
          case LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT:
            return "application/xml";
          case LoaderResource2.XHR_RESPONSE_TYPE.JSON:
            return "application/json";
          case LoaderResource2.XHR_RESPONSE_TYPE.DEFAULT:
          case LoaderResource2.XHR_RESPONSE_TYPE.TEXT:
          default:
            return "text/plain";
        }
      };
      return LoaderResource2;
    }()
  );
  (function(LoaderResource2) {
    (function(STATUS_FLAGS) {
      STATUS_FLAGS[STATUS_FLAGS["NONE"] = 0] = "NONE";
      STATUS_FLAGS[STATUS_FLAGS["DATA_URL"] = 1] = "DATA_URL";
      STATUS_FLAGS[STATUS_FLAGS["COMPLETE"] = 2] = "COMPLETE";
      STATUS_FLAGS[STATUS_FLAGS["LOADING"] = 4] = "LOADING";
    })(LoaderResource2.STATUS_FLAGS || (LoaderResource2.STATUS_FLAGS = {}));
    (function(TYPE) {
      TYPE[TYPE["UNKNOWN"] = 0] = "UNKNOWN";
      TYPE[TYPE["JSON"] = 1] = "JSON";
      TYPE[TYPE["XML"] = 2] = "XML";
      TYPE[TYPE["IMAGE"] = 3] = "IMAGE";
      TYPE[TYPE["AUDIO"] = 4] = "AUDIO";
      TYPE[TYPE["VIDEO"] = 5] = "VIDEO";
      TYPE[TYPE["TEXT"] = 6] = "TEXT";
    })(LoaderResource2.TYPE || (LoaderResource2.TYPE = {}));
    (function(LOAD_TYPE) {
      LOAD_TYPE[LOAD_TYPE["XHR"] = 1] = "XHR";
      LOAD_TYPE[LOAD_TYPE["IMAGE"] = 2] = "IMAGE";
      LOAD_TYPE[LOAD_TYPE["AUDIO"] = 3] = "AUDIO";
      LOAD_TYPE[LOAD_TYPE["VIDEO"] = 4] = "VIDEO";
    })(LoaderResource2.LOAD_TYPE || (LoaderResource2.LOAD_TYPE = {}));
    (function(XHR_RESPONSE_TYPE) {
      XHR_RESPONSE_TYPE["DEFAULT"] = "text";
      XHR_RESPONSE_TYPE["BUFFER"] = "arraybuffer";
      XHR_RESPONSE_TYPE["BLOB"] = "blob";
      XHR_RESPONSE_TYPE["DOCUMENT"] = "document";
      XHR_RESPONSE_TYPE["JSON"] = "json";
      XHR_RESPONSE_TYPE["TEXT"] = "text";
    })(LoaderResource2.XHR_RESPONSE_TYPE || (LoaderResource2.XHR_RESPONSE_TYPE = {}));
    LoaderResource2._loadTypeMap = {
      // images
      gif: LoaderResource2.LOAD_TYPE.IMAGE,
      png: LoaderResource2.LOAD_TYPE.IMAGE,
      bmp: LoaderResource2.LOAD_TYPE.IMAGE,
      jpg: LoaderResource2.LOAD_TYPE.IMAGE,
      jpeg: LoaderResource2.LOAD_TYPE.IMAGE,
      tif: LoaderResource2.LOAD_TYPE.IMAGE,
      tiff: LoaderResource2.LOAD_TYPE.IMAGE,
      webp: LoaderResource2.LOAD_TYPE.IMAGE,
      tga: LoaderResource2.LOAD_TYPE.IMAGE,
      svg: LoaderResource2.LOAD_TYPE.IMAGE,
      "svg+xml": LoaderResource2.LOAD_TYPE.IMAGE,
      // audio
      mp3: LoaderResource2.LOAD_TYPE.AUDIO,
      ogg: LoaderResource2.LOAD_TYPE.AUDIO,
      wav: LoaderResource2.LOAD_TYPE.AUDIO,
      // videos
      mp4: LoaderResource2.LOAD_TYPE.VIDEO,
      webm: LoaderResource2.LOAD_TYPE.VIDEO
    };
    LoaderResource2._xhrTypeMap = {
      // xml
      xhtml: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
      html: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
      htm: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
      xml: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
      tmx: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
      svg: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
      // This was added to handle Tiled Tileset XML, but .tsx is also a TypeScript React Component.
      // Since it is way less likely for people to be loading TypeScript files instead of Tiled files,
      // this should probably be fine.
      tsx: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
      // images
      gif: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
      png: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
      bmp: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
      jpg: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
      jpeg: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
      tif: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
      tiff: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
      webp: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
      tga: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
      // json
      json: LoaderResource2.XHR_RESPONSE_TYPE.JSON,
      // text
      text: LoaderResource2.XHR_RESPONSE_TYPE.TEXT,
      txt: LoaderResource2.XHR_RESPONSE_TYPE.TEXT,
      // fonts
      ttf: LoaderResource2.XHR_RESPONSE_TYPE.BUFFER,
      otf: LoaderResource2.XHR_RESPONSE_TYPE.BUFFER
    };
    LoaderResource2.EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
  })(LoaderResource || (LoaderResource = {}));
  function _noop() {
  }
  function onlyOnce(fn) {
    return function onceWrapper() {
      var arguments$1 = arguments;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments$1[_i];
      }
      if (fn === null) {
        throw new Error("Callback was already called.");
      }
      var callFn = fn;
      fn = null;
      callFn.apply(this, args);
    };
  }
  var AsyncQueueItem = (
    /** @class */
    function() {
      function AsyncQueueItem2(data, callback) {
        this.data = data;
        this.callback = callback;
      }
      return AsyncQueueItem2;
    }()
  );
  var AsyncQueue = (
    /** @class */
    function() {
      function AsyncQueue2(worker, concurrency) {
        var _this = this;
        if (concurrency === void 0) {
          concurrency = 1;
        }
        this.workers = 0;
        this.saturated = _noop;
        this.unsaturated = _noop;
        this.empty = _noop;
        this.drain = _noop;
        this.error = _noop;
        this.started = false;
        this.paused = false;
        this._tasks = [];
        this._insert = function(data, insertAtFront, callback) {
          if (callback && typeof callback !== "function") {
            throw new Error("task callback must be a function");
          }
          _this.started = true;
          if (data == null && _this.idle()) {
            setTimeout(function() {
              return _this.drain();
            }, 1);
            return;
          }
          var item = new AsyncQueueItem(data, typeof callback === "function" ? callback : _noop);
          if (insertAtFront) {
            _this._tasks.unshift(item);
          } else {
            _this._tasks.push(item);
          }
          setTimeout(_this.process, 1);
        };
        this.process = function() {
          while (!_this.paused && _this.workers < _this.concurrency && _this._tasks.length) {
            var task = _this._tasks.shift();
            if (_this._tasks.length === 0) {
              _this.empty();
            }
            _this.workers += 1;
            if (_this.workers === _this.concurrency) {
              _this.saturated();
            }
            _this._worker(task.data, onlyOnce(_this._next(task)));
          }
        };
        this._worker = worker;
        if (concurrency === 0) {
          throw new Error("Concurrency must not be zero");
        }
        this.concurrency = concurrency;
        this.buffer = concurrency / 4;
      }
      AsyncQueue2.prototype._next = function(task) {
        var _this = this;
        return function() {
          var arguments$1 = arguments;
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments$1[_i];
          }
          _this.workers -= 1;
          task.callback.apply(task, args);
          if (args[0] != null) {
            _this.error(args[0], task.data);
          }
          if (_this.workers <= _this.concurrency - _this.buffer) {
            _this.unsaturated();
          }
          if (_this.idle()) {
            _this.drain();
          }
          _this.process();
        };
      };
      AsyncQueue2.prototype.push = function(data, callback) {
        this._insert(data, false, callback);
      };
      AsyncQueue2.prototype.kill = function() {
        this.workers = 0;
        this.drain = _noop;
        this.started = false;
        this._tasks = [];
      };
      AsyncQueue2.prototype.unshift = function(data, callback) {
        this._insert(data, true, callback);
      };
      AsyncQueue2.prototype.length = function() {
        return this._tasks.length;
      };
      AsyncQueue2.prototype.running = function() {
        return this.workers;
      };
      AsyncQueue2.prototype.idle = function() {
        return this._tasks.length + this.workers === 0;
      };
      AsyncQueue2.prototype.pause = function() {
        if (this.paused === true) {
          return;
        }
        this.paused = true;
      };
      AsyncQueue2.prototype.resume = function() {
        if (this.paused === false) {
          return;
        }
        this.paused = false;
        for (var w = 1; w <= this.concurrency; w++) {
          this.process();
        }
      };
      AsyncQueue2.eachSeries = function(array, iterator, callback, deferNext) {
        var i = 0;
        var len = array.length;
        function next(err) {
          if (err || i === len) {
            if (callback) {
              callback(err);
            }
            return;
          }
          if (deferNext) {
            setTimeout(function() {
              iterator(array[i++], next);
            }, 1);
          } else {
            iterator(array[i++], next);
          }
        }
        next();
      };
      AsyncQueue2.queue = function(worker, concurrency) {
        return new AsyncQueue2(worker, concurrency);
      };
      return AsyncQueue2;
    }()
  );
  var MAX_PROGRESS = 100;
  var rgxExtractUrlHash = /(#[\w-]+)?$/;
  var Loader = (
    /** @class */
    function() {
      function Loader2(baseUrl, concurrency) {
        var _this = this;
        if (baseUrl === void 0) {
          baseUrl = "";
        }
        if (concurrency === void 0) {
          concurrency = 10;
        }
        this.progress = 0;
        this.loading = false;
        this.defaultQueryString = "";
        this._beforeMiddleware = [];
        this._afterMiddleware = [];
        this._resourcesParsing = [];
        this._boundLoadResource = function(r, d) {
          return _this._loadResource(r, d);
        };
        this.resources = {};
        this.baseUrl = baseUrl;
        this._beforeMiddleware = [];
        this._afterMiddleware = [];
        this._resourcesParsing = [];
        this._boundLoadResource = function(r, d) {
          return _this._loadResource(r, d);
        };
        this._queue = AsyncQueue.queue(this._boundLoadResource, concurrency);
        this._queue.pause();
        this.resources = {};
        this.onProgress = new Signal();
        this.onError = new Signal();
        this.onLoad = new Signal();
        this.onStart = new Signal();
        this.onComplete = new Signal();
        for (var i = 0; i < Loader2._plugins.length; ++i) {
          var plugin = Loader2._plugins[i];
          var pre = plugin.pre, use = plugin.use;
          if (pre) {
            this.pre(pre);
          }
          if (use) {
            this.use(use);
          }
        }
        this._protected = false;
      }
      Loader2.prototype._add = function(name, url3, options, callback) {
        if (this.loading && (!options || !options.parentResource)) {
          throw new Error("Cannot add resources while the loader is running.");
        }
        if (this.resources[name]) {
          throw new Error('Resource named "' + name + '" already exists.');
        }
        url3 = this._prepareUrl(url3);
        this.resources[name] = new LoaderResource(name, url3, options);
        if (typeof callback === "function") {
          this.resources[name].onAfterMiddleware.once(callback);
        }
        if (this.loading) {
          var parent = options.parentResource;
          var incompleteChildren = [];
          for (var i = 0; i < parent.children.length; ++i) {
            if (!parent.children[i].isComplete) {
              incompleteChildren.push(parent.children[i]);
            }
          }
          var fullChunk = parent.progressChunk * (incompleteChildren.length + 1);
          var eachChunk = fullChunk / (incompleteChildren.length + 2);
          parent.children.push(this.resources[name]);
          parent.progressChunk = eachChunk;
          for (var i = 0; i < incompleteChildren.length; ++i) {
            incompleteChildren[i].progressChunk = eachChunk;
          }
          this.resources[name].progressChunk = eachChunk;
        }
        this._queue.push(this.resources[name]);
        return this;
      };
      Loader2.prototype.pre = function(fn) {
        this._beforeMiddleware.push(fn);
        return this;
      };
      Loader2.prototype.use = function(fn) {
        this._afterMiddleware.push(fn);
        return this;
      };
      Loader2.prototype.reset = function() {
        this.progress = 0;
        this.loading = false;
        this._queue.kill();
        this._queue.pause();
        for (var k in this.resources) {
          var res = this.resources[k];
          if (res._onLoadBinding) {
            res._onLoadBinding.detach();
          }
          if (res.isLoading) {
            res.abort("loader reset");
          }
        }
        this.resources = {};
        return this;
      };
      Loader2.prototype.load = function(cb) {
        if (typeof cb === "function") {
          this.onComplete.once(cb);
        }
        if (this.loading) {
          return this;
        }
        if (this._queue.idle()) {
          this._onStart();
          this._onComplete();
        } else {
          var numTasks = this._queue._tasks.length;
          var chunk = MAX_PROGRESS / numTasks;
          for (var i = 0; i < this._queue._tasks.length; ++i) {
            this._queue._tasks[i].data.progressChunk = chunk;
          }
          this._onStart();
          this._queue.resume();
        }
        return this;
      };
      Object.defineProperty(Loader2.prototype, "concurrency", {
        /**
         * The number of resources to load concurrently.
         * @default 10
         */
        get: function() {
          return this._queue.concurrency;
        },
        set: function(concurrency) {
          this._queue.concurrency = concurrency;
        },
        enumerable: false,
        configurable: true
      });
      Loader2.prototype._prepareUrl = function(url3) {
        var parsedUrl = parseUri(url3, { strictMode: true });
        var result;
        if (parsedUrl.protocol || !parsedUrl.path || url3.indexOf("//") === 0) {
          result = url3;
        } else if (this.baseUrl.length && this.baseUrl.lastIndexOf("/") !== this.baseUrl.length - 1 && url3.charAt(0) !== "/") {
          result = this.baseUrl + "/" + url3;
        } else {
          result = this.baseUrl + url3;
        }
        if (this.defaultQueryString) {
          var hash = rgxExtractUrlHash.exec(result)[0];
          result = result.slice(0, result.length - hash.length);
          if (result.indexOf("?") !== -1) {
            result += "&" + this.defaultQueryString;
          } else {
            result += "?" + this.defaultQueryString;
          }
          result += hash;
        }
        return result;
      };
      Loader2.prototype._loadResource = function(resource, dequeue) {
        var _this = this;
        resource._dequeue = dequeue;
        AsyncQueue.eachSeries(this._beforeMiddleware, function(fn, next) {
          fn.call(_this, resource, function() {
            next(resource.isComplete ? {} : null);
          });
        }, function() {
          if (resource.isComplete) {
            _this._onLoad(resource);
          } else {
            resource._onLoadBinding = resource.onComplete.once(_this._onLoad, _this);
            resource.load();
          }
        }, true);
      };
      Loader2.prototype._onStart = function() {
        this.progress = 0;
        this.loading = true;
        this.onStart.dispatch(this);
      };
      Loader2.prototype._onComplete = function() {
        this.progress = MAX_PROGRESS;
        this.loading = false;
        this.onComplete.dispatch(this, this.resources);
      };
      Loader2.prototype._onLoad = function(resource) {
        var _this = this;
        resource._onLoadBinding = null;
        this._resourcesParsing.push(resource);
        resource._dequeue();
        AsyncQueue.eachSeries(this._afterMiddleware, function(fn, next) {
          fn.call(_this, resource, next);
        }, function() {
          resource.onAfterMiddleware.dispatch(resource);
          _this.progress = Math.min(MAX_PROGRESS, _this.progress + resource.progressChunk);
          _this.onProgress.dispatch(_this, resource);
          if (resource.error) {
            _this.onError.dispatch(resource.error, _this, resource);
          } else {
            _this.onLoad.dispatch(_this, resource);
          }
          _this._resourcesParsing.splice(_this._resourcesParsing.indexOf(resource), 1);
          if (_this._queue.idle() && _this._resourcesParsing.length === 0) {
            _this._onComplete();
          }
        }, true);
      };
      Loader2.prototype.destroy = function() {
        if (!this._protected) {
          this.reset();
        }
      };
      Object.defineProperty(Loader2, "shared", {
        /** A premade instance of the loader that can be used to load resources. */
        get: function() {
          var shared = Loader2._shared;
          if (!shared) {
            shared = new Loader2();
            shared._protected = true;
            Loader2._shared = shared;
          }
          return shared;
        },
        enumerable: false,
        configurable: true
      });
      Loader2.registerPlugin = function(plugin) {
        Loader2._plugins.push(plugin);
        if (plugin.add) {
          plugin.add();
        }
        return Loader2;
      };
      Loader2._plugins = [];
      return Loader2;
    }()
  );
  Loader.prototype.add = function add(name, url3, options, callback) {
    if (Array.isArray(name)) {
      for (var i = 0; i < name.length; ++i) {
        this.add(name[i]);
      }
      return this;
    }
    if (typeof name === "object") {
      options = name;
      callback = url3 || options.callback || options.onComplete;
      url3 = options.url;
      name = options.name || options.key || options.url;
    }
    if (typeof url3 !== "string") {
      callback = options;
      options = url3;
      url3 = name;
    }
    if (typeof url3 !== "string") {
      throw new Error("No url passed to add resource to loader.");
    }
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    return this._add(name, url3, options, callback);
  };
  var AppLoaderPlugin = (
    /** @class */
    function() {
      function AppLoaderPlugin2() {
      }
      AppLoaderPlugin2.init = function(options) {
        options = Object.assign({
          sharedLoader: false
        }, options);
        this.loader = options.sharedLoader ? Loader.shared : new Loader();
      };
      AppLoaderPlugin2.destroy = function() {
        if (this.loader) {
          this.loader.destroy();
          this.loader = null;
        }
      };
      return AppLoaderPlugin2;
    }()
  );
  var TextureLoader = (
    /** @class */
    function() {
      function TextureLoader2() {
      }
      TextureLoader2.add = function() {
        LoaderResource.setExtensionLoadType("svg", LoaderResource.LOAD_TYPE.XHR);
        LoaderResource.setExtensionXhrType("svg", LoaderResource.XHR_RESPONSE_TYPE.TEXT);
      };
      TextureLoader2.use = function(resource, next) {
        if (resource.data && (resource.type === LoaderResource.TYPE.IMAGE || resource.extension === "svg")) {
          var data = resource.data, url3 = resource.url, name = resource.name, metadata = resource.metadata;
          Texture.fromLoader(data, url3, name, metadata).then(function(texture) {
            resource.texture = texture;
            next();
          }).catch(next);
        } else {
          next();
        }
      };
      return TextureLoader2;
    }()
  );
  var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  function encodeBinary(input) {
    var output = "";
    var inx = 0;
    while (inx < input.length) {
      var bytebuffer = [0, 0, 0];
      var encodedCharIndexes = [0, 0, 0, 0];
      for (var jnx = 0; jnx < bytebuffer.length; ++jnx) {
        if (inx < input.length) {
          bytebuffer[jnx] = input.charCodeAt(inx++) & 255;
        } else {
          bytebuffer[jnx] = 0;
        }
      }
      encodedCharIndexes[0] = bytebuffer[0] >> 2;
      encodedCharIndexes[1] = (bytebuffer[0] & 3) << 4 | bytebuffer[1] >> 4;
      encodedCharIndexes[2] = (bytebuffer[1] & 15) << 2 | bytebuffer[2] >> 6;
      encodedCharIndexes[3] = bytebuffer[2] & 63;
      var paddingBytes = inx - (input.length - 1);
      switch (paddingBytes) {
        case 2:
          encodedCharIndexes[3] = 64;
          encodedCharIndexes[2] = 64;
          break;
        case 1:
          encodedCharIndexes[3] = 64;
          break;
      }
      for (var jnx = 0; jnx < encodedCharIndexes.length; ++jnx) {
        output += _keyStr.charAt(encodedCharIndexes[jnx]);
      }
    }
    return output;
  }
  function parsing(resource, next) {
    if (!resource.data) {
      next();
      return;
    }
    if (resource.xhr && resource.xhrType === LoaderResource.XHR_RESPONSE_TYPE.BLOB) {
      if (!self.Blob || typeof resource.data === "string") {
        var type = resource.xhr.getResponseHeader("content-type");
        if (type && type.indexOf("image") === 0) {
          resource.data = new Image();
          resource.data.src = "data:" + type + ";base64," + encodeBinary(resource.xhr.responseText);
          resource.type = LoaderResource.TYPE.IMAGE;
          resource.data.onload = function() {
            resource.data.onload = null;
            next();
          };
          return;
        }
      } else if (resource.data.type.indexOf("image") === 0) {
        var Url_1 = globalThis.URL || globalThis.webkitURL;
        var src_1 = Url_1.createObjectURL(resource.data);
        resource.blob = resource.data;
        resource.data = new Image();
        resource.data.src = src_1;
        resource.type = LoaderResource.TYPE.IMAGE;
        resource.data.onload = function() {
          Url_1.revokeObjectURL(src_1);
          resource.data.onload = null;
          next();
        };
        return;
      }
    }
    next();
  }
  Loader.registerPlugin({ use: parsing });
  Loader.registerPlugin(TextureLoader);

  // node_modules/@pixi/text-bitmap/dist/esm/text-bitmap.js
  var extendStatics11 = function(d, b) {
    extendStatics11 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) {
        if (b2.hasOwnProperty(p)) {
          d2[p] = b2[p];
        }
      }
    };
    return extendStatics11(d, b);
  };
  function __extends11(d, b) {
    extendStatics11(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var BitmapFontData = (
    /** @class */
    function() {
      function BitmapFontData2() {
        this.info = [];
        this.common = [];
        this.page = [];
        this.char = [];
        this.kerning = [];
        this.distanceField = [];
      }
      return BitmapFontData2;
    }()
  );
  var TextFormat = (
    /** @class */
    function() {
      function TextFormat2() {
      }
      TextFormat2.test = function(data) {
        return typeof data === "string" && data.indexOf("info face=") === 0;
      };
      TextFormat2.parse = function(txt) {
        var items = txt.match(/^[a-z]+\s+.+$/gm);
        var rawData = {
          info: [],
          common: [],
          page: [],
          char: [],
          chars: [],
          kerning: [],
          kernings: [],
          distanceField: []
        };
        for (var i in items) {
          var name = items[i].match(/^[a-z]+/gm)[0];
          var attributeList = items[i].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
          var itemData = {};
          for (var i_1 in attributeList) {
            var split = attributeList[i_1].split("=");
            var key = split[0];
            var strValue = split[1].replace(/"/gm, "");
            var floatValue = parseFloat(strValue);
            var value = isNaN(floatValue) ? strValue : floatValue;
            itemData[key] = value;
          }
          rawData[name].push(itemData);
        }
        var font = new BitmapFontData();
        rawData.info.forEach(function(info) {
          return font.info.push({
            face: info.face,
            size: parseInt(info.size, 10)
          });
        });
        rawData.common.forEach(function(common) {
          return font.common.push({
            lineHeight: parseInt(common.lineHeight, 10)
          });
        });
        rawData.page.forEach(function(page) {
          return font.page.push({
            id: parseInt(page.id, 10),
            file: page.file
          });
        });
        rawData.char.forEach(function(char) {
          return font.char.push({
            id: parseInt(char.id, 10),
            page: parseInt(char.page, 10),
            x: parseInt(char.x, 10),
            y: parseInt(char.y, 10),
            width: parseInt(char.width, 10),
            height: parseInt(char.height, 10),
            xoffset: parseInt(char.xoffset, 10),
            yoffset: parseInt(char.yoffset, 10),
            xadvance: parseInt(char.xadvance, 10)
          });
        });
        rawData.kerning.forEach(function(kerning) {
          return font.kerning.push({
            first: parseInt(kerning.first, 10),
            second: parseInt(kerning.second, 10),
            amount: parseInt(kerning.amount, 10)
          });
        });
        rawData.distanceField.forEach(function(df) {
          return font.distanceField.push({
            distanceRange: parseInt(df.distanceRange, 10),
            fieldType: df.fieldType
          });
        });
        return font;
      };
      return TextFormat2;
    }()
  );
  var XMLFormat = (
    /** @class */
    function() {
      function XMLFormat2() {
      }
      XMLFormat2.test = function(data) {
        return data instanceof XMLDocument && data.getElementsByTagName("page").length && data.getElementsByTagName("info")[0].getAttribute("face") !== null;
      };
      XMLFormat2.parse = function(xml) {
        var data = new BitmapFontData();
        var info = xml.getElementsByTagName("info");
        var common = xml.getElementsByTagName("common");
        var page = xml.getElementsByTagName("page");
        var char = xml.getElementsByTagName("char");
        var kerning = xml.getElementsByTagName("kerning");
        var distanceField = xml.getElementsByTagName("distanceField");
        for (var i = 0; i < info.length; i++) {
          data.info.push({
            face: info[i].getAttribute("face"),
            size: parseInt(info[i].getAttribute("size"), 10)
          });
        }
        for (var i = 0; i < common.length; i++) {
          data.common.push({
            lineHeight: parseInt(common[i].getAttribute("lineHeight"), 10)
          });
        }
        for (var i = 0; i < page.length; i++) {
          data.page.push({
            id: parseInt(page[i].getAttribute("id"), 10) || 0,
            file: page[i].getAttribute("file")
          });
        }
        for (var i = 0; i < char.length; i++) {
          var letter = char[i];
          data.char.push({
            id: parseInt(letter.getAttribute("id"), 10),
            page: parseInt(letter.getAttribute("page"), 10) || 0,
            x: parseInt(letter.getAttribute("x"), 10),
            y: parseInt(letter.getAttribute("y"), 10),
            width: parseInt(letter.getAttribute("width"), 10),
            height: parseInt(letter.getAttribute("height"), 10),
            xoffset: parseInt(letter.getAttribute("xoffset"), 10),
            yoffset: parseInt(letter.getAttribute("yoffset"), 10),
            xadvance: parseInt(letter.getAttribute("xadvance"), 10)
          });
        }
        for (var i = 0; i < kerning.length; i++) {
          data.kerning.push({
            first: parseInt(kerning[i].getAttribute("first"), 10),
            second: parseInt(kerning[i].getAttribute("second"), 10),
            amount: parseInt(kerning[i].getAttribute("amount"), 10)
          });
        }
        for (var i = 0; i < distanceField.length; i++) {
          data.distanceField.push({
            fieldType: distanceField[i].getAttribute("fieldType"),
            distanceRange: parseInt(distanceField[i].getAttribute("distanceRange"), 10)
          });
        }
        return data;
      };
      return XMLFormat2;
    }()
  );
  var XMLStringFormat = (
    /** @class */
    function() {
      function XMLStringFormat2() {
      }
      XMLStringFormat2.test = function(data) {
        if (typeof data === "string" && data.indexOf("<font>") > -1) {
          var xml = new globalThis.DOMParser().parseFromString(data, "text/xml");
          return XMLFormat.test(xml);
        }
        return false;
      };
      XMLStringFormat2.parse = function(xmlTxt) {
        var xml = new globalThis.DOMParser().parseFromString(xmlTxt, "text/xml");
        return XMLFormat.parse(xml);
      };
      return XMLStringFormat2;
    }()
  );
  var formats = [
    TextFormat,
    XMLFormat,
    XMLStringFormat
  ];
  function autoDetectFormat(data) {
    for (var i = 0; i < formats.length; i++) {
      if (formats[i].test(data)) {
        return formats[i];
      }
    }
    return null;
  }
  function generateFillStyle(canvas, context3, style, resolution, lines, metrics) {
    var fillStyle = style.fill;
    if (!Array.isArray(fillStyle)) {
      return fillStyle;
    } else if (fillStyle.length === 1) {
      return fillStyle[0];
    }
    var gradient;
    var dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
    var padding = style.padding || 0;
    var width = canvas.width / resolution - dropShadowCorrection - padding * 2;
    var height = canvas.height / resolution - dropShadowCorrection - padding * 2;
    var fill = fillStyle.slice();
    var fillGradientStops = style.fillGradientStops.slice();
    if (!fillGradientStops.length) {
      var lengthPlus1 = fill.length + 1;
      for (var i = 1; i < lengthPlus1; ++i) {
        fillGradientStops.push(i / lengthPlus1);
      }
    }
    fill.unshift(fillStyle[0]);
    fillGradientStops.unshift(0);
    fill.push(fillStyle[fillStyle.length - 1]);
    fillGradientStops.push(1);
    if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
      gradient = context3.createLinearGradient(width / 2, padding, width / 2, height + padding);
      var lastIterationStop = 0;
      var textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
      var gradStopLineHeight = textHeight / height;
      for (var i = 0; i < lines.length; i++) {
        var thisLineTop = metrics.lineHeight * i;
        for (var j = 0; j < fill.length; j++) {
          var lineStop = 0;
          if (typeof fillGradientStops[j] === "number") {
            lineStop = fillGradientStops[j];
          } else {
            lineStop = j / fill.length;
          }
          var globalStop = thisLineTop / height + lineStop * gradStopLineHeight;
          var clampedStop = Math.max(lastIterationStop, globalStop);
          clampedStop = Math.min(clampedStop, 1);
          gradient.addColorStop(clampedStop, fill[j]);
          lastIterationStop = clampedStop;
        }
      }
    } else {
      gradient = context3.createLinearGradient(padding, height / 2, width + padding, height / 2);
      var totalIterations = fill.length + 1;
      var currentIteration = 1;
      for (var i = 0; i < fill.length; i++) {
        var stop = void 0;
        if (typeof fillGradientStops[i] === "number") {
          stop = fillGradientStops[i];
        } else {
          stop = currentIteration / totalIterations;
        }
        gradient.addColorStop(stop, fill[i]);
        currentIteration++;
      }
    }
    return gradient;
  }
  function drawGlyph(canvas, context3, metrics, x, y, resolution, style) {
    var char = metrics.text;
    var fontProperties = metrics.fontProperties;
    context3.translate(x, y);
    context3.scale(resolution, resolution);
    var tx = style.strokeThickness / 2;
    var ty = -(style.strokeThickness / 2);
    context3.font = style.toFontString();
    context3.lineWidth = style.strokeThickness;
    context3.textBaseline = style.textBaseline;
    context3.lineJoin = style.lineJoin;
    context3.miterLimit = style.miterLimit;
    context3.fillStyle = generateFillStyle(canvas, context3, style, resolution, [char], metrics);
    context3.strokeStyle = style.stroke;
    if (style.dropShadow) {
      var dropShadowColor = style.dropShadowColor;
      var rgb = hex2rgb(typeof dropShadowColor === "number" ? dropShadowColor : string2hex(dropShadowColor));
      var dropShadowBlur = style.dropShadowBlur * resolution;
      var dropShadowDistance = style.dropShadowDistance * resolution;
      context3.shadowColor = "rgba(" + rgb[0] * 255 + "," + rgb[1] * 255 + "," + rgb[2] * 255 + "," + style.dropShadowAlpha + ")";
      context3.shadowBlur = dropShadowBlur;
      context3.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
      context3.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance;
    } else {
      context3.shadowColor = "black";
      context3.shadowBlur = 0;
      context3.shadowOffsetX = 0;
      context3.shadowOffsetY = 0;
    }
    if (style.stroke && style.strokeThickness) {
      context3.strokeText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
    }
    if (style.fill) {
      context3.fillText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
    }
    context3.setTransform(1, 0, 0, 1, 0, 0);
    context3.fillStyle = "rgba(0, 0, 0, 0)";
  }
  function splitTextToCharacters(text) {
    return Array.from ? Array.from(text) : text.split("");
  }
  function resolveCharacters(chars) {
    if (typeof chars === "string") {
      chars = [chars];
    }
    var result = [];
    for (var i = 0, j = chars.length; i < j; i++) {
      var item = chars[i];
      if (Array.isArray(item)) {
        if (item.length !== 2) {
          throw new Error("[BitmapFont]: Invalid character range length, expecting 2 got " + item.length + ".");
        }
        var startCode = item[0].charCodeAt(0);
        var endCode = item[1].charCodeAt(0);
        if (endCode < startCode) {
          throw new Error("[BitmapFont]: Invalid character range.");
        }
        for (var i_1 = startCode, j_1 = endCode; i_1 <= j_1; i_1++) {
          result.push(String.fromCharCode(i_1));
        }
      } else {
        result.push.apply(result, splitTextToCharacters(item));
      }
    }
    if (result.length === 0) {
      throw new Error("[BitmapFont]: Empty set when resolving characters.");
    }
    return result;
  }
  function extractCharCode(str) {
    return str.codePointAt ? str.codePointAt(0) : str.charCodeAt(0);
  }
  var BitmapFont = (
    /** @class */
    function() {
      function BitmapFont2(data, textures, ownsTextures) {
        var _a2, _b;
        var info = data.info[0];
        var common = data.common[0];
        var page = data.page[0];
        var distanceField = data.distanceField[0];
        var res = getResolutionOfUrl(page.file);
        var pageTextures = {};
        this._ownsTextures = ownsTextures;
        this.font = info.face;
        this.size = info.size;
        this.lineHeight = common.lineHeight / res;
        this.chars = {};
        this.pageTextures = pageTextures;
        for (var i = 0; i < data.page.length; i++) {
          var _c = data.page[i], id = _c.id, file = _c.file;
          pageTextures[id] = textures instanceof Array ? textures[i] : textures[file];
          if ((distanceField === null || distanceField === void 0 ? void 0 : distanceField.fieldType) && distanceField.fieldType !== "none") {
            pageTextures[id].baseTexture.alphaMode = ALPHA_MODES.NO_PREMULTIPLIED_ALPHA;
          }
        }
        for (var i = 0; i < data.char.length; i++) {
          var _d = data.char[i], id = _d.id, page_1 = _d.page;
          var _e = data.char[i], x = _e.x, y = _e.y, width = _e.width, height = _e.height, xoffset = _e.xoffset, yoffset = _e.yoffset, xadvance = _e.xadvance;
          x /= res;
          y /= res;
          width /= res;
          height /= res;
          xoffset /= res;
          yoffset /= res;
          xadvance /= res;
          var rect = new Rectangle(x + pageTextures[page_1].frame.x / res, y + pageTextures[page_1].frame.y / res, width, height);
          this.chars[id] = {
            xOffset: xoffset,
            yOffset: yoffset,
            xAdvance: xadvance,
            kerning: {},
            texture: new Texture(pageTextures[page_1].baseTexture, rect),
            page: page_1
          };
        }
        for (var i = 0; i < data.kerning.length; i++) {
          var _f = data.kerning[i], first = _f.first, second = _f.second, amount = _f.amount;
          first /= res;
          second /= res;
          amount /= res;
          if (this.chars[second]) {
            this.chars[second].kerning[first] = amount;
          }
        }
        this.distanceFieldRange = distanceField === null || distanceField === void 0 ? void 0 : distanceField.distanceRange;
        this.distanceFieldType = (_b = (_a2 = distanceField === null || distanceField === void 0 ? void 0 : distanceField.fieldType) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase()) !== null && _b !== void 0 ? _b : "none";
      }
      BitmapFont2.prototype.destroy = function() {
        for (var id in this.chars) {
          this.chars[id].texture.destroy();
          this.chars[id].texture = null;
        }
        for (var id in this.pageTextures) {
          if (this._ownsTextures) {
            this.pageTextures[id].destroy(true);
          }
          this.pageTextures[id] = null;
        }
        this.chars = null;
        this.pageTextures = null;
      };
      BitmapFont2.install = function(data, textures, ownsTextures) {
        var fontData;
        if (data instanceof BitmapFontData) {
          fontData = data;
        } else {
          var format3 = autoDetectFormat(data);
          if (!format3) {
            throw new Error("Unrecognized data format for font.");
          }
          fontData = format3.parse(data);
        }
        if (textures instanceof Texture) {
          textures = [textures];
        }
        var font = new BitmapFont2(fontData, textures, ownsTextures);
        BitmapFont2.available[font.font] = font;
        return font;
      };
      BitmapFont2.uninstall = function(name) {
        var font = BitmapFont2.available[name];
        if (!font) {
          throw new Error("No font found named '" + name + "'");
        }
        font.destroy();
        delete BitmapFont2.available[name];
      };
      BitmapFont2.from = function(name, textStyle, options) {
        if (!name) {
          throw new Error("[BitmapFont] Property `name` is required.");
        }
        var _a2 = Object.assign({}, BitmapFont2.defaultOptions, options), chars = _a2.chars, padding = _a2.padding, resolution = _a2.resolution, textureWidth = _a2.textureWidth, textureHeight = _a2.textureHeight;
        var charsList = resolveCharacters(chars);
        var style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);
        var lineWidth = textureWidth;
        var fontData = new BitmapFontData();
        fontData.info[0] = {
          face: style.fontFamily,
          size: style.fontSize
        };
        fontData.common[0] = {
          lineHeight: style.fontSize
        };
        var positionX = 0;
        var positionY = 0;
        var canvas;
        var context3;
        var baseTexture;
        var maxCharHeight = 0;
        var textures = [];
        for (var i = 0; i < charsList.length; i++) {
          if (!canvas) {
            canvas = document.createElement("canvas");
            canvas.width = textureWidth;
            canvas.height = textureHeight;
            context3 = canvas.getContext("2d");
            baseTexture = new BaseTexture(canvas, { resolution });
            textures.push(new Texture(baseTexture));
            fontData.page.push({
              id: textures.length - 1,
              file: ""
            });
          }
          var metrics = TextMetrics.measureText(charsList[i], style, false, canvas);
          var width = metrics.width;
          var height = Math.ceil(metrics.height);
          var textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width);
          if (positionY >= textureHeight - height * resolution) {
            if (positionY === 0) {
              throw new Error("[BitmapFont] textureHeight " + textureHeight + "px is " + ("too small for " + style.fontSize + "px fonts"));
            }
            --i;
            canvas = null;
            context3 = null;
            baseTexture = null;
            positionY = 0;
            positionX = 0;
            maxCharHeight = 0;
            continue;
          }
          maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight);
          if (textureGlyphWidth * resolution + positionX >= lineWidth) {
            --i;
            positionY += maxCharHeight * resolution;
            positionY = Math.ceil(positionY);
            positionX = 0;
            maxCharHeight = 0;
            continue;
          }
          drawGlyph(canvas, context3, metrics, positionX, positionY, resolution, style);
          var id = extractCharCode(metrics.text);
          fontData.char.push({
            id,
            page: textures.length - 1,
            x: positionX / resolution,
            y: positionY / resolution,
            width: textureGlyphWidth,
            height,
            xoffset: 0,
            yoffset: 0,
            xadvance: Math.ceil(width - (style.dropShadow ? style.dropShadowDistance : 0) - (style.stroke ? style.strokeThickness : 0))
          });
          positionX += (textureGlyphWidth + 2 * padding) * resolution;
          positionX = Math.ceil(positionX);
        }
        for (var i = 0, len = charsList.length; i < len; i++) {
          var first = charsList[i];
          for (var j = 0; j < len; j++) {
            var second = charsList[j];
            var c1 = context3.measureText(first).width;
            var c2 = context3.measureText(second).width;
            var total = context3.measureText(first + second).width;
            var amount = total - (c1 + c2);
            if (amount) {
              fontData.kerning.push({
                first: extractCharCode(first),
                second: extractCharCode(second),
                amount
              });
            }
          }
        }
        var font = new BitmapFont2(fontData, textures, true);
        if (BitmapFont2.available[name] !== void 0) {
          BitmapFont2.uninstall(name);
        }
        BitmapFont2.available[name] = font;
        return font;
      };
      BitmapFont2.ALPHA = [["a", "z"], ["A", "Z"], " "];
      BitmapFont2.NUMERIC = [["0", "9"]];
      BitmapFont2.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
      BitmapFont2.ASCII = [[" ", "~"]];
      BitmapFont2.defaultOptions = {
        resolution: 1,
        textureWidth: 512,
        textureHeight: 512,
        padding: 4,
        chars: BitmapFont2.ALPHANUMERIC
      };
      BitmapFont2.available = {};
      return BitmapFont2;
    }()
  );
  var msdfFrag = "// Pixi texture info\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\n// Tint\r\nuniform vec4 uColor;\r\n\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r\nuniform float uFWidth;\r\n\r\nvoid main(void) {\r\n\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\r\n\r\n  // MSDF\r\n  float median = texColor.r + texColor.g + texColor.b -\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\r\n                  max(texColor.r, max(texColor.g, texColor.b));\r\n  // SDF\r\n  median = min(median, texColor.a);\r\n\r\n  float screenPxDistance = uFWidth * (median - 0.5);\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r\n\r\n  // NPM Textures, NPM outputs\r\n  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\r\n\r\n}\r\n";
  var msdfVert = "// Mesh material default fragment\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n";
  var pageMeshDataDefaultPageMeshData = [];
  var pageMeshDataMSDFPageMeshData = [];
  var charRenderDataPool = [];
  var BitmapText = (
    /** @class */
    function(_super) {
      __extends11(BitmapText2, _super);
      function BitmapText2(text, style) {
        if (style === void 0) {
          style = {};
        }
        var _this = _super.call(this) || this;
        _this._tint = 16777215;
        var _a2 = Object.assign({}, BitmapText2.styleDefaults, style), align = _a2.align, tint = _a2.tint, maxWidth = _a2.maxWidth, letterSpacing = _a2.letterSpacing, fontName = _a2.fontName, fontSize = _a2.fontSize;
        if (!BitmapFont.available[fontName]) {
          throw new Error('Missing BitmapFont "' + fontName + '"');
        }
        _this._activePagesMeshData = [];
        _this._textWidth = 0;
        _this._textHeight = 0;
        _this._align = align;
        _this._tint = tint;
        _this._fontName = fontName;
        _this._fontSize = fontSize || BitmapFont.available[fontName].size;
        _this.text = text;
        _this._maxWidth = maxWidth;
        _this._maxLineHeight = 0;
        _this._letterSpacing = letterSpacing;
        _this._anchor = new ObservablePoint(function() {
          _this.dirty = true;
        }, _this, 0, 0);
        _this._roundPixels = settings.ROUND_PIXELS;
        _this.dirty = true;
        _this._resolution = settings.RESOLUTION;
        _this._autoResolution = true;
        _this._textureCache = {};
        return _this;
      }
      BitmapText2.prototype.updateText = function() {
        var _a2;
        var data = BitmapFont.available[this._fontName];
        var scale = this._fontSize / data.size;
        var pos = new Point();
        var chars = [];
        var lineWidths = [];
        var lineSpaces = [];
        var text = this._text.replace(/(?:\r\n|\r)/g, "\n") || " ";
        var charsInput = splitTextToCharacters(text);
        var maxWidth = this._maxWidth * data.size / this._fontSize;
        var pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
        var prevCharCode = null;
        var lastLineWidth = 0;
        var maxLineWidth = 0;
        var line = 0;
        var lastBreakPos = -1;
        var lastBreakWidth = 0;
        var spacesRemoved = 0;
        var maxLineHeight = 0;
        var spaceCount = 0;
        for (var i = 0; i < charsInput.length; i++) {
          var char = charsInput[i];
          var charCode = extractCharCode(char);
          if (/(?:\s)/.test(char)) {
            lastBreakPos = i;
            lastBreakWidth = lastLineWidth;
            spaceCount++;
          }
          if (char === "\r" || char === "\n") {
            lineWidths.push(lastLineWidth);
            lineSpaces.push(-1);
            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
            ++line;
            ++spacesRemoved;
            pos.x = 0;
            pos.y += data.lineHeight;
            prevCharCode = null;
            spaceCount = 0;
            continue;
          }
          var charData = data.chars[charCode];
          if (!charData) {
            continue;
          }
          if (prevCharCode && charData.kerning[prevCharCode]) {
            pos.x += charData.kerning[prevCharCode];
          }
          var charRenderData = charRenderDataPool.pop() || {
            texture: Texture.EMPTY,
            line: 0,
            charCode: 0,
            prevSpaces: 0,
            position: new Point()
          };
          charRenderData.texture = charData.texture;
          charRenderData.line = line;
          charRenderData.charCode = charCode;
          charRenderData.position.x = pos.x + charData.xOffset + this._letterSpacing / 2;
          charRenderData.position.y = pos.y + charData.yOffset;
          charRenderData.prevSpaces = spaceCount;
          chars.push(charRenderData);
          lastLineWidth = charRenderData.position.x + Math.max(charData.xAdvance, charData.texture.orig.width);
          pos.x += charData.xAdvance + this._letterSpacing;
          maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height);
          prevCharCode = charCode;
          if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {
            ++spacesRemoved;
            removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);
            i = lastBreakPos;
            lastBreakPos = -1;
            lineWidths.push(lastBreakWidth);
            lineSpaces.push(chars.length > 0 ? chars[chars.length - 1].prevSpaces : 0);
            maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);
            line++;
            pos.x = 0;
            pos.y += data.lineHeight;
            prevCharCode = null;
            spaceCount = 0;
          }
        }
        var lastChar = charsInput[charsInput.length - 1];
        if (lastChar !== "\r" && lastChar !== "\n") {
          if (/(?:\s)/.test(lastChar)) {
            lastLineWidth = lastBreakWidth;
          }
          lineWidths.push(lastLineWidth);
          maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
          lineSpaces.push(-1);
        }
        var lineAlignOffsets = [];
        for (var i = 0; i <= line; i++) {
          var alignOffset = 0;
          if (this._align === "right") {
            alignOffset = maxLineWidth - lineWidths[i];
          } else if (this._align === "center") {
            alignOffset = (maxLineWidth - lineWidths[i]) / 2;
          } else if (this._align === "justify") {
            alignOffset = lineSpaces[i] < 0 ? 0 : (maxLineWidth - lineWidths[i]) / lineSpaces[i];
          }
          lineAlignOffsets.push(alignOffset);
        }
        var lenChars = chars.length;
        var pagesMeshData = {};
        var newPagesMeshData = [];
        var activePagesMeshData = this._activePagesMeshData;
        for (var i = 0; i < activePagesMeshData.length; i++) {
          pageMeshDataPool.push(activePagesMeshData[i]);
        }
        for (var i = 0; i < lenChars; i++) {
          var texture = chars[i].texture;
          var baseTextureUid = texture.baseTexture.uid;
          if (!pagesMeshData[baseTextureUid]) {
            var pageMeshData = pageMeshDataPool.pop();
            if (!pageMeshData) {
              var geometry = new MeshGeometry();
              var material = void 0;
              var meshBlendMode = void 0;
              if (data.distanceFieldType === "none") {
                material = new MeshMaterial(Texture.EMPTY);
                meshBlendMode = BLEND_MODES.NORMAL;
              } else {
                material = new MeshMaterial(Texture.EMPTY, { program: Program.from(msdfVert, msdfFrag), uniforms: { uFWidth: 0 } });
                meshBlendMode = BLEND_MODES.NORMAL_NPM;
              }
              var mesh = new Mesh(geometry, material);
              mesh.blendMode = meshBlendMode;
              pageMeshData = {
                index: 0,
                indexCount: 0,
                vertexCount: 0,
                uvsCount: 0,
                total: 0,
                mesh,
                vertices: null,
                uvs: null,
                indices: null
              };
            }
            pageMeshData.index = 0;
            pageMeshData.indexCount = 0;
            pageMeshData.vertexCount = 0;
            pageMeshData.uvsCount = 0;
            pageMeshData.total = 0;
            var _textureCache = this._textureCache;
            _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new Texture(texture.baseTexture);
            pageMeshData.mesh.texture = _textureCache[baseTextureUid];
            pageMeshData.mesh.tint = this._tint;
            newPagesMeshData.push(pageMeshData);
            pagesMeshData[baseTextureUid] = pageMeshData;
          }
          pagesMeshData[baseTextureUid].total++;
        }
        for (var i = 0; i < activePagesMeshData.length; i++) {
          if (newPagesMeshData.indexOf(activePagesMeshData[i]) === -1) {
            this.removeChild(activePagesMeshData[i].mesh);
          }
        }
        for (var i = 0; i < newPagesMeshData.length; i++) {
          if (newPagesMeshData[i].mesh.parent !== this) {
            this.addChild(newPagesMeshData[i].mesh);
          }
        }
        this._activePagesMeshData = newPagesMeshData;
        for (var i in pagesMeshData) {
          var pageMeshData = pagesMeshData[i];
          var total = pageMeshData.total;
          if (!(((_a2 = pageMeshData.indices) === null || _a2 === void 0 ? void 0 : _a2.length) > 6 * total) || pageMeshData.vertices.length < Mesh.BATCHABLE_SIZE * 2) {
            pageMeshData.vertices = new Float32Array(4 * 2 * total);
            pageMeshData.uvs = new Float32Array(4 * 2 * total);
            pageMeshData.indices = new Uint16Array(6 * total);
          } else {
            var total_1 = pageMeshData.total;
            var vertices = pageMeshData.vertices;
            for (var i_1 = total_1 * 4 * 2; i_1 < vertices.length; i_1++) {
              vertices[i_1] = 0;
            }
          }
          pageMeshData.mesh.size = 6 * total;
        }
        for (var i = 0; i < lenChars; i++) {
          var char = chars[i];
          var offset = char.position.x + lineAlignOffsets[char.line] * (this._align === "justify" ? char.prevSpaces : 1);
          if (this._roundPixels) {
            offset = Math.round(offset);
          }
          var xPos = offset * scale;
          var yPos = char.position.y * scale;
          var texture = char.texture;
          var pageMesh = pagesMeshData[texture.baseTexture.uid];
          var textureFrame = texture.frame;
          var textureUvs = texture._uvs;
          var index = pageMesh.index++;
          pageMesh.indices[index * 6 + 0] = 0 + index * 4;
          pageMesh.indices[index * 6 + 1] = 1 + index * 4;
          pageMesh.indices[index * 6 + 2] = 2 + index * 4;
          pageMesh.indices[index * 6 + 3] = 0 + index * 4;
          pageMesh.indices[index * 6 + 4] = 2 + index * 4;
          pageMesh.indices[index * 6 + 5] = 3 + index * 4;
          pageMesh.vertices[index * 8 + 0] = xPos;
          pageMesh.vertices[index * 8 + 1] = yPos;
          pageMesh.vertices[index * 8 + 2] = xPos + textureFrame.width * scale;
          pageMesh.vertices[index * 8 + 3] = yPos;
          pageMesh.vertices[index * 8 + 4] = xPos + textureFrame.width * scale;
          pageMesh.vertices[index * 8 + 5] = yPos + textureFrame.height * scale;
          pageMesh.vertices[index * 8 + 6] = xPos;
          pageMesh.vertices[index * 8 + 7] = yPos + textureFrame.height * scale;
          pageMesh.uvs[index * 8 + 0] = textureUvs.x0;
          pageMesh.uvs[index * 8 + 1] = textureUvs.y0;
          pageMesh.uvs[index * 8 + 2] = textureUvs.x1;
          pageMesh.uvs[index * 8 + 3] = textureUvs.y1;
          pageMesh.uvs[index * 8 + 4] = textureUvs.x2;
          pageMesh.uvs[index * 8 + 5] = textureUvs.y2;
          pageMesh.uvs[index * 8 + 6] = textureUvs.x3;
          pageMesh.uvs[index * 8 + 7] = textureUvs.y3;
        }
        this._textWidth = maxLineWidth * scale;
        this._textHeight = (pos.y + data.lineHeight) * scale;
        for (var i in pagesMeshData) {
          var pageMeshData = pagesMeshData[i];
          if (this.anchor.x !== 0 || this.anchor.y !== 0) {
            var vertexCount = 0;
            var anchorOffsetX = this._textWidth * this.anchor.x;
            var anchorOffsetY = this._textHeight * this.anchor.y;
            for (var i_2 = 0; i_2 < pageMeshData.total; i_2++) {
              pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
            }
          }
          this._maxLineHeight = maxLineHeight * scale;
          var vertexBuffer = pageMeshData.mesh.geometry.getBuffer("aVertexPosition");
          var textureBuffer = pageMeshData.mesh.geometry.getBuffer("aTextureCoord");
          var indexBuffer = pageMeshData.mesh.geometry.getIndex();
          vertexBuffer.data = pageMeshData.vertices;
          textureBuffer.data = pageMeshData.uvs;
          indexBuffer.data = pageMeshData.indices;
          vertexBuffer.update();
          textureBuffer.update();
          indexBuffer.update();
        }
        for (var i = 0; i < chars.length; i++) {
          charRenderDataPool.push(chars[i]);
        }
      };
      BitmapText2.prototype.updateTransform = function() {
        this.validate();
        this.containerUpdateTransform();
      };
      BitmapText2.prototype._render = function(renderer) {
        if (this._autoResolution && this._resolution !== renderer.resolution) {
          this._resolution = renderer.resolution;
          this.dirty = true;
        }
        var _a2 = BitmapFont.available[this._fontName], distanceFieldRange = _a2.distanceFieldRange, distanceFieldType = _a2.distanceFieldType, size = _a2.size;
        if (distanceFieldType !== "none") {
          var _b = this.worldTransform, a = _b.a, b = _b.b, c = _b.c, d = _b.d;
          var dx = Math.sqrt(a * a + b * b);
          var dy = Math.sqrt(c * c + d * d);
          var worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;
          var fontScale = this._fontSize / size;
          for (var _i = 0, _c = this._activePagesMeshData; _i < _c.length; _i++) {
            var mesh = _c[_i];
            mesh.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * this._resolution;
          }
        }
        _super.prototype._render.call(this, renderer);
      };
      BitmapText2.prototype.getLocalBounds = function() {
        this.validate();
        return _super.prototype.getLocalBounds.call(this);
      };
      BitmapText2.prototype.validate = function() {
        if (this.dirty) {
          this.updateText();
          this.dirty = false;
        }
      };
      Object.defineProperty(BitmapText2.prototype, "tint", {
        /**
         * The tint of the BitmapText object.
         * @default 0xffffff
         */
        get: function() {
          return this._tint;
        },
        set: function(value) {
          if (this._tint === value) {
            return;
          }
          this._tint = value;
          for (var i = 0; i < this._activePagesMeshData.length; i++) {
            this._activePagesMeshData[i].mesh.tint = value;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText2.prototype, "align", {
        /**
         * The alignment of the BitmapText object.
         * @member {string}
         * @default 'left'
         */
        get: function() {
          return this._align;
        },
        set: function(value) {
          if (this._align !== value) {
            this._align = value;
            this.dirty = true;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText2.prototype, "fontName", {
        /** The name of the BitmapFont. */
        get: function() {
          return this._fontName;
        },
        set: function(value) {
          if (!BitmapFont.available[value]) {
            throw new Error('Missing BitmapFont "' + value + '"');
          }
          if (this._fontName !== value) {
            this._fontName = value;
            this.dirty = true;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText2.prototype, "fontSize", {
        /** The size of the font to display. */
        get: function() {
          return this._fontSize;
        },
        set: function(value) {
          if (this._fontSize !== value) {
            this._fontSize = value;
            this.dirty = true;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText2.prototype, "anchor", {
        /**
         * The anchor sets the origin point of the text.
         *
         * The default is `(0,0)`, this means the text's origin is the top left.
         *
         * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.
         *
         * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.
         */
        get: function() {
          return this._anchor;
        },
        set: function(value) {
          if (typeof value === "number") {
            this._anchor.set(value);
          } else {
            this._anchor.copyFrom(value);
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText2.prototype, "text", {
        /** The text of the BitmapText object. */
        get: function() {
          return this._text;
        },
        set: function(text) {
          text = String(text === null || text === void 0 ? "" : text);
          if (this._text === text) {
            return;
          }
          this._text = text;
          this.dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText2.prototype, "maxWidth", {
        /**
         * The max width of this bitmap text in pixels. If the text provided is longer than the
         * value provided, line breaks will be automatically inserted in the last whitespace.
         * Disable by setting the value to 0.
         */
        get: function() {
          return this._maxWidth;
        },
        set: function(value) {
          if (this._maxWidth === value) {
            return;
          }
          this._maxWidth = value;
          this.dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText2.prototype, "maxLineHeight", {
        /**
         * The max line height. This is useful when trying to use the total height of the Text,
         * i.e. when trying to vertically align.
         * @readonly
         */
        get: function() {
          this.validate();
          return this._maxLineHeight;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText2.prototype, "textWidth", {
        /**
         * The width of the overall text, different from fontSize,
         * which is defined in the style object.
         * @readonly
         */
        get: function() {
          this.validate();
          return this._textWidth;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText2.prototype, "letterSpacing", {
        /** Additional space between characters. */
        get: function() {
          return this._letterSpacing;
        },
        set: function(value) {
          if (this._letterSpacing !== value) {
            this._letterSpacing = value;
            this.dirty = true;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText2.prototype, "roundPixels", {
        /**
         * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
         * Advantages can include sharper image quality (like text) and faster rendering on canvas.
         * The main disadvantage is movement of objects may appear less smooth.
         * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
         * @default PIXI.settings.ROUND_PIXELS
         */
        get: function() {
          return this._roundPixels;
        },
        set: function(value) {
          if (value !== this._roundPixels) {
            this._roundPixels = value;
            this.dirty = true;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText2.prototype, "textHeight", {
        /**
         * The height of the overall text, different from fontSize,
         * which is defined in the style object.
         * @readonly
         */
        get: function() {
          this.validate();
          return this._textHeight;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText2.prototype, "resolution", {
        /**
         * The resolution / device pixel ratio of the canvas.
         *
         * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
         * @default 1
         */
        get: function() {
          return this._resolution;
        },
        set: function(value) {
          this._autoResolution = false;
          if (this._resolution === value) {
            return;
          }
          this._resolution = value;
          this.dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      BitmapText2.prototype.destroy = function(options) {
        var _textureCache = this._textureCache;
        for (var id in _textureCache) {
          var texture = _textureCache[id];
          texture.destroy();
          delete _textureCache[id];
        }
        this._textureCache = null;
        _super.prototype.destroy.call(this, options);
      };
      BitmapText2.styleDefaults = {
        align: "left",
        tint: 16777215,
        maxWidth: 0,
        letterSpacing: 0
      };
      return BitmapText2;
    }(Container)
  );
  var BitmapFontLoader = (
    /** @class */
    function() {
      function BitmapFontLoader2() {
      }
      BitmapFontLoader2.add = function() {
        LoaderResource.setExtensionXhrType("fnt", LoaderResource.XHR_RESPONSE_TYPE.TEXT);
      };
      BitmapFontLoader2.use = function(resource, next) {
        var format3 = autoDetectFormat(resource.data);
        if (!format3) {
          next();
          return;
        }
        var baseUrl = BitmapFontLoader2.getBaseUrl(this, resource);
        var data = format3.parse(resource.data);
        var textures = {};
        var completed = function(page) {
          textures[page.metadata.pageFile] = page.texture;
          if (Object.keys(textures).length === data.page.length) {
            resource.bitmapFont = BitmapFont.install(data, textures, true);
            next();
          }
        };
        for (var i = 0; i < data.page.length; ++i) {
          var pageFile = data.page[i].file;
          var url3 = baseUrl + pageFile;
          var exists = false;
          for (var name in this.resources) {
            var bitmapResource = this.resources[name];
            if (bitmapResource.url === url3) {
              bitmapResource.metadata.pageFile = pageFile;
              if (bitmapResource.texture) {
                completed(bitmapResource);
              } else {
                bitmapResource.onAfterMiddleware.add(completed);
              }
              exists = true;
              break;
            }
          }
          if (!exists) {
            var options = {
              crossOrigin: resource.crossOrigin,
              loadType: LoaderResource.LOAD_TYPE.IMAGE,
              metadata: Object.assign({ pageFile }, resource.metadata.imageMetadata),
              parentResource: resource
            };
            this.add(url3, options, completed);
          }
        }
      };
      BitmapFontLoader2.getBaseUrl = function(loader, resource) {
        var resUrl = !resource.isDataUrl ? BitmapFontLoader2.dirname(resource.url) : "";
        if (resource.isDataUrl) {
          if (resUrl === ".") {
            resUrl = "";
          }
          if (loader.baseUrl && resUrl) {
            if (loader.baseUrl.charAt(loader.baseUrl.length - 1) === "/") {
              resUrl += "/";
            }
          }
        }
        resUrl = resUrl.replace(loader.baseUrl, "");
        if (resUrl && resUrl.charAt(resUrl.length - 1) !== "/") {
          resUrl += "/";
        }
        return resUrl;
      };
      BitmapFontLoader2.dirname = function(url3) {
        var dir = url3.replace(/\\/g, "/").replace(/\/$/, "").replace(/\/[^\/]*$/, "");
        if (dir === url3) {
          return ".";
        } else if (dir === "") {
          return "/";
        }
        return dir;
      };
      return BitmapFontLoader2;
    }()
  );

  // node_modules/@pixi/canvas-graphics/dist/esm/canvas-graphics.js
  var PolygonUtils = (
    /** @class */
    function() {
      function PolygonUtils2() {
      }
      PolygonUtils2.offsetPolygon = function(points, offset) {
        var offsetPoints = [];
        var length = points.length;
        offset = PolygonUtils2.isPolygonClockwise(points) ? offset : -1 * offset;
        for (var j = 0; j < length; j += 2) {
          var i = j - 2;
          if (i < 0) {
            i += length;
          }
          var k = (j + 2) % length;
          var v1x = points[j] - points[i];
          var v1y = points[j + 1] - points[i + 1];
          var len = Math.sqrt(v1x * v1x + v1y * v1y);
          v1x /= len;
          v1y /= len;
          v1x *= offset;
          v1y *= offset;
          var norm1x = -v1y;
          var norm1y = v1x;
          var pij1 = [points[i] + norm1x, points[i + 1] + norm1y];
          var pij2 = [points[j] + norm1x, points[j + 1] + norm1y];
          var v2x = points[k] - points[j];
          var v2y = points[k + 1] - points[j + 1];
          len = Math.sqrt(v2x * v2x + v2y * v2y);
          v2x /= len;
          v2y /= len;
          v2x *= offset;
          v2y *= offset;
          var norm2x = -v2y;
          var norm2y = v2x;
          var pjk1 = [points[j] + norm2x, points[j + 1] + norm2y];
          var pjk2 = [points[k] + norm2x, points[k + 1] + norm2y];
          var intersectPoint = PolygonUtils2.findIntersection(pij1[0], pij1[1], pij2[0], pij2[1], pjk1[0], pjk1[1], pjk2[0], pjk2[1]);
          if (intersectPoint) {
            offsetPoints.push.apply(offsetPoints, intersectPoint);
          }
        }
        return offsetPoints;
      };
      PolygonUtils2.findIntersection = function(x1, y1, x2, y2, x3, y3, x4, y4) {
        var denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
        var numeratorA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
        var numeratorB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
        if (denominator === 0) {
          if (numeratorA === 0 && numeratorB === 0) {
            return [(x1 + x2) / 2, (y1 + y2) / 2];
          }
          return null;
        }
        var uA = numeratorA / denominator;
        return [x1 + uA * (x2 - x1), y1 + uA * (y2 - y1)];
      };
      PolygonUtils2.isPolygonClockwise = function(polygon) {
        var sum = 0;
        for (var i = 0, j = polygon.length - 2; i < polygon.length; j = i, i += 2) {
          sum += (polygon[i] - polygon[j]) * (polygon[i + 1] + polygon[j + 1]);
        }
        return sum > 0;
      };
      return PolygonUtils2;
    }()
  );
  var CanvasGraphicsRenderer = (
    /** @class */
    function() {
      function CanvasGraphicsRenderer2(renderer) {
        this._svgMatrix = null;
        this._tempMatrix = new Matrix();
        this.renderer = renderer;
      }
      CanvasGraphicsRenderer2.prototype._calcCanvasStyle = function(style, tint) {
        var res;
        if (style.texture && style.texture.baseTexture !== Texture.WHITE.baseTexture) {
          if (style.texture.valid) {
            res = canvasUtils.getTintedPattern(style.texture, tint);
            this.setPatternTransform(res, style.matrix || Matrix.IDENTITY);
          } else {
            res = "#808080";
          }
        } else {
          res = "#" + ("00000" + (tint | 0).toString(16)).slice(-6);
        }
        return res;
      };
      CanvasGraphicsRenderer2.prototype.render = function(graphics) {
        var renderer = this.renderer;
        var context3 = renderer.context;
        var worldAlpha = graphics.worldAlpha;
        var transform = graphics.transform.worldTransform;
        renderer.setContextTransform(transform);
        renderer.setBlendMode(graphics.blendMode);
        var graphicsData = graphics.geometry.graphicsData;
        var contextFillStyle;
        var contextStrokeStyle;
        var tintR = (graphics.tint >> 16 & 255) / 255;
        var tintG = (graphics.tint >> 8 & 255) / 255;
        var tintB = (graphics.tint & 255) / 255;
        for (var i = 0; i < graphicsData.length; i++) {
          var data = graphicsData[i];
          var shape = data.shape;
          var fillStyle = data.fillStyle;
          var lineStyle = data.lineStyle;
          var fillColor = data.fillStyle.color | 0;
          var lineColor = data.lineStyle.color | 0;
          if (data.matrix) {
            renderer.setContextTransform(transform.copyTo(this._tempMatrix).append(data.matrix));
          }
          if (fillStyle.visible) {
            var fillTint = ((fillColor >> 16 & 255) / 255 * tintR * 255 << 16) + ((fillColor >> 8 & 255) / 255 * tintG * 255 << 8) + (fillColor & 255) / 255 * tintB * 255;
            contextFillStyle = this._calcCanvasStyle(fillStyle, fillTint);
          }
          if (lineStyle.visible) {
            var lineTint = ((lineColor >> 16 & 255) / 255 * tintR * 255 << 16) + ((lineColor >> 8 & 255) / 255 * tintG * 255 << 8) + (lineColor & 255) / 255 * tintB * 255;
            contextStrokeStyle = this._calcCanvasStyle(lineStyle, lineTint);
          }
          context3.lineWidth = lineStyle.width;
          context3.lineCap = lineStyle.cap;
          context3.lineJoin = lineStyle.join;
          context3.miterLimit = lineStyle.miterLimit;
          if (data.type === SHAPES.POLY) {
            context3.beginPath();
            var tempShape = shape;
            var points = tempShape.points;
            var holes = data.holes;
            var outerArea = void 0;
            var innerArea = void 0;
            var px = void 0;
            var py = void 0;
            var holesDirection = void 0;
            context3.moveTo(points[0], points[1]);
            for (var j = 2; j < points.length; j += 2) {
              context3.lineTo(points[j], points[j + 1]);
            }
            if (tempShape.closeStroke) {
              context3.closePath();
            }
            if (holes.length > 0) {
              holesDirection = [];
              outerArea = 0;
              px = points[0];
              py = points[1];
              for (var j = 2; j + 2 < points.length; j += 2) {
                outerArea += (points[j] - px) * (points[j + 3] - py) - (points[j + 2] - px) * (points[j + 1] - py);
              }
              for (var k = 0; k < holes.length; k++) {
                points = holes[k].shape.points;
                if (!points) {
                  continue;
                }
                innerArea = 0;
                px = points[0];
                py = points[1];
                for (var j = 2; j + 2 < points.length; j += 2) {
                  innerArea += (points[j] - px) * (points[j + 3] - py) - (points[j + 2] - px) * (points[j + 1] - py);
                }
                if (innerArea * outerArea < 0) {
                  context3.moveTo(points[0], points[1]);
                  for (var j = 2; j < points.length; j += 2) {
                    context3.lineTo(points[j], points[j + 1]);
                  }
                } else {
                  context3.moveTo(points[points.length - 2], points[points.length - 1]);
                  for (var j = points.length - 4; j >= 0; j -= 2) {
                    context3.lineTo(points[j], points[j + 1]);
                  }
                }
                if (holes[k].shape.closeStroke) {
                  context3.closePath();
                }
                holesDirection[k] = innerArea * outerArea < 0;
              }
            }
            if (fillStyle.visible) {
              context3.globalAlpha = fillStyle.alpha * worldAlpha;
              context3.fillStyle = contextFillStyle;
              context3.fill();
            }
            if (lineStyle.visible) {
              this.paintPolygonStroke(tempShape, lineStyle, contextStrokeStyle, holes, holesDirection, worldAlpha, context3);
            }
          } else if (data.type === SHAPES.RECT) {
            var tempShape = shape;
            if (fillStyle.visible) {
              context3.globalAlpha = fillStyle.alpha * worldAlpha;
              context3.fillStyle = contextFillStyle;
              context3.fillRect(tempShape.x, tempShape.y, tempShape.width, tempShape.height);
            }
            if (lineStyle.visible) {
              var alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));
              var width = tempShape.width + 2 * alignmentOffset;
              var height = tempShape.height + 2 * alignmentOffset;
              context3.globalAlpha = lineStyle.alpha * worldAlpha;
              context3.strokeStyle = contextStrokeStyle;
              context3.strokeRect(tempShape.x - alignmentOffset, tempShape.y - alignmentOffset, width, height);
            }
          } else if (data.type === SHAPES.CIRC) {
            var tempShape = shape;
            context3.beginPath();
            context3.arc(tempShape.x, tempShape.y, tempShape.radius, 0, 2 * Math.PI);
            context3.closePath();
            if (fillStyle.visible) {
              context3.globalAlpha = fillStyle.alpha * worldAlpha;
              context3.fillStyle = contextFillStyle;
              context3.fill();
            }
            if (lineStyle.visible) {
              if (lineStyle.alignment !== 0.5) {
                var alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));
                context3.beginPath();
                context3.arc(tempShape.x, tempShape.y, tempShape.radius + alignmentOffset, 0, 2 * Math.PI);
                context3.closePath();
              }
              context3.globalAlpha = lineStyle.alpha * worldAlpha;
              context3.strokeStyle = contextStrokeStyle;
              context3.stroke();
            }
          } else if (data.type === SHAPES.ELIP) {
            var tempShape = shape;
            var drawShapeOverStroke = lineStyle.alignment === 1;
            if (!drawShapeOverStroke) {
              this.paintEllipse(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context3);
            }
            if (lineStyle.visible) {
              if (lineStyle.alignment !== 0.5) {
                var kappa = 0.5522848;
                var alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));
                var sW = (tempShape.width + alignmentOffset) * 2;
                var sH = (tempShape.height + alignmentOffset) * 2;
                var sX = tempShape.x - sW / 2;
                var sY = tempShape.y - sH / 2;
                var sOx = sW / 2 * kappa;
                var sOy = sH / 2 * kappa;
                var sXe = sX + sW;
                var sYe = sY + sH;
                var sXm = sX + sW / 2;
                var sYm = sY + sH / 2;
                context3.beginPath();
                context3.moveTo(sX, sYm);
                context3.bezierCurveTo(sX, sYm - sOy, sXm - sOx, sY, sXm, sY);
                context3.bezierCurveTo(sXm + sOx, sY, sXe, sYm - sOy, sXe, sYm);
                context3.bezierCurveTo(sXe, sYm + sOy, sXm + sOx, sYe, sXm, sYe);
                context3.bezierCurveTo(sXm - sOx, sYe, sX, sYm + sOy, sX, sYm);
                context3.closePath();
              }
              context3.globalAlpha = lineStyle.alpha * worldAlpha;
              context3.strokeStyle = contextStrokeStyle;
              context3.stroke();
            }
            if (drawShapeOverStroke) {
              this.paintEllipse(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context3);
            }
          } else if (data.type === SHAPES.RREC) {
            var tempShape = shape;
            var drawShapeOverStroke = lineStyle.alignment === 1;
            if (!drawShapeOverStroke) {
              this.paintRoundedRectangle(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context3);
            }
            if (lineStyle.visible) {
              if (lineStyle.alignment !== 0.5) {
                var width = tempShape.width;
                var height = tempShape.height;
                var alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));
                var sRx = tempShape.x - alignmentOffset;
                var sRy = tempShape.y - alignmentOffset;
                var sWidth = tempShape.width + 2 * alignmentOffset;
                var sHeight = tempShape.height + 2 * alignmentOffset;
                var radiusOffset = alignmentOffset * (lineStyle.alignment >= 1 ? Math.min(sWidth / width, sHeight / height) : Math.min(width / sWidth, height / sHeight));
                var sRadius = tempShape.radius + radiusOffset;
                var sMaxRadius = Math.min(sWidth, sHeight) / 2;
                sRadius = sRadius > sMaxRadius ? sMaxRadius : sRadius;
                context3.beginPath();
                context3.moveTo(sRx, sRy + sRadius);
                context3.lineTo(sRx, sRy + sHeight - sRadius);
                context3.quadraticCurveTo(sRx, sRy + sHeight, sRx + sRadius, sRy + sHeight);
                context3.lineTo(sRx + sWidth - sRadius, sRy + sHeight);
                context3.quadraticCurveTo(sRx + sWidth, sRy + sHeight, sRx + sWidth, sRy + sHeight - sRadius);
                context3.lineTo(sRx + sWidth, sRy + sRadius);
                context3.quadraticCurveTo(sRx + sWidth, sRy, sRx + sWidth - sRadius, sRy);
                context3.lineTo(sRx + sRadius, sRy);
                context3.quadraticCurveTo(sRx, sRy, sRx, sRy + sRadius);
                context3.closePath();
              }
              context3.globalAlpha = lineStyle.alpha * worldAlpha;
              context3.strokeStyle = contextStrokeStyle;
              context3.stroke();
            }
            if (drawShapeOverStroke) {
              this.paintRoundedRectangle(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context3);
            }
          }
        }
      };
      CanvasGraphicsRenderer2.prototype.paintPolygonStroke = function(shape, lineStyle, contextStrokeStyle, holes, holesDirection, worldAlpha, context3) {
        if (lineStyle.alignment !== 0.5) {
          var alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));
          var offsetPoints = PolygonUtils.offsetPolygon(shape.points, alignmentOffset);
          var points = void 0;
          context3.beginPath();
          context3.moveTo(offsetPoints[0], offsetPoints[1]);
          for (var j = 2; j < offsetPoints.length; j += 2) {
            context3.lineTo(offsetPoints[j], offsetPoints[j + 1]);
          }
          if (shape.closeStroke) {
            context3.closePath();
          }
          for (var k = 0; k < holes.length; k++) {
            points = holes[k].shape.points;
            offsetPoints = PolygonUtils.offsetPolygon(points, alignmentOffset);
            if (holesDirection[k]) {
              context3.moveTo(offsetPoints[0], offsetPoints[1]);
              for (var j = 2; j < offsetPoints.length; j += 2) {
                context3.lineTo(offsetPoints[j], offsetPoints[j + 1]);
              }
            } else {
              context3.moveTo(offsetPoints[offsetPoints.length - 2], offsetPoints[offsetPoints.length - 1]);
              for (var j = offsetPoints.length - 4; j >= 0; j -= 2) {
                context3.lineTo(offsetPoints[j], offsetPoints[j + 1]);
              }
            }
            if (holes[k].shape.closeStroke) {
              context3.closePath();
            }
          }
        }
        context3.globalAlpha = lineStyle.alpha * worldAlpha;
        context3.strokeStyle = contextStrokeStyle;
        context3.stroke();
      };
      CanvasGraphicsRenderer2.prototype.paintEllipse = function(shape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context3) {
        var w = shape.width * 2;
        var h = shape.height * 2;
        var x = shape.x - w / 2;
        var y = shape.y - h / 2;
        var kappa = 0.5522848;
        var ox = w / 2 * kappa;
        var oy = h / 2 * kappa;
        var xe = x + w;
        var ye = y + h;
        var xm = x + w / 2;
        var ym = y + h / 2;
        if (lineStyle.alignment === 0) {
          context3.save();
        }
        context3.beginPath();
        context3.moveTo(x, ym);
        context3.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
        context3.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
        context3.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
        context3.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
        context3.closePath();
        if (lineStyle.alignment === 0) {
          context3.clip();
        }
        if (fillStyle.visible) {
          context3.globalAlpha = fillStyle.alpha * worldAlpha;
          context3.fillStyle = contextFillStyle;
          context3.fill();
        }
        if (lineStyle.alignment === 0) {
          context3.restore();
        }
      };
      CanvasGraphicsRenderer2.prototype.paintRoundedRectangle = function(shape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context3) {
        var rx = shape.x;
        var ry = shape.y;
        var width = shape.width;
        var height = shape.height;
        var radius = shape.radius;
        var maxRadius = Math.min(width, height) / 2;
        radius = radius > maxRadius ? maxRadius : radius;
        if (lineStyle.alignment === 0) {
          context3.save();
        }
        context3.beginPath();
        context3.moveTo(rx, ry + radius);
        context3.lineTo(rx, ry + height - radius);
        context3.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
        context3.lineTo(rx + width - radius, ry + height);
        context3.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
        context3.lineTo(rx + width, ry + radius);
        context3.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
        context3.lineTo(rx + radius, ry);
        context3.quadraticCurveTo(rx, ry, rx, ry + radius);
        context3.closePath();
        if (lineStyle.alignment === 0) {
          context3.clip();
        }
        if (fillStyle.visible) {
          context3.globalAlpha = fillStyle.alpha * worldAlpha;
          context3.fillStyle = contextFillStyle;
          context3.fill();
        }
        if (lineStyle.alignment === 0) {
          context3.restore();
        }
      };
      CanvasGraphicsRenderer2.prototype.setPatternTransform = function(pattern, matrix) {
        if (this._svgMatrix === false) {
          return;
        }
        if (!this._svgMatrix) {
          var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          if (svg && svg.createSVGMatrix) {
            this._svgMatrix = svg.createSVGMatrix();
          }
          if (!this._svgMatrix || !pattern.setTransform) {
            this._svgMatrix = false;
            return;
          }
        }
        this._svgMatrix.a = matrix.a;
        this._svgMatrix.b = matrix.b;
        this._svgMatrix.c = matrix.c;
        this._svgMatrix.d = matrix.d;
        this._svgMatrix.e = matrix.tx;
        this._svgMatrix.f = matrix.ty;
        pattern.setTransform(this._svgMatrix.inverse());
      };
      CanvasGraphicsRenderer2.prototype.destroy = function() {
        this.renderer = null;
        this._svgMatrix = null;
        this._tempMatrix = null;
      };
      return CanvasGraphicsRenderer2;
    }()
  );
  var canvasRenderer;
  var tempMatrix3 = new Matrix();
  Graphics.prototype.generateCanvasTexture = function generateCanvasTexture(scaleMode, resolution) {
    if (resolution === void 0) {
      resolution = 1;
    }
    var bounds = this.getLocalBounds();
    var canvasBuffer = RenderTexture.create({
      width: bounds.width,
      height: bounds.height,
      scaleMode,
      resolution
    });
    if (!canvasRenderer) {
      canvasRenderer = new CanvasRenderer();
    }
    this.transform.updateLocalTransform();
    this.transform.localTransform.copyTo(tempMatrix3);
    tempMatrix3.invert();
    tempMatrix3.tx -= bounds.x;
    tempMatrix3.ty -= bounds.y;
    canvasRenderer.render(this, { renderTexture: canvasBuffer, clear: true, transform: tempMatrix3 });
    var texture = Texture.from(canvasBuffer.baseTexture._canvasRenderTarget.canvas, {
      scaleMode
    });
    texture.baseTexture.setResolution(resolution);
    return texture;
  };
  Graphics.prototype.cachedGraphicsData = [];
  Graphics.prototype._renderCanvas = function _renderCanvas3(renderer) {
    if (this.isMask === true) {
      return;
    }
    this.finishPoly();
    renderer.plugins.graphics.render(this);
  };

  // node_modules/@pixi/canvas-mesh/dist/esm/canvas-mesh.js
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function createCommonjsModule(fn, basedir, module) {
    return module = {
      path: basedir,
      exports: {},
      require: function(path, base) {
        return commonjsRequire(path, base === void 0 || base === null ? module.path : base);
      }
    }, fn(module, module.exports), module.exports;
  }
  function commonjsRequire() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
  }
  var eventemitter3 = createCommonjsModule(function(module) {
    var has = Object.prototype.hasOwnProperty, prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) {
        prefix = false;
      }
    }
    function EE(fn, context3, once) {
      this.fn = fn;
      this.context = context3;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context3, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context3 || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) {
        emitter._events[evt] = listener, emitter._eventsCount++;
      } else if (!emitter._events[evt].fn) {
        emitter._events[evt].push(listener);
      } else {
        emitter._events[evt] = [emitter._events[evt], listener];
      }
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) {
        emitter._events = new Events();
      } else {
        delete emitter._events[evt];
      }
    }
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) {
        return names;
      }
      for (name in events = this._events) {
        if (has.call(events, name)) {
          names.push(prefix ? name.slice(1) : name);
        }
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) {
        return [];
      }
      if (handlers.fn) {
        return [handlers.fn];
      }
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) {
        return 0;
      }
      if (listeners.fn) {
        return 1;
      }
      return listeners.length;
    };
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var arguments$1 = arguments;
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) {
        return false;
      }
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) {
          this.removeListener(event, listeners.fn, void 0, true);
        }
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments$1[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) {
            this.removeListener(event, listeners[i].fn, void 0, true);
          }
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) {
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments$1[j];
                }
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter.prototype.on = function on(event, fn, context3) {
      return addListener(this, event, fn, context3, false);
    };
    EventEmitter.prototype.once = function once(event, fn, context3) {
      return addListener(this, event, fn, context3, true);
    };
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context3, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) {
        return this;
      }
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context3 || listeners.context === context3)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context3 && listeners[i].context !== context3) {
            events.push(listeners[i]);
          }
        }
        if (events.length) {
          this._events[evt] = events.length === 1 ? events[0] : events;
        } else {
          clearEvent(this, evt);
        }
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) {
          clearEvent(this, evt);
        }
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    EventEmitter.prefixed = prefix;
    EventEmitter.EventEmitter = EventEmitter;
    {
      module.exports = EventEmitter;
    }
  });
  var punycode = createCommonjsModule(function(module, exports) {
    (function(root) {
      var freeExports = exports && !exports.nodeType && exports;
      var freeModule = module && !module.nodeType && module;
      var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
        root = freeGlobal;
      }
      var punycode2, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
      function error(type) {
        throw RangeError(errors[type]);
      }
      function map4(array, fn) {
        var length = array.length;
        var result = [];
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map4(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [], counter = 0, length = string.length, value, extra;
        while (counter < length) {
          value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        return map4(array, function(value) {
          var output = "";
          if (value > 65535) {
            value -= 65536;
            output += stringFromCharCode(value >>> 10 & 1023 | 55296);
            value = 56320 | value & 1023;
          }
          output += stringFromCharCode(value);
          return output;
        }).join("");
      }
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      }
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      function decode2(input) {
        var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;
        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          for (oldi = i, w = 1, k = base; ; k += base) {
            if (index >= inputLength) {
              error("invalid-input");
            }
            digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error("overflow");
            }
            i += digit * w;
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error("overflow");
            }
            w *= baseMinusT;
          }
          out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error("overflow");
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return ucs2encode(output);
      }
      function encode2(input) {
        var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n = initialN;
        delta = 0;
        bias = initialBias;
        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < 128) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output.length;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          for (m = maxInt, j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < n && ++delta > maxInt) {
              error("overflow");
            }
            if (currentValue == n) {
              for (q = delta, k = base; ; k += base) {
                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t) {
                  break;
                }
                qMinusT = q - t;
                baseMinusT = base - t;
                output.push(
                  stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                );
                q = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      }
      function toUnicode(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode2(string.slice(4).toLowerCase()) : string;
        });
      }
      function toASCII(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode2(string) : string;
        });
      }
      punycode2 = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "1.3.2",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode2,
        "encode": encode2,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      if (freeExports && freeModule) {
        if (module.exports == freeExports) {
          freeModule.exports = punycode2;
        } else {
          for (key in punycode2) {
            punycode2.hasOwnProperty(key) && (freeExports[key] = punycode2[key]);
          }
        }
      } else {
        root.punycode = punycode2;
      }
    })(commonjsGlobal);
  });
  var util = {
    isString: function(arg) {
      return typeof arg === "string";
    },
    isObject: function(arg) {
      return typeof arg === "object" && arg !== null;
    },
    isNull: function(arg) {
      return arg === null;
    },
    isNullOrUndefined: function(arg) {
      return arg == null;
    }
  };
  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  var decode = function(qs, sep, eq, options) {
    sep = sep || "&";
    eq = eq || "=";
    var obj = {};
    if (typeof qs !== "string" || qs.length === 0) {
      return obj;
    }
    var regexp = /\+/g;
    qs = qs.split(sep);
    var maxKeys = 1e3;
    if (options && typeof options.maxKeys === "number") {
      maxKeys = options.maxKeys;
    }
    var len = qs.length;
    if (maxKeys > 0 && len > maxKeys) {
      len = maxKeys;
    }
    for (var i = 0; i < len; ++i) {
      var x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v;
      if (idx >= 0) {
        kstr = x.substr(0, idx);
        vstr = x.substr(idx + 1);
      } else {
        kstr = x;
        vstr = "";
      }
      k = decodeURIComponent(kstr);
      v = decodeURIComponent(vstr);
      if (!hasOwnProperty(obj, k)) {
        obj[k] = v;
      } else if (Array.isArray(obj[k])) {
        obj[k].push(v);
      } else {
        obj[k] = [obj[k], v];
      }
    }
    return obj;
  };
  var stringifyPrimitive = function(v) {
    switch (typeof v) {
      case "string":
        return v;
      case "boolean":
        return v ? "true" : "false";
      case "number":
        return isFinite(v) ? v : "";
      default:
        return "";
    }
  };
  var encode = function(obj, sep, eq, name) {
    sep = sep || "&";
    eq = eq || "=";
    if (obj === null) {
      obj = void 0;
    }
    if (typeof obj === "object") {
      return Object.keys(obj).map(function(k) {
        var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
        if (Array.isArray(obj[k])) {
          return obj[k].map(function(v) {
            return ks + encodeURIComponent(stringifyPrimitive(v));
          }).join(sep);
        } else {
          return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
        }
      }).join(sep);
    }
    if (!name) {
      return "";
    }
    return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
  };
  var querystring = createCommonjsModule(function(module, exports) {
    exports.decode = exports.parse = decode;
    exports.encode = exports.stringify = encode;
  });
  var parse2 = urlParse;
  var resolve2 = urlResolve;
  var format2 = urlFormat;
  function Url() {
    this.protocol = null;
    this.slashes = null;
    this.auth = null;
    this.host = null;
    this.port = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.query = null;
    this.pathname = null;
    this.path = null;
    this.href = null;
  }
  var protocolPattern = /^([a-z0-9.+-]+:)/i;
  var portPattern = /:[0-9]*$/;
  var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
  var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
  var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
  var autoEscape = ["'"].concat(unwise);
  var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
  var hostEndingChars = ["/", "?", "#"];
  var hostnameMaxLen = 255;
  var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
  var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
  var unsafeProtocol = {
    "javascript": true,
    "javascript:": true
  };
  var hostlessProtocol = {
    "javascript": true,
    "javascript:": true
  };
  var slashedProtocol = {
    "http": true,
    "https": true,
    "ftp": true,
    "gopher": true,
    "file": true,
    "http:": true,
    "https:": true,
    "ftp:": true,
    "gopher:": true,
    "file:": true
  };
  function urlParse(url3, parseQueryString, slashesDenoteHost) {
    if (url3 && util.isObject(url3) && url3 instanceof Url) {
      return url3;
    }
    var u = new Url();
    u.parse(url3, parseQueryString, slashesDenoteHost);
    return u;
  }
  Url.prototype.parse = function(url3, parseQueryString, slashesDenoteHost) {
    if (!util.isString(url3)) {
      throw new TypeError("Parameter 'url' must be a string, not " + typeof url3);
    }
    var queryIndex = url3.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url3.indexOf("#") ? "?" : "#", uSplit = url3.split(splitter), slashRegex = /\\/g;
    uSplit[0] = uSplit[0].replace(slashRegex, "/");
    url3 = uSplit.join(splitter);
    var rest = url3;
    rest = rest.trim();
    if (!slashesDenoteHost && url3.split("#").length === 1) {
      var simplePath = simplePathPattern.exec(rest);
      if (simplePath) {
        this.path = rest;
        this.href = rest;
        this.pathname = simplePath[1];
        if (simplePath[2]) {
          this.search = simplePath[2];
          if (parseQueryString) {
            this.query = querystring.parse(this.search.substr(1));
          } else {
            this.query = this.search.substr(1);
          }
        } else if (parseQueryString) {
          this.search = "";
          this.query = {};
        }
        return this;
      }
    }
    var proto = protocolPattern.exec(rest);
    if (proto) {
      proto = proto[0];
      var lowerProto = proto.toLowerCase();
      this.protocol = lowerProto;
      rest = rest.substr(proto.length);
    }
    if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
      var slashes = rest.substr(0, 2) === "//";
      if (slashes && !(proto && hostlessProtocol[proto])) {
        rest = rest.substr(2);
        this.slashes = true;
      }
    }
    if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
      var hostEnd = -1;
      for (var i = 0; i < hostEndingChars.length; i++) {
        var hec = rest.indexOf(hostEndingChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
          hostEnd = hec;
        }
      }
      var auth, atSign;
      if (hostEnd === -1) {
        atSign = rest.lastIndexOf("@");
      } else {
        atSign = rest.lastIndexOf("@", hostEnd);
      }
      if (atSign !== -1) {
        auth = rest.slice(0, atSign);
        rest = rest.slice(atSign + 1);
        this.auth = decodeURIComponent(auth);
      }
      hostEnd = -1;
      for (var i = 0; i < nonHostChars.length; i++) {
        var hec = rest.indexOf(nonHostChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
          hostEnd = hec;
        }
      }
      if (hostEnd === -1) {
        hostEnd = rest.length;
      }
      this.host = rest.slice(0, hostEnd);
      rest = rest.slice(hostEnd);
      this.parseHost();
      this.hostname = this.hostname || "";
      var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
      if (!ipv6Hostname) {
        var hostparts = this.hostname.split(/\./);
        for (var i = 0, l = hostparts.length; i < l; i++) {
          var part = hostparts[i];
          if (!part) {
            continue;
          }
          if (!part.match(hostnamePartPattern)) {
            var newpart = "";
            for (var j = 0, k = part.length; j < k; j++) {
              if (part.charCodeAt(j) > 127) {
                newpart += "x";
              } else {
                newpart += part[j];
              }
            }
            if (!newpart.match(hostnamePartPattern)) {
              var validParts = hostparts.slice(0, i);
              var notHost = hostparts.slice(i + 1);
              var bit = part.match(hostnamePartStart);
              if (bit) {
                validParts.push(bit[1]);
                notHost.unshift(bit[2]);
              }
              if (notHost.length) {
                rest = "/" + notHost.join(".") + rest;
              }
              this.hostname = validParts.join(".");
              break;
            }
          }
        }
      }
      if (this.hostname.length > hostnameMaxLen) {
        this.hostname = "";
      } else {
        this.hostname = this.hostname.toLowerCase();
      }
      if (!ipv6Hostname) {
        this.hostname = punycode.toASCII(this.hostname);
      }
      var p = this.port ? ":" + this.port : "";
      var h = this.hostname || "";
      this.host = h + p;
      this.href += this.host;
      if (ipv6Hostname) {
        this.hostname = this.hostname.substr(1, this.hostname.length - 2);
        if (rest[0] !== "/") {
          rest = "/" + rest;
        }
      }
    }
    if (!unsafeProtocol[lowerProto]) {
      for (var i = 0, l = autoEscape.length; i < l; i++) {
        var ae = autoEscape[i];
        if (rest.indexOf(ae) === -1) {
          continue;
        }
        var esc = encodeURIComponent(ae);
        if (esc === ae) {
          esc = escape(ae);
        }
        rest = rest.split(ae).join(esc);
      }
    }
    var hash = rest.indexOf("#");
    if (hash !== -1) {
      this.hash = rest.substr(hash);
      rest = rest.slice(0, hash);
    }
    var qm = rest.indexOf("?");
    if (qm !== -1) {
      this.search = rest.substr(qm);
      this.query = rest.substr(qm + 1);
      if (parseQueryString) {
        this.query = querystring.parse(this.query);
      }
      rest = rest.slice(0, qm);
    } else if (parseQueryString) {
      this.search = "";
      this.query = {};
    }
    if (rest) {
      this.pathname = rest;
    }
    if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
      this.pathname = "/";
    }
    if (this.pathname || this.search) {
      var p = this.pathname || "";
      var s = this.search || "";
      this.path = p + s;
    }
    this.href = this.format();
    return this;
  };
  function urlFormat(obj) {
    if (util.isString(obj)) {
      obj = urlParse(obj);
    }
    if (!(obj instanceof Url)) {
      return Url.prototype.format.call(obj);
    }
    return obj.format();
  }
  Url.prototype.format = function() {
    var auth = this.auth || "";
    if (auth) {
      auth = encodeURIComponent(auth);
      auth = auth.replace(/%3A/i, ":");
      auth += "@";
    }
    var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
    if (this.host) {
      host = auth + this.host;
    } else if (this.hostname) {
      host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
      if (this.port) {
        host += ":" + this.port;
      }
    }
    if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
      query = querystring.stringify(this.query);
    }
    var search = this.search || query && "?" + query || "";
    if (protocol && protocol.substr(-1) !== ":") {
      protocol += ":";
    }
    if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
      host = "//" + (host || "");
      if (pathname && pathname.charAt(0) !== "/") {
        pathname = "/" + pathname;
      }
    } else if (!host) {
      host = "";
    }
    if (hash && hash.charAt(0) !== "#") {
      hash = "#" + hash;
    }
    if (search && search.charAt(0) !== "?") {
      search = "?" + search;
    }
    pathname = pathname.replace(/[?#]/g, function(match) {
      return encodeURIComponent(match);
    });
    search = search.replace("#", "%23");
    return protocol + host + pathname + search + hash;
  };
  function urlResolve(source, relative) {
    return urlParse(source, false, true).resolve(relative);
  }
  Url.prototype.resolve = function(relative) {
    return this.resolveObject(urlParse(relative, false, true)).format();
  };
  Url.prototype.resolveObject = function(relative) {
    if (util.isString(relative)) {
      var rel = new Url();
      rel.parse(relative, false, true);
      relative = rel;
    }
    var result = new Url();
    var tkeys = Object.keys(this);
    for (var tk = 0; tk < tkeys.length; tk++) {
      var tkey = tkeys[tk];
      result[tkey] = this[tkey];
    }
    result.hash = relative.hash;
    if (relative.href === "") {
      result.href = result.format();
      return result;
    }
    if (relative.slashes && !relative.protocol) {
      var rkeys = Object.keys(relative);
      for (var rk = 0; rk < rkeys.length; rk++) {
        var rkey = rkeys[rk];
        if (rkey !== "protocol") {
          result[rkey] = relative[rkey];
        }
      }
      if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
        result.path = result.pathname = "/";
      }
      result.href = result.format();
      return result;
    }
    if (relative.protocol && relative.protocol !== result.protocol) {
      if (!slashedProtocol[relative.protocol]) {
        var keys = Object.keys(relative);
        for (var v = 0; v < keys.length; v++) {
          var k = keys[v];
          result[k] = relative[k];
        }
        result.href = result.format();
        return result;
      }
      result.protocol = relative.protocol;
      if (!relative.host && !hostlessProtocol[relative.protocol]) {
        var relPath = (relative.pathname || "").split("/");
        while (relPath.length && !(relative.host = relPath.shift())) {
        }
        if (!relative.host) {
          relative.host = "";
        }
        if (!relative.hostname) {
          relative.hostname = "";
        }
        if (relPath[0] !== "") {
          relPath.unshift("");
        }
        if (relPath.length < 2) {
          relPath.unshift("");
        }
        result.pathname = relPath.join("/");
      } else {
        result.pathname = relative.pathname;
      }
      result.search = relative.search;
      result.query = relative.query;
      result.host = relative.host || "";
      result.auth = relative.auth;
      result.hostname = relative.hostname || relative.host;
      result.port = relative.port;
      if (result.pathname || result.search) {
        var p = result.pathname || "";
        var s = result.search || "";
        result.path = p + s;
      }
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    }
    var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
    if (psychotic) {
      result.hostname = "";
      result.port = null;
      if (result.host) {
        if (srcPath[0] === "") {
          srcPath[0] = result.host;
        } else {
          srcPath.unshift(result.host);
        }
      }
      result.host = "";
      if (relative.protocol) {
        relative.hostname = null;
        relative.port = null;
        if (relative.host) {
          if (relPath[0] === "") {
            relPath[0] = relative.host;
          } else {
            relPath.unshift(relative.host);
          }
        }
        relative.host = null;
      }
      mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
    }
    if (isRelAbs) {
      result.host = relative.host || relative.host === "" ? relative.host : result.host;
      result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
      result.search = relative.search;
      result.query = relative.query;
      srcPath = relPath;
    } else if (relPath.length) {
      if (!srcPath) {
        srcPath = [];
      }
      srcPath.pop();
      srcPath = srcPath.concat(relPath);
      result.search = relative.search;
      result.query = relative.query;
    } else if (!util.isNullOrUndefined(relative.search)) {
      if (psychotic) {
        result.hostname = result.host = srcPath.shift();
        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }
      result.search = relative.search;
      result.query = relative.query;
      if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
      }
      result.href = result.format();
      return result;
    }
    if (!srcPath.length) {
      result.pathname = null;
      if (result.search) {
        result.path = "/" + result.search;
      } else {
        result.path = null;
      }
      result.href = result.format();
      return result;
    }
    var last = srcPath.slice(-1)[0];
    var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
    var up = 0;
    for (var i = srcPath.length; i >= 0; i--) {
      last = srcPath[i];
      if (last === ".") {
        srcPath.splice(i, 1);
      } else if (last === "..") {
        srcPath.splice(i, 1);
        up++;
      } else if (up) {
        srcPath.splice(i, 1);
        up--;
      }
    }
    if (!mustEndAbs && !removeAllDots) {
      for (; up--; up) {
        srcPath.unshift("..");
      }
    }
    if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
      srcPath.unshift("");
    }
    if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
      srcPath.push("");
    }
    var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
    if (psychotic) {
      result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
      var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    mustEndAbs = mustEndAbs || result.host && srcPath.length;
    if (mustEndAbs && !isAbsolute) {
      srcPath.unshift("");
    }
    if (!srcPath.length) {
      result.pathname = null;
      result.path = null;
    } else {
      result.pathname = srcPath.join("/");
    }
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
    }
    result.auth = relative.auth || result.auth;
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  };
  Url.prototype.parseHost = function() {
    var host = this.host;
    var port = portPattern.exec(host);
    if (port) {
      port = port[0];
      if (port !== ":") {
        this.port = port.substr(1);
      }
      host = host.substr(0, host.length - port.length);
    }
    if (host) {
      this.hostname = host;
    }
  };
  var url2 = {
    parse: parse2,
    format: format2,
    resolve: resolve2
  };
  settings.RETINA_PREFIX = /@([0-9\.]+)x/;
  settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;
  var saidHello2 = false;
  var VERSION2 = "6.4.2";
  function sayHello2(type) {
    var _a2;
    if (saidHello2) {
      return;
    }
    if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
      var args = [
        "\n %c %c %c PixiJS " + VERSION2 + " - \u2730 " + type + " \u2730  %c  %c  http://www.pixijs.com/  %c %c \u2665%c\u2665%c\u2665 \n\n",
        "background: #ff66a5; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "color: #ff66a5; background: #030307; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "background: #ffc3dc; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;"
      ];
      (_a2 = globalThis.console).log.apply(_a2, args);
    } else if (globalThis.console) {
      globalThis.console.log("PixiJS " + VERSION2 + " - " + type + " - http://www.pixijs.com/");
    }
    saidHello2 = true;
  }
  var supported2;
  function isWebGLSupported2() {
    if (typeof supported2 === "undefined") {
      supported2 = function supported3() {
        var contextOptions = {
          stencil: true,
          failIfMajorPerformanceCaveat: settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
        };
        try {
          if (!globalThis.WebGLRenderingContext) {
            return false;
          }
          var canvas = document.createElement("canvas");
          var gl = canvas.getContext("webgl", contextOptions) || canvas.getContext("experimental-webgl", contextOptions);
          var success = !!(gl && gl.getContextAttributes().stencil);
          if (gl) {
            var loseContext = gl.getExtension("WEBGL_lose_context");
            if (loseContext) {
              loseContext.loseContext();
            }
          }
          gl = null;
          return success;
        } catch (e) {
          return false;
        }
      }();
    }
    return supported2;
  }
  function hex2rgb2(hex, out) {
    if (out === void 0) {
      out = [];
    }
    out[0] = (hex >> 16 & 255) / 255;
    out[1] = (hex >> 8 & 255) / 255;
    out[2] = (hex & 255) / 255;
    return out;
  }
  function hex2string2(hex) {
    var hexString = hex.toString(16);
    hexString = "000000".substring(0, 6 - hexString.length) + hexString;
    return "#" + hexString;
  }
  function mapPremultipliedBlendModes2() {
    var pm = [];
    var npm = [];
    for (var i = 0; i < 32; i++) {
      pm[i] = i;
      npm[i] = i;
    }
    pm[BLEND_MODES.NORMAL_NPM] = BLEND_MODES.NORMAL;
    pm[BLEND_MODES.ADD_NPM] = BLEND_MODES.ADD;
    pm[BLEND_MODES.SCREEN_NPM] = BLEND_MODES.SCREEN;
    npm[BLEND_MODES.NORMAL] = BLEND_MODES.NORMAL_NPM;
    npm[BLEND_MODES.ADD] = BLEND_MODES.ADD_NPM;
    npm[BLEND_MODES.SCREEN] = BLEND_MODES.SCREEN_NPM;
    var array = [];
    array.push(npm);
    array.push(pm);
    return array;
  }
  var premultiplyBlendMode2 = mapPremultipliedBlendModes2();
  function premultiplyTint2(tint, alpha) {
    if (alpha === 1) {
      return (alpha * 255 << 24) + tint;
    }
    if (alpha === 0) {
      return 0;
    }
    var R = tint >> 16 & 255;
    var G = tint >> 8 & 255;
    var B = tint & 255;
    R = R * alpha + 0.5 | 0;
    G = G * alpha + 0.5 | 0;
    B = B * alpha + 0.5 | 0;
    return (alpha * 255 << 24) + (R << 16) + (G << 8) + B;
  }
  function getBufferType2(array) {
    if (array.BYTES_PER_ELEMENT === 4) {
      if (array instanceof Float32Array) {
        return "Float32Array";
      } else if (array instanceof Uint32Array) {
        return "Uint32Array";
      }
      return "Int32Array";
    } else if (array.BYTES_PER_ELEMENT === 2) {
      if (array instanceof Uint16Array) {
        return "Uint16Array";
      }
    } else if (array.BYTES_PER_ELEMENT === 1) {
      if (array instanceof Uint8Array) {
        return "Uint8Array";
      }
    }
    return null;
  }
  function nextPow22(v) {
    v += v === 0 ? 1 : 0;
    --v;
    v |= v >>> 1;
    v |= v >>> 2;
    v |= v >>> 4;
    v |= v >>> 8;
    v |= v >>> 16;
    return v + 1;
  }
  function isPow22(v) {
    return !(v & v - 1) && !!v;
  }
  function log22(v) {
    var r = (v > 65535 ? 1 : 0) << 4;
    v >>>= r;
    var shift = (v > 255 ? 1 : 0) << 3;
    v >>>= shift;
    r |= shift;
    shift = (v > 15 ? 1 : 0) << 2;
    v >>>= shift;
    r |= shift;
    shift = (v > 3 ? 1 : 0) << 1;
    v >>>= shift;
    r |= shift;
    return r | v >> 1;
  }
  function removeItems2(arr, startIdx, removeCount) {
    var length = arr.length;
    var i;
    if (startIdx >= length || removeCount === 0) {
      return;
    }
    removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
    var len = length - removeCount;
    for (i = startIdx; i < len; ++i) {
      arr[i] = arr[i + removeCount];
    }
    arr.length = len;
  }
  var nextUid2 = 0;
  function uid2() {
    return ++nextUid2;
  }
  var warnings2 = {};
  function deprecation2(version, message, ignoreDepth) {
    if (ignoreDepth === void 0) {
      ignoreDepth = 3;
    }
    if (warnings2[message]) {
      return;
    }
    var stack = new Error().stack;
    if (typeof stack === "undefined") {
      console.warn("PixiJS Deprecation Warning: ", message + "\nDeprecated since v" + version);
    } else {
      stack = stack.split("\n").splice(ignoreDepth).join("\n");
      if (console.groupCollapsed) {
        console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", message + "\nDeprecated since v" + version);
        console.warn(stack);
        console.groupEnd();
      } else {
        console.warn("PixiJS Deprecation Warning: ", message + "\nDeprecated since v" + version);
        console.warn(stack);
      }
    }
    warnings2[message] = true;
  }
  var ProgramCache2 = {};
  var TextureCache2 = /* @__PURE__ */ Object.create(null);
  var BaseTextureCache2 = /* @__PURE__ */ Object.create(null);
  (function() {
    function CanvasRenderTarget2(width, height, resolution) {
      this.canvas = document.createElement("canvas");
      this.context = this.canvas.getContext("2d");
      this.resolution = resolution || settings.RESOLUTION;
      this.resize(width, height);
    }
    CanvasRenderTarget2.prototype.clear = function() {
      this.context.setTransform(1, 0, 0, 1, 0, 0);
      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    };
    CanvasRenderTarget2.prototype.resize = function(desiredWidth, desiredHeight) {
      this.canvas.width = Math.round(desiredWidth * this.resolution);
      this.canvas.height = Math.round(desiredHeight * this.resolution);
    };
    CanvasRenderTarget2.prototype.destroy = function() {
      this.context = null;
      this.canvas = null;
    };
    Object.defineProperty(CanvasRenderTarget2.prototype, "width", {
      /**
       * The width of the canvas buffer in pixels.
       * @member {number}
       */
      get: function() {
        return this.canvas.width;
      },
      set: function(val) {
        this.canvas.width = Math.round(val);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CanvasRenderTarget2.prototype, "height", {
      /**
       * The height of the canvas buffer in pixels.
       * @member {number}
       */
      get: function() {
        return this.canvas.height;
      },
      set: function(val) {
        this.canvas.height = Math.round(val);
      },
      enumerable: false,
      configurable: true
    });
    return CanvasRenderTarget2;
  })();
  var tempAnchor3;
  function determineCrossOrigin2(url$1, loc) {
    if (loc === void 0) {
      loc = globalThis.location;
    }
    if (url$1.indexOf("data:") === 0) {
      return "";
    }
    loc = loc || globalThis.location;
    if (!tempAnchor3) {
      tempAnchor3 = document.createElement("a");
    }
    tempAnchor3.href = url$1;
    var parsedUrl = url2.parse(tempAnchor3.href);
    var samePort = !parsedUrl.port && loc.port === "" || parsedUrl.port === loc.port;
    if (parsedUrl.hostname !== loc.hostname || !samePort || parsedUrl.protocol !== loc.protocol) {
      return "anonymous";
    }
    return "";
  }
  function getResolutionOfUrl2(url3, defaultValue3) {
    var resolution = settings.RETINA_PREFIX.exec(url3);
    if (resolution) {
      return parseFloat(resolution[1]);
    }
    return defaultValue3 !== void 0 ? defaultValue3 : 1;
  }
  var Runner2 = (
    /** @class */
    function() {
      function Runner3(name) {
        this.items = [];
        this._name = name;
        this._aliasCount = 0;
      }
      Runner3.prototype.emit = function(a0, a1, a2, a3, a4, a5, a6, a7) {
        if (arguments.length > 8) {
          throw new Error("max arguments reached");
        }
        var _a2 = this, name = _a2.name, items = _a2.items;
        this._aliasCount++;
        for (var i = 0, len = items.length; i < len; i++) {
          items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);
        }
        if (items === this.items) {
          this._aliasCount--;
        }
        return this;
      };
      Runner3.prototype.ensureNonAliasedItems = function() {
        if (this._aliasCount > 0 && this.items.length > 1) {
          this._aliasCount = 0;
          this.items = this.items.slice(0);
        }
      };
      Runner3.prototype.add = function(item) {
        if (item[this._name]) {
          this.ensureNonAliasedItems();
          this.remove(item);
          this.items.push(item);
        }
        return this;
      };
      Runner3.prototype.remove = function(item) {
        var index = this.items.indexOf(item);
        if (index !== -1) {
          this.ensureNonAliasedItems();
          this.items.splice(index, 1);
        }
        return this;
      };
      Runner3.prototype.contains = function(item) {
        return this.items.indexOf(item) !== -1;
      };
      Runner3.prototype.removeAll = function() {
        this.ensureNonAliasedItems();
        this.items.length = 0;
        return this;
      };
      Runner3.prototype.destroy = function() {
        this.removeAll();
        this.items = null;
        this._name = null;
      };
      Object.defineProperty(Runner3.prototype, "empty", {
        /**
         * `true` if there are no this Runner contains no listeners
         * @readonly
         */
        get: function() {
          return this.items.length === 0;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Runner3.prototype, "name", {
        /**
         * The name of the runner.
         * @readonly
         */
        get: function() {
          return this._name;
        },
        enumerable: false,
        configurable: true
      });
      return Runner3;
    }()
  );
  Object.defineProperties(Runner2.prototype, {
    /**
     * Alias for `emit`
     * @memberof PIXI.Runner#
     * @method dispatch
     * @see PIXI.Runner#emit
     */
    dispatch: { value: Runner2.prototype.emit },
    /**
     * Alias for `emit`
     * @memberof PIXI.Runner#
     * @method run
     * @see PIXI.Runner#emit
     */
    run: { value: Runner2.prototype.emit }
  });
  settings.TARGET_FPMS = 0.06;
  var UPDATE_PRIORITY2;
  (function(UPDATE_PRIORITY3) {
    UPDATE_PRIORITY3[UPDATE_PRIORITY3["INTERACTION"] = 50] = "INTERACTION";
    UPDATE_PRIORITY3[UPDATE_PRIORITY3["HIGH"] = 25] = "HIGH";
    UPDATE_PRIORITY3[UPDATE_PRIORITY3["NORMAL"] = 0] = "NORMAL";
    UPDATE_PRIORITY3[UPDATE_PRIORITY3["LOW"] = -25] = "LOW";
    UPDATE_PRIORITY3[UPDATE_PRIORITY3["UTILITY"] = -50] = "UTILITY";
  })(UPDATE_PRIORITY2 || (UPDATE_PRIORITY2 = {}));
  var TickerListener2 = (
    /** @class */
    function() {
      function TickerListener3(fn, context3, priority, once) {
        if (context3 === void 0) {
          context3 = null;
        }
        if (priority === void 0) {
          priority = 0;
        }
        if (once === void 0) {
          once = false;
        }
        this.next = null;
        this.previous = null;
        this._destroyed = false;
        this.fn = fn;
        this.context = context3;
        this.priority = priority;
        this.once = once;
      }
      TickerListener3.prototype.match = function(fn, context3) {
        if (context3 === void 0) {
          context3 = null;
        }
        return this.fn === fn && this.context === context3;
      };
      TickerListener3.prototype.emit = function(deltaTime) {
        if (this.fn) {
          if (this.context) {
            this.fn.call(this.context, deltaTime);
          } else {
            this.fn(deltaTime);
          }
        }
        var redirect = this.next;
        if (this.once) {
          this.destroy(true);
        }
        if (this._destroyed) {
          this.next = null;
        }
        return redirect;
      };
      TickerListener3.prototype.connect = function(previous) {
        this.previous = previous;
        if (previous.next) {
          previous.next.previous = this;
        }
        this.next = previous.next;
        previous.next = this;
      };
      TickerListener3.prototype.destroy = function(hard) {
        if (hard === void 0) {
          hard = false;
        }
        this._destroyed = true;
        this.fn = null;
        this.context = null;
        if (this.previous) {
          this.previous.next = this.next;
        }
        if (this.next) {
          this.next.previous = this.previous;
        }
        var redirect = this.next;
        this.next = hard ? null : redirect;
        this.previous = null;
        return redirect;
      };
      return TickerListener3;
    }()
  );
  var Ticker2 = (
    /** @class */
    function() {
      function Ticker3() {
        var _this = this;
        this.autoStart = false;
        this.deltaTime = 1;
        this.lastTime = -1;
        this.speed = 1;
        this.started = false;
        this._requestId = null;
        this._maxElapsedMS = 100;
        this._minElapsedMS = 0;
        this._protected = false;
        this._lastFrame = -1;
        this._head = new TickerListener2(null, null, Infinity);
        this.deltaMS = 1 / settings.TARGET_FPMS;
        this.elapsedMS = 1 / settings.TARGET_FPMS;
        this._tick = function(time) {
          _this._requestId = null;
          if (_this.started) {
            _this.update(time);
            if (_this.started && _this._requestId === null && _this._head.next) {
              _this._requestId = requestAnimationFrame(_this._tick);
            }
          }
        };
      }
      Ticker3.prototype._requestIfNeeded = function() {
        if (this._requestId === null && this._head.next) {
          this.lastTime = performance.now();
          this._lastFrame = this.lastTime;
          this._requestId = requestAnimationFrame(this._tick);
        }
      };
      Ticker3.prototype._cancelIfNeeded = function() {
        if (this._requestId !== null) {
          cancelAnimationFrame(this._requestId);
          this._requestId = null;
        }
      };
      Ticker3.prototype._startIfPossible = function() {
        if (this.started) {
          this._requestIfNeeded();
        } else if (this.autoStart) {
          this.start();
        }
      };
      Ticker3.prototype.add = function(fn, context3, priority) {
        if (priority === void 0) {
          priority = UPDATE_PRIORITY2.NORMAL;
        }
        return this._addListener(new TickerListener2(fn, context3, priority));
      };
      Ticker3.prototype.addOnce = function(fn, context3, priority) {
        if (priority === void 0) {
          priority = UPDATE_PRIORITY2.NORMAL;
        }
        return this._addListener(new TickerListener2(fn, context3, priority, true));
      };
      Ticker3.prototype._addListener = function(listener) {
        var current = this._head.next;
        var previous = this._head;
        if (!current) {
          listener.connect(previous);
        } else {
          while (current) {
            if (listener.priority > current.priority) {
              listener.connect(previous);
              break;
            }
            previous = current;
            current = current.next;
          }
          if (!listener.previous) {
            listener.connect(previous);
          }
        }
        this._startIfPossible();
        return this;
      };
      Ticker3.prototype.remove = function(fn, context3) {
        var listener = this._head.next;
        while (listener) {
          if (listener.match(fn, context3)) {
            listener = listener.destroy();
          } else {
            listener = listener.next;
          }
        }
        if (!this._head.next) {
          this._cancelIfNeeded();
        }
        return this;
      };
      Object.defineProperty(Ticker3.prototype, "count", {
        /**
         * The number of listeners on this ticker, calculated by walking through linked list
         * @readonly
         * @member {number}
         */
        get: function() {
          if (!this._head) {
            return 0;
          }
          var count = 0;
          var current = this._head;
          while (current = current.next) {
            count++;
          }
          return count;
        },
        enumerable: false,
        configurable: true
      });
      Ticker3.prototype.start = function() {
        if (!this.started) {
          this.started = true;
          this._requestIfNeeded();
        }
      };
      Ticker3.prototype.stop = function() {
        if (this.started) {
          this.started = false;
          this._cancelIfNeeded();
        }
      };
      Ticker3.prototype.destroy = function() {
        if (!this._protected) {
          this.stop();
          var listener = this._head.next;
          while (listener) {
            listener = listener.destroy(true);
          }
          this._head.destroy();
          this._head = null;
        }
      };
      Ticker3.prototype.update = function(currentTime) {
        if (currentTime === void 0) {
          currentTime = performance.now();
        }
        var elapsedMS;
        if (currentTime > this.lastTime) {
          elapsedMS = this.elapsedMS = currentTime - this.lastTime;
          if (elapsedMS > this._maxElapsedMS) {
            elapsedMS = this._maxElapsedMS;
          }
          elapsedMS *= this.speed;
          if (this._minElapsedMS) {
            var delta = currentTime - this._lastFrame | 0;
            if (delta < this._minElapsedMS) {
              return;
            }
            this._lastFrame = currentTime - delta % this._minElapsedMS;
          }
          this.deltaMS = elapsedMS;
          this.deltaTime = this.deltaMS * settings.TARGET_FPMS;
          var head = this._head;
          var listener = head.next;
          while (listener) {
            listener = listener.emit(this.deltaTime);
          }
          if (!head.next) {
            this._cancelIfNeeded();
          }
        } else {
          this.deltaTime = this.deltaMS = this.elapsedMS = 0;
        }
        this.lastTime = currentTime;
      };
      Object.defineProperty(Ticker3.prototype, "FPS", {
        /**
         * The frames per second at which this ticker is running.
         * The default is approximately 60 in most modern browsers.
         * **Note:** This does not factor in the value of
         * {@link PIXI.Ticker#speed}, which is specific
         * to scaling {@link PIXI.Ticker#deltaTime}.
         * @member {number}
         * @readonly
         */
        get: function() {
          return 1e3 / this.elapsedMS;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Ticker3.prototype, "minFPS", {
        /**
         * Manages the maximum amount of milliseconds allowed to
         * elapse between invoking {@link PIXI.Ticker#update}.
         * This value is used to cap {@link PIXI.Ticker#deltaTime},
         * but does not effect the measured value of {@link PIXI.Ticker#FPS}.
         * When setting this property it is clamped to a value between
         * `0` and `PIXI.settings.TARGET_FPMS * 1000`.
         * @member {number}
         * @default 10
         */
        get: function() {
          return 1e3 / this._maxElapsedMS;
        },
        set: function(fps) {
          var minFPS = Math.min(this.maxFPS, fps);
          var minFPMS = Math.min(Math.max(0, minFPS) / 1e3, settings.TARGET_FPMS);
          this._maxElapsedMS = 1 / minFPMS;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Ticker3.prototype, "maxFPS", {
        /**
         * Manages the minimum amount of milliseconds required to
         * elapse between invoking {@link PIXI.Ticker#update}.
         * This will effect the measured value of {@link PIXI.Ticker#FPS}.
         * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
         * Otherwise it will be at least `minFPS`
         * @member {number}
         * @default 0
         */
        get: function() {
          if (this._minElapsedMS) {
            return Math.round(1e3 / this._minElapsedMS);
          }
          return 0;
        },
        set: function(fps) {
          if (fps === 0) {
            this._minElapsedMS = 0;
          } else {
            var maxFPS = Math.max(this.minFPS, fps);
            this._minElapsedMS = 1 / (maxFPS / 1e3);
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Ticker3, "shared", {
        /**
         * The shared ticker instance used by {@link PIXI.AnimatedSprite} and by
         * {@link PIXI.VideoResource} to update animation frames / video textures.
         *
         * It may also be used by {@link PIXI.Application} if created with the `sharedTicker` option property set to true.
         *
         * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
         * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
         * @example
         * let ticker = PIXI.Ticker.shared;
         * // Set this to prevent starting this ticker when listeners are added.
         * // By default this is true only for the PIXI.Ticker.shared instance.
         * ticker.autoStart = false;
         * // FYI, call this to ensure the ticker is stopped. It should be stopped
         * // if you have not attempted to render anything yet.
         * ticker.stop();
         * // Call this when you are ready for a running shared ticker.
         * ticker.start();
         * @example
         * // You may use the shared ticker to render...
         * let renderer = PIXI.autoDetectRenderer();
         * let stage = new PIXI.Container();
         * document.body.appendChild(renderer.view);
         * ticker.add(function (time) {
         *     renderer.render(stage);
         * });
         * @example
         * // Or you can just update it manually.
         * ticker.autoStart = false;
         * ticker.stop();
         * function animate(time) {
         *     ticker.update(time);
         *     renderer.render(stage);
         *     requestAnimationFrame(animate);
         * }
         * animate(performance.now());
         * @member {PIXI.Ticker}
         * @static
         */
        get: function() {
          if (!Ticker3._shared) {
            var shared = Ticker3._shared = new Ticker3();
            shared.autoStart = true;
            shared._protected = true;
          }
          return Ticker3._shared;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Ticker3, "system", {
        /**
         * The system ticker instance used by {@link PIXI.InteractionManager} and by
         * {@link PIXI.BasePrepare} for core timing functionality that shouldn't usually need to be paused,
         * unlike the `shared` ticker which drives visual animations and rendering which may want to be paused.
         *
         * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
         * @member {PIXI.Ticker}
         * @static
         */
        get: function() {
          if (!Ticker3._system) {
            var system = Ticker3._system = new Ticker3();
            system.autoStart = true;
            system._protected = true;
          }
          return Ticker3._system;
        },
        enumerable: false,
        configurable: true
      });
      return Ticker3;
    }()
  );
  var PI_22 = Math.PI * 2;
  var SHAPES2;
  (function(SHAPES3) {
    SHAPES3[SHAPES3["POLY"] = 0] = "POLY";
    SHAPES3[SHAPES3["RECT"] = 1] = "RECT";
    SHAPES3[SHAPES3["CIRC"] = 2] = "CIRC";
    SHAPES3[SHAPES3["ELIP"] = 3] = "ELIP";
    SHAPES3[SHAPES3["RREC"] = 4] = "RREC";
  })(SHAPES2 || (SHAPES2 = {}));
  var Point2 = (
    /** @class */
    function() {
      function Point3(x, y) {
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        this.x = 0;
        this.y = 0;
        this.x = x;
        this.y = y;
      }
      Point3.prototype.clone = function() {
        return new Point3(this.x, this.y);
      };
      Point3.prototype.copyFrom = function(p) {
        this.set(p.x, p.y);
        return this;
      };
      Point3.prototype.copyTo = function(p) {
        p.set(this.x, this.y);
        return p;
      };
      Point3.prototype.equals = function(p) {
        return p.x === this.x && p.y === this.y;
      };
      Point3.prototype.set = function(x, y) {
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = x;
        }
        this.x = x;
        this.y = y;
        return this;
      };
      Point3.prototype.toString = function() {
        return "[@pixi/math:Point x=" + this.x + " y=" + this.y + "]";
      };
      return Point3;
    }()
  );
  var tempPoints$1 = [new Point2(), new Point2(), new Point2(), new Point2()];
  var Rectangle2 = (
    /** @class */
    function() {
      function Rectangle3(x, y, width, height) {
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        if (width === void 0) {
          width = 0;
        }
        if (height === void 0) {
          height = 0;
        }
        this.x = Number(x);
        this.y = Number(y);
        this.width = Number(width);
        this.height = Number(height);
        this.type = SHAPES2.RECT;
      }
      Object.defineProperty(Rectangle3.prototype, "left", {
        /** Returns the left edge of the rectangle. */
        get: function() {
          return this.x;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Rectangle3.prototype, "right", {
        /** Returns the right edge of the rectangle. */
        get: function() {
          return this.x + this.width;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Rectangle3.prototype, "top", {
        /** Returns the top edge of the rectangle. */
        get: function() {
          return this.y;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Rectangle3.prototype, "bottom", {
        /** Returns the bottom edge of the rectangle. */
        get: function() {
          return this.y + this.height;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Rectangle3, "EMPTY", {
        /** A constant empty rectangle. */
        get: function() {
          return new Rectangle3(0, 0, 0, 0);
        },
        enumerable: false,
        configurable: true
      });
      Rectangle3.prototype.clone = function() {
        return new Rectangle3(this.x, this.y, this.width, this.height);
      };
      Rectangle3.prototype.copyFrom = function(rectangle) {
        this.x = rectangle.x;
        this.y = rectangle.y;
        this.width = rectangle.width;
        this.height = rectangle.height;
        return this;
      };
      Rectangle3.prototype.copyTo = function(rectangle) {
        rectangle.x = this.x;
        rectangle.y = this.y;
        rectangle.width = this.width;
        rectangle.height = this.height;
        return rectangle;
      };
      Rectangle3.prototype.contains = function(x, y) {
        if (this.width <= 0 || this.height <= 0) {
          return false;
        }
        if (x >= this.x && x < this.x + this.width) {
          if (y >= this.y && y < this.y + this.height) {
            return true;
          }
        }
        return false;
      };
      Rectangle3.prototype.intersects = function(other, transform) {
        if (!transform) {
          var x0_1 = this.x < other.x ? other.x : this.x;
          var x1_1 = this.right > other.right ? other.right : this.right;
          if (x1_1 <= x0_1) {
            return false;
          }
          var y0_1 = this.y < other.y ? other.y : this.y;
          var y1_1 = this.bottom > other.bottom ? other.bottom : this.bottom;
          return y1_1 > y0_1;
        }
        var x0 = this.left;
        var x1 = this.right;
        var y0 = this.top;
        var y1 = this.bottom;
        if (x1 <= x0 || y1 <= y0) {
          return false;
        }
        var lt = tempPoints$1[0].set(other.left, other.top);
        var lb = tempPoints$1[1].set(other.left, other.bottom);
        var rt = tempPoints$1[2].set(other.right, other.top);
        var rb = tempPoints$1[3].set(other.right, other.bottom);
        if (rt.x <= lt.x || lb.y <= lt.y) {
          return false;
        }
        var s = Math.sign(transform.a * transform.d - transform.b * transform.c);
        if (s === 0) {
          return false;
        }
        transform.apply(lt, lt);
        transform.apply(lb, lb);
        transform.apply(rt, rt);
        transform.apply(rb, rb);
        if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {
          return false;
        }
        var nx = s * (lb.y - lt.y);
        var ny = s * (lt.x - lb.x);
        var n00 = nx * x0 + ny * y0;
        var n10 = nx * x1 + ny * y0;
        var n01 = nx * x0 + ny * y1;
        var n11 = nx * x1 + ny * y1;
        if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
          return false;
        }
        var mx = s * (lt.y - rt.y);
        var my = s * (rt.x - lt.x);
        var m00 = mx * x0 + my * y0;
        var m10 = mx * x1 + my * y0;
        var m01 = mx * x0 + my * y1;
        var m11 = mx * x1 + my * y1;
        if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
          return false;
        }
        return true;
      };
      Rectangle3.prototype.pad = function(paddingX, paddingY) {
        if (paddingX === void 0) {
          paddingX = 0;
        }
        if (paddingY === void 0) {
          paddingY = paddingX;
        }
        this.x -= paddingX;
        this.y -= paddingY;
        this.width += paddingX * 2;
        this.height += paddingY * 2;
        return this;
      };
      Rectangle3.prototype.fit = function(rectangle) {
        var x1 = Math.max(this.x, rectangle.x);
        var x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
        var y1 = Math.max(this.y, rectangle.y);
        var y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
        this.x = x1;
        this.width = Math.max(x2 - x1, 0);
        this.y = y1;
        this.height = Math.max(y2 - y1, 0);
        return this;
      };
      Rectangle3.prototype.ceil = function(resolution, eps) {
        if (resolution === void 0) {
          resolution = 1;
        }
        if (eps === void 0) {
          eps = 1e-3;
        }
        var x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
        var y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
        this.x = Math.floor((this.x + eps) * resolution) / resolution;
        this.y = Math.floor((this.y + eps) * resolution) / resolution;
        this.width = x2 - this.x;
        this.height = y2 - this.y;
        return this;
      };
      Rectangle3.prototype.enlarge = function(rectangle) {
        var x1 = Math.min(this.x, rectangle.x);
        var x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
        var y1 = Math.min(this.y, rectangle.y);
        var y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
        this.x = x1;
        this.width = x2 - x1;
        this.y = y1;
        this.height = y2 - y1;
        return this;
      };
      Rectangle3.prototype.toString = function() {
        return "[@pixi/math:Rectangle x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
      };
      return Rectangle3;
    }()
  );
  var ObservablePoint2 = (
    /** @class */
    function() {
      function ObservablePoint3(cb, scope, x, y) {
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = 0;
        }
        this._x = x;
        this._y = y;
        this.cb = cb;
        this.scope = scope;
      }
      ObservablePoint3.prototype.clone = function(cb, scope) {
        if (cb === void 0) {
          cb = this.cb;
        }
        if (scope === void 0) {
          scope = this.scope;
        }
        return new ObservablePoint3(cb, scope, this._x, this._y);
      };
      ObservablePoint3.prototype.set = function(x, y) {
        if (x === void 0) {
          x = 0;
        }
        if (y === void 0) {
          y = x;
        }
        if (this._x !== x || this._y !== y) {
          this._x = x;
          this._y = y;
          this.cb.call(this.scope);
        }
        return this;
      };
      ObservablePoint3.prototype.copyFrom = function(p) {
        if (this._x !== p.x || this._y !== p.y) {
          this._x = p.x;
          this._y = p.y;
          this.cb.call(this.scope);
        }
        return this;
      };
      ObservablePoint3.prototype.copyTo = function(p) {
        p.set(this._x, this._y);
        return p;
      };
      ObservablePoint3.prototype.equals = function(p) {
        return p.x === this._x && p.y === this._y;
      };
      ObservablePoint3.prototype.toString = function() {
        return "[@pixi/math:ObservablePoint x=0 y=0 scope=" + this.scope + "]";
      };
      Object.defineProperty(ObservablePoint3.prototype, "x", {
        /** Position of the observable point on the x axis. */
        get: function() {
          return this._x;
        },
        set: function(value) {
          if (this._x !== value) {
            this._x = value;
            this.cb.call(this.scope);
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ObservablePoint3.prototype, "y", {
        /** Position of the observable point on the y axis. */
        get: function() {
          return this._y;
        },
        set: function(value) {
          if (this._y !== value) {
            this._y = value;
            this.cb.call(this.scope);
          }
        },
        enumerable: false,
        configurable: true
      });
      return ObservablePoint3;
    }()
  );
  var Matrix2 = (
    /** @class */
    function() {
      function Matrix3(a, b, c, d, tx, ty) {
        if (a === void 0) {
          a = 1;
        }
        if (b === void 0) {
          b = 0;
        }
        if (c === void 0) {
          c = 0;
        }
        if (d === void 0) {
          d = 1;
        }
        if (tx === void 0) {
          tx = 0;
        }
        if (ty === void 0) {
          ty = 0;
        }
        this.array = null;
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
      }
      Matrix3.prototype.fromArray = function(array) {
        this.a = array[0];
        this.b = array[1];
        this.c = array[3];
        this.d = array[4];
        this.tx = array[2];
        this.ty = array[5];
      };
      Matrix3.prototype.set = function(a, b, c, d, tx, ty) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
        return this;
      };
      Matrix3.prototype.toArray = function(transpose, out) {
        if (!this.array) {
          this.array = new Float32Array(9);
        }
        var array = out || this.array;
        if (transpose) {
          array[0] = this.a;
          array[1] = this.b;
          array[2] = 0;
          array[3] = this.c;
          array[4] = this.d;
          array[5] = 0;
          array[6] = this.tx;
          array[7] = this.ty;
          array[8] = 1;
        } else {
          array[0] = this.a;
          array[1] = this.c;
          array[2] = this.tx;
          array[3] = this.b;
          array[4] = this.d;
          array[5] = this.ty;
          array[6] = 0;
          array[7] = 0;
          array[8] = 1;
        }
        return array;
      };
      Matrix3.prototype.apply = function(pos, newPos) {
        newPos = newPos || new Point2();
        var x = pos.x;
        var y = pos.y;
        newPos.x = this.a * x + this.c * y + this.tx;
        newPos.y = this.b * x + this.d * y + this.ty;
        return newPos;
      };
      Matrix3.prototype.applyInverse = function(pos, newPos) {
        newPos = newPos || new Point2();
        var id = 1 / (this.a * this.d + this.c * -this.b);
        var x = pos.x;
        var y = pos.y;
        newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id;
        newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id;
        return newPos;
      };
      Matrix3.prototype.translate = function(x, y) {
        this.tx += x;
        this.ty += y;
        return this;
      };
      Matrix3.prototype.scale = function(x, y) {
        this.a *= x;
        this.d *= y;
        this.c *= x;
        this.b *= y;
        this.tx *= x;
        this.ty *= y;
        return this;
      };
      Matrix3.prototype.rotate = function(angle) {
        var cos = Math.cos(angle);
        var sin = Math.sin(angle);
        var a1 = this.a;
        var c1 = this.c;
        var tx1 = this.tx;
        this.a = a1 * cos - this.b * sin;
        this.b = a1 * sin + this.b * cos;
        this.c = c1 * cos - this.d * sin;
        this.d = c1 * sin + this.d * cos;
        this.tx = tx1 * cos - this.ty * sin;
        this.ty = tx1 * sin + this.ty * cos;
        return this;
      };
      Matrix3.prototype.append = function(matrix) {
        var a1 = this.a;
        var b1 = this.b;
        var c1 = this.c;
        var d1 = this.d;
        this.a = matrix.a * a1 + matrix.b * c1;
        this.b = matrix.a * b1 + matrix.b * d1;
        this.c = matrix.c * a1 + matrix.d * c1;
        this.d = matrix.c * b1 + matrix.d * d1;
        this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
        this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
        return this;
      };
      Matrix3.prototype.setTransform = function(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
        this.a = Math.cos(rotation + skewY) * scaleX;
        this.b = Math.sin(rotation + skewY) * scaleX;
        this.c = -Math.sin(rotation - skewX) * scaleY;
        this.d = Math.cos(rotation - skewX) * scaleY;
        this.tx = x - (pivotX * this.a + pivotY * this.c);
        this.ty = y - (pivotX * this.b + pivotY * this.d);
        return this;
      };
      Matrix3.prototype.prepend = function(matrix) {
        var tx1 = this.tx;
        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
          var a1 = this.a;
          var c1 = this.c;
          this.a = a1 * matrix.a + this.b * matrix.c;
          this.b = a1 * matrix.b + this.b * matrix.d;
          this.c = c1 * matrix.a + this.d * matrix.c;
          this.d = c1 * matrix.b + this.d * matrix.d;
        }
        this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
        this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
        return this;
      };
      Matrix3.prototype.decompose = function(transform) {
        var a = this.a;
        var b = this.b;
        var c = this.c;
        var d = this.d;
        var pivot = transform.pivot;
        var skewX = -Math.atan2(-c, d);
        var skewY = Math.atan2(b, a);
        var delta = Math.abs(skewX + skewY);
        if (delta < 1e-5 || Math.abs(PI_22 - delta) < 1e-5) {
          transform.rotation = skewY;
          transform.skew.x = transform.skew.y = 0;
        } else {
          transform.rotation = 0;
          transform.skew.x = skewX;
          transform.skew.y = skewY;
        }
        transform.scale.x = Math.sqrt(a * a + b * b);
        transform.scale.y = Math.sqrt(c * c + d * d);
        transform.position.x = this.tx + (pivot.x * a + pivot.y * c);
        transform.position.y = this.ty + (pivot.x * b + pivot.y * d);
        return transform;
      };
      Matrix3.prototype.invert = function() {
        var a1 = this.a;
        var b1 = this.b;
        var c1 = this.c;
        var d1 = this.d;
        var tx1 = this.tx;
        var n = a1 * d1 - b1 * c1;
        this.a = d1 / n;
        this.b = -b1 / n;
        this.c = -c1 / n;
        this.d = a1 / n;
        this.tx = (c1 * this.ty - d1 * tx1) / n;
        this.ty = -(a1 * this.ty - b1 * tx1) / n;
        return this;
      };
      Matrix3.prototype.identity = function() {
        this.a = 1;
        this.b = 0;
        this.c = 0;
        this.d = 1;
        this.tx = 0;
        this.ty = 0;
        return this;
      };
      Matrix3.prototype.clone = function() {
        var matrix = new Matrix3();
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
      };
      Matrix3.prototype.copyTo = function(matrix) {
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
      };
      Matrix3.prototype.copyFrom = function(matrix) {
        this.a = matrix.a;
        this.b = matrix.b;
        this.c = matrix.c;
        this.d = matrix.d;
        this.tx = matrix.tx;
        this.ty = matrix.ty;
        return this;
      };
      Matrix3.prototype.toString = function() {
        return "[@pixi/math:Matrix a=" + this.a + " b=" + this.b + " c=" + this.c + " d=" + this.d + " tx=" + this.tx + " ty=" + this.ty + "]";
      };
      Object.defineProperty(Matrix3, "IDENTITY", {
        /**
         * A default (identity) matrix
         * @readonly
         */
        get: function() {
          return new Matrix3();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Matrix3, "TEMP_MATRIX", {
        /**
         * A temp matrix
         * @readonly
         */
        get: function() {
          return new Matrix3();
        },
        enumerable: false,
        configurable: true
      });
      return Matrix3;
    }()
  );
  var ux2 = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
  var uy2 = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
  var vx2 = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
  var vy2 = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
  var rotationCayley2 = [];
  var rotationMatrices2 = [];
  var signum2 = Math.sign;
  function init2() {
    for (var i = 0; i < 16; i++) {
      var row = [];
      rotationCayley2.push(row);
      for (var j = 0; j < 16; j++) {
        var _ux = signum2(ux2[i] * ux2[j] + vx2[i] * uy2[j]);
        var _uy = signum2(uy2[i] * ux2[j] + vy2[i] * uy2[j]);
        var _vx = signum2(ux2[i] * vx2[j] + vx2[i] * vy2[j]);
        var _vy = signum2(uy2[i] * vx2[j] + vy2[i] * vy2[j]);
        for (var k = 0; k < 16; k++) {
          if (ux2[k] === _ux && uy2[k] === _uy && vx2[k] === _vx && vy2[k] === _vy) {
            row.push(k);
            break;
          }
        }
      }
    }
    for (var i = 0; i < 16; i++) {
      var mat = new Matrix2();
      mat.set(ux2[i], uy2[i], vx2[i], vy2[i], 0, 0);
      rotationMatrices2.push(mat);
    }
  }
  init2();
  var groupD82 = {
    /**
     * | Rotation | Direction |
     * |----------|-----------|
     * | 0       | East      |
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */
    E: 0,
    /**
     * | Rotation | Direction |
     * |----------|-----------|
     * | 45     | Southeast |
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */
    SE: 1,
    /**
     * | Rotation | Direction |
     * |----------|-----------|
     * | 90     | South     |
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */
    S: 2,
    /**
     * | Rotation | Direction |
     * |----------|-----------|
     * | 135    | Southwest |
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */
    SW: 3,
    /**
     * | Rotation | Direction |
     * |----------|-----------|
     * | 180     | West      |
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */
    W: 4,
    /**
     * | Rotation    | Direction    |
     * |-------------|--------------|
     * | -135/225 | Northwest    |
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */
    NW: 5,
    /**
     * | Rotation    | Direction    |
     * |-------------|--------------|
     * | -90/270  | North        |
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */
    N: 6,
    /**
     * | Rotation    | Direction    |
     * |-------------|--------------|
     * | -45/315  | Northeast    |
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */
    NE: 7,
    /**
     * Reflection about Y-axis.
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */
    MIRROR_VERTICAL: 8,
    /**
     * Reflection about the main diagonal.
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */
    MAIN_DIAGONAL: 10,
    /**
     * Reflection about X-axis.
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */
    MIRROR_HORIZONTAL: 12,
    /**
     * Reflection about reverse diagonal.
     * @memberof PIXI.groupD8
     * @constant {PIXI.GD8Symmetry}
     */
    REVERSE_DIAGONAL: 14,
    /**
     * @memberof PIXI.groupD8
     * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
     * @returns {PIXI.GD8Symmetry} The X-component of the U-axis
     *    after rotating the axes.
     */
    uX: function(ind) {
      return ux2[ind];
    },
    /**
     * @memberof PIXI.groupD8
     * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
     * @returns {PIXI.GD8Symmetry} The Y-component of the U-axis
     *    after rotating the axes.
     */
    uY: function(ind) {
      return uy2[ind];
    },
    /**
     * @memberof PIXI.groupD8
     * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
     * @returns {PIXI.GD8Symmetry} The X-component of the V-axis
     *    after rotating the axes.
     */
    vX: function(ind) {
      return vx2[ind];
    },
    /**
     * @memberof PIXI.groupD8
     * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
     * @returns {PIXI.GD8Symmetry} The Y-component of the V-axis
     *    after rotating the axes.
     */
    vY: function(ind) {
      return vy2[ind];
    },
    /**
     * @memberof PIXI.groupD8
     * @param {PIXI.GD8Symmetry} rotation - symmetry whose opposite
     *   is needed. Only rotations have opposite symmetries while
     *   reflections don't.
     * @returns {PIXI.GD8Symmetry} The opposite symmetry of `rotation`
     */
    inv: function(rotation) {
      if (rotation & 8) {
        return rotation & 15;
      }
      return -rotation & 7;
    },
    /**
     * Composes the two D8 operations.
     *
     * Taking `^` as reflection:
     *
     * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
     * |-------|-----|-----|-----|-----|------|-------|-------|-------|
     * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
     * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
     * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
     * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
     * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
     * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
     * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
     * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
     *
     * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
     * @memberof PIXI.groupD8
     * @param {PIXI.GD8Symmetry} rotationSecond - Second operation, which
     *   is the row in the above cayley table.
     * @param {PIXI.GD8Symmetry} rotationFirst - First operation, which
     *   is the column in the above cayley table.
     * @returns {PIXI.GD8Symmetry} Composed operation
     */
    add: function(rotationSecond, rotationFirst) {
      return rotationCayley2[rotationSecond][rotationFirst];
    },
    /**
     * Reverse of `add`.
     * @memberof PIXI.groupD8
     * @param {PIXI.GD8Symmetry} rotationSecond - Second operation
     * @param {PIXI.GD8Symmetry} rotationFirst - First operation
     * @returns {PIXI.GD8Symmetry} Result
     */
    sub: function(rotationSecond, rotationFirst) {
      return rotationCayley2[rotationSecond][groupD82.inv(rotationFirst)];
    },
    /**
     * Adds 180 degrees to rotation, which is a commutative
     * operation.
     * @memberof PIXI.groupD8
     * @param {number} rotation - The number to rotate.
     * @returns {number} Rotated number
     */
    rotate180: function(rotation) {
      return rotation ^ 4;
    },
    /**
     * Checks if the rotation angle is vertical, i.e. south
     * or north. It doesn't work for reflections.
     * @memberof PIXI.groupD8
     * @param {PIXI.GD8Symmetry} rotation - The number to check.
     * @returns {boolean} Whether or not the direction is vertical
     */
    isVertical: function(rotation) {
      return (rotation & 3) === 2;
    },
    /**
     * Approximates the vector `V(dx,dy)` into one of the
     * eight directions provided by `groupD8`.
     * @memberof PIXI.groupD8
     * @param {number} dx - X-component of the vector
     * @param {number} dy - Y-component of the vector
     * @returns {PIXI.GD8Symmetry} Approximation of the vector into
     *  one of the eight symmetries.
     */
    byDirection: function(dx, dy) {
      if (Math.abs(dx) * 2 <= Math.abs(dy)) {
        if (dy >= 0) {
          return groupD82.S;
        }
        return groupD82.N;
      } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
        if (dx > 0) {
          return groupD82.E;
        }
        return groupD82.W;
      } else if (dy > 0) {
        if (dx > 0) {
          return groupD82.SE;
        }
        return groupD82.SW;
      } else if (dx > 0) {
        return groupD82.NE;
      }
      return groupD82.NW;
    },
    /**
     * Helps sprite to compensate texture packer rotation.
     * @memberof PIXI.groupD8
     * @param {PIXI.Matrix} matrix - sprite world matrix
     * @param {PIXI.GD8Symmetry} rotation - The rotation factor to use.
     * @param {number} tx - sprite anchoring
     * @param {number} ty - sprite anchoring
     */
    matrixAppendRotationInv: function(matrix, rotation, tx, ty) {
      if (tx === void 0) {
        tx = 0;
      }
      if (ty === void 0) {
        ty = 0;
      }
      var mat = rotationMatrices2[groupD82.inv(rotation)];
      mat.tx = tx;
      mat.ty = ty;
      matrix.append(mat);
    }
  };
  (function() {
    function Transform2() {
      this.worldTransform = new Matrix2();
      this.localTransform = new Matrix2();
      this.position = new ObservablePoint2(this.onChange, this, 0, 0);
      this.scale = new ObservablePoint2(this.onChange, this, 1, 1);
      this.pivot = new ObservablePoint2(this.onChange, this, 0, 0);
      this.skew = new ObservablePoint2(this.updateSkew, this, 0, 0);
      this._rotation = 0;
      this._cx = 1;
      this._sx = 0;
      this._cy = 0;
      this._sy = 1;
      this._localID = 0;
      this._currentLocalID = 0;
      this._worldID = 0;
      this._parentID = 0;
    }
    Transform2.prototype.onChange = function() {
      this._localID++;
    };
    Transform2.prototype.updateSkew = function() {
      this._cx = Math.cos(this._rotation + this.skew.y);
      this._sx = Math.sin(this._rotation + this.skew.y);
      this._cy = -Math.sin(this._rotation - this.skew.x);
      this._sy = Math.cos(this._rotation - this.skew.x);
      this._localID++;
    };
    Transform2.prototype.toString = function() {
      return "[@pixi/math:Transform " + ("position=(" + this.position.x + ", " + this.position.y + ") ") + ("rotation=" + this.rotation + " ") + ("scale=(" + this.scale.x + ", " + this.scale.y + ") ") + ("skew=(" + this.skew.x + ", " + this.skew.y + ") ") + "]";
    };
    Transform2.prototype.updateLocalTransform = function() {
      var lt = this.localTransform;
      if (this._localID !== this._currentLocalID) {
        lt.a = this._cx * this.scale.x;
        lt.b = this._sx * this.scale.x;
        lt.c = this._cy * this.scale.y;
        lt.d = this._sy * this.scale.y;
        lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
        lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
        this._currentLocalID = this._localID;
        this._parentID = -1;
      }
    };
    Transform2.prototype.updateTransform = function(parentTransform) {
      var lt = this.localTransform;
      if (this._localID !== this._currentLocalID) {
        lt.a = this._cx * this.scale.x;
        lt.b = this._sx * this.scale.x;
        lt.c = this._cy * this.scale.y;
        lt.d = this._sy * this.scale.y;
        lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
        lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
        this._currentLocalID = this._localID;
        this._parentID = -1;
      }
      if (this._parentID !== parentTransform._worldID) {
        var pt = parentTransform.worldTransform;
        var wt = this.worldTransform;
        wt.a = lt.a * pt.a + lt.b * pt.c;
        wt.b = lt.a * pt.b + lt.b * pt.d;
        wt.c = lt.c * pt.a + lt.d * pt.c;
        wt.d = lt.c * pt.b + lt.d * pt.d;
        wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
        wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
        this._parentID = parentTransform._worldID;
        this._worldID++;
      }
    };
    Transform2.prototype.setFromMatrix = function(matrix) {
      matrix.decompose(this);
      this._localID++;
    };
    Object.defineProperty(Transform2.prototype, "rotation", {
      /** The rotation of the object in radians. */
      get: function() {
        return this._rotation;
      },
      set: function(value) {
        if (this._rotation !== value) {
          this._rotation = value;
          this.updateSkew();
        }
      },
      enumerable: false,
      configurable: true
    });
    Transform2.IDENTITY = new Transform2();
    return Transform2;
  })();
  settings.PREFER_ENV = isMobile2.any ? ENV.WEBGL : ENV.WEBGL2;
  settings.STRICT_TEXTURE_CACHE = false;
  var INSTALLED2 = [];
  function autoDetectResource2(source, options) {
    if (!source) {
      return null;
    }
    var extension = "";
    if (typeof source === "string") {
      var result = /\.(\w{3,4})(?:$|\?|#)/i.exec(source);
      if (result) {
        extension = result[1].toLowerCase();
      }
    }
    for (var i = INSTALLED2.length - 1; i >= 0; --i) {
      var ResourcePlugin = INSTALLED2[i];
      if (ResourcePlugin.test && ResourcePlugin.test(source, extension)) {
        return new ResourcePlugin(source, options);
      }
    }
    throw new Error("Unrecognized source type to auto-detect Resource");
  }
  var extendStatics12 = function(d, b) {
    extendStatics12 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) {
        if (b2.hasOwnProperty(p)) {
          d2[p] = b2[p];
        }
      }
    };
    return extendStatics12(d, b);
  };
  function __extends12(d, b) {
    extendStatics12(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var __assign2 = function() {
    __assign2 = Object.assign || function __assign3(t) {
      var arguments$1 = arguments;
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments$1[i];
        for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p)) {
            t[p] = s[p];
          }
        }
      }
      return t;
    };
    return __assign2.apply(this, arguments);
  };
  function __rest2(s, e) {
    var t = {};
    for (var p in s) {
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) {
        t[p] = s[p];
      }
    }
    if (s != null && typeof Object.getOwnPropertySymbols === "function") {
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0) {
          t[p[i]] = s[p[i]];
        }
      }
    }
    return t;
  }
  var Resource2 = (
    /** @class */
    function() {
      function Resource3(width, height) {
        if (width === void 0) {
          width = 0;
        }
        if (height === void 0) {
          height = 0;
        }
        this._width = width;
        this._height = height;
        this.destroyed = false;
        this.internal = false;
        this.onResize = new Runner2("setRealSize");
        this.onUpdate = new Runner2("update");
        this.onError = new Runner2("onError");
      }
      Resource3.prototype.bind = function(baseTexture) {
        this.onResize.add(baseTexture);
        this.onUpdate.add(baseTexture);
        this.onError.add(baseTexture);
        if (this._width || this._height) {
          this.onResize.emit(this._width, this._height);
        }
      };
      Resource3.prototype.unbind = function(baseTexture) {
        this.onResize.remove(baseTexture);
        this.onUpdate.remove(baseTexture);
        this.onError.remove(baseTexture);
      };
      Resource3.prototype.resize = function(width, height) {
        if (width !== this._width || height !== this._height) {
          this._width = width;
          this._height = height;
          this.onResize.emit(width, height);
        }
      };
      Object.defineProperty(Resource3.prototype, "valid", {
        /**
         * Has been validated
         * @readonly
         */
        get: function() {
          return !!this._width && !!this._height;
        },
        enumerable: false,
        configurable: true
      });
      Resource3.prototype.update = function() {
        if (!this.destroyed) {
          this.onUpdate.emit();
        }
      };
      Resource3.prototype.load = function() {
        return Promise.resolve(this);
      };
      Object.defineProperty(Resource3.prototype, "width", {
        /**
         * The width of the resource.
         * @readonly
         */
        get: function() {
          return this._width;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Resource3.prototype, "height", {
        /**
         * The height of the resource.
         * @readonly
         */
        get: function() {
          return this._height;
        },
        enumerable: false,
        configurable: true
      });
      Resource3.prototype.style = function(_renderer, _baseTexture, _glTexture) {
        return false;
      };
      Resource3.prototype.dispose = function() {
      };
      Resource3.prototype.destroy = function() {
        if (!this.destroyed) {
          this.destroyed = true;
          this.dispose();
          this.onError.removeAll();
          this.onError = null;
          this.onResize.removeAll();
          this.onResize = null;
          this.onUpdate.removeAll();
          this.onUpdate = null;
        }
      };
      Resource3.test = function(_source, _extension) {
        return false;
      };
      return Resource3;
    }()
  );
  var BufferResource2 = (
    /** @class */
    function(_super) {
      __extends12(BufferResource3, _super);
      function BufferResource3(source, options) {
        var _this = this;
        var _a2 = options || {}, width = _a2.width, height = _a2.height;
        if (!width || !height) {
          throw new Error("BufferResource width or height invalid");
        }
        _this = _super.call(this, width, height) || this;
        _this.data = source;
        return _this;
      }
      BufferResource3.prototype.upload = function(renderer, baseTexture, glTexture) {
        var gl = renderer.gl;
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
        var width = baseTexture.realWidth;
        var height = baseTexture.realHeight;
        if (glTexture.width === width && glTexture.height === height) {
          gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
        } else {
          glTexture.width = width;
          glTexture.height = height;
          gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
        }
        return true;
      };
      BufferResource3.prototype.dispose = function() {
        this.data = null;
      };
      BufferResource3.test = function(source) {
        return source instanceof Float32Array || source instanceof Uint8Array || source instanceof Uint32Array;
      };
      return BufferResource3;
    }(Resource2)
  );
  var defaultBufferOptions2 = {
    scaleMode: SCALE_MODES.NEAREST,
    format: FORMATS.RGBA,
    alphaMode: ALPHA_MODES.NPM
  };
  var BaseTexture2 = (
    /** @class */
    function(_super) {
      __extends12(BaseTexture3, _super);
      function BaseTexture3(resource, options) {
        if (resource === void 0) {
          resource = null;
        }
        if (options === void 0) {
          options = null;
        }
        var _this = _super.call(this) || this;
        options = options || {};
        var alphaMode = options.alphaMode, mipmap = options.mipmap, anisotropicLevel = options.anisotropicLevel, scaleMode = options.scaleMode, width = options.width, height = options.height, wrapMode = options.wrapMode, format3 = options.format, type = options.type, target = options.target, resolution = options.resolution, resourceOptions = options.resourceOptions;
        if (resource && !(resource instanceof Resource2)) {
          resource = autoDetectResource2(resource, resourceOptions);
          resource.internal = true;
        }
        _this.resolution = resolution || settings.RESOLUTION;
        _this.width = Math.round((width || 0) * _this.resolution) / _this.resolution;
        _this.height = Math.round((height || 0) * _this.resolution) / _this.resolution;
        _this._mipmap = mipmap !== void 0 ? mipmap : settings.MIPMAP_TEXTURES;
        _this.anisotropicLevel = anisotropicLevel !== void 0 ? anisotropicLevel : settings.ANISOTROPIC_LEVEL;
        _this._wrapMode = wrapMode || settings.WRAP_MODE;
        _this._scaleMode = scaleMode !== void 0 ? scaleMode : settings.SCALE_MODE;
        _this.format = format3 || FORMATS.RGBA;
        _this.type = type || TYPES.UNSIGNED_BYTE;
        _this.target = target || TARGETS.TEXTURE_2D;
        _this.alphaMode = alphaMode !== void 0 ? alphaMode : ALPHA_MODES.UNPACK;
        _this.uid = uid2();
        _this.touched = 0;
        _this.isPowerOfTwo = false;
        _this._refreshPOT();
        _this._glTextures = {};
        _this.dirtyId = 0;
        _this.dirtyStyleId = 0;
        _this.cacheId = null;
        _this.valid = width > 0 && height > 0;
        _this.textureCacheIds = [];
        _this.destroyed = false;
        _this.resource = null;
        _this._batchEnabled = 0;
        _this._batchLocation = 0;
        _this.parentTextureArray = null;
        _this.setResource(resource);
        return _this;
      }
      Object.defineProperty(BaseTexture3.prototype, "realWidth", {
        /**
         * Pixel width of the source of this texture
         * @readonly
         */
        get: function() {
          return Math.round(this.width * this.resolution);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture3.prototype, "realHeight", {
        /**
         * Pixel height of the source of this texture
         * @readonly
         */
        get: function() {
          return Math.round(this.height * this.resolution);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture3.prototype, "mipmap", {
        /**
         * Mipmap mode of the texture, affects downscaled images
         * @default PIXI.settings.MIPMAP_TEXTURES
         */
        get: function() {
          return this._mipmap;
        },
        set: function(value) {
          if (this._mipmap !== value) {
            this._mipmap = value;
            this.dirtyStyleId++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture3.prototype, "scaleMode", {
        /**
         * The scale mode to apply when scaling this texture
         * @default PIXI.settings.SCALE_MODE
         */
        get: function() {
          return this._scaleMode;
        },
        set: function(value) {
          if (this._scaleMode !== value) {
            this._scaleMode = value;
            this.dirtyStyleId++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture3.prototype, "wrapMode", {
        /**
         * How the texture wraps
         * @default PIXI.settings.WRAP_MODE
         */
        get: function() {
          return this._wrapMode;
        },
        set: function(value) {
          if (this._wrapMode !== value) {
            this._wrapMode = value;
            this.dirtyStyleId++;
          }
        },
        enumerable: false,
        configurable: true
      });
      BaseTexture3.prototype.setStyle = function(scaleMode, mipmap) {
        var dirty;
        if (scaleMode !== void 0 && scaleMode !== this.scaleMode) {
          this.scaleMode = scaleMode;
          dirty = true;
        }
        if (mipmap !== void 0 && mipmap !== this.mipmap) {
          this.mipmap = mipmap;
          dirty = true;
        }
        if (dirty) {
          this.dirtyStyleId++;
        }
        return this;
      };
      BaseTexture3.prototype.setSize = function(desiredWidth, desiredHeight, resolution) {
        resolution = resolution || this.resolution;
        return this.setRealSize(desiredWidth * resolution, desiredHeight * resolution, resolution);
      };
      BaseTexture3.prototype.setRealSize = function(realWidth, realHeight, resolution) {
        this.resolution = resolution || this.resolution;
        this.width = Math.round(realWidth) / this.resolution;
        this.height = Math.round(realHeight) / this.resolution;
        this._refreshPOT();
        this.update();
        return this;
      };
      BaseTexture3.prototype._refreshPOT = function() {
        this.isPowerOfTwo = isPow22(this.realWidth) && isPow22(this.realHeight);
      };
      BaseTexture3.prototype.setResolution = function(resolution) {
        var oldResolution = this.resolution;
        if (oldResolution === resolution) {
          return this;
        }
        this.resolution = resolution;
        if (this.valid) {
          this.width = Math.round(this.width * oldResolution) / resolution;
          this.height = Math.round(this.height * oldResolution) / resolution;
          this.emit("update", this);
        }
        this._refreshPOT();
        return this;
      };
      BaseTexture3.prototype.setResource = function(resource) {
        if (this.resource === resource) {
          return this;
        }
        if (this.resource) {
          throw new Error("Resource can be set only once");
        }
        resource.bind(this);
        this.resource = resource;
        return this;
      };
      BaseTexture3.prototype.update = function() {
        if (!this.valid) {
          if (this.width > 0 && this.height > 0) {
            this.valid = true;
            this.emit("loaded", this);
            this.emit("update", this);
          }
        } else {
          this.dirtyId++;
          this.dirtyStyleId++;
          this.emit("update", this);
        }
      };
      BaseTexture3.prototype.onError = function(event) {
        this.emit("error", this, event);
      };
      BaseTexture3.prototype.destroy = function() {
        if (this.resource) {
          this.resource.unbind(this);
          if (this.resource.internal) {
            this.resource.destroy();
          }
          this.resource = null;
        }
        if (this.cacheId) {
          delete BaseTextureCache2[this.cacheId];
          delete TextureCache2[this.cacheId];
          this.cacheId = null;
        }
        this.dispose();
        BaseTexture3.removeFromCache(this);
        this.textureCacheIds = null;
        this.destroyed = true;
      };
      BaseTexture3.prototype.dispose = function() {
        this.emit("dispose", this);
      };
      BaseTexture3.prototype.castToBaseTexture = function() {
        return this;
      };
      BaseTexture3.from = function(source, options, strict) {
        if (strict === void 0) {
          strict = settings.STRICT_TEXTURE_CACHE;
        }
        var isFrame = typeof source === "string";
        var cacheId = null;
        if (isFrame) {
          cacheId = source;
        } else {
          if (!source._pixiId) {
            var prefix = options && options.pixiIdPrefix || "pixiid";
            source._pixiId = prefix + "_" + uid2();
          }
          cacheId = source._pixiId;
        }
        var baseTexture = BaseTextureCache2[cacheId];
        if (isFrame && strict && !baseTexture) {
          throw new Error('The cacheId "' + cacheId + '" does not exist in BaseTextureCache.');
        }
        if (!baseTexture) {
          baseTexture = new BaseTexture3(source, options);
          baseTexture.cacheId = cacheId;
          BaseTexture3.addToCache(baseTexture, cacheId);
        }
        return baseTexture;
      };
      BaseTexture3.fromBuffer = function(buffer, width, height, options) {
        buffer = buffer || new Float32Array(width * height * 4);
        var resource = new BufferResource2(buffer, { width, height });
        var type = buffer instanceof Float32Array ? TYPES.FLOAT : TYPES.UNSIGNED_BYTE;
        return new BaseTexture3(resource, Object.assign(defaultBufferOptions2, options || { width, height, type }));
      };
      BaseTexture3.addToCache = function(baseTexture, id) {
        if (id) {
          if (baseTexture.textureCacheIds.indexOf(id) === -1) {
            baseTexture.textureCacheIds.push(id);
          }
          if (BaseTextureCache2[id]) {
            console.warn("BaseTexture added to the cache with an id [" + id + "] that already had an entry");
          }
          BaseTextureCache2[id] = baseTexture;
        }
      };
      BaseTexture3.removeFromCache = function(baseTexture) {
        if (typeof baseTexture === "string") {
          var baseTextureFromCache = BaseTextureCache2[baseTexture];
          if (baseTextureFromCache) {
            var index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
            if (index > -1) {
              baseTextureFromCache.textureCacheIds.splice(index, 1);
            }
            delete BaseTextureCache2[baseTexture];
            return baseTextureFromCache;
          }
        } else if (baseTexture && baseTexture.textureCacheIds) {
          for (var i = 0; i < baseTexture.textureCacheIds.length; ++i) {
            delete BaseTextureCache2[baseTexture.textureCacheIds[i]];
          }
          baseTexture.textureCacheIds.length = 0;
          return baseTexture;
        }
        return null;
      };
      BaseTexture3._globalBatch = 0;
      return BaseTexture3;
    }(eventemitter3)
  );
  var AbstractMultiResource2 = (
    /** @class */
    function(_super) {
      __extends12(AbstractMultiResource3, _super);
      function AbstractMultiResource3(length, options) {
        var _this = this;
        var _a2 = options || {}, width = _a2.width, height = _a2.height;
        _this = _super.call(this, width, height) || this;
        _this.items = [];
        _this.itemDirtyIds = [];
        for (var i = 0; i < length; i++) {
          var partTexture = new BaseTexture2();
          _this.items.push(partTexture);
          _this.itemDirtyIds.push(-2);
        }
        _this.length = length;
        _this._load = null;
        _this.baseTexture = null;
        return _this;
      }
      AbstractMultiResource3.prototype.initFromArray = function(resources3, options) {
        for (var i = 0; i < this.length; i++) {
          if (!resources3[i]) {
            continue;
          }
          if (resources3[i].castToBaseTexture) {
            this.addBaseTextureAt(resources3[i].castToBaseTexture(), i);
          } else if (resources3[i] instanceof Resource2) {
            this.addResourceAt(resources3[i], i);
          } else {
            this.addResourceAt(autoDetectResource2(resources3[i], options), i);
          }
        }
      };
      AbstractMultiResource3.prototype.dispose = function() {
        for (var i = 0, len = this.length; i < len; i++) {
          this.items[i].destroy();
        }
        this.items = null;
        this.itemDirtyIds = null;
        this._load = null;
      };
      AbstractMultiResource3.prototype.addResourceAt = function(resource, index) {
        if (!this.items[index]) {
          throw new Error("Index " + index + " is out of bounds");
        }
        if (resource.valid && !this.valid) {
          this.resize(resource.width, resource.height);
        }
        this.items[index].setResource(resource);
        return this;
      };
      AbstractMultiResource3.prototype.bind = function(baseTexture) {
        if (this.baseTexture !== null) {
          throw new Error("Only one base texture per TextureArray is allowed");
        }
        _super.prototype.bind.call(this, baseTexture);
        for (var i = 0; i < this.length; i++) {
          this.items[i].parentTextureArray = baseTexture;
          this.items[i].on("update", baseTexture.update, baseTexture);
        }
      };
      AbstractMultiResource3.prototype.unbind = function(baseTexture) {
        _super.prototype.unbind.call(this, baseTexture);
        for (var i = 0; i < this.length; i++) {
          this.items[i].parentTextureArray = null;
          this.items[i].off("update", baseTexture.update, baseTexture);
        }
      };
      AbstractMultiResource3.prototype.load = function() {
        var _this = this;
        if (this._load) {
          return this._load;
        }
        var resources3 = this.items.map(function(item) {
          return item.resource;
        }).filter(function(item) {
          return item;
        });
        var promises = resources3.map(function(item) {
          return item.load();
        });
        this._load = Promise.all(promises).then(function() {
          var _a2 = _this.items[0], realWidth = _a2.realWidth, realHeight = _a2.realHeight;
          _this.resize(realWidth, realHeight);
          return Promise.resolve(_this);
        });
        return this._load;
      };
      return AbstractMultiResource3;
    }(Resource2)
  );
  var ArrayResource2 = (
    /** @class */
    function(_super) {
      __extends12(ArrayResource3, _super);
      function ArrayResource3(source, options) {
        var _this = this;
        var _a2 = options || {}, width = _a2.width, height = _a2.height;
        var urls;
        var length;
        if (Array.isArray(source)) {
          urls = source;
          length = source.length;
        } else {
          length = source;
        }
        _this = _super.call(this, length, { width, height }) || this;
        if (urls) {
          _this.initFromArray(urls, options);
        }
        return _this;
      }
      ArrayResource3.prototype.addBaseTextureAt = function(baseTexture, index) {
        if (baseTexture.resource) {
          this.addResourceAt(baseTexture.resource, index);
        } else {
          throw new Error("ArrayResource does not support RenderTexture");
        }
        return this;
      };
      ArrayResource3.prototype.bind = function(baseTexture) {
        _super.prototype.bind.call(this, baseTexture);
        baseTexture.target = TARGETS.TEXTURE_2D_ARRAY;
      };
      ArrayResource3.prototype.upload = function(renderer, texture, glTexture) {
        var _a2 = this, length = _a2.length, itemDirtyIds = _a2.itemDirtyIds, items = _a2.items;
        var gl = renderer.gl;
        if (glTexture.dirtyId < 0) {
          gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, glTexture.internalFormat, this._width, this._height, length, 0, texture.format, glTexture.type, null);
        }
        for (var i = 0; i < length; i++) {
          var item = items[i];
          if (itemDirtyIds[i] < item.dirtyId) {
            itemDirtyIds[i] = item.dirtyId;
            if (item.valid) {
              gl.texSubImage3D(
                gl.TEXTURE_2D_ARRAY,
                0,
                0,
                // xoffset
                0,
                // yoffset
                i,
                // zoffset
                item.resource.width,
                item.resource.height,
                1,
                texture.format,
                glTexture.type,
                item.resource.source
              );
            }
          }
        }
        return true;
      };
      return ArrayResource3;
    }(AbstractMultiResource2)
  );
  var BaseImageResource2 = (
    /** @class */
    function(_super) {
      __extends12(BaseImageResource3, _super);
      function BaseImageResource3(source) {
        var _this = this;
        var sourceAny = source;
        var width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.width;
        var height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.height;
        _this = _super.call(this, width, height) || this;
        _this.source = source;
        _this.noSubImage = false;
        return _this;
      }
      BaseImageResource3.crossOrigin = function(element, url3, crossorigin) {
        if (crossorigin === void 0 && url3.indexOf("data:") !== 0) {
          element.crossOrigin = determineCrossOrigin2(url3);
        } else if (crossorigin !== false) {
          element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
        }
      };
      BaseImageResource3.prototype.upload = function(renderer, baseTexture, glTexture, source) {
        var gl = renderer.gl;
        var width = baseTexture.realWidth;
        var height = baseTexture.realHeight;
        source = source || this.source;
        if (source instanceof HTMLImageElement) {
          if (!source.complete || source.naturalWidth === 0) {
            return false;
          }
        } else if (source instanceof HTMLVideoElement) {
          if (source.readyState <= 1) {
            return false;
          }
        }
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
        if (!this.noSubImage && baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height) {
          gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, glTexture.type, source);
        } else {
          glTexture.width = width;
          glTexture.height = height;
          gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.format, glTexture.type, source);
        }
        return true;
      };
      BaseImageResource3.prototype.update = function() {
        if (this.destroyed) {
          return;
        }
        var source = this.source;
        var width = source.naturalWidth || source.videoWidth || source.width;
        var height = source.naturalHeight || source.videoHeight || source.height;
        this.resize(width, height);
        _super.prototype.update.call(this);
      };
      BaseImageResource3.prototype.dispose = function() {
        this.source = null;
      };
      return BaseImageResource3;
    }(Resource2)
  );
  var CanvasResource2 = (
    /** @class */
    function(_super) {
      __extends12(CanvasResource3, _super);
      function CanvasResource3(source) {
        return _super.call(this, source) || this;
      }
      CanvasResource3.test = function(source) {
        var OffscreenCanvas2 = globalThis.OffscreenCanvas;
        if (OffscreenCanvas2 && source instanceof OffscreenCanvas2) {
          return true;
        }
        return globalThis.HTMLCanvasElement && source instanceof HTMLCanvasElement;
      };
      return CanvasResource3;
    }(BaseImageResource2)
  );
  var CubeResource2 = (
    /** @class */
    function(_super) {
      __extends12(CubeResource3, _super);
      function CubeResource3(source, options) {
        var _this = this;
        var _a2 = options || {}, width = _a2.width, height = _a2.height, autoLoad = _a2.autoLoad, linkBaseTexture = _a2.linkBaseTexture;
        if (source && source.length !== CubeResource3.SIDES) {
          throw new Error("Invalid length. Got " + source.length + ", expected 6");
        }
        _this = _super.call(this, 6, { width, height }) || this;
        for (var i = 0; i < CubeResource3.SIDES; i++) {
          _this.items[i].target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i;
        }
        _this.linkBaseTexture = linkBaseTexture !== false;
        if (source) {
          _this.initFromArray(source, options);
        }
        if (autoLoad !== false) {
          _this.load();
        }
        return _this;
      }
      CubeResource3.prototype.bind = function(baseTexture) {
        _super.prototype.bind.call(this, baseTexture);
        baseTexture.target = TARGETS.TEXTURE_CUBE_MAP;
      };
      CubeResource3.prototype.addBaseTextureAt = function(baseTexture, index, linkBaseTexture) {
        if (!this.items[index]) {
          throw new Error("Index " + index + " is out of bounds");
        }
        if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0) {
          if (baseTexture.resource) {
            this.addResourceAt(baseTexture.resource, index);
          } else {
            throw new Error("CubeResource does not support copying of renderTexture.");
          }
        } else {
          baseTexture.target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index;
          baseTexture.parentTextureArray = this.baseTexture;
          this.items[index] = baseTexture;
        }
        if (baseTexture.valid && !this.valid) {
          this.resize(baseTexture.realWidth, baseTexture.realHeight);
        }
        this.items[index] = baseTexture;
        return this;
      };
      CubeResource3.prototype.upload = function(renderer, _baseTexture, glTexture) {
        var dirty = this.itemDirtyIds;
        for (var i = 0; i < CubeResource3.SIDES; i++) {
          var side = this.items[i];
          if (dirty[i] < side.dirtyId) {
            if (side.valid && side.resource) {
              side.resource.upload(renderer, side, glTexture);
              dirty[i] = side.dirtyId;
            } else if (dirty[i] < -1) {
              renderer.gl.texImage2D(side.target, 0, glTexture.internalFormat, _baseTexture.realWidth, _baseTexture.realHeight, 0, _baseTexture.format, glTexture.type, null);
              dirty[i] = -1;
            }
          }
        }
        return true;
      };
      CubeResource3.test = function(source) {
        return Array.isArray(source) && source.length === CubeResource3.SIDES;
      };
      CubeResource3.SIDES = 6;
      return CubeResource3;
    }(AbstractMultiResource2)
  );
  var ImageResource2 = (
    /** @class */
    function(_super) {
      __extends12(ImageResource3, _super);
      function ImageResource3(source, options) {
        var _this = this;
        options = options || {};
        if (!(source instanceof HTMLImageElement)) {
          var imageElement = new Image();
          BaseImageResource2.crossOrigin(imageElement, source, options.crossorigin);
          imageElement.src = source;
          source = imageElement;
        }
        _this = _super.call(this, source) || this;
        if (!source.complete && !!_this._width && !!_this._height) {
          _this._width = 0;
          _this._height = 0;
        }
        _this.url = source.src;
        _this._process = null;
        _this.preserveBitmap = false;
        _this.createBitmap = (options.createBitmap !== void 0 ? options.createBitmap : settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap;
        _this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;
        _this.bitmap = null;
        _this._load = null;
        if (options.autoLoad !== false) {
          _this.load();
        }
        return _this;
      }
      ImageResource3.prototype.load = function(createBitmap) {
        var _this = this;
        if (this._load) {
          return this._load;
        }
        if (createBitmap !== void 0) {
          this.createBitmap = createBitmap;
        }
        this._load = new Promise(function(resolve3, reject) {
          var source = _this.source;
          _this.url = source.src;
          var completed = function() {
            if (_this.destroyed) {
              return;
            }
            source.onload = null;
            source.onerror = null;
            _this.resize(source.width, source.height);
            _this._load = null;
            if (_this.createBitmap) {
              resolve3(_this.process());
            } else {
              resolve3(_this);
            }
          };
          if (source.complete && source.src) {
            completed();
          } else {
            source.onload = completed;
            source.onerror = function(event) {
              reject(event);
              _this.onError.emit(event);
            };
          }
        });
        return this._load;
      };
      ImageResource3.prototype.process = function() {
        var _this = this;
        var source = this.source;
        if (this._process !== null) {
          return this._process;
        }
        if (this.bitmap !== null || !globalThis.createImageBitmap) {
          return Promise.resolve(this);
        }
        var createImageBitmap = globalThis.createImageBitmap;
        var cors = !source.crossOrigin || source.crossOrigin === "anonymous";
        this._process = fetch(source.src, {
          mode: cors ? "cors" : "no-cors"
        }).then(function(r) {
          return r.blob();
        }).then(function(blob) {
          return createImageBitmap(blob, 0, 0, source.width, source.height, {
            premultiplyAlpha: _this.alphaMode === ALPHA_MODES.UNPACK ? "premultiply" : "none"
          });
        }).then(function(bitmap) {
          if (_this.destroyed) {
            return Promise.reject();
          }
          _this.bitmap = bitmap;
          _this.update();
          _this._process = null;
          return Promise.resolve(_this);
        });
        return this._process;
      };
      ImageResource3.prototype.upload = function(renderer, baseTexture, glTexture) {
        if (typeof this.alphaMode === "number") {
          baseTexture.alphaMode = this.alphaMode;
        }
        if (!this.createBitmap) {
          return _super.prototype.upload.call(this, renderer, baseTexture, glTexture);
        }
        if (!this.bitmap) {
          this.process();
          if (!this.bitmap) {
            return false;
          }
        }
        _super.prototype.upload.call(this, renderer, baseTexture, glTexture, this.bitmap);
        if (!this.preserveBitmap) {
          var flag = true;
          var glTextures = baseTexture._glTextures;
          for (var key in glTextures) {
            var otherTex = glTextures[key];
            if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {
              flag = false;
              break;
            }
          }
          if (flag) {
            if (this.bitmap.close) {
              this.bitmap.close();
            }
            this.bitmap = null;
          }
        }
        return true;
      };
      ImageResource3.prototype.dispose = function() {
        this.source.onload = null;
        this.source.onerror = null;
        _super.prototype.dispose.call(this);
        if (this.bitmap) {
          this.bitmap.close();
          this.bitmap = null;
        }
        this._process = null;
        this._load = null;
      };
      ImageResource3.test = function(source) {
        return typeof source === "string" || source instanceof HTMLImageElement;
      };
      return ImageResource3;
    }(BaseImageResource2)
  );
  var SVGResource2 = (
    /** @class */
    function(_super) {
      __extends12(SVGResource3, _super);
      function SVGResource3(sourceBase64, options) {
        var _this = this;
        options = options || {};
        _this = _super.call(this, document.createElement("canvas")) || this;
        _this._width = 0;
        _this._height = 0;
        _this.svg = sourceBase64;
        _this.scale = options.scale || 1;
        _this._overrideWidth = options.width;
        _this._overrideHeight = options.height;
        _this._resolve = null;
        _this._crossorigin = options.crossorigin;
        _this._load = null;
        if (options.autoLoad !== false) {
          _this.load();
        }
        return _this;
      }
      SVGResource3.prototype.load = function() {
        var _this = this;
        if (this._load) {
          return this._load;
        }
        this._load = new Promise(function(resolve3) {
          _this._resolve = function() {
            _this.resize(_this.source.width, _this.source.height);
            resolve3(_this);
          };
          if (SVGResource3.SVG_XML.test(_this.svg.trim())) {
            if (!btoa) {
              throw new Error("Your browser doesn't support base64 conversions.");
            }
            _this.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(_this.svg)));
          }
          _this._loadSvg();
        });
        return this._load;
      };
      SVGResource3.prototype._loadSvg = function() {
        var _this = this;
        var tempImage = new Image();
        BaseImageResource2.crossOrigin(tempImage, this.svg, this._crossorigin);
        tempImage.src = this.svg;
        tempImage.onerror = function(event) {
          if (!_this._resolve) {
            return;
          }
          tempImage.onerror = null;
          _this.onError.emit(event);
        };
        tempImage.onload = function() {
          if (!_this._resolve) {
            return;
          }
          var svgWidth = tempImage.width;
          var svgHeight = tempImage.height;
          if (!svgWidth || !svgHeight) {
            throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
          }
          var width = svgWidth * _this.scale;
          var height = svgHeight * _this.scale;
          if (_this._overrideWidth || _this._overrideHeight) {
            width = _this._overrideWidth || _this._overrideHeight / svgHeight * svgWidth;
            height = _this._overrideHeight || _this._overrideWidth / svgWidth * svgHeight;
          }
          width = Math.round(width);
          height = Math.round(height);
          var canvas = _this.source;
          canvas.width = width;
          canvas.height = height;
          canvas._pixiId = "canvas_" + uid2();
          canvas.getContext("2d").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);
          _this._resolve();
          _this._resolve = null;
        };
      };
      SVGResource3.getSize = function(svgString) {
        var sizeMatch = SVGResource3.SVG_SIZE.exec(svgString);
        var size = {};
        if (sizeMatch) {
          size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
          size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
        }
        return size;
      };
      SVGResource3.prototype.dispose = function() {
        _super.prototype.dispose.call(this);
        this._resolve = null;
        this._crossorigin = null;
      };
      SVGResource3.test = function(source, extension) {
        return extension === "svg" || typeof source === "string" && /^data:image\/svg\+xml(;(charset=utf8|utf8))?;base64/.test(source) || typeof source === "string" && SVGResource3.SVG_XML.test(source);
      };
      SVGResource3.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m;
      SVGResource3.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
      return SVGResource3;
    }(BaseImageResource2)
  );
  var VideoResource2 = (
    /** @class */
    function(_super) {
      __extends12(VideoResource3, _super);
      function VideoResource3(source, options) {
        var _this = this;
        options = options || {};
        if (!(source instanceof HTMLVideoElement)) {
          var videoElement = document.createElement("video");
          videoElement.setAttribute("preload", "auto");
          videoElement.setAttribute("webkit-playsinline", "");
          videoElement.setAttribute("playsinline", "");
          if (typeof source === "string") {
            source = [source];
          }
          var firstSrc = source[0].src || source[0];
          BaseImageResource2.crossOrigin(videoElement, firstSrc, options.crossorigin);
          for (var i = 0; i < source.length; ++i) {
            var sourceElement = document.createElement("source");
            var _a2 = source[i], src = _a2.src, mime = _a2.mime;
            src = src || source[i];
            var baseSrc = src.split("?").shift().toLowerCase();
            var ext = baseSrc.slice(baseSrc.lastIndexOf(".") + 1);
            mime = mime || VideoResource3.MIME_TYPES[ext] || "video/" + ext;
            sourceElement.src = src;
            sourceElement.type = mime;
            videoElement.appendChild(sourceElement);
          }
          source = videoElement;
        }
        _this = _super.call(this, source) || this;
        _this.noSubImage = true;
        _this._autoUpdate = true;
        _this._isConnectedToTicker = false;
        _this._updateFPS = options.updateFPS || 0;
        _this._msToNextUpdate = 0;
        _this.autoPlay = options.autoPlay !== false;
        _this._load = null;
        _this._resolve = null;
        _this._onCanPlay = _this._onCanPlay.bind(_this);
        _this._onError = _this._onError.bind(_this);
        if (options.autoLoad !== false) {
          _this.load();
        }
        return _this;
      }
      VideoResource3.prototype.update = function(_deltaTime) {
        if (!this.destroyed) {
          var elapsedMS = Ticker2.shared.elapsedMS * this.source.playbackRate;
          this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
          if (!this._updateFPS || this._msToNextUpdate <= 0) {
            _super.prototype.update.call(this);
            this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
          }
        }
      };
      VideoResource3.prototype.load = function() {
        var _this = this;
        if (this._load) {
          return this._load;
        }
        var source = this.source;
        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {
          source.complete = true;
        }
        source.addEventListener("play", this._onPlayStart.bind(this));
        source.addEventListener("pause", this._onPlayStop.bind(this));
        if (!this._isSourceReady()) {
          source.addEventListener("canplay", this._onCanPlay);
          source.addEventListener("canplaythrough", this._onCanPlay);
          source.addEventListener("error", this._onError, true);
        } else {
          this._onCanPlay();
        }
        this._load = new Promise(function(resolve3) {
          if (_this.valid) {
            resolve3(_this);
          } else {
            _this._resolve = resolve3;
            source.load();
          }
        });
        return this._load;
      };
      VideoResource3.prototype._onError = function(event) {
        this.source.removeEventListener("error", this._onError, true);
        this.onError.emit(event);
      };
      VideoResource3.prototype._isSourcePlaying = function() {
        var source = this.source;
        return source.currentTime > 0 && source.paused === false && source.ended === false && source.readyState > 2;
      };
      VideoResource3.prototype._isSourceReady = function() {
        var source = this.source;
        return source.readyState === 3 || source.readyState === 4;
      };
      VideoResource3.prototype._onPlayStart = function() {
        if (!this.valid) {
          this._onCanPlay();
        }
        if (this.autoUpdate && !this._isConnectedToTicker) {
          Ticker2.shared.add(this.update, this);
          this._isConnectedToTicker = true;
        }
      };
      VideoResource3.prototype._onPlayStop = function() {
        if (this._isConnectedToTicker) {
          Ticker2.shared.remove(this.update, this);
          this._isConnectedToTicker = false;
        }
      };
      VideoResource3.prototype._onCanPlay = function() {
        var source = this.source;
        source.removeEventListener("canplay", this._onCanPlay);
        source.removeEventListener("canplaythrough", this._onCanPlay);
        var valid = this.valid;
        this.resize(source.videoWidth, source.videoHeight);
        if (!valid && this._resolve) {
          this._resolve(this);
          this._resolve = null;
        }
        if (this._isSourcePlaying()) {
          this._onPlayStart();
        } else if (this.autoPlay) {
          source.play();
        }
      };
      VideoResource3.prototype.dispose = function() {
        if (this._isConnectedToTicker) {
          Ticker2.shared.remove(this.update, this);
          this._isConnectedToTicker = false;
        }
        var source = this.source;
        if (source) {
          source.removeEventListener("error", this._onError, true);
          source.pause();
          source.src = "";
          source.load();
        }
        _super.prototype.dispose.call(this);
      };
      Object.defineProperty(VideoResource3.prototype, "autoUpdate", {
        /** Should the base texture automatically update itself, set to true by default. */
        get: function() {
          return this._autoUpdate;
        },
        set: function(value) {
          if (value !== this._autoUpdate) {
            this._autoUpdate = value;
            if (!this._autoUpdate && this._isConnectedToTicker) {
              Ticker2.shared.remove(this.update, this);
              this._isConnectedToTicker = false;
            } else if (this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying()) {
              Ticker2.shared.add(this.update, this);
              this._isConnectedToTicker = true;
            }
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(VideoResource3.prototype, "updateFPS", {
        /**
         * How many times a second to update the texture from the video. Leave at 0 to update at every render.
         * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
         */
        get: function() {
          return this._updateFPS;
        },
        set: function(value) {
          if (value !== this._updateFPS) {
            this._updateFPS = value;
          }
        },
        enumerable: false,
        configurable: true
      });
      VideoResource3.test = function(source, extension) {
        return globalThis.HTMLVideoElement && source instanceof HTMLVideoElement || VideoResource3.TYPES.indexOf(extension) > -1;
      };
      VideoResource3.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"];
      VideoResource3.MIME_TYPES = {
        ogv: "video/ogg",
        mov: "video/quicktime",
        m4v: "video/mp4"
      };
      return VideoResource3;
    }(BaseImageResource2)
  );
  var ImageBitmapResource2 = (
    /** @class */
    function(_super) {
      __extends12(ImageBitmapResource3, _super);
      function ImageBitmapResource3(source) {
        return _super.call(this, source) || this;
      }
      ImageBitmapResource3.test = function(source) {
        return !!globalThis.createImageBitmap && source instanceof ImageBitmap;
      };
      return ImageBitmapResource3;
    }(BaseImageResource2)
  );
  INSTALLED2.push(ImageResource2, ImageBitmapResource2, CanvasResource2, VideoResource2, SVGResource2, BufferResource2, CubeResource2, ArrayResource2);
  var _resources2 = {
    __proto__: null,
    Resource: Resource2,
    BaseImageResource: BaseImageResource2,
    INSTALLED: INSTALLED2,
    autoDetectResource: autoDetectResource2,
    AbstractMultiResource: AbstractMultiResource2,
    ArrayResource: ArrayResource2,
    BufferResource: BufferResource2,
    CanvasResource: CanvasResource2,
    CubeResource: CubeResource2,
    ImageResource: ImageResource2,
    SVGResource: SVGResource2,
    VideoResource: VideoResource2,
    ImageBitmapResource: ImageBitmapResource2
  };
  var DepthResource2 = (
    /** @class */
    function(_super) {
      __extends12(DepthResource3, _super);
      function DepthResource3() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      DepthResource3.prototype.upload = function(renderer, baseTexture, glTexture) {
        var gl = renderer.gl;
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
        var width = baseTexture.realWidth;
        var height = baseTexture.realHeight;
        if (glTexture.width === width && glTexture.height === height) {
          gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
        } else {
          glTexture.width = width;
          glTexture.height = height;
          gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
        }
        return true;
      };
      return DepthResource3;
    }(BufferResource2)
  );
  var Framebuffer2 = (
    /** @class */
    function() {
      function Framebuffer3(width, height) {
        this.width = Math.round(width || 100);
        this.height = Math.round(height || 100);
        this.stencil = false;
        this.depth = false;
        this.dirtyId = 0;
        this.dirtyFormat = 0;
        this.dirtySize = 0;
        this.depthTexture = null;
        this.colorTextures = [];
        this.glFramebuffers = {};
        this.disposeRunner = new Runner2("disposeFramebuffer");
        this.multisample = MSAA_QUALITY.NONE;
      }
      Object.defineProperty(Framebuffer3.prototype, "colorTexture", {
        /**
         * Reference to the colorTexture.
         * @readonly
         */
        get: function() {
          return this.colorTextures[0];
        },
        enumerable: false,
        configurable: true
      });
      Framebuffer3.prototype.addColorTexture = function(index, texture) {
        if (index === void 0) {
          index = 0;
        }
        this.colorTextures[index] = texture || new BaseTexture2(null, {
          scaleMode: SCALE_MODES.NEAREST,
          resolution: 1,
          mipmap: MIPMAP_MODES.OFF,
          width: this.width,
          height: this.height
        });
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
      };
      Framebuffer3.prototype.addDepthTexture = function(texture) {
        this.depthTexture = texture || new BaseTexture2(new DepthResource2(null, { width: this.width, height: this.height }), {
          scaleMode: SCALE_MODES.NEAREST,
          resolution: 1,
          width: this.width,
          height: this.height,
          mipmap: MIPMAP_MODES.OFF,
          format: FORMATS.DEPTH_COMPONENT,
          type: TYPES.UNSIGNED_SHORT
        });
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
      };
      Framebuffer3.prototype.enableDepth = function() {
        this.depth = true;
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
      };
      Framebuffer3.prototype.enableStencil = function() {
        this.stencil = true;
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
      };
      Framebuffer3.prototype.resize = function(width, height) {
        width = Math.round(width);
        height = Math.round(height);
        if (width === this.width && height === this.height) {
          return;
        }
        this.width = width;
        this.height = height;
        this.dirtyId++;
        this.dirtySize++;
        for (var i = 0; i < this.colorTextures.length; i++) {
          var texture = this.colorTextures[i];
          var resolution = texture.resolution;
          texture.setSize(width / resolution, height / resolution);
        }
        if (this.depthTexture) {
          var resolution = this.depthTexture.resolution;
          this.depthTexture.setSize(width / resolution, height / resolution);
        }
      };
      Framebuffer3.prototype.dispose = function() {
        this.disposeRunner.emit(this, false);
      };
      Framebuffer3.prototype.destroyDepthTexture = function() {
        if (this.depthTexture) {
          this.depthTexture.destroy();
          this.depthTexture = null;
          ++this.dirtyId;
          ++this.dirtyFormat;
        }
      };
      return Framebuffer3;
    }()
  );
  var BaseRenderTexture2 = (
    /** @class */
    function(_super) {
      __extends12(BaseRenderTexture3, _super);
      function BaseRenderTexture3(options) {
        if (options === void 0) {
          options = {};
        }
        var _this = this;
        if (typeof options === "number") {
          var width = arguments[0];
          var height = arguments[1];
          var scaleMode = arguments[2];
          var resolution = arguments[3];
          options = { width, height, scaleMode, resolution };
        }
        options.width = options.width || 100;
        options.height = options.height || 100;
        options.multisample = options.multisample !== void 0 ? options.multisample : MSAA_QUALITY.NONE;
        _this = _super.call(this, null, options) || this;
        _this.mipmap = MIPMAP_MODES.OFF;
        _this.valid = true;
        _this.clearColor = [0, 0, 0, 0];
        _this.framebuffer = new Framebuffer2(_this.realWidth, _this.realHeight).addColorTexture(0, _this);
        _this.framebuffer.multisample = options.multisample;
        _this.maskStack = [];
        _this.filterStack = [{}];
        return _this;
      }
      BaseRenderTexture3.prototype.resize = function(desiredWidth, desiredHeight) {
        this.framebuffer.resize(desiredWidth * this.resolution, desiredHeight * this.resolution);
        this.setRealSize(this.framebuffer.width, this.framebuffer.height);
      };
      BaseRenderTexture3.prototype.dispose = function() {
        this.framebuffer.dispose();
        _super.prototype.dispose.call(this);
      };
      BaseRenderTexture3.prototype.destroy = function() {
        _super.prototype.destroy.call(this);
        this.framebuffer.destroyDepthTexture();
        this.framebuffer = null;
      };
      return BaseRenderTexture3;
    }(BaseTexture2)
  );
  var TextureUvs2 = (
    /** @class */
    function() {
      function TextureUvs3() {
        this.x0 = 0;
        this.y0 = 0;
        this.x1 = 1;
        this.y1 = 0;
        this.x2 = 1;
        this.y2 = 1;
        this.x3 = 0;
        this.y3 = 1;
        this.uvsFloat32 = new Float32Array(8);
      }
      TextureUvs3.prototype.set = function(frame, baseFrame, rotate) {
        var tw = baseFrame.width;
        var th = baseFrame.height;
        if (rotate) {
          var w2 = frame.width / 2 / tw;
          var h2 = frame.height / 2 / th;
          var cX = frame.x / tw + w2;
          var cY = frame.y / th + h2;
          rotate = groupD82.add(rotate, groupD82.NW);
          this.x0 = cX + w2 * groupD82.uX(rotate);
          this.y0 = cY + h2 * groupD82.uY(rotate);
          rotate = groupD82.add(rotate, 2);
          this.x1 = cX + w2 * groupD82.uX(rotate);
          this.y1 = cY + h2 * groupD82.uY(rotate);
          rotate = groupD82.add(rotate, 2);
          this.x2 = cX + w2 * groupD82.uX(rotate);
          this.y2 = cY + h2 * groupD82.uY(rotate);
          rotate = groupD82.add(rotate, 2);
          this.x3 = cX + w2 * groupD82.uX(rotate);
          this.y3 = cY + h2 * groupD82.uY(rotate);
        } else {
          this.x0 = frame.x / tw;
          this.y0 = frame.y / th;
          this.x1 = (frame.x + frame.width) / tw;
          this.y1 = frame.y / th;
          this.x2 = (frame.x + frame.width) / tw;
          this.y2 = (frame.y + frame.height) / th;
          this.x3 = frame.x / tw;
          this.y3 = (frame.y + frame.height) / th;
        }
        this.uvsFloat32[0] = this.x0;
        this.uvsFloat32[1] = this.y0;
        this.uvsFloat32[2] = this.x1;
        this.uvsFloat32[3] = this.y1;
        this.uvsFloat32[4] = this.x2;
        this.uvsFloat32[5] = this.y2;
        this.uvsFloat32[6] = this.x3;
        this.uvsFloat32[7] = this.y3;
      };
      TextureUvs3.prototype.toString = function() {
        return "[@pixi/core:TextureUvs " + ("x0=" + this.x0 + " y0=" + this.y0 + " ") + ("x1=" + this.x1 + " y1=" + this.y1 + " x2=" + this.x2 + " ") + ("y2=" + this.y2 + " x3=" + this.x3 + " y3=" + this.y3) + "]";
      };
      return TextureUvs3;
    }()
  );
  var DEFAULT_UVS2 = new TextureUvs2();
  function removeAllHandlers2(tex) {
    tex.destroy = function _emptyDestroy() {
    };
    tex.on = function _emptyOn() {
    };
    tex.once = function _emptyOnce() {
    };
    tex.emit = function _emptyEmit() {
    };
  }
  var Texture2 = (
    /** @class */
    function(_super) {
      __extends12(Texture3, _super);
      function Texture3(baseTexture, frame, orig, trim, rotate, anchor) {
        var _this = _super.call(this) || this;
        _this.noFrame = false;
        if (!frame) {
          _this.noFrame = true;
          frame = new Rectangle2(0, 0, 1, 1);
        }
        if (baseTexture instanceof Texture3) {
          baseTexture = baseTexture.baseTexture;
        }
        _this.baseTexture = baseTexture;
        _this._frame = frame;
        _this.trim = trim;
        _this.valid = false;
        _this._uvs = DEFAULT_UVS2;
        _this.uvMatrix = null;
        _this.orig = orig || frame;
        _this._rotate = Number(rotate || 0);
        if (rotate === true) {
          _this._rotate = 2;
        } else if (_this._rotate % 2 !== 0) {
          throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
        }
        _this.defaultAnchor = anchor ? new Point2(anchor.x, anchor.y) : new Point2(0, 0);
        _this._updateID = 0;
        _this.textureCacheIds = [];
        if (!baseTexture.valid) {
          baseTexture.once("loaded", _this.onBaseTextureUpdated, _this);
        } else if (_this.noFrame) {
          if (baseTexture.valid) {
            _this.onBaseTextureUpdated(baseTexture);
          }
        } else {
          _this.frame = frame;
        }
        if (_this.noFrame) {
          baseTexture.on("update", _this.onBaseTextureUpdated, _this);
        }
        return _this;
      }
      Texture3.prototype.update = function() {
        if (this.baseTexture.resource) {
          this.baseTexture.resource.update();
        }
      };
      Texture3.prototype.onBaseTextureUpdated = function(baseTexture) {
        if (this.noFrame) {
          if (!this.baseTexture.valid) {
            return;
          }
          this._frame.width = baseTexture.width;
          this._frame.height = baseTexture.height;
          this.valid = true;
          this.updateUvs();
        } else {
          this.frame = this._frame;
        }
        this.emit("update", this);
      };
      Texture3.prototype.destroy = function(destroyBase) {
        if (this.baseTexture) {
          if (destroyBase) {
            var resource = this.baseTexture.resource;
            if (resource && resource.url && TextureCache2[resource.url]) {
              Texture3.removeFromCache(resource.url);
            }
            this.baseTexture.destroy();
          }
          this.baseTexture.off("loaded", this.onBaseTextureUpdated, this);
          this.baseTexture.off("update", this.onBaseTextureUpdated, this);
          this.baseTexture = null;
        }
        this._frame = null;
        this._uvs = null;
        this.trim = null;
        this.orig = null;
        this.valid = false;
        Texture3.removeFromCache(this);
        this.textureCacheIds = null;
      };
      Texture3.prototype.clone = function() {
        var clonedFrame = this._frame.clone();
        var clonedOrig = this._frame === this.orig ? clonedFrame : this.orig.clone();
        var clonedTexture = new Texture3(this.baseTexture, !this.noFrame && clonedFrame, clonedOrig, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);
        if (this.noFrame) {
          clonedTexture._frame = clonedFrame;
        }
        return clonedTexture;
      };
      Texture3.prototype.updateUvs = function() {
        if (this._uvs === DEFAULT_UVS2) {
          this._uvs = new TextureUvs2();
        }
        this._uvs.set(this._frame, this.baseTexture, this.rotate);
        this._updateID++;
      };
      Texture3.from = function(source, options, strict) {
        if (options === void 0) {
          options = {};
        }
        if (strict === void 0) {
          strict = settings.STRICT_TEXTURE_CACHE;
        }
        var isFrame = typeof source === "string";
        var cacheId = null;
        if (isFrame) {
          cacheId = source;
        } else if (source instanceof BaseTexture2) {
          if (!source.cacheId) {
            var prefix = options && options.pixiIdPrefix || "pixiid";
            source.cacheId = prefix + "-" + uid2();
            BaseTexture2.addToCache(source, source.cacheId);
          }
          cacheId = source.cacheId;
        } else {
          if (!source._pixiId) {
            var prefix = options && options.pixiIdPrefix || "pixiid";
            source._pixiId = prefix + "_" + uid2();
          }
          cacheId = source._pixiId;
        }
        var texture = TextureCache2[cacheId];
        if (isFrame && strict && !texture) {
          throw new Error('The cacheId "' + cacheId + '" does not exist in TextureCache.');
        }
        if (!texture && !(source instanceof BaseTexture2)) {
          if (!options.resolution) {
            options.resolution = getResolutionOfUrl2(source);
          }
          texture = new Texture3(new BaseTexture2(source, options));
          texture.baseTexture.cacheId = cacheId;
          BaseTexture2.addToCache(texture.baseTexture, cacheId);
          Texture3.addToCache(texture, cacheId);
        } else if (!texture && source instanceof BaseTexture2) {
          texture = new Texture3(source);
          Texture3.addToCache(texture, cacheId);
        }
        return texture;
      };
      Texture3.fromURL = function(url3, options) {
        var resourceOptions = Object.assign({ autoLoad: false }, options === null || options === void 0 ? void 0 : options.resourceOptions);
        var texture = Texture3.from(url3, Object.assign({ resourceOptions }, options), false);
        var resource = texture.baseTexture.resource;
        if (texture.baseTexture.valid) {
          return Promise.resolve(texture);
        }
        return resource.load().then(function() {
          return Promise.resolve(texture);
        });
      };
      Texture3.fromBuffer = function(buffer, width, height, options) {
        return new Texture3(BaseTexture2.fromBuffer(buffer, width, height, options));
      };
      Texture3.fromLoader = function(source, imageUrl, name, options) {
        var baseTexture = new BaseTexture2(source, Object.assign({
          scaleMode: settings.SCALE_MODE,
          resolution: getResolutionOfUrl2(imageUrl)
        }, options));
        var resource = baseTexture.resource;
        if (resource instanceof ImageResource2) {
          resource.url = imageUrl;
        }
        var texture = new Texture3(baseTexture);
        if (!name) {
          name = imageUrl;
        }
        BaseTexture2.addToCache(texture.baseTexture, name);
        Texture3.addToCache(texture, name);
        if (name !== imageUrl) {
          BaseTexture2.addToCache(texture.baseTexture, imageUrl);
          Texture3.addToCache(texture, imageUrl);
        }
        if (texture.baseTexture.valid) {
          return Promise.resolve(texture);
        }
        return new Promise(function(resolve3) {
          texture.baseTexture.once("loaded", function() {
            return resolve3(texture);
          });
        });
      };
      Texture3.addToCache = function(texture, id) {
        if (id) {
          if (texture.textureCacheIds.indexOf(id) === -1) {
            texture.textureCacheIds.push(id);
          }
          if (TextureCache2[id]) {
            console.warn("Texture added to the cache with an id [" + id + "] that already had an entry");
          }
          TextureCache2[id] = texture;
        }
      };
      Texture3.removeFromCache = function(texture) {
        if (typeof texture === "string") {
          var textureFromCache = TextureCache2[texture];
          if (textureFromCache) {
            var index = textureFromCache.textureCacheIds.indexOf(texture);
            if (index > -1) {
              textureFromCache.textureCacheIds.splice(index, 1);
            }
            delete TextureCache2[texture];
            return textureFromCache;
          }
        } else if (texture && texture.textureCacheIds) {
          for (var i = 0; i < texture.textureCacheIds.length; ++i) {
            if (TextureCache2[texture.textureCacheIds[i]] === texture) {
              delete TextureCache2[texture.textureCacheIds[i]];
            }
          }
          texture.textureCacheIds.length = 0;
          return texture;
        }
        return null;
      };
      Object.defineProperty(Texture3.prototype, "resolution", {
        /**
         * Returns resolution of baseTexture
         * @readonly
         */
        get: function() {
          return this.baseTexture.resolution;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Texture3.prototype, "frame", {
        /**
         * The frame specifies the region of the base texture that this texture uses.
         * Please call `updateUvs()` after you change coordinates of `frame` manually.
         */
        get: function() {
          return this._frame;
        },
        set: function(frame) {
          this._frame = frame;
          this.noFrame = false;
          var x = frame.x, y = frame.y, width = frame.width, height = frame.height;
          var xNotFit = x + width > this.baseTexture.width;
          var yNotFit = y + height > this.baseTexture.height;
          if (xNotFit || yNotFit) {
            var relationship = xNotFit && yNotFit ? "and" : "or";
            var errorX = "X: " + x + " + " + width + " = " + (x + width) + " > " + this.baseTexture.width;
            var errorY = "Y: " + y + " + " + height + " = " + (y + height) + " > " + this.baseTexture.height;
            throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + (errorX + " " + relationship + " " + errorY));
          }
          this.valid = width && height && this.baseTexture.valid;
          if (!this.trim && !this.rotate) {
            this.orig = frame;
          }
          if (this.valid) {
            this.updateUvs();
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Texture3.prototype, "rotate", {
        /**
         * Indicates whether the texture is rotated inside the atlas
         * set to 2 to compensate for texture packer rotation
         * set to 6 to compensate for spine packer rotation
         * can be used to rotate or mirror sprites
         * See {@link PIXI.groupD8} for explanation
         */
        get: function() {
          return this._rotate;
        },
        set: function(rotate) {
          this._rotate = rotate;
          if (this.valid) {
            this.updateUvs();
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Texture3.prototype, "width", {
        /** The width of the Texture in pixels. */
        get: function() {
          return this.orig.width;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Texture3.prototype, "height", {
        /** The height of the Texture in pixels. */
        get: function() {
          return this.orig.height;
        },
        enumerable: false,
        configurable: true
      });
      Texture3.prototype.castToBaseTexture = function() {
        return this.baseTexture;
      };
      Object.defineProperty(Texture3, "EMPTY", {
        /** An empty texture, used often to not have to create multiple empty textures. Can not be destroyed. */
        get: function() {
          if (!Texture3._EMPTY) {
            Texture3._EMPTY = new Texture3(new BaseTexture2());
            removeAllHandlers2(Texture3._EMPTY);
            removeAllHandlers2(Texture3._EMPTY.baseTexture);
          }
          return Texture3._EMPTY;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Texture3, "WHITE", {
        /** A white texture of 16x16 size, used for graphics and other things Can not be destroyed. */
        get: function() {
          if (!Texture3._WHITE) {
            var canvas = document.createElement("canvas");
            var context3 = canvas.getContext("2d");
            canvas.width = 16;
            canvas.height = 16;
            context3.fillStyle = "white";
            context3.fillRect(0, 0, 16, 16);
            Texture3._WHITE = new Texture3(new BaseTexture2(new CanvasResource2(canvas)));
            removeAllHandlers2(Texture3._WHITE);
            removeAllHandlers2(Texture3._WHITE.baseTexture);
          }
          return Texture3._WHITE;
        },
        enumerable: false,
        configurable: true
      });
      return Texture3;
    }(eventemitter3)
  );
  var RenderTexture2 = (
    /** @class */
    function(_super) {
      __extends12(RenderTexture3, _super);
      function RenderTexture3(baseRenderTexture, frame) {
        var _this = _super.call(this, baseRenderTexture, frame) || this;
        _this.valid = true;
        _this.filterFrame = null;
        _this.filterPoolKey = null;
        _this.updateUvs();
        return _this;
      }
      Object.defineProperty(RenderTexture3.prototype, "framebuffer", {
        /**
         * Shortcut to `this.baseTexture.framebuffer`, saves baseTexture cast.
         * @readonly
         */
        get: function() {
          return this.baseTexture.framebuffer;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(RenderTexture3.prototype, "multisample", {
        /**
         * Shortcut to `this.framebuffer.multisample`.
         * @default PIXI.MSAA_QUALITY.NONE
         */
        get: function() {
          return this.framebuffer.multisample;
        },
        set: function(value) {
          this.framebuffer.multisample = value;
        },
        enumerable: false,
        configurable: true
      });
      RenderTexture3.prototype.resize = function(desiredWidth, desiredHeight, resizeBaseTexture) {
        if (resizeBaseTexture === void 0) {
          resizeBaseTexture = true;
        }
        var resolution = this.baseTexture.resolution;
        var width = Math.round(desiredWidth * resolution) / resolution;
        var height = Math.round(desiredHeight * resolution) / resolution;
        this.valid = width > 0 && height > 0;
        this._frame.width = this.orig.width = width;
        this._frame.height = this.orig.height = height;
        if (resizeBaseTexture) {
          this.baseTexture.resize(width, height);
        }
        this.updateUvs();
      };
      RenderTexture3.prototype.setResolution = function(resolution) {
        var baseTexture = this.baseTexture;
        if (baseTexture.resolution === resolution) {
          return;
        }
        baseTexture.setResolution(resolution);
        this.resize(baseTexture.width, baseTexture.height, false);
      };
      RenderTexture3.create = function(options) {
        var arguments$1 = arguments;
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          rest[_i - 1] = arguments$1[_i];
        }
        if (typeof options === "number") {
          deprecation2("6.0.0", "Arguments (width, height, scaleMode, resolution) have been deprecated.");
          options = {
            width: options,
            height: rest[0],
            scaleMode: rest[1],
            resolution: rest[2]
          };
        }
        return new RenderTexture3(new BaseRenderTexture2(options));
      };
      return RenderTexture3;
    }(Texture2)
  );
  var RenderTexturePool2 = (
    /** @class */
    function() {
      function RenderTexturePool3(textureOptions) {
        this.texturePool = {};
        this.textureOptions = textureOptions || {};
        this.enableFullScreen = false;
        this._pixelsWidth = 0;
        this._pixelsHeight = 0;
      }
      RenderTexturePool3.prototype.createTexture = function(realWidth, realHeight, multisample) {
        if (multisample === void 0) {
          multisample = MSAA_QUALITY.NONE;
        }
        var baseRenderTexture = new BaseRenderTexture2(Object.assign({
          width: realWidth,
          height: realHeight,
          resolution: 1,
          multisample
        }, this.textureOptions));
        return new RenderTexture2(baseRenderTexture);
      };
      RenderTexturePool3.prototype.getOptimalTexture = function(minWidth, minHeight, resolution, multisample) {
        if (resolution === void 0) {
          resolution = 1;
        }
        if (multisample === void 0) {
          multisample = MSAA_QUALITY.NONE;
        }
        var key;
        minWidth = Math.ceil(minWidth * resolution - 1e-6);
        minHeight = Math.ceil(minHeight * resolution - 1e-6);
        if (!this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight) {
          minWidth = nextPow22(minWidth);
          minHeight = nextPow22(minHeight);
          key = ((minWidth & 65535) << 16 | minHeight & 65535) >>> 0;
          if (multisample > 1) {
            key += multisample * 4294967296;
          }
        } else {
          key = multisample > 1 ? -multisample : -1;
        }
        if (!this.texturePool[key]) {
          this.texturePool[key] = [];
        }
        var renderTexture = this.texturePool[key].pop();
        if (!renderTexture) {
          renderTexture = this.createTexture(minWidth, minHeight, multisample);
        }
        renderTexture.filterPoolKey = key;
        renderTexture.setResolution(resolution);
        return renderTexture;
      };
      RenderTexturePool3.prototype.getFilterTexture = function(input, resolution, multisample) {
        var filterTexture = this.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY.NONE);
        filterTexture.filterFrame = input.filterFrame;
        return filterTexture;
      };
      RenderTexturePool3.prototype.returnTexture = function(renderTexture) {
        var key = renderTexture.filterPoolKey;
        renderTexture.filterFrame = null;
        this.texturePool[key].push(renderTexture);
      };
      RenderTexturePool3.prototype.returnFilterTexture = function(renderTexture) {
        this.returnTexture(renderTexture);
      };
      RenderTexturePool3.prototype.clear = function(destroyTextures) {
        destroyTextures = destroyTextures !== false;
        if (destroyTextures) {
          for (var i in this.texturePool) {
            var textures = this.texturePool[i];
            if (textures) {
              for (var j = 0; j < textures.length; j++) {
                textures[j].destroy(true);
              }
            }
          }
        }
        this.texturePool = {};
      };
      RenderTexturePool3.prototype.setScreenSize = function(size) {
        if (size.width === this._pixelsWidth && size.height === this._pixelsHeight) {
          return;
        }
        this.enableFullScreen = size.width > 0 && size.height > 0;
        for (var i in this.texturePool) {
          if (!(Number(i) < 0)) {
            continue;
          }
          var textures = this.texturePool[i];
          if (textures) {
            for (var j = 0; j < textures.length; j++) {
              textures[j].destroy(true);
            }
          }
          this.texturePool[i] = [];
        }
        this._pixelsWidth = size.width;
        this._pixelsHeight = size.height;
      };
      RenderTexturePool3.SCREEN_KEY = -1;
      return RenderTexturePool3;
    }()
  );
  var Attribute2 = (
    /** @class */
    function() {
      function Attribute3(buffer, size, normalized, type, stride, start, instance) {
        if (size === void 0) {
          size = 0;
        }
        if (normalized === void 0) {
          normalized = false;
        }
        if (type === void 0) {
          type = TYPES.FLOAT;
        }
        this.buffer = buffer;
        this.size = size;
        this.normalized = normalized;
        this.type = type;
        this.stride = stride;
        this.start = start;
        this.instance = instance;
      }
      Attribute3.prototype.destroy = function() {
        this.buffer = null;
      };
      Attribute3.from = function(buffer, size, normalized, type, stride) {
        return new Attribute3(buffer, size, normalized, type, stride);
      };
      return Attribute3;
    }()
  );
  var UID$42 = 0;
  var Buffer3 = (
    /** @class */
    function() {
      function Buffer4(data, _static, index) {
        if (_static === void 0) {
          _static = true;
        }
        if (index === void 0) {
          index = false;
        }
        this.data = data || new Float32Array(1);
        this._glBuffers = {};
        this._updateID = 0;
        this.index = index;
        this.static = _static;
        this.id = UID$42++;
        this.disposeRunner = new Runner2("disposeBuffer");
      }
      Buffer4.prototype.update = function(data) {
        if (data instanceof Array) {
          data = new Float32Array(data);
        }
        this.data = data || this.data;
        this._updateID++;
      };
      Buffer4.prototype.dispose = function() {
        this.disposeRunner.emit(this, false);
      };
      Buffer4.prototype.destroy = function() {
        this.dispose();
        this.data = null;
      };
      Object.defineProperty(Buffer4.prototype, "index", {
        get: function() {
          return this.type === BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
        },
        /**
         * Flags whether this is an index buffer.
         *
         * Index buffers are of type `ELEMENT_ARRAY_BUFFER`. Note that setting this property to false will make
         * the buffer of type `ARRAY_BUFFER`.
         *
         * For backwards compatibility.
         */
        set: function(value) {
          this.type = value ? BUFFER_TYPE.ELEMENT_ARRAY_BUFFER : BUFFER_TYPE.ARRAY_BUFFER;
        },
        enumerable: false,
        configurable: true
      });
      Buffer4.from = function(data) {
        if (data instanceof Array) {
          data = new Float32Array(data);
        }
        return new Buffer4(data);
      };
      return Buffer4;
    }()
  );
  var map$12 = {
    Float32Array,
    Uint32Array,
    Int32Array,
    Uint8Array
  };
  function interleaveTypedArrays3(arrays, sizes) {
    var outSize = 0;
    var stride = 0;
    var views = {};
    for (var i = 0; i < arrays.length; i++) {
      stride += sizes[i];
      outSize += arrays[i].length;
    }
    var buffer = new ArrayBuffer(outSize * 4);
    var out = null;
    var littleOffset = 0;
    for (var i = 0; i < arrays.length; i++) {
      var size = sizes[i];
      var array = arrays[i];
      var type = getBufferType2(array);
      if (!views[type]) {
        views[type] = new map$12[type](buffer);
      }
      out = views[type];
      for (var j = 0; j < array.length; j++) {
        var indexStart = (j / size | 0) * stride + littleOffset;
        var index = j % size;
        out[indexStart + index] = array[j];
      }
      littleOffset += size;
    }
    return new Float32Array(buffer);
  }
  var byteSizeMap$12 = { 5126: 4, 5123: 2, 5121: 1 };
  var UID$32 = 0;
  var map3 = {
    Float32Array,
    Uint32Array,
    Int32Array,
    Uint8Array,
    Uint16Array
  };
  var Geometry2 = (
    /** @class */
    function() {
      function Geometry3(buffers, attributes) {
        if (buffers === void 0) {
          buffers = [];
        }
        if (attributes === void 0) {
          attributes = {};
        }
        this.buffers = buffers;
        this.indexBuffer = null;
        this.attributes = attributes;
        this.glVertexArrayObjects = {};
        this.id = UID$32++;
        this.instanced = false;
        this.instanceCount = 1;
        this.disposeRunner = new Runner2("disposeGeometry");
        this.refCount = 0;
      }
      Geometry3.prototype.addAttribute = function(id, buffer, size, normalized, type, stride, start, instance) {
        if (size === void 0) {
          size = 0;
        }
        if (normalized === void 0) {
          normalized = false;
        }
        if (instance === void 0) {
          instance = false;
        }
        if (!buffer) {
          throw new Error("You must pass a buffer when creating an attribute");
        }
        if (!(buffer instanceof Buffer3)) {
          if (buffer instanceof Array) {
            buffer = new Float32Array(buffer);
          }
          buffer = new Buffer3(buffer);
        }
        var ids = id.split("|");
        if (ids.length > 1) {
          for (var i = 0; i < ids.length; i++) {
            this.addAttribute(ids[i], buffer, size, normalized, type);
          }
          return this;
        }
        var bufferIndex = this.buffers.indexOf(buffer);
        if (bufferIndex === -1) {
          this.buffers.push(buffer);
          bufferIndex = this.buffers.length - 1;
        }
        this.attributes[id] = new Attribute2(bufferIndex, size, normalized, type, stride, start, instance);
        this.instanced = this.instanced || instance;
        return this;
      };
      Geometry3.prototype.getAttribute = function(id) {
        return this.attributes[id];
      };
      Geometry3.prototype.getBuffer = function(id) {
        return this.buffers[this.getAttribute(id).buffer];
      };
      Geometry3.prototype.addIndex = function(buffer) {
        if (!(buffer instanceof Buffer3)) {
          if (buffer instanceof Array) {
            buffer = new Uint16Array(buffer);
          }
          buffer = new Buffer3(buffer);
        }
        buffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
        this.indexBuffer = buffer;
        if (this.buffers.indexOf(buffer) === -1) {
          this.buffers.push(buffer);
        }
        return this;
      };
      Geometry3.prototype.getIndex = function() {
        return this.indexBuffer;
      };
      Geometry3.prototype.interleave = function() {
        if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer) {
          return this;
        }
        var arrays = [];
        var sizes = [];
        var interleavedBuffer = new Buffer3();
        var i;
        for (i in this.attributes) {
          var attribute = this.attributes[i];
          var buffer = this.buffers[attribute.buffer];
          arrays.push(buffer.data);
          sizes.push(attribute.size * byteSizeMap$12[attribute.type] / 4);
          attribute.buffer = 0;
        }
        interleavedBuffer.data = interleaveTypedArrays3(arrays, sizes);
        for (i = 0; i < this.buffers.length; i++) {
          if (this.buffers[i] !== this.indexBuffer) {
            this.buffers[i].destroy();
          }
        }
        this.buffers = [interleavedBuffer];
        if (this.indexBuffer) {
          this.buffers.push(this.indexBuffer);
        }
        return this;
      };
      Geometry3.prototype.getSize = function() {
        for (var i in this.attributes) {
          var attribute = this.attributes[i];
          var buffer = this.buffers[attribute.buffer];
          return buffer.data.length / (attribute.stride / 4 || attribute.size);
        }
        return 0;
      };
      Geometry3.prototype.dispose = function() {
        this.disposeRunner.emit(this, false);
      };
      Geometry3.prototype.destroy = function() {
        this.dispose();
        this.buffers = null;
        this.indexBuffer = null;
        this.attributes = null;
      };
      Geometry3.prototype.clone = function() {
        var geometry = new Geometry3();
        for (var i = 0; i < this.buffers.length; i++) {
          geometry.buffers[i] = new Buffer3(this.buffers[i].data.slice(0));
        }
        for (var i in this.attributes) {
          var attrib = this.attributes[i];
          geometry.attributes[i] = new Attribute2(attrib.buffer, attrib.size, attrib.normalized, attrib.type, attrib.stride, attrib.start, attrib.instance);
        }
        if (this.indexBuffer) {
          geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];
          geometry.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
        }
        return geometry;
      };
      Geometry3.merge = function(geometries) {
        var geometryOut = new Geometry3();
        var arrays = [];
        var sizes = [];
        var offsets = [];
        var geometry;
        for (var i = 0; i < geometries.length; i++) {
          geometry = geometries[i];
          for (var j = 0; j < geometry.buffers.length; j++) {
            sizes[j] = sizes[j] || 0;
            sizes[j] += geometry.buffers[j].data.length;
            offsets[j] = 0;
          }
        }
        for (var i = 0; i < geometry.buffers.length; i++) {
          arrays[i] = new map3[getBufferType2(geometry.buffers[i].data)](sizes[i]);
          geometryOut.buffers[i] = new Buffer3(arrays[i]);
        }
        for (var i = 0; i < geometries.length; i++) {
          geometry = geometries[i];
          for (var j = 0; j < geometry.buffers.length; j++) {
            arrays[j].set(geometry.buffers[j].data, offsets[j]);
            offsets[j] += geometry.buffers[j].data.length;
          }
        }
        geometryOut.attributes = geometry.attributes;
        if (geometry.indexBuffer) {
          geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];
          geometryOut.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
          var offset = 0;
          var stride = 0;
          var offset2 = 0;
          var bufferIndexToCount = 0;
          for (var i = 0; i < geometry.buffers.length; i++) {
            if (geometry.buffers[i] !== geometry.indexBuffer) {
              bufferIndexToCount = i;
              break;
            }
          }
          for (var i in geometry.attributes) {
            var attribute = geometry.attributes[i];
            if ((attribute.buffer | 0) === bufferIndexToCount) {
              stride += attribute.size * byteSizeMap$12[attribute.type] / 4;
            }
          }
          for (var i = 0; i < geometries.length; i++) {
            var indexBufferData = geometries[i].indexBuffer.data;
            for (var j = 0; j < indexBufferData.length; j++) {
              geometryOut.indexBuffer.data[j + offset2] += offset;
            }
            offset += geometries[i].buffers[bufferIndexToCount].data.length / stride;
            offset2 += indexBufferData.length;
          }
        }
        return geometryOut;
      };
      return Geometry3;
    }()
  );
  var Quad2 = (
    /** @class */
    function(_super) {
      __extends12(Quad3, _super);
      function Quad3() {
        var _this = _super.call(this) || this;
        _this.addAttribute("aVertexPosition", new Float32Array([
          0,
          0,
          1,
          0,
          1,
          1,
          0,
          1
        ])).addIndex([0, 1, 3, 2]);
        return _this;
      }
      return Quad3;
    }(Geometry2)
  );
  var QuadUv2 = (
    /** @class */
    function(_super) {
      __extends12(QuadUv3, _super);
      function QuadUv3() {
        var _this = _super.call(this) || this;
        _this.vertices = new Float32Array([
          -1,
          -1,
          1,
          -1,
          1,
          1,
          -1,
          1
        ]);
        _this.uvs = new Float32Array([
          0,
          0,
          1,
          0,
          1,
          1,
          0,
          1
        ]);
        _this.vertexBuffer = new Buffer3(_this.vertices);
        _this.uvBuffer = new Buffer3(_this.uvs);
        _this.addAttribute("aVertexPosition", _this.vertexBuffer).addAttribute("aTextureCoord", _this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);
        return _this;
      }
      QuadUv3.prototype.map = function(targetTextureFrame, destinationFrame) {
        var x = 0;
        var y = 0;
        this.uvs[0] = x;
        this.uvs[1] = y;
        this.uvs[2] = x + destinationFrame.width / targetTextureFrame.width;
        this.uvs[3] = y;
        this.uvs[4] = x + destinationFrame.width / targetTextureFrame.width;
        this.uvs[5] = y + destinationFrame.height / targetTextureFrame.height;
        this.uvs[6] = x;
        this.uvs[7] = y + destinationFrame.height / targetTextureFrame.height;
        x = destinationFrame.x;
        y = destinationFrame.y;
        this.vertices[0] = x;
        this.vertices[1] = y;
        this.vertices[2] = x + destinationFrame.width;
        this.vertices[3] = y;
        this.vertices[4] = x + destinationFrame.width;
        this.vertices[5] = y + destinationFrame.height;
        this.vertices[6] = x;
        this.vertices[7] = y + destinationFrame.height;
        this.invalidate();
        return this;
      };
      QuadUv3.prototype.invalidate = function() {
        this.vertexBuffer._updateID++;
        this.uvBuffer._updateID++;
        return this;
      };
      return QuadUv3;
    }(Geometry2)
  );
  var UID$22 = 0;
  var UniformGroup2 = (
    /** @class */
    function() {
      function UniformGroup3(uniforms, isStatic, isUbo) {
        this.group = true;
        this.syncUniforms = {};
        this.dirtyId = 0;
        this.id = UID$22++;
        this.static = !!isStatic;
        this.ubo = !!isUbo;
        if (uniforms instanceof Buffer3) {
          this.buffer = uniforms;
          this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER;
          this.autoManage = false;
          this.ubo = true;
        } else {
          this.uniforms = uniforms;
          if (this.ubo) {
            this.buffer = new Buffer3(new Float32Array(1));
            this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER;
            this.autoManage = true;
          }
        }
      }
      UniformGroup3.prototype.update = function() {
        this.dirtyId++;
        if (!this.autoManage && this.buffer) {
          this.buffer.update();
        }
      };
      UniformGroup3.prototype.add = function(name, uniforms, _static) {
        if (!this.ubo) {
          this.uniforms[name] = new UniformGroup3(uniforms, _static);
        } else {
          throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
        }
      };
      UniformGroup3.from = function(uniforms, _static, _ubo) {
        return new UniformGroup3(uniforms, _static, _ubo);
      };
      UniformGroup3.uboFrom = function(uniforms, _static) {
        return new UniformGroup3(uniforms, _static !== null && _static !== void 0 ? _static : true, true);
      };
      return UniformGroup3;
    }()
  );
  var FilterState2 = (
    /** @class */
    function() {
      function FilterState3() {
        this.renderTexture = null;
        this.target = null;
        this.legacy = false;
        this.resolution = 1;
        this.multisample = MSAA_QUALITY.NONE;
        this.sourceFrame = new Rectangle2();
        this.destinationFrame = new Rectangle2();
        this.bindingSourceFrame = new Rectangle2();
        this.bindingDestinationFrame = new Rectangle2();
        this.filters = [];
        this.transform = null;
      }
      FilterState3.prototype.clear = function() {
        this.target = null;
        this.filters = null;
        this.renderTexture = null;
      };
      return FilterState3;
    }()
  );
  var tempPoints3 = [new Point2(), new Point2(), new Point2(), new Point2()];
  var tempMatrix$22 = new Matrix2();
  var FilterSystem2 = (
    /** @class */
    function() {
      function FilterSystem3(renderer) {
        this.renderer = renderer;
        this.defaultFilterStack = [{}];
        this.texturePool = new RenderTexturePool2();
        this.texturePool.setScreenSize(renderer.view);
        this.statePool = [];
        this.quad = new Quad2();
        this.quadUv = new QuadUv2();
        this.tempRect = new Rectangle2();
        this.activeState = {};
        this.globalUniforms = new UniformGroup2({
          outputFrame: new Rectangle2(),
          inputSize: new Float32Array(4),
          inputPixel: new Float32Array(4),
          inputClamp: new Float32Array(4),
          resolution: 1,
          // legacy variables
          filterArea: new Float32Array(4),
          filterClamp: new Float32Array(4)
        }, true);
        this.forceClear = false;
        this.useMaxPadding = false;
      }
      FilterSystem3.prototype.push = function(target, filters2) {
        var _a2, _b;
        var renderer = this.renderer;
        var filterStack = this.defaultFilterStack;
        var state = this.statePool.pop() || new FilterState2();
        var renderTextureSystem = this.renderer.renderTexture;
        var resolution = filters2[0].resolution;
        var multisample = filters2[0].multisample;
        var padding = filters2[0].padding;
        var autoFit = filters2[0].autoFit;
        var legacy = (_a2 = filters2[0].legacy) !== null && _a2 !== void 0 ? _a2 : true;
        for (var i = 1; i < filters2.length; i++) {
          var filter = filters2[i];
          resolution = Math.min(resolution, filter.resolution);
          multisample = Math.min(multisample, filter.multisample);
          padding = this.useMaxPadding ? Math.max(padding, filter.padding) : padding + filter.padding;
          autoFit = autoFit && filter.autoFit;
          legacy = legacy || ((_b = filter.legacy) !== null && _b !== void 0 ? _b : true);
        }
        if (filterStack.length === 1) {
          this.defaultFilterStack[0].renderTexture = renderTextureSystem.current;
        }
        filterStack.push(state);
        state.resolution = resolution;
        state.multisample = multisample;
        state.legacy = legacy;
        state.target = target;
        state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));
        state.sourceFrame.pad(padding);
        var sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);
        if (renderer.projection.transform) {
          this.transformAABB(tempMatrix$22.copyFrom(renderer.projection.transform).invert(), sourceFrameProjected);
        }
        if (autoFit) {
          state.sourceFrame.fit(sourceFrameProjected);
          if (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0) {
            state.sourceFrame.width = 0;
            state.sourceFrame.height = 0;
          }
        } else if (!state.sourceFrame.intersects(sourceFrameProjected)) {
          state.sourceFrame.width = 0;
          state.sourceFrame.height = 0;
        }
        this.roundFrame(state.sourceFrame, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);
        state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution, multisample);
        state.filters = filters2;
        state.destinationFrame.width = state.renderTexture.width;
        state.destinationFrame.height = state.renderTexture.height;
        var destinationFrame = this.tempRect;
        destinationFrame.x = 0;
        destinationFrame.y = 0;
        destinationFrame.width = state.sourceFrame.width;
        destinationFrame.height = state.sourceFrame.height;
        state.renderTexture.filterFrame = state.sourceFrame;
        state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);
        state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);
        state.transform = renderer.projection.transform;
        renderer.projection.transform = null;
        renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame);
        renderer.framebuffer.clear(0, 0, 0, 0);
      };
      FilterSystem3.prototype.pop = function() {
        var filterStack = this.defaultFilterStack;
        var state = filterStack.pop();
        var filters2 = state.filters;
        this.activeState = state;
        var globalUniforms = this.globalUniforms.uniforms;
        globalUniforms.outputFrame = state.sourceFrame;
        globalUniforms.resolution = state.resolution;
        var inputSize = globalUniforms.inputSize;
        var inputPixel = globalUniforms.inputPixel;
        var inputClamp = globalUniforms.inputClamp;
        inputSize[0] = state.destinationFrame.width;
        inputSize[1] = state.destinationFrame.height;
        inputSize[2] = 1 / inputSize[0];
        inputSize[3] = 1 / inputSize[1];
        inputPixel[0] = Math.round(inputSize[0] * state.resolution);
        inputPixel[1] = Math.round(inputSize[1] * state.resolution);
        inputPixel[2] = 1 / inputPixel[0];
        inputPixel[3] = 1 / inputPixel[1];
        inputClamp[0] = 0.5 * inputPixel[2];
        inputClamp[1] = 0.5 * inputPixel[3];
        inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2];
        inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3];
        if (state.legacy) {
          var filterArea = globalUniforms.filterArea;
          filterArea[0] = state.destinationFrame.width;
          filterArea[1] = state.destinationFrame.height;
          filterArea[2] = state.sourceFrame.x;
          filterArea[3] = state.sourceFrame.y;
          globalUniforms.filterClamp = globalUniforms.inputClamp;
        }
        this.globalUniforms.update();
        var lastState = filterStack[filterStack.length - 1];
        this.renderer.framebuffer.blit();
        if (filters2.length === 1) {
          filters2[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES.BLEND, state);
          this.returnFilterTexture(state.renderTexture);
        } else {
          var flip = state.renderTexture;
          var flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
          flop.filterFrame = flip.filterFrame;
          var i = 0;
          for (i = 0; i < filters2.length - 1; ++i) {
            if (i === 1 && state.multisample > 1) {
              flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
              flop.filterFrame = flip.filterFrame;
            }
            filters2[i].apply(this, flip, flop, CLEAR_MODES.CLEAR, state);
            var t = flip;
            flip = flop;
            flop = t;
          }
          filters2[i].apply(this, flip, lastState.renderTexture, CLEAR_MODES.BLEND, state);
          if (i > 1 && state.multisample > 1) {
            this.returnFilterTexture(state.renderTexture);
          }
          this.returnFilterTexture(flip);
          this.returnFilterTexture(flop);
        }
        state.clear();
        this.statePool.push(state);
      };
      FilterSystem3.prototype.bindAndClear = function(filterTexture, clearMode) {
        if (clearMode === void 0) {
          clearMode = CLEAR_MODES.CLEAR;
        }
        var _a2 = this.renderer, renderTextureSystem = _a2.renderTexture, stateSystem = _a2.state;
        if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
          this.renderer.projection.transform = this.activeState.transform;
        } else {
          this.renderer.projection.transform = null;
        }
        if (filterTexture && filterTexture.filterFrame) {
          var destinationFrame = this.tempRect;
          destinationFrame.x = 0;
          destinationFrame.y = 0;
          destinationFrame.width = filterTexture.filterFrame.width;
          destinationFrame.height = filterTexture.filterFrame.height;
          renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);
        } else if (filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
          renderTextureSystem.bind(filterTexture);
        } else {
          this.renderer.renderTexture.bind(filterTexture, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
        }
        var autoClear = stateSystem.stateId & 1 || this.forceClear;
        if (clearMode === CLEAR_MODES.CLEAR || clearMode === CLEAR_MODES.BLIT && autoClear) {
          this.renderer.framebuffer.clear(0, 0, 0, 0);
        }
      };
      FilterSystem3.prototype.applyFilter = function(filter, input, output, clearMode) {
        var renderer = this.renderer;
        renderer.state.set(filter.state);
        this.bindAndClear(output, clearMode);
        filter.uniforms.uSampler = input;
        filter.uniforms.filterGlobals = this.globalUniforms;
        renderer.shader.bind(filter);
        filter.legacy = !!filter.program.attributeData.aTextureCoord;
        if (filter.legacy) {
          this.quadUv.map(input._frame, input.filterFrame);
          renderer.geometry.bind(this.quadUv);
          renderer.geometry.draw(DRAW_MODES.TRIANGLES);
        } else {
          renderer.geometry.bind(this.quad);
          renderer.geometry.draw(DRAW_MODES.TRIANGLE_STRIP);
        }
      };
      FilterSystem3.prototype.calculateSpriteMatrix = function(outputMatrix, sprite) {
        var _a2 = this.activeState, sourceFrame = _a2.sourceFrame, destinationFrame = _a2.destinationFrame;
        var orig = sprite._texture.orig;
        var mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0, destinationFrame.height, sourceFrame.x, sourceFrame.y);
        var worldTransform = sprite.worldTransform.copyTo(Matrix2.TEMP_MATRIX);
        worldTransform.invert();
        mappedMatrix.prepend(worldTransform);
        mappedMatrix.scale(1 / orig.width, 1 / orig.height);
        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
        return mappedMatrix;
      };
      FilterSystem3.prototype.destroy = function() {
        this.renderer = null;
        this.texturePool.clear(false);
      };
      FilterSystem3.prototype.getOptimalFilterTexture = function(minWidth, minHeight, resolution, multisample) {
        if (resolution === void 0) {
          resolution = 1;
        }
        if (multisample === void 0) {
          multisample = MSAA_QUALITY.NONE;
        }
        return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);
      };
      FilterSystem3.prototype.getFilterTexture = function(input, resolution, multisample) {
        if (typeof input === "number") {
          var swap = input;
          input = resolution;
          resolution = swap;
        }
        input = input || this.activeState.renderTexture;
        var filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY.NONE);
        filterTexture.filterFrame = input.filterFrame;
        return filterTexture;
      };
      FilterSystem3.prototype.returnFilterTexture = function(renderTexture) {
        this.texturePool.returnTexture(renderTexture);
      };
      FilterSystem3.prototype.emptyPool = function() {
        this.texturePool.clear(true);
      };
      FilterSystem3.prototype.resize = function() {
        this.texturePool.setScreenSize(this.renderer.view);
      };
      FilterSystem3.prototype.transformAABB = function(matrix, rect) {
        var lt = tempPoints3[0];
        var lb = tempPoints3[1];
        var rt = tempPoints3[2];
        var rb = tempPoints3[3];
        lt.set(rect.left, rect.top);
        lb.set(rect.left, rect.bottom);
        rt.set(rect.right, rect.top);
        rb.set(rect.right, rect.bottom);
        matrix.apply(lt, lt);
        matrix.apply(lb, lb);
        matrix.apply(rt, rt);
        matrix.apply(rb, rb);
        var x0 = Math.min(lt.x, lb.x, rt.x, rb.x);
        var y0 = Math.min(lt.y, lb.y, rt.y, rb.y);
        var x1 = Math.max(lt.x, lb.x, rt.x, rb.x);
        var y1 = Math.max(lt.y, lb.y, rt.y, rb.y);
        rect.x = x0;
        rect.y = y0;
        rect.width = x1 - x0;
        rect.height = y1 - y0;
      };
      FilterSystem3.prototype.roundFrame = function(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
        if (frame.width <= 0 || frame.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0) {
          return;
        }
        if (transform) {
          var a = transform.a, b = transform.b, c = transform.c, d = transform.d;
          if ((Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4)) {
            return;
          }
        }
        transform = transform ? tempMatrix$22.copyFrom(transform) : tempMatrix$22.identity();
        transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
        this.transformAABB(transform, frame);
        frame.ceil(resolution);
        this.transformAABB(transform.invert(), frame);
      };
      return FilterSystem3;
    }()
  );
  var ObjectRenderer2 = (
    /** @class */
    function() {
      function ObjectRenderer3(renderer) {
        this.renderer = renderer;
      }
      ObjectRenderer3.prototype.flush = function() {
      };
      ObjectRenderer3.prototype.destroy = function() {
        this.renderer = null;
      };
      ObjectRenderer3.prototype.start = function() {
      };
      ObjectRenderer3.prototype.stop = function() {
        this.flush();
      };
      ObjectRenderer3.prototype.render = function(_object) {
      };
      return ObjectRenderer3;
    }()
  );
  var BatchSystem2 = (
    /** @class */
    function() {
      function BatchSystem3(renderer) {
        this.renderer = renderer;
        this.emptyRenderer = new ObjectRenderer2(renderer);
        this.currentRenderer = this.emptyRenderer;
      }
      BatchSystem3.prototype.setObjectRenderer = function(objectRenderer) {
        if (this.currentRenderer === objectRenderer) {
          return;
        }
        this.currentRenderer.stop();
        this.currentRenderer = objectRenderer;
        this.currentRenderer.start();
      };
      BatchSystem3.prototype.flush = function() {
        this.setObjectRenderer(this.emptyRenderer);
      };
      BatchSystem3.prototype.reset = function() {
        this.setObjectRenderer(this.emptyRenderer);
      };
      BatchSystem3.prototype.copyBoundTextures = function(arr, maxTextures) {
        var boundTextures = this.renderer.texture.boundTextures;
        for (var i = maxTextures - 1; i >= 0; --i) {
          arr[i] = boundTextures[i] || null;
          if (arr[i]) {
            arr[i]._batchLocation = i;
          }
        }
      };
      BatchSystem3.prototype.boundArray = function(texArray, boundTextures, batchId, maxTextures) {
        var elements = texArray.elements, ids = texArray.ids, count = texArray.count;
        var j = 0;
        for (var i = 0; i < count; i++) {
          var tex = elements[i];
          var loc = tex._batchLocation;
          if (loc >= 0 && loc < maxTextures && boundTextures[loc] === tex) {
            ids[i] = loc;
            continue;
          }
          while (j < maxTextures) {
            var bound = boundTextures[j];
            if (bound && bound._batchEnabled === batchId && bound._batchLocation === j) {
              j++;
              continue;
            }
            ids[i] = j;
            tex._batchLocation = j;
            boundTextures[j] = tex;
            break;
          }
        }
      };
      BatchSystem3.prototype.destroy = function() {
        this.renderer = null;
      };
      return BatchSystem3;
    }()
  );
  var CONTEXT_UID_COUNTER2 = 0;
  var ContextSystem2 = (
    /** @class */
    function() {
      function ContextSystem3(renderer) {
        this.renderer = renderer;
        this.webGLVersion = 1;
        this.extensions = {};
        this.supports = {
          uint32Indices: false
        };
        this.handleContextLost = this.handleContextLost.bind(this);
        this.handleContextRestored = this.handleContextRestored.bind(this);
        renderer.view.addEventListener("webglcontextlost", this.handleContextLost, false);
        renderer.view.addEventListener("webglcontextrestored", this.handleContextRestored, false);
      }
      Object.defineProperty(ContextSystem3.prototype, "isLost", {
        /**
         * `true` if the context is lost
         * @readonly
         */
        get: function() {
          return !this.gl || this.gl.isContextLost();
        },
        enumerable: false,
        configurable: true
      });
      ContextSystem3.prototype.contextChange = function(gl) {
        this.gl = gl;
        this.renderer.gl = gl;
        this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER2++;
        if (gl.isContextLost() && gl.getExtension("WEBGL_lose_context")) {
          gl.getExtension("WEBGL_lose_context").restoreContext();
        }
      };
      ContextSystem3.prototype.initFromContext = function(gl) {
        this.gl = gl;
        this.validateContext(gl);
        this.renderer.gl = gl;
        this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER2++;
        this.renderer.runners.contextChange.emit(gl);
      };
      ContextSystem3.prototype.initFromOptions = function(options) {
        var gl = this.createContext(this.renderer.view, options);
        this.initFromContext(gl);
      };
      ContextSystem3.prototype.createContext = function(canvas, options) {
        var gl;
        if (settings.PREFER_ENV >= ENV.WEBGL2) {
          gl = canvas.getContext("webgl2", options);
        }
        if (gl) {
          this.webGLVersion = 2;
        } else {
          this.webGLVersion = 1;
          gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);
          if (!gl) {
            throw new Error("This browser does not support WebGL. Try using the canvas renderer");
          }
        }
        this.gl = gl;
        this.getExtensions();
        return this.gl;
      };
      ContextSystem3.prototype.getExtensions = function() {
        var gl = this.gl;
        var common = {
          anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
          floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
          s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
          s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
          etc: gl.getExtension("WEBGL_compressed_texture_etc"),
          etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
          pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
          atc: gl.getExtension("WEBGL_compressed_texture_atc"),
          astc: gl.getExtension("WEBGL_compressed_texture_astc")
        };
        if (this.webGLVersion === 1) {
          Object.assign(this.extensions, common, {
            drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
            depthTexture: gl.getExtension("WEBGL_depth_texture"),
            loseContext: gl.getExtension("WEBGL_lose_context"),
            vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
            uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
            // Floats and half-floats
            floatTexture: gl.getExtension("OES_texture_float"),
            floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
            textureHalfFloat: gl.getExtension("OES_texture_half_float"),
            textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear")
          });
        } else if (this.webGLVersion === 2) {
          Object.assign(this.extensions, common, {
            // Floats and half-floats
            colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
          });
        }
      };
      ContextSystem3.prototype.handleContextLost = function(event) {
        event.preventDefault();
      };
      ContextSystem3.prototype.handleContextRestored = function() {
        this.renderer.runners.contextChange.emit(this.gl);
      };
      ContextSystem3.prototype.destroy = function() {
        var view = this.renderer.view;
        this.renderer = null;
        view.removeEventListener("webglcontextlost", this.handleContextLost);
        view.removeEventListener("webglcontextrestored", this.handleContextRestored);
        this.gl.useProgram(null);
        if (this.extensions.loseContext) {
          this.extensions.loseContext.loseContext();
        }
      };
      ContextSystem3.prototype.postrender = function() {
        if (this.renderer.renderingToScreen) {
          this.gl.flush();
        }
      };
      ContextSystem3.prototype.validateContext = function(gl) {
        var attributes = gl.getContextAttributes();
        var isWebGl2 = "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext;
        if (isWebGl2) {
          this.webGLVersion = 2;
        }
        if (attributes && !attributes.stencil) {
          console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
        }
        var hasuint32 = isWebGl2 || !!gl.getExtension("OES_element_index_uint");
        this.supports.uint32Indices = hasuint32;
        if (!hasuint32) {
          console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
        }
      };
      return ContextSystem3;
    }()
  );
  var GLFramebuffer2 = (
    /** @class */
    function() {
      function GLFramebuffer3(framebuffer) {
        this.framebuffer = framebuffer;
        this.stencil = null;
        this.dirtyId = -1;
        this.dirtyFormat = -1;
        this.dirtySize = -1;
        this.multisample = MSAA_QUALITY.NONE;
        this.msaaBuffer = null;
        this.blitFramebuffer = null;
        this.mipLevel = 0;
      }
      return GLFramebuffer3;
    }()
  );
  var tempRectangle2 = new Rectangle2();
  var FramebufferSystem2 = (
    /** @class */
    function() {
      function FramebufferSystem3(renderer) {
        this.renderer = renderer;
        this.managedFramebuffers = [];
        this.unknownFramebuffer = new Framebuffer2(10, 10);
        this.msaaSamples = null;
      }
      FramebufferSystem3.prototype.contextChange = function() {
        var gl = this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        this.current = this.unknownFramebuffer;
        this.viewport = new Rectangle2();
        this.hasMRT = true;
        this.writeDepthTexture = true;
        this.disposeAll(true);
        if (this.renderer.context.webGLVersion === 1) {
          var nativeDrawBuffersExtension_1 = this.renderer.context.extensions.drawBuffers;
          var nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;
          if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
            nativeDrawBuffersExtension_1 = null;
            nativeDepthTextureExtension = null;
          }
          if (nativeDrawBuffersExtension_1) {
            gl.drawBuffers = function(activeTextures) {
              return nativeDrawBuffersExtension_1.drawBuffersWEBGL(activeTextures);
            };
          } else {
            this.hasMRT = false;
            gl.drawBuffers = function() {
            };
          }
          if (!nativeDepthTextureExtension) {
            this.writeDepthTexture = false;
          }
        } else {
          this.msaaSamples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.RGBA8, gl.SAMPLES);
        }
      };
      FramebufferSystem3.prototype.bind = function(framebuffer, frame, mipLevel) {
        if (mipLevel === void 0) {
          mipLevel = 0;
        }
        var gl = this.gl;
        if (framebuffer) {
          var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);
          if (this.current !== framebuffer) {
            this.current = framebuffer;
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);
          }
          if (fbo.mipLevel !== mipLevel) {
            framebuffer.dirtyId++;
            framebuffer.dirtyFormat++;
            fbo.mipLevel = mipLevel;
          }
          if (fbo.dirtyId !== framebuffer.dirtyId) {
            fbo.dirtyId = framebuffer.dirtyId;
            if (fbo.dirtyFormat !== framebuffer.dirtyFormat) {
              fbo.dirtyFormat = framebuffer.dirtyFormat;
              fbo.dirtySize = framebuffer.dirtySize;
              this.updateFramebuffer(framebuffer, mipLevel);
            } else if (fbo.dirtySize !== framebuffer.dirtySize) {
              fbo.dirtySize = framebuffer.dirtySize;
              this.resizeFramebuffer(framebuffer);
            }
          }
          for (var i = 0; i < framebuffer.colorTextures.length; i++) {
            var tex = framebuffer.colorTextures[i];
            this.renderer.texture.unbind(tex.parentTextureArray || tex);
          }
          if (framebuffer.depthTexture) {
            this.renderer.texture.unbind(framebuffer.depthTexture);
          }
          if (frame) {
            var mipWidth = frame.width >> mipLevel;
            var mipHeight = frame.height >> mipLevel;
            var scale = mipWidth / frame.width;
            this.setViewport(frame.x * scale, frame.y * scale, mipWidth, mipHeight);
          } else {
            var mipWidth = framebuffer.width >> mipLevel;
            var mipHeight = framebuffer.height >> mipLevel;
            this.setViewport(0, 0, mipWidth, mipHeight);
          }
        } else {
          if (this.current) {
            this.current = null;
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          }
          if (frame) {
            this.setViewport(frame.x, frame.y, frame.width, frame.height);
          } else {
            this.setViewport(0, 0, this.renderer.width, this.renderer.height);
          }
        }
      };
      FramebufferSystem3.prototype.setViewport = function(x, y, width, height) {
        var v = this.viewport;
        x = Math.round(x);
        y = Math.round(y);
        width = Math.round(width);
        height = Math.round(height);
        if (v.width !== width || v.height !== height || v.x !== x || v.y !== y) {
          v.x = x;
          v.y = y;
          v.width = width;
          v.height = height;
          this.gl.viewport(x, y, width, height);
        }
      };
      Object.defineProperty(FramebufferSystem3.prototype, "size", {
        /**
         * Get the size of the current width and height. Returns object with `width` and `height` values.
         * @readonly
         */
        get: function() {
          if (this.current) {
            return { x: 0, y: 0, width: this.current.width, height: this.current.height };
          }
          return { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
        },
        enumerable: false,
        configurable: true
      });
      FramebufferSystem3.prototype.clear = function(r, g, b, a, mask) {
        if (mask === void 0) {
          mask = BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH;
        }
        var gl = this.gl;
        gl.clearColor(r, g, b, a);
        gl.clear(mask);
      };
      FramebufferSystem3.prototype.initFramebuffer = function(framebuffer) {
        var gl = this.gl;
        var fbo = new GLFramebuffer2(gl.createFramebuffer());
        fbo.multisample = this.detectSamples(framebuffer.multisample);
        framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo;
        this.managedFramebuffers.push(framebuffer);
        framebuffer.disposeRunner.add(this);
        return fbo;
      };
      FramebufferSystem3.prototype.resizeFramebuffer = function(framebuffer) {
        var gl = this.gl;
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        if (fbo.msaaBuffer) {
          gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.RGBA8, framebuffer.width, framebuffer.height);
        }
        if (fbo.stencil) {
          gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
          if (fbo.msaaBuffer) {
            gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
          } else {
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
          }
        }
        var colorTextures = framebuffer.colorTextures;
        var count = colorTextures.length;
        if (!gl.drawBuffers) {
          count = Math.min(count, 1);
        }
        for (var i = 0; i < count; i++) {
          var texture = colorTextures[i];
          var parentTexture = texture.parentTextureArray || texture;
          this.renderer.texture.bind(parentTexture, 0);
        }
        if (framebuffer.depthTexture && this.writeDepthTexture) {
          this.renderer.texture.bind(framebuffer.depthTexture, 0);
        }
      };
      FramebufferSystem3.prototype.updateFramebuffer = function(framebuffer, mipLevel) {
        var gl = this.gl;
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        var colorTextures = framebuffer.colorTextures;
        var count = colorTextures.length;
        if (!gl.drawBuffers) {
          count = Math.min(count, 1);
        }
        if (fbo.multisample > 1 && this.canMultisampleFramebuffer(framebuffer)) {
          fbo.msaaBuffer = fbo.msaaBuffer || gl.createRenderbuffer();
          gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.RGBA8, framebuffer.width, framebuffer.height);
          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, fbo.msaaBuffer);
        } else if (fbo.msaaBuffer) {
          gl.deleteRenderbuffer(fbo.msaaBuffer);
          fbo.msaaBuffer = null;
          if (fbo.blitFramebuffer) {
            fbo.blitFramebuffer.dispose();
            fbo.blitFramebuffer = null;
          }
        }
        var activeTextures = [];
        for (var i = 0; i < count; i++) {
          var texture = colorTextures[i];
          var parentTexture = texture.parentTextureArray || texture;
          this.renderer.texture.bind(parentTexture, 0);
          if (i === 0 && fbo.msaaBuffer) {
            continue;
          }
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, texture.target, parentTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
          activeTextures.push(gl.COLOR_ATTACHMENT0 + i);
        }
        if (activeTextures.length > 1) {
          gl.drawBuffers(activeTextures);
        }
        if (framebuffer.depthTexture) {
          var writeDepthTexture = this.writeDepthTexture;
          if (writeDepthTexture) {
            var depthTexture = framebuffer.depthTexture;
            this.renderer.texture.bind(depthTexture, 0);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
          }
        }
        if ((framebuffer.stencil || framebuffer.depth) && !(framebuffer.depthTexture && this.writeDepthTexture)) {
          fbo.stencil = fbo.stencil || gl.createRenderbuffer();
          gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
          if (fbo.msaaBuffer) {
            gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
          } else {
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
          }
          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, fbo.stencil);
        } else if (fbo.stencil) {
          gl.deleteRenderbuffer(fbo.stencil);
          fbo.stencil = null;
        }
      };
      FramebufferSystem3.prototype.canMultisampleFramebuffer = function(framebuffer) {
        return this.renderer.context.webGLVersion !== 1 && framebuffer.colorTextures.length <= 1 && !framebuffer.depthTexture;
      };
      FramebufferSystem3.prototype.detectSamples = function(samples) {
        var msaaSamples = this.msaaSamples;
        var res = MSAA_QUALITY.NONE;
        if (samples <= 1 || msaaSamples === null) {
          return res;
        }
        for (var i = 0; i < msaaSamples.length; i++) {
          if (msaaSamples[i] <= samples) {
            res = msaaSamples[i];
            break;
          }
        }
        if (res === 1) {
          res = MSAA_QUALITY.NONE;
        }
        return res;
      };
      FramebufferSystem3.prototype.blit = function(framebuffer, sourcePixels, destPixels) {
        var _a2 = this, current = _a2.current, renderer = _a2.renderer, gl = _a2.gl, CONTEXT_UID = _a2.CONTEXT_UID;
        if (renderer.context.webGLVersion !== 2) {
          return;
        }
        if (!current) {
          return;
        }
        var fbo = current.glFramebuffers[CONTEXT_UID];
        if (!fbo) {
          return;
        }
        if (!framebuffer) {
          if (!fbo.msaaBuffer) {
            return;
          }
          var colorTexture = current.colorTextures[0];
          if (!colorTexture) {
            return;
          }
          if (!fbo.blitFramebuffer) {
            fbo.blitFramebuffer = new Framebuffer2(current.width, current.height);
            fbo.blitFramebuffer.addColorTexture(0, colorTexture);
          }
          framebuffer = fbo.blitFramebuffer;
          if (framebuffer.colorTextures[0] !== colorTexture) {
            framebuffer.colorTextures[0] = colorTexture;
            framebuffer.dirtyId++;
            framebuffer.dirtyFormat++;
          }
          if (framebuffer.width !== current.width || framebuffer.height !== current.height) {
            framebuffer.width = current.width;
            framebuffer.height = current.height;
            framebuffer.dirtyId++;
            framebuffer.dirtySize++;
          }
        }
        if (!sourcePixels) {
          sourcePixels = tempRectangle2;
          sourcePixels.width = current.width;
          sourcePixels.height = current.height;
        }
        if (!destPixels) {
          destPixels = sourcePixels;
        }
        var sameSize = sourcePixels.width === destPixels.width && sourcePixels.height === destPixels.height;
        this.bind(framebuffer);
        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo.framebuffer);
        gl.blitFramebuffer(sourcePixels.left, sourcePixels.top, sourcePixels.right, sourcePixels.bottom, destPixels.left, destPixels.top, destPixels.right, destPixels.bottom, gl.COLOR_BUFFER_BIT, sameSize ? gl.NEAREST : gl.LINEAR);
      };
      FramebufferSystem3.prototype.disposeFramebuffer = function(framebuffer, contextLost) {
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        var gl = this.gl;
        if (!fbo) {
          return;
        }
        delete framebuffer.glFramebuffers[this.CONTEXT_UID];
        var index = this.managedFramebuffers.indexOf(framebuffer);
        if (index >= 0) {
          this.managedFramebuffers.splice(index, 1);
        }
        framebuffer.disposeRunner.remove(this);
        if (!contextLost) {
          gl.deleteFramebuffer(fbo.framebuffer);
          if (fbo.msaaBuffer) {
            gl.deleteRenderbuffer(fbo.msaaBuffer);
          }
          if (fbo.stencil) {
            gl.deleteRenderbuffer(fbo.stencil);
          }
        }
        if (fbo.blitFramebuffer) {
          fbo.blitFramebuffer.dispose();
        }
      };
      FramebufferSystem3.prototype.disposeAll = function(contextLost) {
        var list = this.managedFramebuffers;
        this.managedFramebuffers = [];
        for (var i = 0; i < list.length; i++) {
          this.disposeFramebuffer(list[i], contextLost);
        }
      };
      FramebufferSystem3.prototype.forceStencil = function() {
        var framebuffer = this.current;
        if (!framebuffer) {
          return;
        }
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        if (!fbo || fbo.stencil) {
          return;
        }
        framebuffer.stencil = true;
        var w = framebuffer.width;
        var h = framebuffer.height;
        var gl = this.gl;
        var stencil = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);
        if (fbo.msaaBuffer) {
          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, w, h);
        } else {
          gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, w, h);
        }
        fbo.stencil = stencil;
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, stencil);
      };
      FramebufferSystem3.prototype.reset = function() {
        this.current = this.unknownFramebuffer;
        this.viewport = new Rectangle2();
      };
      FramebufferSystem3.prototype.destroy = function() {
        this.renderer = null;
      };
      return FramebufferSystem3;
    }()
  );
  var byteSizeMap2 = { 5126: 4, 5123: 2, 5121: 1 };
  var GeometrySystem2 = (
    /** @class */
    function() {
      function GeometrySystem3(renderer) {
        this.renderer = renderer;
        this._activeGeometry = null;
        this._activeVao = null;
        this.hasVao = true;
        this.hasInstance = true;
        this.canUseUInt32ElementIndex = false;
        this.managedGeometries = {};
      }
      GeometrySystem3.prototype.contextChange = function() {
        this.disposeAll(true);
        var gl = this.gl = this.renderer.gl;
        var context3 = this.renderer.context;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        if (context3.webGLVersion !== 2) {
          var nativeVaoExtension_1 = this.renderer.context.extensions.vertexArrayObject;
          if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
            nativeVaoExtension_1 = null;
          }
          if (nativeVaoExtension_1) {
            gl.createVertexArray = function() {
              return nativeVaoExtension_1.createVertexArrayOES();
            };
            gl.bindVertexArray = function(vao) {
              return nativeVaoExtension_1.bindVertexArrayOES(vao);
            };
            gl.deleteVertexArray = function(vao) {
              return nativeVaoExtension_1.deleteVertexArrayOES(vao);
            };
          } else {
            this.hasVao = false;
            gl.createVertexArray = function() {
              return null;
            };
            gl.bindVertexArray = function() {
              return null;
            };
            gl.deleteVertexArray = function() {
              return null;
            };
          }
        }
        if (context3.webGLVersion !== 2) {
          var instanceExt_1 = gl.getExtension("ANGLE_instanced_arrays");
          if (instanceExt_1) {
            gl.vertexAttribDivisor = function(a, b) {
              return instanceExt_1.vertexAttribDivisorANGLE(a, b);
            };
            gl.drawElementsInstanced = function(a, b, c, d, e) {
              return instanceExt_1.drawElementsInstancedANGLE(a, b, c, d, e);
            };
            gl.drawArraysInstanced = function(a, b, c, d) {
              return instanceExt_1.drawArraysInstancedANGLE(a, b, c, d);
            };
          } else {
            this.hasInstance = false;
          }
        }
        this.canUseUInt32ElementIndex = context3.webGLVersion === 2 || !!context3.extensions.uint32ElementIndex;
      };
      GeometrySystem3.prototype.bind = function(geometry, shader) {
        shader = shader || this.renderer.shader.shader;
        var gl = this.gl;
        var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
        var incRefCount = false;
        if (!vaos) {
          this.managedGeometries[geometry.id] = geometry;
          geometry.disposeRunner.add(this);
          geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};
          incRefCount = true;
        }
        var vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);
        this._activeGeometry = geometry;
        if (this._activeVao !== vao) {
          this._activeVao = vao;
          if (this.hasVao) {
            gl.bindVertexArray(vao);
          } else {
            this.activateVao(geometry, shader.program);
          }
        }
        this.updateBuffers();
      };
      GeometrySystem3.prototype.reset = function() {
        this.unbind();
      };
      GeometrySystem3.prototype.updateBuffers = function() {
        var geometry = this._activeGeometry;
        var bufferSystem = this.renderer.buffer;
        for (var i = 0; i < geometry.buffers.length; i++) {
          var buffer = geometry.buffers[i];
          bufferSystem.update(buffer);
        }
      };
      GeometrySystem3.prototype.checkCompatibility = function(geometry, program) {
        var geometryAttributes = geometry.attributes;
        var shaderAttributes = program.attributeData;
        for (var j in shaderAttributes) {
          if (!geometryAttributes[j]) {
            throw new Error('shader and geometry incompatible, geometry missing the "' + j + '" attribute');
          }
        }
      };
      GeometrySystem3.prototype.getSignature = function(geometry, program) {
        var attribs = geometry.attributes;
        var shaderAttributes = program.attributeData;
        var strings = ["g", geometry.id];
        for (var i in attribs) {
          if (shaderAttributes[i]) {
            strings.push(i, shaderAttributes[i].location);
          }
        }
        return strings.join("-");
      };
      GeometrySystem3.prototype.initGeometryVao = function(geometry, shader, incRefCount) {
        if (incRefCount === void 0) {
          incRefCount = true;
        }
        var gl = this.gl;
        var CONTEXT_UID = this.CONTEXT_UID;
        var bufferSystem = this.renderer.buffer;
        var program = shader.program;
        if (!program.glPrograms[CONTEXT_UID]) {
          this.renderer.shader.generateProgram(shader);
        }
        this.checkCompatibility(geometry, program);
        var signature = this.getSignature(geometry, program);
        var vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];
        var vao = vaoObjectHash[signature];
        if (vao) {
          vaoObjectHash[program.id] = vao;
          return vao;
        }
        var buffers = geometry.buffers;
        var attributes = geometry.attributes;
        var tempStride = {};
        var tempStart = {};
        for (var j in buffers) {
          tempStride[j] = 0;
          tempStart[j] = 0;
        }
        for (var j in attributes) {
          if (!attributes[j].size && program.attributeData[j]) {
            attributes[j].size = program.attributeData[j].size;
          } else if (!attributes[j].size) {
            console.warn("PIXI Geometry attribute '" + j + "' size cannot be determined (likely the bound shader does not have the attribute)");
          }
          tempStride[attributes[j].buffer] += attributes[j].size * byteSizeMap2[attributes[j].type];
        }
        for (var j in attributes) {
          var attribute = attributes[j];
          var attribSize = attribute.size;
          if (attribute.stride === void 0) {
            if (tempStride[attribute.buffer] === attribSize * byteSizeMap2[attribute.type]) {
              attribute.stride = 0;
            } else {
              attribute.stride = tempStride[attribute.buffer];
            }
          }
          if (attribute.start === void 0) {
            attribute.start = tempStart[attribute.buffer];
            tempStart[attribute.buffer] += attribSize * byteSizeMap2[attribute.type];
          }
        }
        vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        for (var i = 0; i < buffers.length; i++) {
          var buffer = buffers[i];
          bufferSystem.bind(buffer);
          if (incRefCount) {
            buffer._glBuffers[CONTEXT_UID].refCount++;
          }
        }
        this.activateVao(geometry, program);
        this._activeVao = vao;
        vaoObjectHash[program.id] = vao;
        vaoObjectHash[signature] = vao;
        return vao;
      };
      GeometrySystem3.prototype.disposeGeometry = function(geometry, contextLost) {
        var _a2;
        if (!this.managedGeometries[geometry.id]) {
          return;
        }
        delete this.managedGeometries[geometry.id];
        var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
        var gl = this.gl;
        var buffers = geometry.buffers;
        var bufferSystem = (_a2 = this.renderer) === null || _a2 === void 0 ? void 0 : _a2.buffer;
        geometry.disposeRunner.remove(this);
        if (!vaos) {
          return;
        }
        if (bufferSystem) {
          for (var i = 0; i < buffers.length; i++) {
            var buf = buffers[i]._glBuffers[this.CONTEXT_UID];
            if (buf) {
              buf.refCount--;
              if (buf.refCount === 0 && !contextLost) {
                bufferSystem.dispose(buffers[i], contextLost);
              }
            }
          }
        }
        if (!contextLost) {
          for (var vaoId in vaos) {
            if (vaoId[0] === "g") {
              var vao = vaos[vaoId];
              if (this._activeVao === vao) {
                this.unbind();
              }
              gl.deleteVertexArray(vao);
            }
          }
        }
        delete geometry.glVertexArrayObjects[this.CONTEXT_UID];
      };
      GeometrySystem3.prototype.disposeAll = function(contextLost) {
        var all = Object.keys(this.managedGeometries);
        for (var i = 0; i < all.length; i++) {
          this.disposeGeometry(this.managedGeometries[all[i]], contextLost);
        }
      };
      GeometrySystem3.prototype.activateVao = function(geometry, program) {
        var gl = this.gl;
        var CONTEXT_UID = this.CONTEXT_UID;
        var bufferSystem = this.renderer.buffer;
        var buffers = geometry.buffers;
        var attributes = geometry.attributes;
        if (geometry.indexBuffer) {
          bufferSystem.bind(geometry.indexBuffer);
        }
        var lastBuffer = null;
        for (var j in attributes) {
          var attribute = attributes[j];
          var buffer = buffers[attribute.buffer];
          var glBuffer = buffer._glBuffers[CONTEXT_UID];
          if (program.attributeData[j]) {
            if (lastBuffer !== glBuffer) {
              bufferSystem.bind(buffer);
              lastBuffer = glBuffer;
            }
            var location = program.attributeData[j].location;
            gl.enableVertexAttribArray(location);
            gl.vertexAttribPointer(location, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);
            if (attribute.instance) {
              if (this.hasInstance) {
                gl.vertexAttribDivisor(location, 1);
              } else {
                throw new Error("geometry error, GPU Instancing is not supported on this device");
              }
            }
          }
        }
      };
      GeometrySystem3.prototype.draw = function(type, size, start, instanceCount) {
        var gl = this.gl;
        var geometry = this._activeGeometry;
        if (geometry.indexBuffer) {
          var byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
          var glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
          if (byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex) {
            if (geometry.instanced) {
              gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1);
            } else {
              gl.drawElements(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
            }
          } else {
            console.warn("unsupported index buffer type: uint32");
          }
        } else if (geometry.instanced) {
          gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1);
        } else {
          gl.drawArrays(type, start, size || geometry.getSize());
        }
        return this;
      };
      GeometrySystem3.prototype.unbind = function() {
        this.gl.bindVertexArray(null);
        this._activeVao = null;
        this._activeGeometry = null;
      };
      GeometrySystem3.prototype.destroy = function() {
        this.renderer = null;
      };
      return GeometrySystem3;
    }()
  );
  var MaskData2 = (
    /** @class */
    function() {
      function MaskData3(maskObject) {
        if (maskObject === void 0) {
          maskObject = null;
        }
        this.type = MASK_TYPES.NONE;
        this.autoDetect = true;
        this.maskObject = maskObject || null;
        this.pooled = false;
        this.isMaskData = true;
        this.resolution = null;
        this.multisample = settings.FILTER_MULTISAMPLE;
        this.enabled = true;
        this._filters = null;
        this._stencilCounter = 0;
        this._scissorCounter = 0;
        this._scissorRect = null;
        this._scissorRectLocal = null;
        this._target = null;
      }
      Object.defineProperty(MaskData3.prototype, "filter", {
        /**
         * The sprite mask filter.
         * If set to `null`, the default sprite mask filter is used.
         * @default null
         */
        get: function() {
          return this._filters ? this._filters[0] : null;
        },
        set: function(value) {
          if (value) {
            if (this._filters) {
              this._filters[0] = value;
            } else {
              this._filters = [value];
            }
          } else {
            this._filters = null;
          }
        },
        enumerable: false,
        configurable: true
      });
      MaskData3.prototype.reset = function() {
        if (this.pooled) {
          this.maskObject = null;
          this.type = MASK_TYPES.NONE;
          this.autoDetect = true;
        }
        this._target = null;
        this._scissorRectLocal = null;
      };
      MaskData3.prototype.copyCountersOrReset = function(maskAbove) {
        if (maskAbove) {
          this._stencilCounter = maskAbove._stencilCounter;
          this._scissorCounter = maskAbove._scissorCounter;
          this._scissorRect = maskAbove._scissorRect;
        } else {
          this._stencilCounter = 0;
          this._scissorCounter = 0;
          this._scissorRect = null;
        }
      };
      return MaskData3;
    }()
  );
  function compileShader2(gl, type, src) {
    var shader = gl.createShader(type);
    gl.shaderSource(shader, src);
    gl.compileShader(shader);
    return shader;
  }
  function logPrettyShaderError2(gl, shader) {
    var shaderSrc = gl.getShaderSource(shader).split("\n").map(function(line, index) {
      return index + ": " + line;
    });
    var shaderLog = gl.getShaderInfoLog(shader);
    var splitShader = shaderLog.split("\n");
    var dedupe = {};
    var lineNumbers = splitShader.map(function(line) {
      return parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"));
    }).filter(function(n) {
      if (n && !dedupe[n]) {
        dedupe[n] = true;
        return true;
      }
      return false;
    });
    var logArgs = [""];
    lineNumbers.forEach(function(number) {
      shaderSrc[number - 1] = "%c" + shaderSrc[number - 1] + "%c";
      logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
    });
    var fragmentSourceToLog = shaderSrc.join("\n");
    logArgs[0] = fragmentSourceToLog;
    console.error(shaderLog);
    console.groupCollapsed("click to view full shader code");
    console.warn.apply(console, logArgs);
    console.groupEnd();
  }
  function logProgramError2(gl, program, vertexShader, fragmentShader) {
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        logPrettyShaderError2(gl, vertexShader);
      }
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        logPrettyShaderError2(gl, fragmentShader);
      }
      console.error("PixiJS Error: Could not initialize shader.");
      if (gl.getProgramInfoLog(program) !== "") {
        console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
      }
    }
  }
  function booleanArray2(size) {
    var array = new Array(size);
    for (var i = 0; i < array.length; i++) {
      array[i] = false;
    }
    return array;
  }
  function defaultValue2(type, size) {
    switch (type) {
      case "float":
        return 0;
      case "vec2":
        return new Float32Array(2 * size);
      case "vec3":
        return new Float32Array(3 * size);
      case "vec4":
        return new Float32Array(4 * size);
      case "int":
      case "uint":
      case "sampler2D":
      case "sampler2DArray":
        return 0;
      case "ivec2":
        return new Int32Array(2 * size);
      case "ivec3":
        return new Int32Array(3 * size);
      case "ivec4":
        return new Int32Array(4 * size);
      case "uvec2":
        return new Uint32Array(2 * size);
      case "uvec3":
        return new Uint32Array(3 * size);
      case "uvec4":
        return new Uint32Array(4 * size);
      case "bool":
        return false;
      case "bvec2":
        return booleanArray2(2 * size);
      case "bvec3":
        return booleanArray2(3 * size);
      case "bvec4":
        return booleanArray2(4 * size);
      case "mat2":
        return new Float32Array([
          1,
          0,
          0,
          1
        ]);
      case "mat3":
        return new Float32Array([
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ]);
      case "mat4":
        return new Float32Array([
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
    }
    return null;
  }
  var unknownContext2 = {};
  var context2 = unknownContext2;
  function getTestContext2() {
    if (context2 === unknownContext2 || context2 && context2.isContextLost()) {
      var canvas = document.createElement("canvas");
      var gl = void 0;
      if (settings.PREFER_ENV >= ENV.WEBGL2) {
        gl = canvas.getContext("webgl2", {});
      }
      if (!gl) {
        gl = canvas.getContext("webgl", {}) || canvas.getContext("experimental-webgl", {});
        if (!gl) {
          gl = null;
        } else {
          gl.getExtension("WEBGL_draw_buffers");
        }
      }
      context2 = gl;
    }
    return context2;
  }
  var maxFragmentPrecision2;
  function getMaxFragmentPrecision2() {
    if (!maxFragmentPrecision2) {
      maxFragmentPrecision2 = PRECISION.MEDIUM;
      var gl = getTestContext2();
      if (gl) {
        if (gl.getShaderPrecisionFormat) {
          var shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
          maxFragmentPrecision2 = shaderFragment.precision ? PRECISION.HIGH : PRECISION.MEDIUM;
        }
      }
    }
    return maxFragmentPrecision2;
  }
  function setPrecision2(src, requestedPrecision, maxSupportedPrecision) {
    if (src.substring(0, 9) !== "precision") {
      var precision = requestedPrecision;
      if (requestedPrecision === PRECISION.HIGH && maxSupportedPrecision !== PRECISION.HIGH) {
        precision = PRECISION.MEDIUM;
      }
      return "precision " + precision + " float;\n" + src;
    } else if (maxSupportedPrecision !== PRECISION.HIGH && src.substring(0, 15) === "precision highp") {
      return src.replace("precision highp", "precision mediump");
    }
    return src;
  }
  var GLSL_TO_SIZE2 = {
    float: 1,
    vec2: 2,
    vec3: 3,
    vec4: 4,
    int: 1,
    ivec2: 2,
    ivec3: 3,
    ivec4: 4,
    uint: 1,
    uvec2: 2,
    uvec3: 3,
    uvec4: 4,
    bool: 1,
    bvec2: 2,
    bvec3: 3,
    bvec4: 4,
    mat2: 4,
    mat3: 9,
    mat4: 16,
    sampler2D: 1
  };
  function mapSize2(type) {
    return GLSL_TO_SIZE2[type];
  }
  var GL_TABLE2 = null;
  var GL_TO_GLSL_TYPES2 = {
    FLOAT: "float",
    FLOAT_VEC2: "vec2",
    FLOAT_VEC3: "vec3",
    FLOAT_VEC4: "vec4",
    INT: "int",
    INT_VEC2: "ivec2",
    INT_VEC3: "ivec3",
    INT_VEC4: "ivec4",
    UNSIGNED_INT: "uint",
    UNSIGNED_INT_VEC2: "uvec2",
    UNSIGNED_INT_VEC3: "uvec3",
    UNSIGNED_INT_VEC4: "uvec4",
    BOOL: "bool",
    BOOL_VEC2: "bvec2",
    BOOL_VEC3: "bvec3",
    BOOL_VEC4: "bvec4",
    FLOAT_MAT2: "mat2",
    FLOAT_MAT3: "mat3",
    FLOAT_MAT4: "mat4",
    SAMPLER_2D: "sampler2D",
    INT_SAMPLER_2D: "sampler2D",
    UNSIGNED_INT_SAMPLER_2D: "sampler2D",
    SAMPLER_CUBE: "samplerCube",
    INT_SAMPLER_CUBE: "samplerCube",
    UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
    SAMPLER_2D_ARRAY: "sampler2DArray",
    INT_SAMPLER_2D_ARRAY: "sampler2DArray",
    UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
  };
  function mapType2(gl, type) {
    if (!GL_TABLE2) {
      var typeNames = Object.keys(GL_TO_GLSL_TYPES2);
      GL_TABLE2 = {};
      for (var i = 0; i < typeNames.length; ++i) {
        var tn = typeNames[i];
        GL_TABLE2[gl[tn]] = GL_TO_GLSL_TYPES2[tn];
      }
    }
    return GL_TABLE2[type];
  }
  var uniformParsers2 = [
    // a float cache layer
    {
      test: function(data) {
        return data.type === "float" && data.size === 1;
      },
      code: function(name) {
        return '\n            if(uv["' + name + '"] !== ud["' + name + '"].value)\n            {\n                ud["' + name + '"].value = uv["' + name + '"]\n                gl.uniform1f(ud["' + name + '"].location, uv["' + name + '"])\n            }\n            ';
      }
    },
    // handling samplers
    {
      test: function(data) {
        return (data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray;
      },
      code: function(name) {
        return 't = syncData.textureCount++;\n\n            renderer.texture.bind(uv["' + name + '"], t);\n\n            if(ud["' + name + '"].value !== t)\n            {\n                ud["' + name + '"].value = t;\n                gl.uniform1i(ud["' + name + '"].location, t);\n; // eslint-disable-line max-len\n            }';
      }
    },
    // uploading pixi matrix object to mat3
    {
      test: function(data, uniform) {
        return data.type === "mat3" && data.size === 1 && uniform.a !== void 0;
      },
      code: function(name) {
        return '\n            gl.uniformMatrix3fv(ud["' + name + '"].location, false, uv["' + name + '"].toArray(true));\n            ';
      },
      codeUbo: function(name) {
        return "\n                var " + name + "_matrix = uv." + name + ".toArray(true);\n\n                data[offset] = " + name + "_matrix[0];\n                data[offset+1] = " + name + "_matrix[1];\n                data[offset+2] = " + name + "_matrix[2];\n        \n                data[offset + 4] = " + name + "_matrix[3];\n                data[offset + 5] = " + name + "_matrix[4];\n                data[offset + 6] = " + name + "_matrix[5];\n        \n                data[offset + 8] = " + name + "_matrix[6];\n                data[offset + 9] = " + name + "_matrix[7];\n                data[offset + 10] = " + name + "_matrix[8];\n            ";
      }
    },
    // uploading a pixi point as a vec2 with caching layer
    {
      test: function(data, uniform) {
        return data.type === "vec2" && data.size === 1 && uniform.x !== void 0;
      },
      code: function(name) {
        return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["' + name + '"].location, v.x, v.y);\n                }';
      },
      codeUbo: function(name) {
        return "\n                v = uv." + name + ";\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            ";
      }
    },
    // caching layer for a vec2
    {
      test: function(data) {
        return data.type === "vec2" && data.size === 1;
      },
      code: function(name) {
        return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["' + name + '"].location, v[0], v[1]);\n                }\n            ';
      }
    },
    // upload a pixi rectangle as a vec4 with caching layer
    {
      test: function(data, uniform) {
        return data.type === "vec4" && data.size === 1 && uniform.width !== void 0;
      },
      code: function(name) {
        return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["' + name + '"].location, v.x, v.y, v.width, v.height)\n                }';
      },
      codeUbo: function(name) {
        return "\n                    v = uv." + name + ";\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                ";
      }
    },
    // a caching layer for vec4 uploading
    {
      test: function(data) {
        return data.type === "vec4" && data.size === 1;
      },
      code: function(name) {
        return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["' + name + '"].location, v[0], v[1], v[2], v[3])\n                }';
      }
    }
  ];
  var GLSL_TO_SINGLE_SETTERS_CACHED2 = {
    float: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }",
    vec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }",
    vec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }",
    vec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }",
    int: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }",
    ivec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }",
    ivec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }",
    ivec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }",
    uint: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }",
    uvec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }",
    uvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }",
    uvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }",
    bool: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }",
    bvec2: "\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }",
    bvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }",
    bvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }",
    mat2: "gl.uniformMatrix2fv(location, false, v)",
    mat3: "gl.uniformMatrix3fv(location, false, v)",
    mat4: "gl.uniformMatrix4fv(location, false, v)",
    sampler2D: "gl.uniform1i(location, v)",
    samplerCube: "gl.uniform1i(location, v)",
    sampler2DArray: "gl.uniform1i(location, v)"
  };
  var GLSL_TO_ARRAY_SETTERS2 = {
    float: "gl.uniform1fv(location, v)",
    vec2: "gl.uniform2fv(location, v)",
    vec3: "gl.uniform3fv(location, v)",
    vec4: "gl.uniform4fv(location, v)",
    mat4: "gl.uniformMatrix4fv(location, false, v)",
    mat3: "gl.uniformMatrix3fv(location, false, v)",
    mat2: "gl.uniformMatrix2fv(location, false, v)",
    int: "gl.uniform1iv(location, v)",
    ivec2: "gl.uniform2iv(location, v)",
    ivec3: "gl.uniform3iv(location, v)",
    ivec4: "gl.uniform4iv(location, v)",
    uint: "gl.uniform1uiv(location, v)",
    uvec2: "gl.uniform2uiv(location, v)",
    uvec3: "gl.uniform3uiv(location, v)",
    uvec4: "gl.uniform4uiv(location, v)",
    bool: "gl.uniform1iv(location, v)",
    bvec2: "gl.uniform2iv(location, v)",
    bvec3: "gl.uniform3iv(location, v)",
    bvec4: "gl.uniform4iv(location, v)",
    sampler2D: "gl.uniform1iv(location, v)",
    samplerCube: "gl.uniform1iv(location, v)",
    sampler2DArray: "gl.uniform1iv(location, v)"
  };
  function generateUniformsSync2(group, uniformData) {
    var _a2;
    var funcFragments = ["\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    "];
    for (var i in group.uniforms) {
      var data = uniformData[i];
      if (!data) {
        if ((_a2 = group.uniforms[i]) === null || _a2 === void 0 ? void 0 : _a2.group) {
          if (group.uniforms[i].ubo) {
            funcFragments.push("\n                        renderer.shader.syncUniformBufferGroup(uv." + i + ", '" + i + "');\n                    ");
          } else {
            funcFragments.push("\n                        renderer.shader.syncUniformGroup(uv." + i + ", syncData);\n                    ");
          }
        }
        continue;
      }
      var uniform = group.uniforms[i];
      var parsed = false;
      for (var j = 0; j < uniformParsers2.length; j++) {
        if (uniformParsers2[j].test(data, uniform)) {
          funcFragments.push(uniformParsers2[j].code(i, uniform));
          parsed = true;
          break;
        }
      }
      if (!parsed) {
        var templateType = data.size === 1 ? GLSL_TO_SINGLE_SETTERS_CACHED2 : GLSL_TO_ARRAY_SETTERS2;
        var template = templateType[data.type].replace("location", 'ud["' + i + '"].location');
        funcFragments.push('\n            cu = ud["' + i + '"];\n            cv = cu.value;\n            v = uv["' + i + '"];\n            ' + template + ";");
      }
    }
    return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
  }
  var fragTemplate2 = [
    "precision mediump float;",
    "void main(void){",
    "float test = 0.1;",
    "%forloop%",
    "gl_FragColor = vec4(0.0);",
    "}"
  ].join("\n");
  function generateIfTestSrc2(maxIfs) {
    var src = "";
    for (var i = 0; i < maxIfs; ++i) {
      if (i > 0) {
        src += "\nelse ";
      }
      if (i < maxIfs - 1) {
        src += "if(test == " + i + ".0){}";
      }
    }
    return src;
  }
  function checkMaxIfStatementsInShader2(maxIfs, gl) {
    if (maxIfs === 0) {
      throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
    }
    var shader = gl.createShader(gl.FRAGMENT_SHADER);
    while (true) {
      var fragmentSrc = fragTemplate2.replace(/%forloop%/gi, generateIfTestSrc2(maxIfs));
      gl.shaderSource(shader, fragmentSrc);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        maxIfs = maxIfs / 2 | 0;
      } else {
        break;
      }
    }
    return maxIfs;
  }
  var unsafeEval2;
  function unsafeEvalSupported2() {
    if (typeof unsafeEval2 === "boolean") {
      return unsafeEval2;
    }
    try {
      var func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
      unsafeEval2 = func({ a: "b" }, "a", "b") === true;
    } catch (e) {
      unsafeEval2 = false;
    }
    return unsafeEval2;
  }
  var defaultFragment$22 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}";
  var defaultVertex$32 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n";
  var UID$12 = 0;
  var nameCache2 = {};
  var Program2 = (
    /** @class */
    function() {
      function Program3(vertexSrc, fragmentSrc, name) {
        if (name === void 0) {
          name = "pixi-shader";
        }
        this.id = UID$12++;
        this.vertexSrc = vertexSrc || Program3.defaultVertexSrc;
        this.fragmentSrc = fragmentSrc || Program3.defaultFragmentSrc;
        this.vertexSrc = this.vertexSrc.trim();
        this.fragmentSrc = this.fragmentSrc.trim();
        if (this.vertexSrc.substring(0, 8) !== "#version") {
          name = name.replace(/\s+/g, "-");
          if (nameCache2[name]) {
            nameCache2[name]++;
            name += "-" + nameCache2[name];
          } else {
            nameCache2[name] = 1;
          }
          this.vertexSrc = "#define SHADER_NAME " + name + "\n" + this.vertexSrc;
          this.fragmentSrc = "#define SHADER_NAME " + name + "\n" + this.fragmentSrc;
          this.vertexSrc = setPrecision2(this.vertexSrc, settings.PRECISION_VERTEX, PRECISION.HIGH);
          this.fragmentSrc = setPrecision2(this.fragmentSrc, settings.PRECISION_FRAGMENT, getMaxFragmentPrecision2());
        }
        this.glPrograms = {};
        this.syncUniforms = null;
      }
      Object.defineProperty(Program3, "defaultVertexSrc", {
        /**
         * The default vertex shader source.
         * @constant
         */
        get: function() {
          return defaultVertex$32;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Program3, "defaultFragmentSrc", {
        /**
         * The default fragment shader source.
         * @constant
         */
        get: function() {
          return defaultFragment$22;
        },
        enumerable: false,
        configurable: true
      });
      Program3.from = function(vertexSrc, fragmentSrc, name) {
        var key = vertexSrc + fragmentSrc;
        var program = ProgramCache2[key];
        if (!program) {
          ProgramCache2[key] = program = new Program3(vertexSrc, fragmentSrc, name);
        }
        return program;
      };
      return Program3;
    }()
  );
  var Shader2 = (
    /** @class */
    function() {
      function Shader3(program, uniforms) {
        this.uniformBindCount = 0;
        this.program = program;
        if (uniforms) {
          if (uniforms instanceof UniformGroup2) {
            this.uniformGroup = uniforms;
          } else {
            this.uniformGroup = new UniformGroup2(uniforms);
          }
        } else {
          this.uniformGroup = new UniformGroup2({});
        }
      }
      Shader3.prototype.checkUniformExists = function(name, group) {
        if (group.uniforms[name]) {
          return true;
        }
        for (var i in group.uniforms) {
          var uniform = group.uniforms[i];
          if (uniform.group) {
            if (this.checkUniformExists(name, uniform)) {
              return true;
            }
          }
        }
        return false;
      };
      Shader3.prototype.destroy = function() {
        this.uniformGroup = null;
      };
      Object.defineProperty(Shader3.prototype, "uniforms", {
        /**
         * Shader uniform values, shortcut for `uniformGroup.uniforms`.
         * @readonly
         */
        get: function() {
          return this.uniformGroup.uniforms;
        },
        enumerable: false,
        configurable: true
      });
      Shader3.from = function(vertexSrc, fragmentSrc, uniforms) {
        var program = Program2.from(vertexSrc, fragmentSrc);
        return new Shader3(program, uniforms);
      };
      return Shader3;
    }()
  );
  var BLEND$12 = 0;
  var OFFSET$12 = 1;
  var CULLING$12 = 2;
  var DEPTH_TEST$12 = 3;
  var WINDING$12 = 4;
  var DEPTH_MASK$12 = 5;
  var State2 = (
    /** @class */
    function() {
      function State3() {
        this.data = 0;
        this.blendMode = BLEND_MODES.NORMAL;
        this.polygonOffset = 0;
        this.blend = true;
        this.depthMask = true;
      }
      Object.defineProperty(State3.prototype, "blend", {
        /**
         * Activates blending of the computed fragment color values.
         * @default true
         */
        get: function() {
          return !!(this.data & 1 << BLEND$12);
        },
        set: function(value) {
          if (!!(this.data & 1 << BLEND$12) !== value) {
            this.data ^= 1 << BLEND$12;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State3.prototype, "offsets", {
        /**
         * Activates adding an offset to depth values of polygon's fragments
         * @default false
         */
        get: function() {
          return !!(this.data & 1 << OFFSET$12);
        },
        set: function(value) {
          if (!!(this.data & 1 << OFFSET$12) !== value) {
            this.data ^= 1 << OFFSET$12;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State3.prototype, "culling", {
        /**
         * Activates culling of polygons.
         * @default false
         */
        get: function() {
          return !!(this.data & 1 << CULLING$12);
        },
        set: function(value) {
          if (!!(this.data & 1 << CULLING$12) !== value) {
            this.data ^= 1 << CULLING$12;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State3.prototype, "depthTest", {
        /**
         * Activates depth comparisons and updates to the depth buffer.
         * @default false
         */
        get: function() {
          return !!(this.data & 1 << DEPTH_TEST$12);
        },
        set: function(value) {
          if (!!(this.data & 1 << DEPTH_TEST$12) !== value) {
            this.data ^= 1 << DEPTH_TEST$12;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State3.prototype, "depthMask", {
        /**
         * Enables or disables writing to the depth buffer.
         * @default true
         */
        get: function() {
          return !!(this.data & 1 << DEPTH_MASK$12);
        },
        set: function(value) {
          if (!!(this.data & 1 << DEPTH_MASK$12) !== value) {
            this.data ^= 1 << DEPTH_MASK$12;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State3.prototype, "clockwiseFrontFace", {
        /**
         * Specifies whether or not front or back-facing polygons can be culled.
         * @default false
         */
        get: function() {
          return !!(this.data & 1 << WINDING$12);
        },
        set: function(value) {
          if (!!(this.data & 1 << WINDING$12) !== value) {
            this.data ^= 1 << WINDING$12;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State3.prototype, "blendMode", {
        /**
         * The blend mode to be applied when this state is set. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
         * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
         * @default PIXI.BLEND_MODES.NORMAL
         */
        get: function() {
          return this._blendMode;
        },
        set: function(value) {
          this.blend = value !== BLEND_MODES.NONE;
          this._blendMode = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State3.prototype, "polygonOffset", {
        /**
         * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
         * @default 0
         */
        get: function() {
          return this._polygonOffset;
        },
        set: function(value) {
          this.offsets = !!value;
          this._polygonOffset = value;
        },
        enumerable: false,
        configurable: true
      });
      State3.prototype.toString = function() {
        return "[@pixi/core:State " + ("blendMode=" + this.blendMode + " ") + ("clockwiseFrontFace=" + this.clockwiseFrontFace + " ") + ("culling=" + this.culling + " ") + ("depthMask=" + this.depthMask + " ") + ("polygonOffset=" + this.polygonOffset) + "]";
      };
      State3.for2d = function() {
        var state = new State3();
        state.depthTest = false;
        state.blend = true;
        return state;
      };
      return State3;
    }()
  );
  var defaultVertex$22 = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
  var defaultFragment$12 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n";
  var Filter2 = (
    /** @class */
    function(_super) {
      __extends12(Filter3, _super);
      function Filter3(vertexSrc, fragmentSrc, uniforms) {
        var _this = this;
        var program = Program2.from(vertexSrc || Filter3.defaultVertexSrc, fragmentSrc || Filter3.defaultFragmentSrc);
        _this = _super.call(this, program, uniforms) || this;
        _this.padding = 0;
        _this.resolution = settings.FILTER_RESOLUTION;
        _this.multisample = settings.FILTER_MULTISAMPLE;
        _this.enabled = true;
        _this.autoFit = true;
        _this.state = new State2();
        return _this;
      }
      Filter3.prototype.apply = function(filterManager, input, output, clearMode, _currentState) {
        filterManager.applyFilter(this, input, output, clearMode);
      };
      Object.defineProperty(Filter3.prototype, "blendMode", {
        /**
         * Sets the blend mode of the filter.
         * @default PIXI.BLEND_MODES.NORMAL
         */
        get: function() {
          return this.state.blendMode;
        },
        set: function(value) {
          this.state.blendMode = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Filter3.prototype, "resolution", {
        /**
         * The resolution of the filter. Setting this to be lower will lower the quality but
         * increase the performance of the filter.
         */
        get: function() {
          return this._resolution;
        },
        set: function(value) {
          this._resolution = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Filter3, "defaultVertexSrc", {
        /**
         * The default vertex shader source
         * @constant
         */
        get: function() {
          return defaultVertex$22;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Filter3, "defaultFragmentSrc", {
        /**
         * The default fragment shader source
         * @constant
         */
        get: function() {
          return defaultFragment$12;
        },
        enumerable: false,
        configurable: true
      });
      return Filter3;
    }(Shader2)
  );
  var vertex3 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n";
  var fragment3 = "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n";
  var tempMat3 = new Matrix2();
  var TextureMatrix2 = (
    /** @class */
    function() {
      function TextureMatrix3(texture, clampMargin) {
        this._texture = texture;
        this.mapCoord = new Matrix2();
        this.uClampFrame = new Float32Array(4);
        this.uClampOffset = new Float32Array(2);
        this._textureID = -1;
        this._updateID = 0;
        this.clampOffset = 0;
        this.clampMargin = typeof clampMargin === "undefined" ? 0.5 : clampMargin;
        this.isSimple = false;
      }
      Object.defineProperty(TextureMatrix3.prototype, "texture", {
        /** Texture property. */
        get: function() {
          return this._texture;
        },
        set: function(value) {
          this._texture = value;
          this._textureID = -1;
        },
        enumerable: false,
        configurable: true
      });
      TextureMatrix3.prototype.multiplyUvs = function(uvs, out) {
        if (out === void 0) {
          out = uvs;
        }
        var mat = this.mapCoord;
        for (var i = 0; i < uvs.length; i += 2) {
          var x = uvs[i];
          var y = uvs[i + 1];
          out[i] = x * mat.a + y * mat.c + mat.tx;
          out[i + 1] = x * mat.b + y * mat.d + mat.ty;
        }
        return out;
      };
      TextureMatrix3.prototype.update = function(forceUpdate) {
        var tex = this._texture;
        if (!tex || !tex.valid) {
          return false;
        }
        if (!forceUpdate && this._textureID === tex._updateID) {
          return false;
        }
        this._textureID = tex._updateID;
        this._updateID++;
        var uvs = tex._uvs;
        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
        var orig = tex.orig;
        var trim = tex.trim;
        if (trim) {
          tempMat3.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);
          this.mapCoord.append(tempMat3);
        }
        var texBase = tex.baseTexture;
        var frame = this.uClampFrame;
        var margin = this.clampMargin / texBase.resolution;
        var offset = this.clampOffset;
        frame[0] = (tex._frame.x + margin + offset) / texBase.width;
        frame[1] = (tex._frame.y + margin + offset) / texBase.height;
        frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;
        frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;
        this.uClampOffset[0] = offset / texBase.realWidth;
        this.uClampOffset[1] = offset / texBase.realHeight;
        this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0;
        return true;
      };
      return TextureMatrix3;
    }()
  );
  var SpriteMaskFilter2 = (
    /** @class */
    function(_super) {
      __extends12(SpriteMaskFilter3, _super);
      function SpriteMaskFilter3(vertexSrc, fragmentSrc, uniforms) {
        var _this = this;
        var sprite = null;
        if (typeof vertexSrc !== "string" && fragmentSrc === void 0 && uniforms === void 0) {
          sprite = vertexSrc;
          vertexSrc = void 0;
          fragmentSrc = void 0;
          uniforms = void 0;
        }
        _this = _super.call(this, vertexSrc || vertex3, fragmentSrc || fragment3, uniforms) || this;
        _this.maskSprite = sprite;
        _this.maskMatrix = new Matrix2();
        return _this;
      }
      Object.defineProperty(SpriteMaskFilter3.prototype, "maskSprite", {
        /**
         * Sprite mask
         * @type {PIXI.DisplayObject}
         */
        get: function() {
          return this._maskSprite;
        },
        set: function(value) {
          this._maskSprite = value;
          if (this._maskSprite) {
            this._maskSprite.renderable = false;
          }
        },
        enumerable: false,
        configurable: true
      });
      SpriteMaskFilter3.prototype.apply = function(filterManager, input, output, clearMode) {
        var maskSprite = this._maskSprite;
        var tex = maskSprite._texture;
        if (!tex.valid) {
          return;
        }
        if (!tex.uvMatrix) {
          tex.uvMatrix = new TextureMatrix2(tex, 0);
        }
        tex.uvMatrix.update();
        this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0 : 1;
        this.uniforms.mask = tex;
        this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.uvMatrix.mapCoord);
        this.uniforms.alpha = maskSprite.worldAlpha;
        this.uniforms.maskClamp = tex.uvMatrix.uClampFrame;
        filterManager.applyFilter(this, input, output, clearMode);
      };
      return SpriteMaskFilter3;
    }(Filter2)
  );
  var MaskSystem2 = (
    /** @class */
    function() {
      function MaskSystem3(renderer) {
        this.renderer = renderer;
        this.enableScissor = true;
        this.alphaMaskPool = [];
        this.maskDataPool = [];
        this.maskStack = [];
        this.alphaMaskIndex = 0;
      }
      MaskSystem3.prototype.setMaskStack = function(maskStack) {
        this.maskStack = maskStack;
        this.renderer.scissor.setMaskStack(maskStack);
        this.renderer.stencil.setMaskStack(maskStack);
      };
      MaskSystem3.prototype.push = function(target, maskDataOrTarget) {
        var maskData = maskDataOrTarget;
        if (!maskData.isMaskData) {
          var d = this.maskDataPool.pop() || new MaskData2();
          d.pooled = true;
          d.maskObject = maskDataOrTarget;
          maskData = d;
        }
        var maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
        maskData.copyCountersOrReset(maskAbove);
        if (maskData.autoDetect) {
          this.detect(maskData);
        }
        maskData._target = target;
        if (maskData.type !== MASK_TYPES.SPRITE) {
          this.maskStack.push(maskData);
        }
        if (maskData.enabled) {
          switch (maskData.type) {
            case MASK_TYPES.SCISSOR:
              this.renderer.scissor.push(maskData);
              break;
            case MASK_TYPES.STENCIL:
              this.renderer.stencil.push(maskData);
              break;
            case MASK_TYPES.SPRITE:
              maskData.copyCountersOrReset(null);
              this.pushSpriteMask(maskData);
              break;
          }
        }
        if (maskData.type === MASK_TYPES.SPRITE) {
          this.maskStack.push(maskData);
        }
      };
      MaskSystem3.prototype.pop = function(target) {
        var maskData = this.maskStack.pop();
        if (!maskData || maskData._target !== target) {
          return;
        }
        if (maskData.enabled) {
          switch (maskData.type) {
            case MASK_TYPES.SCISSOR:
              this.renderer.scissor.pop();
              break;
            case MASK_TYPES.STENCIL:
              this.renderer.stencil.pop(maskData.maskObject);
              break;
            case MASK_TYPES.SPRITE:
              this.popSpriteMask(maskData);
              break;
          }
        }
        maskData.reset();
        if (maskData.pooled) {
          this.maskDataPool.push(maskData);
        }
        if (this.maskStack.length !== 0) {
          var maskCurrent = this.maskStack[this.maskStack.length - 1];
          if (maskCurrent.type === MASK_TYPES.SPRITE && maskCurrent._filters) {
            maskCurrent._filters[0].maskSprite = maskCurrent.maskObject;
          }
        }
      };
      MaskSystem3.prototype.detect = function(maskData) {
        var maskObject = maskData.maskObject;
        if (maskObject.isSprite) {
          maskData.type = MASK_TYPES.SPRITE;
        } else if (this.enableScissor && this.renderer.scissor.testScissor(maskData)) {
          maskData.type = MASK_TYPES.SCISSOR;
        } else {
          maskData.type = MASK_TYPES.STENCIL;
        }
      };
      MaskSystem3.prototype.pushSpriteMask = function(maskData) {
        var _a2, _b;
        var maskObject = maskData.maskObject;
        var target = maskData._target;
        var alphaMaskFilter = maskData._filters;
        if (!alphaMaskFilter) {
          alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];
          if (!alphaMaskFilter) {
            alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter2()];
          }
        }
        var renderer = this.renderer;
        var renderTextureSystem = renderer.renderTexture;
        var resolution;
        var multisample;
        if (renderTextureSystem.current) {
          var renderTexture = renderTextureSystem.current;
          resolution = maskData.resolution || renderTexture.resolution;
          multisample = (_a2 = maskData.multisample) !== null && _a2 !== void 0 ? _a2 : renderTexture.multisample;
        } else {
          resolution = maskData.resolution || renderer.resolution;
          multisample = (_b = maskData.multisample) !== null && _b !== void 0 ? _b : renderer.multisample;
        }
        alphaMaskFilter[0].resolution = resolution;
        alphaMaskFilter[0].multisample = multisample;
        alphaMaskFilter[0].maskSprite = maskObject;
        var stashFilterArea = target.filterArea;
        target.filterArea = maskObject.getBounds(true);
        renderer.filter.push(target, alphaMaskFilter);
        target.filterArea = stashFilterArea;
        if (!maskData._filters) {
          this.alphaMaskIndex++;
        }
      };
      MaskSystem3.prototype.popSpriteMask = function(maskData) {
        this.renderer.filter.pop();
        if (maskData._filters) {
          maskData._filters[0].maskSprite = null;
        } else {
          this.alphaMaskIndex--;
          this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null;
        }
      };
      MaskSystem3.prototype.destroy = function() {
        this.renderer = null;
      };
      return MaskSystem3;
    }()
  );
  var AbstractMaskSystem2 = (
    /** @class */
    function() {
      function AbstractMaskSystem3(renderer) {
        this.renderer = renderer;
        this.maskStack = [];
        this.glConst = 0;
      }
      AbstractMaskSystem3.prototype.getStackLength = function() {
        return this.maskStack.length;
      };
      AbstractMaskSystem3.prototype.setMaskStack = function(maskStack) {
        var gl = this.renderer.gl;
        var curStackLen = this.getStackLength();
        this.maskStack = maskStack;
        var newStackLen = this.getStackLength();
        if (newStackLen !== curStackLen) {
          if (newStackLen === 0) {
            gl.disable(this.glConst);
          } else {
            gl.enable(this.glConst);
            this._useCurrent();
          }
        }
      };
      AbstractMaskSystem3.prototype._useCurrent = function() {
      };
      AbstractMaskSystem3.prototype.destroy = function() {
        this.renderer = null;
        this.maskStack = null;
      };
      return AbstractMaskSystem3;
    }()
  );
  var tempMatrix$12 = new Matrix2();
  var ScissorSystem2 = (
    /** @class */
    function(_super) {
      __extends12(ScissorSystem3, _super);
      function ScissorSystem3(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.glConst = WebGLRenderingContext.SCISSOR_TEST;
        return _this;
      }
      ScissorSystem3.prototype.getStackLength = function() {
        var maskData = this.maskStack[this.maskStack.length - 1];
        if (maskData) {
          return maskData._scissorCounter;
        }
        return 0;
      };
      ScissorSystem3.prototype.calcScissorRect = function(maskData) {
        if (maskData._scissorRectLocal) {
          return;
        }
        var prevData = maskData._scissorRect;
        var maskObject = maskData.maskObject;
        var renderer = this.renderer;
        var renderTextureSystem = renderer.renderTexture;
        maskObject.renderable = true;
        var rect = maskObject.getBounds();
        this.roundFrameToPixels(rect, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);
        maskObject.renderable = false;
        if (prevData) {
          rect.fit(prevData);
        }
        maskData._scissorRectLocal = rect;
      };
      ScissorSystem3.isMatrixRotated = function(matrix) {
        if (!matrix) {
          return false;
        }
        var a = matrix.a, b = matrix.b, c = matrix.c, d = matrix.d;
        return (Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4);
      };
      ScissorSystem3.prototype.testScissor = function(maskData) {
        var maskObject = maskData.maskObject;
        if (!maskObject.isFastRect || !maskObject.isFastRect()) {
          return false;
        }
        if (ScissorSystem3.isMatrixRotated(maskObject.worldTransform)) {
          return false;
        }
        if (ScissorSystem3.isMatrixRotated(this.renderer.projection.transform)) {
          return false;
        }
        this.calcScissorRect(maskData);
        var rect = maskData._scissorRectLocal;
        return rect.width > 0 && rect.height > 0;
      };
      ScissorSystem3.prototype.roundFrameToPixels = function(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
        if (ScissorSystem3.isMatrixRotated(transform)) {
          return;
        }
        transform = transform ? tempMatrix$12.copyFrom(transform) : tempMatrix$12.identity();
        transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
        this.renderer.filter.transformAABB(transform, frame);
        frame.fit(bindingDestinationFrame);
        frame.x = Math.round(frame.x * resolution);
        frame.y = Math.round(frame.y * resolution);
        frame.width = Math.round(frame.width * resolution);
        frame.height = Math.round(frame.height * resolution);
      };
      ScissorSystem3.prototype.push = function(maskData) {
        if (!maskData._scissorRectLocal) {
          this.calcScissorRect(maskData);
        }
        var gl = this.renderer.gl;
        if (!maskData._scissorRect) {
          gl.enable(gl.SCISSOR_TEST);
        }
        maskData._scissorCounter++;
        maskData._scissorRect = maskData._scissorRectLocal;
        this._useCurrent();
      };
      ScissorSystem3.prototype.pop = function() {
        var gl = this.renderer.gl;
        if (this.getStackLength() > 0) {
          this._useCurrent();
        } else {
          gl.disable(gl.SCISSOR_TEST);
        }
      };
      ScissorSystem3.prototype._useCurrent = function() {
        var rect = this.maskStack[this.maskStack.length - 1]._scissorRect;
        var y;
        if (this.renderer.renderTexture.current) {
          y = rect.y;
        } else {
          y = this.renderer.height - rect.height - rect.y;
        }
        this.renderer.gl.scissor(rect.x, y, rect.width, rect.height);
      };
      return ScissorSystem3;
    }(AbstractMaskSystem2)
  );
  var StencilSystem2 = (
    /** @class */
    function(_super) {
      __extends12(StencilSystem3, _super);
      function StencilSystem3(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.glConst = WebGLRenderingContext.STENCIL_TEST;
        return _this;
      }
      StencilSystem3.prototype.getStackLength = function() {
        var maskData = this.maskStack[this.maskStack.length - 1];
        if (maskData) {
          return maskData._stencilCounter;
        }
        return 0;
      };
      StencilSystem3.prototype.push = function(maskData) {
        var maskObject = maskData.maskObject;
        var gl = this.renderer.gl;
        var prevMaskCount = maskData._stencilCounter;
        if (prevMaskCount === 0) {
          this.renderer.framebuffer.forceStencil();
          gl.clearStencil(0);
          gl.clear(gl.STENCIL_BUFFER_BIT);
          gl.enable(gl.STENCIL_TEST);
        }
        maskData._stencilCounter++;
        gl.colorMask(false, false, false, false);
        gl.stencilFunc(gl.EQUAL, prevMaskCount, 4294967295);
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
        maskObject.renderable = true;
        maskObject.render(this.renderer);
        this.renderer.batch.flush();
        maskObject.renderable = false;
        this._useCurrent();
      };
      StencilSystem3.prototype.pop = function(maskObject) {
        var gl = this.renderer.gl;
        if (this.getStackLength() === 0) {
          gl.disable(gl.STENCIL_TEST);
        } else {
          gl.colorMask(false, false, false, false);
          gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
          maskObject.renderable = true;
          maskObject.render(this.renderer);
          this.renderer.batch.flush();
          maskObject.renderable = false;
          this._useCurrent();
        }
      };
      StencilSystem3.prototype._useCurrent = function() {
        var gl = this.renderer.gl;
        gl.colorMask(true, true, true, true);
        gl.stencilFunc(gl.EQUAL, this.getStackLength(), 4294967295);
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
      };
      return StencilSystem3;
    }(AbstractMaskSystem2)
  );
  var ProjectionSystem2 = (
    /** @class */
    function() {
      function ProjectionSystem3(renderer) {
        this.renderer = renderer;
        this.destinationFrame = null;
        this.sourceFrame = null;
        this.defaultFrame = null;
        this.projectionMatrix = new Matrix2();
        this.transform = null;
      }
      ProjectionSystem3.prototype.update = function(destinationFrame, sourceFrame, resolution, root) {
        this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
        this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;
        this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root);
        if (this.transform) {
          this.projectionMatrix.append(this.transform);
        }
        var renderer = this.renderer;
        renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix;
        renderer.globalUniforms.update();
        if (renderer.shader.shader) {
          renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);
        }
      };
      ProjectionSystem3.prototype.calculateProjection = function(_destinationFrame, sourceFrame, _resolution, root) {
        var pm = this.projectionMatrix;
        var sign2 = !root ? 1 : -1;
        pm.identity();
        pm.a = 1 / sourceFrame.width * 2;
        pm.d = sign2 * (1 / sourceFrame.height * 2);
        pm.tx = -1 - sourceFrame.x * pm.a;
        pm.ty = -sign2 - sourceFrame.y * pm.d;
      };
      ProjectionSystem3.prototype.setTransform = function(_matrix) {
      };
      ProjectionSystem3.prototype.destroy = function() {
        this.renderer = null;
      };
      return ProjectionSystem3;
    }()
  );
  var tempRect3 = new Rectangle2();
  var tempRect22 = new Rectangle2();
  var RenderTextureSystem2 = (
    /** @class */
    function() {
      function RenderTextureSystem3(renderer) {
        this.renderer = renderer;
        this.clearColor = renderer._backgroundColorRgba;
        this.defaultMaskStack = [];
        this.current = null;
        this.sourceFrame = new Rectangle2();
        this.destinationFrame = new Rectangle2();
        this.viewportFrame = new Rectangle2();
      }
      RenderTextureSystem3.prototype.bind = function(renderTexture, sourceFrame, destinationFrame) {
        if (renderTexture === void 0) {
          renderTexture = null;
        }
        var renderer = this.renderer;
        this.current = renderTexture;
        var baseTexture;
        var framebuffer;
        var resolution;
        if (renderTexture) {
          baseTexture = renderTexture.baseTexture;
          resolution = baseTexture.resolution;
          if (!sourceFrame) {
            tempRect3.width = renderTexture.frame.width;
            tempRect3.height = renderTexture.frame.height;
            sourceFrame = tempRect3;
          }
          if (!destinationFrame) {
            tempRect22.x = renderTexture.frame.x;
            tempRect22.y = renderTexture.frame.y;
            tempRect22.width = sourceFrame.width;
            tempRect22.height = sourceFrame.height;
            destinationFrame = tempRect22;
          }
          framebuffer = baseTexture.framebuffer;
        } else {
          resolution = renderer.resolution;
          if (!sourceFrame) {
            tempRect3.width = renderer.screen.width;
            tempRect3.height = renderer.screen.height;
            sourceFrame = tempRect3;
          }
          if (!destinationFrame) {
            destinationFrame = tempRect3;
            destinationFrame.width = sourceFrame.width;
            destinationFrame.height = sourceFrame.height;
          }
        }
        var viewportFrame = this.viewportFrame;
        viewportFrame.x = destinationFrame.x * resolution;
        viewportFrame.y = destinationFrame.y * resolution;
        viewportFrame.width = destinationFrame.width * resolution;
        viewportFrame.height = destinationFrame.height * resolution;
        if (!renderTexture) {
          viewportFrame.y = renderer.view.height - (viewportFrame.y + viewportFrame.height);
        }
        viewportFrame.ceil();
        this.renderer.framebuffer.bind(framebuffer, viewportFrame);
        this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer);
        if (renderTexture) {
          this.renderer.mask.setMaskStack(baseTexture.maskStack);
        } else {
          this.renderer.mask.setMaskStack(this.defaultMaskStack);
        }
        this.sourceFrame.copyFrom(sourceFrame);
        this.destinationFrame.copyFrom(destinationFrame);
      };
      RenderTextureSystem3.prototype.clear = function(clearColor, mask) {
        if (this.current) {
          clearColor = clearColor || this.current.baseTexture.clearColor;
        } else {
          clearColor = clearColor || this.clearColor;
        }
        var destinationFrame = this.destinationFrame;
        var baseFrame = this.current ? this.current.baseTexture : this.renderer.screen;
        var clearMask = destinationFrame.width !== baseFrame.width || destinationFrame.height !== baseFrame.height;
        if (clearMask) {
          var _a2 = this.viewportFrame, x = _a2.x, y = _a2.y, width = _a2.width, height = _a2.height;
          x = Math.round(x);
          y = Math.round(y);
          width = Math.round(width);
          height = Math.round(height);
          this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);
          this.renderer.gl.scissor(x, y, width, height);
        }
        this.renderer.framebuffer.clear(clearColor[0], clearColor[1], clearColor[2], clearColor[3], mask);
        if (clearMask) {
          this.renderer.scissor.pop();
        }
      };
      RenderTextureSystem3.prototype.resize = function() {
        this.bind(null);
      };
      RenderTextureSystem3.prototype.reset = function() {
        this.bind(null);
      };
      RenderTextureSystem3.prototype.destroy = function() {
        this.renderer = null;
      };
      return RenderTextureSystem3;
    }()
  );
  function uboUpdate2(_ud, _uv, _renderer, _syncData, buffer) {
    _renderer.buffer.update(buffer);
  }
  var UBO_TO_SINGLE_SETTERS2 = {
    float: "\n        data[offset] = v;\n    ",
    vec2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    ",
    vec3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    ",
    vec4: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    ",
    mat2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    ",
    mat3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    ",
    mat4: "\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    "
  };
  var GLSL_TO_STD40_SIZE2 = {
    float: 4,
    vec2: 8,
    vec3: 12,
    vec4: 16,
    int: 4,
    ivec2: 8,
    ivec3: 12,
    ivec4: 16,
    uint: 4,
    uvec2: 8,
    uvec3: 12,
    uvec4: 16,
    bool: 4,
    bvec2: 8,
    bvec3: 12,
    bvec4: 16,
    mat2: 16 * 2,
    mat3: 16 * 3,
    mat4: 16 * 4
  };
  function createUBOElements2(uniformData) {
    var uboElements = uniformData.map(function(data) {
      return {
        data,
        offset: 0,
        dataLen: 0,
        dirty: 0
      };
    });
    var size = 0;
    var chunkSize = 0;
    var offset = 0;
    for (var i = 0; i < uboElements.length; i++) {
      var uboElement = uboElements[i];
      size = GLSL_TO_STD40_SIZE2[uboElement.data.type];
      if (uboElement.data.size > 1) {
        size = Math.max(size, 16) * uboElement.data.size;
      }
      uboElement.dataLen = size;
      if (chunkSize % size !== 0 && chunkSize < 16) {
        var lineUpValue = chunkSize % size % 16;
        chunkSize += lineUpValue;
        offset += lineUpValue;
      }
      if (chunkSize + size > 16) {
        offset = Math.ceil(offset / 16) * 16;
        uboElement.offset = offset;
        offset += size;
        chunkSize = size;
      } else {
        uboElement.offset = offset;
        chunkSize += size;
        offset += size;
      }
    }
    offset = Math.ceil(offset / 16) * 16;
    return { uboElements, size: offset };
  }
  function getUBOData2(uniforms, uniformData) {
    var usedUniformDatas = [];
    for (var i in uniforms) {
      if (uniformData[i]) {
        usedUniformDatas.push(uniformData[i]);
      }
    }
    usedUniformDatas.sort(function(a, b) {
      return a.index - b.index;
    });
    return usedUniformDatas;
  }
  function generateUniformBufferSync2(group, uniformData) {
    if (!group.autoManage) {
      return { size: 0, syncFunc: uboUpdate2 };
    }
    var usedUniformDatas = getUBOData2(group.uniforms, uniformData);
    var _a2 = createUBOElements2(usedUniformDatas), uboElements = _a2.uboElements, size = _a2.size;
    var funcFragments = ["\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    "];
    for (var i = 0; i < uboElements.length; i++) {
      var uboElement = uboElements[i];
      var uniform = group.uniforms[uboElement.data.name];
      var name = uboElement.data.name;
      var parsed = false;
      for (var j = 0; j < uniformParsers2.length; j++) {
        var uniformParser = uniformParsers2[j];
        if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform)) {
          funcFragments.push("offset = " + uboElement.offset / 4 + ";", uniformParsers2[j].codeUbo(uboElement.data.name, uniform));
          parsed = true;
          break;
        }
      }
      if (!parsed) {
        if (uboElement.data.size > 1) {
          var size_1 = mapSize2(uboElement.data.type);
          var rowSize = Math.max(GLSL_TO_STD40_SIZE2[uboElement.data.type] / 16, 1);
          var elementSize = size_1 / rowSize;
          var remainder = (4 - elementSize % 4) % 4;
          funcFragments.push("\n                cv = ud." + name + ".value;\n                v = uv." + name + ";\n                offset = " + uboElement.offset / 4 + ";\n\n                t = 0;\n\n                for(var i=0; i < " + uboElement.data.size * rowSize + "; i++)\n                {\n                    for(var j = 0; j < " + elementSize + "; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += " + remainder + ";\n                }\n\n                ");
        } else {
          var template = UBO_TO_SINGLE_SETTERS2[uboElement.data.type];
          funcFragments.push("\n                cv = ud." + name + ".value;\n                v = uv." + name + ";\n                offset = " + uboElement.offset / 4 + ";\n                " + template + ";\n                ");
        }
      }
    }
    funcFragments.push("\n       renderer.buffer.update(buffer);\n    ");
    return {
      size,
      // eslint-disable-next-line no-new-func
      syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", funcFragments.join("\n"))
    };
  }
  var GLProgram2 = (
    /** @class */
    function() {
      function GLProgram3(program, uniformData) {
        this.program = program;
        this.uniformData = uniformData;
        this.uniformGroups = {};
        this.uniformDirtyGroups = {};
        this.uniformBufferBindings = {};
      }
      GLProgram3.prototype.destroy = function() {
        this.uniformData = null;
        this.uniformGroups = null;
        this.uniformDirtyGroups = null;
        this.uniformBufferBindings = null;
        this.program = null;
      };
      return GLProgram3;
    }()
  );
  function getAttributeData2(program, gl) {
    var attributes = {};
    var totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (var i = 0; i < totalAttributes; i++) {
      var attribData = gl.getActiveAttrib(program, i);
      if (attribData.name.indexOf("gl_") === 0) {
        continue;
      }
      var type = mapType2(gl, attribData.type);
      var data = {
        type,
        name: attribData.name,
        size: mapSize2(type),
        location: gl.getAttribLocation(program, attribData.name)
      };
      attributes[attribData.name] = data;
    }
    return attributes;
  }
  function getUniformData2(program, gl) {
    var uniforms = {};
    var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (var i = 0; i < totalUniforms; i++) {
      var uniformData = gl.getActiveUniform(program, i);
      var name = uniformData.name.replace(/\[.*?\]$/, "");
      var isArray = !!uniformData.name.match(/\[.*?\]$/);
      var type = mapType2(gl, uniformData.type);
      uniforms[name] = {
        name,
        index: i,
        type,
        size: uniformData.size,
        isArray,
        value: defaultValue2(type, uniformData.size)
      };
    }
    return uniforms;
  }
  function generateProgram2(gl, program) {
    var glVertShader = compileShader2(gl, gl.VERTEX_SHADER, program.vertexSrc);
    var glFragShader = compileShader2(gl, gl.FRAGMENT_SHADER, program.fragmentSrc);
    var webGLProgram = gl.createProgram();
    gl.attachShader(webGLProgram, glVertShader);
    gl.attachShader(webGLProgram, glFragShader);
    gl.linkProgram(webGLProgram);
    if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
      logProgramError2(gl, webGLProgram, glVertShader, glFragShader);
    }
    program.attributeData = getAttributeData2(webGLProgram, gl);
    program.uniformData = getUniformData2(webGLProgram, gl);
    if (!/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertexSrc)) {
      var keys = Object.keys(program.attributeData);
      keys.sort(function(a, b) {
        return a > b ? 1 : -1;
      });
      for (var i = 0; i < keys.length; i++) {
        program.attributeData[keys[i]].location = i;
        gl.bindAttribLocation(webGLProgram, i, keys[i]);
      }
      gl.linkProgram(webGLProgram);
    }
    gl.deleteShader(glVertShader);
    gl.deleteShader(glFragShader);
    var uniformData = {};
    for (var i in program.uniformData) {
      var data = program.uniformData[i];
      uniformData[i] = {
        location: gl.getUniformLocation(webGLProgram, i),
        value: defaultValue2(data.type, data.size)
      };
    }
    var glProgram = new GLProgram2(webGLProgram, uniformData);
    return glProgram;
  }
  var UID2 = 0;
  var defaultSyncData2 = { textureCount: 0, uboCount: 0 };
  var ShaderSystem2 = (
    /** @class */
    function() {
      function ShaderSystem3(renderer) {
        this.destroyed = false;
        this.renderer = renderer;
        this.systemCheck();
        this.gl = null;
        this.shader = null;
        this.program = null;
        this.cache = {};
        this._uboCache = {};
        this.id = UID2++;
      }
      ShaderSystem3.prototype.systemCheck = function() {
        if (!unsafeEvalSupported2()) {
          throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
        }
      };
      ShaderSystem3.prototype.contextChange = function(gl) {
        this.gl = gl;
        this.reset();
      };
      ShaderSystem3.prototype.bind = function(shader, dontSync) {
        shader.uniforms.globals = this.renderer.globalUniforms;
        var program = shader.program;
        var glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(shader);
        this.shader = shader;
        if (this.program !== program) {
          this.program = program;
          this.gl.useProgram(glProgram.program);
        }
        if (!dontSync) {
          defaultSyncData2.textureCount = 0;
          defaultSyncData2.uboCount = 0;
          this.syncUniformGroup(shader.uniformGroup, defaultSyncData2);
        }
        return glProgram;
      };
      ShaderSystem3.prototype.setUniforms = function(uniforms) {
        var shader = this.shader.program;
        var glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];
        shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);
      };
      ShaderSystem3.prototype.syncUniformGroup = function(group, syncData) {
        var glProgram = this.getGlProgram();
        if (!group.static || group.dirtyId !== glProgram.uniformDirtyGroups[group.id]) {
          glProgram.uniformDirtyGroups[group.id] = group.dirtyId;
          this.syncUniforms(group, glProgram, syncData);
        }
      };
      ShaderSystem3.prototype.syncUniforms = function(group, glProgram, syncData) {
        var syncFunc = group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group);
        syncFunc(glProgram.uniformData, group.uniforms, this.renderer, syncData);
      };
      ShaderSystem3.prototype.createSyncGroups = function(group) {
        var id = this.getSignature(group, this.shader.program.uniformData, "u");
        if (!this.cache[id]) {
          this.cache[id] = generateUniformsSync2(group, this.shader.program.uniformData);
        }
        group.syncUniforms[this.shader.program.id] = this.cache[id];
        return group.syncUniforms[this.shader.program.id];
      };
      ShaderSystem3.prototype.syncUniformBufferGroup = function(group, name) {
        var glProgram = this.getGlProgram();
        if (!group.static || group.dirtyId !== 0 || !glProgram.uniformGroups[group.id]) {
          group.dirtyId = 0;
          var syncFunc = glProgram.uniformGroups[group.id] || this.createSyncBufferGroup(group, glProgram, name);
          group.buffer.update();
          syncFunc(glProgram.uniformData, group.uniforms, this.renderer, defaultSyncData2, group.buffer);
        }
        this.renderer.buffer.bindBufferBase(group.buffer, glProgram.uniformBufferBindings[name]);
      };
      ShaderSystem3.prototype.createSyncBufferGroup = function(group, glProgram, name) {
        var gl = this.renderer.gl;
        this.renderer.buffer.bind(group.buffer);
        var uniformBlockIndex = this.gl.getUniformBlockIndex(glProgram.program, name);
        glProgram.uniformBufferBindings[name] = this.shader.uniformBindCount;
        gl.uniformBlockBinding(glProgram.program, uniformBlockIndex, this.shader.uniformBindCount);
        this.shader.uniformBindCount++;
        var id = this.getSignature(group, this.shader.program.uniformData, "ubo");
        var uboData = this._uboCache[id];
        if (!uboData) {
          uboData = this._uboCache[id] = generateUniformBufferSync2(group, this.shader.program.uniformData);
        }
        if (group.autoManage) {
          var data = new Float32Array(uboData.size / 4);
          group.buffer.update(data);
        }
        glProgram.uniformGroups[group.id] = uboData.syncFunc;
        return glProgram.uniformGroups[group.id];
      };
      ShaderSystem3.prototype.getSignature = function(group, uniformData, preFix) {
        var uniforms = group.uniforms;
        var strings = [preFix + "-"];
        for (var i in uniforms) {
          strings.push(i);
          if (uniformData[i]) {
            strings.push(uniformData[i].type);
          }
        }
        return strings.join("-");
      };
      ShaderSystem3.prototype.getGlProgram = function() {
        if (this.shader) {
          return this.shader.program.glPrograms[this.renderer.CONTEXT_UID];
        }
        return null;
      };
      ShaderSystem3.prototype.generateProgram = function(shader) {
        var gl = this.gl;
        var program = shader.program;
        var glProgram = generateProgram2(gl, program);
        program.glPrograms[this.renderer.CONTEXT_UID] = glProgram;
        return glProgram;
      };
      ShaderSystem3.prototype.reset = function() {
        this.program = null;
        this.shader = null;
      };
      ShaderSystem3.prototype.destroy = function() {
        this.renderer = null;
        this.destroyed = true;
      };
      return ShaderSystem3;
    }()
  );
  function mapWebGLBlendModesToPixi2(gl, array) {
    if (array === void 0) {
      array = [];
    }
    array[BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.ADD] = [gl.ONE, gl.ONE];
    array[BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.NONE] = [0, 0];
    array[BLEND_MODES.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
    array[BLEND_MODES.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];
    array[BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];
    array[BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];
    array[BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];
    array[BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];
    array[BLEND_MODES.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
    array[BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];
    return array;
  }
  var BLEND2 = 0;
  var OFFSET2 = 1;
  var CULLING2 = 2;
  var DEPTH_TEST2 = 3;
  var WINDING2 = 4;
  var DEPTH_MASK2 = 5;
  var StateSystem2 = (
    /** @class */
    function() {
      function StateSystem3() {
        this.gl = null;
        this.stateId = 0;
        this.polygonOffset = 0;
        this.blendMode = BLEND_MODES.NONE;
        this._blendEq = false;
        this.map = [];
        this.map[BLEND2] = this.setBlend;
        this.map[OFFSET2] = this.setOffset;
        this.map[CULLING2] = this.setCullFace;
        this.map[DEPTH_TEST2] = this.setDepthTest;
        this.map[WINDING2] = this.setFrontFace;
        this.map[DEPTH_MASK2] = this.setDepthMask;
        this.checks = [];
        this.defaultState = new State2();
        this.defaultState.blend = true;
      }
      StateSystem3.prototype.contextChange = function(gl) {
        this.gl = gl;
        this.blendModes = mapWebGLBlendModesToPixi2(gl);
        this.set(this.defaultState);
        this.reset();
      };
      StateSystem3.prototype.set = function(state) {
        state = state || this.defaultState;
        if (this.stateId !== state.data) {
          var diff = this.stateId ^ state.data;
          var i = 0;
          while (diff) {
            if (diff & 1) {
              this.map[i].call(this, !!(state.data & 1 << i));
            }
            diff = diff >> 1;
            i++;
          }
          this.stateId = state.data;
        }
        for (var i = 0; i < this.checks.length; i++) {
          this.checks[i](this, state);
        }
      };
      StateSystem3.prototype.forceState = function(state) {
        state = state || this.defaultState;
        for (var i = 0; i < this.map.length; i++) {
          this.map[i].call(this, !!(state.data & 1 << i));
        }
        for (var i = 0; i < this.checks.length; i++) {
          this.checks[i](this, state);
        }
        this.stateId = state.data;
      };
      StateSystem3.prototype.setBlend = function(value) {
        this.updateCheck(StateSystem3.checkBlendMode, value);
        this.gl[value ? "enable" : "disable"](this.gl.BLEND);
      };
      StateSystem3.prototype.setOffset = function(value) {
        this.updateCheck(StateSystem3.checkPolygonOffset, value);
        this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
      };
      StateSystem3.prototype.setDepthTest = function(value) {
        this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
      };
      StateSystem3.prototype.setDepthMask = function(value) {
        this.gl.depthMask(value);
      };
      StateSystem3.prototype.setCullFace = function(value) {
        this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
      };
      StateSystem3.prototype.setFrontFace = function(value) {
        this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);
      };
      StateSystem3.prototype.setBlendMode = function(value) {
        if (value === this.blendMode) {
          return;
        }
        this.blendMode = value;
        var mode = this.blendModes[value];
        var gl = this.gl;
        if (mode.length === 2) {
          gl.blendFunc(mode[0], mode[1]);
        } else {
          gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
        }
        if (mode.length === 6) {
          this._blendEq = true;
          gl.blendEquationSeparate(mode[4], mode[5]);
        } else if (this._blendEq) {
          this._blendEq = false;
          gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        }
      };
      StateSystem3.prototype.setPolygonOffset = function(value, scale) {
        this.gl.polygonOffset(value, scale);
      };
      StateSystem3.prototype.reset = function() {
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
        this.forceState(this.defaultState);
        this._blendEq = true;
        this.blendMode = -1;
        this.setBlendMode(0);
      };
      StateSystem3.prototype.updateCheck = function(func, value) {
        var index = this.checks.indexOf(func);
        if (value && index === -1) {
          this.checks.push(func);
        } else if (!value && index !== -1) {
          this.checks.splice(index, 1);
        }
      };
      StateSystem3.checkBlendMode = function(system, state) {
        system.setBlendMode(state.blendMode);
      };
      StateSystem3.checkPolygonOffset = function(system, state) {
        system.setPolygonOffset(1, state.polygonOffset);
      };
      StateSystem3.prototype.destroy = function() {
        this.gl = null;
      };
      return StateSystem3;
    }()
  );
  var TextureGCSystem2 = (
    /** @class */
    function() {
      function TextureGCSystem3(renderer) {
        this.renderer = renderer;
        this.count = 0;
        this.checkCount = 0;
        this.maxIdle = settings.GC_MAX_IDLE;
        this.checkCountMax = settings.GC_MAX_CHECK_COUNT;
        this.mode = settings.GC_MODE;
      }
      TextureGCSystem3.prototype.postrender = function() {
        if (!this.renderer.renderingToScreen) {
          return;
        }
        this.count++;
        if (this.mode === GC_MODES.MANUAL) {
          return;
        }
        this.checkCount++;
        if (this.checkCount > this.checkCountMax) {
          this.checkCount = 0;
          this.run();
        }
      };
      TextureGCSystem3.prototype.run = function() {
        var tm = this.renderer.texture;
        var managedTextures = tm.managedTextures;
        var wasRemoved = false;
        for (var i = 0; i < managedTextures.length; i++) {
          var texture = managedTextures[i];
          if (!texture.framebuffer && this.count - texture.touched > this.maxIdle) {
            tm.destroyTexture(texture, true);
            managedTextures[i] = null;
            wasRemoved = true;
          }
        }
        if (wasRemoved) {
          var j = 0;
          for (var i = 0; i < managedTextures.length; i++) {
            if (managedTextures[i] !== null) {
              managedTextures[j++] = managedTextures[i];
            }
          }
          managedTextures.length = j;
        }
      };
      TextureGCSystem3.prototype.unload = function(displayObject) {
        var tm = this.renderer.texture;
        var texture = displayObject._texture;
        if (texture && !texture.framebuffer) {
          tm.destroyTexture(texture);
        }
        for (var i = displayObject.children.length - 1; i >= 0; i--) {
          this.unload(displayObject.children[i]);
        }
      };
      TextureGCSystem3.prototype.destroy = function() {
        this.renderer = null;
      };
      return TextureGCSystem3;
    }()
  );
  function mapTypeAndFormatToInternalFormat2(gl) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
    var table;
    if ("WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext) {
      table = (_a2 = {}, _a2[TYPES.UNSIGNED_BYTE] = (_b = {}, _b[FORMATS.RGBA] = gl.RGBA8, _b[FORMATS.RGB] = gl.RGB8, _b[FORMATS.RG] = gl.RG8, _b[FORMATS.RED] = gl.R8, _b[FORMATS.RGBA_INTEGER] = gl.RGBA8UI, _b[FORMATS.RGB_INTEGER] = gl.RGB8UI, _b[FORMATS.RG_INTEGER] = gl.RG8UI, _b[FORMATS.RED_INTEGER] = gl.R8UI, _b[FORMATS.ALPHA] = gl.ALPHA, _b[FORMATS.LUMINANCE] = gl.LUMINANCE, _b[FORMATS.LUMINANCE_ALPHA] = gl.LUMINANCE_ALPHA, _b), _a2[TYPES.BYTE] = (_c = {}, _c[FORMATS.RGBA] = gl.RGBA8_SNORM, _c[FORMATS.RGB] = gl.RGB8_SNORM, _c[FORMATS.RG] = gl.RG8_SNORM, _c[FORMATS.RED] = gl.R8_SNORM, _c[FORMATS.RGBA_INTEGER] = gl.RGBA8I, _c[FORMATS.RGB_INTEGER] = gl.RGB8I, _c[FORMATS.RG_INTEGER] = gl.RG8I, _c[FORMATS.RED_INTEGER] = gl.R8I, _c), _a2[TYPES.UNSIGNED_SHORT] = (_d = {}, _d[FORMATS.RGBA_INTEGER] = gl.RGBA16UI, _d[FORMATS.RGB_INTEGER] = gl.RGB16UI, _d[FORMATS.RG_INTEGER] = gl.RG16UI, _d[FORMATS.RED_INTEGER] = gl.R16UI, _d[FORMATS.DEPTH_COMPONENT] = gl.DEPTH_COMPONENT16, _d), _a2[TYPES.SHORT] = (_e = {}, _e[FORMATS.RGBA_INTEGER] = gl.RGBA16I, _e[FORMATS.RGB_INTEGER] = gl.RGB16I, _e[FORMATS.RG_INTEGER] = gl.RG16I, _e[FORMATS.RED_INTEGER] = gl.R16I, _e), _a2[TYPES.UNSIGNED_INT] = (_f = {}, _f[FORMATS.RGBA_INTEGER] = gl.RGBA32UI, _f[FORMATS.RGB_INTEGER] = gl.RGB32UI, _f[FORMATS.RG_INTEGER] = gl.RG32UI, _f[FORMATS.RED_INTEGER] = gl.R32UI, _f[FORMATS.DEPTH_COMPONENT] = gl.DEPTH_COMPONENT24, _f), _a2[TYPES.INT] = (_g = {}, _g[FORMATS.RGBA_INTEGER] = gl.RGBA32I, _g[FORMATS.RGB_INTEGER] = gl.RGB32I, _g[FORMATS.RG_INTEGER] = gl.RG32I, _g[FORMATS.RED_INTEGER] = gl.R32I, _g), _a2[TYPES.FLOAT] = (_h = {}, _h[FORMATS.RGBA] = gl.RGBA32F, _h[FORMATS.RGB] = gl.RGB32F, _h[FORMATS.RG] = gl.RG32F, _h[FORMATS.RED] = gl.R32F, _h[FORMATS.DEPTH_COMPONENT] = gl.DEPTH_COMPONENT32F, _h), _a2[TYPES.HALF_FLOAT] = (_j = {}, _j[FORMATS.RGBA] = gl.RGBA16F, _j[FORMATS.RGB] = gl.RGB16F, _j[FORMATS.RG] = gl.RG16F, _j[FORMATS.RED] = gl.R16F, _j), _a2[TYPES.UNSIGNED_SHORT_5_6_5] = (_k = {}, _k[FORMATS.RGB] = gl.RGB565, _k), _a2[TYPES.UNSIGNED_SHORT_4_4_4_4] = (_l = {}, _l[FORMATS.RGBA] = gl.RGBA4, _l), _a2[TYPES.UNSIGNED_SHORT_5_5_5_1] = (_m = {}, _m[FORMATS.RGBA] = gl.RGB5_A1, _m), _a2[TYPES.UNSIGNED_INT_2_10_10_10_REV] = (_o = {}, _o[FORMATS.RGBA] = gl.RGB10_A2, _o[FORMATS.RGBA_INTEGER] = gl.RGB10_A2UI, _o), _a2[TYPES.UNSIGNED_INT_10F_11F_11F_REV] = (_p = {}, _p[FORMATS.RGB] = gl.R11F_G11F_B10F, _p), _a2[TYPES.UNSIGNED_INT_5_9_9_9_REV] = (_q = {}, _q[FORMATS.RGB] = gl.RGB9_E5, _q), _a2[TYPES.UNSIGNED_INT_24_8] = (_r = {}, _r[FORMATS.DEPTH_STENCIL] = gl.DEPTH24_STENCIL8, _r), _a2[TYPES.FLOAT_32_UNSIGNED_INT_24_8_REV] = (_s = {}, _s[FORMATS.DEPTH_STENCIL] = gl.DEPTH32F_STENCIL8, _s), _a2);
    } else {
      table = (_t = {}, _t[TYPES.UNSIGNED_BYTE] = (_u = {}, _u[FORMATS.RGBA] = gl.RGBA, _u[FORMATS.RGB] = gl.RGB, _u[FORMATS.ALPHA] = gl.ALPHA, _u[FORMATS.LUMINANCE] = gl.LUMINANCE, _u[FORMATS.LUMINANCE_ALPHA] = gl.LUMINANCE_ALPHA, _u), _t[TYPES.UNSIGNED_SHORT_5_6_5] = (_v = {}, _v[FORMATS.RGB] = gl.RGB, _v), _t[TYPES.UNSIGNED_SHORT_4_4_4_4] = (_w = {}, _w[FORMATS.RGBA] = gl.RGBA, _w), _t[TYPES.UNSIGNED_SHORT_5_5_5_1] = (_x = {}, _x[FORMATS.RGBA] = gl.RGBA, _x), _t);
    }
    return table;
  }
  var GLTexture2 = (
    /** @class */
    function() {
      function GLTexture3(texture) {
        this.texture = texture;
        this.width = -1;
        this.height = -1;
        this.dirtyId = -1;
        this.dirtyStyleId = -1;
        this.mipmap = false;
        this.wrapMode = 33071;
        this.type = TYPES.UNSIGNED_BYTE;
        this.internalFormat = FORMATS.RGBA;
        this.samplerType = 0;
      }
      return GLTexture3;
    }()
  );
  var TextureSystem2 = (
    /** @class */
    function() {
      function TextureSystem3(renderer) {
        this.renderer = renderer;
        this.boundTextures = [];
        this.currentLocation = -1;
        this.managedTextures = [];
        this._unknownBoundTextures = false;
        this.unknownTexture = new BaseTexture2();
        this.hasIntegerTextures = false;
      }
      TextureSystem3.prototype.contextChange = function() {
        var gl = this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        this.webGLVersion = this.renderer.context.webGLVersion;
        this.internalFormats = mapTypeAndFormatToInternalFormat2(gl);
        var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        this.boundTextures.length = maxTextures;
        for (var i = 0; i < maxTextures; i++) {
          this.boundTextures[i] = null;
        }
        this.emptyTextures = {};
        var emptyTexture2D = new GLTexture2(gl.createTexture());
        gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));
        this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;
        this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture2(gl.createTexture());
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);
        for (var i = 0; i < 6; i++) {
          gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        }
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        for (var i = 0; i < this.boundTextures.length; i++) {
          this.bind(null, i);
        }
      };
      TextureSystem3.prototype.bind = function(texture, location) {
        if (location === void 0) {
          location = 0;
        }
        var gl = this.gl;
        texture = texture === null || texture === void 0 ? void 0 : texture.castToBaseTexture();
        if (texture && texture.valid && !texture.parentTextureArray) {
          texture.touched = this.renderer.textureGC.count;
          var glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);
          if (this.boundTextures[location] !== texture) {
            if (this.currentLocation !== location) {
              this.currentLocation = location;
              gl.activeTexture(gl.TEXTURE0 + location);
            }
            gl.bindTexture(texture.target, glTexture.texture);
          }
          if (glTexture.dirtyId !== texture.dirtyId) {
            if (this.currentLocation !== location) {
              this.currentLocation = location;
              gl.activeTexture(gl.TEXTURE0 + location);
            }
            this.updateTexture(texture);
          }
          this.boundTextures[location] = texture;
        } else {
          if (this.currentLocation !== location) {
            this.currentLocation = location;
            gl.activeTexture(gl.TEXTURE0 + location);
          }
          gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);
          this.boundTextures[location] = null;
        }
      };
      TextureSystem3.prototype.reset = function() {
        this._unknownBoundTextures = true;
        this.hasIntegerTextures = false;
        this.currentLocation = -1;
        for (var i = 0; i < this.boundTextures.length; i++) {
          this.boundTextures[i] = this.unknownTexture;
        }
      };
      TextureSystem3.prototype.unbind = function(texture) {
        var _a2 = this, gl = _a2.gl, boundTextures = _a2.boundTextures;
        if (this._unknownBoundTextures) {
          this._unknownBoundTextures = false;
          for (var i = 0; i < boundTextures.length; i++) {
            if (boundTextures[i] === this.unknownTexture) {
              this.bind(null, i);
            }
          }
        }
        for (var i = 0; i < boundTextures.length; i++) {
          if (boundTextures[i] === texture) {
            if (this.currentLocation !== i) {
              gl.activeTexture(gl.TEXTURE0 + i);
              this.currentLocation = i;
            }
            gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture);
            boundTextures[i] = null;
          }
        }
      };
      TextureSystem3.prototype.ensureSamplerType = function(maxTextures) {
        var _a2 = this, boundTextures = _a2.boundTextures, hasIntegerTextures = _a2.hasIntegerTextures, CONTEXT_UID = _a2.CONTEXT_UID;
        if (!hasIntegerTextures) {
          return;
        }
        for (var i = maxTextures - 1; i >= 0; --i) {
          var tex = boundTextures[i];
          if (tex) {
            var glTexture = tex._glTextures[CONTEXT_UID];
            if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT) {
              this.renderer.texture.unbind(tex);
            }
          }
        }
      };
      TextureSystem3.prototype.initTexture = function(texture) {
        var glTexture = new GLTexture2(this.gl.createTexture());
        glTexture.dirtyId = -1;
        texture._glTextures[this.CONTEXT_UID] = glTexture;
        this.managedTextures.push(texture);
        texture.on("dispose", this.destroyTexture, this);
        return glTexture;
      };
      TextureSystem3.prototype.initTextureType = function(texture, glTexture) {
        var _a2, _b;
        glTexture.internalFormat = (_b = (_a2 = this.internalFormats[texture.type]) === null || _a2 === void 0 ? void 0 : _a2[texture.format]) !== null && _b !== void 0 ? _b : texture.format;
        if (this.webGLVersion === 2 && texture.type === TYPES.HALF_FLOAT) {
          glTexture.type = this.gl.HALF_FLOAT;
        } else {
          glTexture.type = texture.type;
        }
      };
      TextureSystem3.prototype.updateTexture = function(texture) {
        var glTexture = texture._glTextures[this.CONTEXT_UID];
        if (!glTexture) {
          return;
        }
        var renderer = this.renderer;
        this.initTextureType(texture, glTexture);
        if (texture.resource && texture.resource.upload(renderer, texture, glTexture)) {
          if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT) {
            this.hasIntegerTextures = true;
          }
        } else {
          var width = texture.realWidth;
          var height = texture.realHeight;
          var gl = renderer.gl;
          if (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) {
            glTexture.width = width;
            glTexture.height = height;
            gl.texImage2D(texture.target, 0, glTexture.internalFormat, width, height, 0, texture.format, glTexture.type, null);
          }
        }
        if (texture.dirtyStyleId !== glTexture.dirtyStyleId) {
          this.updateTextureStyle(texture);
        }
        glTexture.dirtyId = texture.dirtyId;
      };
      TextureSystem3.prototype.destroyTexture = function(texture, skipRemove) {
        var gl = this.gl;
        texture = texture.castToBaseTexture();
        if (texture._glTextures[this.CONTEXT_UID]) {
          this.unbind(texture);
          gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);
          texture.off("dispose", this.destroyTexture, this);
          delete texture._glTextures[this.CONTEXT_UID];
          if (!skipRemove) {
            var i = this.managedTextures.indexOf(texture);
            if (i !== -1) {
              removeItems2(this.managedTextures, i, 1);
            }
          }
        }
      };
      TextureSystem3.prototype.updateTextureStyle = function(texture) {
        var glTexture = texture._glTextures[this.CONTEXT_UID];
        if (!glTexture) {
          return;
        }
        if ((texture.mipmap === MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo) {
          glTexture.mipmap = false;
        } else {
          glTexture.mipmap = texture.mipmap >= 1;
        }
        if (this.webGLVersion !== 2 && !texture.isPowerOfTwo) {
          glTexture.wrapMode = WRAP_MODES.CLAMP;
        } else {
          glTexture.wrapMode = texture.wrapMode;
        }
        if (texture.resource && texture.resource.style(this.renderer, texture, glTexture))
          ;
        else {
          this.setStyle(texture, glTexture);
        }
        glTexture.dirtyStyleId = texture.dirtyStyleId;
      };
      TextureSystem3.prototype.setStyle = function(texture, glTexture) {
        var gl = this.gl;
        if (glTexture.mipmap && texture.mipmap !== MIPMAP_MODES.ON_MANUAL) {
          gl.generateMipmap(texture.target);
        }
        gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);
        gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);
        if (glTexture.mipmap) {
          gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
          var anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;
          if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === SCALE_MODES.LINEAR) {
            var level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
            gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
          }
        } else {
          gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
        }
        gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
      };
      TextureSystem3.prototype.destroy = function() {
        this.renderer = null;
      };
      return TextureSystem3;
    }()
  );
  var _systems2 = {
    __proto__: null,
    FilterSystem: FilterSystem2,
    BatchSystem: BatchSystem2,
    ContextSystem: ContextSystem2,
    FramebufferSystem: FramebufferSystem2,
    GeometrySystem: GeometrySystem2,
    MaskSystem: MaskSystem2,
    ScissorSystem: ScissorSystem2,
    StencilSystem: StencilSystem2,
    ProjectionSystem: ProjectionSystem2,
    RenderTextureSystem: RenderTextureSystem2,
    ShaderSystem: ShaderSystem2,
    StateSystem: StateSystem2,
    TextureGCSystem: TextureGCSystem2,
    TextureSystem: TextureSystem2
  };
  var tempMatrix4 = new Matrix2();
  var AbstractRenderer2 = (
    /** @class */
    function(_super) {
      __extends12(AbstractRenderer3, _super);
      function AbstractRenderer3(type, options) {
        if (type === void 0) {
          type = RENDERER_TYPE.UNKNOWN;
        }
        var _this = _super.call(this) || this;
        options = Object.assign({}, settings.RENDER_OPTIONS, options);
        _this.options = options;
        _this.type = type;
        _this.screen = new Rectangle2(0, 0, options.width, options.height);
        _this.view = options.view || document.createElement("canvas");
        _this.resolution = options.resolution || settings.RESOLUTION;
        _this.useContextAlpha = options.useContextAlpha;
        _this.autoDensity = !!options.autoDensity;
        _this.preserveDrawingBuffer = options.preserveDrawingBuffer;
        _this.clearBeforeRender = options.clearBeforeRender;
        _this._backgroundColor = 0;
        _this._backgroundColorRgba = [0, 0, 0, 1];
        _this._backgroundColorString = "#000000";
        _this.backgroundColor = options.backgroundColor || _this._backgroundColor;
        _this.backgroundAlpha = options.backgroundAlpha;
        if (options.transparent !== void 0) {
          deprecation2("6.0.0", "Option transparent is deprecated, please use backgroundAlpha instead.");
          _this.useContextAlpha = options.transparent;
          _this.backgroundAlpha = options.transparent ? 0 : 1;
        }
        _this._lastObjectRendered = null;
        _this.plugins = {};
        return _this;
      }
      AbstractRenderer3.prototype.initPlugins = function(staticMap) {
        for (var o in staticMap) {
          this.plugins[o] = new staticMap[o](this);
        }
      };
      Object.defineProperty(AbstractRenderer3.prototype, "width", {
        /**
         * Same as view.width, actual number of pixels in the canvas by horizontal.
         * @member {number}
         * @readonly
         * @default 800
         */
        get: function() {
          return this.view.width;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractRenderer3.prototype, "height", {
        /**
         * Same as view.height, actual number of pixels in the canvas by vertical.
         * @member {number}
         * @readonly
         * @default 600
         */
        get: function() {
          return this.view.height;
        },
        enumerable: false,
        configurable: true
      });
      AbstractRenderer3.prototype.resize = function(desiredScreenWidth, desiredScreenHeight) {
        this.view.width = Math.round(desiredScreenWidth * this.resolution);
        this.view.height = Math.round(desiredScreenHeight * this.resolution);
        var screenWidth = this.view.width / this.resolution;
        var screenHeight = this.view.height / this.resolution;
        this.screen.width = screenWidth;
        this.screen.height = screenHeight;
        if (this.autoDensity) {
          this.view.style.width = screenWidth + "px";
          this.view.style.height = screenHeight + "px";
        }
        this.emit("resize", screenWidth, screenHeight);
      };
      AbstractRenderer3.prototype.generateTexture = function(displayObject, options, resolution, region) {
        if (options === void 0) {
          options = {};
        }
        if (typeof options === "number") {
          deprecation2("6.1.0", "generateTexture options (scaleMode, resolution, region) are now object options.");
          options = { scaleMode: options, resolution, region };
        }
        var manualRegion = options.region, textureOptions = __rest2(options, ["region"]);
        region = manualRegion || displayObject.getLocalBounds(null, true);
        if (region.width === 0) {
          region.width = 1;
        }
        if (region.height === 0) {
          region.height = 1;
        }
        var renderTexture = RenderTexture2.create(__assign2({ width: region.width, height: region.height }, textureOptions));
        tempMatrix4.tx = -region.x;
        tempMatrix4.ty = -region.y;
        this.render(displayObject, {
          renderTexture,
          clear: false,
          transform: tempMatrix4,
          skipUpdateTransform: !!displayObject.parent
        });
        return renderTexture;
      };
      AbstractRenderer3.prototype.destroy = function(removeView) {
        for (var o in this.plugins) {
          this.plugins[o].destroy();
          this.plugins[o] = null;
        }
        if (removeView && this.view.parentNode) {
          this.view.parentNode.removeChild(this.view);
        }
        var thisAny = this;
        thisAny.plugins = null;
        thisAny.type = RENDERER_TYPE.UNKNOWN;
        thisAny.view = null;
        thisAny.screen = null;
        thisAny._tempDisplayObjectParent = null;
        thisAny.options = null;
        this._backgroundColorRgba = null;
        this._backgroundColorString = null;
        this._lastObjectRendered = null;
      };
      Object.defineProperty(AbstractRenderer3.prototype, "backgroundColor", {
        /**
         * The background color to fill if not transparent
         * @member {number}
         */
        get: function() {
          return this._backgroundColor;
        },
        set: function(value) {
          this._backgroundColor = value;
          this._backgroundColorString = hex2string2(value);
          hex2rgb2(value, this._backgroundColorRgba);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractRenderer3.prototype, "backgroundAlpha", {
        /**
         * The background color alpha. Setting this to 0 will make the canvas transparent.
         * @member {number}
         */
        get: function() {
          return this._backgroundColorRgba[3];
        },
        set: function(value) {
          this._backgroundColorRgba[3] = value;
        },
        enumerable: false,
        configurable: true
      });
      return AbstractRenderer3;
    }(eventemitter3)
  );
  var GLBuffer2 = (
    /** @class */
    function() {
      function GLBuffer3(buffer) {
        this.buffer = buffer || null;
        this.updateID = -1;
        this.byteLength = -1;
        this.refCount = 0;
      }
      return GLBuffer3;
    }()
  );
  var BufferSystem2 = (
    /** @class */
    function() {
      function BufferSystem3(renderer) {
        this.renderer = renderer;
        this.managedBuffers = {};
        this.boundBufferBases = {};
      }
      BufferSystem3.prototype.destroy = function() {
        this.renderer = null;
      };
      BufferSystem3.prototype.contextChange = function() {
        this.disposeAll(true);
        this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID;
      };
      BufferSystem3.prototype.bind = function(buffer) {
        var _a2 = this, gl = _a2.gl, CONTEXT_UID = _a2.CONTEXT_UID;
        var glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
        gl.bindBuffer(buffer.type, glBuffer.buffer);
      };
      BufferSystem3.prototype.bindBufferBase = function(buffer, index) {
        var _a2 = this, gl = _a2.gl, CONTEXT_UID = _a2.CONTEXT_UID;
        if (this.boundBufferBases[index] !== buffer) {
          var glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
          this.boundBufferBases[index] = buffer;
          gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);
        }
      };
      BufferSystem3.prototype.bindBufferRange = function(buffer, index, offset) {
        var _a2 = this, gl = _a2.gl, CONTEXT_UID = _a2.CONTEXT_UID;
        offset = offset || 0;
        var glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
        gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);
      };
      BufferSystem3.prototype.update = function(buffer) {
        var _a2 = this, gl = _a2.gl, CONTEXT_UID = _a2.CONTEXT_UID;
        var glBuffer = buffer._glBuffers[CONTEXT_UID];
        if (buffer._updateID === glBuffer.updateID) {
          return;
        }
        glBuffer.updateID = buffer._updateID;
        gl.bindBuffer(buffer.type, glBuffer.buffer);
        if (glBuffer.byteLength >= buffer.data.byteLength) {
          gl.bufferSubData(buffer.type, 0, buffer.data);
        } else {
          var drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
          glBuffer.byteLength = buffer.data.byteLength;
          gl.bufferData(buffer.type, buffer.data, drawType);
        }
      };
      BufferSystem3.prototype.dispose = function(buffer, contextLost) {
        if (!this.managedBuffers[buffer.id]) {
          return;
        }
        delete this.managedBuffers[buffer.id];
        var glBuffer = buffer._glBuffers[this.CONTEXT_UID];
        var gl = this.gl;
        buffer.disposeRunner.remove(this);
        if (!glBuffer) {
          return;
        }
        if (!contextLost) {
          gl.deleteBuffer(glBuffer.buffer);
        }
        delete buffer._glBuffers[this.CONTEXT_UID];
      };
      BufferSystem3.prototype.disposeAll = function(contextLost) {
        var all = Object.keys(this.managedBuffers);
        for (var i = 0; i < all.length; i++) {
          this.dispose(this.managedBuffers[all[i]], contextLost);
        }
      };
      BufferSystem3.prototype.createGLBuffer = function(buffer) {
        var _a2 = this, CONTEXT_UID = _a2.CONTEXT_UID, gl = _a2.gl;
        buffer._glBuffers[CONTEXT_UID] = new GLBuffer2(gl.createBuffer());
        this.managedBuffers[buffer.id] = buffer;
        buffer.disposeRunner.add(this);
        return buffer._glBuffers[CONTEXT_UID];
      };
      return BufferSystem3;
    }()
  );
  (function(_super) {
    __extends12(Renderer2, _super);
    function Renderer2(options) {
      var _this = _super.call(this, RENDERER_TYPE.WEBGL, options) || this;
      options = _this.options;
      _this.gl = null;
      _this.CONTEXT_UID = 0;
      _this.runners = {
        destroy: new Runner2("destroy"),
        contextChange: new Runner2("contextChange"),
        reset: new Runner2("reset"),
        update: new Runner2("update"),
        postrender: new Runner2("postrender"),
        prerender: new Runner2("prerender"),
        resize: new Runner2("resize")
      };
      _this.runners.contextChange.add(_this);
      _this.globalUniforms = new UniformGroup2({
        projectionMatrix: new Matrix2()
      }, true);
      _this.addSystem(MaskSystem2, "mask").addSystem(ContextSystem2, "context").addSystem(StateSystem2, "state").addSystem(ShaderSystem2, "shader").addSystem(TextureSystem2, "texture").addSystem(BufferSystem2, "buffer").addSystem(GeometrySystem2, "geometry").addSystem(FramebufferSystem2, "framebuffer").addSystem(ScissorSystem2, "scissor").addSystem(StencilSystem2, "stencil").addSystem(ProjectionSystem2, "projection").addSystem(TextureGCSystem2, "textureGC").addSystem(FilterSystem2, "filter").addSystem(RenderTextureSystem2, "renderTexture").addSystem(BatchSystem2, "batch");
      _this.initPlugins(Renderer2.__plugins);
      _this.multisample = void 0;
      if (options.context) {
        _this.context.initFromContext(options.context);
      } else {
        _this.context.initFromOptions({
          alpha: !!_this.useContextAlpha,
          antialias: options.antialias,
          premultipliedAlpha: _this.useContextAlpha && _this.useContextAlpha !== "notMultiplied",
          stencil: true,
          preserveDrawingBuffer: options.preserveDrawingBuffer,
          powerPreference: _this.options.powerPreference
        });
      }
      _this.renderingToScreen = true;
      sayHello2(_this.context.webGLVersion === 2 ? "WebGL 2" : "WebGL 1");
      _this.resize(_this.options.width, _this.options.height);
      return _this;
    }
    Renderer2.create = function(options) {
      if (isWebGLSupported2()) {
        return new Renderer2(options);
      }
      throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.');
    };
    Renderer2.prototype.contextChange = function() {
      var gl = this.gl;
      var samples;
      if (this.context.webGLVersion === 1) {
        var framebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        samples = gl.getParameter(gl.SAMPLES);
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      } else {
        var framebuffer = gl.getParameter(gl.DRAW_FRAMEBUFFER_BINDING);
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
        samples = gl.getParameter(gl.SAMPLES);
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, framebuffer);
      }
      if (samples >= MSAA_QUALITY.HIGH) {
        this.multisample = MSAA_QUALITY.HIGH;
      } else if (samples >= MSAA_QUALITY.MEDIUM) {
        this.multisample = MSAA_QUALITY.MEDIUM;
      } else if (samples >= MSAA_QUALITY.LOW) {
        this.multisample = MSAA_QUALITY.LOW;
      } else {
        this.multisample = MSAA_QUALITY.NONE;
      }
    };
    Renderer2.prototype.addSystem = function(ClassRef, name) {
      var system = new ClassRef(this);
      if (this[name]) {
        throw new Error('Whoops! The name "' + name + '" is already in use');
      }
      this[name] = system;
      for (var i in this.runners) {
        this.runners[i].add(system);
      }
      return this;
    };
    Renderer2.prototype.render = function(displayObject, options) {
      var renderTexture;
      var clear;
      var transform;
      var skipUpdateTransform;
      if (options) {
        if (options instanceof RenderTexture2) {
          deprecation2("6.0.0", "Renderer#render arguments changed, use options instead.");
          renderTexture = options;
          clear = arguments[2];
          transform = arguments[3];
          skipUpdateTransform = arguments[4];
        } else {
          renderTexture = options.renderTexture;
          clear = options.clear;
          transform = options.transform;
          skipUpdateTransform = options.skipUpdateTransform;
        }
      }
      this.renderingToScreen = !renderTexture;
      this.runners.prerender.emit();
      this.emit("prerender");
      this.projection.transform = transform;
      if (this.context.isLost) {
        return;
      }
      if (!renderTexture) {
        this._lastObjectRendered = displayObject;
      }
      if (!skipUpdateTransform) {
        var cacheParent = displayObject.enableTempParent();
        displayObject.updateTransform();
        displayObject.disableTempParent(cacheParent);
      }
      this.renderTexture.bind(renderTexture);
      this.batch.currentRenderer.start();
      if (clear !== void 0 ? clear : this.clearBeforeRender) {
        this.renderTexture.clear();
      }
      displayObject.render(this);
      this.batch.currentRenderer.flush();
      if (renderTexture) {
        renderTexture.baseTexture.update();
      }
      this.runners.postrender.emit();
      this.projection.transform = null;
      this.emit("postrender");
    };
    Renderer2.prototype.generateTexture = function(displayObject, options, resolution, region) {
      if (options === void 0) {
        options = {};
      }
      var renderTexture = _super.prototype.generateTexture.call(this, displayObject, options, resolution, region);
      this.framebuffer.blit();
      return renderTexture;
    };
    Renderer2.prototype.resize = function(desiredScreenWidth, desiredScreenHeight) {
      _super.prototype.resize.call(this, desiredScreenWidth, desiredScreenHeight);
      this.runners.resize.emit(this.screen.height, this.screen.width);
    };
    Renderer2.prototype.reset = function() {
      this.runners.reset.emit();
      return this;
    };
    Renderer2.prototype.clear = function() {
      this.renderTexture.bind();
      this.renderTexture.clear();
    };
    Renderer2.prototype.destroy = function(removeView) {
      this.runners.destroy.emit();
      for (var r in this.runners) {
        this.runners[r].destroy();
      }
      _super.prototype.destroy.call(this, removeView);
      this.gl = null;
    };
    Object.defineProperty(Renderer2.prototype, "extract", {
      /**
       * Please use `plugins.extract` instead.
       * @member {PIXI.Extract} extract
       * @deprecated since 6.0.0
       * @readonly
       */
      get: function() {
        deprecation2("6.0.0", "Renderer#extract has been deprecated, please use Renderer#plugins.extract instead.");
        return this.plugins.extract;
      },
      enumerable: false,
      configurable: true
    });
    Renderer2.registerPlugin = function(pluginName, ctor) {
      Renderer2.__plugins = Renderer2.__plugins || {};
      Renderer2.__plugins[pluginName] = ctor;
    };
    return Renderer2;
  })(AbstractRenderer2);
  var BatchDrawCall2 = (
    /** @class */
    function() {
      function BatchDrawCall3() {
        this.texArray = null;
        this.blend = 0;
        this.type = DRAW_MODES.TRIANGLES;
        this.start = 0;
        this.size = 0;
        this.data = null;
      }
      return BatchDrawCall3;
    }()
  );
  var BatchTextureArray2 = (
    /** @class */
    function() {
      function BatchTextureArray3() {
        this.elements = [];
        this.ids = [];
        this.count = 0;
      }
      BatchTextureArray3.prototype.clear = function() {
        for (var i = 0; i < this.count; i++) {
          this.elements[i] = null;
        }
        this.count = 0;
      };
      return BatchTextureArray3;
    }()
  );
  var ViewableBuffer2 = (
    /** @class */
    function() {
      function ViewableBuffer3(sizeOrBuffer) {
        if (typeof sizeOrBuffer === "number") {
          this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
        } else if (sizeOrBuffer instanceof Uint8Array) {
          this.rawBinaryData = sizeOrBuffer.buffer;
        } else {
          this.rawBinaryData = sizeOrBuffer;
        }
        this.uint32View = new Uint32Array(this.rawBinaryData);
        this.float32View = new Float32Array(this.rawBinaryData);
      }
      Object.defineProperty(ViewableBuffer3.prototype, "int8View", {
        /** View on the raw binary data as a `Int8Array`. */
        get: function() {
          if (!this._int8View) {
            this._int8View = new Int8Array(this.rawBinaryData);
          }
          return this._int8View;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ViewableBuffer3.prototype, "uint8View", {
        /** View on the raw binary data as a `Uint8Array`. */
        get: function() {
          if (!this._uint8View) {
            this._uint8View = new Uint8Array(this.rawBinaryData);
          }
          return this._uint8View;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ViewableBuffer3.prototype, "int16View", {
        /**  View on the raw binary data as a `Int16Array`. */
        get: function() {
          if (!this._int16View) {
            this._int16View = new Int16Array(this.rawBinaryData);
          }
          return this._int16View;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ViewableBuffer3.prototype, "uint16View", {
        /** View on the raw binary data as a `Uint16Array`. */
        get: function() {
          if (!this._uint16View) {
            this._uint16View = new Uint16Array(this.rawBinaryData);
          }
          return this._uint16View;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ViewableBuffer3.prototype, "int32View", {
        /** View on the raw binary data as a `Int32Array`. */
        get: function() {
          if (!this._int32View) {
            this._int32View = new Int32Array(this.rawBinaryData);
          }
          return this._int32View;
        },
        enumerable: false,
        configurable: true
      });
      ViewableBuffer3.prototype.view = function(type) {
        return this[type + "View"];
      };
      ViewableBuffer3.prototype.destroy = function() {
        this.rawBinaryData = null;
        this._int8View = null;
        this._uint8View = null;
        this._int16View = null;
        this._uint16View = null;
        this._int32View = null;
        this.uint32View = null;
        this.float32View = null;
      };
      ViewableBuffer3.sizeOf = function(type) {
        switch (type) {
          case "int8":
          case "uint8":
            return 1;
          case "int16":
          case "uint16":
            return 2;
          case "int32":
          case "uint32":
          case "float32":
            return 4;
          default:
            throw new Error(type + " isn't a valid view type");
        }
      };
      return ViewableBuffer3;
    }()
  );
  var AbstractBatchRenderer2 = (
    /** @class */
    function(_super) {
      __extends12(AbstractBatchRenderer3, _super);
      function AbstractBatchRenderer3(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.shaderGenerator = null;
        _this.geometryClass = null;
        _this.vertexSize = null;
        _this.state = State2.for2d();
        _this.size = settings.SPRITE_BATCH_SIZE * 4;
        _this._vertexCount = 0;
        _this._indexCount = 0;
        _this._bufferedElements = [];
        _this._bufferedTextures = [];
        _this._bufferSize = 0;
        _this._shader = null;
        _this._packedGeometries = [];
        _this._packedGeometryPoolSize = 2;
        _this._flushId = 0;
        _this._aBuffers = {};
        _this._iBuffers = {};
        _this.MAX_TEXTURES = 1;
        _this.renderer.on("prerender", _this.onPrerender, _this);
        renderer.runners.contextChange.add(_this);
        _this._dcIndex = 0;
        _this._aIndex = 0;
        _this._iIndex = 0;
        _this._attributeBuffer = null;
        _this._indexBuffer = null;
        _this._tempBoundTextures = [];
        return _this;
      }
      AbstractBatchRenderer3.prototype.contextChange = function() {
        var gl = this.renderer.gl;
        if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {
          this.MAX_TEXTURES = 1;
        } else {
          this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), settings.SPRITE_MAX_TEXTURES);
          this.MAX_TEXTURES = checkMaxIfStatementsInShader2(this.MAX_TEXTURES, gl);
        }
        this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);
        for (var i = 0; i < this._packedGeometryPoolSize; i++) {
          this._packedGeometries[i] = new this.geometryClass();
        }
        this.initFlushBuffers();
      };
      AbstractBatchRenderer3.prototype.initFlushBuffers = function() {
        var _drawCallPool = AbstractBatchRenderer3._drawCallPool, _textureArrayPool = AbstractBatchRenderer3._textureArrayPool;
        var MAX_SPRITES = this.size / 4;
        var MAX_TA = Math.floor(MAX_SPRITES / this.MAX_TEXTURES) + 1;
        while (_drawCallPool.length < MAX_SPRITES) {
          _drawCallPool.push(new BatchDrawCall2());
        }
        while (_textureArrayPool.length < MAX_TA) {
          _textureArrayPool.push(new BatchTextureArray2());
        }
        for (var i = 0; i < this.MAX_TEXTURES; i++) {
          this._tempBoundTextures[i] = null;
        }
      };
      AbstractBatchRenderer3.prototype.onPrerender = function() {
        this._flushId = 0;
      };
      AbstractBatchRenderer3.prototype.render = function(element) {
        if (!element._texture.valid) {
          return;
        }
        if (this._vertexCount + element.vertexData.length / 2 > this.size) {
          this.flush();
        }
        this._vertexCount += element.vertexData.length / 2;
        this._indexCount += element.indices.length;
        this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;
        this._bufferedElements[this._bufferSize++] = element;
      };
      AbstractBatchRenderer3.prototype.buildTexturesAndDrawCalls = function() {
        var _a2 = this, textures = _a2._bufferedTextures, MAX_TEXTURES = _a2.MAX_TEXTURES;
        var textureArrays = AbstractBatchRenderer3._textureArrayPool;
        var batch = this.renderer.batch;
        var boundTextures = this._tempBoundTextures;
        var touch = this.renderer.textureGC.count;
        var TICK = ++BaseTexture2._globalBatch;
        var countTexArrays = 0;
        var texArray = textureArrays[0];
        var start = 0;
        batch.copyBoundTextures(boundTextures, MAX_TEXTURES);
        for (var i = 0; i < this._bufferSize; ++i) {
          var tex = textures[i];
          textures[i] = null;
          if (tex._batchEnabled === TICK) {
            continue;
          }
          if (texArray.count >= MAX_TEXTURES) {
            batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);
            this.buildDrawCalls(texArray, start, i);
            start = i;
            texArray = textureArrays[++countTexArrays];
            ++TICK;
          }
          tex._batchEnabled = TICK;
          tex.touched = touch;
          texArray.elements[texArray.count++] = tex;
        }
        if (texArray.count > 0) {
          batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);
          this.buildDrawCalls(texArray, start, this._bufferSize);
          ++countTexArrays;
          ++TICK;
        }
        for (var i = 0; i < boundTextures.length; i++) {
          boundTextures[i] = null;
        }
        BaseTexture2._globalBatch = TICK;
      };
      AbstractBatchRenderer3.prototype.buildDrawCalls = function(texArray, start, finish) {
        var _a2 = this, elements = _a2._bufferedElements, _attributeBuffer = _a2._attributeBuffer, _indexBuffer = _a2._indexBuffer, vertexSize = _a2.vertexSize;
        var drawCalls = AbstractBatchRenderer3._drawCallPool;
        var dcIndex = this._dcIndex;
        var aIndex = this._aIndex;
        var iIndex = this._iIndex;
        var drawCall = drawCalls[dcIndex];
        drawCall.start = this._iIndex;
        drawCall.texArray = texArray;
        for (var i = start; i < finish; ++i) {
          var sprite = elements[i];
          var tex = sprite._texture.baseTexture;
          var spriteBlendMode = premultiplyBlendMode2[tex.alphaMode ? 1 : 0][sprite.blendMode];
          elements[i] = null;
          if (start < i && drawCall.blend !== spriteBlendMode) {
            drawCall.size = iIndex - drawCall.start;
            start = i;
            drawCall = drawCalls[++dcIndex];
            drawCall.texArray = texArray;
            drawCall.start = iIndex;
          }
          this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);
          aIndex += sprite.vertexData.length / 2 * vertexSize;
          iIndex += sprite.indices.length;
          drawCall.blend = spriteBlendMode;
        }
        if (start < finish) {
          drawCall.size = iIndex - drawCall.start;
          ++dcIndex;
        }
        this._dcIndex = dcIndex;
        this._aIndex = aIndex;
        this._iIndex = iIndex;
      };
      AbstractBatchRenderer3.prototype.bindAndClearTexArray = function(texArray) {
        var textureSystem = this.renderer.texture;
        for (var j = 0; j < texArray.count; j++) {
          textureSystem.bind(texArray.elements[j], texArray.ids[j]);
          texArray.elements[j] = null;
        }
        texArray.count = 0;
      };
      AbstractBatchRenderer3.prototype.updateGeometry = function() {
        var _a2 = this, packedGeometries = _a2._packedGeometries, attributeBuffer = _a2._attributeBuffer, indexBuffer = _a2._indexBuffer;
        if (!settings.CAN_UPLOAD_SAME_BUFFER) {
          if (this._packedGeometryPoolSize <= this._flushId) {
            this._packedGeometryPoolSize++;
            packedGeometries[this._flushId] = new this.geometryClass();
          }
          packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
          packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
          this.renderer.geometry.bind(packedGeometries[this._flushId]);
          this.renderer.geometry.updateBuffers();
          this._flushId++;
        } else {
          packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
          packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
          this.renderer.geometry.updateBuffers();
        }
      };
      AbstractBatchRenderer3.prototype.drawBatches = function() {
        var dcCount = this._dcIndex;
        var _a2 = this.renderer, gl = _a2.gl, stateSystem = _a2.state;
        var drawCalls = AbstractBatchRenderer3._drawCallPool;
        var curTexArray = null;
        for (var i = 0; i < dcCount; i++) {
          var _b = drawCalls[i], texArray = _b.texArray, type = _b.type, size = _b.size, start = _b.start, blend = _b.blend;
          if (curTexArray !== texArray) {
            curTexArray = texArray;
            this.bindAndClearTexArray(texArray);
          }
          this.state.blendMode = blend;
          stateSystem.set(this.state);
          gl.drawElements(type, size, gl.UNSIGNED_SHORT, start * 2);
        }
      };
      AbstractBatchRenderer3.prototype.flush = function() {
        if (this._vertexCount === 0) {
          return;
        }
        this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);
        this._indexBuffer = this.getIndexBuffer(this._indexCount);
        this._aIndex = 0;
        this._iIndex = 0;
        this._dcIndex = 0;
        this.buildTexturesAndDrawCalls();
        this.updateGeometry();
        this.drawBatches();
        this._bufferSize = 0;
        this._vertexCount = 0;
        this._indexCount = 0;
      };
      AbstractBatchRenderer3.prototype.start = function() {
        this.renderer.state.set(this.state);
        this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES);
        this.renderer.shader.bind(this._shader);
        if (settings.CAN_UPLOAD_SAME_BUFFER) {
          this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
        }
      };
      AbstractBatchRenderer3.prototype.stop = function() {
        this.flush();
      };
      AbstractBatchRenderer3.prototype.destroy = function() {
        for (var i = 0; i < this._packedGeometryPoolSize; i++) {
          if (this._packedGeometries[i]) {
            this._packedGeometries[i].destroy();
          }
        }
        this.renderer.off("prerender", this.onPrerender, this);
        this._aBuffers = null;
        this._iBuffers = null;
        this._packedGeometries = null;
        this._attributeBuffer = null;
        this._indexBuffer = null;
        if (this._shader) {
          this._shader.destroy();
          this._shader = null;
        }
        _super.prototype.destroy.call(this);
      };
      AbstractBatchRenderer3.prototype.getAttributeBuffer = function(size) {
        var roundedP2 = nextPow22(Math.ceil(size / 8));
        var roundedSizeIndex = log22(roundedP2);
        var roundedSize = roundedP2 * 8;
        if (this._aBuffers.length <= roundedSizeIndex) {
          this._iBuffers.length = roundedSizeIndex + 1;
        }
        var buffer = this._aBuffers[roundedSize];
        if (!buffer) {
          this._aBuffers[roundedSize] = buffer = new ViewableBuffer2(roundedSize * this.vertexSize * 4);
        }
        return buffer;
      };
      AbstractBatchRenderer3.prototype.getIndexBuffer = function(size) {
        var roundedP2 = nextPow22(Math.ceil(size / 12));
        var roundedSizeIndex = log22(roundedP2);
        var roundedSize = roundedP2 * 12;
        if (this._iBuffers.length <= roundedSizeIndex) {
          this._iBuffers.length = roundedSizeIndex + 1;
        }
        var buffer = this._iBuffers[roundedSizeIndex];
        if (!buffer) {
          this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);
        }
        return buffer;
      };
      AbstractBatchRenderer3.prototype.packInterleavedGeometry = function(element, attributeBuffer, indexBuffer, aIndex, iIndex) {
        var uint32View = attributeBuffer.uint32View, float32View = attributeBuffer.float32View;
        var packedVertices = aIndex / this.vertexSize;
        var uvs = element.uvs;
        var indicies = element.indices;
        var vertexData = element.vertexData;
        var textureId = element._texture.baseTexture._batchLocation;
        var alpha = Math.min(element.worldAlpha, 1);
        var argb = alpha < 1 && element._texture.baseTexture.alphaMode ? premultiplyTint2(element._tintRGB, alpha) : element._tintRGB + (alpha * 255 << 24);
        for (var i = 0; i < vertexData.length; i += 2) {
          float32View[aIndex++] = vertexData[i];
          float32View[aIndex++] = vertexData[i + 1];
          float32View[aIndex++] = uvs[i];
          float32View[aIndex++] = uvs[i + 1];
          uint32View[aIndex++] = argb;
          float32View[aIndex++] = textureId;
        }
        for (var i = 0; i < indicies.length; i++) {
          indexBuffer[iIndex++] = packedVertices + indicies[i];
        }
      };
      AbstractBatchRenderer3._drawCallPool = [];
      AbstractBatchRenderer3._textureArrayPool = [];
      return AbstractBatchRenderer3;
    }(ObjectRenderer2)
  );
  var BatchShaderGenerator2 = (
    /** @class */
    function() {
      function BatchShaderGenerator3(vertexSrc, fragTemplate3) {
        this.vertexSrc = vertexSrc;
        this.fragTemplate = fragTemplate3;
        this.programCache = {};
        this.defaultGroupCache = {};
        if (fragTemplate3.indexOf("%count%") < 0) {
          throw new Error('Fragment template must contain "%count%".');
        }
        if (fragTemplate3.indexOf("%forloop%") < 0) {
          throw new Error('Fragment template must contain "%forloop%".');
        }
      }
      BatchShaderGenerator3.prototype.generateShader = function(maxTextures) {
        if (!this.programCache[maxTextures]) {
          var sampleValues = new Int32Array(maxTextures);
          for (var i = 0; i < maxTextures; i++) {
            sampleValues[i] = i;
          }
          this.defaultGroupCache[maxTextures] = UniformGroup2.from({ uSamplers: sampleValues }, true);
          var fragmentSrc = this.fragTemplate;
          fragmentSrc = fragmentSrc.replace(/%count%/gi, "" + maxTextures);
          fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));
          this.programCache[maxTextures] = new Program2(this.vertexSrc, fragmentSrc);
        }
        var uniforms = {
          tint: new Float32Array([1, 1, 1, 1]),
          translationMatrix: new Matrix2(),
          default: this.defaultGroupCache[maxTextures]
        };
        return new Shader2(this.programCache[maxTextures], uniforms);
      };
      BatchShaderGenerator3.prototype.generateSampleSrc = function(maxTextures) {
        var src = "";
        src += "\n";
        src += "\n";
        for (var i = 0; i < maxTextures; i++) {
          if (i > 0) {
            src += "\nelse ";
          }
          if (i < maxTextures - 1) {
            src += "if(vTextureId < " + i + ".5)";
          }
          src += "\n{";
          src += "\n	color = texture2D(uSamplers[" + i + "], vTextureCoord);";
          src += "\n}";
        }
        src += "\n";
        src += "\n";
        return src;
      };
      return BatchShaderGenerator3;
    }()
  );
  var BatchGeometry2 = (
    /** @class */
    function(_super) {
      __extends12(BatchGeometry3, _super);
      function BatchGeometry3(_static) {
        if (_static === void 0) {
          _static = false;
        }
        var _this = _super.call(this) || this;
        _this._buffer = new Buffer3(null, _static, false);
        _this._indexBuffer = new Buffer3(null, _static, true);
        _this.addAttribute("aVertexPosition", _this._buffer, 2, false, TYPES.FLOAT).addAttribute("aTextureCoord", _this._buffer, 2, false, TYPES.FLOAT).addAttribute("aColor", _this._buffer, 4, true, TYPES.UNSIGNED_BYTE).addAttribute("aTextureId", _this._buffer, 1, true, TYPES.FLOAT).addIndex(_this._indexBuffer);
        return _this;
      }
      return BatchGeometry3;
    }(Geometry2)
  );
  var defaultVertex2 = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n";
  var defaultFragment2 = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n";
  var BatchPluginFactory2 = (
    /** @class */
    function() {
      function BatchPluginFactory3() {
      }
      BatchPluginFactory3.create = function(options) {
        var _a2 = Object.assign({
          vertex: defaultVertex2,
          fragment: defaultFragment2,
          geometryClass: BatchGeometry2,
          vertexSize: 6
        }, options), vertex6 = _a2.vertex, fragment8 = _a2.fragment, vertexSize = _a2.vertexSize, geometryClass = _a2.geometryClass;
        return (
          /** @class */
          function(_super) {
            __extends12(BatchPlugin, _super);
            function BatchPlugin(renderer) {
              var _this = _super.call(this, renderer) || this;
              _this.shaderGenerator = new BatchShaderGenerator2(vertex6, fragment8);
              _this.geometryClass = geometryClass;
              _this.vertexSize = vertexSize;
              return _this;
            }
            return BatchPlugin;
          }(AbstractBatchRenderer2)
        );
      };
      Object.defineProperty(BatchPluginFactory3, "defaultVertexSrc", {
        /**
         * The default vertex shader source
         * @readonly
         */
        get: function() {
          return defaultVertex2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BatchPluginFactory3, "defaultFragmentTemplate", {
        /**
         * The default fragment shader source
         * @readonly
         */
        get: function() {
          return defaultFragment2;
        },
        enumerable: false,
        configurable: true
      });
      return BatchPluginFactory3;
    }()
  );
  BatchPluginFactory2.create();
  var resources2 = {};
  var _loop_12 = function(name) {
    Object.defineProperty(resources2, name, {
      get: function() {
        deprecation2("6.0.0", "PIXI.systems." + name + " has moved to PIXI." + name);
        return _resources2[name];
      }
    });
  };
  for (name in _resources2) {
    _loop_12(name);
  }
  var name;
  var systems2 = {};
  var _loop_22 = function(name) {
    Object.defineProperty(systems2, name, {
      get: function() {
        deprecation2("6.0.0", "PIXI.resources." + name + " has moved to PIXI." + name);
        return _systems2[name];
      }
    });
  };
  for (name in _systems2) {
    _loop_22(name);
  }
  var name;
  var CanvasMeshRenderer = (
    /** @class */
    function() {
      function CanvasMeshRenderer2(renderer) {
        this.renderer = renderer;
      }
      CanvasMeshRenderer2.prototype.render = function(mesh) {
        var renderer = this.renderer;
        var transform = mesh.worldTransform;
        renderer.context.globalAlpha = mesh.worldAlpha;
        renderer.setBlendMode(mesh.blendMode);
        renderer.setContextTransform(transform, mesh.roundPixels);
        if (mesh.drawMode !== DRAW_MODES.TRIANGLES) {
          this._renderTriangleMesh(mesh);
        } else {
          this._renderTriangles(mesh);
        }
      };
      CanvasMeshRenderer2.prototype._renderTriangleMesh = function(mesh) {
        var length = mesh.geometry.buffers[0].data.length;
        for (var i = 0; i < length - 2; i++) {
          var index = i * 2;
          this._renderDrawTriangle(mesh, index, index + 2, index + 4);
        }
      };
      CanvasMeshRenderer2.prototype._renderTriangles = function(mesh) {
        var indices2 = mesh.geometry.getIndex().data;
        var length = indices2.length;
        for (var i = 0; i < length; i += 3) {
          var index0 = indices2[i] * 2;
          var index1 = indices2[i + 1] * 2;
          var index2 = indices2[i + 2] * 2;
          this._renderDrawTriangle(mesh, index0, index1, index2);
        }
      };
      CanvasMeshRenderer2.prototype._renderDrawTriangle = function(mesh, index0, index1, index2) {
        var context3 = this.renderer.context;
        var vertices = mesh.geometry.buffers[0].data;
        var uvs = mesh.uvs, texture = mesh.texture;
        if (!texture.valid) {
          return;
        }
        var isTinted = mesh.tint !== 16777215;
        var base = texture.baseTexture;
        var textureWidth = base.width;
        var textureHeight = base.height;
        if (isTinted) {
          if (mesh._cachedTint !== mesh.tint) {
            mesh._cachedTint = mesh.tint;
            mesh._cachedTexture = mesh._cachedTexture || new Texture2(base);
            mesh._tintedCanvas = canvasUtils.getTintedCanvas({ texture: mesh._cachedTexture }, mesh.tint);
          }
        }
        var textureSource = isTinted ? mesh._tintedCanvas : base.getDrawableSource();
        var u0 = uvs[index0] * base.width;
        var u1 = uvs[index1] * base.width;
        var u2 = uvs[index2] * base.width;
        var v0 = uvs[index0 + 1] * base.height;
        var v1 = uvs[index1 + 1] * base.height;
        var v2 = uvs[index2 + 1] * base.height;
        var x0 = vertices[index0];
        var x1 = vertices[index1];
        var x2 = vertices[index2];
        var y0 = vertices[index0 + 1];
        var y1 = vertices[index1 + 1];
        var y2 = vertices[index2 + 1];
        var screenPadding = mesh.canvasPadding / this.renderer.resolution;
        if (screenPadding > 0) {
          var _a2 = mesh.worldTransform, a = _a2.a, b = _a2.b, c = _a2.c, d = _a2.d;
          var centerX = (x0 + x1 + x2) / 3;
          var centerY = (y0 + y1 + y2) / 3;
          var normX = x0 - centerX;
          var normY = y0 - centerY;
          var screenX = a * normX + c * normY;
          var screenY = b * normX + d * normY;
          var screenDist = Math.sqrt(screenX * screenX + screenY * screenY);
          var paddingFactor = 1 + screenPadding / screenDist;
          x0 = centerX + normX * paddingFactor;
          y0 = centerY + normY * paddingFactor;
          normX = x1 - centerX;
          normY = y1 - centerY;
          screenX = a * normX + c * normY;
          screenY = b * normX + d * normY;
          screenDist = Math.sqrt(screenX * screenX + screenY * screenY);
          paddingFactor = 1 + screenPadding / screenDist;
          x1 = centerX + normX * paddingFactor;
          y1 = centerY + normY * paddingFactor;
          normX = x2 - centerX;
          normY = y2 - centerY;
          screenX = a * normX + c * normY;
          screenY = b * normX + d * normY;
          screenDist = Math.sqrt(screenX * screenX + screenY * screenY);
          paddingFactor = 1 + screenPadding / screenDist;
          x2 = centerX + normX * paddingFactor;
          y2 = centerY + normY * paddingFactor;
        }
        context3.save();
        context3.beginPath();
        context3.moveTo(x0, y0);
        context3.lineTo(x1, y1);
        context3.lineTo(x2, y2);
        context3.closePath();
        context3.clip();
        var delta = u0 * v1 + v0 * u2 + u1 * v2 - v1 * u2 - v0 * u1 - u0 * v2;
        var deltaA = x0 * v1 + v0 * x2 + x1 * v2 - v1 * x2 - v0 * x1 - x0 * v2;
        var deltaB = u0 * x1 + x0 * u2 + u1 * x2 - x1 * u2 - x0 * u1 - u0 * x2;
        var deltaC = u0 * v1 * x2 + v0 * x1 * u2 + x0 * u1 * v2 - x0 * v1 * u2 - v0 * u1 * x2 - u0 * x1 * v2;
        var deltaD = y0 * v1 + v0 * y2 + y1 * v2 - v1 * y2 - v0 * y1 - y0 * v2;
        var deltaE = u0 * y1 + y0 * u2 + u1 * y2 - y1 * u2 - y0 * u1 - u0 * y2;
        var deltaF = u0 * v1 * y2 + v0 * y1 * u2 + y0 * u1 * v2 - y0 * v1 * u2 - v0 * u1 * y2 - u0 * y1 * v2;
        context3.transform(deltaA / delta, deltaD / delta, deltaB / delta, deltaE / delta, deltaC / delta, deltaF / delta);
        context3.drawImage(textureSource, 0, 0, textureWidth * base.resolution, textureHeight * base.resolution, 0, 0, textureWidth, textureHeight);
        context3.restore();
        this.renderer.invalidateBlendMode();
      };
      CanvasMeshRenderer2.prototype.renderMeshFlat = function(mesh) {
        var context3 = this.renderer.context;
        var vertices = mesh.geometry.getBuffer("aVertexPosition").data;
        var length = vertices.length / 2;
        context3.beginPath();
        for (var i = 1; i < length - 2; ++i) {
          var index = i * 2;
          var x0 = vertices[index];
          var y0 = vertices[index + 1];
          var x1 = vertices[index + 2];
          var y1 = vertices[index + 3];
          var x2 = vertices[index + 4];
          var y2 = vertices[index + 5];
          context3.moveTo(x0, y0);
          context3.lineTo(x1, y1);
          context3.lineTo(x2, y2);
        }
        context3.fillStyle = "#FF0000";
        context3.fill();
        context3.closePath();
      };
      CanvasMeshRenderer2.prototype.destroy = function() {
        this.renderer = null;
      };
      return CanvasMeshRenderer2;
    }()
  );
  settings.MESH_CANVAS_PADDING = 0;
  MeshMaterial.prototype._renderCanvas = function _renderCanvas4(renderer, mesh) {
    renderer.plugins.mesh.render(mesh);
  };
  NineSlicePlane.prototype._cachedTint = 16777215;
  NineSlicePlane.prototype._tintedCanvas = null;
  NineSlicePlane.prototype._canvasUvs = null;
  NineSlicePlane.prototype._renderCanvas = function _renderCanvas5(renderer) {
    var context3 = renderer.context;
    var transform = this.worldTransform;
    var isTinted = this.tint !== 16777215;
    var texture = this.texture;
    if (!texture.valid) {
      return;
    }
    if (isTinted) {
      if (this._cachedTint !== this.tint) {
        this._cachedTint = this.tint;
        this._tintedCanvas = canvasUtils.getTintedCanvas(this, this.tint);
      }
    }
    var textureSource = !isTinted ? texture.baseTexture.getDrawableSource() : this._tintedCanvas;
    if (!this._canvasUvs) {
      this._canvasUvs = [0, 0, 0, 0, 0, 0, 0, 0];
    }
    var vertices = this.vertices;
    var uvs = this._canvasUvs;
    var u0 = isTinted ? 0 : texture.frame.x;
    var v0 = isTinted ? 0 : texture.frame.y;
    var u1 = u0 + texture.frame.width;
    var v1 = v0 + texture.frame.height;
    uvs[0] = u0;
    uvs[1] = u0 + this._leftWidth;
    uvs[2] = u1 - this._rightWidth;
    uvs[3] = u1;
    uvs[4] = v0;
    uvs[5] = v0 + this._topHeight;
    uvs[6] = v1 - this._bottomHeight;
    uvs[7] = v1;
    for (var i = 0; i < 8; i++) {
      uvs[i] *= texture.baseTexture.resolution;
    }
    context3.globalAlpha = this.worldAlpha;
    renderer.setBlendMode(this.blendMode);
    renderer.setContextTransform(transform, this.roundPixels);
    for (var row = 0; row < 3; row++) {
      for (var col = 0; col < 3; col++) {
        var ind = col * 2 + row * 8;
        var sw = Math.max(1, uvs[col + 1] - uvs[col]);
        var sh = Math.max(1, uvs[row + 5] - uvs[row + 4]);
        var dw = Math.max(1, vertices[ind + 10] - vertices[ind]);
        var dh = Math.max(1, vertices[ind + 11] - vertices[ind + 1]);
        context3.drawImage(textureSource, uvs[col], uvs[row + 4], sw, sh, vertices[ind], vertices[ind + 1], dw, dh);
      }
    }
  };
  var warned = false;
  Mesh.prototype._cachedTint = 16777215;
  Mesh.prototype._tintedCanvas = null;
  Mesh.prototype._cachedTexture = null;
  Mesh.prototype._renderCanvas = function _renderCanvas6(renderer) {
    if (this.shader.uvMatrix) {
      this.shader.uvMatrix.update();
      this.calculateUvs();
    }
    if (this.material._renderCanvas) {
      this.material._renderCanvas(renderer, this);
    } else if (!warned) {
      warned = true;
      if (globalThis.console) {
        console.warn("Mesh with custom shaders are not supported in CanvasRenderer.");
      }
    }
  };
  Mesh.prototype._canvasPadding = null;
  Object.defineProperty(Mesh.prototype, "canvasPadding", {
    get: function() {
      return this._canvasPadding !== null ? this._canvasPadding : settings.MESH_CANVAS_PADDING;
    },
    set: function(value) {
      this._canvasPadding = value;
    }
  });
  SimpleMesh.prototype._renderCanvas = function _renderCanvas7(renderer) {
    if (this.autoUpdate) {
      this.geometry.getBuffer("aVertexPosition").update();
    }
    if (this.shader.update) {
      this.shader.update();
    }
    this.calculateUvs();
    this.material._renderCanvas(renderer, this);
  };
  SimpleRope.prototype._renderCanvas = function _renderCanvas8(renderer) {
    if (this.autoUpdate || this.geometry._width !== this.shader.texture.height) {
      this.geometry._width = this.shader.texture.height;
      this.geometry.update();
    }
    if (this.shader.update) {
      this.shader.update();
    }
    this.calculateUvs();
    this.material._renderCanvas(renderer, this);
  };

  // node_modules/@pixi/canvas-sprite-tiling/dist/esm/canvas-sprite-tiling.js
  var worldMatrix = new Matrix();
  var patternMatrix = new Matrix();
  var patternRect = [new Point(), new Point(), new Point(), new Point()];
  TilingSprite.prototype._renderCanvas = function _renderCanvas9(renderer) {
    var texture = this._texture;
    if (!texture.baseTexture.valid) {
      return;
    }
    var context3 = renderer.context;
    var transform = this.worldTransform;
    var baseTexture = texture.baseTexture;
    var source = baseTexture.getDrawableSource();
    var baseTextureResolution = baseTexture.resolution;
    if (this._textureID !== this._texture._updateID || this._cachedTint !== this.tint) {
      this._textureID = this._texture._updateID;
      var tempCanvas = new CanvasRenderTarget(texture._frame.width, texture._frame.height, baseTextureResolution);
      if (this.tint !== 16777215) {
        this._tintedCanvas = canvasUtils.getTintedCanvas(this, this.tint);
        tempCanvas.context.drawImage(this._tintedCanvas, 0, 0);
      } else {
        tempCanvas.context.drawImage(source, -texture._frame.x * baseTextureResolution, -texture._frame.y * baseTextureResolution);
      }
      this._cachedTint = this.tint;
      this._canvasPattern = tempCanvas.context.createPattern(tempCanvas.canvas, "repeat");
    }
    context3.globalAlpha = this.worldAlpha;
    renderer.setBlendMode(this.blendMode);
    this.tileTransform.updateLocalTransform();
    var lt = this.tileTransform.localTransform;
    var W = this._width;
    var H = this._height;
    worldMatrix.identity();
    patternMatrix.copyFrom(lt);
    if (!this.uvRespectAnchor) {
      patternMatrix.translate(-this.anchor.x * W, -this.anchor.y * H);
    }
    patternMatrix.scale(this.tileScale.x / baseTextureResolution, this.tileScale.y / baseTextureResolution);
    worldMatrix.prepend(patternMatrix);
    worldMatrix.prepend(transform);
    renderer.setContextTransform(worldMatrix);
    context3.fillStyle = this._canvasPattern;
    var lx = this.anchor.x * -W;
    var ly = this.anchor.y * -H;
    patternRect[0].set(lx, ly);
    patternRect[1].set(lx + W, ly);
    patternRect[2].set(lx + W, ly + H);
    patternRect[3].set(lx, ly + H);
    for (var i = 0; i < 4; i++) {
      patternMatrix.applyInverse(patternRect[i], patternRect[i]);
    }
    context3.beginPath();
    context3.moveTo(patternRect[0].x, patternRect[0].y);
    for (var i = 1; i < 4; i++) {
      context3.lineTo(patternRect[i].x, patternRect[i].y);
    }
    context3.closePath();
    context3.fill();
  };

  // node_modules/@pixi/filter-alpha/dist/esm/filter-alpha.js
  var extendStatics13 = function(d, b) {
    extendStatics13 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) {
        if (b2.hasOwnProperty(p)) {
          d2[p] = b2[p];
        }
      }
    };
    return extendStatics13(d, b);
  };
  function __extends13(d, b) {
    extendStatics13(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var fragment4 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n";
  var AlphaFilter = (
    /** @class */
    function(_super) {
      __extends13(AlphaFilter2, _super);
      function AlphaFilter2(alpha) {
        if (alpha === void 0) {
          alpha = 1;
        }
        var _this = _super.call(this, defaultVertex$1, fragment4, { uAlpha: 1 }) || this;
        _this.alpha = alpha;
        return _this;
      }
      Object.defineProperty(AlphaFilter2.prototype, "alpha", {
        /**
         * Coefficient for alpha multiplication
         * @default 1
         */
        get: function() {
          return this.uniforms.uAlpha;
        },
        set: function(value) {
          this.uniforms.uAlpha = value;
        },
        enumerable: false,
        configurable: true
      });
      return AlphaFilter2;
    }(Filter)
  );

  // node_modules/@pixi/filter-color-matrix/dist/esm/filter-color-matrix.js
  var extendStatics14 = function(d, b) {
    extendStatics14 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) {
        if (b2.hasOwnProperty(p)) {
          d2[p] = b2[p];
        }
      }
    };
    return extendStatics14(d, b);
  };
  function __extends14(d, b) {
    extendStatics14(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var fragment5 = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n";
  var ColorMatrixFilter = (
    /** @class */
    function(_super) {
      __extends14(ColorMatrixFilter2, _super);
      function ColorMatrixFilter2() {
        var _this = this;
        var uniforms = {
          m: new Float32Array([
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ]),
          uAlpha: 1
        };
        _this = _super.call(this, defaultFilterVertex, fragment5, uniforms) || this;
        _this.alpha = 1;
        return _this;
      }
      ColorMatrixFilter2.prototype._loadMatrix = function(matrix, multiply) {
        if (multiply === void 0) {
          multiply = false;
        }
        var newMatrix = matrix;
        if (multiply) {
          this._multiply(newMatrix, this.uniforms.m, matrix);
          newMatrix = this._colorMatrix(newMatrix);
        }
        this.uniforms.m = newMatrix;
      };
      ColorMatrixFilter2.prototype._multiply = function(out, a, b) {
        out[0] = a[0] * b[0] + a[1] * b[5] + a[2] * b[10] + a[3] * b[15];
        out[1] = a[0] * b[1] + a[1] * b[6] + a[2] * b[11] + a[3] * b[16];
        out[2] = a[0] * b[2] + a[1] * b[7] + a[2] * b[12] + a[3] * b[17];
        out[3] = a[0] * b[3] + a[1] * b[8] + a[2] * b[13] + a[3] * b[18];
        out[4] = a[0] * b[4] + a[1] * b[9] + a[2] * b[14] + a[3] * b[19] + a[4];
        out[5] = a[5] * b[0] + a[6] * b[5] + a[7] * b[10] + a[8] * b[15];
        out[6] = a[5] * b[1] + a[6] * b[6] + a[7] * b[11] + a[8] * b[16];
        out[7] = a[5] * b[2] + a[6] * b[7] + a[7] * b[12] + a[8] * b[17];
        out[8] = a[5] * b[3] + a[6] * b[8] + a[7] * b[13] + a[8] * b[18];
        out[9] = a[5] * b[4] + a[6] * b[9] + a[7] * b[14] + a[8] * b[19] + a[9];
        out[10] = a[10] * b[0] + a[11] * b[5] + a[12] * b[10] + a[13] * b[15];
        out[11] = a[10] * b[1] + a[11] * b[6] + a[12] * b[11] + a[13] * b[16];
        out[12] = a[10] * b[2] + a[11] * b[7] + a[12] * b[12] + a[13] * b[17];
        out[13] = a[10] * b[3] + a[11] * b[8] + a[12] * b[13] + a[13] * b[18];
        out[14] = a[10] * b[4] + a[11] * b[9] + a[12] * b[14] + a[13] * b[19] + a[14];
        out[15] = a[15] * b[0] + a[16] * b[5] + a[17] * b[10] + a[18] * b[15];
        out[16] = a[15] * b[1] + a[16] * b[6] + a[17] * b[11] + a[18] * b[16];
        out[17] = a[15] * b[2] + a[16] * b[7] + a[17] * b[12] + a[18] * b[17];
        out[18] = a[15] * b[3] + a[16] * b[8] + a[17] * b[13] + a[18] * b[18];
        out[19] = a[15] * b[4] + a[16] * b[9] + a[17] * b[14] + a[18] * b[19] + a[19];
        return out;
      };
      ColorMatrixFilter2.prototype._colorMatrix = function(matrix) {
        var m = new Float32Array(matrix);
        m[4] /= 255;
        m[9] /= 255;
        m[14] /= 255;
        m[19] /= 255;
        return m;
      };
      ColorMatrixFilter2.prototype.brightness = function(b, multiply) {
        var matrix = [
          b,
          0,
          0,
          0,
          0,
          0,
          b,
          0,
          0,
          0,
          0,
          0,
          b,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.tint = function(color, multiply) {
        var r = color >> 16 & 255;
        var g = color >> 8 & 255;
        var b = color & 255;
        var matrix = [
          r / 255,
          0,
          0,
          0,
          0,
          0,
          g / 255,
          0,
          0,
          0,
          0,
          0,
          b / 255,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.greyscale = function(scale, multiply) {
        var matrix = [
          scale,
          scale,
          scale,
          0,
          0,
          scale,
          scale,
          scale,
          0,
          0,
          scale,
          scale,
          scale,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.blackAndWhite = function(multiply) {
        var matrix = [
          0.3,
          0.6,
          0.1,
          0,
          0,
          0.3,
          0.6,
          0.1,
          0,
          0,
          0.3,
          0.6,
          0.1,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.hue = function(rotation, multiply) {
        rotation = (rotation || 0) / 180 * Math.PI;
        var cosR = Math.cos(rotation);
        var sinR = Math.sin(rotation);
        var sqrt = Math.sqrt;
        var w = 1 / 3;
        var sqrW = sqrt(w);
        var a00 = cosR + (1 - cosR) * w;
        var a01 = w * (1 - cosR) - sqrW * sinR;
        var a02 = w * (1 - cosR) + sqrW * sinR;
        var a10 = w * (1 - cosR) + sqrW * sinR;
        var a11 = cosR + w * (1 - cosR);
        var a12 = w * (1 - cosR) - sqrW * sinR;
        var a20 = w * (1 - cosR) - sqrW * sinR;
        var a21 = w * (1 - cosR) + sqrW * sinR;
        var a22 = cosR + w * (1 - cosR);
        var matrix = [
          a00,
          a01,
          a02,
          0,
          0,
          a10,
          a11,
          a12,
          0,
          0,
          a20,
          a21,
          a22,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.contrast = function(amount, multiply) {
        var v = (amount || 0) + 1;
        var o = -0.5 * (v - 1);
        var matrix = [
          v,
          0,
          0,
          0,
          o,
          0,
          v,
          0,
          0,
          o,
          0,
          0,
          v,
          0,
          o,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.saturate = function(amount, multiply) {
        if (amount === void 0) {
          amount = 0;
        }
        var x = amount * 2 / 3 + 1;
        var y = (x - 1) * -0.5;
        var matrix = [
          x,
          y,
          y,
          0,
          0,
          y,
          x,
          y,
          0,
          0,
          y,
          y,
          x,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.desaturate = function() {
        this.saturate(-1);
      };
      ColorMatrixFilter2.prototype.negative = function(multiply) {
        var matrix = [
          -1,
          0,
          0,
          1,
          0,
          0,
          -1,
          0,
          1,
          0,
          0,
          0,
          -1,
          1,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.sepia = function(multiply) {
        var matrix = [
          0.393,
          0.7689999,
          0.18899999,
          0,
          0,
          0.349,
          0.6859999,
          0.16799999,
          0,
          0,
          0.272,
          0.5339999,
          0.13099999,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.technicolor = function(multiply) {
        var matrix = [
          1.9125277891456083,
          -0.8545344976951645,
          -0.09155508482755585,
          0,
          11.793603434377337,
          -0.3087833385928097,
          1.7658908555458428,
          -0.10601743074722245,
          0,
          -70.35205161461398,
          -0.231103377548616,
          -0.7501899197440212,
          1.847597816108189,
          0,
          30.950940869491138,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.polaroid = function(multiply) {
        var matrix = [
          1.438,
          -0.062,
          -0.062,
          0,
          0,
          -0.122,
          1.378,
          -0.122,
          0,
          0,
          -0.016,
          -0.016,
          1.483,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.toBGR = function(multiply) {
        var matrix = [
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.kodachrome = function(multiply) {
        var matrix = [
          1.1285582396593525,
          -0.3967382283601348,
          -0.03992559172921793,
          0,
          63.72958762196502,
          -0.16404339962244616,
          1.0835251566291304,
          -0.05498805115633132,
          0,
          24.732407896706203,
          -0.16786010706155763,
          -0.5603416277695248,
          1.6014850761964943,
          0,
          35.62982807460946,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.browni = function(multiply) {
        var matrix = [
          0.5997023498159715,
          0.34553243048391263,
          -0.2708298674538042,
          0,
          47.43192855600873,
          -0.037703249837783157,
          0.8609577587992641,
          0.15059552388459913,
          0,
          -36.96841498319127,
          0.24113635128153335,
          -0.07441037908422492,
          0.44972182064877153,
          0,
          -7.562075277591283,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.vintage = function(multiply) {
        var matrix = [
          0.6279345635605994,
          0.3202183420819367,
          -0.03965408211312453,
          0,
          9.651285835294123,
          0.02578397704808868,
          0.6441188644374771,
          0.03259127616149294,
          0,
          7.462829176470591,
          0.0466055556782719,
          -0.0851232987247891,
          0.5241648018700465,
          0,
          5.159190588235296,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.colorTone = function(desaturation, toned, lightColor, darkColor, multiply) {
        desaturation = desaturation || 0.2;
        toned = toned || 0.15;
        lightColor = lightColor || 16770432;
        darkColor = darkColor || 3375104;
        var lR = (lightColor >> 16 & 255) / 255;
        var lG = (lightColor >> 8 & 255) / 255;
        var lB = (lightColor & 255) / 255;
        var dR = (darkColor >> 16 & 255) / 255;
        var dG = (darkColor >> 8 & 255) / 255;
        var dB = (darkColor & 255) / 255;
        var matrix = [
          0.3,
          0.59,
          0.11,
          0,
          0,
          lR,
          lG,
          lB,
          desaturation,
          0,
          dR,
          dG,
          dB,
          toned,
          0,
          lR - dR,
          lG - dG,
          lB - dB,
          0,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.night = function(intensity, multiply) {
        intensity = intensity || 0.1;
        var matrix = [
          intensity * -2,
          -intensity,
          0,
          0,
          0,
          -intensity,
          0,
          intensity,
          0,
          0,
          0,
          intensity,
          intensity * 2,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.predator = function(amount, multiply) {
        var matrix = [
          // row 1
          11.224130630493164 * amount,
          -4.794486999511719 * amount,
          -2.8746118545532227 * amount,
          0 * amount,
          0.40342438220977783 * amount,
          // row 2
          -3.6330697536468506 * amount,
          9.193157196044922 * amount,
          -2.951810836791992 * amount,
          0 * amount,
          -1.316135048866272 * amount,
          // row 3
          -3.2184197902679443 * amount,
          -4.2375030517578125 * amount,
          7.476448059082031 * amount,
          0 * amount,
          0.8044459223747253 * amount,
          // row 4
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.lsd = function(multiply) {
        var matrix = [
          2,
          -0.4,
          0.5,
          0,
          0,
          -0.5,
          2,
          -0.4,
          0,
          0,
          -0.4,
          -0.5,
          3,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.reset = function() {
        var matrix = [
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, false);
      };
      Object.defineProperty(ColorMatrixFilter2.prototype, "matrix", {
        /**
         * The matrix of the color matrix filter
         * @member {number[]}
         * @default [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
         */
        get: function() {
          return this.uniforms.m;
        },
        set: function(value) {
          this.uniforms.m = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ColorMatrixFilter2.prototype, "alpha", {
        /**
         * The opacity value to use when mixing the original and resultant colors.
         *
         * When the value is 0, the original color is used without modification.
         * When the value is 1, the result color is used.
         * When in the range (0, 1) the color is interpolated between the original and result by this amount.
         * @default 1
         */
        get: function() {
          return this.uniforms.uAlpha;
        },
        set: function(value) {
          this.uniforms.uAlpha = value;
        },
        enumerable: false,
        configurable: true
      });
      return ColorMatrixFilter2;
    }(Filter)
  );
  ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;

  // node_modules/@pixi/filter-pixelate/dist/filter-pixelate.esm.mjs
  var extendStatics15 = function(d, b) {
    extendStatics15 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) {
        if (Object.prototype.hasOwnProperty.call(b2, p)) {
          d2[p] = b2[p];
        }
      }
    };
    return extendStatics15(d, b);
  };
  function __extends15(d, b) {
    extendStatics15(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var vertex4 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
  var fragment6 = "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform vec2 size;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvec2 pixelate(vec2 coord, vec2 size)\n{\n	return floor( coord / size ) * size;\n}\n\nvoid main(void)\n{\n    vec2 coord = mapCoord(vTextureCoord);\n\n    coord = pixelate(coord, size);\n\n    coord = unmapCoord(coord);\n\n    gl_FragColor = texture2D(uSampler, coord);\n}\n";
  var PixelateFilter = (
    /** @class */
    function(_super) {
      __extends15(PixelateFilter2, _super);
      function PixelateFilter2(size) {
        if (size === void 0) {
          size = 10;
        }
        var _this = _super.call(this, vertex4, fragment6) || this;
        _this.size = size;
        return _this;
      }
      Object.defineProperty(PixelateFilter2.prototype, "size", {
        /**
         * This a point that describes the size of the blocks.
         * x is the width of the block and y is the height.
         *
         * @member {PIXI.Point|Array<number>|number}
         * @default 10
         */
        get: function() {
          return this.uniforms.size;
        },
        set: function(value) {
          if (typeof value === "number") {
            value = [value, value];
          }
          this.uniforms.size = value;
        },
        enumerable: false,
        configurable: true
      });
      return PixelateFilter2;
    }(Filter)
  );

  // node_modules/@pixi/filter-crt/dist/filter-crt.esm.mjs
  var extendStatics16 = function(d, b) {
    extendStatics16 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) {
        if (Object.prototype.hasOwnProperty.call(b2, p)) {
          d2[p] = b2[p];
        }
      }
    };
    return extendStatics16(d, b);
  };
  function __extends16(d, b) {
    extendStatics16(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var vertex5 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
  var fragment7 = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nconst float SQRT_2 = 1.414213;\n\nconst float light = 1.0;\n\nuniform float curvature;\nuniform float lineWidth;\nuniform float lineContrast;\nuniform bool verticalLine;\nuniform float noise;\nuniform float noiseSize;\n\nuniform float vignetting;\nuniform float vignettingAlpha;\nuniform float vignettingBlur;\n\nuniform float seed;\nuniform float time;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main(void)\n{\n    vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n    vec2 dir = vec2(vTextureCoord.xy * filterArea.xy / dimensions - vec2(0.5, 0.5));\n    \n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n    vec3 rgb = gl_FragColor.rgb;\n\n    if (noise > 0.0 && noiseSize > 0.0)\n    {\n        pixelCoord.x = floor(pixelCoord.x / noiseSize);\n        pixelCoord.y = floor(pixelCoord.y / noiseSize);\n        float _noise = rand(pixelCoord * noiseSize * seed) - 0.5;\n        rgb += _noise * noise;\n    }\n\n    if (lineWidth > 0.0)\n    {\n        float _c = curvature > 0. ? curvature : 1.;\n        float k = curvature > 0. ?(length(dir * dir) * 0.25 * _c * _c + 0.935 * _c) : 1.;\n        vec2 uv = dir * k;\n\n        float v = (verticalLine ? uv.x * dimensions.x : uv.y * dimensions.y) * min(1.0, 2.0 / lineWidth ) / _c;\n        float j = 1. + cos(v * 1.2 - time) * 0.5 * lineContrast;\n        rgb *= j;\n        float segment = verticalLine ? mod((dir.x + .5) * dimensions.x, 4.) : mod((dir.y + .5) * dimensions.y, 4.);\n        rgb *= 0.99 + ceil(segment) * 0.015;\n    }\n\n    if (vignetting > 0.0)\n    {\n        float outter = SQRT_2 - vignetting * SQRT_2;\n        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignettingBlur * SQRT_2), 0.0, 1.0);\n        rgb *= darker + (1.0 - darker) * (1.0 - vignettingAlpha);\n    }\n\n    gl_FragColor.rgb = rgb;\n}\n";
  var CRTFilter = (
    /** @class */
    function(_super) {
      __extends16(CRTFilter2, _super);
      function CRTFilter2(options) {
        var _this = _super.call(this, vertex5, fragment7) || this;
        _this.time = 0;
        _this.seed = 0;
        _this.uniforms.dimensions = new Float32Array(2);
        Object.assign(_this, CRTFilter2.defaults, options);
        return _this;
      }
      CRTFilter2.prototype.apply = function(filterManager, input, output, clear) {
        var _a2 = input.filterFrame, width = _a2.width, height = _a2.height;
        this.uniforms.dimensions[0] = width;
        this.uniforms.dimensions[1] = height;
        this.uniforms.seed = this.seed;
        this.uniforms.time = this.time;
        filterManager.applyFilter(this, input, output, clear);
      };
      Object.defineProperty(CRTFilter2.prototype, "curvature", {
        get: function() {
          return this.uniforms.curvature;
        },
        /**
         * Bent of interlaced lines, higher value means more bend
         * @default 1
         */
        set: function(value) {
          this.uniforms.curvature = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CRTFilter2.prototype, "lineWidth", {
        get: function() {
          return this.uniforms.lineWidth;
        },
        /**
         * Width of interlaced lines
         * @default 1
         */
        set: function(value) {
          this.uniforms.lineWidth = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CRTFilter2.prototype, "lineContrast", {
        get: function() {
          return this.uniforms.lineContrast;
        },
        /**
         * Contrast of interlaced lines
         * @default 0.25
         */
        set: function(value) {
          this.uniforms.lineContrast = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CRTFilter2.prototype, "verticalLine", {
        get: function() {
          return this.uniforms.verticalLine;
        },
        /**
         * `true` for vertical lines, `false` for horizontal lines
         * @default false
         */
        set: function(value) {
          this.uniforms.verticalLine = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CRTFilter2.prototype, "noise", {
        get: function() {
          return this.uniforms.noise;
        },
        /**
         * Opacity/intensity of the noise effect between `0` and `1`
         * @default 0
         */
        set: function(value) {
          this.uniforms.noise = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CRTFilter2.prototype, "noiseSize", {
        get: function() {
          return this.uniforms.noiseSize;
        },
        /**
         * The size of the noise particles
         * @default 0
         */
        set: function(value) {
          this.uniforms.noiseSize = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CRTFilter2.prototype, "vignetting", {
        get: function() {
          return this.uniforms.vignetting;
        },
        /**
         * The radius of the vignette effect, smaller
         * values produces a smaller vignette
         * @default 0
         */
        set: function(value) {
          this.uniforms.vignetting = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CRTFilter2.prototype, "vignettingAlpha", {
        get: function() {
          return this.uniforms.vignettingAlpha;
        },
        /**
         * Amount of opacity of vignette
         * @default 0
         */
        set: function(value) {
          this.uniforms.vignettingAlpha = value;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CRTFilter2.prototype, "vignettingBlur", {
        get: function() {
          return this.uniforms.vignettingBlur;
        },
        /**
         * Blur intensity of the vignette
         * @default 0
         */
        set: function(value) {
          this.uniforms.vignettingBlur = value;
        },
        enumerable: false,
        configurable: true
      });
      CRTFilter2.defaults = {
        curvature: 1,
        lineWidth: 1,
        lineContrast: 0.25,
        verticalLine: false,
        noise: 0,
        noiseSize: 1,
        seed: 0,
        vignetting: 0.3,
        vignettingAlpha: 1,
        vignettingBlur: 0.3,
        time: 0
      };
      return CRTFilter2;
    }(Filter)
  );

  // src-www/js/libs/pixi-build.js
  Renderer.registerPlugin("batch", BatchRenderer);
  Renderer.registerPlugin("extract", Extract);
  Renderer.registerPlugin("tilingSprite", TilingSpriteRenderer);
  CanvasRenderer.registerPlugin("extract", CanvasExtract);
  CanvasRenderer.registerPlugin("graphics", CanvasGraphicsRenderer);
  CanvasRenderer.registerPlugin("mesh", CanvasMeshRenderer);
  CanvasRenderer.registerPlugin("sprite", CanvasSpriteRenderer);
  Application.registerPlugin(TickerPlugin);
  var filters = {
    AlphaFilter,
    ColorMatrixFilter,
    PixelateFilter,
    CRTFilter
  };

  // src-www/js/libs/pixi.js
  window["PIXI"] = pixi_build_exports;
})();
/*! Bundled license information:

punycode/punycode.js:
  (*! https://mths.be/punycode v1.3.2 by @mathias *)

@pixi/constants/dist/esm/constants.js:
  (*!
   * @pixi/constants - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/constants is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

@pixi/math/dist/esm/math.js:
  (*!
   * @pixi/math - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/math is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

@pixi/runner/dist/esm/runner.js:
  (*!
   * @pixi/runner - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/runner is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

@pixi/settings/dist/esm/settings.js:
  (*!
   * @pixi/settings - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/settings is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*!
   * @pixi/constants - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/constants is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

@pixi/ticker/dist/esm/ticker.js:
  (*!
   * @pixi/ticker - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/ticker is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

@pixi/utils/dist/esm/utils.js:
  (*!
   * @pixi/utils - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/utils is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

@pixi/display/dist/esm/display.js:
  (*!
   * @pixi/display - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/display is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)
  (*!
   * @pixi/constants - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/constants is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

@pixi/core/dist/esm/core.js:
  (*!
   * @pixi/core - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/core is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

@pixi/canvas-display/dist/esm/canvas-display.js:
  (*!
   * @pixi/canvas-display - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/canvas-display is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

@pixi/extract/dist/esm/extract.js:
  (*!
   * @pixi/extract - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/extract is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*!
   * @pixi/settings - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/settings is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*!
   * @pixi/constants - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/constants is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*!
   * @pixi/display - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/display is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

@pixi/mesh/dist/esm/mesh.js:
  (*!
   * @pixi/mesh - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/mesh is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

@pixi/sprite/dist/esm/sprite.js:
  (*!
   * @pixi/sprite - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/sprite is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

@pixi/canvas-renderer/dist/esm/canvas-renderer.js:
  (*!
   * @pixi/canvas-renderer - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/canvas-renderer is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

@pixi/canvas-extract/dist/esm/canvas-extract.js:
  (*!
   * @pixi/canvas-extract - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/canvas-extract is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

@pixi/app/dist/esm/app.js:
  (*!
   * @pixi/app - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/app is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

@pixi/graphics/dist/esm/graphics.js:
  (*!
   * @pixi/graphics - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/graphics is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

@pixi/mesh-extras/dist/esm/mesh-extras.js:
  (*!
   * @pixi/mesh-extras - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/mesh-extras is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

@pixi/mixin-cache-as-bitmap/dist/esm/mixin-cache-as-bitmap.js:
  (*!
   * @pixi/mixin-cache-as-bitmap - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/mixin-cache-as-bitmap is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*!
   * @pixi/constants - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/constants is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

@pixi/sprite-tiling/dist/esm/sprite-tiling.js:
  (*!
   * @pixi/sprite-tiling - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/sprite-tiling is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

@pixi/canvas-sprite/dist/esm/canvas-sprite.js:
  (*!
   * @pixi/canvas-sprite - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/canvas-sprite is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

@pixi/text/dist/esm/text.js:
  (*!
   * @pixi/text - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/text is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

@pixi/loaders/dist/esm/loaders.js:
  (*!
   * @pixi/loaders - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/loaders is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

@pixi/text-bitmap/dist/esm/text-bitmap.js:
  (*!
   * @pixi/text-bitmap - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/text-bitmap is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

@pixi/canvas-graphics/dist/esm/canvas-graphics.js:
  (*!
   * @pixi/canvas-graphics - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/canvas-graphics is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

@pixi/canvas-mesh/dist/esm/canvas-mesh.js:
  (*!
   * @pixi/canvas-mesh - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/canvas-mesh is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*!
   * @pixi/utils - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/utils is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*!
   * @pixi/runner - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/runner is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*!
   * @pixi/ticker - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/ticker is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*!
   * @pixi/math - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/math is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*!
   * @pixi/core - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/core is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

@pixi/canvas-sprite-tiling/dist/esm/canvas-sprite-tiling.js:
  (*!
   * @pixi/canvas-sprite-tiling - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/canvas-sprite-tiling is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

@pixi/filter-alpha/dist/esm/filter-alpha.js:
  (*!
   * @pixi/filter-alpha - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/filter-alpha is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

@pixi/filter-color-matrix/dist/esm/filter-color-matrix.js:
  (*!
   * @pixi/filter-color-matrix - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/filter-color-matrix is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

@pixi/filter-pixelate/dist/filter-pixelate.esm.mjs:
  (*!
   * @pixi/filter-pixelate - v4.2.0
   * Compiled Fri, 05 Aug 2022 19:53:35 UTC
   *
   * @pixi/filter-pixelate is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@pixi/filter-crt/dist/filter-crt.esm.mjs:
  (*!
   * @pixi/filter-crt - v4.2.0
   * Compiled Fri, 05 Aug 2022 19:53:35 UTC
   *
   * @pixi/filter-crt is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=pixi.js.map
