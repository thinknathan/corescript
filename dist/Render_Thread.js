/*!
 * Render_Thread.js - corescript v1.6.1 (community-1.4)
 * (c) 2015 KADOKAWA CORPORATION./YOJI OJIMA
 * Contributions by the RPG Maker MV CoreScript team
 * https://github.com/thinknathan/corescript/blob/master/CONTRIBUTORS.md
 *
 * Licensed under the MIT License.
 * https://github.com/thinknathan/corescript/blob/master/LICENSE
 */
(function () {
	'use strict';
	const proxyMarker = Symbol('Comlink.proxy'),
		createEndpoint = Symbol('Comlink.endpoint'),
		releaseProxy = Symbol('Comlink.releaseProxy'),
		throwMarker = Symbol('Comlink.thrown'),
		isObject = (t) =>
			('object' == typeof t && null !== t) || 'function' == typeof t,
		proxyTransferHandler = {
			canHandle: (t) => isObject(t) && t[proxyMarker],
			serialize(t) {
				const { port1: e, port2: i } = new MessageChannel();
				return expose(t, e), [i, [i]];
			},
			deserialize: (t) => (t.start(), wrap(t)),
		},
		throwTransferHandler = {
			canHandle: (t) => isObject(t) && throwMarker in t,
			serialize({ value: t }) {
				let e;
				return (
					(e =
						t instanceof Error
							? {
									isError: !0,
									value: { message: t.message, name: t.name, stack: t.stack },
							  }
							: { isError: !1, value: t }),
					[e, []]
				);
			},
			deserialize(t) {
				if (t.isError) throw Object.assign(new Error(t.value.message), t.value);
				throw t.value;
			},
		},
		transferHandlers = new Map([
			['proxy', proxyTransferHandler],
			['throw', throwTransferHandler],
		]);
	function expose(t, e = self) {
		e.addEventListener('message', function i(r) {
			if (!r || !r.data) return;
			const { id: s, type: n, path: a } = Object.assign({ path: [] }, r.data),
				o = (r.data.argumentList || []).map(fromWireValue);
			let h;
			try {
				const e = a.slice(0, -1).reduce((t, e) => t[e], t),
					i = a.reduce((t, e) => t[e], t);
				switch (n) {
					case 'GET':
						h = i;
						break;
					case 'SET':
						(e[a.slice(-1)[0]] = fromWireValue(r.data.value)), (h = !0);
						break;
					case 'APPLY':
						h = i.apply(e, o);
						break;
					case 'CONSTRUCT':
						h = proxy(new i(...o));
						break;
					case 'ENDPOINT':
						{
							const { port1: e, port2: i } = new MessageChannel();
							expose(t, i), (h = transfer(e, [e]));
						}
						break;
					case 'RELEASE':
						h = void 0;
						break;
					default:
						return;
				}
			} catch (t) {
				h = { value: t, [throwMarker]: 0 };
			}
			Promise.resolve(h)
				.catch((t) => ({ value: t, [throwMarker]: 0 }))
				.then((t) => {
					const [r, a] = toWireValue(t);
					e.postMessage(Object.assign(Object.assign({}, r), { id: s }), a),
						'RELEASE' === n &&
							(e.removeEventListener('message', i), closeEndPoint(e));
				});
		}),
			e.start && e.start();
	}
	function isMessagePort(t) {
		return 'MessagePort' === t.constructor.name;
	}
	function closeEndPoint(t) {
		isMessagePort(t) && t.close();
	}
	function wrap(t, e) {
		return createProxy(t, [], e);
	}
	function throwIfProxyReleased(t) {
		if (t) throw new Error('Proxy has been released and is not useable');
	}
	function createProxy(t, e = [], i = function () {}) {
		let r = !1;
		const s = new Proxy(i, {
			get(i, n) {
				if ((throwIfProxyReleased(r), n === releaseProxy))
					return () =>
						requestResponseMessage(t, {
							type: 'RELEASE',
							path: e.map((t) => t.toString()),
						}).then(() => {
							closeEndPoint(t), (r = !0);
						});
				if ('then' === n) {
					if (0 === e.length) return { then: () => s };
					const i = requestResponseMessage(t, {
						type: 'GET',
						path: e.map((t) => t.toString()),
					}).then(fromWireValue);
					return i.then.bind(i);
				}
				return createProxy(t, [...e, n]);
			},
			set(i, s, n) {
				throwIfProxyReleased(r);
				const [a, o] = toWireValue(n);
				return requestResponseMessage(
					t,
					{ type: 'SET', path: [...e, s].map((t) => t.toString()), value: a },
					o
				).then(fromWireValue);
			},
			apply(i, s, n) {
				throwIfProxyReleased(r);
				const a = e[e.length - 1];
				if (a === createEndpoint)
					return requestResponseMessage(t, { type: 'ENDPOINT' }).then(
						fromWireValue
					);
				if ('bind' === a) return createProxy(t, e.slice(0, -1));
				const [o, h] = processArguments(n);
				return requestResponseMessage(
					t,
					{ type: 'APPLY', path: e.map((t) => t.toString()), argumentList: o },
					h
				).then(fromWireValue);
			},
			construct(i, s) {
				throwIfProxyReleased(r);
				const [n, a] = processArguments(s);
				return requestResponseMessage(
					t,
					{
						type: 'CONSTRUCT',
						path: e.map((t) => t.toString()),
						argumentList: n,
					},
					a
				).then(fromWireValue);
			},
		});
		return s;
	}
	function myFlat(t) {
		return Array.prototype.concat.apply([], t);
	}
	function processArguments(t) {
		const e = t.map(toWireValue);
		return [e.map((t) => t[0]), myFlat(e.map((t) => t[1]))];
	}
	const transferCache = new WeakMap();
	function transfer(t, e) {
		return transferCache.set(t, e), t;
	}
	function proxy(t) {
		return Object.assign(t, { [proxyMarker]: !0 });
	}
	function toWireValue(t) {
		for (const [e, i] of transferHandlers)
			if (i.canHandle(t)) {
				const [r, s] = i.serialize(t);
				return [{ type: 'HANDLER', name: e, value: r }, s];
			}
		return [{ type: 'RAW', value: t }, transferCache.get(t) || []];
	}
	function fromWireValue(t) {
		switch (t.type) {
			case 'HANDLER':
				return transferHandlers.get(t.name).deserialize(t.value);
			case 'RAW':
				return t.value;
		}
	}
	function requestResponseMessage(t, e, i) {
		return new Promise((r) => {
			const s = generateUUID();
			t.addEventListener('message', function e(i) {
				i.data &&
					i.data.id &&
					i.data.id === s &&
					(t.removeEventListener('message', e), r(i.data));
			}),
				t.start && t.start(),
				t.postMessage(Object.assign({ id: s }, e), i);
		});
	}
	function generateUUID() {
		return new Array(4)
			.fill(0)
			.map(() =>
				Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)
			)
			.join('-');
	}
	/*!
	 * @pixi/constants - v6.4.2
	 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
	 *
	 * @pixi/constants is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 */ var ENV$9,
		ENV2,
		RENDERER_TYPE$9,
		RENDERER_TYPE2,
		BUFFER_BITS$9,
		BUFFER_BITS2,
		BLEND_MODES$9,
		BLEND_MODES2,
		DRAW_MODES$9,
		DRAW_MODES2,
		FORMATS$9,
		FORMATS2,
		TARGETS$9,
		TARGETS2,
		TYPES$9,
		TYPES2,
		SAMPLER_TYPES$9,
		SAMPLER_TYPES2,
		SCALE_MODES$9,
		SCALE_MODES2,
		WRAP_MODES$9,
		WRAP_MODES2,
		MIPMAP_MODES$9,
		MIPMAP_MODES2,
		ALPHA_MODES$9,
		ALPHA_MODES2,
		CLEAR_MODES$9,
		CLEAR_MODES2,
		GC_MODES$9,
		GC_MODES2,
		PRECISION$9,
		PRECISION2,
		MASK_TYPES$9,
		MASK_TYPES2,
		MSAA_QUALITY$9,
		MSAA_QUALITY2,
		BUFFER_TYPE$9,
		BUFFER_TYPE2;
	(ENV2 = ENV$9 || (ENV$9 = {})),
		(ENV2[(ENV2.WEBGL_LEGACY = 0)] = 'WEBGL_LEGACY'),
		(ENV2[(ENV2.WEBGL = 1)] = 'WEBGL'),
		(ENV2[(ENV2.WEBGL2 = 2)] = 'WEBGL2'),
		(RENDERER_TYPE2 = RENDERER_TYPE$9 || (RENDERER_TYPE$9 = {})),
		(RENDERER_TYPE2[(RENDERER_TYPE2.UNKNOWN = 0)] = 'UNKNOWN'),
		(RENDERER_TYPE2[(RENDERER_TYPE2.WEBGL = 1)] = 'WEBGL'),
		(RENDERER_TYPE2[(RENDERER_TYPE2.CANVAS = 2)] = 'CANVAS'),
		(BUFFER_BITS2 = BUFFER_BITS$9 || (BUFFER_BITS$9 = {})),
		(BUFFER_BITS2[(BUFFER_BITS2.COLOR = 16384)] = 'COLOR'),
		(BUFFER_BITS2[(BUFFER_BITS2.DEPTH = 256)] = 'DEPTH'),
		(BUFFER_BITS2[(BUFFER_BITS2.STENCIL = 1024)] = 'STENCIL'),
		(BLEND_MODES2 = BLEND_MODES$9 || (BLEND_MODES$9 = {})),
		(BLEND_MODES2[(BLEND_MODES2.NORMAL = 0)] = 'NORMAL'),
		(BLEND_MODES2[(BLEND_MODES2.ADD = 1)] = 'ADD'),
		(BLEND_MODES2[(BLEND_MODES2.MULTIPLY = 2)] = 'MULTIPLY'),
		(BLEND_MODES2[(BLEND_MODES2.SCREEN = 3)] = 'SCREEN'),
		(BLEND_MODES2[(BLEND_MODES2.OVERLAY = 4)] = 'OVERLAY'),
		(BLEND_MODES2[(BLEND_MODES2.DARKEN = 5)] = 'DARKEN'),
		(BLEND_MODES2[(BLEND_MODES2.LIGHTEN = 6)] = 'LIGHTEN'),
		(BLEND_MODES2[(BLEND_MODES2.COLOR_DODGE = 7)] = 'COLOR_DODGE'),
		(BLEND_MODES2[(BLEND_MODES2.COLOR_BURN = 8)] = 'COLOR_BURN'),
		(BLEND_MODES2[(BLEND_MODES2.HARD_LIGHT = 9)] = 'HARD_LIGHT'),
		(BLEND_MODES2[(BLEND_MODES2.SOFT_LIGHT = 10)] = 'SOFT_LIGHT'),
		(BLEND_MODES2[(BLEND_MODES2.DIFFERENCE = 11)] = 'DIFFERENCE'),
		(BLEND_MODES2[(BLEND_MODES2.EXCLUSION = 12)] = 'EXCLUSION'),
		(BLEND_MODES2[(BLEND_MODES2.HUE = 13)] = 'HUE'),
		(BLEND_MODES2[(BLEND_MODES2.SATURATION = 14)] = 'SATURATION'),
		(BLEND_MODES2[(BLEND_MODES2.COLOR = 15)] = 'COLOR'),
		(BLEND_MODES2[(BLEND_MODES2.LUMINOSITY = 16)] = 'LUMINOSITY'),
		(BLEND_MODES2[(BLEND_MODES2.NORMAL_NPM = 17)] = 'NORMAL_NPM'),
		(BLEND_MODES2[(BLEND_MODES2.ADD_NPM = 18)] = 'ADD_NPM'),
		(BLEND_MODES2[(BLEND_MODES2.SCREEN_NPM = 19)] = 'SCREEN_NPM'),
		(BLEND_MODES2[(BLEND_MODES2.NONE = 20)] = 'NONE'),
		(BLEND_MODES2[(BLEND_MODES2.SRC_OVER = 0)] = 'SRC_OVER'),
		(BLEND_MODES2[(BLEND_MODES2.SRC_IN = 21)] = 'SRC_IN'),
		(BLEND_MODES2[(BLEND_MODES2.SRC_OUT = 22)] = 'SRC_OUT'),
		(BLEND_MODES2[(BLEND_MODES2.SRC_ATOP = 23)] = 'SRC_ATOP'),
		(BLEND_MODES2[(BLEND_MODES2.DST_OVER = 24)] = 'DST_OVER'),
		(BLEND_MODES2[(BLEND_MODES2.DST_IN = 25)] = 'DST_IN'),
		(BLEND_MODES2[(BLEND_MODES2.DST_OUT = 26)] = 'DST_OUT'),
		(BLEND_MODES2[(BLEND_MODES2.DST_ATOP = 27)] = 'DST_ATOP'),
		(BLEND_MODES2[(BLEND_MODES2.ERASE = 26)] = 'ERASE'),
		(BLEND_MODES2[(BLEND_MODES2.SUBTRACT = 28)] = 'SUBTRACT'),
		(BLEND_MODES2[(BLEND_MODES2.XOR = 29)] = 'XOR'),
		(DRAW_MODES2 = DRAW_MODES$9 || (DRAW_MODES$9 = {})),
		(DRAW_MODES2[(DRAW_MODES2.POINTS = 0)] = 'POINTS'),
		(DRAW_MODES2[(DRAW_MODES2.LINES = 1)] = 'LINES'),
		(DRAW_MODES2[(DRAW_MODES2.LINE_LOOP = 2)] = 'LINE_LOOP'),
		(DRAW_MODES2[(DRAW_MODES2.LINE_STRIP = 3)] = 'LINE_STRIP'),
		(DRAW_MODES2[(DRAW_MODES2.TRIANGLES = 4)] = 'TRIANGLES'),
		(DRAW_MODES2[(DRAW_MODES2.TRIANGLE_STRIP = 5)] = 'TRIANGLE_STRIP'),
		(DRAW_MODES2[(DRAW_MODES2.TRIANGLE_FAN = 6)] = 'TRIANGLE_FAN'),
		(FORMATS2 = FORMATS$9 || (FORMATS$9 = {})),
		(FORMATS2[(FORMATS2.RGBA = 6408)] = 'RGBA'),
		(FORMATS2[(FORMATS2.RGB = 6407)] = 'RGB'),
		(FORMATS2[(FORMATS2.RG = 33319)] = 'RG'),
		(FORMATS2[(FORMATS2.RED = 6403)] = 'RED'),
		(FORMATS2[(FORMATS2.RGBA_INTEGER = 36249)] = 'RGBA_INTEGER'),
		(FORMATS2[(FORMATS2.RGB_INTEGER = 36248)] = 'RGB_INTEGER'),
		(FORMATS2[(FORMATS2.RG_INTEGER = 33320)] = 'RG_INTEGER'),
		(FORMATS2[(FORMATS2.RED_INTEGER = 36244)] = 'RED_INTEGER'),
		(FORMATS2[(FORMATS2.ALPHA = 6406)] = 'ALPHA'),
		(FORMATS2[(FORMATS2.LUMINANCE = 6409)] = 'LUMINANCE'),
		(FORMATS2[(FORMATS2.LUMINANCE_ALPHA = 6410)] = 'LUMINANCE_ALPHA'),
		(FORMATS2[(FORMATS2.DEPTH_COMPONENT = 6402)] = 'DEPTH_COMPONENT'),
		(FORMATS2[(FORMATS2.DEPTH_STENCIL = 34041)] = 'DEPTH_STENCIL'),
		(TARGETS2 = TARGETS$9 || (TARGETS$9 = {})),
		(TARGETS2[(TARGETS2.TEXTURE_2D = 3553)] = 'TEXTURE_2D'),
		(TARGETS2[(TARGETS2.TEXTURE_CUBE_MAP = 34067)] = 'TEXTURE_CUBE_MAP'),
		(TARGETS2[(TARGETS2.TEXTURE_2D_ARRAY = 35866)] = 'TEXTURE_2D_ARRAY'),
		(TARGETS2[(TARGETS2.TEXTURE_CUBE_MAP_POSITIVE_X = 34069)] =
			'TEXTURE_CUBE_MAP_POSITIVE_X'),
		(TARGETS2[(TARGETS2.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070)] =
			'TEXTURE_CUBE_MAP_NEGATIVE_X'),
		(TARGETS2[(TARGETS2.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071)] =
			'TEXTURE_CUBE_MAP_POSITIVE_Y'),
		(TARGETS2[(TARGETS2.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072)] =
			'TEXTURE_CUBE_MAP_NEGATIVE_Y'),
		(TARGETS2[(TARGETS2.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073)] =
			'TEXTURE_CUBE_MAP_POSITIVE_Z'),
		(TARGETS2[(TARGETS2.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074)] =
			'TEXTURE_CUBE_MAP_NEGATIVE_Z'),
		(TYPES2 = TYPES$9 || (TYPES$9 = {})),
		(TYPES2[(TYPES2.UNSIGNED_BYTE = 5121)] = 'UNSIGNED_BYTE'),
		(TYPES2[(TYPES2.UNSIGNED_SHORT = 5123)] = 'UNSIGNED_SHORT'),
		(TYPES2[(TYPES2.UNSIGNED_SHORT_5_6_5 = 33635)] = 'UNSIGNED_SHORT_5_6_5'),
		(TYPES2[(TYPES2.UNSIGNED_SHORT_4_4_4_4 = 32819)] =
			'UNSIGNED_SHORT_4_4_4_4'),
		(TYPES2[(TYPES2.UNSIGNED_SHORT_5_5_5_1 = 32820)] =
			'UNSIGNED_SHORT_5_5_5_1'),
		(TYPES2[(TYPES2.UNSIGNED_INT = 5125)] = 'UNSIGNED_INT'),
		(TYPES2[(TYPES2.UNSIGNED_INT_10F_11F_11F_REV = 35899)] =
			'UNSIGNED_INT_10F_11F_11F_REV'),
		(TYPES2[(TYPES2.UNSIGNED_INT_2_10_10_10_REV = 33640)] =
			'UNSIGNED_INT_2_10_10_10_REV'),
		(TYPES2[(TYPES2.UNSIGNED_INT_24_8 = 34042)] = 'UNSIGNED_INT_24_8'),
		(TYPES2[(TYPES2.UNSIGNED_INT_5_9_9_9_REV = 35902)] =
			'UNSIGNED_INT_5_9_9_9_REV'),
		(TYPES2[(TYPES2.BYTE = 5120)] = 'BYTE'),
		(TYPES2[(TYPES2.SHORT = 5122)] = 'SHORT'),
		(TYPES2[(TYPES2.INT = 5124)] = 'INT'),
		(TYPES2[(TYPES2.FLOAT = 5126)] = 'FLOAT'),
		(TYPES2[(TYPES2.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269)] =
			'FLOAT_32_UNSIGNED_INT_24_8_REV'),
		(TYPES2[(TYPES2.HALF_FLOAT = 36193)] = 'HALF_FLOAT'),
		(SAMPLER_TYPES2 = SAMPLER_TYPES$9 || (SAMPLER_TYPES$9 = {})),
		(SAMPLER_TYPES2[(SAMPLER_TYPES2.FLOAT = 0)] = 'FLOAT'),
		(SAMPLER_TYPES2[(SAMPLER_TYPES2.INT = 1)] = 'INT'),
		(SAMPLER_TYPES2[(SAMPLER_TYPES2.UINT = 2)] = 'UINT'),
		(SCALE_MODES2 = SCALE_MODES$9 || (SCALE_MODES$9 = {})),
		(SCALE_MODES2[(SCALE_MODES2.NEAREST = 0)] = 'NEAREST'),
		(SCALE_MODES2[(SCALE_MODES2.LINEAR = 1)] = 'LINEAR'),
		(WRAP_MODES2 = WRAP_MODES$9 || (WRAP_MODES$9 = {})),
		(WRAP_MODES2[(WRAP_MODES2.CLAMP = 33071)] = 'CLAMP'),
		(WRAP_MODES2[(WRAP_MODES2.REPEAT = 10497)] = 'REPEAT'),
		(WRAP_MODES2[(WRAP_MODES2.MIRRORED_REPEAT = 33648)] = 'MIRRORED_REPEAT'),
		(MIPMAP_MODES2 = MIPMAP_MODES$9 || (MIPMAP_MODES$9 = {})),
		(MIPMAP_MODES2[(MIPMAP_MODES2.OFF = 0)] = 'OFF'),
		(MIPMAP_MODES2[(MIPMAP_MODES2.POW2 = 1)] = 'POW2'),
		(MIPMAP_MODES2[(MIPMAP_MODES2.ON = 2)] = 'ON'),
		(MIPMAP_MODES2[(MIPMAP_MODES2.ON_MANUAL = 3)] = 'ON_MANUAL'),
		(ALPHA_MODES2 = ALPHA_MODES$9 || (ALPHA_MODES$9 = {})),
		(ALPHA_MODES2[(ALPHA_MODES2.NPM = 0)] = 'NPM'),
		(ALPHA_MODES2[(ALPHA_MODES2.UNPACK = 1)] = 'UNPACK'),
		(ALPHA_MODES2[(ALPHA_MODES2.PMA = 2)] = 'PMA'),
		(ALPHA_MODES2[(ALPHA_MODES2.NO_PREMULTIPLIED_ALPHA = 0)] =
			'NO_PREMULTIPLIED_ALPHA'),
		(ALPHA_MODES2[(ALPHA_MODES2.PREMULTIPLY_ON_UPLOAD = 1)] =
			'PREMULTIPLY_ON_UPLOAD'),
		(ALPHA_MODES2[(ALPHA_MODES2.PREMULTIPLY_ALPHA = 2)] = 'PREMULTIPLY_ALPHA'),
		(ALPHA_MODES2[(ALPHA_MODES2.PREMULTIPLIED_ALPHA = 2)] =
			'PREMULTIPLIED_ALPHA'),
		(CLEAR_MODES2 = CLEAR_MODES$9 || (CLEAR_MODES$9 = {})),
		(CLEAR_MODES2[(CLEAR_MODES2.NO = 0)] = 'NO'),
		(CLEAR_MODES2[(CLEAR_MODES2.YES = 1)] = 'YES'),
		(CLEAR_MODES2[(CLEAR_MODES2.AUTO = 2)] = 'AUTO'),
		(CLEAR_MODES2[(CLEAR_MODES2.BLEND = 0)] = 'BLEND'),
		(CLEAR_MODES2[(CLEAR_MODES2.CLEAR = 1)] = 'CLEAR'),
		(CLEAR_MODES2[(CLEAR_MODES2.BLIT = 2)] = 'BLIT'),
		(GC_MODES2 = GC_MODES$9 || (GC_MODES$9 = {})),
		(GC_MODES2[(GC_MODES2.AUTO = 0)] = 'AUTO'),
		(GC_MODES2[(GC_MODES2.MANUAL = 1)] = 'MANUAL'),
		(PRECISION2 = PRECISION$9 || (PRECISION$9 = {})),
		(PRECISION2.LOW = 'lowp'),
		(PRECISION2.MEDIUM = 'mediump'),
		(PRECISION2.HIGH = 'highp'),
		(MASK_TYPES2 = MASK_TYPES$9 || (MASK_TYPES$9 = {})),
		(MASK_TYPES2[(MASK_TYPES2.NONE = 0)] = 'NONE'),
		(MASK_TYPES2[(MASK_TYPES2.SCISSOR = 1)] = 'SCISSOR'),
		(MASK_TYPES2[(MASK_TYPES2.STENCIL = 2)] = 'STENCIL'),
		(MASK_TYPES2[(MASK_TYPES2.SPRITE = 3)] = 'SPRITE'),
		(MSAA_QUALITY2 = MSAA_QUALITY$9 || (MSAA_QUALITY$9 = {})),
		(MSAA_QUALITY2[(MSAA_QUALITY2.NONE = 0)] = 'NONE'),
		(MSAA_QUALITY2[(MSAA_QUALITY2.LOW = 2)] = 'LOW'),
		(MSAA_QUALITY2[(MSAA_QUALITY2.MEDIUM = 4)] = 'MEDIUM'),
		(MSAA_QUALITY2[(MSAA_QUALITY2.HIGH = 8)] = 'HIGH'),
		(BUFFER_TYPE2 = BUFFER_TYPE$9 || (BUFFER_TYPE$9 = {})),
		(BUFFER_TYPE2[(BUFFER_TYPE2.ELEMENT_ARRAY_BUFFER = 34963)] =
			'ELEMENT_ARRAY_BUFFER'),
		(BUFFER_TYPE2[(BUFFER_TYPE2.ARRAY_BUFFER = 34962)] = 'ARRAY_BUFFER'),
		(BUFFER_TYPE2[(BUFFER_TYPE2.UNIFORM_BUFFER = 35345)] = 'UNIFORM_BUFFER');
	/*!
	 * @pixi/math - v6.4.2
	 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
	 *
	 * @pixi/math is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 */
	var PI_2$3 = 2 * Math.PI,
		RAD_TO_DEG$1 = 180 / Math.PI,
		DEG_TO_RAD$1 = Math.PI / 180,
		SHAPES$3,
		SHAPES2;
	(SHAPES2 = SHAPES$3 || (SHAPES$3 = {})),
		(SHAPES2[(SHAPES2.POLY = 0)] = 'POLY'),
		(SHAPES2[(SHAPES2.RECT = 1)] = 'RECT'),
		(SHAPES2[(SHAPES2.CIRC = 2)] = 'CIRC'),
		(SHAPES2[(SHAPES2.ELIP = 3)] = 'ELIP'),
		(SHAPES2[(SHAPES2.RREC = 4)] = 'RREC');
	var Point$4 = (function () {
			function t(t, e) {
				void 0 === t && (t = 0),
					void 0 === e && (e = 0),
					(this.x = 0),
					(this.y = 0),
					(this.x = t),
					(this.y = e);
			}
			return (
				(t.prototype.clone = function () {
					return new t(this.x, this.y);
				}),
				(t.prototype.copyFrom = function (t) {
					return this.set(t.x, t.y), this;
				}),
				(t.prototype.copyTo = function (t) {
					return t.set(this.x, this.y), t;
				}),
				(t.prototype.equals = function (t) {
					return t.x === this.x && t.y === this.y;
				}),
				(t.prototype.set = function (t, e) {
					return (
						void 0 === t && (t = 0),
						void 0 === e && (e = t),
						(this.x = t),
						(this.y = e),
						this
					);
				}),
				(t.prototype.toString = function () {
					return '[@pixi/math:Point x=' + this.x + ' y=' + this.y + ']';
				}),
				t
			);
		})(),
		tempPoints$4 = [new Point$4(), new Point$4(), new Point$4(), new Point$4()],
		Rectangle$4 = (function () {
			function t(t, e, i, r) {
				void 0 === t && (t = 0),
					void 0 === e && (e = 0),
					void 0 === i && (i = 0),
					void 0 === r && (r = 0),
					(this.x = Number(t)),
					(this.y = Number(e)),
					(this.width = Number(i)),
					(this.height = Number(r)),
					(this.type = SHAPES$3.RECT);
			}
			return (
				Object.defineProperty(t.prototype, 'left', {
					get: function () {
						return this.x;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'right', {
					get: function () {
						return this.x + this.width;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'top', {
					get: function () {
						return this.y;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'bottom', {
					get: function () {
						return this.y + this.height;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t, 'EMPTY', {
					get: function () {
						return new t(0, 0, 0, 0);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.clone = function () {
					return new t(this.x, this.y, this.width, this.height);
				}),
				(t.prototype.copyFrom = function (t) {
					return (
						(this.x = t.x),
						(this.y = t.y),
						(this.width = t.width),
						(this.height = t.height),
						this
					);
				}),
				(t.prototype.copyTo = function (t) {
					return (
						(t.x = this.x),
						(t.y = this.y),
						(t.width = this.width),
						(t.height = this.height),
						t
					);
				}),
				(t.prototype.contains = function (t, e) {
					return (
						!(this.width <= 0 || this.height <= 0) &&
						t >= this.x &&
						t < this.x + this.width &&
						e >= this.y &&
						e < this.y + this.height
					);
				}),
				(t.prototype.intersects = function (t, e) {
					if (!e) {
						var i = this.x < t.x ? t.x : this.x;
						if ((this.right > t.right ? t.right : this.right) <= i) return !1;
						var r = this.y < t.y ? t.y : this.y;
						return (this.bottom > t.bottom ? t.bottom : this.bottom) > r;
					}
					var s = this.left,
						n = this.right,
						a = this.top,
						o = this.bottom;
					if (n <= s || o <= a) return !1;
					var h = tempPoints$4[0].set(t.left, t.top),
						u = tempPoints$4[1].set(t.left, t.bottom),
						l = tempPoints$4[2].set(t.right, t.top),
						c = tempPoints$4[3].set(t.right, t.bottom);
					if (l.x <= h.x || u.y <= h.y) return !1;
					var d = Math.sign(e.a * e.d - e.b * e.c);
					if (0 === d) return !1;
					if (
						(e.apply(h, h),
						e.apply(u, u),
						e.apply(l, l),
						e.apply(c, c),
						Math.max(h.x, u.x, l.x, c.x) <= s ||
							Math.min(h.x, u.x, l.x, c.x) >= n ||
							Math.max(h.y, u.y, l.y, c.y) <= a ||
							Math.min(h.y, u.y, l.y, c.y) >= o)
					)
						return !1;
					var p = d * (u.y - h.y),
						f = d * (h.x - u.x),
						m = p * s + f * a,
						_ = p * n + f * a,
						g = p * s + f * o,
						E = p * n + f * o;
					if (
						Math.max(m, _, g, E) <= p * h.x + f * h.y ||
						Math.min(m, _, g, E) >= p * c.x + f * c.y
					)
						return !1;
					var y = d * (h.y - l.y),
						T = d * (l.x - h.x),
						v = y * s + T * a,
						S = y * n + T * a,
						x = y * s + T * o,
						b = y * n + T * o;
					return !(
						Math.max(v, S, x, b) <= y * h.x + T * h.y ||
						Math.min(v, S, x, b) >= y * c.x + T * c.y
					);
				}),
				(t.prototype.pad = function (t, e) {
					return (
						void 0 === t && (t = 0),
						void 0 === e && (e = t),
						(this.x -= t),
						(this.y -= e),
						(this.width += 2 * t),
						(this.height += 2 * e),
						this
					);
				}),
				(t.prototype.fit = function (t) {
					var e = Math.max(this.x, t.x),
						i = Math.min(this.x + this.width, t.x + t.width),
						r = Math.max(this.y, t.y),
						s = Math.min(this.y + this.height, t.y + t.height);
					return (
						(this.x = e),
						(this.width = Math.max(i - e, 0)),
						(this.y = r),
						(this.height = Math.max(s - r, 0)),
						this
					);
				}),
				(t.prototype.ceil = function (t, e) {
					void 0 === t && (t = 1), void 0 === e && (e = 0.001);
					var i = Math.ceil((this.x + this.width - e) * t) / t,
						r = Math.ceil((this.y + this.height - e) * t) / t;
					return (
						(this.x = Math.floor((this.x + e) * t) / t),
						(this.y = Math.floor((this.y + e) * t) / t),
						(this.width = i - this.x),
						(this.height = r - this.y),
						this
					);
				}),
				(t.prototype.enlarge = function (t) {
					var e = Math.min(this.x, t.x),
						i = Math.max(this.x + this.width, t.x + t.width),
						r = Math.min(this.y, t.y),
						s = Math.max(this.y + this.height, t.y + t.height);
					return (
						(this.x = e),
						(this.width = i - e),
						(this.y = r),
						(this.height = s - r),
						this
					);
				}),
				(t.prototype.toString = function () {
					return (
						'[@pixi/math:Rectangle x=' +
						this.x +
						' y=' +
						this.y +
						' width=' +
						this.width +
						' height=' +
						this.height +
						']'
					);
				}),
				t
			);
		})(),
		Circle = (function () {
			function t(t, e, i) {
				void 0 === t && (t = 0),
					void 0 === e && (e = 0),
					void 0 === i && (i = 0),
					(this.x = t),
					(this.y = e),
					(this.radius = i),
					(this.type = SHAPES$3.CIRC);
			}
			return (
				(t.prototype.clone = function () {
					return new t(this.x, this.y, this.radius);
				}),
				(t.prototype.contains = function (t, e) {
					if (this.radius <= 0) return !1;
					var i = this.radius * this.radius,
						r = this.x - t,
						s = this.y - e;
					return (r *= r) + (s *= s) <= i;
				}),
				(t.prototype.getBounds = function () {
					return new Rectangle$4(
						this.x - this.radius,
						this.y - this.radius,
						2 * this.radius,
						2 * this.radius
					);
				}),
				(t.prototype.toString = function () {
					return (
						'[@pixi/math:Circle x=' +
						this.x +
						' y=' +
						this.y +
						' radius=' +
						this.radius +
						']'
					);
				}),
				t
			);
		})(),
		Ellipse = (function () {
			function t(t, e, i, r) {
				void 0 === t && (t = 0),
					void 0 === e && (e = 0),
					void 0 === i && (i = 0),
					void 0 === r && (r = 0),
					(this.x = t),
					(this.y = e),
					(this.width = i),
					(this.height = r),
					(this.type = SHAPES$3.ELIP);
			}
			return (
				(t.prototype.clone = function () {
					return new t(this.x, this.y, this.width, this.height);
				}),
				(t.prototype.contains = function (t, e) {
					if (this.width <= 0 || this.height <= 0) return !1;
					var i = (t - this.x) / this.width,
						r = (e - this.y) / this.height;
					return (i *= i) + (r *= r) <= 1;
				}),
				(t.prototype.getBounds = function () {
					return new Rectangle$4(
						this.x - this.width,
						this.y - this.height,
						this.width,
						this.height
					);
				}),
				(t.prototype.toString = function () {
					return (
						'[@pixi/math:Ellipse x=' +
						this.x +
						' y=' +
						this.y +
						' width=' +
						this.width +
						' height=' +
						this.height +
						']'
					);
				}),
				t
			);
		})(),
		Polygon = (function () {
			function t() {
				for (var t = arguments, e = [], i = 0; i < arguments.length; i++)
					e[i] = t[i];
				var r = Array.isArray(e[0]) ? e[0] : e;
				if ('number' != typeof r[0]) {
					for (var s = [], n = 0, a = r.length; n < a; n++)
						s.push(r[n].x, r[n].y);
					r = s;
				}
				(this.points = r), (this.type = SHAPES$3.POLY), (this.closeStroke = !0);
			}
			return (
				(t.prototype.clone = function () {
					var e = new t(this.points.slice());
					return (e.closeStroke = this.closeStroke), e;
				}),
				(t.prototype.contains = function (t, e) {
					for (
						var i = !1, r = this.points.length / 2, s = 0, n = r - 1;
						s < r;
						n = s++
					) {
						var a = this.points[2 * s],
							o = this.points[2 * s + 1],
							h = this.points[2 * n],
							u = this.points[2 * n + 1];
						o > e != u > e && t < ((e - o) / (u - o)) * (h - a) + a && (i = !i);
					}
					return i;
				}),
				(t.prototype.toString = function () {
					return (
						'[@pixi/math:PolygoncloseStroke=' +
						this.closeStroke +
						'points=' +
						this.points.reduce(function (t, e) {
							return t + ', ' + e;
						}, '') +
						']'
					);
				}),
				t
			);
		})(),
		RoundedRectangle = (function () {
			function t(t, e, i, r, s) {
				void 0 === t && (t = 0),
					void 0 === e && (e = 0),
					void 0 === i && (i = 0),
					void 0 === r && (r = 0),
					void 0 === s && (s = 20),
					(this.x = t),
					(this.y = e),
					(this.width = i),
					(this.height = r),
					(this.radius = s),
					(this.type = SHAPES$3.RREC);
			}
			return (
				(t.prototype.clone = function () {
					return new t(this.x, this.y, this.width, this.height, this.radius);
				}),
				(t.prototype.contains = function (t, e) {
					if (this.width <= 0 || this.height <= 0) return !1;
					if (
						t >= this.x &&
						t <= this.x + this.width &&
						e >= this.y &&
						e <= this.y + this.height
					) {
						var i = Math.max(
							0,
							Math.min(this.radius, Math.min(this.width, this.height) / 2)
						);
						if (
							(e >= this.y + i && e <= this.y + this.height - i) ||
							(t >= this.x + i && t <= this.x + this.width - i)
						)
							return !0;
						var r = t - (this.x + i),
							s = e - (this.y + i),
							n = i * i;
						if (r * r + s * s <= n) return !0;
						if ((r = t - (this.x + this.width - i)) * r + s * s <= n) return !0;
						if (r * r + (s = e - (this.y + this.height - i)) * s <= n)
							return !0;
						if ((r = t - (this.x + i)) * r + s * s <= n) return !0;
					}
					return !1;
				}),
				(t.prototype.toString = function () {
					return (
						'[@pixi/math:RoundedRectangle x=' +
						this.x +
						' y=' +
						this.y +
						'width=' +
						this.width +
						' height=' +
						this.height +
						' radius=' +
						this.radius +
						']'
					);
				}),
				t
			);
		})(),
		ObservablePoint$3 = (function () {
			function t(t, e, i, r) {
				void 0 === i && (i = 0),
					void 0 === r && (r = 0),
					(this._x = i),
					(this._y = r),
					(this.cb = t),
					(this.scope = e);
			}
			return (
				(t.prototype.clone = function (e, i) {
					return (
						void 0 === e && (e = this.cb),
						void 0 === i && (i = this.scope),
						new t(e, i, this._x, this._y)
					);
				}),
				(t.prototype.set = function (t, e) {
					return (
						void 0 === t && (t = 0),
						void 0 === e && (e = t),
						(this._x === t && this._y === e) ||
							((this._x = t), (this._y = e), this.cb.call(this.scope)),
						this
					);
				}),
				(t.prototype.copyFrom = function (t) {
					return (
						(this._x === t.x && this._y === t.y) ||
							((this._x = t.x), (this._y = t.y), this.cb.call(this.scope)),
						this
					);
				}),
				(t.prototype.copyTo = function (t) {
					return t.set(this._x, this._y), t;
				}),
				(t.prototype.equals = function (t) {
					return t.x === this._x && t.y === this._y;
				}),
				(t.prototype.toString = function () {
					return (
						'[@pixi/math:ObservablePoint x=0 y=0 scope=' + this.scope + ']'
					);
				}),
				Object.defineProperty(t.prototype, 'x', {
					get: function () {
						return this._x;
					},
					set: function (t) {
						this._x !== t && ((this._x = t), this.cb.call(this.scope));
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'y', {
					get: function () {
						return this._y;
					},
					set: function (t) {
						this._y !== t && ((this._y = t), this.cb.call(this.scope));
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			);
		})(),
		Matrix$3 = (function () {
			function t(t, e, i, r, s, n) {
				void 0 === t && (t = 1),
					void 0 === e && (e = 0),
					void 0 === i && (i = 0),
					void 0 === r && (r = 1),
					void 0 === s && (s = 0),
					void 0 === n && (n = 0),
					(this.array = null),
					(this.a = t),
					(this.b = e),
					(this.c = i),
					(this.d = r),
					(this.tx = s),
					(this.ty = n);
			}
			return (
				(t.prototype.fromArray = function (t) {
					(this.a = t[0]),
						(this.b = t[1]),
						(this.c = t[3]),
						(this.d = t[4]),
						(this.tx = t[2]),
						(this.ty = t[5]);
				}),
				(t.prototype.set = function (t, e, i, r, s, n) {
					return (
						(this.a = t),
						(this.b = e),
						(this.c = i),
						(this.d = r),
						(this.tx = s),
						(this.ty = n),
						this
					);
				}),
				(t.prototype.toArray = function (t, e) {
					this.array || (this.array = new Float32Array(9));
					var i = e || this.array;
					return (
						t
							? ((i[0] = this.a),
							  (i[1] = this.b),
							  (i[2] = 0),
							  (i[3] = this.c),
							  (i[4] = this.d),
							  (i[5] = 0),
							  (i[6] = this.tx),
							  (i[7] = this.ty),
							  (i[8] = 1))
							: ((i[0] = this.a),
							  (i[1] = this.c),
							  (i[2] = this.tx),
							  (i[3] = this.b),
							  (i[4] = this.d),
							  (i[5] = this.ty),
							  (i[6] = 0),
							  (i[7] = 0),
							  (i[8] = 1)),
						i
					);
				}),
				(t.prototype.apply = function (t, e) {
					e = e || new Point$4();
					var i = t.x,
						r = t.y;
					return (
						(e.x = this.a * i + this.c * r + this.tx),
						(e.y = this.b * i + this.d * r + this.ty),
						e
					);
				}),
				(t.prototype.applyInverse = function (t, e) {
					e = e || new Point$4();
					var i = 1 / (this.a * this.d + this.c * -this.b),
						r = t.x,
						s = t.y;
					return (
						(e.x =
							this.d * i * r +
							-this.c * i * s +
							(this.ty * this.c - this.tx * this.d) * i),
						(e.y =
							this.a * i * s +
							-this.b * i * r +
							(-this.ty * this.a + this.tx * this.b) * i),
						e
					);
				}),
				(t.prototype.translate = function (t, e) {
					return (this.tx += t), (this.ty += e), this;
				}),
				(t.prototype.scale = function (t, e) {
					return (
						(this.a *= t),
						(this.d *= e),
						(this.c *= t),
						(this.b *= e),
						(this.tx *= t),
						(this.ty *= e),
						this
					);
				}),
				(t.prototype.rotate = function (t) {
					var e = Math.cos(t),
						i = Math.sin(t),
						r = this.a,
						s = this.c,
						n = this.tx;
					return (
						(this.a = r * e - this.b * i),
						(this.b = r * i + this.b * e),
						(this.c = s * e - this.d * i),
						(this.d = s * i + this.d * e),
						(this.tx = n * e - this.ty * i),
						(this.ty = n * i + this.ty * e),
						this
					);
				}),
				(t.prototype.append = function (t) {
					var e = this.a,
						i = this.b,
						r = this.c,
						s = this.d;
					return (
						(this.a = t.a * e + t.b * r),
						(this.b = t.a * i + t.b * s),
						(this.c = t.c * e + t.d * r),
						(this.d = t.c * i + t.d * s),
						(this.tx = t.tx * e + t.ty * r + this.tx),
						(this.ty = t.tx * i + t.ty * s + this.ty),
						this
					);
				}),
				(t.prototype.setTransform = function (t, e, i, r, s, n, a, o, h) {
					return (
						(this.a = Math.cos(a + h) * s),
						(this.b = Math.sin(a + h) * s),
						(this.c = -Math.sin(a - o) * n),
						(this.d = Math.cos(a - o) * n),
						(this.tx = t - (i * this.a + r * this.c)),
						(this.ty = e - (i * this.b + r * this.d)),
						this
					);
				}),
				(t.prototype.prepend = function (t) {
					var e = this.tx;
					if (1 !== t.a || 0 !== t.b || 0 !== t.c || 1 !== t.d) {
						var i = this.a,
							r = this.c;
						(this.a = i * t.a + this.b * t.c),
							(this.b = i * t.b + this.b * t.d),
							(this.c = r * t.a + this.d * t.c),
							(this.d = r * t.b + this.d * t.d);
					}
					return (
						(this.tx = e * t.a + this.ty * t.c + t.tx),
						(this.ty = e * t.b + this.ty * t.d + t.ty),
						this
					);
				}),
				(t.prototype.decompose = function (t) {
					var e = this.a,
						i = this.b,
						r = this.c,
						s = this.d,
						n = t.pivot,
						a = -Math.atan2(-r, s),
						o = Math.atan2(i, e),
						h = Math.abs(a + o);
					return (
						h < 1e-5 || Math.abs(PI_2$3 - h) < 1e-5
							? ((t.rotation = o), (t.skew.x = t.skew.y = 0))
							: ((t.rotation = 0), (t.skew.x = a), (t.skew.y = o)),
						(t.scale.x = Math.sqrt(e * e + i * i)),
						(t.scale.y = Math.sqrt(r * r + s * s)),
						(t.position.x = this.tx + (n.x * e + n.y * r)),
						(t.position.y = this.ty + (n.x * i + n.y * s)),
						t
					);
				}),
				(t.prototype.invert = function () {
					var t = this.a,
						e = this.b,
						i = this.c,
						r = this.d,
						s = this.tx,
						n = t * r - e * i;
					return (
						(this.a = r / n),
						(this.b = -e / n),
						(this.c = -i / n),
						(this.d = t / n),
						(this.tx = (i * this.ty - r * s) / n),
						(this.ty = -(t * this.ty - e * s) / n),
						this
					);
				}),
				(t.prototype.identity = function () {
					return (
						(this.a = 1),
						(this.b = 0),
						(this.c = 0),
						(this.d = 1),
						(this.tx = 0),
						(this.ty = 0),
						this
					);
				}),
				(t.prototype.clone = function () {
					var e = new t();
					return (
						(e.a = this.a),
						(e.b = this.b),
						(e.c = this.c),
						(e.d = this.d),
						(e.tx = this.tx),
						(e.ty = this.ty),
						e
					);
				}),
				(t.prototype.copyTo = function (t) {
					return (
						(t.a = this.a),
						(t.b = this.b),
						(t.c = this.c),
						(t.d = this.d),
						(t.tx = this.tx),
						(t.ty = this.ty),
						t
					);
				}),
				(t.prototype.copyFrom = function (t) {
					return (
						(this.a = t.a),
						(this.b = t.b),
						(this.c = t.c),
						(this.d = t.d),
						(this.tx = t.tx),
						(this.ty = t.ty),
						this
					);
				}),
				(t.prototype.toString = function () {
					return (
						'[@pixi/math:Matrix a=' +
						this.a +
						' b=' +
						this.b +
						' c=' +
						this.c +
						' d=' +
						this.d +
						' tx=' +
						this.tx +
						' ty=' +
						this.ty +
						']'
					);
				}),
				Object.defineProperty(t, 'IDENTITY', {
					get: function () {
						return new t();
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t, 'TEMP_MATRIX', {
					get: function () {
						return new t();
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			);
		})(),
		ux$3 = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1],
		uy$3 = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1],
		vx$3 = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1],
		vy$3 = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1],
		rotationCayley$3 = [],
		rotationMatrices$3 = [],
		signum$3 = Math.sign;
	function init$3() {
		for (var t = 0; t < 16; t++) {
			var e = [];
			rotationCayley$3.push(e);
			for (var i = 0; i < 16; i++)
				for (
					var r = signum$3(ux$3[t] * ux$3[i] + vx$3[t] * uy$3[i]),
						s = signum$3(uy$3[t] * ux$3[i] + vy$3[t] * uy$3[i]),
						n = signum$3(ux$3[t] * vx$3[i] + vx$3[t] * vy$3[i]),
						a = signum$3(uy$3[t] * vx$3[i] + vy$3[t] * vy$3[i]),
						o = 0;
					o < 16;
					o++
				)
					if (
						ux$3[o] === r &&
						uy$3[o] === s &&
						vx$3[o] === n &&
						vy$3[o] === a
					) {
						e.push(o);
						break;
					}
		}
		for (t = 0; t < 16; t++) {
			var h = new Matrix$3();
			h.set(ux$3[t], uy$3[t], vx$3[t], vy$3[t], 0, 0),
				rotationMatrices$3.push(h);
		}
	}
	init$3();
	var groupD8$3 = {
			E: 0,
			SE: 1,
			S: 2,
			SW: 3,
			W: 4,
			NW: 5,
			N: 6,
			NE: 7,
			MIRROR_VERTICAL: 8,
			MAIN_DIAGONAL: 10,
			MIRROR_HORIZONTAL: 12,
			REVERSE_DIAGONAL: 14,
			uX: function (t) {
				return ux$3[t];
			},
			uY: function (t) {
				return uy$3[t];
			},
			vX: function (t) {
				return vx$3[t];
			},
			vY: function (t) {
				return vy$3[t];
			},
			inv: function (t) {
				return 8 & t ? 15 & t : 7 & -t;
			},
			add: function (t, e) {
				return rotationCayley$3[t][e];
			},
			sub: function (t, e) {
				return rotationCayley$3[t][groupD8$3.inv(e)];
			},
			rotate180: function (t) {
				return 4 ^ t;
			},
			isVertical: function (t) {
				return 2 == (3 & t);
			},
			byDirection: function (t, e) {
				return 2 * Math.abs(t) <= Math.abs(e)
					? e >= 0
						? groupD8$3.S
						: groupD8$3.N
					: 2 * Math.abs(e) <= Math.abs(t)
					? t > 0
						? groupD8$3.E
						: groupD8$3.W
					: e > 0
					? t > 0
						? groupD8$3.SE
						: groupD8$3.SW
					: t > 0
					? groupD8$3.NE
					: groupD8$3.NW;
			},
			matrixAppendRotationInv: function (t, e, i, r) {
				void 0 === i && (i = 0), void 0 === r && (r = 0);
				var s = rotationMatrices$3[groupD8$3.inv(e)];
				(s.tx = i), (s.ty = r), t.append(s);
			},
		},
		Transform$1 = (function () {
			function t() {
				(this.worldTransform = new Matrix$3()),
					(this.localTransform = new Matrix$3()),
					(this.position = new ObservablePoint$3(this.onChange, this, 0, 0)),
					(this.scale = new ObservablePoint$3(this.onChange, this, 1, 1)),
					(this.pivot = new ObservablePoint$3(this.onChange, this, 0, 0)),
					(this.skew = new ObservablePoint$3(this.updateSkew, this, 0, 0)),
					(this._rotation = 0),
					(this._cx = 1),
					(this._sx = 0),
					(this._cy = 0),
					(this._sy = 1),
					(this._localID = 0),
					(this._currentLocalID = 0),
					(this._worldID = 0),
					(this._parentID = 0);
			}
			return (
				(t.prototype.onChange = function () {
					this._localID++;
				}),
				(t.prototype.updateSkew = function () {
					(this._cx = Math.cos(this._rotation + this.skew.y)),
						(this._sx = Math.sin(this._rotation + this.skew.y)),
						(this._cy = -Math.sin(this._rotation - this.skew.x)),
						(this._sy = Math.cos(this._rotation - this.skew.x)),
						this._localID++;
				}),
				(t.prototype.toString = function () {
					return (
						'[@pixi/math:Transform position=(' +
						this.position.x +
						', ' +
						this.position.y +
						') rotation=' +
						this.rotation +
						' scale=(' +
						this.scale.x +
						', ' +
						this.scale.y +
						') skew=(' +
						this.skew.x +
						', ' +
						this.skew.y +
						') ]'
					);
				}),
				(t.prototype.updateLocalTransform = function () {
					var t = this.localTransform;
					this._localID !== this._currentLocalID &&
						((t.a = this._cx * this.scale.x),
						(t.b = this._sx * this.scale.x),
						(t.c = this._cy * this.scale.y),
						(t.d = this._sy * this.scale.y),
						(t.tx =
							this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c)),
						(t.ty =
							this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d)),
						(this._currentLocalID = this._localID),
						(this._parentID = -1));
				}),
				(t.prototype.updateTransform = function (t) {
					var e = this.localTransform;
					if (
						(this._localID !== this._currentLocalID &&
							((e.a = this._cx * this.scale.x),
							(e.b = this._sx * this.scale.x),
							(e.c = this._cy * this.scale.y),
							(e.d = this._sy * this.scale.y),
							(e.tx =
								this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c)),
							(e.ty =
								this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d)),
							(this._currentLocalID = this._localID),
							(this._parentID = -1)),
						this._parentID !== t._worldID)
					) {
						var i = t.worldTransform,
							r = this.worldTransform;
						(r.a = e.a * i.a + e.b * i.c),
							(r.b = e.a * i.b + e.b * i.d),
							(r.c = e.c * i.a + e.d * i.c),
							(r.d = e.c * i.b + e.d * i.d),
							(r.tx = e.tx * i.a + e.ty * i.c + i.tx),
							(r.ty = e.tx * i.b + e.ty * i.d + i.ty),
							(this._parentID = t._worldID),
							this._worldID++;
					}
				}),
				(t.prototype.setFromMatrix = function (t) {
					t.decompose(this), this._localID++;
				}),
				Object.defineProperty(t.prototype, 'rotation', {
					get: function () {
						return this._rotation;
					},
					set: function (t) {
						this._rotation !== t && ((this._rotation = t), this.updateSkew());
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.IDENTITY = new t()),
				t
			);
		})(),
		Runner$3 = (function () {
			function t(t) {
				(this.items = []), (this._name = t), (this._aliasCount = 0);
			}
			return (
				(t.prototype.emit = function (t, e, i, r, s, n, a, o) {
					if (arguments.length > 8) throw new Error('max arguments reached');
					var h = this,
						u = h.name,
						l = h.items;
					this._aliasCount++;
					for (var c = 0, d = l.length; c < d; c++)
						l[c][u](t, e, i, r, s, n, a, o);
					return l === this.items && this._aliasCount--, this;
				}),
				(t.prototype.ensureNonAliasedItems = function () {
					this._aliasCount > 0 &&
						this.items.length > 1 &&
						((this._aliasCount = 0), (this.items = this.items.slice(0)));
				}),
				(t.prototype.add = function (t) {
					return (
						t[this._name] &&
							(this.ensureNonAliasedItems(),
							this.remove(t),
							this.items.push(t)),
						this
					);
				}),
				(t.prototype.remove = function (t) {
					var e = this.items.indexOf(t);
					return (
						-1 !== e && (this.ensureNonAliasedItems(), this.items.splice(e, 1)),
						this
					);
				}),
				(t.prototype.contains = function (t) {
					return -1 !== this.items.indexOf(t);
				}),
				(t.prototype.removeAll = function () {
					return this.ensureNonAliasedItems(), (this.items.length = 0), this;
				}),
				(t.prototype.destroy = function () {
					this.removeAll(), (this.items = null), (this._name = null);
				}),
				Object.defineProperty(t.prototype, 'empty', {
					get: function () {
						return 0 === this.items.length;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'name', {
					get: function () {
						return this._name;
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			);
		})();
	Object.defineProperties(Runner$3.prototype, {
		dispatch: { value: Runner$3.prototype.emit },
		run: { value: Runner$3.prototype.emit },
	});
	var appleIphone$1 = /iPhone/i,
		appleIpod$1 = /iPod/i,
		appleTablet$1 = /iPad/i,
		appleUniversal$1 = /\biOS-universal(?:.+)Mac\b/i,
		androidPhone$1 = /\bAndroid(?:.+)Mobile\b/i,
		androidTablet$1 = /Android/i,
		amazonPhone$1 = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i,
		amazonTablet$1 = /Silk/i,
		windowsPhone$1 = /Windows Phone/i,
		windowsTablet$1 = /\bWindows(?:.+)ARM\b/i,
		otherBlackBerry$1 = /BlackBerry/i,
		otherBlackBerry10$1 = /BB10/i,
		otherOpera$1 = /Opera Mini/i,
		otherChrome$1 = /\b(CriOS|Chrome)(?:.+)Mobile/i,
		otherFirefox$1 = /Mobile(?:.+)Firefox\b/i,
		isAppleTabletOnIos13$1 = function (t) {
			return (
				void 0 !== t &&
				'MacIntel' === t.platform &&
				'number' == typeof t.maxTouchPoints &&
				t.maxTouchPoints > 1 &&
				'undefined' == typeof MSStream
			);
		};
	function createMatch$1(t) {
		return function (e) {
			return e.test(t);
		};
	}
	function isMobile$4(t) {
		var e = { userAgent: '', platform: '', maxTouchPoints: 0 };
		t || 'undefined' == typeof navigator
			? 'string' == typeof t
				? (e.userAgent = t)
				: t &&
				  t.userAgent &&
				  (e = {
						userAgent: t.userAgent,
						platform: t.platform,
						maxTouchPoints: t.maxTouchPoints || 0,
				  })
			: (e = {
					userAgent: navigator.userAgent,
					platform: navigator.platform,
					maxTouchPoints: navigator.maxTouchPoints || 0,
			  });
		var i = e.userAgent,
			r = i.split('[FBAN');
		void 0 !== r[1] && (i = r[0]),
			void 0 !== (r = i.split('Twitter'))[1] && (i = r[0]);
		var s = createMatch$1(i),
			n = {
				apple: {
					phone: s(appleIphone$1) && !s(windowsPhone$1),
					ipod: s(appleIpod$1),
					tablet:
						!s(appleIphone$1) &&
						(s(appleTablet$1) || isAppleTabletOnIos13$1(e)) &&
						!s(windowsPhone$1),
					universal: s(appleUniversal$1),
					device:
						(s(appleIphone$1) ||
							s(appleIpod$1) ||
							s(appleTablet$1) ||
							s(appleUniversal$1) ||
							isAppleTabletOnIos13$1(e)) &&
						!s(windowsPhone$1),
				},
				amazon: {
					phone: s(amazonPhone$1),
					tablet: !s(amazonPhone$1) && s(amazonTablet$1),
					device: s(amazonPhone$1) || s(amazonTablet$1),
				},
				android: {
					phone:
						(!s(windowsPhone$1) && s(amazonPhone$1)) ||
						(!s(windowsPhone$1) && s(androidPhone$1)),
					tablet:
						!s(windowsPhone$1) &&
						!s(amazonPhone$1) &&
						!s(androidPhone$1) &&
						(s(amazonTablet$1) || s(androidTablet$1)),
					device:
						(!s(windowsPhone$1) &&
							(s(amazonPhone$1) ||
								s(amazonTablet$1) ||
								s(androidPhone$1) ||
								s(androidTablet$1))) ||
						s(/\bokhttp\b/i),
				},
				windows: {
					phone: s(windowsPhone$1),
					tablet: s(windowsTablet$1),
					device: s(windowsPhone$1) || s(windowsTablet$1),
				},
				other: {
					blackberry: s(otherBlackBerry$1),
					blackberry10: s(otherBlackBerry10$1),
					opera: s(otherOpera$1),
					firefox: s(otherFirefox$1),
					chrome: s(otherChrome$1),
					device:
						s(otherBlackBerry$1) ||
						s(otherBlackBerry10$1) ||
						s(otherOpera$1) ||
						s(otherFirefox$1) ||
						s(otherChrome$1),
				},
				any: !1,
				phone: !1,
				tablet: !1,
			};
		return (
			(n.any =
				n.apple.device ||
				n.android.device ||
				n.windows.device ||
				n.other.device),
			(n.phone = n.apple.phone || n.android.phone || n.windows.phone),
			(n.tablet = n.apple.tablet || n.android.tablet || n.windows.tablet),
			n
		);
	}
	/*!
	 * @pixi/settings - v6.4.2
	 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
	 *
	 * @pixi/settings is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 */ var isMobile$3 = isMobile$4(globalThis.navigator),
		ENV$8,
		RENDERER_TYPE$8,
		BUFFER_BITS$8,
		BLEND_MODES$8,
		DRAW_MODES$8,
		FORMATS$8,
		TARGETS$8,
		TYPES$8,
		SAMPLER_TYPES$8,
		SCALE_MODES$8,
		WRAP_MODES$8,
		MIPMAP_MODES$8,
		ALPHA_MODES$8,
		CLEAR_MODES$8,
		GC_MODES$8,
		PRECISION$8,
		MASK_TYPES$8,
		MSAA_QUALITY$8,
		BUFFER_TYPE$8;
	function maxRecommendedTextures$3(t) {
		var e,
			i = !0;
		(isMobile$3.tablet || isMobile$3.phone) &&
			(isMobile$3.apple.device &&
				(e = navigator.userAgent.match(/OS (\d+)_(\d+)?/)) &&
				parseInt(e[1], 10) < 11 &&
				(i = !1),
			isMobile$3.android.device &&
				(e = navigator.userAgent.match(/Android\s([0-9.]*)/)) &&
				parseInt(e[1], 10) < 7 &&
				(i = !1));
		return i ? t : 4;
	}
	function canUploadSameBuffer$3() {
		return !isMobile$3.apple.device;
	}
	/*!
	 * @pixi/constants - v6.4.2
	 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
	 *
	 * @pixi/constants is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 */ !(function (t) {
		(t[(t.WEBGL_LEGACY = 0)] = 'WEBGL_LEGACY'),
			(t[(t.WEBGL = 1)] = 'WEBGL'),
			(t[(t.WEBGL2 = 2)] = 'WEBGL2');
	})(ENV$8 || (ENV$8 = {})),
		(function (t) {
			(t[(t.UNKNOWN = 0)] = 'UNKNOWN'),
				(t[(t.WEBGL = 1)] = 'WEBGL'),
				(t[(t.CANVAS = 2)] = 'CANVAS');
		})(RENDERER_TYPE$8 || (RENDERER_TYPE$8 = {})),
		(function (t) {
			(t[(t.COLOR = 16384)] = 'COLOR'),
				(t[(t.DEPTH = 256)] = 'DEPTH'),
				(t[(t.STENCIL = 1024)] = 'STENCIL');
		})(BUFFER_BITS$8 || (BUFFER_BITS$8 = {})),
		(function (t) {
			(t[(t.NORMAL = 0)] = 'NORMAL'),
				(t[(t.ADD = 1)] = 'ADD'),
				(t[(t.MULTIPLY = 2)] = 'MULTIPLY'),
				(t[(t.SCREEN = 3)] = 'SCREEN'),
				(t[(t.OVERLAY = 4)] = 'OVERLAY'),
				(t[(t.DARKEN = 5)] = 'DARKEN'),
				(t[(t.LIGHTEN = 6)] = 'LIGHTEN'),
				(t[(t.COLOR_DODGE = 7)] = 'COLOR_DODGE'),
				(t[(t.COLOR_BURN = 8)] = 'COLOR_BURN'),
				(t[(t.HARD_LIGHT = 9)] = 'HARD_LIGHT'),
				(t[(t.SOFT_LIGHT = 10)] = 'SOFT_LIGHT'),
				(t[(t.DIFFERENCE = 11)] = 'DIFFERENCE'),
				(t[(t.EXCLUSION = 12)] = 'EXCLUSION'),
				(t[(t.HUE = 13)] = 'HUE'),
				(t[(t.SATURATION = 14)] = 'SATURATION'),
				(t[(t.COLOR = 15)] = 'COLOR'),
				(t[(t.LUMINOSITY = 16)] = 'LUMINOSITY'),
				(t[(t.NORMAL_NPM = 17)] = 'NORMAL_NPM'),
				(t[(t.ADD_NPM = 18)] = 'ADD_NPM'),
				(t[(t.SCREEN_NPM = 19)] = 'SCREEN_NPM'),
				(t[(t.NONE = 20)] = 'NONE'),
				(t[(t.SRC_OVER = 0)] = 'SRC_OVER'),
				(t[(t.SRC_IN = 21)] = 'SRC_IN'),
				(t[(t.SRC_OUT = 22)] = 'SRC_OUT'),
				(t[(t.SRC_ATOP = 23)] = 'SRC_ATOP'),
				(t[(t.DST_OVER = 24)] = 'DST_OVER'),
				(t[(t.DST_IN = 25)] = 'DST_IN'),
				(t[(t.DST_OUT = 26)] = 'DST_OUT'),
				(t[(t.DST_ATOP = 27)] = 'DST_ATOP'),
				(t[(t.ERASE = 26)] = 'ERASE'),
				(t[(t.SUBTRACT = 28)] = 'SUBTRACT'),
				(t[(t.XOR = 29)] = 'XOR');
		})(BLEND_MODES$8 || (BLEND_MODES$8 = {})),
		(function (t) {
			(t[(t.POINTS = 0)] = 'POINTS'),
				(t[(t.LINES = 1)] = 'LINES'),
				(t[(t.LINE_LOOP = 2)] = 'LINE_LOOP'),
				(t[(t.LINE_STRIP = 3)] = 'LINE_STRIP'),
				(t[(t.TRIANGLES = 4)] = 'TRIANGLES'),
				(t[(t.TRIANGLE_STRIP = 5)] = 'TRIANGLE_STRIP'),
				(t[(t.TRIANGLE_FAN = 6)] = 'TRIANGLE_FAN');
		})(DRAW_MODES$8 || (DRAW_MODES$8 = {})),
		(function (t) {
			(t[(t.RGBA = 6408)] = 'RGBA'),
				(t[(t.RGB = 6407)] = 'RGB'),
				(t[(t.RG = 33319)] = 'RG'),
				(t[(t.RED = 6403)] = 'RED'),
				(t[(t.RGBA_INTEGER = 36249)] = 'RGBA_INTEGER'),
				(t[(t.RGB_INTEGER = 36248)] = 'RGB_INTEGER'),
				(t[(t.RG_INTEGER = 33320)] = 'RG_INTEGER'),
				(t[(t.RED_INTEGER = 36244)] = 'RED_INTEGER'),
				(t[(t.ALPHA = 6406)] = 'ALPHA'),
				(t[(t.LUMINANCE = 6409)] = 'LUMINANCE'),
				(t[(t.LUMINANCE_ALPHA = 6410)] = 'LUMINANCE_ALPHA'),
				(t[(t.DEPTH_COMPONENT = 6402)] = 'DEPTH_COMPONENT'),
				(t[(t.DEPTH_STENCIL = 34041)] = 'DEPTH_STENCIL');
		})(FORMATS$8 || (FORMATS$8 = {})),
		(function (t) {
			(t[(t.TEXTURE_2D = 3553)] = 'TEXTURE_2D'),
				(t[(t.TEXTURE_CUBE_MAP = 34067)] = 'TEXTURE_CUBE_MAP'),
				(t[(t.TEXTURE_2D_ARRAY = 35866)] = 'TEXTURE_2D_ARRAY'),
				(t[(t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069)] =
					'TEXTURE_CUBE_MAP_POSITIVE_X'),
				(t[(t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070)] =
					'TEXTURE_CUBE_MAP_NEGATIVE_X'),
				(t[(t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071)] =
					'TEXTURE_CUBE_MAP_POSITIVE_Y'),
				(t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072)] =
					'TEXTURE_CUBE_MAP_NEGATIVE_Y'),
				(t[(t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073)] =
					'TEXTURE_CUBE_MAP_POSITIVE_Z'),
				(t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074)] =
					'TEXTURE_CUBE_MAP_NEGATIVE_Z');
		})(TARGETS$8 || (TARGETS$8 = {})),
		(function (t) {
			(t[(t.UNSIGNED_BYTE = 5121)] = 'UNSIGNED_BYTE'),
				(t[(t.UNSIGNED_SHORT = 5123)] = 'UNSIGNED_SHORT'),
				(t[(t.UNSIGNED_SHORT_5_6_5 = 33635)] = 'UNSIGNED_SHORT_5_6_5'),
				(t[(t.UNSIGNED_SHORT_4_4_4_4 = 32819)] = 'UNSIGNED_SHORT_4_4_4_4'),
				(t[(t.UNSIGNED_SHORT_5_5_5_1 = 32820)] = 'UNSIGNED_SHORT_5_5_5_1'),
				(t[(t.UNSIGNED_INT = 5125)] = 'UNSIGNED_INT'),
				(t[(t.UNSIGNED_INT_10F_11F_11F_REV = 35899)] =
					'UNSIGNED_INT_10F_11F_11F_REV'),
				(t[(t.UNSIGNED_INT_2_10_10_10_REV = 33640)] =
					'UNSIGNED_INT_2_10_10_10_REV'),
				(t[(t.UNSIGNED_INT_24_8 = 34042)] = 'UNSIGNED_INT_24_8'),
				(t[(t.UNSIGNED_INT_5_9_9_9_REV = 35902)] = 'UNSIGNED_INT_5_9_9_9_REV'),
				(t[(t.BYTE = 5120)] = 'BYTE'),
				(t[(t.SHORT = 5122)] = 'SHORT'),
				(t[(t.INT = 5124)] = 'INT'),
				(t[(t.FLOAT = 5126)] = 'FLOAT'),
				(t[(t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269)] =
					'FLOAT_32_UNSIGNED_INT_24_8_REV'),
				(t[(t.HALF_FLOAT = 36193)] = 'HALF_FLOAT');
		})(TYPES$8 || (TYPES$8 = {})),
		(function (t) {
			(t[(t.FLOAT = 0)] = 'FLOAT'),
				(t[(t.INT = 1)] = 'INT'),
				(t[(t.UINT = 2)] = 'UINT');
		})(SAMPLER_TYPES$8 || (SAMPLER_TYPES$8 = {})),
		(function (t) {
			(t[(t.NEAREST = 0)] = 'NEAREST'), (t[(t.LINEAR = 1)] = 'LINEAR');
		})(SCALE_MODES$8 || (SCALE_MODES$8 = {})),
		(function (t) {
			(t[(t.CLAMP = 33071)] = 'CLAMP'),
				(t[(t.REPEAT = 10497)] = 'REPEAT'),
				(t[(t.MIRRORED_REPEAT = 33648)] = 'MIRRORED_REPEAT');
		})(WRAP_MODES$8 || (WRAP_MODES$8 = {})),
		(function (t) {
			(t[(t.OFF = 0)] = 'OFF'),
				(t[(t.POW2 = 1)] = 'POW2'),
				(t[(t.ON = 2)] = 'ON'),
				(t[(t.ON_MANUAL = 3)] = 'ON_MANUAL');
		})(MIPMAP_MODES$8 || (MIPMAP_MODES$8 = {})),
		(function (t) {
			(t[(t.NPM = 0)] = 'NPM'),
				(t[(t.UNPACK = 1)] = 'UNPACK'),
				(t[(t.PMA = 2)] = 'PMA'),
				(t[(t.NO_PREMULTIPLIED_ALPHA = 0)] = 'NO_PREMULTIPLIED_ALPHA'),
				(t[(t.PREMULTIPLY_ON_UPLOAD = 1)] = 'PREMULTIPLY_ON_UPLOAD'),
				(t[(t.PREMULTIPLY_ALPHA = 2)] = 'PREMULTIPLY_ALPHA'),
				(t[(t.PREMULTIPLIED_ALPHA = 2)] = 'PREMULTIPLIED_ALPHA');
		})(ALPHA_MODES$8 || (ALPHA_MODES$8 = {})),
		(function (t) {
			(t[(t.NO = 0)] = 'NO'),
				(t[(t.YES = 1)] = 'YES'),
				(t[(t.AUTO = 2)] = 'AUTO'),
				(t[(t.BLEND = 0)] = 'BLEND'),
				(t[(t.CLEAR = 1)] = 'CLEAR'),
				(t[(t.BLIT = 2)] = 'BLIT');
		})(CLEAR_MODES$8 || (CLEAR_MODES$8 = {})),
		(function (t) {
			(t[(t.AUTO = 0)] = 'AUTO'), (t[(t.MANUAL = 1)] = 'MANUAL');
		})(GC_MODES$8 || (GC_MODES$8 = {})),
		(function (t) {
			(t.LOW = 'lowp'), (t.MEDIUM = 'mediump'), (t.HIGH = 'highp');
		})(PRECISION$8 || (PRECISION$8 = {})),
		(function (t) {
			(t[(t.NONE = 0)] = 'NONE'),
				(t[(t.SCISSOR = 1)] = 'SCISSOR'),
				(t[(t.STENCIL = 2)] = 'STENCIL'),
				(t[(t.SPRITE = 3)] = 'SPRITE');
		})(MASK_TYPES$8 || (MASK_TYPES$8 = {})),
		(function (t) {
			(t[(t.NONE = 0)] = 'NONE'),
				(t[(t.LOW = 2)] = 'LOW'),
				(t[(t.MEDIUM = 4)] = 'MEDIUM'),
				(t[(t.HIGH = 8)] = 'HIGH');
		})(MSAA_QUALITY$8 || (MSAA_QUALITY$8 = {})),
		(function (t) {
			(t[(t.ELEMENT_ARRAY_BUFFER = 34963)] = 'ELEMENT_ARRAY_BUFFER'),
				(t[(t.ARRAY_BUFFER = 34962)] = 'ARRAY_BUFFER'),
				(t[(t.UNIFORM_BUFFER = 35345)] = 'UNIFORM_BUFFER');
		})(BUFFER_TYPE$8 || (BUFFER_TYPE$8 = {}));
	var settings$4 = {
			MIPMAP_TEXTURES: MIPMAP_MODES$8.POW2,
			ANISOTROPIC_LEVEL: 0,
			RESOLUTION: 1,
			FILTER_RESOLUTION: 1,
			FILTER_MULTISAMPLE: MSAA_QUALITY$8.NONE,
			SPRITE_MAX_TEXTURES: maxRecommendedTextures$3(32),
			SPRITE_BATCH_SIZE: 4096,
			RENDER_OPTIONS: {
				view: null,
				antialias: !1,
				autoDensity: !1,
				backgroundColor: 0,
				backgroundAlpha: 1,
				useContextAlpha: !0,
				clearBeforeRender: !0,
				preserveDrawingBuffer: !1,
				width: 800,
				height: 600,
				legacy: !1,
			},
			GC_MODE: GC_MODES$8.AUTO,
			GC_MAX_IDLE: 3600,
			GC_MAX_CHECK_COUNT: 600,
			WRAP_MODE: WRAP_MODES$8.CLAMP,
			SCALE_MODE: SCALE_MODES$8.LINEAR,
			PRECISION_VERTEX: PRECISION$8.HIGH,
			PRECISION_FRAGMENT: isMobile$3.apple.device
				? PRECISION$8.HIGH
				: PRECISION$8.MEDIUM,
			CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer$3(),
			CREATE_IMAGE_BITMAP: !1,
			ROUND_PIXELS: !1,
		},
		UPDATE_PRIORITY$3,
		UPDATE_PRIORITY2;
	/*!
	 * @pixi/ticker - v6.4.2
	 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
	 *
	 * @pixi/ticker is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 */ (settings$4.TARGET_FPMS = 0.06),
		(UPDATE_PRIORITY2 = UPDATE_PRIORITY$3 || (UPDATE_PRIORITY$3 = {})),
		(UPDATE_PRIORITY2[(UPDATE_PRIORITY2.INTERACTION = 50)] = 'INTERACTION'),
		(UPDATE_PRIORITY2[(UPDATE_PRIORITY2.HIGH = 25)] = 'HIGH'),
		(UPDATE_PRIORITY2[(UPDATE_PRIORITY2.NORMAL = 0)] = 'NORMAL'),
		(UPDATE_PRIORITY2[(UPDATE_PRIORITY2.LOW = -25)] = 'LOW'),
		(UPDATE_PRIORITY2[(UPDATE_PRIORITY2.UTILITY = -50)] = 'UTILITY');
	var TickerListener$3 = (function () {
			function t(t, e, i, r) {
				void 0 === e && (e = null),
					void 0 === i && (i = 0),
					void 0 === r && (r = !1),
					(this.next = null),
					(this.previous = null),
					(this._destroyed = !1),
					(this.fn = t),
					(this.context = e),
					(this.priority = i),
					(this.once = r);
			}
			return (
				(t.prototype.match = function (t, e) {
					return (
						void 0 === e && (e = null), this.fn === t && this.context === e
					);
				}),
				(t.prototype.emit = function (t) {
					this.fn &&
						(this.context ? this.fn.call(this.context, t) : this.fn(t));
					var e = this.next;
					return (
						this.once && this.destroy(!0),
						this._destroyed && (this.next = null),
						e
					);
				}),
				(t.prototype.connect = function (t) {
					(this.previous = t),
						t.next && (t.next.previous = this),
						(this.next = t.next),
						(t.next = this);
				}),
				(t.prototype.destroy = function (t) {
					void 0 === t && (t = !1),
						(this._destroyed = !0),
						(this.fn = null),
						(this.context = null),
						this.previous && (this.previous.next = this.next),
						this.next && (this.next.previous = this.previous);
					var e = this.next;
					return (this.next = t ? null : e), (this.previous = null), e;
				}),
				t
			);
		})(),
		Ticker$3 = (function () {
			function t() {
				var t = this;
				(this.autoStart = !1),
					(this.deltaTime = 1),
					(this.lastTime = -1),
					(this.speed = 1),
					(this.started = !1),
					(this._requestId = null),
					(this._maxElapsedMS = 100),
					(this._minElapsedMS = 0),
					(this._protected = !1),
					(this._lastFrame = -1),
					(this._head = new TickerListener$3(null, null, 1 / 0)),
					(this.deltaMS = 1 / settings$4.TARGET_FPMS),
					(this.elapsedMS = 1 / settings$4.TARGET_FPMS),
					(this._tick = function (e) {
						(t._requestId = null),
							t.started &&
								(t.update(e),
								t.started &&
									null === t._requestId &&
									t._head.next &&
									(t._requestId = requestAnimationFrame(t._tick)));
					});
			}
			return (
				(t.prototype._requestIfNeeded = function () {
					null === this._requestId &&
						this._head.next &&
						((this.lastTime = performance.now()),
						(this._lastFrame = this.lastTime),
						(this._requestId = requestAnimationFrame(this._tick)));
				}),
				(t.prototype._cancelIfNeeded = function () {
					null !== this._requestId &&
						(cancelAnimationFrame(this._requestId), (this._requestId = null));
				}),
				(t.prototype._startIfPossible = function () {
					this.started
						? this._requestIfNeeded()
						: this.autoStart && this.start();
				}),
				(t.prototype.add = function (t, e, i) {
					return (
						void 0 === i && (i = UPDATE_PRIORITY$3.NORMAL),
						this._addListener(new TickerListener$3(t, e, i))
					);
				}),
				(t.prototype.addOnce = function (t, e, i) {
					return (
						void 0 === i && (i = UPDATE_PRIORITY$3.NORMAL),
						this._addListener(new TickerListener$3(t, e, i, !0))
					);
				}),
				(t.prototype._addListener = function (t) {
					var e = this._head.next,
						i = this._head;
					if (e) {
						for (; e; ) {
							if (t.priority > e.priority) {
								t.connect(i);
								break;
							}
							(i = e), (e = e.next);
						}
						t.previous || t.connect(i);
					} else t.connect(i);
					return this._startIfPossible(), this;
				}),
				(t.prototype.remove = function (t, e) {
					for (var i = this._head.next; i; )
						i = i.match(t, e) ? i.destroy() : i.next;
					return this._head.next || this._cancelIfNeeded(), this;
				}),
				Object.defineProperty(t.prototype, 'count', {
					get: function () {
						if (!this._head) return 0;
						for (var t = 0, e = this._head; (e = e.next); ) t++;
						return t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.start = function () {
					this.started || ((this.started = !0), this._requestIfNeeded());
				}),
				(t.prototype.stop = function () {
					this.started && ((this.started = !1), this._cancelIfNeeded());
				}),
				(t.prototype.destroy = function () {
					if (!this._protected) {
						this.stop();
						for (var t = this._head.next; t; ) t = t.destroy(!0);
						this._head.destroy(), (this._head = null);
					}
				}),
				(t.prototype.update = function (t) {
					var e;
					if ((void 0 === t && (t = performance.now()), t > this.lastTime)) {
						if (
							((e = this.elapsedMS = t - this.lastTime) > this._maxElapsedMS &&
								(e = this._maxElapsedMS),
							(e *= this.speed),
							this._minElapsedMS)
						) {
							var i = (t - this._lastFrame) | 0;
							if (i < this._minElapsedMS) return;
							this._lastFrame = t - (i % this._minElapsedMS);
						}
						(this.deltaMS = e),
							(this.deltaTime = this.deltaMS * settings$4.TARGET_FPMS);
						for (var r = this._head, s = r.next; s; )
							s = s.emit(this.deltaTime);
						r.next || this._cancelIfNeeded();
					} else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
					this.lastTime = t;
				}),
				Object.defineProperty(t.prototype, 'FPS', {
					get: function () {
						return 1e3 / this.elapsedMS;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'minFPS', {
					get: function () {
						return 1e3 / this._maxElapsedMS;
					},
					set: function (t) {
						var e = Math.min(this.maxFPS, t),
							i = Math.min(Math.max(0, e) / 1e3, settings$4.TARGET_FPMS);
						this._maxElapsedMS = 1 / i;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'maxFPS', {
					get: function () {
						return this._minElapsedMS
							? Math.round(1e3 / this._minElapsedMS)
							: 0;
					},
					set: function (t) {
						if (0 === t) this._minElapsedMS = 0;
						else {
							var e = Math.max(this.minFPS, t);
							this._minElapsedMS = 1 / (e / 1e3);
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t, 'shared', {
					get: function () {
						if (!t._shared) {
							var e = (t._shared = new t());
							(e.autoStart = !0), (e._protected = !0);
						}
						return t._shared;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t, 'system', {
					get: function () {
						if (!t._system) {
							var e = (t._system = new t());
							(e.autoStart = !0), (e._protected = !0);
						}
						return t._system;
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			);
		})(),
		TickerPlugin = (function () {
			function t() {}
			return (
				(t.init = function (t) {
					var e = this;
					(t = Object.assign({ autoStart: !0, sharedTicker: !1 }, t)),
						Object.defineProperty(this, 'ticker', {
							set: function (t) {
								this._ticker && this._ticker.remove(this.render, this),
									(this._ticker = t),
									t && t.add(this.render, this, UPDATE_PRIORITY$3.LOW);
							},
							get: function () {
								return this._ticker;
							},
						}),
						(this.stop = function () {
							e._ticker.stop();
						}),
						(this.start = function () {
							e._ticker.start();
						}),
						(this._ticker = null),
						(this.ticker = t.sharedTicker ? Ticker$3.shared : new Ticker$3()),
						t.autoStart && this.start();
				}),
				(t.destroy = function () {
					if (this._ticker) {
						var t = this._ticker;
						(this.ticker = null), t.destroy();
					}
				}),
				t
			);
		})();
	function createCommonjsModule$4(t, e, i) {
		return (
			t(
				(i = {
					path: e,
					exports: {},
					require: function (t, e) {
						return commonjsRequire$3(t, null == e ? i.path : e);
					},
				}),
				i.exports
			),
			i.exports
		);
	}
	function commonjsRequire$3() {
		throw new Error(
			'Dynamic requires are not currently supported by @rollup/plugin-commonjs'
		);
	}
	var eventemitter3$1 = createCommonjsModule$4(function (t) {
		var e = Object.prototype.hasOwnProperty,
			i = '~';
		function r() {}
		function s(t, e, i) {
			(this.fn = t), (this.context = e), (this.once = i || !1);
		}
		function n(t, e, r, n, a) {
			if ('function' != typeof r)
				throw new TypeError('The listener must be a function');
			var o = new s(r, n || t, a),
				h = i ? i + e : e;
			return (
				t._events[h]
					? t._events[h].fn
						? (t._events[h] = [t._events[h], o])
						: t._events[h].push(o)
					: ((t._events[h] = o), t._eventsCount++),
				t
			);
		}
		function a(t, e) {
			0 == --t._eventsCount ? (t._events = new r()) : delete t._events[e];
		}
		function o() {
			(this._events = new r()), (this._eventsCount = 0);
		}
		Object.create &&
			((r.prototype = Object.create(null)), new r().__proto__ || (i = !1)),
			(o.prototype.eventNames = function () {
				var t,
					r,
					s = [];
				if (0 === this._eventsCount) return s;
				for (r in (t = this._events))
					e.call(t, r) && s.push(i ? r.slice(1) : r);
				return Object.getOwnPropertySymbols
					? s.concat(Object.getOwnPropertySymbols(t))
					: s;
			}),
			(o.prototype.listeners = function (t) {
				var e = i ? i + t : t,
					r = this._events[e];
				if (!r) return [];
				if (r.fn) return [r.fn];
				for (var s = 0, n = r.length, a = new Array(n); s < n; s++)
					a[s] = r[s].fn;
				return a;
			}),
			(o.prototype.listenerCount = function (t) {
				var e = i ? i + t : t,
					r = this._events[e];
				return r ? (r.fn ? 1 : r.length) : 0;
			}),
			(o.prototype.emit = function (t, e, r, s, n, a) {
				var o = i ? i + t : t;
				if (!this._events[o]) return !1;
				var h,
					u,
					l = this._events[o],
					c = arguments.length;
				if (l.fn) {
					switch ((l.once && this.removeListener(t, l.fn, void 0, !0), c)) {
						case 1:
							return l.fn.call(l.context), !0;
						case 2:
							return l.fn.call(l.context, e), !0;
						case 3:
							return l.fn.call(l.context, e, r), !0;
						case 4:
							return l.fn.call(l.context, e, r, s), !0;
						case 5:
							return l.fn.call(l.context, e, r, s, n), !0;
						case 6:
							return l.fn.call(l.context, e, r, s, n, a), !0;
					}
					for (u = 1, h = new Array(c - 1); u < c; u++) h[u - 1] = arguments[u];
					l.fn.apply(l.context, h);
				} else {
					var d,
						p = l.length;
					for (u = 0; u < p; u++)
						switch (
							(l[u].once && this.removeListener(t, l[u].fn, void 0, !0), c)
						) {
							case 1:
								l[u].fn.call(l[u].context);
								break;
							case 2:
								l[u].fn.call(l[u].context, e);
								break;
							case 3:
								l[u].fn.call(l[u].context, e, r);
								break;
							case 4:
								l[u].fn.call(l[u].context, e, r, s);
								break;
							default:
								if (!h)
									for (d = 1, h = new Array(c - 1); d < c; d++)
										h[d - 1] = arguments[d];
								l[u].fn.apply(l[u].context, h);
						}
				}
				return !0;
			}),
			(o.prototype.on = function (t, e, i) {
				return n(this, t, e, i, !1);
			}),
			(o.prototype.once = function (t, e, i) {
				return n(this, t, e, i, !0);
			}),
			(o.prototype.removeListener = function (t, e, r, s) {
				var n = i ? i + t : t;
				if (!this._events[n]) return this;
				if (!e) return a(this, n), this;
				var o = this._events[n];
				if (o.fn)
					o.fn !== e || (s && !o.once) || (r && o.context !== r) || a(this, n);
				else {
					for (var h = 0, u = [], l = o.length; h < l; h++)
						(o[h].fn !== e || (s && !o[h].once) || (r && o[h].context !== r)) &&
							u.push(o[h]);
					u.length ? (this._events[n] = 1 === u.length ? u[0] : u) : a(this, n);
				}
				return this;
			}),
			(o.prototype.removeAllListeners = function (t) {
				var e;
				return (
					t
						? ((e = i ? i + t : t), this._events[e] && a(this, e))
						: ((this._events = new r()), (this._eventsCount = 0)),
					this
				);
			}),
			(o.prototype.off = o.prototype.removeListener),
			(o.prototype.addListener = o.prototype.on),
			(o.prefixed = i),
			(o.EventEmitter = o),
			(t.exports = o);
	});
	eventemitter3$1.EventEmitter, eventemitter3$1.prefixed;
	var earcut_1 = earcut,
		_default = earcut;
	function earcut(t, e, i) {
		i = i || 2;
		var r,
			s,
			n,
			a,
			o,
			h,
			u,
			l = e && e.length,
			c = l ? e[0] * i : t.length,
			d = linkedList(t, 0, c, i, !0),
			p = [];
		if (!d || d.next === d.prev) return p;
		if ((l && (d = eliminateHoles(t, e, d, i)), t.length > 80 * i)) {
			(r = n = t[0]), (s = a = t[1]);
			for (var f = i; f < c; f += i)
				(o = t[f]) < r && (r = o),
					(h = t[f + 1]) < s && (s = h),
					o > n && (n = o),
					h > a && (a = h);
			u = 0 !== (u = Math.max(n - r, a - s)) ? 1 / u : 0;
		}
		return earcutLinked(d, p, i, r, s, u), p;
	}
	function linkedList(t, e, i, r, s) {
		var n, a;
		if (s === signedArea(t, e, i, r) > 0)
			for (n = e; n < i; n += r) a = insertNode(n, t[n], t[n + 1], a);
		else for (n = i - r; n >= e; n -= r) a = insertNode(n, t[n], t[n + 1], a);
		return a && equals(a, a.next) && (removeNode(a), (a = a.next)), a;
	}
	function filterPoints(t, e) {
		if (!t) return t;
		e || (e = t);
		var i,
			r = t;
		do {
			if (
				((i = !1),
				r.steiner || (!equals(r, r.next) && 0 !== area(r.prev, r, r.next)))
			)
				r = r.next;
			else {
				if ((removeNode(r), (r = e = r.prev) === r.next)) break;
				i = !0;
			}
		} while (i || r !== e);
		return e;
	}
	function earcutLinked(t, e, i, r, s, n, a) {
		if (t) {
			!a && n && indexCurve(t, r, s, n);
			for (var o, h, u = t; t.prev !== t.next; )
				if (
					((o = t.prev), (h = t.next), n ? isEarHashed(t, r, s, n) : isEar(t))
				)
					e.push(o.i / i),
						e.push(t.i / i),
						e.push(h.i / i),
						removeNode(t),
						(t = h.next),
						(u = h.next);
				else if ((t = h) === u) {
					a
						? 1 === a
							? earcutLinked(
									(t = cureLocalIntersections(filterPoints(t), e, i)),
									e,
									i,
									r,
									s,
									n,
									2
							  )
							: 2 === a && splitEarcut(t, e, i, r, s, n)
						: earcutLinked(filterPoints(t), e, i, r, s, n, 1);
					break;
				}
		}
	}
	function isEar(t) {
		var e = t.prev,
			i = t,
			r = t.next;
		if (area(e, i, r) >= 0) return !1;
		for (var s = t.next.next; s !== t.prev; ) {
			if (
				pointInTriangle(e.x, e.y, i.x, i.y, r.x, r.y, s.x, s.y) &&
				area(s.prev, s, s.next) >= 0
			)
				return !1;
			s = s.next;
		}
		return !0;
	}
	function isEarHashed(t, e, i, r) {
		var s = t.prev,
			n = t,
			a = t.next;
		if (area(s, n, a) >= 0) return !1;
		for (
			var o = s.x < n.x ? (s.x < a.x ? s.x : a.x) : n.x < a.x ? n.x : a.x,
				h = s.y < n.y ? (s.y < a.y ? s.y : a.y) : n.y < a.y ? n.y : a.y,
				u = s.x > n.x ? (s.x > a.x ? s.x : a.x) : n.x > a.x ? n.x : a.x,
				l = s.y > n.y ? (s.y > a.y ? s.y : a.y) : n.y > a.y ? n.y : a.y,
				c = zOrder(o, h, e, i, r),
				d = zOrder(u, l, e, i, r),
				p = t.prevZ,
				f = t.nextZ;
			p && p.z >= c && f && f.z <= d;

		) {
			if (
				p !== t.prev &&
				p !== t.next &&
				pointInTriangle(s.x, s.y, n.x, n.y, a.x, a.y, p.x, p.y) &&
				area(p.prev, p, p.next) >= 0
			)
				return !1;
			if (
				((p = p.prevZ),
				f !== t.prev &&
					f !== t.next &&
					pointInTriangle(s.x, s.y, n.x, n.y, a.x, a.y, f.x, f.y) &&
					area(f.prev, f, f.next) >= 0)
			)
				return !1;
			f = f.nextZ;
		}
		for (; p && p.z >= c; ) {
			if (
				p !== t.prev &&
				p !== t.next &&
				pointInTriangle(s.x, s.y, n.x, n.y, a.x, a.y, p.x, p.y) &&
				area(p.prev, p, p.next) >= 0
			)
				return !1;
			p = p.prevZ;
		}
		for (; f && f.z <= d; ) {
			if (
				f !== t.prev &&
				f !== t.next &&
				pointInTriangle(s.x, s.y, n.x, n.y, a.x, a.y, f.x, f.y) &&
				area(f.prev, f, f.next) >= 0
			)
				return !1;
			f = f.nextZ;
		}
		return !0;
	}
	function cureLocalIntersections(t, e, i) {
		var r = t;
		do {
			var s = r.prev,
				n = r.next.next;
			!equals(s, n) &&
				intersects(s, r, r.next, n) &&
				locallyInside(s, n) &&
				locallyInside(n, s) &&
				(e.push(s.i / i),
				e.push(r.i / i),
				e.push(n.i / i),
				removeNode(r),
				removeNode(r.next),
				(r = t = n)),
				(r = r.next);
		} while (r !== t);
		return filterPoints(r);
	}
	function splitEarcut(t, e, i, r, s, n) {
		var a = t;
		do {
			for (var o = a.next.next; o !== a.prev; ) {
				if (a.i !== o.i && isValidDiagonal(a, o)) {
					var h = splitPolygon(a, o);
					return (
						(a = filterPoints(a, a.next)),
						(h = filterPoints(h, h.next)),
						earcutLinked(a, e, i, r, s, n),
						void earcutLinked(h, e, i, r, s, n)
					);
				}
				o = o.next;
			}
			a = a.next;
		} while (a !== t);
	}
	function eliminateHoles(t, e, i, r) {
		var s,
			n,
			a,
			o = [];
		for (s = 0, n = e.length; s < n; s++)
			(a = linkedList(
				t,
				e[s] * r,
				s < n - 1 ? e[s + 1] * r : t.length,
				r,
				!1
			)) === a.next && (a.steiner = !0),
				o.push(getLeftmost(a));
		for (o.sort(compareX), s = 0; s < o.length; s++)
			i = filterPoints((i = eliminateHole(o[s], i)), i.next);
		return i;
	}
	function compareX(t, e) {
		return t.x - e.x;
	}
	function eliminateHole(t, e) {
		var i = findHoleBridge(t, e);
		if (!i) return e;
		var r = splitPolygon(i, t),
			s = filterPoints(i, i.next);
		return filterPoints(r, r.next), e === i ? s : e;
	}
	function findHoleBridge(t, e) {
		var i,
			r = e,
			s = t.x,
			n = t.y,
			a = -1 / 0;
		do {
			if (n <= r.y && n >= r.next.y && r.next.y !== r.y) {
				var o = r.x + ((n - r.y) * (r.next.x - r.x)) / (r.next.y - r.y);
				if (o <= s && o > a) {
					if (((a = o), o === s)) {
						if (n === r.y) return r;
						if (n === r.next.y) return r.next;
					}
					i = r.x < r.next.x ? r : r.next;
				}
			}
			r = r.next;
		} while (r !== e);
		if (!i) return null;
		if (s === a) return i;
		var h,
			u = i,
			l = i.x,
			c = i.y,
			d = 1 / 0;
		r = i;
		do {
			s >= r.x &&
				r.x >= l &&
				s !== r.x &&
				pointInTriangle(n < c ? s : a, n, l, c, n < c ? a : s, n, r.x, r.y) &&
				((h = Math.abs(n - r.y) / (s - r.x)),
				locallyInside(r, t) &&
					(h < d ||
						(h === d &&
							(r.x > i.x || (r.x === i.x && sectorContainsSector(i, r))))) &&
					((i = r), (d = h))),
				(r = r.next);
		} while (r !== u);
		return i;
	}
	function sectorContainsSector(t, e) {
		return area(t.prev, t, e.prev) < 0 && area(e.next, t, t.next) < 0;
	}
	function indexCurve(t, e, i, r) {
		var s = t;
		do {
			null === s.z && (s.z = zOrder(s.x, s.y, e, i, r)),
				(s.prevZ = s.prev),
				(s.nextZ = s.next),
				(s = s.next);
		} while (s !== t);
		(s.prevZ.nextZ = null), (s.prevZ = null), sortLinked(s);
	}
	function sortLinked(t) {
		var e,
			i,
			r,
			s,
			n,
			a,
			o,
			h,
			u = 1;
		do {
			for (i = t, t = null, n = null, a = 0; i; ) {
				for (a++, r = i, o = 0, e = 0; e < u && (o++, (r = r.nextZ)); e++);
				for (h = u; o > 0 || (h > 0 && r); )
					0 !== o && (0 === h || !r || i.z <= r.z)
						? ((s = i), (i = i.nextZ), o--)
						: ((s = r), (r = r.nextZ), h--),
						n ? (n.nextZ = s) : (t = s),
						(s.prevZ = n),
						(n = s);
				i = r;
			}
			(n.nextZ = null), (u *= 2);
		} while (a > 1);
		return t;
	}
	function zOrder(t, e, i, r, s) {
		return (
			(t =
				1431655765 &
				((t =
					858993459 &
					((t =
						252645135 &
						((t = 16711935 & ((t = 32767 * (t - i) * s) | (t << 8))) |
							(t << 4))) |
						(t << 2))) |
					(t << 1))) |
			((e =
				1431655765 &
				((e =
					858993459 &
					((e =
						252645135 &
						((e = 16711935 & ((e = 32767 * (e - r) * s) | (e << 8))) |
							(e << 4))) |
						(e << 2))) |
					(e << 1))) <<
				1)
		);
	}
	function getLeftmost(t) {
		var e = t,
			i = t;
		do {
			(e.x < i.x || (e.x === i.x && e.y < i.y)) && (i = e), (e = e.next);
		} while (e !== t);
		return i;
	}
	function pointInTriangle(t, e, i, r, s, n, a, o) {
		return (
			(s - a) * (e - o) - (t - a) * (n - o) >= 0 &&
			(t - a) * (r - o) - (i - a) * (e - o) >= 0 &&
			(i - a) * (n - o) - (s - a) * (r - o) >= 0
		);
	}
	function isValidDiagonal(t, e) {
		return (
			t.next.i !== e.i &&
			t.prev.i !== e.i &&
			!intersectsPolygon(t, e) &&
			((locallyInside(t, e) &&
				locallyInside(e, t) &&
				middleInside(t, e) &&
				(area(t.prev, t, e.prev) || area(t, e.prev, e))) ||
				(equals(t, e) &&
					area(t.prev, t, t.next) > 0 &&
					area(e.prev, e, e.next) > 0))
		);
	}
	function area(t, e, i) {
		return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y);
	}
	function equals(t, e) {
		return t.x === e.x && t.y === e.y;
	}
	function intersects(t, e, i, r) {
		var s = sign$1(area(t, e, i)),
			n = sign$1(area(t, e, r)),
			a = sign$1(area(i, r, t)),
			o = sign$1(area(i, r, e));
		return (
			(s !== n && a !== o) ||
			!(0 !== s || !onSegment(t, i, e)) ||
			!(0 !== n || !onSegment(t, r, e)) ||
			!(0 !== a || !onSegment(i, t, r)) ||
			!(0 !== o || !onSegment(i, e, r))
		);
	}
	function onSegment(t, e, i) {
		return (
			e.x <= Math.max(t.x, i.x) &&
			e.x >= Math.min(t.x, i.x) &&
			e.y <= Math.max(t.y, i.y) &&
			e.y >= Math.min(t.y, i.y)
		);
	}
	function sign$1(t) {
		return t > 0 ? 1 : t < 0 ? -1 : 0;
	}
	function intersectsPolygon(t, e) {
		var i = t;
		do {
			if (
				i.i !== t.i &&
				i.next.i !== t.i &&
				i.i !== e.i &&
				i.next.i !== e.i &&
				intersects(i, i.next, t, e)
			)
				return !0;
			i = i.next;
		} while (i !== t);
		return !1;
	}
	function locallyInside(t, e) {
		return area(t.prev, t, t.next) < 0
			? area(t, e, t.next) >= 0 && area(t, t.prev, e) >= 0
			: area(t, e, t.prev) < 0 || area(t, t.next, e) < 0;
	}
	function middleInside(t, e) {
		var i = t,
			r = !1,
			s = (t.x + e.x) / 2,
			n = (t.y + e.y) / 2;
		do {
			i.y > n != i.next.y > n &&
				i.next.y !== i.y &&
				s < ((i.next.x - i.x) * (n - i.y)) / (i.next.y - i.y) + i.x &&
				(r = !r),
				(i = i.next);
		} while (i !== t);
		return r;
	}
	function splitPolygon(t, e) {
		var i = new Node(t.i, t.x, t.y),
			r = new Node(e.i, e.x, e.y),
			s = t.next,
			n = e.prev;
		return (
			(t.next = e),
			(e.prev = t),
			(i.next = s),
			(s.prev = i),
			(r.next = i),
			(i.prev = r),
			(n.next = r),
			(r.prev = n),
			r
		);
	}
	function insertNode(t, e, i, r) {
		var s = new Node(t, e, i);
		return (
			r
				? ((s.next = r.next), (s.prev = r), (r.next.prev = s), (r.next = s))
				: ((s.prev = s), (s.next = s)),
			s
		);
	}
	function removeNode(t) {
		(t.next.prev = t.prev),
			(t.prev.next = t.next),
			t.prevZ && (t.prevZ.nextZ = t.nextZ),
			t.nextZ && (t.nextZ.prevZ = t.prevZ);
	}
	function Node(t, e, i) {
		(this.i = t),
			(this.x = e),
			(this.y = i),
			(this.prev = null),
			(this.next = null),
			(this.z = null),
			(this.prevZ = null),
			(this.nextZ = null),
			(this.steiner = !1);
	}
	function signedArea(t, e, i, r) {
		for (var s = 0, n = e, a = i - r; n < i; n += r)
			(s += (t[a] - t[n]) * (t[n + 1] + t[a + 1])), (a = n);
		return s;
	}
	(earcut.deviation = function (t, e, i, r) {
		var s = e && e.length,
			n = s ? e[0] * i : t.length,
			a = Math.abs(signedArea(t, 0, n, i));
		if (s)
			for (var o = 0, h = e.length; o < h; o++) {
				var u = e[o] * i,
					l = o < h - 1 ? e[o + 1] * i : t.length;
				a -= Math.abs(signedArea(t, u, l, i));
			}
		var c = 0;
		for (o = 0; o < r.length; o += 3) {
			var d = r[o] * i,
				p = r[o + 1] * i,
				f = r[o + 2] * i;
			c += Math.abs(
				(t[d] - t[f]) * (t[p + 1] - t[d + 1]) -
					(t[d] - t[p]) * (t[f + 1] - t[d + 1])
			);
		}
		return 0 === a && 0 === c ? 0 : Math.abs((c - a) / a);
	}),
		(earcut.flatten = function (t) {
			for (
				var e = t[0][0].length,
					i = { vertices: [], holes: [], dimensions: e },
					r = 0,
					s = 0;
				s < t.length;
				s++
			) {
				for (var n = 0; n < t[s].length; n++)
					for (var a = 0; a < e; a++) i.vertices.push(t[s][n][a]);
				s > 0 && ((r += t[s - 1].length), i.holes.push(r));
			}
			return i;
		}),
		(earcut_1.default = _default),
		earcut_1.deviation,
		earcut_1.flatten;
	var commonjsGlobal$1 =
		'undefined' != typeof globalThis
			? globalThis
			: 'undefined' != typeof window
			? window
			: 'undefined' != typeof global
			? global
			: 'undefined' != typeof self
			? self
			: {};
	function createCommonjsModule$3(t, e, i) {
		return (
			t(
				(i = {
					path: e,
					exports: {},
					require: function (t, e) {
						return commonjsRequire$2(t, null == e ? i.path : e);
					},
				}),
				i.exports
			),
			i.exports
		);
	}
	function commonjsRequire$2() {
		throw new Error(
			'Dynamic requires are not currently supported by @rollup/plugin-commonjs'
		);
	}
	var punycode$1 = createCommonjsModule$3(function (t, e) {
		!(function (i) {
			var r = e && !e.nodeType && e,
				s = t && !t.nodeType && t,
				n = 'object' == typeof commonjsGlobal$1 && commonjsGlobal$1;
			(n.global !== n && n.window !== n && n.self !== n) || (i = n);
			var a,
				o,
				h = 2147483647,
				u = 36,
				l = /^xn--/,
				c = /[^\x20-\x7E]/,
				d = /[\x2E\u3002\uFF0E\uFF61]/g,
				p = {
					overflow: 'Overflow: input needs wider integers to process',
					'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
					'invalid-input': 'Invalid input',
				},
				f = Math.floor,
				m = String.fromCharCode;
			function _(t) {
				throw RangeError(p[t]);
			}
			function g(t, e) {
				for (var i = t.length, r = []; i--; ) r[i] = e(t[i]);
				return r;
			}
			function E(t, e) {
				var i = t.split('@'),
					r = '';
				return (
					i.length > 1 && ((r = i[0] + '@'), (t = i[1])),
					r + g((t = t.replace(d, '.')).split('.'), e).join('.')
				);
			}
			function y(t) {
				for (var e, i, r = [], s = 0, n = t.length; s < n; )
					(e = t.charCodeAt(s++)) >= 55296 && e <= 56319 && s < n
						? 56320 == (64512 & (i = t.charCodeAt(s++)))
							? r.push(((1023 & e) << 10) + (1023 & i) + 65536)
							: (r.push(e), s--)
						: r.push(e);
				return r;
			}
			function T(t) {
				return g(t, function (t) {
					var e = '';
					return (
						t > 65535 &&
							((e += m((((t -= 65536) >>> 10) & 1023) | 55296)),
							(t = 56320 | (1023 & t))),
						e + m(t)
					);
				}).join('');
			}
			function v(t, e) {
				return t + 22 + 75 * (t < 26) - ((0 != e) << 5);
			}
			function S(t, e, i) {
				var r = 0;
				for (t = i ? f(t / 700) : t >> 1, t += f(t / e); t > 455; r += u)
					t = f(t / 35);
				return f(r + (36 * t) / (t + 38));
			}
			function x(t) {
				var e,
					i,
					r,
					s,
					n,
					a,
					o,
					l,
					c,
					d,
					p,
					m = [],
					g = t.length,
					E = 0,
					y = 128,
					v = 72;
				for ((i = t.lastIndexOf('-')) < 0 && (i = 0), r = 0; r < i; ++r)
					t.charCodeAt(r) >= 128 && _('not-basic'), m.push(t.charCodeAt(r));
				for (s = i > 0 ? i + 1 : 0; s < g; ) {
					for (
						n = E, a = 1, o = u;
						s >= g && _('invalid-input'),
							((l =
								(p = t.charCodeAt(s++)) - 48 < 10
									? p - 22
									: p - 65 < 26
									? p - 65
									: p - 97 < 26
									? p - 97
									: u) >= u ||
								l > f((h - E) / a)) &&
								_('overflow'),
							(E += l * a),
							!(l < (c = o <= v ? 1 : o >= v + 26 ? 26 : o - v));
						o += u
					)
						a > f(h / (d = u - c)) && _('overflow'), (a *= d);
					(v = S(E - n, (e = m.length + 1), 0 == n)),
						f(E / e) > h - y && _('overflow'),
						(y += f(E / e)),
						(E %= e),
						m.splice(E++, 0, y);
				}
				return T(m);
			}
			function b(t) {
				var e,
					i,
					r,
					s,
					n,
					a,
					o,
					l,
					c,
					d,
					p,
					g,
					E,
					T,
					x,
					b = [];
				for (g = (t = y(t)).length, e = 128, i = 0, n = 72, a = 0; a < g; ++a)
					(p = t[a]) < 128 && b.push(m(p));
				for (r = s = b.length, s && b.push('-'); r < g; ) {
					for (o = h, a = 0; a < g; ++a) (p = t[a]) >= e && p < o && (o = p);
					for (
						o - e > f((h - i) / (E = r + 1)) && _('overflow'),
							i += (o - e) * E,
							e = o,
							a = 0;
						a < g;
						++a
					)
						if (((p = t[a]) < e && ++i > h && _('overflow'), p == e)) {
							for (
								l = i, c = u;
								!(l < (d = c <= n ? 1 : c >= n + 26 ? 26 : c - n));
								c += u
							)
								(x = l - d),
									(T = u - d),
									b.push(m(v(d + (x % T), 0))),
									(l = f(x / T));
							b.push(m(v(l, 0))), (n = S(i, E, r == s)), (i = 0), ++r;
						}
					++i, ++e;
				}
				return b.join('');
			}
			if (
				((a = {
					version: '1.3.2',
					ucs2: { decode: y, encode: T },
					decode: x,
					encode: b,
					toASCII: function (t) {
						return E(t, function (t) {
							return c.test(t) ? 'xn--' + b(t) : t;
						});
					},
					toUnicode: function (t) {
						return E(t, function (t) {
							return l.test(t) ? x(t.slice(4).toLowerCase()) : t;
						});
					},
				}),
				r && s)
			)
				if (t.exports == r) s.exports = a;
				else for (o in a) a.hasOwnProperty(o) && (r[o] = a[o]);
			else i.punycode = a;
		})(commonjsGlobal$1);
	});
	function createCommonjsModule$2(t, e, i) {
		return (
			t(
				(i = {
					path: e,
					exports: {},
					require: function (t, e) {
						return commonjsRequire$1(t, null == e ? i.path : e);
					},
				}),
				i.exports
			),
			i.exports
		);
	}
	function commonjsRequire$1() {
		throw new Error(
			'Dynamic requires are not currently supported by @rollup/plugin-commonjs'
		);
	}
	function hasOwnProperty$1(t, e) {
		return Object.prototype.hasOwnProperty.call(t, e);
	}
	punycode$1.decode,
		punycode$1.encode,
		punycode$1.toASCII,
		punycode$1.toUnicode,
		punycode$1.ucs2,
		punycode$1.version;
	var decode$1 = function (t, e, i, r) {
			(e = e || '&'), (i = i || '=');
			var s = {};
			if ('string' != typeof t || 0 === t.length) return s;
			var n = /\+/g;
			t = t.split(e);
			var a = 1e3;
			r && 'number' == typeof r.maxKeys && (a = r.maxKeys);
			var o = t.length;
			a > 0 && o > a && (o = a);
			for (var h = 0; h < o; ++h) {
				var u,
					l,
					c,
					d,
					p = t[h].replace(n, '%20'),
					f = p.indexOf(i);
				f >= 0
					? ((u = p.substr(0, f)), (l = p.substr(f + 1)))
					: ((u = p), (l = '')),
					(c = decodeURIComponent(u)),
					(d = decodeURIComponent(l)),
					hasOwnProperty$1(s, c)
						? Array.isArray(s[c])
							? s[c].push(d)
							: (s[c] = [s[c], d])
						: (s[c] = d);
			}
			return s;
		},
		stringifyPrimitive$1 = function (t) {
			switch (typeof t) {
				case 'string':
					return t;
				case 'boolean':
					return t ? 'true' : 'false';
				case 'number':
					return isFinite(t) ? t : '';
				default:
					return '';
			}
		},
		encode$1 = function (t, e, i, r) {
			return (
				(e = e || '&'),
				(i = i || '='),
				null === t && (t = void 0),
				'object' == typeof t
					? Object.keys(t)
							.map(function (r) {
								var s = encodeURIComponent(stringifyPrimitive$1(r)) + i;
								return Array.isArray(t[r])
									? t[r]
											.map(function (t) {
												return s + encodeURIComponent(stringifyPrimitive$1(t));
											})
											.join(e)
									: s + encodeURIComponent(stringifyPrimitive$1(t[r]));
							})
							.join(e)
					: r
					? encodeURIComponent(stringifyPrimitive$1(r)) +
					  i +
					  encodeURIComponent(stringifyPrimitive$1(t))
					: ''
			);
		},
		querystring$1 = createCommonjsModule$2(function (t, e) {
			(e.decode = e.parse = decode$1), (e.encode = e.stringify = encode$1);
		});
	querystring$1.decode,
		querystring$1.encode,
		querystring$1.parse,
		querystring$1.stringify;
	var util$1 = {
			isString: function (t) {
				return 'string' == typeof t;
			},
			isObject: function (t) {
				return 'object' == typeof t && null !== t;
			},
			isNull: function (t) {
				return null === t;
			},
			isNullOrUndefined: function (t) {
				return null == t;
			},
		},
		parse$4 = urlParse$1,
		resolve$4 = urlResolve$1,
		resolveObject = urlResolveObject,
		format$4 = urlFormat$1,
		Url_1 = Url$1;
	function Url$1() {
		(this.protocol = null),
			(this.slashes = null),
			(this.auth = null),
			(this.host = null),
			(this.port = null),
			(this.hostname = null),
			(this.hash = null),
			(this.search = null),
			(this.query = null),
			(this.pathname = null),
			(this.path = null),
			(this.href = null);
	}
	var protocolPattern$1 = /^([a-z0-9.+-]+:)/i,
		portPattern$1 = /:[0-9]*$/,
		simplePathPattern$1 = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
		delims$1 = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
		unwise$1 = ['{', '}', '|', '\\', '^', '`'].concat(delims$1),
		autoEscape$1 = ["'"].concat(unwise$1),
		nonHostChars$1 = ['%', '/', '?', ';', '#'].concat(autoEscape$1),
		hostEndingChars$1 = ['/', '?', '#'],
		hostnameMaxLen$1 = 255,
		hostnamePartPattern$1 = /^[+a-z0-9A-Z_-]{0,63}$/,
		hostnamePartStart$1 = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
		unsafeProtocol$1 = { javascript: !0, 'javascript:': !0 },
		hostlessProtocol$1 = { javascript: !0, 'javascript:': !0 },
		slashedProtocol$1 = {
			http: !0,
			https: !0,
			ftp: !0,
			gopher: !0,
			file: !0,
			'http:': !0,
			'https:': !0,
			'ftp:': !0,
			'gopher:': !0,
			'file:': !0,
		};
	function urlParse$1(t, e, i) {
		if (t && util$1.isObject(t) && t instanceof Url$1) return t;
		var r = new Url$1();
		return r.parse(t, e, i), r;
	}
	function urlFormat$1(t) {
		return (
			util$1.isString(t) && (t = urlParse$1(t)),
			t instanceof Url$1 ? t.format() : Url$1.prototype.format.call(t)
		);
	}
	function urlResolve$1(t, e) {
		return urlParse$1(t, !1, !0).resolve(e);
	}
	function urlResolveObject(t, e) {
		return t ? urlParse$1(t, !1, !0).resolveObject(e) : e;
	}
	(Url$1.prototype.parse = function (t, e, i) {
		if (!util$1.isString(t))
			throw new TypeError("Parameter 'url' must be a string, not " + typeof t);
		var r = t.indexOf('?'),
			s = -1 !== r && r < t.indexOf('#') ? '?' : '#',
			n = t.split(s);
		n[0] = n[0].replace(/\\/g, '/');
		var a = (t = n.join(s));
		if (((a = a.trim()), !i && 1 === t.split('#').length)) {
			var o = simplePathPattern$1.exec(a);
			if (o)
				return (
					(this.path = a),
					(this.href = a),
					(this.pathname = o[1]),
					o[2]
						? ((this.search = o[2]),
						  (this.query = e
								? querystring$1.parse(this.search.substr(1))
								: this.search.substr(1)))
						: e && ((this.search = ''), (this.query = {})),
					this
				);
		}
		var h = protocolPattern$1.exec(a);
		if (h) {
			var u = (h = h[0]).toLowerCase();
			(this.protocol = u), (a = a.substr(h.length));
		}
		if (i || h || a.match(/^\/\/[^@\/]+@[^@\/]+/)) {
			var l = '//' === a.substr(0, 2);
			!l ||
				(h && hostlessProtocol$1[h]) ||
				((a = a.substr(2)), (this.slashes = !0));
		}
		if (!hostlessProtocol$1[h] && (l || (h && !slashedProtocol$1[h]))) {
			for (var c, d, p = -1, f = 0; f < hostEndingChars$1.length; f++)
				-1 !== (m = a.indexOf(hostEndingChars$1[f])) &&
					(-1 === p || m < p) &&
					(p = m);
			for (
				-1 !== (d = -1 === p ? a.lastIndexOf('@') : a.lastIndexOf('@', p)) &&
					((c = a.slice(0, d)),
					(a = a.slice(d + 1)),
					(this.auth = decodeURIComponent(c))),
					p = -1,
					f = 0;
				f < nonHostChars$1.length;
				f++
			) {
				var m;
				-1 !== (m = a.indexOf(nonHostChars$1[f])) &&
					(-1 === p || m < p) &&
					(p = m);
			}
			-1 === p && (p = a.length),
				(this.host = a.slice(0, p)),
				(a = a.slice(p)),
				this.parseHost(),
				(this.hostname = this.hostname || '');
			var _ =
				'[' === this.hostname[0] &&
				']' === this.hostname[this.hostname.length - 1];
			if (!_)
				for (
					var g = this.hostname.split(/\./), E = ((f = 0), g.length);
					f < E;
					f++
				) {
					var y = g[f];
					if (y && !y.match(hostnamePartPattern$1)) {
						for (var T = '', v = 0, S = y.length; v < S; v++)
							y.charCodeAt(v) > 127 ? (T += 'x') : (T += y[v]);
						if (!T.match(hostnamePartPattern$1)) {
							var x = g.slice(0, f),
								b = g.slice(f + 1),
								A = y.match(hostnamePartStart$1);
							A && (x.push(A[1]), b.unshift(A[2])),
								b.length && (a = '/' + b.join('.') + a),
								(this.hostname = x.join('.'));
							break;
						}
					}
				}
			this.hostname.length > hostnameMaxLen$1
				? (this.hostname = '')
				: (this.hostname = this.hostname.toLowerCase()),
				_ || (this.hostname = punycode$1.toASCII(this.hostname));
			var R = this.port ? ':' + this.port : '',
				I = this.hostname || '';
			(this.host = I + R),
				(this.href += this.host),
				_ &&
					((this.hostname = this.hostname.substr(1, this.hostname.length - 2)),
					'/' !== a[0] && (a = '/' + a));
		}
		if (!unsafeProtocol$1[u])
			for (f = 0, E = autoEscape$1.length; f < E; f++) {
				var M = autoEscape$1[f];
				if (-1 !== a.indexOf(M)) {
					var w = encodeURIComponent(M);
					w === M && (w = escape(M)), (a = a.split(M).join(w));
				}
			}
		var C = a.indexOf('#');
		-1 !== C && ((this.hash = a.substr(C)), (a = a.slice(0, C)));
		var P = a.indexOf('?');
		if (
			(-1 !== P
				? ((this.search = a.substr(P)),
				  (this.query = a.substr(P + 1)),
				  e && (this.query = querystring$1.parse(this.query)),
				  (a = a.slice(0, P)))
				: e && ((this.search = ''), (this.query = {})),
			a && (this.pathname = a),
			slashedProtocol$1[u] &&
				this.hostname &&
				!this.pathname &&
				(this.pathname = '/'),
			this.pathname || this.search)
		) {
			R = this.pathname || '';
			var O = this.search || '';
			this.path = R + O;
		}
		return (this.href = this.format()), this;
	}),
		(Url$1.prototype.format = function () {
			var t = this.auth || '';
			t && ((t = (t = encodeURIComponent(t)).replace(/%3A/i, ':')), (t += '@'));
			var e = this.protocol || '',
				i = this.pathname || '',
				r = this.hash || '',
				s = !1,
				n = '';
			this.host
				? (s = t + this.host)
				: this.hostname &&
				  ((s =
						t +
						(-1 === this.hostname.indexOf(':')
							? this.hostname
							: '[' + this.hostname + ']')),
				  this.port && (s += ':' + this.port)),
				this.query &&
					util$1.isObject(this.query) &&
					Object.keys(this.query).length &&
					(n = querystring$1.stringify(this.query));
			var a = this.search || (n && '?' + n) || '';
			return (
				e && ':' !== e.substr(-1) && (e += ':'),
				this.slashes || ((!e || slashedProtocol$1[e]) && !1 !== s)
					? ((s = '//' + (s || '')), i && '/' !== i.charAt(0) && (i = '/' + i))
					: s || (s = ''),
				r && '#' !== r.charAt(0) && (r = '#' + r),
				a && '?' !== a.charAt(0) && (a = '?' + a),
				e +
					s +
					(i = i.replace(/[?#]/g, function (t) {
						return encodeURIComponent(t);
					})) +
					(a = a.replace('#', '%23')) +
					r
			);
		}),
		(Url$1.prototype.resolve = function (t) {
			return this.resolveObject(urlParse$1(t, !1, !0)).format();
		}),
		(Url$1.prototype.resolveObject = function (t) {
			if (util$1.isString(t)) {
				var e = new Url$1();
				e.parse(t, !1, !0), (t = e);
			}
			for (
				var i = new Url$1(), r = Object.keys(this), s = 0;
				s < r.length;
				s++
			) {
				var n = r[s];
				i[n] = this[n];
			}
			if (((i.hash = t.hash), '' === t.href)) return (i.href = i.format()), i;
			if (t.slashes && !t.protocol) {
				for (var a = Object.keys(t), o = 0; o < a.length; o++) {
					var h = a[o];
					'protocol' !== h && (i[h] = t[h]);
				}
				return (
					slashedProtocol$1[i.protocol] &&
						i.hostname &&
						!i.pathname &&
						(i.path = i.pathname = '/'),
					(i.href = i.format()),
					i
				);
			}
			if (t.protocol && t.protocol !== i.protocol) {
				if (!slashedProtocol$1[t.protocol]) {
					for (var u = Object.keys(t), l = 0; l < u.length; l++) {
						var c = u[l];
						i[c] = t[c];
					}
					return (i.href = i.format()), i;
				}
				if (
					((i.protocol = t.protocol), t.host || hostlessProtocol$1[t.protocol])
				)
					i.pathname = t.pathname;
				else {
					for (
						var d = (t.pathname || '').split('/');
						d.length && !(t.host = d.shift());

					);
					t.host || (t.host = ''),
						t.hostname || (t.hostname = ''),
						'' !== d[0] && d.unshift(''),
						d.length < 2 && d.unshift(''),
						(i.pathname = d.join('/'));
				}
				if (
					((i.search = t.search),
					(i.query = t.query),
					(i.host = t.host || ''),
					(i.auth = t.auth),
					(i.hostname = t.hostname || t.host),
					(i.port = t.port),
					i.pathname || i.search)
				) {
					var p = i.pathname || '',
						f = i.search || '';
					i.path = p + f;
				}
				return (i.slashes = i.slashes || t.slashes), (i.href = i.format()), i;
			}
			var m = i.pathname && '/' === i.pathname.charAt(0),
				_ = t.host || (t.pathname && '/' === t.pathname.charAt(0)),
				g = _ || m || (i.host && t.pathname),
				E = g,
				y = (i.pathname && i.pathname.split('/')) || [],
				T =
					((d = (t.pathname && t.pathname.split('/')) || []),
					i.protocol && !slashedProtocol$1[i.protocol]);
			if (
				(T &&
					((i.hostname = ''),
					(i.port = null),
					i.host && ('' === y[0] ? (y[0] = i.host) : y.unshift(i.host)),
					(i.host = ''),
					t.protocol &&
						((t.hostname = null),
						(t.port = null),
						t.host && ('' === d[0] ? (d[0] = t.host) : d.unshift(t.host)),
						(t.host = null)),
					(g = g && ('' === d[0] || '' === y[0]))),
				_)
			)
				(i.host = t.host || '' === t.host ? t.host : i.host),
					(i.hostname =
						t.hostname || '' === t.hostname ? t.hostname : i.hostname),
					(i.search = t.search),
					(i.query = t.query),
					(y = d);
			else if (d.length)
				y || (y = []),
					y.pop(),
					(y = y.concat(d)),
					(i.search = t.search),
					(i.query = t.query);
			else if (!util$1.isNullOrUndefined(t.search))
				return (
					T &&
						((i.hostname = i.host = y.shift()),
						(A = !!(i.host && i.host.indexOf('@') > 0) && i.host.split('@')) &&
							((i.auth = A.shift()), (i.host = i.hostname = A.shift()))),
					(i.search = t.search),
					(i.query = t.query),
					(util$1.isNull(i.pathname) && util$1.isNull(i.search)) ||
						(i.path =
							(i.pathname ? i.pathname : '') + (i.search ? i.search : '')),
					(i.href = i.format()),
					i
				);
			if (!y.length)
				return (
					(i.pathname = null),
					i.search ? (i.path = '/' + i.search) : (i.path = null),
					(i.href = i.format()),
					i
				);
			for (
				var v = y.slice(-1)[0],
					S =
						((i.host || t.host || y.length > 1) && ('.' === v || '..' === v)) ||
						'' === v,
					x = 0,
					b = y.length;
				b >= 0;
				b--
			)
				'.' === (v = y[b])
					? y.splice(b, 1)
					: '..' === v
					? (y.splice(b, 1), x++)
					: x && (y.splice(b, 1), x--);
			if (!g && !E) for (; x--; x) y.unshift('..');
			!g || '' === y[0] || (y[0] && '/' === y[0].charAt(0)) || y.unshift(''),
				S && '/' !== y.join('/').substr(-1) && y.push('');
			var A,
				R = '' === y[0] || (y[0] && '/' === y[0].charAt(0));
			return (
				T &&
					((i.hostname = i.host = R ? '' : y.length ? y.shift() : ''),
					(A = !!(i.host && i.host.indexOf('@') > 0) && i.host.split('@')) &&
						((i.auth = A.shift()), (i.host = i.hostname = A.shift()))),
				(g = g || (i.host && y.length)) && !R && y.unshift(''),
				y.length
					? (i.pathname = y.join('/'))
					: ((i.pathname = null), (i.path = null)),
				(util$1.isNull(i.pathname) && util$1.isNull(i.search)) ||
					(i.path =
						(i.pathname ? i.pathname : '') + (i.search ? i.search : '')),
				(i.auth = t.auth || i.auth),
				(i.slashes = i.slashes || t.slashes),
				(i.href = i.format()),
				i
			);
		}),
		(Url$1.prototype.parseHost = function () {
			var t = this.host,
				e = portPattern$1.exec(t);
			e &&
				(':' !== (e = e[0]) && (this.port = e.substr(1)),
				(t = t.substr(0, t.length - e.length))),
				t && (this.hostname = t);
		});
	var url$1 = {
		parse: parse$4,
		resolve: resolve$4,
		resolveObject,
		format: format$4,
		Url: Url_1,
	};
	const { parse: parse$3 } = url$1,
		{ format: format$3 } = url$1,
		{ resolve: resolve$3 } = url$1;
	/*!
	 * @pixi/utils - v6.4.2
	 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
	 *
	 * @pixi/utils is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 */
	var url2$2 = { parse: parse$3, format: format$3, resolve: resolve$3 };
	(settings$4.RETINA_PREFIX = /@([0-9\.]+)x/),
		(settings$4.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1);
	var saidHello$3 = !1,
		VERSION$3 = '6.4.2',
		supported$3;
	function skipHello() {
		saidHello$3 = !0;
	}
	function sayHello$3(t) {
		var e;
		if (!saidHello$3) {
			if (navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
				var i = [
					'\n %c %c %c PixiJS ' +
						VERSION$3 +
						' - ✰ ' +
						t +
						' ✰  %c  %c  http://www.pixijs.com/  %c %c ♥%c♥%c♥ \n\n',
					'background: #ff66a5; padding:5px 0;',
					'background: #ff66a5; padding:5px 0;',
					'color: #ff66a5; background: #030307; padding:5px 0;',
					'background: #ff66a5; padding:5px 0;',
					'background: #ffc3dc; padding:5px 0;',
					'background: #ff66a5; padding:5px 0;',
					'color: #ff2424; background: #fff; padding:5px 0;',
					'color: #ff2424; background: #fff; padding:5px 0;',
					'color: #ff2424; background: #fff; padding:5px 0;',
				];
				(e = globalThis.console).log.apply(e, i);
			} else
				globalThis.console &&
					globalThis.console.log(
						'PixiJS ' + VERSION$3 + ' - ' + t + ' - http://www.pixijs.com/'
					);
			saidHello$3 = !0;
		}
	}
	function isWebGLSupported$3() {
		return (
			void 0 === supported$3 &&
				(supported$3 = (function () {
					var t = {
						stencil: !0,
						failIfMajorPerformanceCaveat:
							settings$4.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT,
					};
					try {
						if (!globalThis.WebGLRenderingContext) return !1;
						var e = document.createElement('canvas'),
							i =
								e.getContext('webgl', t) ||
								e.getContext('experimental-webgl', t),
							r = !(!i || !i.getContextAttributes().stencil);
						if (i) {
							var s = i.getExtension('WEBGL_lose_context');
							s && s.loseContext();
						}
						return (i = null), r;
					} catch (t) {
						return !1;
					}
				})()),
			supported$3
		);
	}
	var aliceblue = '#f0f8ff',
		antiquewhite = '#faebd7',
		aqua = '#00ffff',
		aquamarine = '#7fffd4',
		azure = '#f0ffff',
		beige = '#f5f5dc',
		bisque = '#ffe4c4',
		black = '#000000',
		blanchedalmond = '#ffebcd',
		blue = '#0000ff',
		blueviolet = '#8a2be2',
		brown = '#a52a2a',
		burlywood = '#deb887',
		cadetblue = '#5f9ea0',
		chartreuse = '#7fff00',
		chocolate = '#d2691e',
		coral = '#ff7f50',
		cornflowerblue = '#6495ed',
		cornsilk = '#fff8dc',
		crimson = '#dc143c',
		cyan = '#00ffff',
		darkblue = '#00008b',
		darkcyan = '#008b8b',
		darkgoldenrod = '#b8860b',
		darkgray = '#a9a9a9',
		darkgreen = '#006400',
		darkgrey = '#a9a9a9',
		darkkhaki = '#bdb76b',
		darkmagenta = '#8b008b',
		darkolivegreen = '#556b2f',
		darkorange = '#ff8c00',
		darkorchid = '#9932cc',
		darkred = '#8b0000',
		darksalmon = '#e9967a',
		darkseagreen = '#8fbc8f',
		darkslateblue = '#483d8b',
		darkslategray = '#2f4f4f',
		darkslategrey = '#2f4f4f',
		darkturquoise = '#00ced1',
		darkviolet = '#9400d3',
		deeppink = '#ff1493',
		deepskyblue = '#00bfff',
		dimgray = '#696969',
		dimgrey = '#696969',
		dodgerblue = '#1e90ff',
		firebrick = '#b22222',
		floralwhite = '#fffaf0',
		forestgreen = '#228b22',
		fuchsia = '#ff00ff',
		gainsboro = '#dcdcdc',
		ghostwhite = '#f8f8ff',
		goldenrod = '#daa520',
		gold = '#ffd700',
		gray = '#808080',
		green = '#008000',
		greenyellow = '#adff2f',
		grey = '#808080',
		honeydew = '#f0fff0',
		hotpink = '#ff69b4',
		indianred = '#cd5c5c',
		indigo = '#4b0082',
		ivory = '#fffff0',
		khaki = '#f0e68c',
		lavenderblush = '#fff0f5',
		lavender = '#e6e6fa',
		lawngreen = '#7cfc00',
		lemonchiffon = '#fffacd',
		lightblue = '#add8e6',
		lightcoral = '#f08080',
		lightcyan = '#e0ffff',
		lightgoldenrodyellow = '#fafad2',
		lightgray = '#d3d3d3',
		lightgreen = '#90ee90',
		lightgrey = '#d3d3d3',
		lightpink = '#ffb6c1',
		lightsalmon = '#ffa07a',
		lightseagreen = '#20b2aa',
		lightskyblue = '#87cefa',
		lightslategray = '#778899',
		lightslategrey = '#778899',
		lightsteelblue = '#b0c4de',
		lightyellow = '#ffffe0',
		lime = '#00ff00',
		limegreen = '#32cd32',
		linen = '#faf0e6',
		magenta = '#ff00ff',
		maroon = '#800000',
		mediumaquamarine = '#66cdaa',
		mediumblue = '#0000cd',
		mediumorchid = '#ba55d3',
		mediumpurple = '#9370db',
		mediumseagreen = '#3cb371',
		mediumslateblue = '#7b68ee',
		mediumspringgreen = '#00fa9a',
		mediumturquoise = '#48d1cc',
		mediumvioletred = '#c71585',
		midnightblue = '#191970',
		mintcream = '#f5fffa',
		mistyrose = '#ffe4e1',
		moccasin = '#ffe4b5',
		navajowhite = '#ffdead',
		navy = '#000080',
		oldlace = '#fdf5e6',
		olive = '#808000',
		olivedrab = '#6b8e23',
		orange = '#ffa500',
		orangered = '#ff4500',
		orchid = '#da70d6',
		palegoldenrod = '#eee8aa',
		palegreen = '#98fb98',
		paleturquoise = '#afeeee',
		palevioletred = '#db7093',
		papayawhip = '#ffefd5',
		peachpuff = '#ffdab9',
		peru = '#cd853f',
		pink = '#ffc0cb',
		plum = '#dda0dd',
		powderblue = '#b0e0e6',
		purple = '#800080',
		rebeccapurple = '#663399',
		red = '#ff0000',
		rosybrown = '#bc8f8f',
		royalblue = '#4169e1',
		saddlebrown = '#8b4513',
		salmon = '#fa8072',
		sandybrown = '#f4a460',
		seagreen = '#2e8b57',
		seashell = '#fff5ee',
		sienna = '#a0522d',
		silver = '#c0c0c0',
		skyblue = '#87ceeb',
		slateblue = '#6a5acd',
		slategray = '#708090',
		slategrey = '#708090',
		snow = '#fffafa',
		springgreen = '#00ff7f',
		steelblue = '#4682b4',
		tan = '#d2b48c',
		teal = '#008080',
		thistle = '#d8bfd8',
		tomato = '#ff6347',
		turquoise = '#40e0d0',
		violet = '#ee82ee',
		wheat = '#f5deb3',
		white = '#ffffff',
		whitesmoke = '#f5f5f5',
		yellow = '#ffff00',
		yellowgreen = '#9acd32',
		cssColorNames = {
			aliceblue,
			antiquewhite,
			aqua,
			aquamarine,
			azure,
			beige,
			bisque,
			black,
			blanchedalmond,
			blue,
			blueviolet,
			brown,
			burlywood,
			cadetblue,
			chartreuse,
			chocolate,
			coral,
			cornflowerblue,
			cornsilk,
			crimson,
			cyan,
			darkblue,
			darkcyan,
			darkgoldenrod,
			darkgray,
			darkgreen,
			darkgrey,
			darkkhaki,
			darkmagenta,
			darkolivegreen,
			darkorange,
			darkorchid,
			darkred,
			darksalmon,
			darkseagreen,
			darkslateblue,
			darkslategray,
			darkslategrey,
			darkturquoise,
			darkviolet,
			deeppink,
			deepskyblue,
			dimgray,
			dimgrey,
			dodgerblue,
			firebrick,
			floralwhite,
			forestgreen,
			fuchsia,
			gainsboro,
			ghostwhite,
			goldenrod,
			gold,
			gray,
			green,
			greenyellow,
			grey,
			honeydew,
			hotpink,
			indianred,
			indigo,
			ivory,
			khaki,
			lavenderblush,
			lavender,
			lawngreen,
			lemonchiffon,
			lightblue,
			lightcoral,
			lightcyan,
			lightgoldenrodyellow,
			lightgray,
			lightgreen,
			lightgrey,
			lightpink,
			lightsalmon,
			lightseagreen,
			lightskyblue,
			lightslategray,
			lightslategrey,
			lightsteelblue,
			lightyellow,
			lime,
			limegreen,
			linen,
			magenta,
			maroon,
			mediumaquamarine,
			mediumblue,
			mediumorchid,
			mediumpurple,
			mediumseagreen,
			mediumslateblue,
			mediumspringgreen,
			mediumturquoise,
			mediumvioletred,
			midnightblue,
			mintcream,
			mistyrose,
			moccasin,
			navajowhite,
			navy,
			oldlace,
			olive,
			olivedrab,
			orange,
			orangered,
			orchid,
			palegoldenrod,
			palegreen,
			paleturquoise,
			palevioletred,
			papayawhip,
			peachpuff,
			peru,
			pink,
			plum,
			powderblue,
			purple,
			rebeccapurple,
			red,
			rosybrown,
			royalblue,
			saddlebrown,
			salmon,
			sandybrown,
			seagreen,
			seashell,
			sienna,
			silver,
			skyblue,
			slateblue,
			slategray,
			slategrey,
			snow,
			springgreen,
			steelblue,
			tan,
			teal,
			thistle,
			tomato,
			turquoise,
			violet,
			wheat,
			white,
			whitesmoke,
			yellow,
			yellowgreen,
		};
	function hex2rgb$3(t, e) {
		return (
			void 0 === e && (e = []),
			(e[0] = ((t >> 16) & 255) / 255),
			(e[1] = ((t >> 8) & 255) / 255),
			(e[2] = (255 & t) / 255),
			e
		);
	}
	function hex2string$3(t) {
		var e = t.toString(16);
		return '#' + ('000000'.substring(0, 6 - e.length) + e);
	}
	function string2hex(t) {
		return (
			'string' == typeof t &&
				'#' === (t = cssColorNames[t.toLowerCase()] || t)[0] &&
				(t = t.slice(1)),
			parseInt(t, 16)
		);
	}
	function rgb2hex(t) {
		return ((255 * t[0]) << 16) + ((255 * t[1]) << 8) + ((255 * t[2]) | 0);
	}
	function mapPremultipliedBlendModes$3() {
		for (var t = [], e = [], i = 0; i < 32; i++) (t[i] = i), (e[i] = i);
		(t[BLEND_MODES$9.NORMAL_NPM] = BLEND_MODES$9.NORMAL),
			(t[BLEND_MODES$9.ADD_NPM] = BLEND_MODES$9.ADD),
			(t[BLEND_MODES$9.SCREEN_NPM] = BLEND_MODES$9.SCREEN),
			(e[BLEND_MODES$9.NORMAL] = BLEND_MODES$9.NORMAL_NPM),
			(e[BLEND_MODES$9.ADD] = BLEND_MODES$9.ADD_NPM),
			(e[BLEND_MODES$9.SCREEN] = BLEND_MODES$9.SCREEN_NPM);
		var r = [];
		return r.push(e), r.push(t), r;
	}
	var premultiplyBlendMode$3 = mapPremultipliedBlendModes$3();
	function correctBlendMode(t, e) {
		return premultiplyBlendMode$3[e ? 1 : 0][t];
	}
	function premultiplyRgba(t, e, i, r) {
		return (
			(i = i || new Float32Array(4)),
			r || void 0 === r
				? ((i[0] = t[0] * e), (i[1] = t[1] * e), (i[2] = t[2] * e))
				: ((i[0] = t[0]), (i[1] = t[1]), (i[2] = t[2])),
			(i[3] = e),
			i
		);
	}
	function premultiplyTint$3(t, e) {
		if (1 === e) return ((255 * e) << 24) + t;
		if (0 === e) return 0;
		var i = (t >> 16) & 255,
			r = (t >> 8) & 255,
			s = 255 & t;
		return (
			((255 * e) << 24) +
			((i = (i * e + 0.5) | 0) << 16) +
			((r = (r * e + 0.5) | 0) << 8) +
			((s * e + 0.5) | 0)
		);
	}
	function premultiplyTintToRgba(t, e, i, r) {
		return (
			((i = i || new Float32Array(4))[0] = ((t >> 16) & 255) / 255),
			(i[1] = ((t >> 8) & 255) / 255),
			(i[2] = (255 & t) / 255),
			(r || void 0 === r) && ((i[0] *= e), (i[1] *= e), (i[2] *= e)),
			(i[3] = e),
			i
		);
	}
	function createIndicesForQuads$1(t, e) {
		void 0 === e && (e = null);
		var i = 6 * t;
		if ((e = e || new Uint16Array(i)).length !== i)
			throw new Error(
				'Out buffer length is incorrect, got ' + e.length + ' and expected ' + i
			);
		for (var r = 0, s = 0; r < i; r += 6, s += 4)
			(e[r + 0] = s + 0),
				(e[r + 1] = s + 1),
				(e[r + 2] = s + 2),
				(e[r + 3] = s + 0),
				(e[r + 4] = s + 2),
				(e[r + 5] = s + 3);
		return e;
	}
	function getBufferType$3(t) {
		if (4 === t.BYTES_PER_ELEMENT)
			return t instanceof Float32Array
				? 'Float32Array'
				: t instanceof Uint32Array
				? 'Uint32Array'
				: 'Int32Array';
		if (2 === t.BYTES_PER_ELEMENT) {
			if (t instanceof Uint16Array) return 'Uint16Array';
		} else if (1 === t.BYTES_PER_ELEMENT && t instanceof Uint8Array)
			return 'Uint8Array';
		return null;
	}
	var map$5 = { Float32Array, Uint32Array, Int32Array, Uint8Array };
	function interleaveTypedArrays$4(t, e) {
		for (var i = 0, r = 0, s = {}, n = 0; n < t.length; n++)
			(r += e[n]), (i += t[n].length);
		var a = new ArrayBuffer(4 * i),
			o = null,
			h = 0;
		for (n = 0; n < t.length; n++) {
			var u = e[n],
				l = t[n],
				c = getBufferType$3(l);
			s[c] || (s[c] = new map$5[c](a)), (o = s[c]);
			for (var d = 0; d < l.length; d++)
				o[((d / u) | 0) * r + h + (d % u)] = l[d];
			h += u;
		}
		return new Float32Array(a);
	}
	function nextPow2$3(t) {
		return (
			(t += 0 === t ? 1 : 0),
			--t,
			(t |= t >>> 1),
			(t |= t >>> 2),
			(t |= t >>> 4),
			(t |= t >>> 8),
			1 + (t |= t >>> 16)
		);
	}
	function isPow2$3(t) {
		return !(t & (t - 1) || !t);
	}
	function log2$3(t) {
		var e = (t > 65535 ? 1 : 0) << 4,
			i = ((t >>>= e) > 255 ? 1 : 0) << 3;
		return (
			(e |= i),
			(e |= i = ((t >>>= i) > 15 ? 1 : 0) << 2),
			(e |= i = ((t >>>= i) > 3 ? 1 : 0) << 1) | ((t >>>= i) >> 1)
		);
	}
	function removeItems$3(t, e, i) {
		var r,
			s = t.length;
		if (!(e >= s || 0 === i)) {
			var n = s - (i = e + i > s ? s - e : i);
			for (r = e; r < n; ++r) t[r] = t[r + i];
			t.length = n;
		}
	}
	function sign(t) {
		return 0 === t ? 0 : t < 0 ? -1 : 1;
	}
	var nextUid$3 = 0;
	function uid$3() {
		return ++nextUid$3;
	}
	var warnings$3 = {};
	function deprecation$3(t, e, i) {
		if ((void 0 === i && (i = 3), !warnings$3[e])) {
			var r = new Error().stack;
			void 0 === r ||
				((r = r.split('\n').splice(i).join('\n')), console.groupCollapsed),
				(warnings$3[e] = !0);
		}
	}
	var ProgramCache$3 = {},
		TextureCache$3 = Object.create(null),
		BaseTextureCache$3 = Object.create(null);
	function destroyTextureCache() {
		var t;
		for (t in TextureCache$3) TextureCache$3[t].destroy();
		for (t in BaseTextureCache$3) BaseTextureCache$3[t].destroy();
	}
	function clearTextureCache() {
		var t;
		for (t in TextureCache$3) delete TextureCache$3[t];
		for (t in BaseTextureCache$3) delete BaseTextureCache$3[t];
	}
	var CanvasRenderTarget = (function () {
		function t(t, e, i) {
			(this.canvas = document.createElement('canvas')),
				(this.context = this.canvas.getContext('2d')),
				(this.resolution = i || settings$4.RESOLUTION),
				this.resize(t, e);
		}
		return (
			(t.prototype.clear = function () {
				this.context.setTransform(1, 0, 0, 1, 0, 0),
					this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
			}),
			(t.prototype.resize = function (t, e) {
				(this.canvas.width = Math.round(t * this.resolution)),
					(this.canvas.height = Math.round(e * this.resolution));
			}),
			(t.prototype.destroy = function () {
				(this.context = null), (this.canvas = null);
			}),
			Object.defineProperty(t.prototype, 'width', {
				get: function () {
					return this.canvas.width;
				},
				set: function (t) {
					this.canvas.width = Math.round(t);
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(t.prototype, 'height', {
				get: function () {
					return this.canvas.height;
				},
				set: function (t) {
					this.canvas.height = Math.round(t);
				},
				enumerable: !1,
				configurable: !0,
			}),
			t
		);
	})();
	function trimCanvas(t) {
		var e,
			i,
			r,
			s = t.width,
			n = t.height,
			a = t.getContext('2d'),
			o = a.getImageData(0, 0, s, n).data,
			h = o.length,
			u = { top: null, left: null, right: null, bottom: null },
			l = null;
		for (e = 0; e < h; e += 4)
			0 !== o[e + 3] &&
				((i = (e / 4) % s),
				(r = ~~(e / 4 / s)),
				null === u.top && (u.top = r),
				(null === u.left || i < u.left) && (u.left = i),
				(null === u.right || u.right < i) && (u.right = i + 1),
				(null === u.bottom || u.bottom < r) && (u.bottom = r));
		return (
			null !== u.top &&
				((s = u.right - u.left),
				(n = u.bottom - u.top + 1),
				(l = a.getImageData(u.left, u.top, s, n))),
			{ height: n, width: s, data: l }
		);
	}
	var DATA_URI =
			/^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i,
		tempAnchor$4;
	function decomposeDataUri(t) {
		var e = DATA_URI.exec(t);
		if (e)
			return {
				mediaType: e[1] ? e[1].toLowerCase() : void 0,
				subType: e[2] ? e[2].toLowerCase() : void 0,
				charset: e[3] ? e[3].toLowerCase() : void 0,
				encoding: e[4] ? e[4].toLowerCase() : void 0,
				data: e[5],
			};
	}
	function determineCrossOrigin$3(t, e) {
		if ((void 0 === e && (e = globalThis.location), 0 === t.indexOf('data:')))
			return '';
		(e = e || globalThis.location),
			tempAnchor$4 || (tempAnchor$4 = document.createElement('a')),
			(tempAnchor$4.href = t);
		var i = url2$2.parse(tempAnchor$4.href),
			r = (!i.port && '' === e.port) || i.port === e.port;
		return i.hostname === e.hostname && r && i.protocol === e.protocol
			? ''
			: 'anonymous';
	}
	function getResolutionOfUrl$3(t, e) {
		var i = settings$4.RETINA_PREFIX.exec(t);
		return i ? parseFloat(i[1]) : void 0 !== e ? e : 1;
	}
	var utils$1 = null,
		utils = Object.freeze({
			__proto__: null,
			default: utils$1,
			isMobile: isMobile$3,
			EventEmitter: eventemitter3$1,
			earcut: earcut_1,
			BaseTextureCache: BaseTextureCache$3,
			CanvasRenderTarget,
			DATA_URI,
			ProgramCache: ProgramCache$3,
			TextureCache: TextureCache$3,
			clearTextureCache,
			correctBlendMode,
			createIndicesForQuads: createIndicesForQuads$1,
			decomposeDataUri,
			deprecation: deprecation$3,
			destroyTextureCache,
			determineCrossOrigin: determineCrossOrigin$3,
			getBufferType: getBufferType$3,
			getResolutionOfUrl: getResolutionOfUrl$3,
			hex2rgb: hex2rgb$3,
			hex2string: hex2string$3,
			interleaveTypedArrays: interleaveTypedArrays$4,
			isPow2: isPow2$3,
			isWebGLSupported: isWebGLSupported$3,
			log2: log2$3,
			nextPow2: nextPow2$3,
			premultiplyBlendMode: premultiplyBlendMode$3,
			premultiplyRgba,
			premultiplyTint: premultiplyTint$3,
			premultiplyTintToRgba,
			removeItems: removeItems$3,
			rgb2hex,
			sayHello: sayHello$3,
			sign,
			skipHello,
			string2hex,
			trimCanvas,
			uid: uid$3,
			url: url2$2,
		});
	/*!
	 * @pixi/display - v6.4.2
	 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
	 *
	 * @pixi/display is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 */
	settings$4.SORTABLE_CHILDREN = !1;
	var Bounds$2 = (function () {
			function t() {
				(this.minX = 1 / 0),
					(this.minY = 1 / 0),
					(this.maxX = -1 / 0),
					(this.maxY = -1 / 0),
					(this.rect = null),
					(this.updateID = -1);
			}
			return (
				(t.prototype.isEmpty = function () {
					return this.minX > this.maxX || this.minY > this.maxY;
				}),
				(t.prototype.clear = function () {
					(this.minX = 1 / 0),
						(this.minY = 1 / 0),
						(this.maxX = -1 / 0),
						(this.maxY = -1 / 0);
				}),
				(t.prototype.getRectangle = function (t) {
					return this.minX > this.maxX || this.minY > this.maxY
						? Rectangle$4.EMPTY
						: (((t = t || new Rectangle$4(0, 0, 1, 1)).x = this.minX),
						  (t.y = this.minY),
						  (t.width = this.maxX - this.minX),
						  (t.height = this.maxY - this.minY),
						  t);
				}),
				(t.prototype.addPoint = function (t) {
					(this.minX = Math.min(this.minX, t.x)),
						(this.maxX = Math.max(this.maxX, t.x)),
						(this.minY = Math.min(this.minY, t.y)),
						(this.maxY = Math.max(this.maxY, t.y));
				}),
				(t.prototype.addPointMatrix = function (t, e) {
					var i = t.a,
						r = t.b,
						s = t.c,
						n = t.d,
						a = t.tx,
						o = t.ty,
						h = i * e.x + s * e.y + a,
						u = r * e.x + n * e.y + o;
					(this.minX = Math.min(this.minX, h)),
						(this.maxX = Math.max(this.maxX, h)),
						(this.minY = Math.min(this.minY, u)),
						(this.maxY = Math.max(this.maxY, u));
				}),
				(t.prototype.addQuad = function (t) {
					var e = this.minX,
						i = this.minY,
						r = this.maxX,
						s = this.maxY,
						n = t[0],
						a = t[1];
					(e = n < e ? n : e),
						(i = a < i ? a : i),
						(r = n > r ? n : r),
						(s = a > s ? a : s),
						(e = (n = t[2]) < e ? n : e),
						(i = (a = t[3]) < i ? a : i),
						(r = n > r ? n : r),
						(s = a > s ? a : s),
						(e = (n = t[4]) < e ? n : e),
						(i = (a = t[5]) < i ? a : i),
						(r = n > r ? n : r),
						(s = a > s ? a : s),
						(e = (n = t[6]) < e ? n : e),
						(i = (a = t[7]) < i ? a : i),
						(r = n > r ? n : r),
						(s = a > s ? a : s),
						(this.minX = e),
						(this.minY = i),
						(this.maxX = r),
						(this.maxY = s);
				}),
				(t.prototype.addFrame = function (t, e, i, r, s) {
					this.addFrameMatrix(t.worldTransform, e, i, r, s);
				}),
				(t.prototype.addFrameMatrix = function (t, e, i, r, s) {
					var n = t.a,
						a = t.b,
						o = t.c,
						h = t.d,
						u = t.tx,
						l = t.ty,
						c = this.minX,
						d = this.minY,
						p = this.maxX,
						f = this.maxY,
						m = n * e + o * i + u,
						_ = a * e + h * i + l;
					(c = m < c ? m : c),
						(d = _ < d ? _ : d),
						(p = m > p ? m : p),
						(f = _ > f ? _ : f),
						(c = (m = n * r + o * i + u) < c ? m : c),
						(d = (_ = a * r + h * i + l) < d ? _ : d),
						(p = m > p ? m : p),
						(f = _ > f ? _ : f),
						(c = (m = n * e + o * s + u) < c ? m : c),
						(d = (_ = a * e + h * s + l) < d ? _ : d),
						(p = m > p ? m : p),
						(f = _ > f ? _ : f),
						(c = (m = n * r + o * s + u) < c ? m : c),
						(d = (_ = a * r + h * s + l) < d ? _ : d),
						(p = m > p ? m : p),
						(f = _ > f ? _ : f),
						(this.minX = c),
						(this.minY = d),
						(this.maxX = p),
						(this.maxY = f);
				}),
				(t.prototype.addVertexData = function (t, e, i) {
					for (
						var r = this.minX,
							s = this.minY,
							n = this.maxX,
							a = this.maxY,
							o = e;
						o < i;
						o += 2
					) {
						var h = t[o],
							u = t[o + 1];
						(r = h < r ? h : r),
							(s = u < s ? u : s),
							(n = h > n ? h : n),
							(a = u > a ? u : a);
					}
					(this.minX = r), (this.minY = s), (this.maxX = n), (this.maxY = a);
				}),
				(t.prototype.addVertices = function (t, e, i, r) {
					this.addVerticesMatrix(t.worldTransform, e, i, r);
				}),
				(t.prototype.addVerticesMatrix = function (t, e, i, r, s, n) {
					void 0 === s && (s = 0), void 0 === n && (n = s);
					for (
						var a = t.a,
							o = t.b,
							h = t.c,
							u = t.d,
							l = t.tx,
							c = t.ty,
							d = this.minX,
							p = this.minY,
							f = this.maxX,
							m = this.maxY,
							_ = i;
						_ < r;
						_ += 2
					) {
						var g = e[_],
							E = e[_ + 1],
							y = a * g + h * E + l,
							T = u * E + o * g + c;
						(d = Math.min(d, y - s)),
							(f = Math.max(f, y + s)),
							(p = Math.min(p, T - n)),
							(m = Math.max(m, T + n));
					}
					(this.minX = d), (this.minY = p), (this.maxX = f), (this.maxY = m);
				}),
				(t.prototype.addBounds = function (t) {
					var e = this.minX,
						i = this.minY,
						r = this.maxX,
						s = this.maxY;
					(this.minX = t.minX < e ? t.minX : e),
						(this.minY = t.minY < i ? t.minY : i),
						(this.maxX = t.maxX > r ? t.maxX : r),
						(this.maxY = t.maxY > s ? t.maxY : s);
				}),
				(t.prototype.addBoundsMask = function (t, e) {
					var i = t.minX > e.minX ? t.minX : e.minX,
						r = t.minY > e.minY ? t.minY : e.minY,
						s = t.maxX < e.maxX ? t.maxX : e.maxX,
						n = t.maxY < e.maxY ? t.maxY : e.maxY;
					if (i <= s && r <= n) {
						var a = this.minX,
							o = this.minY,
							h = this.maxX,
							u = this.maxY;
						(this.minX = i < a ? i : a),
							(this.minY = r < o ? r : o),
							(this.maxX = s > h ? s : h),
							(this.maxY = n > u ? n : u);
					}
				}),
				(t.prototype.addBoundsMatrix = function (t, e) {
					this.addFrameMatrix(e, t.minX, t.minY, t.maxX, t.maxY);
				}),
				(t.prototype.addBoundsArea = function (t, e) {
					var i = t.minX > e.x ? t.minX : e.x,
						r = t.minY > e.y ? t.minY : e.y,
						s = t.maxX < e.x + e.width ? t.maxX : e.x + e.width,
						n = t.maxY < e.y + e.height ? t.maxY : e.y + e.height;
					if (i <= s && r <= n) {
						var a = this.minX,
							o = this.minY,
							h = this.maxX,
							u = this.maxY;
						(this.minX = i < a ? i : a),
							(this.minY = r < o ? r : o),
							(this.maxX = s > h ? s : h),
							(this.maxY = n > u ? n : u);
					}
				}),
				(t.prototype.pad = function (t, e) {
					void 0 === t && (t = 0),
						void 0 === e && (e = t),
						this.isEmpty() ||
							((this.minX -= t),
							(this.maxX += t),
							(this.minY -= e),
							(this.maxY += e));
				}),
				(t.prototype.addFramePad = function (t, e, i, r, s, n) {
					(t -= s),
						(e -= n),
						(i += s),
						(r += n),
						(this.minX = this.minX < t ? this.minX : t),
						(this.maxX = this.maxX > i ? this.maxX : i),
						(this.minY = this.minY < e ? this.minY : e),
						(this.maxY = this.maxY > r ? this.maxY : r);
				}),
				t
			);
		})(),
		extendStatics$o = function (t, e) {
			return (extendStatics$o =
				Object.setPrototypeOf ||
				({ __proto__: [] } instanceof Array &&
					function (t, e) {
						t.__proto__ = e;
					}) ||
				function (t, e) {
					for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
				})(t, e);
		};
	/*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */ function __extends$o(
		t,
		e
	) {
		function i() {
			this.constructor = t;
		}
		extendStatics$o(t, e),
			(t.prototype =
				null === e ? Object.create(e) : ((i.prototype = e.prototype), new i()));
	}
	var DisplayObject$2 = (function (t) {
			function e() {
				var e = t.call(this) || this;
				return (
					(e.tempDisplayObjectParent = null),
					(e.transform = new Transform$1()),
					(e.alpha = 1),
					(e.visible = !0),
					(e.renderable = !0),
					(e.cullable = !1),
					(e.cullArea = null),
					(e.parent = null),
					(e.worldAlpha = 1),
					(e._lastSortedIndex = 0),
					(e._zIndex = 0),
					(e.filterArea = null),
					(e.filters = null),
					(e._enabledFilters = null),
					(e._bounds = new Bounds$2()),
					(e._localBounds = null),
					(e._boundsID = 0),
					(e._boundsRect = null),
					(e._localBoundsRect = null),
					(e._mask = null),
					(e._maskRefCount = 0),
					(e._destroyed = !1),
					(e.isSprite = !1),
					(e.isMask = !1),
					e
				);
			}
			return (
				__extends$o(e, t),
				(e.mixin = function (t) {
					for (var i = Object.keys(t), r = 0; r < i.length; ++r) {
						var s = i[r];
						Object.defineProperty(
							e.prototype,
							s,
							Object.getOwnPropertyDescriptor(t, s)
						);
					}
				}),
				Object.defineProperty(e.prototype, 'destroyed', {
					get: function () {
						return this._destroyed;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype._recursivePostUpdateTransform = function () {
					this.parent
						? (this.parent._recursivePostUpdateTransform(),
						  this.transform.updateTransform(this.parent.transform))
						: this.transform.updateTransform(
								this._tempDisplayObjectParent.transform
						  );
				}),
				(e.prototype.updateTransform = function () {
					this._boundsID++,
						this.transform.updateTransform(this.parent.transform),
						(this.worldAlpha = this.alpha * this.parent.worldAlpha);
				}),
				(e.prototype.getBounds = function (t, e) {
					return (
						t ||
							(this.parent
								? (this._recursivePostUpdateTransform(), this.updateTransform())
								: ((this.parent = this._tempDisplayObjectParent),
								  this.updateTransform(),
								  (this.parent = null))),
						this._bounds.updateID !== this._boundsID &&
							(this.calculateBounds(),
							(this._bounds.updateID = this._boundsID)),
						e ||
							(this._boundsRect || (this._boundsRect = new Rectangle$4()),
							(e = this._boundsRect)),
						this._bounds.getRectangle(e)
					);
				}),
				(e.prototype.getLocalBounds = function (t) {
					t ||
						(this._localBoundsRect ||
							(this._localBoundsRect = new Rectangle$4()),
						(t = this._localBoundsRect)),
						this._localBounds || (this._localBounds = new Bounds$2());
					var e = this.transform,
						i = this.parent;
					(this.parent = null),
						(this.transform = this._tempDisplayObjectParent.transform);
					var r = this._bounds,
						s = this._boundsID;
					this._bounds = this._localBounds;
					var n = this.getBounds(!1, t);
					return (
						(this.parent = i),
						(this.transform = e),
						(this._bounds = r),
						(this._bounds.updateID += this._boundsID - s),
						n
					);
				}),
				(e.prototype.toGlobal = function (t, e, i) {
					return (
						void 0 === i && (i = !1),
						i ||
							(this._recursivePostUpdateTransform(),
							this.parent
								? this.displayObjectUpdateTransform()
								: ((this.parent = this._tempDisplayObjectParent),
								  this.displayObjectUpdateTransform(),
								  (this.parent = null))),
						this.worldTransform.apply(t, e)
					);
				}),
				(e.prototype.toLocal = function (t, e, i, r) {
					return (
						e && (t = e.toGlobal(t, i, r)),
						r ||
							(this._recursivePostUpdateTransform(),
							this.parent
								? this.displayObjectUpdateTransform()
								: ((this.parent = this._tempDisplayObjectParent),
								  this.displayObjectUpdateTransform(),
								  (this.parent = null))),
						this.worldTransform.applyInverse(t, i)
					);
				}),
				(e.prototype.setParent = function (t) {
					if (!t || !t.addChild)
						throw new Error('setParent: Argument must be a Container');
					return t.addChild(this), t;
				}),
				(e.prototype.setTransform = function (t, e, i, r, s, n, a, o, h) {
					return (
						void 0 === t && (t = 0),
						void 0 === e && (e = 0),
						void 0 === i && (i = 1),
						void 0 === r && (r = 1),
						void 0 === s && (s = 0),
						void 0 === n && (n = 0),
						void 0 === a && (a = 0),
						void 0 === o && (o = 0),
						void 0 === h && (h = 0),
						(this.position.x = t),
						(this.position.y = e),
						(this.scale.x = i || 1),
						(this.scale.y = r || 1),
						(this.rotation = s),
						(this.skew.x = n),
						(this.skew.y = a),
						(this.pivot.x = o),
						(this.pivot.y = h),
						this
					);
				}),
				(e.prototype.destroy = function (t) {
					this.parent && this.parent.removeChild(this),
						(this._destroyed = !0),
						(this.transform = null),
						(this.parent = null),
						(this._bounds = null),
						(this.mask = null),
						(this.cullArea = null),
						(this.filters = null),
						(this.filterArea = null),
						(this.hitArea = null),
						(this.interactive = !1),
						(this.interactiveChildren = !1),
						this.emit('destroyed'),
						this.removeAllListeners();
				}),
				Object.defineProperty(e.prototype, '_tempDisplayObjectParent', {
					get: function () {
						return (
							null === this.tempDisplayObjectParent &&
								(this.tempDisplayObjectParent = new TemporaryDisplayObject$2()),
							this.tempDisplayObjectParent
						);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.enableTempParent = function () {
					var t = this.parent;
					return (this.parent = this._tempDisplayObjectParent), t;
				}),
				(e.prototype.disableTempParent = function (t) {
					this.parent = t;
				}),
				Object.defineProperty(e.prototype, 'x', {
					get: function () {
						return this.position.x;
					},
					set: function (t) {
						this.transform.position.x = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'y', {
					get: function () {
						return this.position.y;
					},
					set: function (t) {
						this.transform.position.y = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'worldTransform', {
					get: function () {
						return this.transform.worldTransform;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'localTransform', {
					get: function () {
						return this.transform.localTransform;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'position', {
					get: function () {
						return this.transform.position;
					},
					set: function (t) {
						this.transform.position.copyFrom(t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'scale', {
					get: function () {
						return this.transform.scale;
					},
					set: function (t) {
						this.transform.scale.copyFrom(t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'pivot', {
					get: function () {
						return this.transform.pivot;
					},
					set: function (t) {
						this.transform.pivot.copyFrom(t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'skew', {
					get: function () {
						return this.transform.skew;
					},
					set: function (t) {
						this.transform.skew.copyFrom(t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'rotation', {
					get: function () {
						return this.transform.rotation;
					},
					set: function (t) {
						this.transform.rotation = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'angle', {
					get: function () {
						return this.transform.rotation * RAD_TO_DEG$1;
					},
					set: function (t) {
						this.transform.rotation = t * DEG_TO_RAD$1;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'zIndex', {
					get: function () {
						return this._zIndex;
					},
					set: function (t) {
						(this._zIndex = t), this.parent && (this.parent.sortDirty = !0);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'worldVisible', {
					get: function () {
						var t = this;
						do {
							if (!t.visible) return !1;
							t = t.parent;
						} while (t);
						return !0;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'mask', {
					get: function () {
						return this._mask;
					},
					set: function (t) {
						var e;
						this._mask !== t &&
							(this._mask &&
								((e = this._mask.maskObject || this._mask)._maskRefCount--,
								0 === e._maskRefCount &&
									((e.renderable = !0), (e.isMask = !1))),
							(this._mask = t),
							this._mask &&
								(0 ===
									(e = this._mask.maskObject || this._mask)._maskRefCount &&
									((e.renderable = !1), (e.isMask = !0)),
								e._maskRefCount++));
					},
					enumerable: !1,
					configurable: !0,
				}),
				e
			);
		})(eventemitter3$1),
		TemporaryDisplayObject$2 = (function (t) {
			function e() {
				var e = (null !== t && t.apply(this, arguments)) || this;
				return (e.sortDirty = null), e;
			}
			return __extends$o(e, t), e;
		})(DisplayObject$2),
		ENV$7,
		RENDERER_TYPE$7,
		BUFFER_BITS$7,
		BLEND_MODES$7,
		DRAW_MODES$7,
		FORMATS$7,
		TARGETS$7,
		TYPES$7,
		SAMPLER_TYPES$7,
		SCALE_MODES$7,
		WRAP_MODES$7,
		MIPMAP_MODES$7,
		ALPHA_MODES$7,
		CLEAR_MODES$7,
		GC_MODES$7,
		PRECISION$7,
		MASK_TYPES$7,
		MSAA_QUALITY$7,
		BUFFER_TYPE$7;
	function sortChildren$2(t, e) {
		return t.zIndex === e.zIndex
			? t._lastSortedIndex - e._lastSortedIndex
			: t.zIndex - e.zIndex;
	}
	(DisplayObject$2.prototype.displayObjectUpdateTransform =
		DisplayObject$2.prototype.updateTransform),
		(function (t) {
			(t[(t.WEBGL_LEGACY = 0)] = 'WEBGL_LEGACY'),
				(t[(t.WEBGL = 1)] = 'WEBGL'),
				(t[(t.WEBGL2 = 2)] = 'WEBGL2');
		})(ENV$7 || (ENV$7 = {})),
		(function (t) {
			(t[(t.UNKNOWN = 0)] = 'UNKNOWN'),
				(t[(t.WEBGL = 1)] = 'WEBGL'),
				(t[(t.CANVAS = 2)] = 'CANVAS');
		})(RENDERER_TYPE$7 || (RENDERER_TYPE$7 = {})),
		(function (t) {
			(t[(t.COLOR = 16384)] = 'COLOR'),
				(t[(t.DEPTH = 256)] = 'DEPTH'),
				(t[(t.STENCIL = 1024)] = 'STENCIL');
		})(BUFFER_BITS$7 || (BUFFER_BITS$7 = {})),
		(function (t) {
			(t[(t.NORMAL = 0)] = 'NORMAL'),
				(t[(t.ADD = 1)] = 'ADD'),
				(t[(t.MULTIPLY = 2)] = 'MULTIPLY'),
				(t[(t.SCREEN = 3)] = 'SCREEN'),
				(t[(t.OVERLAY = 4)] = 'OVERLAY'),
				(t[(t.DARKEN = 5)] = 'DARKEN'),
				(t[(t.LIGHTEN = 6)] = 'LIGHTEN'),
				(t[(t.COLOR_DODGE = 7)] = 'COLOR_DODGE'),
				(t[(t.COLOR_BURN = 8)] = 'COLOR_BURN'),
				(t[(t.HARD_LIGHT = 9)] = 'HARD_LIGHT'),
				(t[(t.SOFT_LIGHT = 10)] = 'SOFT_LIGHT'),
				(t[(t.DIFFERENCE = 11)] = 'DIFFERENCE'),
				(t[(t.EXCLUSION = 12)] = 'EXCLUSION'),
				(t[(t.HUE = 13)] = 'HUE'),
				(t[(t.SATURATION = 14)] = 'SATURATION'),
				(t[(t.COLOR = 15)] = 'COLOR'),
				(t[(t.LUMINOSITY = 16)] = 'LUMINOSITY'),
				(t[(t.NORMAL_NPM = 17)] = 'NORMAL_NPM'),
				(t[(t.ADD_NPM = 18)] = 'ADD_NPM'),
				(t[(t.SCREEN_NPM = 19)] = 'SCREEN_NPM'),
				(t[(t.NONE = 20)] = 'NONE'),
				(t[(t.SRC_OVER = 0)] = 'SRC_OVER'),
				(t[(t.SRC_IN = 21)] = 'SRC_IN'),
				(t[(t.SRC_OUT = 22)] = 'SRC_OUT'),
				(t[(t.SRC_ATOP = 23)] = 'SRC_ATOP'),
				(t[(t.DST_OVER = 24)] = 'DST_OVER'),
				(t[(t.DST_IN = 25)] = 'DST_IN'),
				(t[(t.DST_OUT = 26)] = 'DST_OUT'),
				(t[(t.DST_ATOP = 27)] = 'DST_ATOP'),
				(t[(t.ERASE = 26)] = 'ERASE'),
				(t[(t.SUBTRACT = 28)] = 'SUBTRACT'),
				(t[(t.XOR = 29)] = 'XOR');
		})(BLEND_MODES$7 || (BLEND_MODES$7 = {})),
		(function (t) {
			(t[(t.POINTS = 0)] = 'POINTS'),
				(t[(t.LINES = 1)] = 'LINES'),
				(t[(t.LINE_LOOP = 2)] = 'LINE_LOOP'),
				(t[(t.LINE_STRIP = 3)] = 'LINE_STRIP'),
				(t[(t.TRIANGLES = 4)] = 'TRIANGLES'),
				(t[(t.TRIANGLE_STRIP = 5)] = 'TRIANGLE_STRIP'),
				(t[(t.TRIANGLE_FAN = 6)] = 'TRIANGLE_FAN');
		})(DRAW_MODES$7 || (DRAW_MODES$7 = {})),
		(function (t) {
			(t[(t.RGBA = 6408)] = 'RGBA'),
				(t[(t.RGB = 6407)] = 'RGB'),
				(t[(t.RG = 33319)] = 'RG'),
				(t[(t.RED = 6403)] = 'RED'),
				(t[(t.RGBA_INTEGER = 36249)] = 'RGBA_INTEGER'),
				(t[(t.RGB_INTEGER = 36248)] = 'RGB_INTEGER'),
				(t[(t.RG_INTEGER = 33320)] = 'RG_INTEGER'),
				(t[(t.RED_INTEGER = 36244)] = 'RED_INTEGER'),
				(t[(t.ALPHA = 6406)] = 'ALPHA'),
				(t[(t.LUMINANCE = 6409)] = 'LUMINANCE'),
				(t[(t.LUMINANCE_ALPHA = 6410)] = 'LUMINANCE_ALPHA'),
				(t[(t.DEPTH_COMPONENT = 6402)] = 'DEPTH_COMPONENT'),
				(t[(t.DEPTH_STENCIL = 34041)] = 'DEPTH_STENCIL');
		})(FORMATS$7 || (FORMATS$7 = {})),
		(function (t) {
			(t[(t.TEXTURE_2D = 3553)] = 'TEXTURE_2D'),
				(t[(t.TEXTURE_CUBE_MAP = 34067)] = 'TEXTURE_CUBE_MAP'),
				(t[(t.TEXTURE_2D_ARRAY = 35866)] = 'TEXTURE_2D_ARRAY'),
				(t[(t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069)] =
					'TEXTURE_CUBE_MAP_POSITIVE_X'),
				(t[(t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070)] =
					'TEXTURE_CUBE_MAP_NEGATIVE_X'),
				(t[(t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071)] =
					'TEXTURE_CUBE_MAP_POSITIVE_Y'),
				(t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072)] =
					'TEXTURE_CUBE_MAP_NEGATIVE_Y'),
				(t[(t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073)] =
					'TEXTURE_CUBE_MAP_POSITIVE_Z'),
				(t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074)] =
					'TEXTURE_CUBE_MAP_NEGATIVE_Z');
		})(TARGETS$7 || (TARGETS$7 = {})),
		(function (t) {
			(t[(t.UNSIGNED_BYTE = 5121)] = 'UNSIGNED_BYTE'),
				(t[(t.UNSIGNED_SHORT = 5123)] = 'UNSIGNED_SHORT'),
				(t[(t.UNSIGNED_SHORT_5_6_5 = 33635)] = 'UNSIGNED_SHORT_5_6_5'),
				(t[(t.UNSIGNED_SHORT_4_4_4_4 = 32819)] = 'UNSIGNED_SHORT_4_4_4_4'),
				(t[(t.UNSIGNED_SHORT_5_5_5_1 = 32820)] = 'UNSIGNED_SHORT_5_5_5_1'),
				(t[(t.UNSIGNED_INT = 5125)] = 'UNSIGNED_INT'),
				(t[(t.UNSIGNED_INT_10F_11F_11F_REV = 35899)] =
					'UNSIGNED_INT_10F_11F_11F_REV'),
				(t[(t.UNSIGNED_INT_2_10_10_10_REV = 33640)] =
					'UNSIGNED_INT_2_10_10_10_REV'),
				(t[(t.UNSIGNED_INT_24_8 = 34042)] = 'UNSIGNED_INT_24_8'),
				(t[(t.UNSIGNED_INT_5_9_9_9_REV = 35902)] = 'UNSIGNED_INT_5_9_9_9_REV'),
				(t[(t.BYTE = 5120)] = 'BYTE'),
				(t[(t.SHORT = 5122)] = 'SHORT'),
				(t[(t.INT = 5124)] = 'INT'),
				(t[(t.FLOAT = 5126)] = 'FLOAT'),
				(t[(t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269)] =
					'FLOAT_32_UNSIGNED_INT_24_8_REV'),
				(t[(t.HALF_FLOAT = 36193)] = 'HALF_FLOAT');
		})(TYPES$7 || (TYPES$7 = {})),
		(function (t) {
			(t[(t.FLOAT = 0)] = 'FLOAT'),
				(t[(t.INT = 1)] = 'INT'),
				(t[(t.UINT = 2)] = 'UINT');
		})(SAMPLER_TYPES$7 || (SAMPLER_TYPES$7 = {})),
		(function (t) {
			(t[(t.NEAREST = 0)] = 'NEAREST'), (t[(t.LINEAR = 1)] = 'LINEAR');
		})(SCALE_MODES$7 || (SCALE_MODES$7 = {})),
		(function (t) {
			(t[(t.CLAMP = 33071)] = 'CLAMP'),
				(t[(t.REPEAT = 10497)] = 'REPEAT'),
				(t[(t.MIRRORED_REPEAT = 33648)] = 'MIRRORED_REPEAT');
		})(WRAP_MODES$7 || (WRAP_MODES$7 = {})),
		(function (t) {
			(t[(t.OFF = 0)] = 'OFF'),
				(t[(t.POW2 = 1)] = 'POW2'),
				(t[(t.ON = 2)] = 'ON'),
				(t[(t.ON_MANUAL = 3)] = 'ON_MANUAL');
		})(MIPMAP_MODES$7 || (MIPMAP_MODES$7 = {})),
		(function (t) {
			(t[(t.NPM = 0)] = 'NPM'),
				(t[(t.UNPACK = 1)] = 'UNPACK'),
				(t[(t.PMA = 2)] = 'PMA'),
				(t[(t.NO_PREMULTIPLIED_ALPHA = 0)] = 'NO_PREMULTIPLIED_ALPHA'),
				(t[(t.PREMULTIPLY_ON_UPLOAD = 1)] = 'PREMULTIPLY_ON_UPLOAD'),
				(t[(t.PREMULTIPLY_ALPHA = 2)] = 'PREMULTIPLY_ALPHA'),
				(t[(t.PREMULTIPLIED_ALPHA = 2)] = 'PREMULTIPLIED_ALPHA');
		})(ALPHA_MODES$7 || (ALPHA_MODES$7 = {})),
		(function (t) {
			(t[(t.NO = 0)] = 'NO'),
				(t[(t.YES = 1)] = 'YES'),
				(t[(t.AUTO = 2)] = 'AUTO'),
				(t[(t.BLEND = 0)] = 'BLEND'),
				(t[(t.CLEAR = 1)] = 'CLEAR'),
				(t[(t.BLIT = 2)] = 'BLIT');
		})(CLEAR_MODES$7 || (CLEAR_MODES$7 = {})),
		(function (t) {
			(t[(t.AUTO = 0)] = 'AUTO'), (t[(t.MANUAL = 1)] = 'MANUAL');
		})(GC_MODES$7 || (GC_MODES$7 = {})),
		(function (t) {
			(t.LOW = 'lowp'), (t.MEDIUM = 'mediump'), (t.HIGH = 'highp');
		})(PRECISION$7 || (PRECISION$7 = {})),
		(function (t) {
			(t[(t.NONE = 0)] = 'NONE'),
				(t[(t.SCISSOR = 1)] = 'SCISSOR'),
				(t[(t.STENCIL = 2)] = 'STENCIL'),
				(t[(t.SPRITE = 3)] = 'SPRITE');
		})(MASK_TYPES$7 || (MASK_TYPES$7 = {})),
		(function (t) {
			(t[(t.NONE = 0)] = 'NONE'),
				(t[(t.LOW = 2)] = 'LOW'),
				(t[(t.MEDIUM = 4)] = 'MEDIUM'),
				(t[(t.HIGH = 8)] = 'HIGH');
		})(MSAA_QUALITY$7 || (MSAA_QUALITY$7 = {})),
		(function (t) {
			(t[(t.ELEMENT_ARRAY_BUFFER = 34963)] = 'ELEMENT_ARRAY_BUFFER'),
				(t[(t.ARRAY_BUFFER = 34962)] = 'ARRAY_BUFFER'),
				(t[(t.UNIFORM_BUFFER = 35345)] = 'UNIFORM_BUFFER');
		})(BUFFER_TYPE$7 || (BUFFER_TYPE$7 = {}));
	var Container$2 = (function (t) {
		function e() {
			var e = t.call(this) || this;
			return (
				(e.children = []),
				(e.sortableChildren = settings$4.SORTABLE_CHILDREN),
				(e.sortDirty = !1),
				e
			);
		}
		return (
			__extends$o(e, t),
			(e.prototype.onChildrenChange = function (t) {}),
			(e.prototype.addChild = function () {
				for (var t = arguments, e = [], i = 0; i < arguments.length; i++)
					e[i] = t[i];
				if (e.length > 1)
					for (var r = 0; r < e.length; r++) this.addChild(e[r]);
				else {
					var s = e[0];
					s.parent && s.parent.removeChild(s),
						(s.parent = this),
						(this.sortDirty = !0),
						(s.transform._parentID = -1),
						this.children.push(s),
						this._boundsID++,
						this.onChildrenChange(this.children.length - 1),
						this.emit('childAdded', s, this, this.children.length - 1),
						s.emit('added', this);
				}
				return e[0];
			}),
			(e.prototype.addChildAt = function (t, e) {
				if (e < 0 || e > this.children.length)
					throw new Error(
						t +
							'addChildAt: The index ' +
							e +
							' supplied is out of bounds ' +
							this.children.length
					);
				return (
					t.parent && t.parent.removeChild(t),
					(t.parent = this),
					(this.sortDirty = !0),
					(t.transform._parentID = -1),
					this.children.splice(e, 0, t),
					this._boundsID++,
					this.onChildrenChange(e),
					t.emit('added', this),
					this.emit('childAdded', t, this, e),
					t
				);
			}),
			(e.prototype.swapChildren = function (t, e) {
				if (t !== e) {
					var i = this.getChildIndex(t),
						r = this.getChildIndex(e);
					(this.children[i] = e),
						(this.children[r] = t),
						this.onChildrenChange(i < r ? i : r);
				}
			}),
			(e.prototype.getChildIndex = function (t) {
				var e = this.children.indexOf(t);
				if (-1 === e)
					throw new Error(
						'The supplied DisplayObject must be a child of the caller'
					);
				return e;
			}),
			(e.prototype.setChildIndex = function (t, e) {
				if (e < 0 || e >= this.children.length)
					throw new Error(
						'The index ' +
							e +
							' supplied is out of bounds ' +
							this.children.length
					);
				var i = this.getChildIndex(t);
				removeItems$3(this.children, i, 1),
					this.children.splice(e, 0, t),
					this.onChildrenChange(e);
			}),
			(e.prototype.getChildAt = function (t) {
				if (t < 0 || t >= this.children.length)
					throw new Error('getChildAt: Index (' + t + ') does not exist.');
				return this.children[t];
			}),
			(e.prototype.removeChild = function () {
				for (var t = arguments, e = [], i = 0; i < arguments.length; i++)
					e[i] = t[i];
				if (e.length > 1)
					for (var r = 0; r < e.length; r++) this.removeChild(e[r]);
				else {
					var s = e[0],
						n = this.children.indexOf(s);
					if (-1 === n) return null;
					(s.parent = null),
						(s.transform._parentID = -1),
						removeItems$3(this.children, n, 1),
						this._boundsID++,
						this.onChildrenChange(n),
						s.emit('removed', this),
						this.emit('childRemoved', s, this, n);
				}
				return e[0];
			}),
			(e.prototype.removeChildAt = function (t) {
				var e = this.getChildAt(t);
				return (
					(e.parent = null),
					(e.transform._parentID = -1),
					removeItems$3(this.children, t, 1),
					this._boundsID++,
					this.onChildrenChange(t),
					e.emit('removed', this),
					this.emit('childRemoved', e, this, t),
					e
				);
			}),
			(e.prototype.removeChildren = function (t, e) {
				void 0 === t && (t = 0), void 0 === e && (e = this.children.length);
				var i,
					r = t,
					s = e - r;
				if (s > 0 && s <= e) {
					i = this.children.splice(r, s);
					for (var n = 0; n < i.length; ++n)
						(i[n].parent = null),
							i[n].transform && (i[n].transform._parentID = -1);
					for (
						this._boundsID++, this.onChildrenChange(t), n = 0;
						n < i.length;
						++n
					)
						i[n].emit('removed', this),
							this.emit('childRemoved', i[n], this, n);
					return i;
				}
				if (0 === s && 0 === this.children.length) return [];
				throw new RangeError(
					'removeChildren: numeric values are outside the acceptable range.'
				);
			}),
			(e.prototype.sortChildren = function () {
				for (var t = !1, e = 0, i = this.children.length; e < i; ++e) {
					var r = this.children[e];
					(r._lastSortedIndex = e), t || 0 === r.zIndex || (t = !0);
				}
				t && this.children.length > 1 && this.children.sort(sortChildren$2),
					(this.sortDirty = !1);
			}),
			(e.prototype.updateTransform = function () {
				this.sortableChildren && this.sortDirty && this.sortChildren(),
					this._boundsID++,
					this.transform.updateTransform(this.parent.transform),
					(this.worldAlpha = this.alpha * this.parent.worldAlpha);
				for (var t = 0, e = this.children.length; t < e; ++t) {
					var i = this.children[t];
					i.visible && i.updateTransform();
				}
			}),
			(e.prototype.calculateBounds = function () {
				this._bounds.clear(), this._calculateBounds();
				for (var t = 0; t < this.children.length; t++) {
					var e = this.children[t];
					if (e.visible && e.renderable)
						if ((e.calculateBounds(), e._mask)) {
							var i = e._mask.maskObject || e._mask;
							i.calculateBounds(),
								this._bounds.addBoundsMask(e._bounds, i._bounds);
						} else
							e.filterArea
								? this._bounds.addBoundsArea(e._bounds, e.filterArea)
								: this._bounds.addBounds(e._bounds);
				}
				this._bounds.updateID = this._boundsID;
			}),
			(e.prototype.getLocalBounds = function (e, i) {
				void 0 === i && (i = !1);
				var r = t.prototype.getLocalBounds.call(this, e);
				if (!i)
					for (var s = 0, n = this.children.length; s < n; ++s) {
						var a = this.children[s];
						a.visible && a.updateTransform();
					}
				return r;
			}),
			(e.prototype._calculateBounds = function () {}),
			(e.prototype._renderWithCulling = function (t) {
				var i = t.renderTexture.sourceFrame;
				if (i.width > 0 && i.height > 0) {
					var r, s;
					if (
						(this.cullArea
							? ((r = this.cullArea), (s = this.worldTransform))
							: this._render !== e.prototype._render &&
							  (r = this.getBounds(!0)),
						r && i.intersects(r, s))
					)
						this._render(t);
					else if (this.cullArea) return;
					for (var n = 0, a = this.children.length; n < a; ++n) {
						var o = this.children[n],
							h = o.cullable;
						(o.cullable = h || !this.cullArea), o.render(t), (o.cullable = h);
					}
				}
			}),
			(e.prototype.render = function (t) {
				if (this.visible && !(this.worldAlpha <= 0) && this.renderable)
					if (this._mask || (this.filters && this.filters.length))
						this.renderAdvanced(t);
					else if (this.cullable) this._renderWithCulling(t);
					else {
						this._render(t);
						for (var e = 0, i = this.children.length; e < i; ++e)
							this.children[e].render(t);
					}
			}),
			(e.prototype.renderAdvanced = function (t) {
				var e = this.filters,
					i = this._mask;
				if (e) {
					this._enabledFilters || (this._enabledFilters = []),
						(this._enabledFilters.length = 0);
					for (var r = 0; r < e.length; r++)
						e[r].enabled && this._enabledFilters.push(e[r]);
				}
				var s =
					(e && this._enabledFilters && this._enabledFilters.length) ||
					(i &&
						(!i.isMaskData ||
							(i.enabled && (i.autoDetect || i.type !== MASK_TYPES$7.NONE))));
				if (
					(s && t.batch.flush(),
					e &&
						this._enabledFilters &&
						this._enabledFilters.length &&
						t.filter.push(this, this._enabledFilters),
					i && t.mask.push(this, this._mask),
					this.cullable)
				)
					this._renderWithCulling(t);
				else {
					this._render(t), (r = 0);
					for (var n = this.children.length; r < n; ++r)
						this.children[r].render(t);
				}
				s && t.batch.flush(),
					i && t.mask.pop(this),
					e &&
						this._enabledFilters &&
						this._enabledFilters.length &&
						t.filter.pop();
			}),
			(e.prototype._render = function (t) {}),
			(e.prototype.destroy = function (e) {
				t.prototype.destroy.call(this), (this.sortDirty = !1);
				var i = 'boolean' == typeof e ? e : e && e.children,
					r = this.removeChildren(0, this.children.length);
				if (i) for (var s = 0; s < r.length; ++s) r[s].destroy(e);
			}),
			Object.defineProperty(e.prototype, 'width', {
				get: function () {
					return this.scale.x * this.getLocalBounds().width;
				},
				set: function (t) {
					var e = this.getLocalBounds().width;
					(this.scale.x = 0 !== e ? t / e : 1), (this._width = t);
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(e.prototype, 'height', {
				get: function () {
					return this.scale.y * this.getLocalBounds().height;
				},
				set: function (t) {
					var e = this.getLocalBounds().height;
					(this.scale.y = 0 !== e ? t / e : 1), (this._height = t);
				},
				enumerable: !1,
				configurable: !0,
			}),
			e
		);
	})(DisplayObject$2);
	(Container$2.prototype.containerUpdateTransform =
		Container$2.prototype.updateTransform),
		/*!
		 * @pixi/core - v6.4.2
		 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
		 *
		 * @pixi/core is licensed under the MIT License.
		 * http://www.opensource.org/licenses/mit-license
		 */
		(settings$4.PREFER_ENV = isMobile$3.any ? ENV$9.WEBGL : ENV$9.WEBGL2),
		(settings$4.STRICT_TEXTURE_CACHE = !1);
	var INSTALLED$3 = [];
	function autoDetectResource$3(t, e) {
		if (!t) return null;
		var i = '';
		if ('string' == typeof t) {
			var r = /\.(\w{3,4})(?:$|\?|#)/i.exec(t);
			r && (i = r[1].toLowerCase());
		}
		for (var s = INSTALLED$3.length - 1; s >= 0; --s) {
			var n = INSTALLED$3[s];
			if (n.test && n.test(t, i)) return new n(t, e);
		}
		throw new Error('Unrecognized source type to auto-detect Resource');
	}
	/*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */ var extendStatics$n =
		function (t, e) {
			return (extendStatics$n =
				Object.setPrototypeOf ||
				({ __proto__: [] } instanceof Array &&
					function (t, e) {
						t.__proto__ = e;
					}) ||
				function (t, e) {
					for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
				})(t, e);
		};
	function __extends$n(t, e) {
		function i() {
			this.constructor = t;
		}
		extendStatics$n(t, e),
			(t.prototype =
				null === e ? Object.create(e) : ((i.prototype = e.prototype), new i()));
	}
	var __assign$3 = function () {
		return (
			(__assign$3 =
				Object.assign ||
				function (t) {
					for (var e, i = arguments, r = 1, s = arguments.length; r < s; r++)
						for (var n in (e = i[r]))
							Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
					return t;
				}),
			__assign$3.apply(this, arguments)
		);
	};
	function __rest$3(t, e) {
		var i = {};
		for (var r in t)
			Object.prototype.hasOwnProperty.call(t, r) &&
				e.indexOf(r) < 0 &&
				(i[r] = t[r]);
		if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
			var s = 0;
			for (r = Object.getOwnPropertySymbols(t); s < r.length; s++)
				e.indexOf(r[s]) < 0 && (i[r[s]] = t[r[s]]);
		}
		return i;
	}
	var Resource$3 = (function () {
			function t(t, e) {
				void 0 === t && (t = 0),
					void 0 === e && (e = 0),
					(this._width = t),
					(this._height = e),
					(this.destroyed = !1),
					(this.internal = !1),
					(this.onResize = new Runner$3('setRealSize')),
					(this.onUpdate = new Runner$3('update')),
					(this.onError = new Runner$3('onError'));
			}
			return (
				(t.prototype.bind = function (t) {
					this.onResize.add(t),
						this.onUpdate.add(t),
						this.onError.add(t),
						(this._width || this._height) &&
							this.onResize.emit(this._width, this._height);
				}),
				(t.prototype.unbind = function (t) {
					this.onResize.remove(t),
						this.onUpdate.remove(t),
						this.onError.remove(t);
				}),
				(t.prototype.resize = function (t, e) {
					(t === this._width && e === this._height) ||
						((this._width = t), (this._height = e), this.onResize.emit(t, e));
				}),
				Object.defineProperty(t.prototype, 'valid', {
					get: function () {
						return !!this._width && !!this._height;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.update = function () {
					this.destroyed || this.onUpdate.emit();
				}),
				(t.prototype.load = function () {
					return Promise.resolve(this);
				}),
				Object.defineProperty(t.prototype, 'width', {
					get: function () {
						return this._width;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'height', {
					get: function () {
						return this._height;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.style = function (t, e, i) {
					return !1;
				}),
				(t.prototype.dispose = function () {}),
				(t.prototype.destroy = function () {
					this.destroyed ||
						((this.destroyed = !0),
						this.dispose(),
						this.onError.removeAll(),
						(this.onError = null),
						this.onResize.removeAll(),
						(this.onResize = null),
						this.onUpdate.removeAll(),
						(this.onUpdate = null));
				}),
				(t.test = function (t, e) {
					return !1;
				}),
				t
			);
		})(),
		BufferResource$3 = (function (t) {
			function e(e, i) {
				var r = this,
					s = i || {},
					n = s.width,
					a = s.height;
				if (!n || !a) throw new Error('BufferResource width or height invalid');
				return ((r = t.call(this, n, a) || this).data = e), r;
			}
			return (
				__extends$n(e, t),
				(e.prototype.upload = function (t, e, i) {
					var r = t.gl;
					r.pixelStorei(
						r.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
						e.alphaMode === ALPHA_MODES$9.UNPACK
					);
					var s = e.realWidth,
						n = e.realHeight;
					return (
						i.width === s && i.height === n
							? r.texSubImage2D(
									e.target,
									0,
									0,
									0,
									s,
									n,
									e.format,
									i.type,
									this.data
							  )
							: ((i.width = s),
							  (i.height = n),
							  r.texImage2D(
									e.target,
									0,
									i.internalFormat,
									s,
									n,
									0,
									e.format,
									i.type,
									this.data
							  )),
						!0
					);
				}),
				(e.prototype.dispose = function () {
					this.data = null;
				}),
				(e.test = function (t) {
					return (
						t instanceof Float32Array ||
						t instanceof Uint8Array ||
						t instanceof Uint32Array
					);
				}),
				e
			);
		})(Resource$3),
		defaultBufferOptions$3 = {
			scaleMode: SCALE_MODES$9.NEAREST,
			format: FORMATS$9.RGBA,
			alphaMode: ALPHA_MODES$9.NPM,
		},
		BaseTexture$3 = (function (t) {
			function e(e, i) {
				void 0 === e && (e = null), void 0 === i && (i = null);
				var r = t.call(this) || this,
					s = (i = i || {}).alphaMode,
					n = i.mipmap,
					a = i.anisotropicLevel,
					o = i.scaleMode,
					h = i.width,
					u = i.height,
					l = i.wrapMode,
					c = i.format,
					d = i.type,
					p = i.target,
					f = i.resolution,
					m = i.resourceOptions;
				return (
					!e ||
						e instanceof Resource$3 ||
						((e = autoDetectResource$3(e, m)).internal = !0),
					(r.resolution = f || settings$4.RESOLUTION),
					(r.width = Math.round((h || 0) * r.resolution) / r.resolution),
					(r.height = Math.round((u || 0) * r.resolution) / r.resolution),
					(r._mipmap = void 0 !== n ? n : settings$4.MIPMAP_TEXTURES),
					(r.anisotropicLevel =
						void 0 !== a ? a : settings$4.ANISOTROPIC_LEVEL),
					(r._wrapMode = l || settings$4.WRAP_MODE),
					(r._scaleMode = void 0 !== o ? o : settings$4.SCALE_MODE),
					(r.format = c || FORMATS$9.RGBA),
					(r.type = d || TYPES$9.UNSIGNED_BYTE),
					(r.target = p || TARGETS$9.TEXTURE_2D),
					(r.alphaMode = void 0 !== s ? s : ALPHA_MODES$9.UNPACK),
					(r.uid = uid$3()),
					(r.touched = 0),
					(r.isPowerOfTwo = !1),
					r._refreshPOT(),
					(r._glTextures = {}),
					(r.dirtyId = 0),
					(r.dirtyStyleId = 0),
					(r.cacheId = null),
					(r.valid = h > 0 && u > 0),
					(r.textureCacheIds = []),
					(r.destroyed = !1),
					(r.resource = null),
					(r._batchEnabled = 0),
					(r._batchLocation = 0),
					(r.parentTextureArray = null),
					r.setResource(e),
					r
				);
			}
			return (
				__extends$n(e, t),
				Object.defineProperty(e.prototype, 'realWidth', {
					get: function () {
						return Math.round(this.width * this.resolution);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'realHeight', {
					get: function () {
						return Math.round(this.height * this.resolution);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'mipmap', {
					get: function () {
						return this._mipmap;
					},
					set: function (t) {
						this._mipmap !== t && ((this._mipmap = t), this.dirtyStyleId++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'scaleMode', {
					get: function () {
						return this._scaleMode;
					},
					set: function (t) {
						this._scaleMode !== t &&
							((this._scaleMode = t), this.dirtyStyleId++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'wrapMode', {
					get: function () {
						return this._wrapMode;
					},
					set: function (t) {
						this._wrapMode !== t && ((this._wrapMode = t), this.dirtyStyleId++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.setStyle = function (t, e) {
					var i;
					return (
						void 0 !== t &&
							t !== this.scaleMode &&
							((this.scaleMode = t), (i = !0)),
						void 0 !== e && e !== this.mipmap && ((this.mipmap = e), (i = !0)),
						i && this.dirtyStyleId++,
						this
					);
				}),
				(e.prototype.setSize = function (t, e, i) {
					return (i = i || this.resolution), this.setRealSize(t * i, e * i, i);
				}),
				(e.prototype.setRealSize = function (t, e, i) {
					return (
						(this.resolution = i || this.resolution),
						(this.width = Math.round(t) / this.resolution),
						(this.height = Math.round(e) / this.resolution),
						this._refreshPOT(),
						this.update(),
						this
					);
				}),
				(e.prototype._refreshPOT = function () {
					this.isPowerOfTwo =
						isPow2$3(this.realWidth) && isPow2$3(this.realHeight);
				}),
				(e.prototype.setResolution = function (t) {
					var e = this.resolution;
					return (
						e === t ||
							((this.resolution = t),
							this.valid &&
								((this.width = Math.round(this.width * e) / t),
								(this.height = Math.round(this.height * e) / t),
								this.emit('update', this)),
							this._refreshPOT()),
						this
					);
				}),
				(e.prototype.setResource = function (t) {
					if (this.resource === t) return this;
					if (this.resource) throw new Error('Resource can be set only once');
					return t.bind(this), (this.resource = t), this;
				}),
				(e.prototype.update = function () {
					this.valid
						? (this.dirtyId++, this.dirtyStyleId++, this.emit('update', this))
						: this.width > 0 &&
						  this.height > 0 &&
						  ((this.valid = !0),
						  this.emit('loaded', this),
						  this.emit('update', this));
				}),
				(e.prototype.onError = function (t) {
					this.emit('error', this, t);
				}),
				(e.prototype.destroy = function () {
					this.resource &&
						(this.resource.unbind(this),
						this.resource.internal && this.resource.destroy(),
						(this.resource = null)),
						this.cacheId &&
							(delete BaseTextureCache$3[this.cacheId],
							delete TextureCache$3[this.cacheId],
							(this.cacheId = null)),
						this.dispose(),
						e.removeFromCache(this),
						(this.textureCacheIds = null),
						(this.destroyed = !0);
				}),
				(e.prototype.dispose = function () {
					this.emit('dispose', this);
				}),
				(e.prototype.castToBaseTexture = function () {
					return this;
				}),
				(e.from = function (t, i, r) {
					void 0 === r && (r = settings$4.STRICT_TEXTURE_CACHE);
					var s = 'string' == typeof t,
						n = null;
					if (s) n = t;
					else {
						if (!t._pixiId) {
							var a = (i && i.pixiIdPrefix) || 'pixiid';
							t._pixiId = a + '_' + uid$3();
						}
						n = t._pixiId;
					}
					var o = BaseTextureCache$3[n];
					if (s && r && !o)
						throw new Error(
							'The cacheId "' + n + '" does not exist in BaseTextureCache.'
						);
					return o || (((o = new e(t, i)).cacheId = n), e.addToCache(o, n)), o;
				}),
				(e.fromBuffer = function (t, i, r, s) {
					t = t || new Float32Array(i * r * 4);
					var n = new BufferResource$3(t, { width: i, height: r }),
						a =
							t instanceof Float32Array ? TYPES$9.FLOAT : TYPES$9.UNSIGNED_BYTE;
					return new e(
						n,
						Object.assign(
							defaultBufferOptions$3,
							s || { width: i, height: r, type: a }
						)
					);
				}),
				(e.addToCache = function (t, e) {
					e &&
						(-1 === t.textureCacheIds.indexOf(e) && t.textureCacheIds.push(e),
						BaseTextureCache$3[e],
						(BaseTextureCache$3[e] = t));
				}),
				(e.removeFromCache = function (t) {
					if ('string' == typeof t) {
						var e = BaseTextureCache$3[t];
						if (e) {
							var i = e.textureCacheIds.indexOf(t);
							return (
								i > -1 && e.textureCacheIds.splice(i, 1),
								delete BaseTextureCache$3[t],
								e
							);
						}
					} else if (t && t.textureCacheIds) {
						for (var r = 0; r < t.textureCacheIds.length; ++r)
							delete BaseTextureCache$3[t.textureCacheIds[r]];
						return (t.textureCacheIds.length = 0), t;
					}
					return null;
				}),
				(e._globalBatch = 0),
				e
			);
		})(eventemitter3$1),
		AbstractMultiResource$3 = (function (t) {
			function e(e, i) {
				var r = this,
					s = i || {},
					n = s.width,
					a = s.height;
				((r = t.call(this, n, a) || this).items = []), (r.itemDirtyIds = []);
				for (var o = 0; o < e; o++) {
					var h = new BaseTexture$3();
					r.items.push(h), r.itemDirtyIds.push(-2);
				}
				return (r.length = e), (r._load = null), (r.baseTexture = null), r;
			}
			return (
				__extends$n(e, t),
				(e.prototype.initFromArray = function (t, e) {
					for (var i = 0; i < this.length; i++)
						t[i] &&
							(t[i].castToBaseTexture
								? this.addBaseTextureAt(t[i].castToBaseTexture(), i)
								: t[i] instanceof Resource$3
								? this.addResourceAt(t[i], i)
								: this.addResourceAt(autoDetectResource$3(t[i], e), i));
				}),
				(e.prototype.dispose = function () {
					for (var t = 0, e = this.length; t < e; t++) this.items[t].destroy();
					(this.items = null), (this.itemDirtyIds = null), (this._load = null);
				}),
				(e.prototype.addResourceAt = function (t, e) {
					if (!this.items[e])
						throw new Error('Index ' + e + ' is out of bounds');
					return (
						t.valid && !this.valid && this.resize(t.width, t.height),
						this.items[e].setResource(t),
						this
					);
				}),
				(e.prototype.bind = function (e) {
					if (null !== this.baseTexture)
						throw new Error(
							'Only one base texture per TextureArray is allowed'
						);
					t.prototype.bind.call(this, e);
					for (var i = 0; i < this.length; i++)
						(this.items[i].parentTextureArray = e),
							this.items[i].on('update', e.update, e);
				}),
				(e.prototype.unbind = function (e) {
					t.prototype.unbind.call(this, e);
					for (var i = 0; i < this.length; i++)
						(this.items[i].parentTextureArray = null),
							this.items[i].off('update', e.update, e);
				}),
				(e.prototype.load = function () {
					var t = this;
					if (this._load) return this._load;
					var e = this.items
						.map(function (t) {
							return t.resource;
						})
						.filter(function (t) {
							return t;
						})
						.map(function (t) {
							return t.load();
						});
					return (
						(this._load = Promise.all(e).then(function () {
							var e = t.items[0],
								i = e.realWidth,
								r = e.realHeight;
							return t.resize(i, r), Promise.resolve(t);
						})),
						this._load
					);
				}),
				e
			);
		})(Resource$3),
		ArrayResource$3 = (function (t) {
			function e(e, i) {
				var r,
					s,
					n = this,
					a = i || {},
					o = a.width,
					h = a.height;
				return (
					Array.isArray(e) ? ((r = e), (s = e.length)) : (s = e),
					(n = t.call(this, s, { width: o, height: h }) || this),
					r && n.initFromArray(r, i),
					n
				);
			}
			return (
				__extends$n(e, t),
				(e.prototype.addBaseTextureAt = function (t, e) {
					if (!t.resource)
						throw new Error('ArrayResource does not support RenderTexture');
					return this.addResourceAt(t.resource, e), this;
				}),
				(e.prototype.bind = function (e) {
					t.prototype.bind.call(this, e),
						(e.target = TARGETS$9.TEXTURE_2D_ARRAY);
				}),
				(e.prototype.upload = function (t, e, i) {
					var r = this,
						s = r.length,
						n = r.itemDirtyIds,
						a = r.items,
						o = t.gl;
					i.dirtyId < 0 &&
						o.texImage3D(
							o.TEXTURE_2D_ARRAY,
							0,
							i.internalFormat,
							this._width,
							this._height,
							s,
							0,
							e.format,
							i.type,
							null
						);
					for (var h = 0; h < s; h++) {
						var u = a[h];
						n[h] < u.dirtyId &&
							((n[h] = u.dirtyId),
							u.valid &&
								o.texSubImage3D(
									o.TEXTURE_2D_ARRAY,
									0,
									0,
									0,
									h,
									u.resource.width,
									u.resource.height,
									1,
									e.format,
									i.type,
									u.resource.source
								));
					}
					return !0;
				}),
				e
			);
		})(AbstractMultiResource$3),
		BaseImageResource$3 = (function (t) {
			function e(e) {
				var i = this,
					r = e,
					s = r.naturalWidth || r.videoWidth || r.width,
					n = r.naturalHeight || r.videoHeight || r.height;
				return (
					((i = t.call(this, s, n) || this).source = e), (i.noSubImage = !1), i
				);
			}
			return (
				__extends$n(e, t),
				(e.crossOrigin = function (t, e, i) {
					void 0 === i && 0 !== e.indexOf('data:')
						? (t.crossOrigin = determineCrossOrigin$3(e))
						: !1 !== i &&
						  (t.crossOrigin = 'string' == typeof i ? i : 'anonymous');
				}),
				(e.prototype.upload = function (t, e, i, r) {
					var s = t.gl,
						n = e.realWidth,
						a = e.realHeight;
					if ((r = r || this.source) instanceof HTMLImageElement) {
						if (!r.complete || 0 === r.naturalWidth) return !1;
					} else if (r instanceof HTMLVideoElement && r.readyState <= 1)
						return !1;
					return (
						s.pixelStorei(
							s.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
							e.alphaMode === ALPHA_MODES$9.UNPACK
						),
						this.noSubImage ||
						e.target !== s.TEXTURE_2D ||
						i.width !== n ||
						i.height !== a
							? ((i.width = n),
							  (i.height = a),
							  s.texImage2D(
									e.target,
									0,
									i.internalFormat,
									e.format,
									i.type,
									r
							  ))
							: s.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, e.format, i.type, r),
						!0
					);
				}),
				(e.prototype.update = function () {
					if (!this.destroyed) {
						var e = this.source,
							i = e.naturalWidth || e.videoWidth || e.width,
							r = e.naturalHeight || e.videoHeight || e.height;
						this.resize(i, r), t.prototype.update.call(this);
					}
				}),
				(e.prototype.dispose = function () {
					this.source = null;
				}),
				e
			);
		})(Resource$3),
		CanvasResource$3 = (function (t) {
			function e(e) {
				return t.call(this, e) || this;
			}
			return (
				__extends$n(e, t),
				(e.test = function (t) {
					var e = globalThis.OffscreenCanvas;
					return (
						!!(e && t instanceof e) ||
						(globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement)
					);
				}),
				e
			);
		})(BaseImageResource$3),
		CubeResource$3 = (function (t) {
			function e(i, r) {
				var s = this,
					n = r || {},
					a = n.width,
					o = n.height,
					h = n.autoLoad,
					u = n.linkBaseTexture;
				if (i && i.length !== e.SIDES)
					throw new Error('Invalid length. Got ' + i.length + ', expected 6');
				s = t.call(this, 6, { width: a, height: o }) || this;
				for (var l = 0; l < e.SIDES; l++)
					s.items[l].target = TARGETS$9.TEXTURE_CUBE_MAP_POSITIVE_X + l;
				return (
					(s.linkBaseTexture = !1 !== u),
					i && s.initFromArray(i, r),
					!1 !== h && s.load(),
					s
				);
			}
			return (
				__extends$n(e, t),
				(e.prototype.bind = function (e) {
					t.prototype.bind.call(this, e),
						(e.target = TARGETS$9.TEXTURE_CUBE_MAP);
				}),
				(e.prototype.addBaseTextureAt = function (t, e, i) {
					if (!this.items[e])
						throw new Error('Index ' + e + ' is out of bounds');
					if (
						!this.linkBaseTexture ||
						t.parentTextureArray ||
						Object.keys(t._glTextures).length > 0
					) {
						if (!t.resource)
							throw new Error(
								'CubeResource does not support copying of renderTexture.'
							);
						this.addResourceAt(t.resource, e);
					} else
						(t.target = TARGETS$9.TEXTURE_CUBE_MAP_POSITIVE_X + e),
							(t.parentTextureArray = this.baseTexture),
							(this.items[e] = t);
					return (
						t.valid && !this.valid && this.resize(t.realWidth, t.realHeight),
						(this.items[e] = t),
						this
					);
				}),
				(e.prototype.upload = function (t, i, r) {
					for (var s = this.itemDirtyIds, n = 0; n < e.SIDES; n++) {
						var a = this.items[n];
						s[n] < a.dirtyId &&
							(a.valid && a.resource
								? (a.resource.upload(t, a, r), (s[n] = a.dirtyId))
								: s[n] < -1 &&
								  (t.gl.texImage2D(
										a.target,
										0,
										r.internalFormat,
										i.realWidth,
										i.realHeight,
										0,
										i.format,
										r.type,
										null
								  ),
								  (s[n] = -1)));
					}
					return !0;
				}),
				(e.test = function (t) {
					return Array.isArray(t) && t.length === e.SIDES;
				}),
				(e.SIDES = 6),
				e
			);
		})(AbstractMultiResource$3),
		ImageResource$3 = (function (t) {
			function e(e, i) {
				var r = this;
				if (((i = i || {}), !(e instanceof HTMLImageElement))) {
					var s = new Image();
					BaseImageResource$3.crossOrigin(s, e, i.crossorigin),
						(s.src = e),
						(e = s);
				}
				return (
					(r = t.call(this, e) || this),
					!e.complete &&
						r._width &&
						r._height &&
						((r._width = 0), (r._height = 0)),
					(r.url = e.src),
					(r._process = null),
					(r.preserveBitmap = !1),
					(r.createBitmap =
						(void 0 !== i.createBitmap
							? i.createBitmap
							: settings$4.CREATE_IMAGE_BITMAP) &&
						!!globalThis.createImageBitmap),
					(r.alphaMode = 'number' == typeof i.alphaMode ? i.alphaMode : null),
					(r.bitmap = null),
					(r._load = null),
					!1 !== i.autoLoad && r.load(),
					r
				);
			}
			return (
				__extends$n(e, t),
				(e.prototype.load = function (t) {
					var e = this;
					return (
						this._load ||
							(void 0 !== t && (this.createBitmap = t),
							(this._load = new Promise(function (t, i) {
								var r = e.source;
								e.url = r.src;
								var s = function () {
									e.destroyed ||
										((r.onload = null),
										(r.onerror = null),
										e.resize(r.width, r.height),
										(e._load = null),
										e.createBitmap ? t(e.process()) : t(e));
								};
								r.complete && r.src
									? s()
									: ((r.onload = s),
									  (r.onerror = function (t) {
											i(t), e.onError.emit(t);
									  }));
							}))),
						this._load
					);
				}),
				(e.prototype.process = function () {
					var t = this,
						e = this.source;
					if (null !== this._process) return this._process;
					if (null !== this.bitmap || !globalThis.createImageBitmap)
						return Promise.resolve(this);
					var i = globalThis.createImageBitmap,
						r = !e.crossOrigin || 'anonymous' === e.crossOrigin;
					return (
						(this._process = fetch(e.src, { mode: r ? 'cors' : 'no-cors' })
							.then(function (t) {
								return t.blob();
							})
							.then(function (r) {
								return i(r, 0, 0, e.width, e.height, {
									premultiplyAlpha:
										t.alphaMode === ALPHA_MODES$9.UNPACK
											? 'premultiply'
											: 'none',
								});
							})
							.then(function (e) {
								return t.destroyed
									? Promise.reject()
									: ((t.bitmap = e),
									  t.update(),
									  (t._process = null),
									  Promise.resolve(t));
							})),
						this._process
					);
				}),
				(e.prototype.upload = function (e, i, r) {
					if (
						('number' == typeof this.alphaMode &&
							(i.alphaMode = this.alphaMode),
						!this.createBitmap)
					)
						return t.prototype.upload.call(this, e, i, r);
					if (!this.bitmap && (this.process(), !this.bitmap)) return !1;
					if (
						(t.prototype.upload.call(this, e, i, r, this.bitmap),
						!this.preserveBitmap)
					) {
						var s = !0,
							n = i._glTextures;
						for (var a in n) {
							var o = n[a];
							if (o !== r && o.dirtyId !== i.dirtyId) {
								s = !1;
								break;
							}
						}
						s &&
							(this.bitmap.close && this.bitmap.close(), (this.bitmap = null));
					}
					return !0;
				}),
				(e.prototype.dispose = function () {
					(this.source.onload = null),
						(this.source.onerror = null),
						t.prototype.dispose.call(this),
						this.bitmap && (this.bitmap.close(), (this.bitmap = null)),
						(this._process = null),
						(this._load = null);
				}),
				(e.test = function (t) {
					return 'string' == typeof t || t instanceof HTMLImageElement;
				}),
				e
			);
		})(BaseImageResource$3),
		SVGResource$3 = (function (t) {
			function e(e, i) {
				var r = this;
				return (
					(i = i || {}),
					((r =
						t.call(this, document.createElement('canvas')) || this)._width = 0),
					(r._height = 0),
					(r.svg = e),
					(r.scale = i.scale || 1),
					(r._overrideWidth = i.width),
					(r._overrideHeight = i.height),
					(r._resolve = null),
					(r._crossorigin = i.crossorigin),
					(r._load = null),
					!1 !== i.autoLoad && r.load(),
					r
				);
			}
			return (
				__extends$n(e, t),
				(e.prototype.load = function () {
					var t = this;
					return (
						this._load ||
							(this._load = new Promise(function (i) {
								if (
									((t._resolve = function () {
										t.resize(t.source.width, t.source.height), i(t);
									}),
									e.SVG_XML.test(t.svg.trim()))
								) {
									if (!btoa)
										throw new Error(
											"Your browser doesn't support base64 conversions."
										);
									t.svg =
										'data:image/svg+xml;base64,' +
										btoa(unescape(encodeURIComponent(t.svg)));
								}
								t._loadSvg();
							})),
						this._load
					);
				}),
				(e.prototype._loadSvg = function () {
					var t = this,
						e = new Image();
					BaseImageResource$3.crossOrigin(e, this.svg, this._crossorigin),
						(e.src = this.svg),
						(e.onerror = function (i) {
							t._resolve && ((e.onerror = null), t.onError.emit(i));
						}),
						(e.onload = function () {
							if (t._resolve) {
								var i = e.width,
									r = e.height;
								if (!i || !r)
									throw new Error(
										'The SVG image must have width and height defined (in pixels), canvas API needs them.'
									);
								var s = i * t.scale,
									n = r * t.scale;
								(t._overrideWidth || t._overrideHeight) &&
									((s = t._overrideWidth || (t._overrideHeight / r) * i),
									(n = t._overrideHeight || (t._overrideWidth / i) * r)),
									(s = Math.round(s)),
									(n = Math.round(n));
								var a = t.source;
								(a.width = s),
									(a.height = n),
									(a._pixiId = 'canvas_' + uid$3()),
									a.getContext('2d').drawImage(e, 0, 0, i, r, 0, 0, s, n),
									t._resolve(),
									(t._resolve = null);
							}
						});
				}),
				(e.getSize = function (t) {
					var i = e.SVG_SIZE.exec(t),
						r = {};
					return (
						i &&
							((r[i[1]] = Math.round(parseFloat(i[3]))),
							(r[i[5]] = Math.round(parseFloat(i[7])))),
						r
					);
				}),
				(e.prototype.dispose = function () {
					t.prototype.dispose.call(this),
						(this._resolve = null),
						(this._crossorigin = null);
				}),
				(e.test = function (t, i) {
					return (
						'svg' === i ||
						('string' == typeof t &&
							/^data:image\/svg\+xml(;(charset=utf8|utf8))?;base64/.test(t)) ||
						('string' == typeof t && e.SVG_XML.test(t))
					);
				}),
				(e.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m),
				(e.SVG_SIZE =
					/<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i),
				e
			);
		})(BaseImageResource$3),
		VideoResource$3 = (function (t) {
			function e(i, r) {
				var s = this;
				if (((r = r || {}), !(i instanceof HTMLVideoElement))) {
					var n = document.createElement('video');
					n.setAttribute('preload', 'auto'),
						n.setAttribute('webkit-playsinline', ''),
						n.setAttribute('playsinline', ''),
						'string' == typeof i && (i = [i]);
					var a = i[0].src || i[0];
					BaseImageResource$3.crossOrigin(n, a, r.crossorigin);
					for (var o = 0; o < i.length; ++o) {
						var h = document.createElement('source'),
							u = i[o],
							l = u.src,
							c = u.mime,
							d = (l = l || i[o]).split('?').shift().toLowerCase(),
							p = d.slice(d.lastIndexOf('.') + 1);
						(c = c || e.MIME_TYPES[p] || 'video/' + p),
							(h.src = l),
							(h.type = c),
							n.appendChild(h);
					}
					i = n;
				}
				return (
					((s = t.call(this, i) || this).noSubImage = !0),
					(s._autoUpdate = !0),
					(s._isConnectedToTicker = !1),
					(s._updateFPS = r.updateFPS || 0),
					(s._msToNextUpdate = 0),
					(s.autoPlay = !1 !== r.autoPlay),
					(s._load = null),
					(s._resolve = null),
					(s._onCanPlay = s._onCanPlay.bind(s)),
					(s._onError = s._onError.bind(s)),
					!1 !== r.autoLoad && s.load(),
					s
				);
			}
			return (
				__extends$n(e, t),
				(e.prototype.update = function (e) {
					if (!this.destroyed) {
						var i = Ticker$3.shared.elapsedMS * this.source.playbackRate;
						(this._msToNextUpdate = Math.floor(this._msToNextUpdate - i)),
							(!this._updateFPS || this._msToNextUpdate <= 0) &&
								(t.prototype.update.call(this),
								(this._msToNextUpdate = this._updateFPS
									? Math.floor(1e3 / this._updateFPS)
									: 0));
					}
				}),
				(e.prototype.load = function () {
					var t = this;
					if (this._load) return this._load;
					var e = this.source;
					return (
						(e.readyState === e.HAVE_ENOUGH_DATA ||
							e.readyState === e.HAVE_FUTURE_DATA) &&
							e.width &&
							e.height &&
							(e.complete = !0),
						e.addEventListener('play', this._onPlayStart.bind(this)),
						e.addEventListener('pause', this._onPlayStop.bind(this)),
						this._isSourceReady()
							? this._onCanPlay()
							: (e.addEventListener('canplay', this._onCanPlay),
							  e.addEventListener('canplaythrough', this._onCanPlay),
							  e.addEventListener('error', this._onError, !0)),
						(this._load = new Promise(function (i) {
							t.valid ? i(t) : ((t._resolve = i), e.load());
						})),
						this._load
					);
				}),
				(e.prototype._onError = function (t) {
					this.source.removeEventListener('error', this._onError, !0),
						this.onError.emit(t);
				}),
				(e.prototype._isSourcePlaying = function () {
					var t = this.source;
					return (
						t.currentTime > 0 &&
						!1 === t.paused &&
						!1 === t.ended &&
						t.readyState > 2
					);
				}),
				(e.prototype._isSourceReady = function () {
					var t = this.source;
					return 3 === t.readyState || 4 === t.readyState;
				}),
				(e.prototype._onPlayStart = function () {
					this.valid || this._onCanPlay(),
						this.autoUpdate &&
							!this._isConnectedToTicker &&
							(Ticker$3.shared.add(this.update, this),
							(this._isConnectedToTicker = !0));
				}),
				(e.prototype._onPlayStop = function () {
					this._isConnectedToTicker &&
						(Ticker$3.shared.remove(this.update, this),
						(this._isConnectedToTicker = !1));
				}),
				(e.prototype._onCanPlay = function () {
					var t = this.source;
					t.removeEventListener('canplay', this._onCanPlay),
						t.removeEventListener('canplaythrough', this._onCanPlay);
					var e = this.valid;
					this.resize(t.videoWidth, t.videoHeight),
						!e &&
							this._resolve &&
							(this._resolve(this), (this._resolve = null)),
						this._isSourcePlaying()
							? this._onPlayStart()
							: this.autoPlay && t.play();
				}),
				(e.prototype.dispose = function () {
					this._isConnectedToTicker &&
						(Ticker$3.shared.remove(this.update, this),
						(this._isConnectedToTicker = !1));
					var e = this.source;
					e &&
						(e.removeEventListener('error', this._onError, !0),
						e.pause(),
						(e.src = ''),
						e.load()),
						t.prototype.dispose.call(this);
				}),
				Object.defineProperty(e.prototype, 'autoUpdate', {
					get: function () {
						return this._autoUpdate;
					},
					set: function (t) {
						t !== this._autoUpdate &&
							((this._autoUpdate = t),
							!this._autoUpdate && this._isConnectedToTicker
								? (Ticker$3.shared.remove(this.update, this),
								  (this._isConnectedToTicker = !1))
								: this._autoUpdate &&
								  !this._isConnectedToTicker &&
								  this._isSourcePlaying() &&
								  (Ticker$3.shared.add(this.update, this),
								  (this._isConnectedToTicker = !0)));
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'updateFPS', {
					get: function () {
						return this._updateFPS;
					},
					set: function (t) {
						t !== this._updateFPS && (this._updateFPS = t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.test = function (t, i) {
					return (
						(globalThis.HTMLVideoElement && t instanceof HTMLVideoElement) ||
						e.TYPES.indexOf(i) > -1
					);
				}),
				(e.TYPES = ['mp4', 'm4v', 'webm', 'ogg', 'ogv', 'h264', 'avi', 'mov']),
				(e.MIME_TYPES = {
					ogv: 'video/ogg',
					mov: 'video/quicktime',
					m4v: 'video/mp4',
				}),
				e
			);
		})(BaseImageResource$3),
		ImageBitmapResource$3 = (function (t) {
			function e(e) {
				return t.call(this, e) || this;
			}
			return (
				__extends$n(e, t),
				(e.test = function (t) {
					return !!globalThis.createImageBitmap && t instanceof ImageBitmap;
				}),
				e
			);
		})(BaseImageResource$3);
	INSTALLED$3.push(
		ImageResource$3,
		ImageBitmapResource$3,
		CanvasResource$3,
		VideoResource$3,
		SVGResource$3,
		BufferResource$3,
		CubeResource$3,
		ArrayResource$3
	);
	var _resources = {
			__proto__: null,
			Resource: Resource$3,
			BaseImageResource: BaseImageResource$3,
			INSTALLED: INSTALLED$3,
			autoDetectResource: autoDetectResource$3,
			AbstractMultiResource: AbstractMultiResource$3,
			ArrayResource: ArrayResource$3,
			BufferResource: BufferResource$3,
			CanvasResource: CanvasResource$3,
			CubeResource: CubeResource$3,
			ImageResource: ImageResource$3,
			SVGResource: SVGResource$3,
			VideoResource: VideoResource$3,
			ImageBitmapResource: ImageBitmapResource$3,
		},
		DepthResource$3 = (function (t) {
			function e() {
				return (null !== t && t.apply(this, arguments)) || this;
			}
			return (
				__extends$n(e, t),
				(e.prototype.upload = function (t, e, i) {
					var r = t.gl;
					r.pixelStorei(
						r.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
						e.alphaMode === ALPHA_MODES$9.UNPACK
					);
					var s = e.realWidth,
						n = e.realHeight;
					return (
						i.width === s && i.height === n
							? r.texSubImage2D(
									e.target,
									0,
									0,
									0,
									s,
									n,
									e.format,
									i.type,
									this.data
							  )
							: ((i.width = s),
							  (i.height = n),
							  r.texImage2D(
									e.target,
									0,
									i.internalFormat,
									s,
									n,
									0,
									e.format,
									i.type,
									this.data
							  )),
						!0
					);
				}),
				e
			);
		})(BufferResource$3),
		Framebuffer$3 = (function () {
			function t(t, e) {
				(this.width = Math.round(t || 100)),
					(this.height = Math.round(e || 100)),
					(this.stencil = !1),
					(this.depth = !1),
					(this.dirtyId = 0),
					(this.dirtyFormat = 0),
					(this.dirtySize = 0),
					(this.depthTexture = null),
					(this.colorTextures = []),
					(this.glFramebuffers = {}),
					(this.disposeRunner = new Runner$3('disposeFramebuffer')),
					(this.multisample = MSAA_QUALITY$9.NONE);
			}
			return (
				Object.defineProperty(t.prototype, 'colorTexture', {
					get: function () {
						return this.colorTextures[0];
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.addColorTexture = function (t, e) {
					return (
						void 0 === t && (t = 0),
						(this.colorTextures[t] =
							e ||
							new BaseTexture$3(null, {
								scaleMode: SCALE_MODES$9.NEAREST,
								resolution: 1,
								mipmap: MIPMAP_MODES$9.OFF,
								width: this.width,
								height: this.height,
							})),
						this.dirtyId++,
						this.dirtyFormat++,
						this
					);
				}),
				(t.prototype.addDepthTexture = function (t) {
					return (
						(this.depthTexture =
							t ||
							new BaseTexture$3(
								new DepthResource$3(null, {
									width: this.width,
									height: this.height,
								}),
								{
									scaleMode: SCALE_MODES$9.NEAREST,
									resolution: 1,
									width: this.width,
									height: this.height,
									mipmap: MIPMAP_MODES$9.OFF,
									format: FORMATS$9.DEPTH_COMPONENT,
									type: TYPES$9.UNSIGNED_SHORT,
								}
							)),
						this.dirtyId++,
						this.dirtyFormat++,
						this
					);
				}),
				(t.prototype.enableDepth = function () {
					return (this.depth = !0), this.dirtyId++, this.dirtyFormat++, this;
				}),
				(t.prototype.enableStencil = function () {
					return (this.stencil = !0), this.dirtyId++, this.dirtyFormat++, this;
				}),
				(t.prototype.resize = function (t, e) {
					if (
						((t = Math.round(t)),
						(e = Math.round(e)),
						t !== this.width || e !== this.height)
					) {
						(this.width = t),
							(this.height = e),
							this.dirtyId++,
							this.dirtySize++;
						for (var i = 0; i < this.colorTextures.length; i++) {
							var r = this.colorTextures[i],
								s = r.resolution;
							r.setSize(t / s, e / s);
						}
						this.depthTexture &&
							((s = this.depthTexture.resolution),
							this.depthTexture.setSize(t / s, e / s));
					}
				}),
				(t.prototype.dispose = function () {
					this.disposeRunner.emit(this, !1);
				}),
				(t.prototype.destroyDepthTexture = function () {
					this.depthTexture &&
						(this.depthTexture.destroy(),
						(this.depthTexture = null),
						++this.dirtyId,
						++this.dirtyFormat);
				}),
				t
			);
		})(),
		BaseRenderTexture$3 = (function (t) {
			function e(e) {
				void 0 === e && (e = {});
				var i = this;
				if ('number' == typeof e) {
					var r = arguments[0],
						s = arguments[1],
						n = arguments[2],
						a = arguments[3];
					e = { width: r, height: s, scaleMode: n, resolution: a };
				}
				return (
					(e.width = e.width || 100),
					(e.height = e.height || 100),
					(e.multisample =
						void 0 !== e.multisample ? e.multisample : MSAA_QUALITY$9.NONE),
					((i = t.call(this, null, e) || this).mipmap = MIPMAP_MODES$9.OFF),
					(i.valid = !0),
					(i.clearColor = [0, 0, 0, 0]),
					(i.framebuffer = new Framebuffer$3(
						i.realWidth,
						i.realHeight
					).addColorTexture(0, i)),
					(i.framebuffer.multisample = e.multisample),
					(i.maskStack = []),
					(i.filterStack = [{}]),
					i
				);
			}
			return (
				__extends$n(e, t),
				(e.prototype.resize = function (t, e) {
					this.framebuffer.resize(t * this.resolution, e * this.resolution),
						this.setRealSize(this.framebuffer.width, this.framebuffer.height);
				}),
				(e.prototype.dispose = function () {
					this.framebuffer.dispose(), t.prototype.dispose.call(this);
				}),
				(e.prototype.destroy = function () {
					t.prototype.destroy.call(this),
						this.framebuffer.destroyDepthTexture(),
						(this.framebuffer = null);
				}),
				e
			);
		})(BaseTexture$3),
		TextureUvs$3 = (function () {
			function t() {
				(this.x0 = 0),
					(this.y0 = 0),
					(this.x1 = 1),
					(this.y1 = 0),
					(this.x2 = 1),
					(this.y2 = 1),
					(this.x3 = 0),
					(this.y3 = 1),
					(this.uvsFloat32 = new Float32Array(8));
			}
			return (
				(t.prototype.set = function (t, e, i) {
					var r = e.width,
						s = e.height;
					if (i) {
						var n = t.width / 2 / r,
							a = t.height / 2 / s,
							o = t.x / r + n,
							h = t.y / s + a;
						(i = groupD8$3.add(i, groupD8$3.NW)),
							(this.x0 = o + n * groupD8$3.uX(i)),
							(this.y0 = h + a * groupD8$3.uY(i)),
							(i = groupD8$3.add(i, 2)),
							(this.x1 = o + n * groupD8$3.uX(i)),
							(this.y1 = h + a * groupD8$3.uY(i)),
							(i = groupD8$3.add(i, 2)),
							(this.x2 = o + n * groupD8$3.uX(i)),
							(this.y2 = h + a * groupD8$3.uY(i)),
							(i = groupD8$3.add(i, 2)),
							(this.x3 = o + n * groupD8$3.uX(i)),
							(this.y3 = h + a * groupD8$3.uY(i));
					} else
						(this.x0 = t.x / r),
							(this.y0 = t.y / s),
							(this.x1 = (t.x + t.width) / r),
							(this.y1 = t.y / s),
							(this.x2 = (t.x + t.width) / r),
							(this.y2 = (t.y + t.height) / s),
							(this.x3 = t.x / r),
							(this.y3 = (t.y + t.height) / s);
					(this.uvsFloat32[0] = this.x0),
						(this.uvsFloat32[1] = this.y0),
						(this.uvsFloat32[2] = this.x1),
						(this.uvsFloat32[3] = this.y1),
						(this.uvsFloat32[4] = this.x2),
						(this.uvsFloat32[5] = this.y2),
						(this.uvsFloat32[6] = this.x3),
						(this.uvsFloat32[7] = this.y3);
				}),
				(t.prototype.toString = function () {
					return (
						'[@pixi/core:TextureUvs x0=' +
						this.x0 +
						' y0=' +
						this.y0 +
						' x1=' +
						this.x1 +
						' y1=' +
						this.y1 +
						' x2=' +
						this.x2 +
						' y2=' +
						this.y2 +
						' x3=' +
						this.x3 +
						' y3=' +
						this.y3 +
						']'
					);
				}),
				t
			);
		})(),
		DEFAULT_UVS$3 = new TextureUvs$3();
	function removeAllHandlers$3(t) {
		(t.destroy = function () {}),
			(t.on = function () {}),
			(t.once = function () {}),
			(t.emit = function () {});
	}
	var Texture$3 = (function (t) {
			function e(i, r, s, n, a, o) {
				var h = t.call(this) || this;
				if (
					((h.noFrame = !1),
					r || ((h.noFrame = !0), (r = new Rectangle$4(0, 0, 1, 1))),
					i instanceof e && (i = i.baseTexture),
					(h.baseTexture = i),
					(h._frame = r),
					(h.trim = n),
					(h.valid = !1),
					(h._uvs = DEFAULT_UVS$3),
					(h.uvMatrix = null),
					(h.orig = s || r),
					(h._rotate = Number(a || 0)),
					!0 === a)
				)
					h._rotate = 2;
				else if (h._rotate % 2 != 0)
					throw new Error(
						'attempt to use diamond-shaped UVs. If you are sure, set rotation manually'
					);
				return (
					(h.defaultAnchor = o ? new Point$4(o.x, o.y) : new Point$4(0, 0)),
					(h._updateID = 0),
					(h.textureCacheIds = []),
					i.valid
						? h.noFrame
							? i.valid && h.onBaseTextureUpdated(i)
							: (h.frame = r)
						: i.once('loaded', h.onBaseTextureUpdated, h),
					h.noFrame && i.on('update', h.onBaseTextureUpdated, h),
					h
				);
			}
			return (
				__extends$n(e, t),
				(e.prototype.update = function () {
					this.baseTexture.resource && this.baseTexture.resource.update();
				}),
				(e.prototype.onBaseTextureUpdated = function (t) {
					if (this.noFrame) {
						if (!this.baseTexture.valid) return;
						(this._frame.width = t.width),
							(this._frame.height = t.height),
							(this.valid = !0),
							this.updateUvs();
					} else this.frame = this._frame;
					this.emit('update', this);
				}),
				(e.prototype.destroy = function (t) {
					if (this.baseTexture) {
						if (t) {
							var i = this.baseTexture.resource;
							i && i.url && TextureCache$3[i.url] && e.removeFromCache(i.url),
								this.baseTexture.destroy();
						}
						this.baseTexture.off('loaded', this.onBaseTextureUpdated, this),
							this.baseTexture.off('update', this.onBaseTextureUpdated, this),
							(this.baseTexture = null);
					}
					(this._frame = null),
						(this._uvs = null),
						(this.trim = null),
						(this.orig = null),
						(this.valid = !1),
						e.removeFromCache(this),
						(this.textureCacheIds = null);
				}),
				(e.prototype.clone = function () {
					var t = this._frame.clone(),
						i = this._frame === this.orig ? t : this.orig.clone(),
						r = new e(
							this.baseTexture,
							!this.noFrame && t,
							i,
							this.trim && this.trim.clone(),
							this.rotate,
							this.defaultAnchor
						);
					return this.noFrame && (r._frame = t), r;
				}),
				(e.prototype.updateUvs = function () {
					this._uvs === DEFAULT_UVS$3 && (this._uvs = new TextureUvs$3()),
						this._uvs.set(this._frame, this.baseTexture, this.rotate),
						this._updateID++;
				}),
				(e.from = function (t, i, r) {
					void 0 === i && (i = {}),
						void 0 === r && (r = settings$4.STRICT_TEXTURE_CACHE);
					var s = 'string' == typeof t,
						n = null;
					if (s) n = t;
					else if (t instanceof BaseTexture$3) {
						if (!t.cacheId) {
							var a = (i && i.pixiIdPrefix) || 'pixiid';
							(t.cacheId = a + '-' + uid$3()),
								BaseTexture$3.addToCache(t, t.cacheId);
						}
						n = t.cacheId;
					} else
						t._pixiId ||
							((a = (i && i.pixiIdPrefix) || 'pixiid'),
							(t._pixiId = a + '_' + uid$3())),
							(n = t._pixiId);
					var o = TextureCache$3[n];
					if (s && r && !o)
						throw new Error(
							'The cacheId "' + n + '" does not exist in TextureCache.'
						);
					return (
						o || t instanceof BaseTexture$3
							? !o &&
							  t instanceof BaseTexture$3 &&
							  ((o = new e(t)), e.addToCache(o, n))
							: (i.resolution || (i.resolution = getResolutionOfUrl$3(t)),
							  ((o = new e(new BaseTexture$3(t, i))).baseTexture.cacheId = n),
							  BaseTexture$3.addToCache(o.baseTexture, n),
							  e.addToCache(o, n)),
						o
					);
				}),
				(e.fromURL = function (t, i) {
					var r = Object.assign(
							{ autoLoad: !1 },
							null == i ? void 0 : i.resourceOptions
						),
						s = e.from(t, Object.assign({ resourceOptions: r }, i), !1),
						n = s.baseTexture.resource;
					return s.baseTexture.valid
						? Promise.resolve(s)
						: n.load().then(function () {
								return Promise.resolve(s);
						  });
				}),
				(e.fromBuffer = function (t, i, r, s) {
					return new e(BaseTexture$3.fromBuffer(t, i, r, s));
				}),
				(e.fromLoader = function (t, i, r, s) {
					var n = new BaseTexture$3(
							t,
							Object.assign(
								{
									scaleMode: settings$4.SCALE_MODE,
									resolution: getResolutionOfUrl$3(i),
								},
								s
							)
						),
						a = n.resource;
					a instanceof ImageResource$3 && (a.url = i);
					var o = new e(n);
					return (
						r || (r = i),
						BaseTexture$3.addToCache(o.baseTexture, r),
						e.addToCache(o, r),
						r !== i &&
							(BaseTexture$3.addToCache(o.baseTexture, i), e.addToCache(o, i)),
						o.baseTexture.valid
							? Promise.resolve(o)
							: new Promise(function (t) {
									o.baseTexture.once('loaded', function () {
										return t(o);
									});
							  })
					);
				}),
				(e.addToCache = function (t, e) {
					e &&
						(-1 === t.textureCacheIds.indexOf(e) && t.textureCacheIds.push(e),
						TextureCache$3[e],
						(TextureCache$3[e] = t));
				}),
				(e.removeFromCache = function (t) {
					if ('string' == typeof t) {
						var e = TextureCache$3[t];
						if (e) {
							var i = e.textureCacheIds.indexOf(t);
							return (
								i > -1 && e.textureCacheIds.splice(i, 1),
								delete TextureCache$3[t],
								e
							);
						}
					} else if (t && t.textureCacheIds) {
						for (var r = 0; r < t.textureCacheIds.length; ++r)
							TextureCache$3[t.textureCacheIds[r]] === t &&
								delete TextureCache$3[t.textureCacheIds[r]];
						return (t.textureCacheIds.length = 0), t;
					}
					return null;
				}),
				Object.defineProperty(e.prototype, 'resolution', {
					get: function () {
						return this.baseTexture.resolution;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'frame', {
					get: function () {
						return this._frame;
					},
					set: function (t) {
						(this._frame = t), (this.noFrame = !1);
						var e = t.x,
							i = t.y,
							r = t.width,
							s = t.height,
							n = e + r > this.baseTexture.width,
							a = i + s > this.baseTexture.height;
						if (n || a) {
							var o = n && a ? 'and' : 'or',
								h =
									'X: ' +
									e +
									' + ' +
									r +
									' = ' +
									(e + r) +
									' > ' +
									this.baseTexture.width,
								u =
									'Y: ' +
									i +
									' + ' +
									s +
									' = ' +
									(i + s) +
									' > ' +
									this.baseTexture.height;
							throw new Error(
								'Texture Error: frame does not fit inside the base Texture dimensions: ' +
									h +
									' ' +
									o +
									' ' +
									u
							);
						}
						(this.valid = r && s && this.baseTexture.valid),
							this.trim || this.rotate || (this.orig = t),
							this.valid && this.updateUvs();
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'rotate', {
					get: function () {
						return this._rotate;
					},
					set: function (t) {
						(this._rotate = t), this.valid && this.updateUvs();
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'width', {
					get: function () {
						return this.orig.width;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'height', {
					get: function () {
						return this.orig.height;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.castToBaseTexture = function () {
					return this.baseTexture;
				}),
				Object.defineProperty(e, 'EMPTY', {
					get: function () {
						return (
							e._EMPTY ||
								((e._EMPTY = new e(new BaseTexture$3())),
								removeAllHandlers$3(e._EMPTY),
								removeAllHandlers$3(e._EMPTY.baseTexture)),
							e._EMPTY
						);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e, 'WHITE', {
					get: function () {
						if (!e._WHITE) {
							var t = document.createElement('canvas'),
								i = t.getContext('2d');
							(t.width = 16),
								(t.height = 16),
								(i.fillStyle = 'white'),
								i.fillRect(0, 0, 16, 16),
								(e._WHITE = new e(new BaseTexture$3(new CanvasResource$3(t)))),
								removeAllHandlers$3(e._WHITE),
								removeAllHandlers$3(e._WHITE.baseTexture);
						}
						return e._WHITE;
					},
					enumerable: !1,
					configurable: !0,
				}),
				e
			);
		})(eventemitter3$1),
		RenderTexture$3 = (function (t) {
			function e(e, i) {
				var r = t.call(this, e, i) || this;
				return (
					(r.valid = !0),
					(r.filterFrame = null),
					(r.filterPoolKey = null),
					r.updateUvs(),
					r
				);
			}
			return (
				__extends$n(e, t),
				Object.defineProperty(e.prototype, 'framebuffer', {
					get: function () {
						return this.baseTexture.framebuffer;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'multisample', {
					get: function () {
						return this.framebuffer.multisample;
					},
					set: function (t) {
						this.framebuffer.multisample = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.resize = function (t, e, i) {
					void 0 === i && (i = !0);
					var r = this.baseTexture.resolution,
						s = Math.round(t * r) / r,
						n = Math.round(e * r) / r;
					(this.valid = s > 0 && n > 0),
						(this._frame.width = this.orig.width = s),
						(this._frame.height = this.orig.height = n),
						i && this.baseTexture.resize(s, n),
						this.updateUvs();
				}),
				(e.prototype.setResolution = function (t) {
					var e = this.baseTexture;
					e.resolution !== t &&
						(e.setResolution(t), this.resize(e.width, e.height, !1));
				}),
				(e.create = function (t) {
					for (var i = arguments, r = [], s = 1; s < arguments.length; s++)
						r[s - 1] = i[s];
					return (
						'number' == typeof t &&
							(deprecation$3(
								'6.0.0',
								'Arguments (width, height, scaleMode, resolution) have been deprecated.'
							),
							(t = {
								width: t,
								height: r[0],
								scaleMode: r[1],
								resolution: r[2],
							})),
						new e(new BaseRenderTexture$3(t))
					);
				}),
				e
			);
		})(Texture$3),
		RenderTexturePool$3 = (function () {
			function t(t) {
				(this.texturePool = {}),
					(this.textureOptions = t || {}),
					(this.enableFullScreen = !1),
					(this._pixelsWidth = 0),
					(this._pixelsHeight = 0);
			}
			return (
				(t.prototype.createTexture = function (t, e, i) {
					void 0 === i && (i = MSAA_QUALITY$9.NONE);
					var r = new BaseRenderTexture$3(
						Object.assign(
							{ width: t, height: e, resolution: 1, multisample: i },
							this.textureOptions
						)
					);
					return new RenderTexture$3(r);
				}),
				(t.prototype.getOptimalTexture = function (t, e, i, r) {
					var s;
					void 0 === i && (i = 1),
						void 0 === r && (r = MSAA_QUALITY$9.NONE),
						(t = Math.ceil(t * i - 1e-6)),
						(e = Math.ceil(e * i - 1e-6)),
						this.enableFullScreen &&
						t === this._pixelsWidth &&
						e === this._pixelsHeight
							? (s = r > 1 ? -r : -1)
							: ((s =
									(((65535 & (t = nextPow2$3(t))) << 16) |
										(65535 & (e = nextPow2$3(e)))) >>>
									0),
							  r > 1 && (s += 4294967296 * r)),
						this.texturePool[s] || (this.texturePool[s] = []);
					var n = this.texturePool[s].pop();
					return (
						n || (n = this.createTexture(t, e, r)),
						(n.filterPoolKey = s),
						n.setResolution(i),
						n
					);
				}),
				(t.prototype.getFilterTexture = function (t, e, i) {
					var r = this.getOptimalTexture(
						t.width,
						t.height,
						e || t.resolution,
						i || MSAA_QUALITY$9.NONE
					);
					return (r.filterFrame = t.filterFrame), r;
				}),
				(t.prototype.returnTexture = function (t) {
					var e = t.filterPoolKey;
					(t.filterFrame = null), this.texturePool[e].push(t);
				}),
				(t.prototype.returnFilterTexture = function (t) {
					this.returnTexture(t);
				}),
				(t.prototype.clear = function (t) {
					if ((t = !1 !== t))
						for (var e in this.texturePool) {
							var i = this.texturePool[e];
							if (i) for (var r = 0; r < i.length; r++) i[r].destroy(!0);
						}
					this.texturePool = {};
				}),
				(t.prototype.setScreenSize = function (t) {
					if (
						t.width !== this._pixelsWidth ||
						t.height !== this._pixelsHeight
					) {
						for (var e in ((this.enableFullScreen =
							t.width > 0 && t.height > 0),
						this.texturePool))
							if (Number(e) < 0) {
								var i = this.texturePool[e];
								if (i) for (var r = 0; r < i.length; r++) i[r].destroy(!0);
								this.texturePool[e] = [];
							}
						(this._pixelsWidth = t.width), (this._pixelsHeight = t.height);
					}
				}),
				(t.SCREEN_KEY = -1),
				t
			);
		})(),
		Attribute$3 = (function () {
			function t(t, e, i, r, s, n, a) {
				void 0 === e && (e = 0),
					void 0 === i && (i = !1),
					void 0 === r && (r = TYPES$9.FLOAT),
					(this.buffer = t),
					(this.size = e),
					(this.normalized = i),
					(this.type = r),
					(this.stride = s),
					(this.start = n),
					(this.instance = a);
			}
			return (
				(t.prototype.destroy = function () {
					this.buffer = null;
				}),
				(t.from = function (e, i, r, s, n) {
					return new t(e, i, r, s, n);
				}),
				t
			);
		})(),
		UID$4$3 = 0,
		Buffer$3 = (function () {
			function t(t, e, i) {
				void 0 === e && (e = !0),
					void 0 === i && (i = !1),
					(this.data = t || new Float32Array(1)),
					(this._glBuffers = {}),
					(this._updateID = 0),
					(this.index = i),
					(this.static = e),
					(this.id = UID$4$3++),
					(this.disposeRunner = new Runner$3('disposeBuffer'));
			}
			return (
				(t.prototype.update = function (t) {
					t instanceof Array && (t = new Float32Array(t)),
						(this.data = t || this.data),
						this._updateID++;
				}),
				(t.prototype.dispose = function () {
					this.disposeRunner.emit(this, !1);
				}),
				(t.prototype.destroy = function () {
					this.dispose(), (this.data = null);
				}),
				Object.defineProperty(t.prototype, 'index', {
					get: function () {
						return this.type === BUFFER_TYPE$9.ELEMENT_ARRAY_BUFFER;
					},
					set: function (t) {
						this.type = t
							? BUFFER_TYPE$9.ELEMENT_ARRAY_BUFFER
							: BUFFER_TYPE$9.ARRAY_BUFFER;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.from = function (e) {
					return e instanceof Array && (e = new Float32Array(e)), new t(e);
				}),
				t
			);
		})(),
		map$1$3 = { Float32Array, Uint32Array, Int32Array, Uint8Array };
	function interleaveTypedArrays$3(t, e) {
		for (var i = 0, r = 0, s = {}, n = 0; n < t.length; n++)
			(r += e[n]), (i += t[n].length);
		var a = new ArrayBuffer(4 * i),
			o = null,
			h = 0;
		for (n = 0; n < t.length; n++) {
			var u = e[n],
				l = t[n],
				c = getBufferType$3(l);
			s[c] || (s[c] = new map$1$3[c](a)), (o = s[c]);
			for (var d = 0; d < l.length; d++)
				o[((d / u) | 0) * r + h + (d % u)] = l[d];
			h += u;
		}
		return new Float32Array(a);
	}
	var byteSizeMap$1$3 = { 5126: 4, 5123: 2, 5121: 1 },
		UID$3$3 = 0,
		map$4 = { Float32Array, Uint32Array, Int32Array, Uint8Array, Uint16Array },
		Geometry$3 = (function () {
			function t(t, e) {
				void 0 === t && (t = []),
					void 0 === e && (e = {}),
					(this.buffers = t),
					(this.indexBuffer = null),
					(this.attributes = e),
					(this.glVertexArrayObjects = {}),
					(this.id = UID$3$3++),
					(this.instanced = !1),
					(this.instanceCount = 1),
					(this.disposeRunner = new Runner$3('disposeGeometry')),
					(this.refCount = 0);
			}
			return (
				(t.prototype.addAttribute = function (t, e, i, r, s, n, a, o) {
					if (
						(void 0 === i && (i = 0),
						void 0 === r && (r = !1),
						void 0 === o && (o = !1),
						!e)
					)
						throw new Error(
							'You must pass a buffer when creating an attribute'
						);
					e instanceof Buffer$3 ||
						(e instanceof Array && (e = new Float32Array(e)),
						(e = new Buffer$3(e)));
					var h = t.split('|');
					if (h.length > 1) {
						for (var u = 0; u < h.length; u++)
							this.addAttribute(h[u], e, i, r, s);
						return this;
					}
					var l = this.buffers.indexOf(e);
					return (
						-1 === l && (this.buffers.push(e), (l = this.buffers.length - 1)),
						(this.attributes[t] = new Attribute$3(l, i, r, s, n, a, o)),
						(this.instanced = this.instanced || o),
						this
					);
				}),
				(t.prototype.getAttribute = function (t) {
					return this.attributes[t];
				}),
				(t.prototype.getBuffer = function (t) {
					return this.buffers[this.getAttribute(t).buffer];
				}),
				(t.prototype.addIndex = function (t) {
					return (
						t instanceof Buffer$3 ||
							(t instanceof Array && (t = new Uint16Array(t)),
							(t = new Buffer$3(t))),
						(t.type = BUFFER_TYPE$9.ELEMENT_ARRAY_BUFFER),
						(this.indexBuffer = t),
						-1 === this.buffers.indexOf(t) && this.buffers.push(t),
						this
					);
				}),
				(t.prototype.getIndex = function () {
					return this.indexBuffer;
				}),
				(t.prototype.interleave = function () {
					if (
						1 === this.buffers.length ||
						(2 === this.buffers.length && this.indexBuffer)
					)
						return this;
					var t,
						e = [],
						i = [],
						r = new Buffer$3();
					for (t in this.attributes) {
						var s = this.attributes[t],
							n = this.buffers[s.buffer];
						e.push(n.data),
							i.push((s.size * byteSizeMap$1$3[s.type]) / 4),
							(s.buffer = 0);
					}
					for (
						r.data = interleaveTypedArrays$3(e, i), t = 0;
						t < this.buffers.length;
						t++
					)
						this.buffers[t] !== this.indexBuffer && this.buffers[t].destroy();
					return (
						(this.buffers = [r]),
						this.indexBuffer && this.buffers.push(this.indexBuffer),
						this
					);
				}),
				(t.prototype.getSize = function () {
					for (var t in this.attributes) {
						var e = this.attributes[t];
						return (
							this.buffers[e.buffer].data.length / (e.stride / 4 || e.size)
						);
					}
					return 0;
				}),
				(t.prototype.dispose = function () {
					this.disposeRunner.emit(this, !1);
				}),
				(t.prototype.destroy = function () {
					this.dispose(),
						(this.buffers = null),
						(this.indexBuffer = null),
						(this.attributes = null);
				}),
				(t.prototype.clone = function () {
					for (var e = new t(), i = 0; i < this.buffers.length; i++)
						e.buffers[i] = new Buffer$3(this.buffers[i].data.slice(0));
					for (var i in this.attributes) {
						var r = this.attributes[i];
						e.attributes[i] = new Attribute$3(
							r.buffer,
							r.size,
							r.normalized,
							r.type,
							r.stride,
							r.start,
							r.instance
						);
					}
					return (
						this.indexBuffer &&
							((e.indexBuffer =
								e.buffers[this.buffers.indexOf(this.indexBuffer)]),
							(e.indexBuffer.type = BUFFER_TYPE$9.ELEMENT_ARRAY_BUFFER)),
						e
					);
				}),
				(t.merge = function (e) {
					for (
						var i, r = new t(), s = [], n = [], a = [], o = 0;
						o < e.length;
						o++
					) {
						i = e[o];
						for (var h = 0; h < i.buffers.length; h++)
							(n[h] = n[h] || 0),
								(n[h] += i.buffers[h].data.length),
								(a[h] = 0);
					}
					for (o = 0; o < i.buffers.length; o++)
						(s[o] = new map$4[getBufferType$3(i.buffers[o].data)](n[o])),
							(r.buffers[o] = new Buffer$3(s[o]));
					for (o = 0; o < e.length; o++)
						for (i = e[o], h = 0; h < i.buffers.length; h++)
							s[h].set(i.buffers[h].data, a[h]),
								(a[h] += i.buffers[h].data.length);
					if (((r.attributes = i.attributes), i.indexBuffer)) {
						(r.indexBuffer = r.buffers[i.buffers.indexOf(i.indexBuffer)]),
							(r.indexBuffer.type = BUFFER_TYPE$9.ELEMENT_ARRAY_BUFFER);
						var u = 0,
							l = 0,
							c = 0,
							d = 0;
						for (o = 0; o < i.buffers.length; o++)
							if (i.buffers[o] !== i.indexBuffer) {
								d = o;
								break;
							}
						for (var o in i.attributes) {
							var p = i.attributes[o];
							(0 | p.buffer) === d &&
								(l += (p.size * byteSizeMap$1$3[p.type]) / 4);
						}
						for (o = 0; o < e.length; o++) {
							var f = e[o].indexBuffer.data;
							for (h = 0; h < f.length; h++) r.indexBuffer.data[h + c] += u;
							(u += e[o].buffers[d].data.length / l), (c += f.length);
						}
					}
					return r;
				}),
				t
			);
		})(),
		Quad$3 = (function (t) {
			function e() {
				var e = t.call(this) || this;
				return (
					e
						.addAttribute(
							'aVertexPosition',
							new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])
						)
						.addIndex([0, 1, 3, 2]),
					e
				);
			}
			return __extends$n(e, t), e;
		})(Geometry$3),
		QuadUv$3 = (function (t) {
			function e() {
				var e = t.call(this) || this;
				return (
					(e.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1])),
					(e.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])),
					(e.vertexBuffer = new Buffer$3(e.vertices)),
					(e.uvBuffer = new Buffer$3(e.uvs)),
					e
						.addAttribute('aVertexPosition', e.vertexBuffer)
						.addAttribute('aTextureCoord', e.uvBuffer)
						.addIndex([0, 1, 2, 0, 2, 3]),
					e
				);
			}
			return (
				__extends$n(e, t),
				(e.prototype.map = function (t, e) {
					var i = 0,
						r = 0;
					return (
						(this.uvs[0] = i),
						(this.uvs[1] = r),
						(this.uvs[2] = i + e.width / t.width),
						(this.uvs[3] = r),
						(this.uvs[4] = i + e.width / t.width),
						(this.uvs[5] = r + e.height / t.height),
						(this.uvs[6] = i),
						(this.uvs[7] = r + e.height / t.height),
						(i = e.x),
						(r = e.y),
						(this.vertices[0] = i),
						(this.vertices[1] = r),
						(this.vertices[2] = i + e.width),
						(this.vertices[3] = r),
						(this.vertices[4] = i + e.width),
						(this.vertices[5] = r + e.height),
						(this.vertices[6] = i),
						(this.vertices[7] = r + e.height),
						this.invalidate(),
						this
					);
				}),
				(e.prototype.invalidate = function () {
					return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;
				}),
				e
			);
		})(Geometry$3),
		UID$2$3 = 0,
		UniformGroup$3 = (function () {
			function t(t, e, i) {
				(this.group = !0),
					(this.syncUniforms = {}),
					(this.dirtyId = 0),
					(this.id = UID$2$3++),
					(this.static = !!e),
					(this.ubo = !!i),
					t instanceof Buffer$3
						? ((this.buffer = t),
						  (this.buffer.type = BUFFER_TYPE$9.UNIFORM_BUFFER),
						  (this.autoManage = !1),
						  (this.ubo = !0))
						: ((this.uniforms = t),
						  this.ubo &&
								((this.buffer = new Buffer$3(new Float32Array(1))),
								(this.buffer.type = BUFFER_TYPE$9.UNIFORM_BUFFER),
								(this.autoManage = !0)));
			}
			return (
				(t.prototype.update = function () {
					this.dirtyId++,
						!this.autoManage && this.buffer && this.buffer.update();
				}),
				(t.prototype.add = function (e, i, r) {
					if (this.ubo)
						throw new Error(
							'[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them'
						);
					this.uniforms[e] = new t(i, r);
				}),
				(t.from = function (e, i, r) {
					return new t(e, i, r);
				}),
				(t.uboFrom = function (e, i) {
					return new t(e, null == i || i, !0);
				}),
				t
			);
		})(),
		FilterState$3 = (function () {
			function t() {
				(this.renderTexture = null),
					(this.target = null),
					(this.legacy = !1),
					(this.resolution = 1),
					(this.multisample = MSAA_QUALITY$9.NONE),
					(this.sourceFrame = new Rectangle$4()),
					(this.destinationFrame = new Rectangle$4()),
					(this.bindingSourceFrame = new Rectangle$4()),
					(this.bindingDestinationFrame = new Rectangle$4()),
					(this.filters = []),
					(this.transform = null);
			}
			return (
				(t.prototype.clear = function () {
					(this.target = null),
						(this.filters = null),
						(this.renderTexture = null);
				}),
				t
			);
		})(),
		tempPoints$3 = [new Point$4(), new Point$4(), new Point$4(), new Point$4()],
		tempMatrix$2$3 = new Matrix$3(),
		FilterSystem$3 = (function () {
			function t(t) {
				(this.renderer = t),
					(this.defaultFilterStack = [{}]),
					(this.texturePool = new RenderTexturePool$3()),
					this.texturePool.setScreenSize(t.view),
					(this.statePool = []),
					(this.quad = new Quad$3()),
					(this.quadUv = new QuadUv$3()),
					(this.tempRect = new Rectangle$4()),
					(this.activeState = {}),
					(this.globalUniforms = new UniformGroup$3(
						{
							outputFrame: new Rectangle$4(),
							inputSize: new Float32Array(4),
							inputPixel: new Float32Array(4),
							inputClamp: new Float32Array(4),
							resolution: 1,
							filterArea: new Float32Array(4),
							filterClamp: new Float32Array(4),
						},
						!0
					)),
					(this.forceClear = !1),
					(this.useMaxPadding = !1);
			}
			return (
				(t.prototype.push = function (t, e) {
					for (
						var i,
							r,
							s = this.renderer,
							n = this.defaultFilterStack,
							a = this.statePool.pop() || new FilterState$3(),
							o = this.renderer.renderTexture,
							h = e[0].resolution,
							u = e[0].multisample,
							l = e[0].padding,
							c = e[0].autoFit,
							d = null === (i = e[0].legacy) || void 0 === i || i,
							p = 1;
						p < e.length;
						p++
					) {
						var f = e[p];
						(h = Math.min(h, f.resolution)),
							(u = Math.min(u, f.multisample)),
							(l = this.useMaxPadding ? Math.max(l, f.padding) : l + f.padding),
							(c = c && f.autoFit),
							(d = d || null === (r = f.legacy) || void 0 === r || r);
					}
					1 === n.length &&
						(this.defaultFilterStack[0].renderTexture = o.current),
						n.push(a),
						(a.resolution = h),
						(a.multisample = u),
						(a.legacy = d),
						(a.target = t),
						a.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)),
						a.sourceFrame.pad(l);
					var m = this.tempRect.copyFrom(o.sourceFrame);
					s.projection.transform &&
						this.transformAABB(
							tempMatrix$2$3.copyFrom(s.projection.transform).invert(),
							m
						),
						c
							? (a.sourceFrame.fit(m),
							  (a.sourceFrame.width <= 0 || a.sourceFrame.height <= 0) &&
									((a.sourceFrame.width = 0), (a.sourceFrame.height = 0)))
							: a.sourceFrame.intersects(m) ||
							  ((a.sourceFrame.width = 0), (a.sourceFrame.height = 0)),
						this.roundFrame(
							a.sourceFrame,
							o.current ? o.current.resolution : s.resolution,
							o.sourceFrame,
							o.destinationFrame,
							s.projection.transform
						),
						(a.renderTexture = this.getOptimalFilterTexture(
							a.sourceFrame.width,
							a.sourceFrame.height,
							h,
							u
						)),
						(a.filters = e),
						(a.destinationFrame.width = a.renderTexture.width),
						(a.destinationFrame.height = a.renderTexture.height);
					var _ = this.tempRect;
					(_.x = 0),
						(_.y = 0),
						(_.width = a.sourceFrame.width),
						(_.height = a.sourceFrame.height),
						(a.renderTexture.filterFrame = a.sourceFrame),
						a.bindingSourceFrame.copyFrom(o.sourceFrame),
						a.bindingDestinationFrame.copyFrom(o.destinationFrame),
						(a.transform = s.projection.transform),
						(s.projection.transform = null),
						o.bind(a.renderTexture, a.sourceFrame, _),
						s.framebuffer.clear(0, 0, 0, 0);
				}),
				(t.prototype.pop = function () {
					var t = this.defaultFilterStack,
						e = t.pop(),
						i = e.filters;
					this.activeState = e;
					var r = this.globalUniforms.uniforms;
					(r.outputFrame = e.sourceFrame), (r.resolution = e.resolution);
					var s = r.inputSize,
						n = r.inputPixel,
						a = r.inputClamp;
					if (
						((s[0] = e.destinationFrame.width),
						(s[1] = e.destinationFrame.height),
						(s[2] = 1 / s[0]),
						(s[3] = 1 / s[1]),
						(n[0] = Math.round(s[0] * e.resolution)),
						(n[1] = Math.round(s[1] * e.resolution)),
						(n[2] = 1 / n[0]),
						(n[3] = 1 / n[1]),
						(a[0] = 0.5 * n[2]),
						(a[1] = 0.5 * n[3]),
						(a[2] = e.sourceFrame.width * s[2] - 0.5 * n[2]),
						(a[3] = e.sourceFrame.height * s[3] - 0.5 * n[3]),
						e.legacy)
					) {
						var o = r.filterArea;
						(o[0] = e.destinationFrame.width),
							(o[1] = e.destinationFrame.height),
							(o[2] = e.sourceFrame.x),
							(o[3] = e.sourceFrame.y),
							(r.filterClamp = r.inputClamp);
					}
					this.globalUniforms.update();
					var h = t[t.length - 1];
					if ((this.renderer.framebuffer.blit(), 1 === i.length))
						i[0].apply(
							this,
							e.renderTexture,
							h.renderTexture,
							CLEAR_MODES$9.BLEND,
							e
						),
							this.returnFilterTexture(e.renderTexture);
					else {
						var u = e.renderTexture,
							l = this.getOptimalFilterTexture(u.width, u.height, e.resolution);
						l.filterFrame = u.filterFrame;
						var c = 0;
						for (c = 0; c < i.length - 1; ++c) {
							1 === c &&
								e.multisample > 1 &&
								((l = this.getOptimalFilterTexture(
									u.width,
									u.height,
									e.resolution
								)).filterFrame = u.filterFrame),
								i[c].apply(this, u, l, CLEAR_MODES$9.CLEAR, e);
							var d = u;
							(u = l), (l = d);
						}
						i[c].apply(this, u, h.renderTexture, CLEAR_MODES$9.BLEND, e),
							c > 1 &&
								e.multisample > 1 &&
								this.returnFilterTexture(e.renderTexture),
							this.returnFilterTexture(u),
							this.returnFilterTexture(l);
					}
					e.clear(), this.statePool.push(e);
				}),
				(t.prototype.bindAndClear = function (t, e) {
					void 0 === e && (e = CLEAR_MODES$9.CLEAR);
					var i = this.renderer,
						r = i.renderTexture,
						s = i.state;
					if (
						(t ===
						this.defaultFilterStack[this.defaultFilterStack.length - 1]
							.renderTexture
							? (this.renderer.projection.transform =
									this.activeState.transform)
							: (this.renderer.projection.transform = null),
						t && t.filterFrame)
					) {
						var n = this.tempRect;
						(n.x = 0),
							(n.y = 0),
							(n.width = t.filterFrame.width),
							(n.height = t.filterFrame.height),
							r.bind(t, t.filterFrame, n);
					} else
						t !==
						this.defaultFilterStack[this.defaultFilterStack.length - 1]
							.renderTexture
							? r.bind(t)
							: this.renderer.renderTexture.bind(
									t,
									this.activeState.bindingSourceFrame,
									this.activeState.bindingDestinationFrame
							  );
					var a = 1 & s.stateId || this.forceClear;
					(e === CLEAR_MODES$9.CLEAR || (e === CLEAR_MODES$9.BLIT && a)) &&
						this.renderer.framebuffer.clear(0, 0, 0, 0);
				}),
				(t.prototype.applyFilter = function (t, e, i, r) {
					var s = this.renderer;
					s.state.set(t.state),
						this.bindAndClear(i, r),
						(t.uniforms.uSampler = e),
						(t.uniforms.filterGlobals = this.globalUniforms),
						s.shader.bind(t),
						(t.legacy = !!t.program.attributeData.aTextureCoord),
						t.legacy
							? (this.quadUv.map(e._frame, e.filterFrame),
							  s.geometry.bind(this.quadUv),
							  s.geometry.draw(DRAW_MODES$9.TRIANGLES))
							: (s.geometry.bind(this.quad),
							  s.geometry.draw(DRAW_MODES$9.TRIANGLE_STRIP));
				}),
				(t.prototype.calculateSpriteMatrix = function (t, e) {
					var i = this.activeState,
						r = i.sourceFrame,
						s = i.destinationFrame,
						n = e._texture.orig,
						a = t.set(s.width, 0, 0, s.height, r.x, r.y),
						o = e.worldTransform.copyTo(Matrix$3.TEMP_MATRIX);
					return (
						o.invert(),
						a.prepend(o),
						a.scale(1 / n.width, 1 / n.height),
						a.translate(e.anchor.x, e.anchor.y),
						a
					);
				}),
				(t.prototype.destroy = function () {
					(this.renderer = null), this.texturePool.clear(!1);
				}),
				(t.prototype.getOptimalFilterTexture = function (t, e, i, r) {
					return (
						void 0 === i && (i = 1),
						void 0 === r && (r = MSAA_QUALITY$9.NONE),
						this.texturePool.getOptimalTexture(t, e, i, r)
					);
				}),
				(t.prototype.getFilterTexture = function (t, e, i) {
					if ('number' == typeof t) {
						var r = t;
						(t = e), (e = r);
					}
					t = t || this.activeState.renderTexture;
					var s = this.texturePool.getOptimalTexture(
						t.width,
						t.height,
						e || t.resolution,
						i || MSAA_QUALITY$9.NONE
					);
					return (s.filterFrame = t.filterFrame), s;
				}),
				(t.prototype.returnFilterTexture = function (t) {
					this.texturePool.returnTexture(t);
				}),
				(t.prototype.emptyPool = function () {
					this.texturePool.clear(!0);
				}),
				(t.prototype.resize = function () {
					this.texturePool.setScreenSize(this.renderer.view);
				}),
				(t.prototype.transformAABB = function (t, e) {
					var i = tempPoints$3[0],
						r = tempPoints$3[1],
						s = tempPoints$3[2],
						n = tempPoints$3[3];
					i.set(e.left, e.top),
						r.set(e.left, e.bottom),
						s.set(e.right, e.top),
						n.set(e.right, e.bottom),
						t.apply(i, i),
						t.apply(r, r),
						t.apply(s, s),
						t.apply(n, n);
					var a = Math.min(i.x, r.x, s.x, n.x),
						o = Math.min(i.y, r.y, s.y, n.y),
						h = Math.max(i.x, r.x, s.x, n.x),
						u = Math.max(i.y, r.y, s.y, n.y);
					(e.x = a), (e.y = o), (e.width = h - a), (e.height = u - o);
				}),
				(t.prototype.roundFrame = function (t, e, i, r, s) {
					if (
						!(t.width <= 0 || t.height <= 0 || i.width <= 0 || i.height <= 0)
					) {
						if (s) {
							var n = s.a,
								a = s.b,
								o = s.c,
								h = s.d;
							if (
								(Math.abs(a) > 1e-4 || Math.abs(o) > 1e-4) &&
								(Math.abs(n) > 1e-4 || Math.abs(h) > 1e-4)
							)
								return;
						}
						(s = s ? tempMatrix$2$3.copyFrom(s) : tempMatrix$2$3.identity())
							.translate(-i.x, -i.y)
							.scale(r.width / i.width, r.height / i.height)
							.translate(r.x, r.y),
							this.transformAABB(s, t),
							t.ceil(e),
							this.transformAABB(s.invert(), t);
					}
				}),
				t
			);
		})(),
		ObjectRenderer$3 = (function () {
			function t(t) {
				this.renderer = t;
			}
			return (
				(t.prototype.flush = function () {}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				(t.prototype.start = function () {}),
				(t.prototype.stop = function () {
					this.flush();
				}),
				(t.prototype.render = function (t) {}),
				t
			);
		})(),
		BatchSystem$3 = (function () {
			function t(t) {
				(this.renderer = t),
					(this.emptyRenderer = new ObjectRenderer$3(t)),
					(this.currentRenderer = this.emptyRenderer);
			}
			return (
				(t.prototype.setObjectRenderer = function (t) {
					this.currentRenderer !== t &&
						(this.currentRenderer.stop(),
						(this.currentRenderer = t),
						this.currentRenderer.start());
				}),
				(t.prototype.flush = function () {
					this.setObjectRenderer(this.emptyRenderer);
				}),
				(t.prototype.reset = function () {
					this.setObjectRenderer(this.emptyRenderer);
				}),
				(t.prototype.copyBoundTextures = function (t, e) {
					for (
						var i = this.renderer.texture.boundTextures, r = e - 1;
						r >= 0;
						--r
					)
						(t[r] = i[r] || null), t[r] && (t[r]._batchLocation = r);
				}),
				(t.prototype.boundArray = function (t, e, i, r) {
					for (
						var s = t.elements, n = t.ids, a = t.count, o = 0, h = 0;
						h < a;
						h++
					) {
						var u = s[h],
							l = u._batchLocation;
						if (l >= 0 && l < r && e[l] === u) n[h] = l;
						else
							for (; o < r; ) {
								var c = e[o];
								if (!c || c._batchEnabled !== i || c._batchLocation !== o) {
									(n[h] = o), (u._batchLocation = o), (e[o] = u);
									break;
								}
								o++;
							}
					}
				}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})(),
		CONTEXT_UID_COUNTER$3 = 0,
		ContextSystem$3 = (function () {
			function t(t) {
				(this.renderer = t),
					(this.webGLVersion = 1),
					(this.extensions = {}),
					(this.supports = { uint32Indices: !1 }),
					(this.handleContextLost = this.handleContextLost.bind(this)),
					(this.handleContextRestored = this.handleContextRestored.bind(this)),
					t.view.addEventListener(
						'webglcontextlost',
						this.handleContextLost,
						!1
					),
					t.view.addEventListener(
						'webglcontextrestored',
						this.handleContextRestored,
						!1
					);
			}
			return (
				Object.defineProperty(t.prototype, 'isLost', {
					get: function () {
						return !this.gl || this.gl.isContextLost();
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.contextChange = function (t) {
					(this.gl = t),
						(this.renderer.gl = t),
						(this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER$3++),
						t.isContextLost() &&
							t.getExtension('WEBGL_lose_context') &&
							t.getExtension('WEBGL_lose_context').restoreContext();
				}),
				(t.prototype.initFromContext = function (t) {
					(this.gl = t),
						this.validateContext(t),
						(this.renderer.gl = t),
						(this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER$3++),
						this.renderer.runners.contextChange.emit(t);
				}),
				(t.prototype.initFromOptions = function (t) {
					var e = this.createContext(this.renderer.view, t);
					this.initFromContext(e);
				}),
				(t.prototype.createContext = function (t, e) {
					var i;
					if (
						(settings$4.PREFER_ENV >= ENV$9.WEBGL2 &&
							(i = t.getContext('webgl2', e)),
						i)
					)
						this.webGLVersion = 2;
					else if (
						((this.webGLVersion = 1),
						!(i =
							t.getContext('webgl', e) ||
							t.getContext('experimental-webgl', e)))
					)
						throw new Error(
							'This browser does not support WebGL. Try using the canvas renderer'
						);
					return (this.gl = i), this.getExtensions(), this.gl;
				}),
				(t.prototype.getExtensions = function () {
					var t = this.gl,
						e = {
							anisotropicFiltering: t.getExtension(
								'EXT_texture_filter_anisotropic'
							),
							floatTextureLinear: t.getExtension('OES_texture_float_linear'),
							s3tc: t.getExtension('WEBGL_compressed_texture_s3tc'),
							s3tc_sRGB: t.getExtension('WEBGL_compressed_texture_s3tc_srgb'),
							etc: t.getExtension('WEBGL_compressed_texture_etc'),
							etc1: t.getExtension('WEBGL_compressed_texture_etc1'),
							pvrtc:
								t.getExtension('WEBGL_compressed_texture_pvrtc') ||
								t.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),
							atc: t.getExtension('WEBGL_compressed_texture_atc'),
							astc: t.getExtension('WEBGL_compressed_texture_astc'),
						};
					1 === this.webGLVersion
						? Object.assign(this.extensions, e, {
								drawBuffers: t.getExtension('WEBGL_draw_buffers'),
								depthTexture: t.getExtension('WEBGL_depth_texture'),
								loseContext: t.getExtension('WEBGL_lose_context'),
								vertexArrayObject:
									t.getExtension('OES_vertex_array_object') ||
									t.getExtension('MOZ_OES_vertex_array_object') ||
									t.getExtension('WEBKIT_OES_vertex_array_object'),
								uint32ElementIndex: t.getExtension('OES_element_index_uint'),
								floatTexture: t.getExtension('OES_texture_float'),
								floatTextureLinear: t.getExtension('OES_texture_float_linear'),
								textureHalfFloat: t.getExtension('OES_texture_half_float'),
								textureHalfFloatLinear: t.getExtension(
									'OES_texture_half_float_linear'
								),
						  })
						: 2 === this.webGLVersion &&
						  Object.assign(this.extensions, e, {
								colorBufferFloat: t.getExtension('EXT_color_buffer_float'),
						  });
				}),
				(t.prototype.handleContextLost = function (t) {
					t.preventDefault();
				}),
				(t.prototype.handleContextRestored = function () {
					this.renderer.runners.contextChange.emit(this.gl);
				}),
				(t.prototype.destroy = function () {
					var t = this.renderer.view;
					(this.renderer = null),
						t.removeEventListener('webglcontextlost', this.handleContextLost),
						t.removeEventListener(
							'webglcontextrestored',
							this.handleContextRestored
						),
						this.gl.useProgram(null),
						this.extensions.loseContext &&
							this.extensions.loseContext.loseContext();
				}),
				(t.prototype.postrender = function () {
					this.renderer.renderingToScreen && this.gl.flush();
				}),
				(t.prototype.validateContext = function (t) {
					var e = t.getContextAttributes(),
						i =
							'WebGL2RenderingContext' in globalThis &&
							t instanceof globalThis.WebGL2RenderingContext;
					i && (this.webGLVersion = 2), e && e.stencil;
					var r = i || !!t.getExtension('OES_element_index_uint');
					this.supports.uint32Indices = r;
				}),
				t
			);
		})(),
		GLFramebuffer$3 = function (t) {
			(this.framebuffer = t),
				(this.stencil = null),
				(this.dirtyId = -1),
				(this.dirtyFormat = -1),
				(this.dirtySize = -1),
				(this.multisample = MSAA_QUALITY$9.NONE),
				(this.msaaBuffer = null),
				(this.blitFramebuffer = null),
				(this.mipLevel = 0);
		},
		tempRectangle$3 = new Rectangle$4(),
		FramebufferSystem$3 = (function () {
			function t(t) {
				(this.renderer = t),
					(this.managedFramebuffers = []),
					(this.unknownFramebuffer = new Framebuffer$3(10, 10)),
					(this.msaaSamples = null);
			}
			return (
				(t.prototype.contextChange = function () {
					var t = (this.gl = this.renderer.gl);
					if (
						((this.CONTEXT_UID = this.renderer.CONTEXT_UID),
						(this.current = this.unknownFramebuffer),
						(this.viewport = new Rectangle$4()),
						(this.hasMRT = !0),
						(this.writeDepthTexture = !0),
						this.disposeAll(!0),
						1 === this.renderer.context.webGLVersion)
					) {
						var e = this.renderer.context.extensions.drawBuffers,
							i = this.renderer.context.extensions.depthTexture;
						settings$4.PREFER_ENV === ENV$9.WEBGL_LEGACY &&
							((e = null), (i = null)),
							e
								? (t.drawBuffers = function (t) {
										return e.drawBuffersWEBGL(t);
								  })
								: ((this.hasMRT = !1), (t.drawBuffers = function () {})),
							i || (this.writeDepthTexture = !1);
					} else
						this.msaaSamples = t.getInternalformatParameter(
							t.RENDERBUFFER,
							t.RGBA8,
							t.SAMPLES
						);
				}),
				(t.prototype.bind = function (t, e, i) {
					void 0 === i && (i = 0);
					var r = this.gl;
					if (t) {
						var s =
							t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t);
						this.current !== t &&
							((this.current = t),
							r.bindFramebuffer(r.FRAMEBUFFER, s.framebuffer)),
							s.mipLevel !== i &&
								(t.dirtyId++, t.dirtyFormat++, (s.mipLevel = i)),
							s.dirtyId !== t.dirtyId &&
								((s.dirtyId = t.dirtyId),
								s.dirtyFormat !== t.dirtyFormat
									? ((s.dirtyFormat = t.dirtyFormat),
									  (s.dirtySize = t.dirtySize),
									  this.updateFramebuffer(t, i))
									: s.dirtySize !== t.dirtySize &&
									  ((s.dirtySize = t.dirtySize), this.resizeFramebuffer(t)));
						for (var n = 0; n < t.colorTextures.length; n++) {
							var a = t.colorTextures[n];
							this.renderer.texture.unbind(a.parentTextureArray || a);
						}
						if (
							(t.depthTexture && this.renderer.texture.unbind(t.depthTexture),
							e)
						) {
							var o = e.width >> i,
								h = e.height >> i,
								u = o / e.width;
							this.setViewport(e.x * u, e.y * u, o, h);
						} else
							(o = t.width >> i),
								(h = t.height >> i),
								this.setViewport(0, 0, o, h);
					} else
						this.current &&
							((this.current = null), r.bindFramebuffer(r.FRAMEBUFFER, null)),
							e
								? this.setViewport(e.x, e.y, e.width, e.height)
								: this.setViewport(
										0,
										0,
										this.renderer.width,
										this.renderer.height
								  );
				}),
				(t.prototype.setViewport = function (t, e, i, r) {
					var s = this.viewport;
					(t = Math.round(t)),
						(e = Math.round(e)),
						(i = Math.round(i)),
						(r = Math.round(r)),
						(s.width === i && s.height === r && s.x === t && s.y === e) ||
							((s.x = t),
							(s.y = e),
							(s.width = i),
							(s.height = r),
							this.gl.viewport(t, e, i, r));
				}),
				Object.defineProperty(t.prototype, 'size', {
					get: function () {
						return this.current
							? {
									x: 0,
									y: 0,
									width: this.current.width,
									height: this.current.height,
							  }
							: {
									x: 0,
									y: 0,
									width: this.renderer.width,
									height: this.renderer.height,
							  };
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.clear = function (t, e, i, r, s) {
					void 0 === s && (s = BUFFER_BITS$9.COLOR | BUFFER_BITS$9.DEPTH);
					var n = this.gl;
					n.clearColor(t, e, i, r), n.clear(s);
				}),
				(t.prototype.initFramebuffer = function (t) {
					var e = this.gl,
						i = new GLFramebuffer$3(e.createFramebuffer());
					return (
						(i.multisample = this.detectSamples(t.multisample)),
						(t.glFramebuffers[this.CONTEXT_UID] = i),
						this.managedFramebuffers.push(t),
						t.disposeRunner.add(this),
						i
					);
				}),
				(t.prototype.resizeFramebuffer = function (t) {
					var e = this.gl,
						i = t.glFramebuffers[this.CONTEXT_UID];
					i.msaaBuffer &&
						(e.bindRenderbuffer(e.RENDERBUFFER, i.msaaBuffer),
						e.renderbufferStorageMultisample(
							e.RENDERBUFFER,
							i.multisample,
							e.RGBA8,
							t.width,
							t.height
						)),
						i.stencil &&
							(e.bindRenderbuffer(e.RENDERBUFFER, i.stencil),
							i.msaaBuffer
								? e.renderbufferStorageMultisample(
										e.RENDERBUFFER,
										i.multisample,
										e.DEPTH24_STENCIL8,
										t.width,
										t.height
								  )
								: e.renderbufferStorage(
										e.RENDERBUFFER,
										e.DEPTH_STENCIL,
										t.width,
										t.height
								  ));
					var r = t.colorTextures,
						s = r.length;
					e.drawBuffers || (s = Math.min(s, 1));
					for (var n = 0; n < s; n++) {
						var a = r[n],
							o = a.parentTextureArray || a;
						this.renderer.texture.bind(o, 0);
					}
					t.depthTexture &&
						this.writeDepthTexture &&
						this.renderer.texture.bind(t.depthTexture, 0);
				}),
				(t.prototype.updateFramebuffer = function (t, e) {
					var i = this.gl,
						r = t.glFramebuffers[this.CONTEXT_UID],
						s = t.colorTextures,
						n = s.length;
					i.drawBuffers || (n = Math.min(n, 1)),
						r.multisample > 1 && this.canMultisampleFramebuffer(t)
							? ((r.msaaBuffer = r.msaaBuffer || i.createRenderbuffer()),
							  i.bindRenderbuffer(i.RENDERBUFFER, r.msaaBuffer),
							  i.renderbufferStorageMultisample(
									i.RENDERBUFFER,
									r.multisample,
									i.RGBA8,
									t.width,
									t.height
							  ),
							  i.framebufferRenderbuffer(
									i.FRAMEBUFFER,
									i.COLOR_ATTACHMENT0,
									i.RENDERBUFFER,
									r.msaaBuffer
							  ))
							: r.msaaBuffer &&
							  (i.deleteRenderbuffer(r.msaaBuffer),
							  (r.msaaBuffer = null),
							  r.blitFramebuffer &&
									(r.blitFramebuffer.dispose(), (r.blitFramebuffer = null)));
					for (var a = [], o = 0; o < n; o++) {
						var h = s[o],
							u = h.parentTextureArray || h;
						this.renderer.texture.bind(u, 0),
							(0 === o && r.msaaBuffer) ||
								(i.framebufferTexture2D(
									i.FRAMEBUFFER,
									i.COLOR_ATTACHMENT0 + o,
									h.target,
									u._glTextures[this.CONTEXT_UID].texture,
									e
								),
								a.push(i.COLOR_ATTACHMENT0 + o));
					}
					if (
						(a.length > 1 && i.drawBuffers(a),
						t.depthTexture && this.writeDepthTexture)
					) {
						var l = t.depthTexture;
						this.renderer.texture.bind(l, 0),
							i.framebufferTexture2D(
								i.FRAMEBUFFER,
								i.DEPTH_ATTACHMENT,
								i.TEXTURE_2D,
								l._glTextures[this.CONTEXT_UID].texture,
								e
							);
					}
					(!t.stencil && !t.depth) || (t.depthTexture && this.writeDepthTexture)
						? r.stencil && (i.deleteRenderbuffer(r.stencil), (r.stencil = null))
						: ((r.stencil = r.stencil || i.createRenderbuffer()),
						  i.bindRenderbuffer(i.RENDERBUFFER, r.stencil),
						  r.msaaBuffer
								? i.renderbufferStorageMultisample(
										i.RENDERBUFFER,
										r.multisample,
										i.DEPTH24_STENCIL8,
										t.width,
										t.height
								  )
								: i.renderbufferStorage(
										i.RENDERBUFFER,
										i.DEPTH_STENCIL,
										t.width,
										t.height
								  ),
						  i.framebufferRenderbuffer(
								i.FRAMEBUFFER,
								i.DEPTH_STENCIL_ATTACHMENT,
								i.RENDERBUFFER,
								r.stencil
						  ));
				}),
				(t.prototype.canMultisampleFramebuffer = function (t) {
					return (
						1 !== this.renderer.context.webGLVersion &&
						t.colorTextures.length <= 1 &&
						!t.depthTexture
					);
				}),
				(t.prototype.detectSamples = function (t) {
					var e = this.msaaSamples,
						i = MSAA_QUALITY$9.NONE;
					if (t <= 1 || null === e) return i;
					for (var r = 0; r < e.length; r++)
						if (e[r] <= t) {
							i = e[r];
							break;
						}
					return 1 === i && (i = MSAA_QUALITY$9.NONE), i;
				}),
				(t.prototype.blit = function (t, e, i) {
					var r = this,
						s = r.current,
						n = r.renderer,
						a = r.gl,
						o = r.CONTEXT_UID;
					if (2 === n.context.webGLVersion && s) {
						var h = s.glFramebuffers[o];
						if (h) {
							if (!t) {
								if (!h.msaaBuffer) return;
								var u = s.colorTextures[0];
								if (!u) return;
								h.blitFramebuffer ||
									((h.blitFramebuffer = new Framebuffer$3(s.width, s.height)),
									h.blitFramebuffer.addColorTexture(0, u)),
									(t = h.blitFramebuffer).colorTextures[0] !== u &&
										((t.colorTextures[0] = u), t.dirtyId++, t.dirtyFormat++),
									(t.width === s.width && t.height === s.height) ||
										((t.width = s.width),
										(t.height = s.height),
										t.dirtyId++,
										t.dirtySize++);
							}
							e ||
								(((e = tempRectangle$3).width = s.width),
								(e.height = s.height)),
								i || (i = e);
							var l = e.width === i.width && e.height === i.height;
							this.bind(t),
								a.bindFramebuffer(a.READ_FRAMEBUFFER, h.framebuffer),
								a.blitFramebuffer(
									e.left,
									e.top,
									e.right,
									e.bottom,
									i.left,
									i.top,
									i.right,
									i.bottom,
									a.COLOR_BUFFER_BIT,
									l ? a.NEAREST : a.LINEAR
								);
						}
					}
				}),
				(t.prototype.disposeFramebuffer = function (t, e) {
					var i = t.glFramebuffers[this.CONTEXT_UID],
						r = this.gl;
					if (i) {
						delete t.glFramebuffers[this.CONTEXT_UID];
						var s = this.managedFramebuffers.indexOf(t);
						s >= 0 && this.managedFramebuffers.splice(s, 1),
							t.disposeRunner.remove(this),
							e ||
								(r.deleteFramebuffer(i.framebuffer),
								i.msaaBuffer && r.deleteRenderbuffer(i.msaaBuffer),
								i.stencil && r.deleteRenderbuffer(i.stencil)),
							i.blitFramebuffer && i.blitFramebuffer.dispose();
					}
				}),
				(t.prototype.disposeAll = function (t) {
					var e = this.managedFramebuffers;
					this.managedFramebuffers = [];
					for (var i = 0; i < e.length; i++) this.disposeFramebuffer(e[i], t);
				}),
				(t.prototype.forceStencil = function () {
					var t = this.current;
					if (t) {
						var e = t.glFramebuffers[this.CONTEXT_UID];
						if (e && !e.stencil) {
							t.stencil = !0;
							var i = t.width,
								r = t.height,
								s = this.gl,
								n = s.createRenderbuffer();
							s.bindRenderbuffer(s.RENDERBUFFER, n),
								e.msaaBuffer
									? s.renderbufferStorageMultisample(
											s.RENDERBUFFER,
											e.multisample,
											s.DEPTH24_STENCIL8,
											i,
											r
									  )
									: s.renderbufferStorage(
											s.RENDERBUFFER,
											s.DEPTH_STENCIL,
											i,
											r
									  ),
								(e.stencil = n),
								s.framebufferRenderbuffer(
									s.FRAMEBUFFER,
									s.DEPTH_STENCIL_ATTACHMENT,
									s.RENDERBUFFER,
									n
								);
						}
					}
				}),
				(t.prototype.reset = function () {
					(this.current = this.unknownFramebuffer),
						(this.viewport = new Rectangle$4());
				}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})(),
		byteSizeMap$4 = { 5126: 4, 5123: 2, 5121: 1 },
		GeometrySystem$3 = (function () {
			function t(t) {
				(this.renderer = t),
					(this._activeGeometry = null),
					(this._activeVao = null),
					(this.hasVao = !0),
					(this.hasInstance = !0),
					(this.canUseUInt32ElementIndex = !1),
					(this.managedGeometries = {});
			}
			return (
				(t.prototype.contextChange = function () {
					this.disposeAll(!0);
					var t = (this.gl = this.renderer.gl),
						e = this.renderer.context;
					if (
						((this.CONTEXT_UID = this.renderer.CONTEXT_UID),
						2 !== e.webGLVersion)
					) {
						var i = this.renderer.context.extensions.vertexArrayObject;
						settings$4.PREFER_ENV === ENV$9.WEBGL_LEGACY && (i = null),
							i
								? ((t.createVertexArray = function () {
										return i.createVertexArrayOES();
								  }),
								  (t.bindVertexArray = function (t) {
										return i.bindVertexArrayOES(t);
								  }),
								  (t.deleteVertexArray = function (t) {
										return i.deleteVertexArrayOES(t);
								  }))
								: ((this.hasVao = !1),
								  (t.createVertexArray = function () {
										return null;
								  }),
								  (t.bindVertexArray = function () {
										return null;
								  }),
								  (t.deleteVertexArray = function () {
										return null;
								  }));
					}
					if (2 !== e.webGLVersion) {
						var r = t.getExtension('ANGLE_instanced_arrays');
						r
							? ((t.vertexAttribDivisor = function (t, e) {
									return r.vertexAttribDivisorANGLE(t, e);
							  }),
							  (t.drawElementsInstanced = function (t, e, i, s, n) {
									return r.drawElementsInstancedANGLE(t, e, i, s, n);
							  }),
							  (t.drawArraysInstanced = function (t, e, i, s) {
									return r.drawArraysInstancedANGLE(t, e, i, s);
							  }))
							: (this.hasInstance = !1);
					}
					this.canUseUInt32ElementIndex =
						2 === e.webGLVersion || !!e.extensions.uint32ElementIndex;
				}),
				(t.prototype.bind = function (t, e) {
					e = e || this.renderer.shader.shader;
					var i = this.gl,
						r = t.glVertexArrayObjects[this.CONTEXT_UID],
						s = !1;
					r ||
						((this.managedGeometries[t.id] = t),
						t.disposeRunner.add(this),
						(t.glVertexArrayObjects[this.CONTEXT_UID] = r = {}),
						(s = !0));
					var n = r[e.program.id] || this.initGeometryVao(t, e, s);
					(this._activeGeometry = t),
						this._activeVao !== n &&
							((this._activeVao = n),
							this.hasVao
								? i.bindVertexArray(n)
								: this.activateVao(t, e.program)),
						this.updateBuffers();
				}),
				(t.prototype.reset = function () {
					this.unbind();
				}),
				(t.prototype.updateBuffers = function () {
					for (
						var t = this._activeGeometry, e = this.renderer.buffer, i = 0;
						i < t.buffers.length;
						i++
					) {
						var r = t.buffers[i];
						e.update(r);
					}
				}),
				(t.prototype.checkCompatibility = function (t, e) {
					var i = t.attributes,
						r = e.attributeData;
					for (var s in r)
						if (!i[s])
							throw new Error(
								'shader and geometry incompatible, geometry missing the "' +
									s +
									'" attribute'
							);
				}),
				(t.prototype.getSignature = function (t, e) {
					var i = t.attributes,
						r = e.attributeData,
						s = ['g', t.id];
					for (var n in i) r[n] && s.push(n, r[n].location);
					return s.join('-');
				}),
				(t.prototype.initGeometryVao = function (t, e, i) {
					void 0 === i && (i = !0);
					var r = this.gl,
						s = this.CONTEXT_UID,
						n = this.renderer.buffer,
						a = e.program;
					a.glPrograms[s] || this.renderer.shader.generateProgram(e),
						this.checkCompatibility(t, a);
					var o = this.getSignature(t, a),
						h = t.glVertexArrayObjects[this.CONTEXT_UID],
						u = h[o];
					if (u) return (h[a.id] = u), u;
					var l = t.buffers,
						c = t.attributes,
						d = {},
						p = {};
					for (var f in l) (d[f] = 0), (p[f] = 0);
					for (var f in c)
						!c[f].size && a.attributeData[f]
							? (c[f].size = a.attributeData[f].size)
							: c[f].size,
							(d[c[f].buffer] += c[f].size * byteSizeMap$4[c[f].type]);
					for (var f in c) {
						var m = c[f],
							_ = m.size;
						void 0 === m.stride &&
							(d[m.buffer] === _ * byteSizeMap$4[m.type]
								? (m.stride = 0)
								: (m.stride = d[m.buffer])),
							void 0 === m.start &&
								((m.start = p[m.buffer]),
								(p[m.buffer] += _ * byteSizeMap$4[m.type]));
					}
					(u = r.createVertexArray()), r.bindVertexArray(u);
					for (var g = 0; g < l.length; g++) {
						var E = l[g];
						n.bind(E), i && E._glBuffers[s].refCount++;
					}
					return (
						this.activateVao(t, a),
						(this._activeVao = u),
						(h[a.id] = u),
						(h[o] = u),
						u
					);
				}),
				(t.prototype.disposeGeometry = function (t, e) {
					var i;
					if (this.managedGeometries[t.id]) {
						delete this.managedGeometries[t.id];
						var r = t.glVertexArrayObjects[this.CONTEXT_UID],
							s = this.gl,
							n = t.buffers,
							a =
								null === (i = this.renderer) || void 0 === i
									? void 0
									: i.buffer;
						if ((t.disposeRunner.remove(this), r)) {
							if (a)
								for (var o = 0; o < n.length; o++) {
									var h = n[o]._glBuffers[this.CONTEXT_UID];
									h &&
										(h.refCount--, 0 !== h.refCount || e || a.dispose(n[o], e));
								}
							if (!e)
								for (var u in r)
									if ('g' === u[0]) {
										var l = r[u];
										this._activeVao === l && this.unbind(),
											s.deleteVertexArray(l);
									}
							delete t.glVertexArrayObjects[this.CONTEXT_UID];
						}
					}
				}),
				(t.prototype.disposeAll = function (t) {
					for (
						var e = Object.keys(this.managedGeometries), i = 0;
						i < e.length;
						i++
					)
						this.disposeGeometry(this.managedGeometries[e[i]], t);
				}),
				(t.prototype.activateVao = function (t, e) {
					var i = this.gl,
						r = this.CONTEXT_UID,
						s = this.renderer.buffer,
						n = t.buffers,
						a = t.attributes;
					t.indexBuffer && s.bind(t.indexBuffer);
					var o = null;
					for (var h in a) {
						var u = a[h],
							l = n[u.buffer],
							c = l._glBuffers[r];
						if (e.attributeData[h]) {
							o !== c && (s.bind(l), (o = c));
							var d = e.attributeData[h].location;
							if (
								(i.enableVertexAttribArray(d),
								i.vertexAttribPointer(
									d,
									u.size,
									u.type || i.FLOAT,
									u.normalized,
									u.stride,
									u.start
								),
								u.instance)
							) {
								if (!this.hasInstance)
									throw new Error(
										'geometry error, GPU Instancing is not supported on this device'
									);
								i.vertexAttribDivisor(d, 1);
							}
						}
					}
				}),
				(t.prototype.draw = function (t, e, i, r) {
					var s = this.gl,
						n = this._activeGeometry;
					if (n.indexBuffer) {
						var a = n.indexBuffer.data.BYTES_PER_ELEMENT,
							o = 2 === a ? s.UNSIGNED_SHORT : s.UNSIGNED_INT;
						(2 === a || (4 === a && this.canUseUInt32ElementIndex)) &&
							(n.instanced
								? s.drawElementsInstanced(
										t,
										e || n.indexBuffer.data.length,
										o,
										(i || 0) * a,
										r || 1
								  )
								: s.drawElements(
										t,
										e || n.indexBuffer.data.length,
										o,
										(i || 0) * a
								  ));
					} else
						n.instanced
							? s.drawArraysInstanced(t, i, e || n.getSize(), r || 1)
							: s.drawArrays(t, i, e || n.getSize());
					return this;
				}),
				(t.prototype.unbind = function () {
					this.gl.bindVertexArray(null),
						(this._activeVao = null),
						(this._activeGeometry = null);
				}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})(),
		MaskData$3 = (function () {
			function t(t) {
				void 0 === t && (t = null),
					(this.type = MASK_TYPES$9.NONE),
					(this.autoDetect = !0),
					(this.maskObject = t || null),
					(this.pooled = !1),
					(this.isMaskData = !0),
					(this.resolution = null),
					(this.multisample = settings$4.FILTER_MULTISAMPLE),
					(this.enabled = !0),
					(this._filters = null),
					(this._stencilCounter = 0),
					(this._scissorCounter = 0),
					(this._scissorRect = null),
					(this._scissorRectLocal = null),
					(this._target = null);
			}
			return (
				Object.defineProperty(t.prototype, 'filter', {
					get: function () {
						return this._filters ? this._filters[0] : null;
					},
					set: function (t) {
						t
							? this._filters
								? (this._filters[0] = t)
								: (this._filters = [t])
							: (this._filters = null);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.reset = function () {
					this.pooled &&
						((this.maskObject = null),
						(this.type = MASK_TYPES$9.NONE),
						(this.autoDetect = !0)),
						(this._target = null),
						(this._scissorRectLocal = null);
				}),
				(t.prototype.copyCountersOrReset = function (t) {
					t
						? ((this._stencilCounter = t._stencilCounter),
						  (this._scissorCounter = t._scissorCounter),
						  (this._scissorRect = t._scissorRect))
						: ((this._stencilCounter = 0),
						  (this._scissorCounter = 0),
						  (this._scissorRect = null));
				}),
				t
			);
		})();
	function compileShader$3(t, e, i) {
		var r = t.createShader(e);
		return t.shaderSource(r, i), t.compileShader(r), r;
	}
	function logPrettyShaderError$3(t, e) {
		var i = t
				.getShaderSource(e)
				.split('\n')
				.map(function (t, e) {
					return e + ': ' + t;
				}),
			r = t.getShaderInfoLog(e).split('\n'),
			s = {},
			n = r
				.map(function (t) {
					return parseFloat(t.replace(/^ERROR\: 0\:([\d]+)\:.*$/, '$1'));
				})
				.filter(function (t) {
					return !(!t || s[t] || ((s[t] = !0), 0));
				}),
			a = [''];
		n.forEach(function (t) {
			(i[t - 1] = '%c' + i[t - 1] + '%c'),
				a.push(
					'background: #FF0000; color:#FFFFFF; font-size: 10px',
					'font-size: 10px'
				);
		});
		var o = i.join('\n');
		a[0] = o;
	}
	function logProgramError$3(t, e, i, r) {
		t.getProgramParameter(e, t.LINK_STATUS) ||
			(t.getShaderParameter(i, t.COMPILE_STATUS) ||
				logPrettyShaderError$3(t, i),
			t.getShaderParameter(r, t.COMPILE_STATUS) || logPrettyShaderError$3(t, r),
			t.getProgramInfoLog(e));
	}
	function booleanArray$3(t) {
		for (var e = new Array(t), i = 0; i < e.length; i++) e[i] = !1;
		return e;
	}
	function defaultValue$3(t, e) {
		switch (t) {
			case 'float':
			case 'int':
			case 'uint':
			case 'sampler2D':
			case 'sampler2DArray':
				return 0;
			case 'vec2':
				return new Float32Array(2 * e);
			case 'vec3':
				return new Float32Array(3 * e);
			case 'vec4':
				return new Float32Array(4 * e);
			case 'ivec2':
				return new Int32Array(2 * e);
			case 'ivec3':
				return new Int32Array(3 * e);
			case 'ivec4':
				return new Int32Array(4 * e);
			case 'uvec2':
				return new Uint32Array(2 * e);
			case 'uvec3':
				return new Uint32Array(3 * e);
			case 'uvec4':
				return new Uint32Array(4 * e);
			case 'bool':
				return !1;
			case 'bvec2':
				return booleanArray$3(2 * e);
			case 'bvec3':
				return booleanArray$3(3 * e);
			case 'bvec4':
				return booleanArray$3(4 * e);
			case 'mat2':
				return new Float32Array([1, 0, 0, 1]);
			case 'mat3':
				return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
			case 'mat4':
				return new Float32Array([
					1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
				]);
		}
		return null;
	}
	var unknownContext$3 = {},
		context$3 = unknownContext$3,
		maxFragmentPrecision$3;
	function getTestContext$3() {
		if (
			context$3 === unknownContext$3 ||
			(context$3 && context$3.isContextLost())
		) {
			var t = document.createElement('canvas'),
				e = void 0;
			settings$4.PREFER_ENV >= ENV$9.WEBGL2 && (e = t.getContext('webgl2', {})),
				e ||
					((e =
						t.getContext('webgl', {}) || t.getContext('experimental-webgl', {}))
						? e.getExtension('WEBGL_draw_buffers')
						: (e = null)),
				(context$3 = e);
		}
		return context$3;
	}
	function getMaxFragmentPrecision$3() {
		if (!maxFragmentPrecision$3) {
			maxFragmentPrecision$3 = PRECISION$9.MEDIUM;
			var t = getTestContext$3();
			if (t && t.getShaderPrecisionFormat) {
				var e = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT);
				maxFragmentPrecision$3 = e.precision
					? PRECISION$9.HIGH
					: PRECISION$9.MEDIUM;
			}
		}
		return maxFragmentPrecision$3;
	}
	function setPrecision$3(t, e, i) {
		if ('precision' !== t.substring(0, 9)) {
			var r = e;
			return (
				e === PRECISION$9.HIGH &&
					i !== PRECISION$9.HIGH &&
					(r = PRECISION$9.MEDIUM),
				'precision ' + r + ' float;\n' + t
			);
		}
		return i !== PRECISION$9.HIGH && 'precision highp' === t.substring(0, 15)
			? t.replace('precision highp', 'precision mediump')
			: t;
	}
	var GLSL_TO_SIZE$3 = {
		float: 1,
		vec2: 2,
		vec3: 3,
		vec4: 4,
		int: 1,
		ivec2: 2,
		ivec3: 3,
		ivec4: 4,
		uint: 1,
		uvec2: 2,
		uvec3: 3,
		uvec4: 4,
		bool: 1,
		bvec2: 2,
		bvec3: 3,
		bvec4: 4,
		mat2: 4,
		mat3: 9,
		mat4: 16,
		sampler2D: 1,
	};
	function mapSize$3(t) {
		return GLSL_TO_SIZE$3[t];
	}
	var GL_TABLE$3 = null,
		GL_TO_GLSL_TYPES$3 = {
			FLOAT: 'float',
			FLOAT_VEC2: 'vec2',
			FLOAT_VEC3: 'vec3',
			FLOAT_VEC4: 'vec4',
			INT: 'int',
			INT_VEC2: 'ivec2',
			INT_VEC3: 'ivec3',
			INT_VEC4: 'ivec4',
			UNSIGNED_INT: 'uint',
			UNSIGNED_INT_VEC2: 'uvec2',
			UNSIGNED_INT_VEC3: 'uvec3',
			UNSIGNED_INT_VEC4: 'uvec4',
			BOOL: 'bool',
			BOOL_VEC2: 'bvec2',
			BOOL_VEC3: 'bvec3',
			BOOL_VEC4: 'bvec4',
			FLOAT_MAT2: 'mat2',
			FLOAT_MAT3: 'mat3',
			FLOAT_MAT4: 'mat4',
			SAMPLER_2D: 'sampler2D',
			INT_SAMPLER_2D: 'sampler2D',
			UNSIGNED_INT_SAMPLER_2D: 'sampler2D',
			SAMPLER_CUBE: 'samplerCube',
			INT_SAMPLER_CUBE: 'samplerCube',
			UNSIGNED_INT_SAMPLER_CUBE: 'samplerCube',
			SAMPLER_2D_ARRAY: 'sampler2DArray',
			INT_SAMPLER_2D_ARRAY: 'sampler2DArray',
			UNSIGNED_INT_SAMPLER_2D_ARRAY: 'sampler2DArray',
		};
	function mapType$3(t, e) {
		if (!GL_TABLE$3) {
			var i = Object.keys(GL_TO_GLSL_TYPES$3);
			GL_TABLE$3 = {};
			for (var r = 0; r < i.length; ++r) {
				var s = i[r];
				GL_TABLE$3[t[s]] = GL_TO_GLSL_TYPES$3[s];
			}
		}
		return GL_TABLE$3[e];
	}
	var uniformParsers$3 = [
			{
				test: function (t) {
					return 'float' === t.type && 1 === t.size;
				},
				code: function (t) {
					return (
						'\n            if(uv["' +
						t +
						'"] !== ud["' +
						t +
						'"].value)\n            {\n                ud["' +
						t +
						'"].value = uv["' +
						t +
						'"]\n                gl.uniform1f(ud["' +
						t +
						'"].location, uv["' +
						t +
						'"])\n            }\n            '
					);
				},
			},
			{
				test: function (t) {
					return (
						('sampler2D' === t.type ||
							'samplerCube' === t.type ||
							'sampler2DArray' === t.type) &&
						1 === t.size &&
						!t.isArray
					);
				},
				code: function (t) {
					return (
						't = syncData.textureCount++;\n\n            renderer.texture.bind(uv["' +
						t +
						'"], t);\n\n            if(ud["' +
						t +
						'"].value !== t)\n            {\n                ud["' +
						t +
						'"].value = t;\n                gl.uniform1i(ud["' +
						t +
						'"].location, t);\n; // eslint-disable-line max-len\n            }'
					);
				},
			},
			{
				test: function (t, e) {
					return 'mat3' === t.type && 1 === t.size && void 0 !== e.a;
				},
				code: function (t) {
					return (
						'\n            gl.uniformMatrix3fv(ud["' +
						t +
						'"].location, false, uv["' +
						t +
						'"].toArray(true));\n            '
					);
				},
				codeUbo: function (t) {
					return (
						'\n                var ' +
						t +
						'_matrix = uv.' +
						t +
						'.toArray(true);\n\n                data[offset] = ' +
						t +
						'_matrix[0];\n                data[offset+1] = ' +
						t +
						'_matrix[1];\n                data[offset+2] = ' +
						t +
						'_matrix[2];\n        \n                data[offset + 4] = ' +
						t +
						'_matrix[3];\n                data[offset + 5] = ' +
						t +
						'_matrix[4];\n                data[offset + 6] = ' +
						t +
						'_matrix[5];\n        \n                data[offset + 8] = ' +
						t +
						'_matrix[6];\n                data[offset + 9] = ' +
						t +
						'_matrix[7];\n                data[offset + 10] = ' +
						t +
						'_matrix[8];\n            '
					);
				},
			},
			{
				test: function (t, e) {
					return 'vec2' === t.type && 1 === t.size && void 0 !== e.x;
				},
				code: function (t) {
					return (
						'\n                cv = ud["' +
						t +
						'"].value;\n                v = uv["' +
						t +
						'"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["' +
						t +
						'"].location, v.x, v.y);\n                }'
					);
				},
				codeUbo: function (t) {
					return (
						'\n                v = uv.' +
						t +
						';\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            '
					);
				},
			},
			{
				test: function (t) {
					return 'vec2' === t.type && 1 === t.size;
				},
				code: function (t) {
					return (
						'\n                cv = ud["' +
						t +
						'"].value;\n                v = uv["' +
						t +
						'"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["' +
						t +
						'"].location, v[0], v[1]);\n                }\n            '
					);
				},
			},
			{
				test: function (t, e) {
					return 'vec4' === t.type && 1 === t.size && void 0 !== e.width;
				},
				code: function (t) {
					return (
						'\n                cv = ud["' +
						t +
						'"].value;\n                v = uv["' +
						t +
						'"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["' +
						t +
						'"].location, v.x, v.y, v.width, v.height)\n                }'
					);
				},
				codeUbo: function (t) {
					return (
						'\n                    v = uv.' +
						t +
						';\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                '
					);
				},
			},
			{
				test: function (t) {
					return 'vec4' === t.type && 1 === t.size;
				},
				code: function (t) {
					return (
						'\n                cv = ud["' +
						t +
						'"].value;\n                v = uv["' +
						t +
						'"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["' +
						t +
						'"].location, v[0], v[1], v[2], v[3])\n                }'
					);
				},
			},
		],
		GLSL_TO_SINGLE_SETTERS_CACHED$3 = {
			float:
				'\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }',
			vec2: '\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }',
			vec3: '\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }',
			vec4: '\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }',
			int: '\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }',
			ivec2:
				'\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }',
			ivec3:
				'\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }',
			ivec4:
				'\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }',
			uint: '\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }',
			uvec2:
				'\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }',
			uvec3:
				'\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }',
			uvec4:
				'\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }',
			bool: '\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }',
			bvec2:
				'\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }',
			bvec3:
				'\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }',
			bvec4:
				'\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }',
			mat2: 'gl.uniformMatrix2fv(location, false, v)',
			mat3: 'gl.uniformMatrix3fv(location, false, v)',
			mat4: 'gl.uniformMatrix4fv(location, false, v)',
			sampler2D: 'gl.uniform1i(location, v)',
			samplerCube: 'gl.uniform1i(location, v)',
			sampler2DArray: 'gl.uniform1i(location, v)',
		},
		GLSL_TO_ARRAY_SETTERS$3 = {
			float: 'gl.uniform1fv(location, v)',
			vec2: 'gl.uniform2fv(location, v)',
			vec3: 'gl.uniform3fv(location, v)',
			vec4: 'gl.uniform4fv(location, v)',
			mat4: 'gl.uniformMatrix4fv(location, false, v)',
			mat3: 'gl.uniformMatrix3fv(location, false, v)',
			mat2: 'gl.uniformMatrix2fv(location, false, v)',
			int: 'gl.uniform1iv(location, v)',
			ivec2: 'gl.uniform2iv(location, v)',
			ivec3: 'gl.uniform3iv(location, v)',
			ivec4: 'gl.uniform4iv(location, v)',
			uint: 'gl.uniform1uiv(location, v)',
			uvec2: 'gl.uniform2uiv(location, v)',
			uvec3: 'gl.uniform3uiv(location, v)',
			uvec4: 'gl.uniform4uiv(location, v)',
			bool: 'gl.uniform1iv(location, v)',
			bvec2: 'gl.uniform2iv(location, v)',
			bvec3: 'gl.uniform3iv(location, v)',
			bvec4: 'gl.uniform4iv(location, v)',
			sampler2D: 'gl.uniform1iv(location, v)',
			samplerCube: 'gl.uniform1iv(location, v)',
			sampler2DArray: 'gl.uniform1iv(location, v)',
		};
	function generateUniformsSync$3(t, e) {
		var i,
			r = [
				'\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    ',
			];
		for (var s in t.uniforms) {
			var n = e[s];
			if (n) {
				for (
					var a = t.uniforms[s], o = !1, h = 0;
					h < uniformParsers$3.length;
					h++
				)
					if (uniformParsers$3[h].test(n, a)) {
						r.push(uniformParsers$3[h].code(s, a)), (o = !0);
						break;
					}
				if (!o) {
					var u = (
						1 === n.size
							? GLSL_TO_SINGLE_SETTERS_CACHED$3
							: GLSL_TO_ARRAY_SETTERS$3
					)[n.type].replace('location', 'ud["' + s + '"].location');
					r.push(
						'\n            cu = ud["' +
							s +
							'"];\n            cv = cu.value;\n            v = uv["' +
							s +
							'"];\n            ' +
							u +
							';'
					);
				}
			} else
				(null === (i = t.uniforms[s]) || void 0 === i ? void 0 : i.group) &&
					(t.uniforms[s].ubo
						? r.push(
								'\n                        renderer.shader.syncUniformBufferGroup(uv.' +
									s +
									", '" +
									s +
									"');\n                    "
						  )
						: r.push(
								'\n                        renderer.shader.syncUniformGroup(uv.' +
									s +
									', syncData);\n                    '
						  ));
		}
		return new Function('ud', 'uv', 'renderer', 'syncData', r.join('\n'));
	}
	var fragTemplate$3 = [
			'precision mediump float;',
			'void main(void){',
			'float test = 0.1;',
			'%forloop%',
			'gl_FragColor = vec4(0.0);',
			'}',
		].join('\n'),
		unsafeEval$3;
	function generateIfTestSrc$3(t) {
		for (var e = '', i = 0; i < t; ++i)
			i > 0 && (e += '\nelse '),
				i < t - 1 && (e += 'if(test == ' + i + '.0){}');
		return e;
	}
	function checkMaxIfStatementsInShader$3(t, e) {
		if (0 === t)
			throw new Error(
				'Invalid value of `0` passed to `checkMaxIfStatementsInShader`'
			);
		for (var i = e.createShader(e.FRAGMENT_SHADER); ; ) {
			var r = fragTemplate$3.replace(/%forloop%/gi, generateIfTestSrc$3(t));
			if (
				(e.shaderSource(i, r),
				e.compileShader(i),
				e.getShaderParameter(i, e.COMPILE_STATUS))
			)
				break;
			t = (t / 2) | 0;
		}
		return t;
	}
	function unsafeEvalSupported$3() {
		if ('boolean' == typeof unsafeEval$3) return unsafeEval$3;
		try {
			var t = new Function(
				'param1',
				'param2',
				'param3',
				'return param1[param2] === param3;'
			);
			unsafeEval$3 = !0 === t({ a: 'b' }, 'a', 'b');
		} catch (t) {
			unsafeEval$3 = !1;
		}
		return unsafeEval$3;
	}
	var defaultFragment$2$3 =
			'varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}',
		defaultVertex$3$3 =
			'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n',
		UID$1$3 = 0,
		nameCache$3 = {},
		Program$3 = (function () {
			function t(e, i, r) {
				void 0 === r && (r = 'pixi-shader'),
					(this.id = UID$1$3++),
					(this.vertexSrc = e || t.defaultVertexSrc),
					(this.fragmentSrc = i || t.defaultFragmentSrc),
					(this.vertexSrc = this.vertexSrc.trim()),
					(this.fragmentSrc = this.fragmentSrc.trim()),
					'#version' !== this.vertexSrc.substring(0, 8) &&
						((r = r.replace(/\s+/g, '-')),
						nameCache$3[r]
							? (nameCache$3[r]++, (r += '-' + nameCache$3[r]))
							: (nameCache$3[r] = 1),
						(this.vertexSrc =
							'#define SHADER_NAME ' + r + '\n' + this.vertexSrc),
						(this.fragmentSrc =
							'#define SHADER_NAME ' + r + '\n' + this.fragmentSrc),
						(this.vertexSrc = setPrecision$3(
							this.vertexSrc,
							settings$4.PRECISION_VERTEX,
							PRECISION$9.HIGH
						)),
						(this.fragmentSrc = setPrecision$3(
							this.fragmentSrc,
							settings$4.PRECISION_FRAGMENT,
							getMaxFragmentPrecision$3()
						))),
					(this.glPrograms = {}),
					(this.syncUniforms = null);
			}
			return (
				Object.defineProperty(t, 'defaultVertexSrc', {
					get: function () {
						return defaultVertex$3$3;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t, 'defaultFragmentSrc', {
					get: function () {
						return defaultFragment$2$3;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.from = function (e, i, r) {
					var s = e + i,
						n = ProgramCache$3[s];
					return n || (ProgramCache$3[s] = n = new t(e, i, r)), n;
				}),
				t
			);
		})(),
		Shader$3 = (function () {
			function t(t, e) {
				(this.uniformBindCount = 0),
					(this.program = t),
					(this.uniformGroup = e
						? e instanceof UniformGroup$3
							? e
							: new UniformGroup$3(e)
						: new UniformGroup$3({}));
			}
			return (
				(t.prototype.checkUniformExists = function (t, e) {
					if (e.uniforms[t]) return !0;
					for (var i in e.uniforms) {
						var r = e.uniforms[i];
						if (r.group && this.checkUniformExists(t, r)) return !0;
					}
					return !1;
				}),
				(t.prototype.destroy = function () {
					this.uniformGroup = null;
				}),
				Object.defineProperty(t.prototype, 'uniforms', {
					get: function () {
						return this.uniformGroup.uniforms;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.from = function (e, i, r) {
					return new t(Program$3.from(e, i), r);
				}),
				t
			);
		})(),
		BLEND$1$3 = 0,
		OFFSET$1$3 = 1,
		CULLING$1$3 = 2,
		DEPTH_TEST$1$3 = 3,
		WINDING$1$3 = 4,
		DEPTH_MASK$1$3 = 5,
		State$3 = (function () {
			function t() {
				(this.data = 0),
					(this.blendMode = BLEND_MODES$9.NORMAL),
					(this.polygonOffset = 0),
					(this.blend = !0),
					(this.depthMask = !0);
			}
			return (
				Object.defineProperty(t.prototype, 'blend', {
					get: function () {
						return !!(this.data & (1 << BLEND$1$3));
					},
					set: function (t) {
						!!(this.data & (1 << BLEND$1$3)) !== t &&
							(this.data ^= 1 << BLEND$1$3);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'offsets', {
					get: function () {
						return !!(this.data & (1 << OFFSET$1$3));
					},
					set: function (t) {
						!!(this.data & (1 << OFFSET$1$3)) !== t &&
							(this.data ^= 1 << OFFSET$1$3);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'culling', {
					get: function () {
						return !!(this.data & (1 << CULLING$1$3));
					},
					set: function (t) {
						!!(this.data & (1 << CULLING$1$3)) !== t &&
							(this.data ^= 1 << CULLING$1$3);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'depthTest', {
					get: function () {
						return !!(this.data & (1 << DEPTH_TEST$1$3));
					},
					set: function (t) {
						!!(this.data & (1 << DEPTH_TEST$1$3)) !== t &&
							(this.data ^= 1 << DEPTH_TEST$1$3);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'depthMask', {
					get: function () {
						return !!(this.data & (1 << DEPTH_MASK$1$3));
					},
					set: function (t) {
						!!(this.data & (1 << DEPTH_MASK$1$3)) !== t &&
							(this.data ^= 1 << DEPTH_MASK$1$3);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'clockwiseFrontFace', {
					get: function () {
						return !!(this.data & (1 << WINDING$1$3));
					},
					set: function (t) {
						!!(this.data & (1 << WINDING$1$3)) !== t &&
							(this.data ^= 1 << WINDING$1$3);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'blendMode', {
					get: function () {
						return this._blendMode;
					},
					set: function (t) {
						(this.blend = t !== BLEND_MODES$9.NONE), (this._blendMode = t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'polygonOffset', {
					get: function () {
						return this._polygonOffset;
					},
					set: function (t) {
						(this.offsets = !!t), (this._polygonOffset = t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.toString = function () {
					return (
						'[@pixi/core:State blendMode=' +
						this.blendMode +
						' clockwiseFrontFace=' +
						this.clockwiseFrontFace +
						' culling=' +
						this.culling +
						' depthMask=' +
						this.depthMask +
						' polygonOffset=' +
						this.polygonOffset +
						']'
					);
				}),
				(t.for2d = function () {
					var e = new t();
					return (e.depthTest = !1), (e.blend = !0), e;
				}),
				t
			);
		})(),
		defaultVertex$2$2 =
			'attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n',
		defaultFragment$1$3 =
			'varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n',
		Filter$3 = (function (t) {
			function e(i, r, s) {
				var n = this,
					a = Program$3.from(
						i || e.defaultVertexSrc,
						r || e.defaultFragmentSrc
					);
				return (
					((n = t.call(this, a, s) || this).padding = 0),
					(n.resolution = settings$4.FILTER_RESOLUTION),
					(n.multisample = settings$4.FILTER_MULTISAMPLE),
					(n.enabled = !0),
					(n.autoFit = !0),
					(n.state = new State$3()),
					n
				);
			}
			return (
				__extends$n(e, t),
				(e.prototype.apply = function (t, e, i, r, s) {
					t.applyFilter(this, e, i, r);
				}),
				Object.defineProperty(e.prototype, 'blendMode', {
					get: function () {
						return this.state.blendMode;
					},
					set: function (t) {
						this.state.blendMode = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'resolution', {
					get: function () {
						return this._resolution;
					},
					set: function (t) {
						this._resolution = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e, 'defaultVertexSrc', {
					get: function () {
						return defaultVertex$2$2;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e, 'defaultFragmentSrc', {
					get: function () {
						return defaultFragment$1$3;
					},
					enumerable: !1,
					configurable: !0,
				}),
				e
			);
		})(Shader$3),
		vertex$c =
			'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n',
		fragment$e =
			'varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n',
		tempMat$4 = new Matrix$3(),
		TextureMatrix$3 = (function () {
			function t(t, e) {
				(this._texture = t),
					(this.mapCoord = new Matrix$3()),
					(this.uClampFrame = new Float32Array(4)),
					(this.uClampOffset = new Float32Array(2)),
					(this._textureID = -1),
					(this._updateID = 0),
					(this.clampOffset = 0),
					(this.clampMargin = void 0 === e ? 0.5 : e),
					(this.isSimple = !1);
			}
			return (
				Object.defineProperty(t.prototype, 'texture', {
					get: function () {
						return this._texture;
					},
					set: function (t) {
						(this._texture = t), (this._textureID = -1);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.multiplyUvs = function (t, e) {
					void 0 === e && (e = t);
					for (var i = this.mapCoord, r = 0; r < t.length; r += 2) {
						var s = t[r],
							n = t[r + 1];
						(e[r] = s * i.a + n * i.c + i.tx),
							(e[r + 1] = s * i.b + n * i.d + i.ty);
					}
					return e;
				}),
				(t.prototype.update = function (t) {
					var e = this._texture;
					if (!e || !e.valid) return !1;
					if (!t && this._textureID === e._updateID) return !1;
					(this._textureID = e._updateID), this._updateID++;
					var i = e._uvs;
					this.mapCoord.set(
						i.x1 - i.x0,
						i.y1 - i.y0,
						i.x3 - i.x0,
						i.y3 - i.y0,
						i.x0,
						i.y0
					);
					var r = e.orig,
						s = e.trim;
					s &&
						(tempMat$4.set(
							r.width / s.width,
							0,
							0,
							r.height / s.height,
							-s.x / s.width,
							-s.y / s.height
						),
						this.mapCoord.append(tempMat$4));
					var n = e.baseTexture,
						a = this.uClampFrame,
						o = this.clampMargin / n.resolution,
						h = this.clampOffset;
					return (
						(a[0] = (e._frame.x + o + h) / n.width),
						(a[1] = (e._frame.y + o + h) / n.height),
						(a[2] = (e._frame.x + e._frame.width - o + h) / n.width),
						(a[3] = (e._frame.y + e._frame.height - o + h) / n.height),
						(this.uClampOffset[0] = h / n.realWidth),
						(this.uClampOffset[1] = h / n.realHeight),
						(this.isSimple =
							e._frame.width === n.width &&
							e._frame.height === n.height &&
							0 === e.rotate),
						!0
					);
				}),
				t
			);
		})(),
		SpriteMaskFilter$3 = (function (t) {
			function e(e, i, r) {
				var s = this,
					n = null;
				return (
					'string' != typeof e &&
						void 0 === i &&
						void 0 === r &&
						((n = e), (e = void 0), (i = void 0), (r = void 0)),
					((s =
						t.call(this, e || vertex$c, i || fragment$e, r) ||
						this).maskSprite = n),
					(s.maskMatrix = new Matrix$3()),
					s
				);
			}
			return (
				__extends$n(e, t),
				Object.defineProperty(e.prototype, 'maskSprite', {
					get: function () {
						return this._maskSprite;
					},
					set: function (t) {
						(this._maskSprite = t),
							this._maskSprite && (this._maskSprite.renderable = !1);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.apply = function (t, e, i, r) {
					var s = this._maskSprite,
						n = s._texture;
					n.valid &&
						(n.uvMatrix || (n.uvMatrix = new TextureMatrix$3(n, 0)),
						n.uvMatrix.update(),
						(this.uniforms.npmAlpha = n.baseTexture.alphaMode ? 0 : 1),
						(this.uniforms.mask = n),
						(this.uniforms.otherMatrix = t
							.calculateSpriteMatrix(this.maskMatrix, s)
							.prepend(n.uvMatrix.mapCoord)),
						(this.uniforms.alpha = s.worldAlpha),
						(this.uniforms.maskClamp = n.uvMatrix.uClampFrame),
						t.applyFilter(this, e, i, r));
				}),
				e
			);
		})(Filter$3),
		MaskSystem$3 = (function () {
			function t(t) {
				(this.renderer = t),
					(this.enableScissor = !0),
					(this.alphaMaskPool = []),
					(this.maskDataPool = []),
					(this.maskStack = []),
					(this.alphaMaskIndex = 0);
			}
			return (
				(t.prototype.setMaskStack = function (t) {
					(this.maskStack = t),
						this.renderer.scissor.setMaskStack(t),
						this.renderer.stencil.setMaskStack(t);
				}),
				(t.prototype.push = function (t, e) {
					var i = e;
					if (!i.isMaskData) {
						var r = this.maskDataPool.pop() || new MaskData$3();
						(r.pooled = !0), (r.maskObject = e), (i = r);
					}
					var s =
						0 !== this.maskStack.length
							? this.maskStack[this.maskStack.length - 1]
							: null;
					if (
						(i.copyCountersOrReset(s),
						i.autoDetect && this.detect(i),
						(i._target = t),
						i.type !== MASK_TYPES$9.SPRITE && this.maskStack.push(i),
						i.enabled)
					)
						switch (i.type) {
							case MASK_TYPES$9.SCISSOR:
								this.renderer.scissor.push(i);
								break;
							case MASK_TYPES$9.STENCIL:
								this.renderer.stencil.push(i);
								break;
							case MASK_TYPES$9.SPRITE:
								i.copyCountersOrReset(null), this.pushSpriteMask(i);
						}
					i.type === MASK_TYPES$9.SPRITE && this.maskStack.push(i);
				}),
				(t.prototype.pop = function (t) {
					var e = this.maskStack.pop();
					if (e && e._target === t) {
						if (e.enabled)
							switch (e.type) {
								case MASK_TYPES$9.SCISSOR:
									this.renderer.scissor.pop();
									break;
								case MASK_TYPES$9.STENCIL:
									this.renderer.stencil.pop(e.maskObject);
									break;
								case MASK_TYPES$9.SPRITE:
									this.popSpriteMask(e);
							}
						if (
							(e.reset(),
							e.pooled && this.maskDataPool.push(e),
							0 !== this.maskStack.length)
						) {
							var i = this.maskStack[this.maskStack.length - 1];
							i.type === MASK_TYPES$9.SPRITE &&
								i._filters &&
								(i._filters[0].maskSprite = i.maskObject);
						}
					}
				}),
				(t.prototype.detect = function (t) {
					t.maskObject.isSprite
						? (t.type = MASK_TYPES$9.SPRITE)
						: this.enableScissor && this.renderer.scissor.testScissor(t)
						? (t.type = MASK_TYPES$9.SCISSOR)
						: (t.type = MASK_TYPES$9.STENCIL);
				}),
				(t.prototype.pushSpriteMask = function (t) {
					var e,
						i,
						r = t.maskObject,
						s = t._target,
						n = t._filters;
					n ||
						(n = this.alphaMaskPool[this.alphaMaskIndex]) ||
						(n = this.alphaMaskPool[this.alphaMaskIndex] =
							[new SpriteMaskFilter$3()]);
					var a,
						o,
						h = this.renderer,
						u = h.renderTexture;
					if (u.current) {
						var l = u.current;
						(a = t.resolution || l.resolution),
							(o =
								null !== (e = t.multisample) && void 0 !== e
									? e
									: l.multisample);
					} else
						(a = t.resolution || h.resolution),
							(o =
								null !== (i = t.multisample) && void 0 !== i
									? i
									: h.multisample);
					(n[0].resolution = a), (n[0].multisample = o), (n[0].maskSprite = r);
					var c = s.filterArea;
					(s.filterArea = r.getBounds(!0)),
						h.filter.push(s, n),
						(s.filterArea = c),
						t._filters || this.alphaMaskIndex++;
				}),
				(t.prototype.popSpriteMask = function (t) {
					this.renderer.filter.pop(),
						t._filters
							? (t._filters[0].maskSprite = null)
							: (this.alphaMaskIndex--,
							  (this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null));
				}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})(),
		AbstractMaskSystem$3 = (function () {
			function t(t) {
				(this.renderer = t), (this.maskStack = []), (this.glConst = 0);
			}
			return (
				(t.prototype.getStackLength = function () {
					return this.maskStack.length;
				}),
				(t.prototype.setMaskStack = function (t) {
					var e = this.renderer.gl,
						i = this.getStackLength();
					this.maskStack = t;
					var r = this.getStackLength();
					r !== i &&
						(0 === r
							? e.disable(this.glConst)
							: (e.enable(this.glConst), this._useCurrent()));
				}),
				(t.prototype._useCurrent = function () {}),
				(t.prototype.destroy = function () {
					(this.renderer = null), (this.maskStack = null);
				}),
				t
			);
		})(),
		tempMatrix$1$3 = new Matrix$3(),
		ScissorSystem$3 = (function (t) {
			function e(e) {
				var i = t.call(this, e) || this;
				return (i.glConst = WebGLRenderingContext.SCISSOR_TEST), i;
			}
			return (
				__extends$n(e, t),
				(e.prototype.getStackLength = function () {
					var t = this.maskStack[this.maskStack.length - 1];
					return t ? t._scissorCounter : 0;
				}),
				(e.prototype.calcScissorRect = function (t) {
					if (!t._scissorRectLocal) {
						var e = t._scissorRect,
							i = t.maskObject,
							r = this.renderer,
							s = r.renderTexture;
						i.renderable = !0;
						var n = i.getBounds();
						this.roundFrameToPixels(
							n,
							s.current ? s.current.resolution : r.resolution,
							s.sourceFrame,
							s.destinationFrame,
							r.projection.transform
						),
							(i.renderable = !1),
							e && n.fit(e),
							(t._scissorRectLocal = n);
					}
				}),
				(e.isMatrixRotated = function (t) {
					if (!t) return !1;
					var e = t.a,
						i = t.b,
						r = t.c,
						s = t.d;
					return (
						(Math.abs(i) > 1e-4 || Math.abs(r) > 1e-4) &&
						(Math.abs(e) > 1e-4 || Math.abs(s) > 1e-4)
					);
				}),
				(e.prototype.testScissor = function (t) {
					var i = t.maskObject;
					if (!i.isFastRect || !i.isFastRect()) return !1;
					if (e.isMatrixRotated(i.worldTransform)) return !1;
					if (e.isMatrixRotated(this.renderer.projection.transform)) return !1;
					this.calcScissorRect(t);
					var r = t._scissorRectLocal;
					return r.width > 0 && r.height > 0;
				}),
				(e.prototype.roundFrameToPixels = function (t, i, r, s, n) {
					e.isMatrixRotated(n) ||
						((n = n ? tempMatrix$1$3.copyFrom(n) : tempMatrix$1$3.identity())
							.translate(-r.x, -r.y)
							.scale(s.width / r.width, s.height / r.height)
							.translate(s.x, s.y),
						this.renderer.filter.transformAABB(n, t),
						t.fit(s),
						(t.x = Math.round(t.x * i)),
						(t.y = Math.round(t.y * i)),
						(t.width = Math.round(t.width * i)),
						(t.height = Math.round(t.height * i)));
				}),
				(e.prototype.push = function (t) {
					t._scissorRectLocal || this.calcScissorRect(t);
					var e = this.renderer.gl;
					t._scissorRect || e.enable(e.SCISSOR_TEST),
						t._scissorCounter++,
						(t._scissorRect = t._scissorRectLocal),
						this._useCurrent();
				}),
				(e.prototype.pop = function () {
					var t = this.renderer.gl;
					this.getStackLength() > 0
						? this._useCurrent()
						: t.disable(t.SCISSOR_TEST);
				}),
				(e.prototype._useCurrent = function () {
					var t,
						e = this.maskStack[this.maskStack.length - 1]._scissorRect;
					(t = this.renderer.renderTexture.current
						? e.y
						: this.renderer.height - e.height - e.y),
						this.renderer.gl.scissor(e.x, t, e.width, e.height);
				}),
				e
			);
		})(AbstractMaskSystem$3),
		StencilSystem$3 = (function (t) {
			function e(e) {
				var i = t.call(this, e) || this;
				return (i.glConst = WebGLRenderingContext.STENCIL_TEST), i;
			}
			return (
				__extends$n(e, t),
				(e.prototype.getStackLength = function () {
					var t = this.maskStack[this.maskStack.length - 1];
					return t ? t._stencilCounter : 0;
				}),
				(e.prototype.push = function (t) {
					var e = t.maskObject,
						i = this.renderer.gl,
						r = t._stencilCounter;
					0 === r &&
						(this.renderer.framebuffer.forceStencil(),
						i.clearStencil(0),
						i.clear(i.STENCIL_BUFFER_BIT),
						i.enable(i.STENCIL_TEST)),
						t._stencilCounter++,
						i.colorMask(!1, !1, !1, !1),
						i.stencilFunc(i.EQUAL, r, 4294967295),
						i.stencilOp(i.KEEP, i.KEEP, i.INCR),
						(e.renderable = !0),
						e.render(this.renderer),
						this.renderer.batch.flush(),
						(e.renderable = !1),
						this._useCurrent();
				}),
				(e.prototype.pop = function (t) {
					var e = this.renderer.gl;
					0 === this.getStackLength()
						? e.disable(e.STENCIL_TEST)
						: (e.colorMask(!1, !1, !1, !1),
						  e.stencilOp(e.KEEP, e.KEEP, e.DECR),
						  (t.renderable = !0),
						  t.render(this.renderer),
						  this.renderer.batch.flush(),
						  (t.renderable = !1),
						  this._useCurrent());
				}),
				(e.prototype._useCurrent = function () {
					var t = this.renderer.gl;
					t.colorMask(!0, !0, !0, !0),
						t.stencilFunc(t.EQUAL, this.getStackLength(), 4294967295),
						t.stencilOp(t.KEEP, t.KEEP, t.KEEP);
				}),
				e
			);
		})(AbstractMaskSystem$3),
		ProjectionSystem$3 = (function () {
			function t(t) {
				(this.renderer = t),
					(this.destinationFrame = null),
					(this.sourceFrame = null),
					(this.defaultFrame = null),
					(this.projectionMatrix = new Matrix$3()),
					(this.transform = null);
			}
			return (
				(t.prototype.update = function (t, e, i, r) {
					(this.destinationFrame =
						t || this.destinationFrame || this.defaultFrame),
						(this.sourceFrame = e || this.sourceFrame || t),
						this.calculateProjection(
							this.destinationFrame,
							this.sourceFrame,
							i,
							r
						),
						this.transform && this.projectionMatrix.append(this.transform);
					var s = this.renderer;
					(s.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix),
						s.globalUniforms.update(),
						s.shader.shader &&
							s.shader.syncUniformGroup(s.shader.shader.uniforms.globals);
				}),
				(t.prototype.calculateProjection = function (t, e, i, r) {
					var s = this.projectionMatrix,
						n = r ? -1 : 1;
					s.identity(),
						(s.a = (1 / e.width) * 2),
						(s.d = n * ((1 / e.height) * 2)),
						(s.tx = -1 - e.x * s.a),
						(s.ty = -n - e.y * s.d);
				}),
				(t.prototype.setTransform = function (t) {}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})(),
		tempRect$3 = new Rectangle$4(),
		tempRect2$3 = new Rectangle$4(),
		RenderTextureSystem$3 = (function () {
			function t(t) {
				(this.renderer = t),
					(this.clearColor = t._backgroundColorRgba),
					(this.defaultMaskStack = []),
					(this.current = null),
					(this.sourceFrame = new Rectangle$4()),
					(this.destinationFrame = new Rectangle$4()),
					(this.viewportFrame = new Rectangle$4());
			}
			return (
				(t.prototype.bind = function (t, e, i) {
					void 0 === t && (t = null);
					var r,
						s,
						n,
						a = this.renderer;
					(this.current = t),
						t
							? ((n = (r = t.baseTexture).resolution),
							  e ||
									((tempRect$3.width = t.frame.width),
									(tempRect$3.height = t.frame.height),
									(e = tempRect$3)),
							  i ||
									((tempRect2$3.x = t.frame.x),
									(tempRect2$3.y = t.frame.y),
									(tempRect2$3.width = e.width),
									(tempRect2$3.height = e.height),
									(i = tempRect2$3)),
							  (s = r.framebuffer))
							: ((n = a.resolution),
							  e ||
									((tempRect$3.width = a.screen.width),
									(tempRect$3.height = a.screen.height),
									(e = tempRect$3)),
							  i ||
									(((i = tempRect$3).width = e.width), (i.height = e.height)));
					var o = this.viewportFrame;
					(o.x = i.x * n),
						(o.y = i.y * n),
						(o.width = i.width * n),
						(o.height = i.height * n),
						t || (o.y = a.view.height - (o.y + o.height)),
						o.ceil(),
						this.renderer.framebuffer.bind(s, o),
						this.renderer.projection.update(i, e, n, !s),
						t
							? this.renderer.mask.setMaskStack(r.maskStack)
							: this.renderer.mask.setMaskStack(this.defaultMaskStack),
						this.sourceFrame.copyFrom(e),
						this.destinationFrame.copyFrom(i);
				}),
				(t.prototype.clear = function (t, e) {
					t = this.current
						? t || this.current.baseTexture.clearColor
						: t || this.clearColor;
					var i = this.destinationFrame,
						r = this.current ? this.current.baseTexture : this.renderer.screen,
						s = i.width !== r.width || i.height !== r.height;
					if (s) {
						var n = this.viewportFrame,
							a = n.x,
							o = n.y,
							h = n.width,
							u = n.height;
						(a = Math.round(a)),
							(o = Math.round(o)),
							(h = Math.round(h)),
							(u = Math.round(u)),
							this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST),
							this.renderer.gl.scissor(a, o, h, u);
					}
					this.renderer.framebuffer.clear(t[0], t[1], t[2], t[3], e),
						s && this.renderer.scissor.pop();
				}),
				(t.prototype.resize = function () {
					this.bind(null);
				}),
				(t.prototype.reset = function () {
					this.bind(null);
				}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})();
	function uboUpdate$3(t, e, i, r, s) {
		i.buffer.update(s);
	}
	var UBO_TO_SINGLE_SETTERS$3 = {
			float: '\n        data[offset] = v;\n    ',
			vec2: '\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    ',
			vec3: '\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    ',
			vec4: '\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    ',
			mat2: '\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    ',
			mat3: '\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    ',
			mat4: '\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    ',
		},
		GLSL_TO_STD40_SIZE$3 = {
			float: 4,
			vec2: 8,
			vec3: 12,
			vec4: 16,
			int: 4,
			ivec2: 8,
			ivec3: 12,
			ivec4: 16,
			uint: 4,
			uvec2: 8,
			uvec3: 12,
			uvec4: 16,
			bool: 4,
			bvec2: 8,
			bvec3: 12,
			bvec4: 16,
			mat2: 32,
			mat3: 48,
			mat4: 64,
		};
	function createUBOElements$3(t) {
		for (
			var e = t.map(function (t) {
					return { data: t, offset: 0, dataLen: 0, dirty: 0 };
				}),
				i = 0,
				r = 0,
				s = 0,
				n = 0;
			n < e.length;
			n++
		) {
			var a = e[n];
			if (
				((i = GLSL_TO_STD40_SIZE$3[a.data.type]),
				a.data.size > 1 && (i = Math.max(i, 16) * a.data.size),
				(a.dataLen = i),
				r % i != 0 && r < 16)
			) {
				var o = (r % i) % 16;
				(r += o), (s += o);
			}
			r + i > 16
				? ((s = 16 * Math.ceil(s / 16)), (a.offset = s), (s += i), (r = i))
				: ((a.offset = s), (r += i), (s += i));
		}
		return { uboElements: e, size: (s = 16 * Math.ceil(s / 16)) };
	}
	function getUBOData$3(t, e) {
		var i = [];
		for (var r in t) e[r] && i.push(e[r]);
		return (
			i.sort(function (t, e) {
				return t.index - e.index;
			}),
			i
		);
	}
	function generateUniformBufferSync$3(t, e) {
		if (!t.autoManage) return { size: 0, syncFunc: uboUpdate$3 };
		for (
			var i = createUBOElements$3(getUBOData$3(t.uniforms, e)),
				r = i.uboElements,
				s = i.size,
				n = [
					'\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    ',
				],
				a = 0;
			a < r.length;
			a++
		) {
			for (
				var o = r[a],
					h = t.uniforms[o.data.name],
					u = o.data.name,
					l = !1,
					c = 0;
				c < uniformParsers$3.length;
				c++
			) {
				var d = uniformParsers$3[c];
				if (d.codeUbo && d.test(o.data, h)) {
					n.push(
						'offset = ' + o.offset / 4 + ';',
						uniformParsers$3[c].codeUbo(o.data.name, h)
					),
						(l = !0);
					break;
				}
			}
			if (!l)
				if (o.data.size > 1) {
					var p = mapSize$3(o.data.type),
						f = Math.max(GLSL_TO_STD40_SIZE$3[o.data.type] / 16, 1),
						m = p / f,
						_ = (4 - (m % 4)) % 4;
					n.push(
						'\n                cv = ud.' +
							u +
							'.value;\n                v = uv.' +
							u +
							';\n                offset = ' +
							o.offset / 4 +
							';\n\n                t = 0;\n\n                for(var i=0; i < ' +
							o.data.size * f +
							'; i++)\n                {\n                    for(var j = 0; j < ' +
							m +
							'; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += ' +
							_ +
							';\n                }\n\n                '
					);
				} else {
					var g = UBO_TO_SINGLE_SETTERS$3[o.data.type];
					n.push(
						'\n                cv = ud.' +
							u +
							'.value;\n                v = uv.' +
							u +
							';\n                offset = ' +
							o.offset / 4 +
							';\n                ' +
							g +
							';\n                '
					);
				}
		}
		return (
			n.push('\n       renderer.buffer.update(buffer);\n    '),
			{
				size: s,
				syncFunc: new Function(
					'ud',
					'uv',
					'renderer',
					'syncData',
					'buffer',
					n.join('\n')
				),
			}
		);
	}
	var IGLUniformData = function () {},
		GLProgram$3 = (function () {
			function t(t, e) {
				(this.program = t),
					(this.uniformData = e),
					(this.uniformGroups = {}),
					(this.uniformDirtyGroups = {}),
					(this.uniformBufferBindings = {});
			}
			return (
				(t.prototype.destroy = function () {
					(this.uniformData = null),
						(this.uniformGroups = null),
						(this.uniformDirtyGroups = null),
						(this.uniformBufferBindings = null),
						(this.program = null);
				}),
				t
			);
		})();
	function getAttributeData$3(t, e) {
		for (
			var i = {}, r = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES), s = 0;
			s < r;
			s++
		) {
			var n = e.getActiveAttrib(t, s);
			if (0 !== n.name.indexOf('gl_')) {
				var a = mapType$3(e, n.type),
					o = {
						type: a,
						name: n.name,
						size: mapSize$3(a),
						location: e.getAttribLocation(t, n.name),
					};
				i[n.name] = o;
			}
		}
		return i;
	}
	function getUniformData$3(t, e) {
		for (
			var i = {}, r = e.getProgramParameter(t, e.ACTIVE_UNIFORMS), s = 0;
			s < r;
			s++
		) {
			var n = e.getActiveUniform(t, s),
				a = n.name.replace(/\[.*?\]$/, ''),
				o = !!n.name.match(/\[.*?\]$/),
				h = mapType$3(e, n.type);
			i[a] = {
				name: a,
				index: s,
				type: h,
				size: n.size,
				isArray: o,
				value: defaultValue$3(h, n.size),
			};
		}
		return i;
	}
	function generateProgram$3(t, e) {
		var i = compileShader$3(t, t.VERTEX_SHADER, e.vertexSrc),
			r = compileShader$3(t, t.FRAGMENT_SHADER, e.fragmentSrc),
			s = t.createProgram();
		if (
			(t.attachShader(s, i),
			t.attachShader(s, r),
			t.linkProgram(s),
			t.getProgramParameter(s, t.LINK_STATUS) || logProgramError$3(t, s, i, r),
			(e.attributeData = getAttributeData$3(s, t)),
			(e.uniformData = getUniformData$3(s, t)),
			!/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e.vertexSrc))
		) {
			var n = Object.keys(e.attributeData);
			n.sort(function (t, e) {
				return t > e ? 1 : -1;
			});
			for (var a = 0; a < n.length; a++)
				(e.attributeData[n[a]].location = a), t.bindAttribLocation(s, a, n[a]);
			t.linkProgram(s);
		}
		t.deleteShader(i), t.deleteShader(r);
		var o = {};
		for (var a in e.uniformData) {
			var h = e.uniformData[a];
			o[a] = {
				location: t.getUniformLocation(s, a),
				value: defaultValue$3(h.type, h.size),
			};
		}
		return new GLProgram$3(s, o);
	}
	var UID$7 = 0,
		defaultSyncData$3 = { textureCount: 0, uboCount: 0 },
		ShaderSystem$3 = (function () {
			function t(t) {
				(this.destroyed = !1),
					(this.renderer = t),
					this.systemCheck(),
					(this.gl = null),
					(this.shader = null),
					(this.program = null),
					(this.cache = {}),
					(this._uboCache = {}),
					(this.id = UID$7++);
			}
			return (
				(t.prototype.systemCheck = function () {
					if (!unsafeEvalSupported$3())
						throw new Error(
							'Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.'
						);
				}),
				(t.prototype.contextChange = function (t) {
					(this.gl = t), this.reset();
				}),
				(t.prototype.bind = function (t, e) {
					t.uniforms.globals = this.renderer.globalUniforms;
					var i = t.program,
						r =
							i.glPrograms[this.renderer.CONTEXT_UID] ||
							this.generateProgram(t);
					return (
						(this.shader = t),
						this.program !== i &&
							((this.program = i), this.gl.useProgram(r.program)),
						e ||
							((defaultSyncData$3.textureCount = 0),
							(defaultSyncData$3.uboCount = 0),
							this.syncUniformGroup(t.uniformGroup, defaultSyncData$3)),
						r
					);
				}),
				(t.prototype.setUniforms = function (t) {
					var e = this.shader.program,
						i = e.glPrograms[this.renderer.CONTEXT_UID];
					e.syncUniforms(i.uniformData, t, this.renderer);
				}),
				(t.prototype.syncUniformGroup = function (t, e) {
					var i = this.getGlProgram();
					(t.static && t.dirtyId === i.uniformDirtyGroups[t.id]) ||
						((i.uniformDirtyGroups[t.id] = t.dirtyId),
						this.syncUniforms(t, i, e));
				}),
				(t.prototype.syncUniforms = function (t, e, i) {
					(t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t))(
						e.uniformData,
						t.uniforms,
						this.renderer,
						i
					);
				}),
				(t.prototype.createSyncGroups = function (t) {
					var e = this.getSignature(t, this.shader.program.uniformData, 'u');
					return (
						this.cache[e] ||
							(this.cache[e] = generateUniformsSync$3(
								t,
								this.shader.program.uniformData
							)),
						(t.syncUniforms[this.shader.program.id] = this.cache[e]),
						t.syncUniforms[this.shader.program.id]
					);
				}),
				(t.prototype.syncUniformBufferGroup = function (t, e) {
					var i = this.getGlProgram();
					if (!t.static || 0 !== t.dirtyId || !i.uniformGroups[t.id]) {
						t.dirtyId = 0;
						var r =
							i.uniformGroups[t.id] || this.createSyncBufferGroup(t, i, e);
						t.buffer.update(),
							r(
								i.uniformData,
								t.uniforms,
								this.renderer,
								defaultSyncData$3,
								t.buffer
							);
					}
					this.renderer.buffer.bindBufferBase(
						t.buffer,
						i.uniformBufferBindings[e]
					);
				}),
				(t.prototype.createSyncBufferGroup = function (t, e, i) {
					var r = this.renderer.gl;
					this.renderer.buffer.bind(t.buffer);
					var s = this.gl.getUniformBlockIndex(e.program, i);
					(e.uniformBufferBindings[i] = this.shader.uniformBindCount),
						r.uniformBlockBinding(e.program, s, this.shader.uniformBindCount),
						this.shader.uniformBindCount++;
					var n = this.getSignature(t, this.shader.program.uniformData, 'ubo'),
						a = this._uboCache[n];
					if (
						(a ||
							(a = this._uboCache[n] =
								generateUniformBufferSync$3(
									t,
									this.shader.program.uniformData
								)),
						t.autoManage)
					) {
						var o = new Float32Array(a.size / 4);
						t.buffer.update(o);
					}
					return (e.uniformGroups[t.id] = a.syncFunc), e.uniformGroups[t.id];
				}),
				(t.prototype.getSignature = function (t, e, i) {
					var r = t.uniforms,
						s = [i + '-'];
					for (var n in r) s.push(n), e[n] && s.push(e[n].type);
					return s.join('-');
				}),
				(t.prototype.getGlProgram = function () {
					return this.shader
						? this.shader.program.glPrograms[this.renderer.CONTEXT_UID]
						: null;
				}),
				(t.prototype.generateProgram = function (t) {
					var e = this.gl,
						i = t.program,
						r = generateProgram$3(e, i);
					return (i.glPrograms[this.renderer.CONTEXT_UID] = r), r;
				}),
				(t.prototype.reset = function () {
					(this.program = null), (this.shader = null);
				}),
				(t.prototype.destroy = function () {
					(this.renderer = null), (this.destroyed = !0);
				}),
				t
			);
		})();
	function mapWebGLBlendModesToPixi$3(t, e) {
		return (
			void 0 === e && (e = []),
			(e[BLEND_MODES$9.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.ADD] = [t.ONE, t.ONE]),
			(e[BLEND_MODES$9.MULTIPLY] = [
				t.DST_COLOR,
				t.ONE_MINUS_SRC_ALPHA,
				t.ONE,
				t.ONE_MINUS_SRC_ALPHA,
			]),
			(e[BLEND_MODES$9.SCREEN] = [
				t.ONE,
				t.ONE_MINUS_SRC_COLOR,
				t.ONE,
				t.ONE_MINUS_SRC_ALPHA,
			]),
			(e[BLEND_MODES$9.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.NONE] = [0, 0]),
			(e[BLEND_MODES$9.NORMAL_NPM] = [
				t.SRC_ALPHA,
				t.ONE_MINUS_SRC_ALPHA,
				t.ONE,
				t.ONE_MINUS_SRC_ALPHA,
			]),
			(e[BLEND_MODES$9.ADD_NPM] = [t.SRC_ALPHA, t.ONE, t.ONE, t.ONE]),
			(e[BLEND_MODES$9.SCREEN_NPM] = [
				t.SRC_ALPHA,
				t.ONE_MINUS_SRC_COLOR,
				t.ONE,
				t.ONE_MINUS_SRC_ALPHA,
			]),
			(e[BLEND_MODES$9.SRC_IN] = [t.DST_ALPHA, t.ZERO]),
			(e[BLEND_MODES$9.SRC_OUT] = [t.ONE_MINUS_DST_ALPHA, t.ZERO]),
			(e[BLEND_MODES$9.SRC_ATOP] = [t.DST_ALPHA, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.DST_OVER] = [t.ONE_MINUS_DST_ALPHA, t.ONE]),
			(e[BLEND_MODES$9.DST_IN] = [t.ZERO, t.SRC_ALPHA]),
			(e[BLEND_MODES$9.DST_OUT] = [t.ZERO, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.DST_ATOP] = [t.ONE_MINUS_DST_ALPHA, t.SRC_ALPHA]),
			(e[BLEND_MODES$9.XOR] = [t.ONE_MINUS_DST_ALPHA, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.SUBTRACT] = [
				t.ONE,
				t.ONE,
				t.ONE,
				t.ONE,
				t.FUNC_REVERSE_SUBTRACT,
				t.FUNC_ADD,
			]),
			e
		);
	}
	var BLEND$4 = 0,
		OFFSET$4 = 1,
		CULLING$4 = 2,
		DEPTH_TEST$4 = 3,
		WINDING$4 = 4,
		DEPTH_MASK$4 = 5,
		StateSystem$3 = (function () {
			function t() {
				(this.gl = null),
					(this.stateId = 0),
					(this.polygonOffset = 0),
					(this.blendMode = BLEND_MODES$9.NONE),
					(this._blendEq = !1),
					(this.map = []),
					(this.map[BLEND$4] = this.setBlend),
					(this.map[OFFSET$4] = this.setOffset),
					(this.map[CULLING$4] = this.setCullFace),
					(this.map[DEPTH_TEST$4] = this.setDepthTest),
					(this.map[WINDING$4] = this.setFrontFace),
					(this.map[DEPTH_MASK$4] = this.setDepthMask),
					(this.checks = []),
					(this.defaultState = new State$3()),
					(this.defaultState.blend = !0);
			}
			return (
				(t.prototype.contextChange = function (t) {
					(this.gl = t),
						(this.blendModes = mapWebGLBlendModesToPixi$3(t)),
						this.set(this.defaultState),
						this.reset();
				}),
				(t.prototype.set = function (t) {
					if (((t = t || this.defaultState), this.stateId !== t.data)) {
						for (var e = this.stateId ^ t.data, i = 0; e; )
							1 & e && this.map[i].call(this, !!(t.data & (1 << i))),
								(e >>= 1),
								i++;
						this.stateId = t.data;
					}
					for (i = 0; i < this.checks.length; i++) this.checks[i](this, t);
				}),
				(t.prototype.forceState = function (t) {
					t = t || this.defaultState;
					for (var e = 0; e < this.map.length; e++)
						this.map[e].call(this, !!(t.data & (1 << e)));
					for (e = 0; e < this.checks.length; e++) this.checks[e](this, t);
					this.stateId = t.data;
				}),
				(t.prototype.setBlend = function (e) {
					this.updateCheck(t.checkBlendMode, e),
						this.gl[e ? 'enable' : 'disable'](this.gl.BLEND);
				}),
				(t.prototype.setOffset = function (e) {
					this.updateCheck(t.checkPolygonOffset, e),
						this.gl[e ? 'enable' : 'disable'](this.gl.POLYGON_OFFSET_FILL);
				}),
				(t.prototype.setDepthTest = function (t) {
					this.gl[t ? 'enable' : 'disable'](this.gl.DEPTH_TEST);
				}),
				(t.prototype.setDepthMask = function (t) {
					this.gl.depthMask(t);
				}),
				(t.prototype.setCullFace = function (t) {
					this.gl[t ? 'enable' : 'disable'](this.gl.CULL_FACE);
				}),
				(t.prototype.setFrontFace = function (t) {
					this.gl.frontFace(this.gl[t ? 'CW' : 'CCW']);
				}),
				(t.prototype.setBlendMode = function (t) {
					if (t !== this.blendMode) {
						this.blendMode = t;
						var e = this.blendModes[t],
							i = this.gl;
						2 === e.length
							? i.blendFunc(e[0], e[1])
							: i.blendFuncSeparate(e[0], e[1], e[2], e[3]),
							6 === e.length
								? ((this._blendEq = !0), i.blendEquationSeparate(e[4], e[5]))
								: this._blendEq &&
								  ((this._blendEq = !1),
								  i.blendEquationSeparate(i.FUNC_ADD, i.FUNC_ADD));
					}
				}),
				(t.prototype.setPolygonOffset = function (t, e) {
					this.gl.polygonOffset(t, e);
				}),
				(t.prototype.reset = function () {
					this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1),
						this.forceState(this.defaultState),
						(this._blendEq = !0),
						(this.blendMode = -1),
						this.setBlendMode(0);
				}),
				(t.prototype.updateCheck = function (t, e) {
					var i = this.checks.indexOf(t);
					e && -1 === i
						? this.checks.push(t)
						: e || -1 === i || this.checks.splice(i, 1);
				}),
				(t.checkBlendMode = function (t, e) {
					t.setBlendMode(e.blendMode);
				}),
				(t.checkPolygonOffset = function (t, e) {
					t.setPolygonOffset(1, e.polygonOffset);
				}),
				(t.prototype.destroy = function () {
					this.gl = null;
				}),
				t
			);
		})(),
		TextureGCSystem$3 = (function () {
			function t(t) {
				(this.renderer = t),
					(this.count = 0),
					(this.checkCount = 0),
					(this.maxIdle = settings$4.GC_MAX_IDLE),
					(this.checkCountMax = settings$4.GC_MAX_CHECK_COUNT),
					(this.mode = settings$4.GC_MODE);
			}
			return (
				(t.prototype.postrender = function () {
					this.renderer.renderingToScreen &&
						(this.count++,
						this.mode !== GC_MODES$9.MANUAL &&
							(this.checkCount++,
							this.checkCount > this.checkCountMax &&
								((this.checkCount = 0), this.run())));
				}),
				(t.prototype.run = function () {
					for (
						var t = this.renderer.texture, e = t.managedTextures, i = !1, r = 0;
						r < e.length;
						r++
					) {
						var s = e[r];
						!s.framebuffer &&
							this.count - s.touched > this.maxIdle &&
							(t.destroyTexture(s, !0), (e[r] = null), (i = !0));
					}
					if (i) {
						var n = 0;
						for (r = 0; r < e.length; r++) null !== e[r] && (e[n++] = e[r]);
						e.length = n;
					}
				}),
				(t.prototype.unload = function (t) {
					var e = this.renderer.texture,
						i = t._texture;
					i && !i.framebuffer && e.destroyTexture(i);
					for (var r = t.children.length - 1; r >= 0; r--)
						this.unload(t.children[r]);
				}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})();
	function mapTypeAndFormatToInternalFormat$3(t) {
		var e, i, r, s, n, a, o, h, u, l, c, d, p, f, m, _, g, E, y, T, v, S, x;
		return (
			'WebGL2RenderingContext' in globalThis &&
			t instanceof globalThis.WebGL2RenderingContext
				? (((e = {})[TYPES$9.UNSIGNED_BYTE] =
						(((i = {})[FORMATS$9.RGBA] = t.RGBA8),
						(i[FORMATS$9.RGB] = t.RGB8),
						(i[FORMATS$9.RG] = t.RG8),
						(i[FORMATS$9.RED] = t.R8),
						(i[FORMATS$9.RGBA_INTEGER] = t.RGBA8UI),
						(i[FORMATS$9.RGB_INTEGER] = t.RGB8UI),
						(i[FORMATS$9.RG_INTEGER] = t.RG8UI),
						(i[FORMATS$9.RED_INTEGER] = t.R8UI),
						(i[FORMATS$9.ALPHA] = t.ALPHA),
						(i[FORMATS$9.LUMINANCE] = t.LUMINANCE),
						(i[FORMATS$9.LUMINANCE_ALPHA] = t.LUMINANCE_ALPHA),
						i)),
				  (e[TYPES$9.BYTE] =
						(((r = {})[FORMATS$9.RGBA] = t.RGBA8_SNORM),
						(r[FORMATS$9.RGB] = t.RGB8_SNORM),
						(r[FORMATS$9.RG] = t.RG8_SNORM),
						(r[FORMATS$9.RED] = t.R8_SNORM),
						(r[FORMATS$9.RGBA_INTEGER] = t.RGBA8I),
						(r[FORMATS$9.RGB_INTEGER] = t.RGB8I),
						(r[FORMATS$9.RG_INTEGER] = t.RG8I),
						(r[FORMATS$9.RED_INTEGER] = t.R8I),
						r)),
				  (e[TYPES$9.UNSIGNED_SHORT] =
						(((s = {})[FORMATS$9.RGBA_INTEGER] = t.RGBA16UI),
						(s[FORMATS$9.RGB_INTEGER] = t.RGB16UI),
						(s[FORMATS$9.RG_INTEGER] = t.RG16UI),
						(s[FORMATS$9.RED_INTEGER] = t.R16UI),
						(s[FORMATS$9.DEPTH_COMPONENT] = t.DEPTH_COMPONENT16),
						s)),
				  (e[TYPES$9.SHORT] =
						(((n = {})[FORMATS$9.RGBA_INTEGER] = t.RGBA16I),
						(n[FORMATS$9.RGB_INTEGER] = t.RGB16I),
						(n[FORMATS$9.RG_INTEGER] = t.RG16I),
						(n[FORMATS$9.RED_INTEGER] = t.R16I),
						n)),
				  (e[TYPES$9.UNSIGNED_INT] =
						(((a = {})[FORMATS$9.RGBA_INTEGER] = t.RGBA32UI),
						(a[FORMATS$9.RGB_INTEGER] = t.RGB32UI),
						(a[FORMATS$9.RG_INTEGER] = t.RG32UI),
						(a[FORMATS$9.RED_INTEGER] = t.R32UI),
						(a[FORMATS$9.DEPTH_COMPONENT] = t.DEPTH_COMPONENT24),
						a)),
				  (e[TYPES$9.INT] =
						(((o = {})[FORMATS$9.RGBA_INTEGER] = t.RGBA32I),
						(o[FORMATS$9.RGB_INTEGER] = t.RGB32I),
						(o[FORMATS$9.RG_INTEGER] = t.RG32I),
						(o[FORMATS$9.RED_INTEGER] = t.R32I),
						o)),
				  (e[TYPES$9.FLOAT] =
						(((h = {})[FORMATS$9.RGBA] = t.RGBA32F),
						(h[FORMATS$9.RGB] = t.RGB32F),
						(h[FORMATS$9.RG] = t.RG32F),
						(h[FORMATS$9.RED] = t.R32F),
						(h[FORMATS$9.DEPTH_COMPONENT] = t.DEPTH_COMPONENT32F),
						h)),
				  (e[TYPES$9.HALF_FLOAT] =
						(((u = {})[FORMATS$9.RGBA] = t.RGBA16F),
						(u[FORMATS$9.RGB] = t.RGB16F),
						(u[FORMATS$9.RG] = t.RG16F),
						(u[FORMATS$9.RED] = t.R16F),
						u)),
				  (e[TYPES$9.UNSIGNED_SHORT_5_6_5] =
						(((l = {})[FORMATS$9.RGB] = t.RGB565), l)),
				  (e[TYPES$9.UNSIGNED_SHORT_4_4_4_4] =
						(((c = {})[FORMATS$9.RGBA] = t.RGBA4), c)),
				  (e[TYPES$9.UNSIGNED_SHORT_5_5_5_1] =
						(((d = {})[FORMATS$9.RGBA] = t.RGB5_A1), d)),
				  (e[TYPES$9.UNSIGNED_INT_2_10_10_10_REV] =
						(((p = {})[FORMATS$9.RGBA] = t.RGB10_A2),
						(p[FORMATS$9.RGBA_INTEGER] = t.RGB10_A2UI),
						p)),
				  (e[TYPES$9.UNSIGNED_INT_10F_11F_11F_REV] =
						(((f = {})[FORMATS$9.RGB] = t.R11F_G11F_B10F), f)),
				  (e[TYPES$9.UNSIGNED_INT_5_9_9_9_REV] =
						(((m = {})[FORMATS$9.RGB] = t.RGB9_E5), m)),
				  (e[TYPES$9.UNSIGNED_INT_24_8] =
						(((_ = {})[FORMATS$9.DEPTH_STENCIL] = t.DEPTH24_STENCIL8), _)),
				  (e[TYPES$9.FLOAT_32_UNSIGNED_INT_24_8_REV] =
						(((g = {})[FORMATS$9.DEPTH_STENCIL] = t.DEPTH32F_STENCIL8), g)),
				  (x = e))
				: (((E = {})[TYPES$9.UNSIGNED_BYTE] =
						(((y = {})[FORMATS$9.RGBA] = t.RGBA),
						(y[FORMATS$9.RGB] = t.RGB),
						(y[FORMATS$9.ALPHA] = t.ALPHA),
						(y[FORMATS$9.LUMINANCE] = t.LUMINANCE),
						(y[FORMATS$9.LUMINANCE_ALPHA] = t.LUMINANCE_ALPHA),
						y)),
				  (E[TYPES$9.UNSIGNED_SHORT_5_6_5] =
						(((T = {})[FORMATS$9.RGB] = t.RGB), T)),
				  (E[TYPES$9.UNSIGNED_SHORT_4_4_4_4] =
						(((v = {})[FORMATS$9.RGBA] = t.RGBA), v)),
				  (E[TYPES$9.UNSIGNED_SHORT_5_5_5_1] =
						(((S = {})[FORMATS$9.RGBA] = t.RGBA), S)),
				  (x = E)),
			x
		);
	}
	var GLTexture$3 = function (t) {
			(this.texture = t),
				(this.width = -1),
				(this.height = -1),
				(this.dirtyId = -1),
				(this.dirtyStyleId = -1),
				(this.mipmap = !1),
				(this.wrapMode = 33071),
				(this.type = TYPES$9.UNSIGNED_BYTE),
				(this.internalFormat = FORMATS$9.RGBA),
				(this.samplerType = 0);
		},
		TextureSystem$3 = (function () {
			function t(t) {
				(this.renderer = t),
					(this.boundTextures = []),
					(this.currentLocation = -1),
					(this.managedTextures = []),
					(this._unknownBoundTextures = !1),
					(this.unknownTexture = new BaseTexture$3()),
					(this.hasIntegerTextures = !1);
			}
			return (
				(t.prototype.contextChange = function () {
					var t = (this.gl = this.renderer.gl);
					(this.CONTEXT_UID = this.renderer.CONTEXT_UID),
						(this.webGLVersion = this.renderer.context.webGLVersion),
						(this.internalFormats = mapTypeAndFormatToInternalFormat$3(t));
					var e = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
					this.boundTextures.length = e;
					for (var i = 0; i < e; i++) this.boundTextures[i] = null;
					this.emptyTextures = {};
					var r = new GLTexture$3(t.createTexture());
					for (
						t.bindTexture(t.TEXTURE_2D, r.texture),
							t.texImage2D(
								t.TEXTURE_2D,
								0,
								t.RGBA,
								1,
								1,
								0,
								t.RGBA,
								t.UNSIGNED_BYTE,
								new Uint8Array(4)
							),
							this.emptyTextures[t.TEXTURE_2D] = r,
							this.emptyTextures[t.TEXTURE_CUBE_MAP] = new GLTexture$3(
								t.createTexture()
							),
							t.bindTexture(
								t.TEXTURE_CUBE_MAP,
								this.emptyTextures[t.TEXTURE_CUBE_MAP].texture
							),
							i = 0;
						i < 6;
						i++
					)
						t.texImage2D(
							t.TEXTURE_CUBE_MAP_POSITIVE_X + i,
							0,
							t.RGBA,
							1,
							1,
							0,
							t.RGBA,
							t.UNSIGNED_BYTE,
							null
						);
					for (
						t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR),
							t.texParameteri(
								t.TEXTURE_CUBE_MAP,
								t.TEXTURE_MIN_FILTER,
								t.LINEAR
							),
							i = 0;
						i < this.boundTextures.length;
						i++
					)
						this.bind(null, i);
				}),
				(t.prototype.bind = function (t, e) {
					void 0 === e && (e = 0);
					var i = this.gl;
					if (
						(t = null == t ? void 0 : t.castToBaseTexture()) &&
						t.valid &&
						!t.parentTextureArray
					) {
						t.touched = this.renderer.textureGC.count;
						var r = t._glTextures[this.CONTEXT_UID] || this.initTexture(t);
						this.boundTextures[e] !== t &&
							(this.currentLocation !== e &&
								((this.currentLocation = e), i.activeTexture(i.TEXTURE0 + e)),
							i.bindTexture(t.target, r.texture)),
							r.dirtyId !== t.dirtyId &&
								(this.currentLocation !== e &&
									((this.currentLocation = e), i.activeTexture(i.TEXTURE0 + e)),
								this.updateTexture(t)),
							(this.boundTextures[e] = t);
					} else
						this.currentLocation !== e &&
							((this.currentLocation = e), i.activeTexture(i.TEXTURE0 + e)),
							i.bindTexture(
								i.TEXTURE_2D,
								this.emptyTextures[i.TEXTURE_2D].texture
							),
							(this.boundTextures[e] = null);
				}),
				(t.prototype.reset = function () {
					(this._unknownBoundTextures = !0),
						(this.hasIntegerTextures = !1),
						(this.currentLocation = -1);
					for (var t = 0; t < this.boundTextures.length; t++)
						this.boundTextures[t] = this.unknownTexture;
				}),
				(t.prototype.unbind = function (t) {
					var e = this.gl,
						i = this.boundTextures;
					if (this._unknownBoundTextures) {
						this._unknownBoundTextures = !1;
						for (var r = 0; r < i.length; r++)
							i[r] === this.unknownTexture && this.bind(null, r);
					}
					for (r = 0; r < i.length; r++)
						i[r] === t &&
							(this.currentLocation !== r &&
								(e.activeTexture(e.TEXTURE0 + r), (this.currentLocation = r)),
							e.bindTexture(t.target, this.emptyTextures[t.target].texture),
							(i[r] = null));
				}),
				(t.prototype.ensureSamplerType = function (t) {
					var e = this,
						i = e.boundTextures,
						r = e.hasIntegerTextures,
						s = e.CONTEXT_UID;
					if (r)
						for (var n = t - 1; n >= 0; --n) {
							var a = i[n];
							a &&
								a._glTextures[s].samplerType !== SAMPLER_TYPES$9.FLOAT &&
								this.renderer.texture.unbind(a);
						}
				}),
				(t.prototype.initTexture = function (t) {
					var e = new GLTexture$3(this.gl.createTexture());
					return (
						(e.dirtyId = -1),
						(t._glTextures[this.CONTEXT_UID] = e),
						this.managedTextures.push(t),
						t.on('dispose', this.destroyTexture, this),
						e
					);
				}),
				(t.prototype.initTextureType = function (t, e) {
					var i, r;
					(e.internalFormat =
						null !==
							(r =
								null === (i = this.internalFormats[t.type]) || void 0 === i
									? void 0
									: i[t.format]) && void 0 !== r
							? r
							: t.format),
						2 === this.webGLVersion && t.type === TYPES$9.HALF_FLOAT
							? (e.type = this.gl.HALF_FLOAT)
							: (e.type = t.type);
				}),
				(t.prototype.updateTexture = function (t) {
					var e = t._glTextures[this.CONTEXT_UID];
					if (e) {
						var i = this.renderer;
						if (
							(this.initTextureType(t, e),
							t.resource && t.resource.upload(i, t, e))
						)
							e.samplerType !== SAMPLER_TYPES$9.FLOAT &&
								(this.hasIntegerTextures = !0);
						else {
							var r = t.realWidth,
								s = t.realHeight,
								n = i.gl;
							(e.width !== r || e.height !== s || e.dirtyId < 0) &&
								((e.width = r),
								(e.height = s),
								n.texImage2D(
									t.target,
									0,
									e.internalFormat,
									r,
									s,
									0,
									t.format,
									e.type,
									null
								));
						}
						t.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(t),
							(e.dirtyId = t.dirtyId);
					}
				}),
				(t.prototype.destroyTexture = function (t, e) {
					var i = this.gl;
					if (
						(t = t.castToBaseTexture())._glTextures[this.CONTEXT_UID] &&
						(this.unbind(t),
						i.deleteTexture(t._glTextures[this.CONTEXT_UID].texture),
						t.off('dispose', this.destroyTexture, this),
						delete t._glTextures[this.CONTEXT_UID],
						!e)
					) {
						var r = this.managedTextures.indexOf(t);
						-1 !== r && removeItems$3(this.managedTextures, r, 1);
					}
				}),
				(t.prototype.updateTextureStyle = function (t) {
					var e = t._glTextures[this.CONTEXT_UID];
					e &&
						((t.mipmap !== MIPMAP_MODES$9.POW2 && 2 === this.webGLVersion) ||
						t.isPowerOfTwo
							? (e.mipmap = t.mipmap >= 1)
							: (e.mipmap = !1),
						2 === this.webGLVersion || t.isPowerOfTwo
							? (e.wrapMode = t.wrapMode)
							: (e.wrapMode = WRAP_MODES$9.CLAMP),
						(t.resource && t.resource.style(this.renderer, t, e)) ||
							this.setStyle(t, e),
						(e.dirtyStyleId = t.dirtyStyleId));
				}),
				(t.prototype.setStyle = function (t, e) {
					var i = this.gl;
					if (
						(e.mipmap &&
							t.mipmap !== MIPMAP_MODES$9.ON_MANUAL &&
							i.generateMipmap(t.target),
						i.texParameteri(t.target, i.TEXTURE_WRAP_S, e.wrapMode),
						i.texParameteri(t.target, i.TEXTURE_WRAP_T, e.wrapMode),
						e.mipmap)
					) {
						i.texParameteri(
							t.target,
							i.TEXTURE_MIN_FILTER,
							t.scaleMode === SCALE_MODES$9.LINEAR
								? i.LINEAR_MIPMAP_LINEAR
								: i.NEAREST_MIPMAP_NEAREST
						);
						var r = this.renderer.context.extensions.anisotropicFiltering;
						if (
							r &&
							t.anisotropicLevel > 0 &&
							t.scaleMode === SCALE_MODES$9.LINEAR
						) {
							var s = Math.min(
								t.anisotropicLevel,
								i.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
							);
							i.texParameterf(t.target, r.TEXTURE_MAX_ANISOTROPY_EXT, s);
						}
					} else
						i.texParameteri(
							t.target,
							i.TEXTURE_MIN_FILTER,
							t.scaleMode === SCALE_MODES$9.LINEAR ? i.LINEAR : i.NEAREST
						);
					i.texParameteri(
						t.target,
						i.TEXTURE_MAG_FILTER,
						t.scaleMode === SCALE_MODES$9.LINEAR ? i.LINEAR : i.NEAREST
					);
				}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})(),
		_systems = {
			__proto__: null,
			FilterSystem: FilterSystem$3,
			BatchSystem: BatchSystem$3,
			ContextSystem: ContextSystem$3,
			FramebufferSystem: FramebufferSystem$3,
			GeometrySystem: GeometrySystem$3,
			MaskSystem: MaskSystem$3,
			ScissorSystem: ScissorSystem$3,
			StencilSystem: StencilSystem$3,
			ProjectionSystem: ProjectionSystem$3,
			RenderTextureSystem: RenderTextureSystem$3,
			ShaderSystem: ShaderSystem$3,
			StateSystem: StateSystem$3,
			TextureGCSystem: TextureGCSystem$3,
			TextureSystem: TextureSystem$3,
		},
		tempMatrix$7 = new Matrix$3(),
		AbstractRenderer$3 = (function (t) {
			function e(e, i) {
				void 0 === e && (e = RENDERER_TYPE$9.UNKNOWN);
				var r = t.call(this) || this;
				return (
					(i = Object.assign({}, settings$4.RENDER_OPTIONS, i)),
					(r.options = i),
					(r.type = e),
					(r.screen = new Rectangle$4(0, 0, i.width, i.height)),
					(r.view = i.view || document.createElement('canvas')),
					(r.resolution = i.resolution || settings$4.RESOLUTION),
					(r.useContextAlpha = i.useContextAlpha),
					(r.autoDensity = !!i.autoDensity),
					(r.preserveDrawingBuffer = i.preserveDrawingBuffer),
					(r.clearBeforeRender = i.clearBeforeRender),
					(r._backgroundColor = 0),
					(r._backgroundColorRgba = [0, 0, 0, 1]),
					(r._backgroundColorString = '#000000'),
					(r.backgroundColor = i.backgroundColor || r._backgroundColor),
					(r.backgroundAlpha = i.backgroundAlpha),
					void 0 !== i.transparent &&
						(deprecation$3(
							'6.0.0',
							'Option transparent is deprecated, please use backgroundAlpha instead.'
						),
						(r.useContextAlpha = i.transparent),
						(r.backgroundAlpha = i.transparent ? 0 : 1)),
					(r._lastObjectRendered = null),
					(r.plugins = {}),
					r
				);
			}
			return (
				__extends$n(e, t),
				(e.prototype.initPlugins = function (t) {
					for (var e in t) this.plugins[e] = new t[e](this);
				}),
				Object.defineProperty(e.prototype, 'width', {
					get: function () {
						return this.view.width;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'height', {
					get: function () {
						return this.view.height;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.resize = function (t, e) {
					(this.view.width = Math.round(t * this.resolution)),
						(this.view.height = Math.round(e * this.resolution));
					var i = this.view.width / this.resolution,
						r = this.view.height / this.resolution;
					(this.screen.width = i),
						(this.screen.height = r),
						this.autoDensity &&
							((this.view.style.width = i + 'px'),
							(this.view.style.height = r + 'px')),
						this.emit('resize', i, r);
				}),
				(e.prototype.generateTexture = function (t, e, i, r) {
					void 0 === e && (e = {}),
						'number' == typeof e &&
							(deprecation$3(
								'6.1.0',
								'generateTexture options (scaleMode, resolution, region) are now object options.'
							),
							(e = { scaleMode: e, resolution: i, region: r }));
					var s = e.region,
						n = __rest$3(e, ['region']);
					0 === (r = s || t.getLocalBounds(null, !0)).width && (r.width = 1),
						0 === r.height && (r.height = 1);
					var a = RenderTexture$3.create(
						__assign$3({ width: r.width, height: r.height }, n)
					);
					return (
						(tempMatrix$7.tx = -r.x),
						(tempMatrix$7.ty = -r.y),
						this.render(t, {
							renderTexture: a,
							clear: !1,
							transform: tempMatrix$7,
							skipUpdateTransform: !!t.parent,
						}),
						a
					);
				}),
				(e.prototype.destroy = function (t) {
					for (var e in this.plugins)
						this.plugins[e].destroy(), (this.plugins[e] = null);
					t &&
						this.view.parentNode &&
						this.view.parentNode.removeChild(this.view);
					var i = this;
					(i.plugins = null),
						(i.type = RENDERER_TYPE$9.UNKNOWN),
						(i.view = null),
						(i.screen = null),
						(i._tempDisplayObjectParent = null),
						(i.options = null),
						(this._backgroundColorRgba = null),
						(this._backgroundColorString = null),
						(this._lastObjectRendered = null);
				}),
				Object.defineProperty(e.prototype, 'backgroundColor', {
					get: function () {
						return this._backgroundColor;
					},
					set: function (t) {
						(this._backgroundColor = t),
							(this._backgroundColorString = hex2string$3(t)),
							hex2rgb$3(t, this._backgroundColorRgba);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'backgroundAlpha', {
					get: function () {
						return this._backgroundColorRgba[3];
					},
					set: function (t) {
						this._backgroundColorRgba[3] = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				e
			);
		})(eventemitter3$1),
		GLBuffer$3 = function (t) {
			(this.buffer = t || null),
				(this.updateID = -1),
				(this.byteLength = -1),
				(this.refCount = 0);
		},
		BufferSystem$3 = (function () {
			function t(t) {
				(this.renderer = t),
					(this.managedBuffers = {}),
					(this.boundBufferBases = {});
			}
			return (
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				(t.prototype.contextChange = function () {
					this.disposeAll(!0),
						(this.gl = this.renderer.gl),
						(this.CONTEXT_UID = this.renderer.CONTEXT_UID);
				}),
				(t.prototype.bind = function (t) {
					var e = this.gl,
						i = this.CONTEXT_UID,
						r = t._glBuffers[i] || this.createGLBuffer(t);
					e.bindBuffer(t.type, r.buffer);
				}),
				(t.prototype.bindBufferBase = function (t, e) {
					var i = this.gl,
						r = this.CONTEXT_UID;
					if (this.boundBufferBases[e] !== t) {
						var s = t._glBuffers[r] || this.createGLBuffer(t);
						(this.boundBufferBases[e] = t),
							i.bindBufferBase(i.UNIFORM_BUFFER, e, s.buffer);
					}
				}),
				(t.prototype.bindBufferRange = function (t, e, i) {
					var r = this.gl,
						s = this.CONTEXT_UID;
					i = i || 0;
					var n = t._glBuffers[s] || this.createGLBuffer(t);
					r.bindBufferRange(r.UNIFORM_BUFFER, e || 0, n.buffer, 256 * i, 256);
				}),
				(t.prototype.update = function (t) {
					var e = this.gl,
						i = this.CONTEXT_UID,
						r = t._glBuffers[i];
					if (t._updateID !== r.updateID)
						if (
							((r.updateID = t._updateID),
							e.bindBuffer(t.type, r.buffer),
							r.byteLength >= t.data.byteLength)
						)
							e.bufferSubData(t.type, 0, t.data);
						else {
							var s = t.static ? e.STATIC_DRAW : e.DYNAMIC_DRAW;
							(r.byteLength = t.data.byteLength),
								e.bufferData(t.type, t.data, s);
						}
				}),
				(t.prototype.dispose = function (t, e) {
					if (this.managedBuffers[t.id]) {
						delete this.managedBuffers[t.id];
						var i = t._glBuffers[this.CONTEXT_UID],
							r = this.gl;
						t.disposeRunner.remove(this),
							i &&
								(e || r.deleteBuffer(i.buffer),
								delete t._glBuffers[this.CONTEXT_UID]);
					}
				}),
				(t.prototype.disposeAll = function (t) {
					for (
						var e = Object.keys(this.managedBuffers), i = 0;
						i < e.length;
						i++
					)
						this.dispose(this.managedBuffers[e[i]], t);
				}),
				(t.prototype.createGLBuffer = function (t) {
					var e = this.CONTEXT_UID,
						i = this.gl;
					return (
						(t._glBuffers[e] = new GLBuffer$3(i.createBuffer())),
						(this.managedBuffers[t.id] = t),
						t.disposeRunner.add(this),
						t._glBuffers[e]
					);
				}),
				t
			);
		})(),
		Renderer$1 = (function (t) {
			function e(i) {
				var r = t.call(this, RENDERER_TYPE$9.WEBGL, i) || this;
				return (
					(i = r.options),
					(r.gl = null),
					(r.CONTEXT_UID = 0),
					(r.runners = {
						destroy: new Runner$3('destroy'),
						contextChange: new Runner$3('contextChange'),
						reset: new Runner$3('reset'),
						update: new Runner$3('update'),
						postrender: new Runner$3('postrender'),
						prerender: new Runner$3('prerender'),
						resize: new Runner$3('resize'),
					}),
					r.runners.contextChange.add(r),
					(r.globalUniforms = new UniformGroup$3(
						{ projectionMatrix: new Matrix$3() },
						!0
					)),
					r
						.addSystem(MaskSystem$3, 'mask')
						.addSystem(ContextSystem$3, 'context')
						.addSystem(StateSystem$3, 'state')
						.addSystem(ShaderSystem$3, 'shader')
						.addSystem(TextureSystem$3, 'texture')
						.addSystem(BufferSystem$3, 'buffer')
						.addSystem(GeometrySystem$3, 'geometry')
						.addSystem(FramebufferSystem$3, 'framebuffer')
						.addSystem(ScissorSystem$3, 'scissor')
						.addSystem(StencilSystem$3, 'stencil')
						.addSystem(ProjectionSystem$3, 'projection')
						.addSystem(TextureGCSystem$3, 'textureGC')
						.addSystem(FilterSystem$3, 'filter')
						.addSystem(RenderTextureSystem$3, 'renderTexture')
						.addSystem(BatchSystem$3, 'batch'),
					r.initPlugins(e.__plugins),
					(r.multisample = void 0),
					i.context
						? r.context.initFromContext(i.context)
						: r.context.initFromOptions({
								alpha: !!r.useContextAlpha,
								antialias: i.antialias,
								premultipliedAlpha:
									r.useContextAlpha && 'notMultiplied' !== r.useContextAlpha,
								stencil: !0,
								preserveDrawingBuffer: i.preserveDrawingBuffer,
								powerPreference: r.options.powerPreference,
						  }),
					(r.renderingToScreen = !0),
					sayHello$3(2 === r.context.webGLVersion ? 'WebGL 2' : 'WebGL 1'),
					r.resize(r.options.width, r.options.height),
					r
				);
			}
			return (
				__extends$n(e, t),
				(e.create = function (t) {
					if (isWebGLSupported$3()) return new e(t);
					throw new Error(
						'WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.'
					);
				}),
				(e.prototype.contextChange = function () {
					var t,
						e = this.gl;
					if (1 === this.context.webGLVersion) {
						var i = e.getParameter(e.FRAMEBUFFER_BINDING);
						e.bindFramebuffer(e.FRAMEBUFFER, null),
							(t = e.getParameter(e.SAMPLES)),
							e.bindFramebuffer(e.FRAMEBUFFER, i);
					} else
						(i = e.getParameter(e.DRAW_FRAMEBUFFER_BINDING)),
							e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
							(t = e.getParameter(e.SAMPLES)),
							e.bindFramebuffer(e.DRAW_FRAMEBUFFER, i);
					t >= MSAA_QUALITY$9.HIGH
						? (this.multisample = MSAA_QUALITY$9.HIGH)
						: t >= MSAA_QUALITY$9.MEDIUM
						? (this.multisample = MSAA_QUALITY$9.MEDIUM)
						: t >= MSAA_QUALITY$9.LOW
						? (this.multisample = MSAA_QUALITY$9.LOW)
						: (this.multisample = MSAA_QUALITY$9.NONE);
				}),
				(e.prototype.addSystem = function (t, e) {
					var i = new t(this);
					if (this[e])
						throw new Error('Whoops! The name "' + e + '" is already in use');
					for (var r in ((this[e] = i), this.runners)) this.runners[r].add(i);
					return this;
				}),
				(e.prototype.render = function (t, e) {
					var i, r, s, n;
					if (
						(e &&
							(e instanceof RenderTexture$3
								? (deprecation$3(
										'6.0.0',
										'Renderer#render arguments changed, use options instead.'
								  ),
								  (i = e),
								  (r = arguments[2]),
								  (s = arguments[3]),
								  (n = arguments[4]))
								: ((i = e.renderTexture),
								  (r = e.clear),
								  (s = e.transform),
								  (n = e.skipUpdateTransform))),
						(this.renderingToScreen = !i),
						this.runners.prerender.emit(),
						this.emit('prerender'),
						(this.projection.transform = s),
						!this.context.isLost)
					) {
						if ((i || (this._lastObjectRendered = t), !n)) {
							var a = t.enableTempParent();
							t.updateTransform(), t.disableTempParent(a);
						}
						this.renderTexture.bind(i),
							this.batch.currentRenderer.start(),
							(void 0 !== r ? r : this.clearBeforeRender) &&
								this.renderTexture.clear(),
							t.render(this),
							this.batch.currentRenderer.flush(),
							i && i.baseTexture.update(),
							this.runners.postrender.emit(),
							(this.projection.transform = null),
							this.emit('postrender');
					}
				}),
				(e.prototype.generateTexture = function (e, i, r, s) {
					void 0 === i && (i = {});
					var n = t.prototype.generateTexture.call(this, e, i, r, s);
					return this.framebuffer.blit(), n;
				}),
				(e.prototype.resize = function (e, i) {
					t.prototype.resize.call(this, e, i),
						this.runners.resize.emit(this.screen.height, this.screen.width);
				}),
				(e.prototype.reset = function () {
					return this.runners.reset.emit(), this;
				}),
				(e.prototype.clear = function () {
					this.renderTexture.bind(), this.renderTexture.clear();
				}),
				(e.prototype.destroy = function (e) {
					for (var i in (this.runners.destroy.emit(), this.runners))
						this.runners[i].destroy();
					t.prototype.destroy.call(this, e), (this.gl = null);
				}),
				Object.defineProperty(e.prototype, 'extract', {
					get: function () {
						return (
							deprecation$3(
								'6.0.0',
								'Renderer#extract has been deprecated, please use Renderer#plugins.extract instead.'
							),
							this.plugins.extract
						);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.registerPlugin = function (t, i) {
					(e.__plugins = e.__plugins || {}), (e.__plugins[t] = i);
				}),
				e
			);
		})(AbstractRenderer$3);
	function autoDetectRenderer(t) {
		return Renderer$1.create(t);
	}
	var $defaultVertex =
			'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}',
		$defaultFilterVertex =
			'attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n',
		defaultVertex$1$2 = $defaultVertex,
		defaultFilterVertex = $defaultFilterVertex,
		System = (function () {
			function t(t) {
				deprecation$3(
					'6.1.0',
					'System class is deprecated, implemement ISystem interface instead.'
				),
					(this.renderer = t);
			}
			return (
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})(),
		BatchDrawCall$3 = function () {
			(this.texArray = null),
				(this.blend = 0),
				(this.type = DRAW_MODES$9.TRIANGLES),
				(this.start = 0),
				(this.size = 0),
				(this.data = null);
		},
		BatchTextureArray$3 = (function () {
			function t() {
				(this.elements = []), (this.ids = []), (this.count = 0);
			}
			return (
				(t.prototype.clear = function () {
					for (var t = 0; t < this.count; t++) this.elements[t] = null;
					this.count = 0;
				}),
				t
			);
		})(),
		ViewableBuffer$3 = (function () {
			function t(t) {
				'number' == typeof t
					? (this.rawBinaryData = new ArrayBuffer(t))
					: t instanceof Uint8Array
					? (this.rawBinaryData = t.buffer)
					: (this.rawBinaryData = t),
					(this.uint32View = new Uint32Array(this.rawBinaryData)),
					(this.float32View = new Float32Array(this.rawBinaryData));
			}
			return (
				Object.defineProperty(t.prototype, 'int8View', {
					get: function () {
						return (
							this._int8View ||
								(this._int8View = new Int8Array(this.rawBinaryData)),
							this._int8View
						);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'uint8View', {
					get: function () {
						return (
							this._uint8View ||
								(this._uint8View = new Uint8Array(this.rawBinaryData)),
							this._uint8View
						);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'int16View', {
					get: function () {
						return (
							this._int16View ||
								(this._int16View = new Int16Array(this.rawBinaryData)),
							this._int16View
						);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'uint16View', {
					get: function () {
						return (
							this._uint16View ||
								(this._uint16View = new Uint16Array(this.rawBinaryData)),
							this._uint16View
						);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'int32View', {
					get: function () {
						return (
							this._int32View ||
								(this._int32View = new Int32Array(this.rawBinaryData)),
							this._int32View
						);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.view = function (t) {
					return this[t + 'View'];
				}),
				(t.prototype.destroy = function () {
					(this.rawBinaryData = null),
						(this._int8View = null),
						(this._uint8View = null),
						(this._int16View = null),
						(this._uint16View = null),
						(this._int32View = null),
						(this.uint32View = null),
						(this.float32View = null);
				}),
				(t.sizeOf = function (t) {
					switch (t) {
						case 'int8':
						case 'uint8':
							return 1;
						case 'int16':
						case 'uint16':
							return 2;
						case 'int32':
						case 'uint32':
						case 'float32':
							return 4;
						default:
							throw new Error(t + " isn't a valid view type");
					}
				}),
				t
			);
		})(),
		AbstractBatchRenderer$3 = (function (t) {
			function e(e) {
				var i = t.call(this, e) || this;
				return (
					(i.shaderGenerator = null),
					(i.geometryClass = null),
					(i.vertexSize = null),
					(i.state = State$3.for2d()),
					(i.size = 4 * settings$4.SPRITE_BATCH_SIZE),
					(i._vertexCount = 0),
					(i._indexCount = 0),
					(i._bufferedElements = []),
					(i._bufferedTextures = []),
					(i._bufferSize = 0),
					(i._shader = null),
					(i._packedGeometries = []),
					(i._packedGeometryPoolSize = 2),
					(i._flushId = 0),
					(i._aBuffers = {}),
					(i._iBuffers = {}),
					(i.MAX_TEXTURES = 1),
					i.renderer.on('prerender', i.onPrerender, i),
					e.runners.contextChange.add(i),
					(i._dcIndex = 0),
					(i._aIndex = 0),
					(i._iIndex = 0),
					(i._attributeBuffer = null),
					(i._indexBuffer = null),
					(i._tempBoundTextures = []),
					i
				);
			}
			return (
				__extends$n(e, t),
				(e.prototype.contextChange = function () {
					var t = this.renderer.gl;
					settings$4.PREFER_ENV === ENV$9.WEBGL_LEGACY
						? (this.MAX_TEXTURES = 1)
						: ((this.MAX_TEXTURES = Math.min(
								t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
								settings$4.SPRITE_MAX_TEXTURES
						  )),
						  (this.MAX_TEXTURES = checkMaxIfStatementsInShader$3(
								this.MAX_TEXTURES,
								t
						  ))),
						(this._shader = this.shaderGenerator.generateShader(
							this.MAX_TEXTURES
						));
					for (var e = 0; e < this._packedGeometryPoolSize; e++)
						this._packedGeometries[e] = new this.geometryClass();
					this.initFlushBuffers();
				}),
				(e.prototype.initFlushBuffers = function () {
					for (
						var t = e._drawCallPool,
							i = e._textureArrayPool,
							r = this.size / 4,
							s = Math.floor(r / this.MAX_TEXTURES) + 1;
						t.length < r;

					)
						t.push(new BatchDrawCall$3());
					for (; i.length < s; ) i.push(new BatchTextureArray$3());
					for (var n = 0; n < this.MAX_TEXTURES; n++)
						this._tempBoundTextures[n] = null;
				}),
				(e.prototype.onPrerender = function () {
					this._flushId = 0;
				}),
				(e.prototype.render = function (t) {
					t._texture.valid &&
						(this._vertexCount + t.vertexData.length / 2 > this.size &&
							this.flush(),
						(this._vertexCount += t.vertexData.length / 2),
						(this._indexCount += t.indices.length),
						(this._bufferedTextures[this._bufferSize] = t._texture.baseTexture),
						(this._bufferedElements[this._bufferSize++] = t));
				}),
				(e.prototype.buildTexturesAndDrawCalls = function () {
					var t = this._bufferedTextures,
						i = this.MAX_TEXTURES,
						r = e._textureArrayPool,
						s = this.renderer.batch,
						n = this._tempBoundTextures,
						a = this.renderer.textureGC.count,
						o = ++BaseTexture$3._globalBatch,
						h = 0,
						u = r[0],
						l = 0;
					s.copyBoundTextures(n, i);
					for (var c = 0; c < this._bufferSize; ++c) {
						var d = t[c];
						(t[c] = null),
							d._batchEnabled !== o &&
								(u.count >= i &&
									(s.boundArray(u, n, o, i),
									this.buildDrawCalls(u, l, c),
									(l = c),
									(u = r[++h]),
									++o),
								(d._batchEnabled = o),
								(d.touched = a),
								(u.elements[u.count++] = d));
					}
					for (
						u.count > 0 &&
							(s.boundArray(u, n, o, i),
							this.buildDrawCalls(u, l, this._bufferSize),
							++h,
							++o),
							c = 0;
						c < n.length;
						c++
					)
						n[c] = null;
					BaseTexture$3._globalBatch = o;
				}),
				(e.prototype.buildDrawCalls = function (t, i, r) {
					var s = this,
						n = s._bufferedElements,
						a = s._attributeBuffer,
						o = s._indexBuffer,
						h = s.vertexSize,
						u = e._drawCallPool,
						l = this._dcIndex,
						c = this._aIndex,
						d = this._iIndex,
						p = u[l];
					(p.start = this._iIndex), (p.texArray = t);
					for (var f = i; f < r; ++f) {
						var m = n[f],
							_ = m._texture.baseTexture,
							g = premultiplyBlendMode$3[_.alphaMode ? 1 : 0][m.blendMode];
						(n[f] = null),
							i < f &&
								p.blend !== g &&
								((p.size = d - p.start),
								(i = f),
								((p = u[++l]).texArray = t),
								(p.start = d)),
							this.packInterleavedGeometry(m, a, o, c, d),
							(c += (m.vertexData.length / 2) * h),
							(d += m.indices.length),
							(p.blend = g);
					}
					i < r && ((p.size = d - p.start), ++l),
						(this._dcIndex = l),
						(this._aIndex = c),
						(this._iIndex = d);
				}),
				(e.prototype.bindAndClearTexArray = function (t) {
					for (var e = this.renderer.texture, i = 0; i < t.count; i++)
						e.bind(t.elements[i], t.ids[i]), (t.elements[i] = null);
					t.count = 0;
				}),
				(e.prototype.updateGeometry = function () {
					var t = this,
						e = t._packedGeometries,
						i = t._attributeBuffer,
						r = t._indexBuffer;
					settings$4.CAN_UPLOAD_SAME_BUFFER
						? (e[this._flushId]._buffer.update(i.rawBinaryData),
						  e[this._flushId]._indexBuffer.update(r),
						  this.renderer.geometry.updateBuffers())
						: (this._packedGeometryPoolSize <= this._flushId &&
								(this._packedGeometryPoolSize++,
								(e[this._flushId] = new this.geometryClass())),
						  e[this._flushId]._buffer.update(i.rawBinaryData),
						  e[this._flushId]._indexBuffer.update(r),
						  this.renderer.geometry.bind(e[this._flushId]),
						  this.renderer.geometry.updateBuffers(),
						  this._flushId++);
				}),
				(e.prototype.drawBatches = function () {
					for (
						var t = this._dcIndex,
							i = this.renderer,
							r = i.gl,
							s = i.state,
							n = e._drawCallPool,
							a = null,
							o = 0;
						o < t;
						o++
					) {
						var h = n[o],
							u = h.texArray,
							l = h.type,
							c = h.size,
							d = h.start,
							p = h.blend;
						a !== u && ((a = u), this.bindAndClearTexArray(u)),
							(this.state.blendMode = p),
							s.set(this.state),
							r.drawElements(l, c, r.UNSIGNED_SHORT, 2 * d);
					}
				}),
				(e.prototype.flush = function () {
					0 !== this._vertexCount &&
						((this._attributeBuffer = this.getAttributeBuffer(
							this._vertexCount
						)),
						(this._indexBuffer = this.getIndexBuffer(this._indexCount)),
						(this._aIndex = 0),
						(this._iIndex = 0),
						(this._dcIndex = 0),
						this.buildTexturesAndDrawCalls(),
						this.updateGeometry(),
						this.drawBatches(),
						(this._bufferSize = 0),
						(this._vertexCount = 0),
						(this._indexCount = 0));
				}),
				(e.prototype.start = function () {
					this.renderer.state.set(this.state),
						this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES),
						this.renderer.shader.bind(this._shader),
						settings$4.CAN_UPLOAD_SAME_BUFFER &&
							this.renderer.geometry.bind(
								this._packedGeometries[this._flushId]
							);
				}),
				(e.prototype.stop = function () {
					this.flush();
				}),
				(e.prototype.destroy = function () {
					for (var e = 0; e < this._packedGeometryPoolSize; e++)
						this._packedGeometries[e] && this._packedGeometries[e].destroy();
					this.renderer.off('prerender', this.onPrerender, this),
						(this._aBuffers = null),
						(this._iBuffers = null),
						(this._packedGeometries = null),
						(this._attributeBuffer = null),
						(this._indexBuffer = null),
						this._shader && (this._shader.destroy(), (this._shader = null)),
						t.prototype.destroy.call(this);
				}),
				(e.prototype.getAttributeBuffer = function (t) {
					var e = nextPow2$3(Math.ceil(t / 8)),
						i = log2$3(e),
						r = 8 * e;
					this._aBuffers.length <= i && (this._iBuffers.length = i + 1);
					var s = this._aBuffers[r];
					return (
						s ||
							(this._aBuffers[r] = s =
								new ViewableBuffer$3(r * this.vertexSize * 4)),
						s
					);
				}),
				(e.prototype.getIndexBuffer = function (t) {
					var e = nextPow2$3(Math.ceil(t / 12)),
						i = log2$3(e),
						r = 12 * e;
					this._iBuffers.length <= i && (this._iBuffers.length = i + 1);
					var s = this._iBuffers[i];
					return s || (this._iBuffers[i] = s = new Uint16Array(r)), s;
				}),
				(e.prototype.packInterleavedGeometry = function (t, e, i, r, s) {
					for (
						var n = e.uint32View,
							a = e.float32View,
							o = r / this.vertexSize,
							h = t.uvs,
							u = t.indices,
							l = t.vertexData,
							c = t._texture.baseTexture._batchLocation,
							d = Math.min(t.worldAlpha, 1),
							p =
								d < 1 && t._texture.baseTexture.alphaMode
									? premultiplyTint$3(t._tintRGB, d)
									: t._tintRGB + ((255 * d) << 24),
							f = 0;
						f < l.length;
						f += 2
					)
						(a[r++] = l[f]),
							(a[r++] = l[f + 1]),
							(a[r++] = h[f]),
							(a[r++] = h[f + 1]),
							(n[r++] = p),
							(a[r++] = c);
					for (f = 0; f < u.length; f++) i[s++] = o + u[f];
				}),
				(e._drawCallPool = []),
				(e._textureArrayPool = []),
				e
			);
		})(ObjectRenderer$3),
		BatchShaderGenerator$3 = (function () {
			function t(t, e) {
				if (
					((this.vertexSrc = t),
					(this.fragTemplate = e),
					(this.programCache = {}),
					(this.defaultGroupCache = {}),
					e.indexOf('%count%') < 0)
				)
					throw new Error('Fragment template must contain "%count%".');
				if (e.indexOf('%forloop%') < 0)
					throw new Error('Fragment template must contain "%forloop%".');
			}
			return (
				(t.prototype.generateShader = function (t) {
					if (!this.programCache[t]) {
						for (var e = new Int32Array(t), i = 0; i < t; i++) e[i] = i;
						this.defaultGroupCache[t] = UniformGroup$3.from(
							{ uSamplers: e },
							!0
						);
						var r = this.fragTemplate;
						(r = (r = r.replace(/%count%/gi, '' + t)).replace(
							/%forloop%/gi,
							this.generateSampleSrc(t)
						)),
							(this.programCache[t] = new Program$3(this.vertexSrc, r));
					}
					var s = {
						tint: new Float32Array([1, 1, 1, 1]),
						translationMatrix: new Matrix$3(),
						default: this.defaultGroupCache[t],
					};
					return new Shader$3(this.programCache[t], s);
				}),
				(t.prototype.generateSampleSrc = function (t) {
					var e = '';
					(e += '\n'), (e += '\n');
					for (var i = 0; i < t; i++)
						i > 0 && (e += '\nelse '),
							i < t - 1 && (e += 'if(vTextureId < ' + i + '.5)'),
							(e += '\n{'),
							(e +=
								'\n\tcolor = texture2D(uSamplers[' + i + '], vTextureCoord);'),
							(e += '\n}');
					return (e += '\n') + '\n';
				}),
				t
			);
		})(),
		BatchGeometry$3 = (function (t) {
			function e(e) {
				void 0 === e && (e = !1);
				var i = t.call(this) || this;
				return (
					(i._buffer = new Buffer$3(null, e, !1)),
					(i._indexBuffer = new Buffer$3(null, e, !0)),
					i
						.addAttribute('aVertexPosition', i._buffer, 2, !1, TYPES$9.FLOAT)
						.addAttribute('aTextureCoord', i._buffer, 2, !1, TYPES$9.FLOAT)
						.addAttribute('aColor', i._buffer, 4, !0, TYPES$9.UNSIGNED_BYTE)
						.addAttribute('aTextureId', i._buffer, 1, !0, TYPES$9.FLOAT)
						.addIndex(i._indexBuffer),
					i
				);
			}
			return __extends$n(e, t), e;
		})(Geometry$3),
		defaultVertex$5 =
			'precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n',
		defaultFragment$5 =
			'varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n',
		BatchPluginFactory$3 = (function () {
			function t() {}
			return (
				(t.create = function (t) {
					var e = Object.assign(
							{
								vertex: defaultVertex$5,
								fragment: defaultFragment$5,
								geometryClass: BatchGeometry$3,
								vertexSize: 6,
							},
							t
						),
						i = e.vertex,
						r = e.fragment,
						s = e.vertexSize,
						n = e.geometryClass;
					return (function (t) {
						function e(e) {
							var a = t.call(this, e) || this;
							return (
								(a.shaderGenerator = new BatchShaderGenerator$3(i, r)),
								(a.geometryClass = n),
								(a.vertexSize = s),
								a
							);
						}
						return __extends$n(e, t), e;
					})(AbstractBatchRenderer$3);
				}),
				Object.defineProperty(t, 'defaultVertexSrc', {
					get: function () {
						return defaultVertex$5;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t, 'defaultFragmentTemplate', {
					get: function () {
						return defaultFragment$5;
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			);
		})(),
		BatchRenderer = BatchPluginFactory$3.create(),
		resources = {},
		_loop_1 = function (t) {
			Object.defineProperty(resources, t, {
				get: function () {
					return (
						deprecation$3(
							'6.0.0',
							'PIXI.systems.' + t + ' has moved to PIXI.' + t
						),
						_resources[t]
					);
				},
			});
		};
	for (var name in _resources) _loop_1(name);
	var systems = {},
		_loop_2 = function (t) {
			Object.defineProperty(systems, t, {
				get: function () {
					return (
						deprecation$3(
							'6.0.0',
							'PIXI.resources.' + t + ' has moved to PIXI.' + t
						),
						_systems[t]
					);
				},
			});
		};
	for (var name in _systems) _loop_2(name);
	/*!
	 * @pixi/canvas-display - v6.4.2
	 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
	 *
	 * @pixi/canvas-display is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 */ (Container$2.prototype._renderCanvas = function (t) {}),
		(Container$2.prototype.renderCanvas = function (t) {
			if (this.visible && !(this.worldAlpha <= 0) && this.renderable) {
				this._mask && t.maskManager.pushMask(this._mask), this._renderCanvas(t);
				for (var e = 0, i = this.children.length; e < i; ++e)
					this.children[e].renderCanvas(t);
				this._mask && t.maskManager.popMask(t);
			}
		}),
		(DisplayObject$2.prototype.renderCanvas = function (t) {});
	/*!
	 * @pixi/extract - v6.4.2
	 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
	 *
	 * @pixi/extract is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 */
	var appleIphone = /iPhone/i,
		appleIpod = /iPod/i,
		appleTablet = /iPad/i,
		appleUniversal = /\biOS-universal(?:.+)Mac\b/i,
		androidPhone = /\bAndroid(?:.+)Mobile\b/i,
		androidTablet = /Android/i,
		amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i,
		amazonTablet = /Silk/i,
		windowsPhone = /Windows Phone/i,
		windowsTablet = /\bWindows(?:.+)ARM\b/i,
		otherBlackBerry = /BlackBerry/i,
		otherBlackBerry10 = /BB10/i,
		otherOpera = /Opera Mini/i,
		otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i,
		otherFirefox = /Mobile(?:.+)Firefox\b/i,
		isAppleTabletOnIos13 = function (t) {
			return (
				void 0 !== t &&
				'MacIntel' === t.platform &&
				'number' == typeof t.maxTouchPoints &&
				t.maxTouchPoints > 1 &&
				'undefined' == typeof MSStream
			);
		};
	function createMatch(t) {
		return function (e) {
			return e.test(t);
		};
	}
	function isMobile$1$1(t) {
		var e = { userAgent: '', platform: '', maxTouchPoints: 0 };
		t || 'undefined' == typeof navigator
			? 'string' == typeof t
				? (e.userAgent = t)
				: t &&
				  t.userAgent &&
				  (e = {
						userAgent: t.userAgent,
						platform: t.platform,
						maxTouchPoints: t.maxTouchPoints || 0,
				  })
			: (e = {
					userAgent: navigator.userAgent,
					platform: navigator.platform,
					maxTouchPoints: navigator.maxTouchPoints || 0,
			  });
		var i = e.userAgent,
			r = i.split('[FBAN');
		void 0 !== r[1] && (i = r[0]),
			void 0 !== (r = i.split('Twitter'))[1] && (i = r[0]);
		var s = createMatch(i),
			n = {
				apple: {
					phone: s(appleIphone) && !s(windowsPhone),
					ipod: s(appleIpod),
					tablet:
						!s(appleIphone) &&
						(s(appleTablet) || isAppleTabletOnIos13(e)) &&
						!s(windowsPhone),
					universal: s(appleUniversal),
					device:
						(s(appleIphone) ||
							s(appleIpod) ||
							s(appleTablet) ||
							s(appleUniversal) ||
							isAppleTabletOnIos13(e)) &&
						!s(windowsPhone),
				},
				amazon: {
					phone: s(amazonPhone),
					tablet: !s(amazonPhone) && s(amazonTablet),
					device: s(amazonPhone) || s(amazonTablet),
				},
				android: {
					phone:
						(!s(windowsPhone) && s(amazonPhone)) ||
						(!s(windowsPhone) && s(androidPhone)),
					tablet:
						!s(windowsPhone) &&
						!s(amazonPhone) &&
						!s(androidPhone) &&
						(s(amazonTablet) || s(androidTablet)),
					device:
						(!s(windowsPhone) &&
							(s(amazonPhone) ||
								s(amazonTablet) ||
								s(androidPhone) ||
								s(androidTablet))) ||
						s(/\bokhttp\b/i),
				},
				windows: {
					phone: s(windowsPhone),
					tablet: s(windowsTablet),
					device: s(windowsPhone) || s(windowsTablet),
				},
				other: {
					blackberry: s(otherBlackBerry),
					blackberry10: s(otherBlackBerry10),
					opera: s(otherOpera),
					firefox: s(otherFirefox),
					chrome: s(otherChrome),
					device:
						s(otherBlackBerry) ||
						s(otherBlackBerry10) ||
						s(otherOpera) ||
						s(otherFirefox) ||
						s(otherChrome),
				},
				any: !1,
				phone: !1,
				tablet: !1,
			};
		return (
			(n.any =
				n.apple.device ||
				n.android.device ||
				n.windows.device ||
				n.other.device),
			(n.phone = n.apple.phone || n.android.phone || n.windows.phone),
			(n.tablet = n.apple.tablet || n.android.tablet || n.windows.tablet),
			n
		);
	}
	/*!
	 * @pixi/settings - v6.4.2
	 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
	 *
	 * @pixi/settings is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 */ var isMobile$2 = isMobile$1$1(globalThis.navigator),
		ENV$1$1,
		RENDERER_TYPE$1$1,
		BUFFER_BITS$1$1,
		BLEND_MODES$1$1,
		DRAW_MODES$1$1,
		FORMATS$1$1,
		TARGETS$1$1,
		TYPES$1$1,
		SAMPLER_TYPES$1$1,
		SCALE_MODES$1$1,
		WRAP_MODES$1$1,
		MIPMAP_MODES$1$1,
		ALPHA_MODES$1$1,
		CLEAR_MODES$1$1,
		GC_MODES$1$1,
		PRECISION$1$1,
		MASK_TYPES$1$1,
		MSAA_QUALITY$1$1,
		BUFFER_TYPE$1$1;
	function maxRecommendedTextures$2(t) {
		var e,
			i = !0;
		(isMobile$2.tablet || isMobile$2.phone) &&
			(isMobile$2.apple.device &&
				(e = navigator.userAgent.match(/OS (\d+)_(\d+)?/)) &&
				parseInt(e[1], 10) < 11 &&
				(i = !1),
			isMobile$2.android.device &&
				(e = navigator.userAgent.match(/Android\s([0-9.]*)/)) &&
				parseInt(e[1], 10) < 7 &&
				(i = !1));
		return i ? t : 4;
	}
	function canUploadSameBuffer$2() {
		return !isMobile$2.apple.device;
	}
	/*!
	 * @pixi/constants - v6.4.2
	 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
	 *
	 * @pixi/constants is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 */ !(function (t) {
		(t[(t.WEBGL_LEGACY = 0)] = 'WEBGL_LEGACY'),
			(t[(t.WEBGL = 1)] = 'WEBGL'),
			(t[(t.WEBGL2 = 2)] = 'WEBGL2');
	})(ENV$1$1 || (ENV$1$1 = {})),
		(function (t) {
			(t[(t.UNKNOWN = 0)] = 'UNKNOWN'),
				(t[(t.WEBGL = 1)] = 'WEBGL'),
				(t[(t.CANVAS = 2)] = 'CANVAS');
		})(RENDERER_TYPE$1$1 || (RENDERER_TYPE$1$1 = {})),
		(function (t) {
			(t[(t.COLOR = 16384)] = 'COLOR'),
				(t[(t.DEPTH = 256)] = 'DEPTH'),
				(t[(t.STENCIL = 1024)] = 'STENCIL');
		})(BUFFER_BITS$1$1 || (BUFFER_BITS$1$1 = {})),
		(function (t) {
			(t[(t.NORMAL = 0)] = 'NORMAL'),
				(t[(t.ADD = 1)] = 'ADD'),
				(t[(t.MULTIPLY = 2)] = 'MULTIPLY'),
				(t[(t.SCREEN = 3)] = 'SCREEN'),
				(t[(t.OVERLAY = 4)] = 'OVERLAY'),
				(t[(t.DARKEN = 5)] = 'DARKEN'),
				(t[(t.LIGHTEN = 6)] = 'LIGHTEN'),
				(t[(t.COLOR_DODGE = 7)] = 'COLOR_DODGE'),
				(t[(t.COLOR_BURN = 8)] = 'COLOR_BURN'),
				(t[(t.HARD_LIGHT = 9)] = 'HARD_LIGHT'),
				(t[(t.SOFT_LIGHT = 10)] = 'SOFT_LIGHT'),
				(t[(t.DIFFERENCE = 11)] = 'DIFFERENCE'),
				(t[(t.EXCLUSION = 12)] = 'EXCLUSION'),
				(t[(t.HUE = 13)] = 'HUE'),
				(t[(t.SATURATION = 14)] = 'SATURATION'),
				(t[(t.COLOR = 15)] = 'COLOR'),
				(t[(t.LUMINOSITY = 16)] = 'LUMINOSITY'),
				(t[(t.NORMAL_NPM = 17)] = 'NORMAL_NPM'),
				(t[(t.ADD_NPM = 18)] = 'ADD_NPM'),
				(t[(t.SCREEN_NPM = 19)] = 'SCREEN_NPM'),
				(t[(t.NONE = 20)] = 'NONE'),
				(t[(t.SRC_OVER = 0)] = 'SRC_OVER'),
				(t[(t.SRC_IN = 21)] = 'SRC_IN'),
				(t[(t.SRC_OUT = 22)] = 'SRC_OUT'),
				(t[(t.SRC_ATOP = 23)] = 'SRC_ATOP'),
				(t[(t.DST_OVER = 24)] = 'DST_OVER'),
				(t[(t.DST_IN = 25)] = 'DST_IN'),
				(t[(t.DST_OUT = 26)] = 'DST_OUT'),
				(t[(t.DST_ATOP = 27)] = 'DST_ATOP'),
				(t[(t.ERASE = 26)] = 'ERASE'),
				(t[(t.SUBTRACT = 28)] = 'SUBTRACT'),
				(t[(t.XOR = 29)] = 'XOR');
		})(BLEND_MODES$1$1 || (BLEND_MODES$1$1 = {})),
		(function (t) {
			(t[(t.POINTS = 0)] = 'POINTS'),
				(t[(t.LINES = 1)] = 'LINES'),
				(t[(t.LINE_LOOP = 2)] = 'LINE_LOOP'),
				(t[(t.LINE_STRIP = 3)] = 'LINE_STRIP'),
				(t[(t.TRIANGLES = 4)] = 'TRIANGLES'),
				(t[(t.TRIANGLE_STRIP = 5)] = 'TRIANGLE_STRIP'),
				(t[(t.TRIANGLE_FAN = 6)] = 'TRIANGLE_FAN');
		})(DRAW_MODES$1$1 || (DRAW_MODES$1$1 = {})),
		(function (t) {
			(t[(t.RGBA = 6408)] = 'RGBA'),
				(t[(t.RGB = 6407)] = 'RGB'),
				(t[(t.RG = 33319)] = 'RG'),
				(t[(t.RED = 6403)] = 'RED'),
				(t[(t.RGBA_INTEGER = 36249)] = 'RGBA_INTEGER'),
				(t[(t.RGB_INTEGER = 36248)] = 'RGB_INTEGER'),
				(t[(t.RG_INTEGER = 33320)] = 'RG_INTEGER'),
				(t[(t.RED_INTEGER = 36244)] = 'RED_INTEGER'),
				(t[(t.ALPHA = 6406)] = 'ALPHA'),
				(t[(t.LUMINANCE = 6409)] = 'LUMINANCE'),
				(t[(t.LUMINANCE_ALPHA = 6410)] = 'LUMINANCE_ALPHA'),
				(t[(t.DEPTH_COMPONENT = 6402)] = 'DEPTH_COMPONENT'),
				(t[(t.DEPTH_STENCIL = 34041)] = 'DEPTH_STENCIL');
		})(FORMATS$1$1 || (FORMATS$1$1 = {})),
		(function (t) {
			(t[(t.TEXTURE_2D = 3553)] = 'TEXTURE_2D'),
				(t[(t.TEXTURE_CUBE_MAP = 34067)] = 'TEXTURE_CUBE_MAP'),
				(t[(t.TEXTURE_2D_ARRAY = 35866)] = 'TEXTURE_2D_ARRAY'),
				(t[(t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069)] =
					'TEXTURE_CUBE_MAP_POSITIVE_X'),
				(t[(t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070)] =
					'TEXTURE_CUBE_MAP_NEGATIVE_X'),
				(t[(t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071)] =
					'TEXTURE_CUBE_MAP_POSITIVE_Y'),
				(t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072)] =
					'TEXTURE_CUBE_MAP_NEGATIVE_Y'),
				(t[(t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073)] =
					'TEXTURE_CUBE_MAP_POSITIVE_Z'),
				(t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074)] =
					'TEXTURE_CUBE_MAP_NEGATIVE_Z');
		})(TARGETS$1$1 || (TARGETS$1$1 = {})),
		(function (t) {
			(t[(t.UNSIGNED_BYTE = 5121)] = 'UNSIGNED_BYTE'),
				(t[(t.UNSIGNED_SHORT = 5123)] = 'UNSIGNED_SHORT'),
				(t[(t.UNSIGNED_SHORT_5_6_5 = 33635)] = 'UNSIGNED_SHORT_5_6_5'),
				(t[(t.UNSIGNED_SHORT_4_4_4_4 = 32819)] = 'UNSIGNED_SHORT_4_4_4_4'),
				(t[(t.UNSIGNED_SHORT_5_5_5_1 = 32820)] = 'UNSIGNED_SHORT_5_5_5_1'),
				(t[(t.UNSIGNED_INT = 5125)] = 'UNSIGNED_INT'),
				(t[(t.UNSIGNED_INT_10F_11F_11F_REV = 35899)] =
					'UNSIGNED_INT_10F_11F_11F_REV'),
				(t[(t.UNSIGNED_INT_2_10_10_10_REV = 33640)] =
					'UNSIGNED_INT_2_10_10_10_REV'),
				(t[(t.UNSIGNED_INT_24_8 = 34042)] = 'UNSIGNED_INT_24_8'),
				(t[(t.UNSIGNED_INT_5_9_9_9_REV = 35902)] = 'UNSIGNED_INT_5_9_9_9_REV'),
				(t[(t.BYTE = 5120)] = 'BYTE'),
				(t[(t.SHORT = 5122)] = 'SHORT'),
				(t[(t.INT = 5124)] = 'INT'),
				(t[(t.FLOAT = 5126)] = 'FLOAT'),
				(t[(t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269)] =
					'FLOAT_32_UNSIGNED_INT_24_8_REV'),
				(t[(t.HALF_FLOAT = 36193)] = 'HALF_FLOAT');
		})(TYPES$1$1 || (TYPES$1$1 = {})),
		(function (t) {
			(t[(t.FLOAT = 0)] = 'FLOAT'),
				(t[(t.INT = 1)] = 'INT'),
				(t[(t.UINT = 2)] = 'UINT');
		})(SAMPLER_TYPES$1$1 || (SAMPLER_TYPES$1$1 = {})),
		(function (t) {
			(t[(t.NEAREST = 0)] = 'NEAREST'), (t[(t.LINEAR = 1)] = 'LINEAR');
		})(SCALE_MODES$1$1 || (SCALE_MODES$1$1 = {})),
		(function (t) {
			(t[(t.CLAMP = 33071)] = 'CLAMP'),
				(t[(t.REPEAT = 10497)] = 'REPEAT'),
				(t[(t.MIRRORED_REPEAT = 33648)] = 'MIRRORED_REPEAT');
		})(WRAP_MODES$1$1 || (WRAP_MODES$1$1 = {})),
		(function (t) {
			(t[(t.OFF = 0)] = 'OFF'),
				(t[(t.POW2 = 1)] = 'POW2'),
				(t[(t.ON = 2)] = 'ON'),
				(t[(t.ON_MANUAL = 3)] = 'ON_MANUAL');
		})(MIPMAP_MODES$1$1 || (MIPMAP_MODES$1$1 = {})),
		(function (t) {
			(t[(t.NPM = 0)] = 'NPM'),
				(t[(t.UNPACK = 1)] = 'UNPACK'),
				(t[(t.PMA = 2)] = 'PMA'),
				(t[(t.NO_PREMULTIPLIED_ALPHA = 0)] = 'NO_PREMULTIPLIED_ALPHA'),
				(t[(t.PREMULTIPLY_ON_UPLOAD = 1)] = 'PREMULTIPLY_ON_UPLOAD'),
				(t[(t.PREMULTIPLY_ALPHA = 2)] = 'PREMULTIPLY_ALPHA'),
				(t[(t.PREMULTIPLIED_ALPHA = 2)] = 'PREMULTIPLIED_ALPHA');
		})(ALPHA_MODES$1$1 || (ALPHA_MODES$1$1 = {})),
		(function (t) {
			(t[(t.NO = 0)] = 'NO'),
				(t[(t.YES = 1)] = 'YES'),
				(t[(t.AUTO = 2)] = 'AUTO'),
				(t[(t.BLEND = 0)] = 'BLEND'),
				(t[(t.CLEAR = 1)] = 'CLEAR'),
				(t[(t.BLIT = 2)] = 'BLIT');
		})(CLEAR_MODES$1$1 || (CLEAR_MODES$1$1 = {})),
		(function (t) {
			(t[(t.AUTO = 0)] = 'AUTO'), (t[(t.MANUAL = 1)] = 'MANUAL');
		})(GC_MODES$1$1 || (GC_MODES$1$1 = {})),
		(function (t) {
			(t.LOW = 'lowp'), (t.MEDIUM = 'mediump'), (t.HIGH = 'highp');
		})(PRECISION$1$1 || (PRECISION$1$1 = {})),
		(function (t) {
			(t[(t.NONE = 0)] = 'NONE'),
				(t[(t.SCISSOR = 1)] = 'SCISSOR'),
				(t[(t.STENCIL = 2)] = 'STENCIL'),
				(t[(t.SPRITE = 3)] = 'SPRITE');
		})(MASK_TYPES$1$1 || (MASK_TYPES$1$1 = {})),
		(function (t) {
			(t[(t.NONE = 0)] = 'NONE'),
				(t[(t.LOW = 2)] = 'LOW'),
				(t[(t.MEDIUM = 4)] = 'MEDIUM'),
				(t[(t.HIGH = 8)] = 'HIGH');
		})(MSAA_QUALITY$1$1 || (MSAA_QUALITY$1$1 = {})),
		(function (t) {
			(t[(t.ELEMENT_ARRAY_BUFFER = 34963)] = 'ELEMENT_ARRAY_BUFFER'),
				(t[(t.ARRAY_BUFFER = 34962)] = 'ARRAY_BUFFER'),
				(t[(t.UNIFORM_BUFFER = 35345)] = 'UNIFORM_BUFFER');
		})(BUFFER_TYPE$1$1 || (BUFFER_TYPE$1$1 = {}));
	var settings$3 = {
			MIPMAP_TEXTURES: MIPMAP_MODES$1$1.POW2,
			ANISOTROPIC_LEVEL: 0,
			RESOLUTION: 1,
			FILTER_RESOLUTION: 1,
			FILTER_MULTISAMPLE: MSAA_QUALITY$1$1.NONE,
			SPRITE_MAX_TEXTURES: maxRecommendedTextures$2(32),
			SPRITE_BATCH_SIZE: 4096,
			RENDER_OPTIONS: {
				view: null,
				antialias: !1,
				autoDensity: !1,
				backgroundColor: 0,
				backgroundAlpha: 1,
				useContextAlpha: !0,
				clearBeforeRender: !0,
				preserveDrawingBuffer: !1,
				width: 800,
				height: 600,
				legacy: !1,
			},
			GC_MODE: GC_MODES$1$1.AUTO,
			GC_MAX_IDLE: 3600,
			GC_MAX_CHECK_COUNT: 600,
			WRAP_MODE: WRAP_MODES$1$1.CLAMP,
			SCALE_MODE: SCALE_MODES$1$1.LINEAR,
			PRECISION_VERTEX: PRECISION$1$1.HIGH,
			PRECISION_FRAGMENT: isMobile$2.apple.device
				? PRECISION$1$1.HIGH
				: PRECISION$1$1.MEDIUM,
			CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer$2(),
			CREATE_IMAGE_BITMAP: !1,
			ROUND_PIXELS: !1,
			/*!
			 * @pixi/display - v6.4.2
			 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
			 *
			 * @pixi/display is licensed under the MIT License.
			 * http://www.opensource.org/licenses/mit-license
			 */
			SORTABLE_CHILDREN: !1,
		},
		Bounds$1 = (function () {
			function t() {
				(this.minX = 1 / 0),
					(this.minY = 1 / 0),
					(this.maxX = -1 / 0),
					(this.maxY = -1 / 0),
					(this.rect = null),
					(this.updateID = -1);
			}
			return (
				(t.prototype.isEmpty = function () {
					return this.minX > this.maxX || this.minY > this.maxY;
				}),
				(t.prototype.clear = function () {
					(this.minX = 1 / 0),
						(this.minY = 1 / 0),
						(this.maxX = -1 / 0),
						(this.maxY = -1 / 0);
				}),
				(t.prototype.getRectangle = function (t) {
					return this.minX > this.maxX || this.minY > this.maxY
						? Rectangle$4.EMPTY
						: (((t = t || new Rectangle$4(0, 0, 1, 1)).x = this.minX),
						  (t.y = this.minY),
						  (t.width = this.maxX - this.minX),
						  (t.height = this.maxY - this.minY),
						  t);
				}),
				(t.prototype.addPoint = function (t) {
					(this.minX = Math.min(this.minX, t.x)),
						(this.maxX = Math.max(this.maxX, t.x)),
						(this.minY = Math.min(this.minY, t.y)),
						(this.maxY = Math.max(this.maxY, t.y));
				}),
				(t.prototype.addPointMatrix = function (t, e) {
					var i = t.a,
						r = t.b,
						s = t.c,
						n = t.d,
						a = t.tx,
						o = t.ty,
						h = i * e.x + s * e.y + a,
						u = r * e.x + n * e.y + o;
					(this.minX = Math.min(this.minX, h)),
						(this.maxX = Math.max(this.maxX, h)),
						(this.minY = Math.min(this.minY, u)),
						(this.maxY = Math.max(this.maxY, u));
				}),
				(t.prototype.addQuad = function (t) {
					var e = this.minX,
						i = this.minY,
						r = this.maxX,
						s = this.maxY,
						n = t[0],
						a = t[1];
					(e = n < e ? n : e),
						(i = a < i ? a : i),
						(r = n > r ? n : r),
						(s = a > s ? a : s),
						(e = (n = t[2]) < e ? n : e),
						(i = (a = t[3]) < i ? a : i),
						(r = n > r ? n : r),
						(s = a > s ? a : s),
						(e = (n = t[4]) < e ? n : e),
						(i = (a = t[5]) < i ? a : i),
						(r = n > r ? n : r),
						(s = a > s ? a : s),
						(e = (n = t[6]) < e ? n : e),
						(i = (a = t[7]) < i ? a : i),
						(r = n > r ? n : r),
						(s = a > s ? a : s),
						(this.minX = e),
						(this.minY = i),
						(this.maxX = r),
						(this.maxY = s);
				}),
				(t.prototype.addFrame = function (t, e, i, r, s) {
					this.addFrameMatrix(t.worldTransform, e, i, r, s);
				}),
				(t.prototype.addFrameMatrix = function (t, e, i, r, s) {
					var n = t.a,
						a = t.b,
						o = t.c,
						h = t.d,
						u = t.tx,
						l = t.ty,
						c = this.minX,
						d = this.minY,
						p = this.maxX,
						f = this.maxY,
						m = n * e + o * i + u,
						_ = a * e + h * i + l;
					(c = m < c ? m : c),
						(d = _ < d ? _ : d),
						(p = m > p ? m : p),
						(f = _ > f ? _ : f),
						(c = (m = n * r + o * i + u) < c ? m : c),
						(d = (_ = a * r + h * i + l) < d ? _ : d),
						(p = m > p ? m : p),
						(f = _ > f ? _ : f),
						(c = (m = n * e + o * s + u) < c ? m : c),
						(d = (_ = a * e + h * s + l) < d ? _ : d),
						(p = m > p ? m : p),
						(f = _ > f ? _ : f),
						(c = (m = n * r + o * s + u) < c ? m : c),
						(d = (_ = a * r + h * s + l) < d ? _ : d),
						(p = m > p ? m : p),
						(f = _ > f ? _ : f),
						(this.minX = c),
						(this.minY = d),
						(this.maxX = p),
						(this.maxY = f);
				}),
				(t.prototype.addVertexData = function (t, e, i) {
					for (
						var r = this.minX,
							s = this.minY,
							n = this.maxX,
							a = this.maxY,
							o = e;
						o < i;
						o += 2
					) {
						var h = t[o],
							u = t[o + 1];
						(r = h < r ? h : r),
							(s = u < s ? u : s),
							(n = h > n ? h : n),
							(a = u > a ? u : a);
					}
					(this.minX = r), (this.minY = s), (this.maxX = n), (this.maxY = a);
				}),
				(t.prototype.addVertices = function (t, e, i, r) {
					this.addVerticesMatrix(t.worldTransform, e, i, r);
				}),
				(t.prototype.addVerticesMatrix = function (t, e, i, r, s, n) {
					void 0 === s && (s = 0), void 0 === n && (n = s);
					for (
						var a = t.a,
							o = t.b,
							h = t.c,
							u = t.d,
							l = t.tx,
							c = t.ty,
							d = this.minX,
							p = this.minY,
							f = this.maxX,
							m = this.maxY,
							_ = i;
						_ < r;
						_ += 2
					) {
						var g = e[_],
							E = e[_ + 1],
							y = a * g + h * E + l,
							T = u * E + o * g + c;
						(d = Math.min(d, y - s)),
							(f = Math.max(f, y + s)),
							(p = Math.min(p, T - n)),
							(m = Math.max(m, T + n));
					}
					(this.minX = d), (this.minY = p), (this.maxX = f), (this.maxY = m);
				}),
				(t.prototype.addBounds = function (t) {
					var e = this.minX,
						i = this.minY,
						r = this.maxX,
						s = this.maxY;
					(this.minX = t.minX < e ? t.minX : e),
						(this.minY = t.minY < i ? t.minY : i),
						(this.maxX = t.maxX > r ? t.maxX : r),
						(this.maxY = t.maxY > s ? t.maxY : s);
				}),
				(t.prototype.addBoundsMask = function (t, e) {
					var i = t.minX > e.minX ? t.minX : e.minX,
						r = t.minY > e.minY ? t.minY : e.minY,
						s = t.maxX < e.maxX ? t.maxX : e.maxX,
						n = t.maxY < e.maxY ? t.maxY : e.maxY;
					if (i <= s && r <= n) {
						var a = this.minX,
							o = this.minY,
							h = this.maxX,
							u = this.maxY;
						(this.minX = i < a ? i : a),
							(this.minY = r < o ? r : o),
							(this.maxX = s > h ? s : h),
							(this.maxY = n > u ? n : u);
					}
				}),
				(t.prototype.addBoundsMatrix = function (t, e) {
					this.addFrameMatrix(e, t.minX, t.minY, t.maxX, t.maxY);
				}),
				(t.prototype.addBoundsArea = function (t, e) {
					var i = t.minX > e.x ? t.minX : e.x,
						r = t.minY > e.y ? t.minY : e.y,
						s = t.maxX < e.x + e.width ? t.maxX : e.x + e.width,
						n = t.maxY < e.y + e.height ? t.maxY : e.y + e.height;
					if (i <= s && r <= n) {
						var a = this.minX,
							o = this.minY,
							h = this.maxX,
							u = this.maxY;
						(this.minX = i < a ? i : a),
							(this.minY = r < o ? r : o),
							(this.maxX = s > h ? s : h),
							(this.maxY = n > u ? n : u);
					}
				}),
				(t.prototype.pad = function (t, e) {
					void 0 === t && (t = 0),
						void 0 === e && (e = t),
						this.isEmpty() ||
							((this.minX -= t),
							(this.maxX += t),
							(this.minY -= e),
							(this.maxY += e));
				}),
				(t.prototype.addFramePad = function (t, e, i, r, s, n) {
					(t -= s),
						(e -= n),
						(i += s),
						(r += n),
						(this.minX = this.minX < t ? this.minX : t),
						(this.maxX = this.maxX > i ? this.maxX : i),
						(this.minY = this.minY < e ? this.minY : e),
						(this.maxY = this.maxY > r ? this.maxY : r);
				}),
				t
			);
		})(),
		extendStatics$m = function (t, e) {
			return (extendStatics$m =
				Object.setPrototypeOf ||
				({ __proto__: [] } instanceof Array &&
					function (t, e) {
						t.__proto__ = e;
					}) ||
				function (t, e) {
					for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
				})(t, e);
		};
	function __extends$m(t, e) {
		function i() {
			this.constructor = t;
		}
		extendStatics$m(t, e),
			(t.prototype =
				null === e ? Object.create(e) : ((i.prototype = e.prototype), new i()));
	}
	var DisplayObject$1 = (function (t) {
			function e() {
				var e = t.call(this) || this;
				return (
					(e.tempDisplayObjectParent = null),
					(e.transform = new Transform$1()),
					(e.alpha = 1),
					(e.visible = !0),
					(e.renderable = !0),
					(e.cullable = !1),
					(e.cullArea = null),
					(e.parent = null),
					(e.worldAlpha = 1),
					(e._lastSortedIndex = 0),
					(e._zIndex = 0),
					(e.filterArea = null),
					(e.filters = null),
					(e._enabledFilters = null),
					(e._bounds = new Bounds$1()),
					(e._localBounds = null),
					(e._boundsID = 0),
					(e._boundsRect = null),
					(e._localBoundsRect = null),
					(e._mask = null),
					(e._maskRefCount = 0),
					(e._destroyed = !1),
					(e.isSprite = !1),
					(e.isMask = !1),
					e
				);
			}
			return (
				__extends$m(e, t),
				(e.mixin = function (t) {
					for (var i = Object.keys(t), r = 0; r < i.length; ++r) {
						var s = i[r];
						Object.defineProperty(
							e.prototype,
							s,
							Object.getOwnPropertyDescriptor(t, s)
						);
					}
				}),
				Object.defineProperty(e.prototype, 'destroyed', {
					get: function () {
						return this._destroyed;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype._recursivePostUpdateTransform = function () {
					this.parent
						? (this.parent._recursivePostUpdateTransform(),
						  this.transform.updateTransform(this.parent.transform))
						: this.transform.updateTransform(
								this._tempDisplayObjectParent.transform
						  );
				}),
				(e.prototype.updateTransform = function () {
					this._boundsID++,
						this.transform.updateTransform(this.parent.transform),
						(this.worldAlpha = this.alpha * this.parent.worldAlpha);
				}),
				(e.prototype.getBounds = function (t, e) {
					return (
						t ||
							(this.parent
								? (this._recursivePostUpdateTransform(), this.updateTransform())
								: ((this.parent = this._tempDisplayObjectParent),
								  this.updateTransform(),
								  (this.parent = null))),
						this._bounds.updateID !== this._boundsID &&
							(this.calculateBounds(),
							(this._bounds.updateID = this._boundsID)),
						e ||
							(this._boundsRect || (this._boundsRect = new Rectangle$4()),
							(e = this._boundsRect)),
						this._bounds.getRectangle(e)
					);
				}),
				(e.prototype.getLocalBounds = function (t) {
					t ||
						(this._localBoundsRect ||
							(this._localBoundsRect = new Rectangle$4()),
						(t = this._localBoundsRect)),
						this._localBounds || (this._localBounds = new Bounds$1());
					var e = this.transform,
						i = this.parent;
					(this.parent = null),
						(this.transform = this._tempDisplayObjectParent.transform);
					var r = this._bounds,
						s = this._boundsID;
					this._bounds = this._localBounds;
					var n = this.getBounds(!1, t);
					return (
						(this.parent = i),
						(this.transform = e),
						(this._bounds = r),
						(this._bounds.updateID += this._boundsID - s),
						n
					);
				}),
				(e.prototype.toGlobal = function (t, e, i) {
					return (
						void 0 === i && (i = !1),
						i ||
							(this._recursivePostUpdateTransform(),
							this.parent
								? this.displayObjectUpdateTransform()
								: ((this.parent = this._tempDisplayObjectParent),
								  this.displayObjectUpdateTransform(),
								  (this.parent = null))),
						this.worldTransform.apply(t, e)
					);
				}),
				(e.prototype.toLocal = function (t, e, i, r) {
					return (
						e && (t = e.toGlobal(t, i, r)),
						r ||
							(this._recursivePostUpdateTransform(),
							this.parent
								? this.displayObjectUpdateTransform()
								: ((this.parent = this._tempDisplayObjectParent),
								  this.displayObjectUpdateTransform(),
								  (this.parent = null))),
						this.worldTransform.applyInverse(t, i)
					);
				}),
				(e.prototype.setParent = function (t) {
					if (!t || !t.addChild)
						throw new Error('setParent: Argument must be a Container');
					return t.addChild(this), t;
				}),
				(e.prototype.setTransform = function (t, e, i, r, s, n, a, o, h) {
					return (
						void 0 === t && (t = 0),
						void 0 === e && (e = 0),
						void 0 === i && (i = 1),
						void 0 === r && (r = 1),
						void 0 === s && (s = 0),
						void 0 === n && (n = 0),
						void 0 === a && (a = 0),
						void 0 === o && (o = 0),
						void 0 === h && (h = 0),
						(this.position.x = t),
						(this.position.y = e),
						(this.scale.x = i || 1),
						(this.scale.y = r || 1),
						(this.rotation = s),
						(this.skew.x = n),
						(this.skew.y = a),
						(this.pivot.x = o),
						(this.pivot.y = h),
						this
					);
				}),
				(e.prototype.destroy = function (t) {
					this.parent && this.parent.removeChild(this),
						(this._destroyed = !0),
						(this.transform = null),
						(this.parent = null),
						(this._bounds = null),
						(this.mask = null),
						(this.cullArea = null),
						(this.filters = null),
						(this.filterArea = null),
						(this.hitArea = null),
						(this.interactive = !1),
						(this.interactiveChildren = !1),
						this.emit('destroyed'),
						this.removeAllListeners();
				}),
				Object.defineProperty(e.prototype, '_tempDisplayObjectParent', {
					get: function () {
						return (
							null === this.tempDisplayObjectParent &&
								(this.tempDisplayObjectParent = new TemporaryDisplayObject$1()),
							this.tempDisplayObjectParent
						);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.enableTempParent = function () {
					var t = this.parent;
					return (this.parent = this._tempDisplayObjectParent), t;
				}),
				(e.prototype.disableTempParent = function (t) {
					this.parent = t;
				}),
				Object.defineProperty(e.prototype, 'x', {
					get: function () {
						return this.position.x;
					},
					set: function (t) {
						this.transform.position.x = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'y', {
					get: function () {
						return this.position.y;
					},
					set: function (t) {
						this.transform.position.y = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'worldTransform', {
					get: function () {
						return this.transform.worldTransform;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'localTransform', {
					get: function () {
						return this.transform.localTransform;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'position', {
					get: function () {
						return this.transform.position;
					},
					set: function (t) {
						this.transform.position.copyFrom(t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'scale', {
					get: function () {
						return this.transform.scale;
					},
					set: function (t) {
						this.transform.scale.copyFrom(t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'pivot', {
					get: function () {
						return this.transform.pivot;
					},
					set: function (t) {
						this.transform.pivot.copyFrom(t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'skew', {
					get: function () {
						return this.transform.skew;
					},
					set: function (t) {
						this.transform.skew.copyFrom(t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'rotation', {
					get: function () {
						return this.transform.rotation;
					},
					set: function (t) {
						this.transform.rotation = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'angle', {
					get: function () {
						return this.transform.rotation * RAD_TO_DEG$1;
					},
					set: function (t) {
						this.transform.rotation = t * DEG_TO_RAD$1;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'zIndex', {
					get: function () {
						return this._zIndex;
					},
					set: function (t) {
						(this._zIndex = t), this.parent && (this.parent.sortDirty = !0);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'worldVisible', {
					get: function () {
						var t = this;
						do {
							if (!t.visible) return !1;
							t = t.parent;
						} while (t);
						return !0;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'mask', {
					get: function () {
						return this._mask;
					},
					set: function (t) {
						var e;
						this._mask !== t &&
							(this._mask &&
								((e = this._mask.maskObject || this._mask)._maskRefCount--,
								0 === e._maskRefCount &&
									((e.renderable = !0), (e.isMask = !1))),
							(this._mask = t),
							this._mask &&
								(0 ===
									(e = this._mask.maskObject || this._mask)._maskRefCount &&
									((e.renderable = !1), (e.isMask = !0)),
								e._maskRefCount++));
					},
					enumerable: !1,
					configurable: !0,
				}),
				e
			);
		})(eventemitter3$1),
		TemporaryDisplayObject$1 = (function (t) {
			function e() {
				var e = (null !== t && t.apply(this, arguments)) || this;
				return (e.sortDirty = null), e;
			}
			return __extends$m(e, t), e;
		})(DisplayObject$1),
		ENV$6,
		RENDERER_TYPE$6,
		BUFFER_BITS$6,
		BLEND_MODES$6,
		DRAW_MODES$6,
		FORMATS$6,
		TARGETS$6,
		TYPES$6,
		SAMPLER_TYPES$6,
		SCALE_MODES$6,
		WRAP_MODES$6,
		MIPMAP_MODES$6,
		ALPHA_MODES$6,
		CLEAR_MODES$6,
		GC_MODES$6,
		PRECISION$6,
		MASK_TYPES$6,
		MSAA_QUALITY$6,
		BUFFER_TYPE$6;
	function sortChildren$1(t, e) {
		return t.zIndex === e.zIndex
			? t._lastSortedIndex - e._lastSortedIndex
			: t.zIndex - e.zIndex;
	}
	(DisplayObject$1.prototype.displayObjectUpdateTransform =
		DisplayObject$1.prototype.updateTransform),
		(function (t) {
			(t[(t.WEBGL_LEGACY = 0)] = 'WEBGL_LEGACY'),
				(t[(t.WEBGL = 1)] = 'WEBGL'),
				(t[(t.WEBGL2 = 2)] = 'WEBGL2');
		})(ENV$6 || (ENV$6 = {})),
		(function (t) {
			(t[(t.UNKNOWN = 0)] = 'UNKNOWN'),
				(t[(t.WEBGL = 1)] = 'WEBGL'),
				(t[(t.CANVAS = 2)] = 'CANVAS');
		})(RENDERER_TYPE$6 || (RENDERER_TYPE$6 = {})),
		(function (t) {
			(t[(t.COLOR = 16384)] = 'COLOR'),
				(t[(t.DEPTH = 256)] = 'DEPTH'),
				(t[(t.STENCIL = 1024)] = 'STENCIL');
		})(BUFFER_BITS$6 || (BUFFER_BITS$6 = {})),
		(function (t) {
			(t[(t.NORMAL = 0)] = 'NORMAL'),
				(t[(t.ADD = 1)] = 'ADD'),
				(t[(t.MULTIPLY = 2)] = 'MULTIPLY'),
				(t[(t.SCREEN = 3)] = 'SCREEN'),
				(t[(t.OVERLAY = 4)] = 'OVERLAY'),
				(t[(t.DARKEN = 5)] = 'DARKEN'),
				(t[(t.LIGHTEN = 6)] = 'LIGHTEN'),
				(t[(t.COLOR_DODGE = 7)] = 'COLOR_DODGE'),
				(t[(t.COLOR_BURN = 8)] = 'COLOR_BURN'),
				(t[(t.HARD_LIGHT = 9)] = 'HARD_LIGHT'),
				(t[(t.SOFT_LIGHT = 10)] = 'SOFT_LIGHT'),
				(t[(t.DIFFERENCE = 11)] = 'DIFFERENCE'),
				(t[(t.EXCLUSION = 12)] = 'EXCLUSION'),
				(t[(t.HUE = 13)] = 'HUE'),
				(t[(t.SATURATION = 14)] = 'SATURATION'),
				(t[(t.COLOR = 15)] = 'COLOR'),
				(t[(t.LUMINOSITY = 16)] = 'LUMINOSITY'),
				(t[(t.NORMAL_NPM = 17)] = 'NORMAL_NPM'),
				(t[(t.ADD_NPM = 18)] = 'ADD_NPM'),
				(t[(t.SCREEN_NPM = 19)] = 'SCREEN_NPM'),
				(t[(t.NONE = 20)] = 'NONE'),
				(t[(t.SRC_OVER = 0)] = 'SRC_OVER'),
				(t[(t.SRC_IN = 21)] = 'SRC_IN'),
				(t[(t.SRC_OUT = 22)] = 'SRC_OUT'),
				(t[(t.SRC_ATOP = 23)] = 'SRC_ATOP'),
				(t[(t.DST_OVER = 24)] = 'DST_OVER'),
				(t[(t.DST_IN = 25)] = 'DST_IN'),
				(t[(t.DST_OUT = 26)] = 'DST_OUT'),
				(t[(t.DST_ATOP = 27)] = 'DST_ATOP'),
				(t[(t.ERASE = 26)] = 'ERASE'),
				(t[(t.SUBTRACT = 28)] = 'SUBTRACT'),
				(t[(t.XOR = 29)] = 'XOR');
		})(BLEND_MODES$6 || (BLEND_MODES$6 = {})),
		(function (t) {
			(t[(t.POINTS = 0)] = 'POINTS'),
				(t[(t.LINES = 1)] = 'LINES'),
				(t[(t.LINE_LOOP = 2)] = 'LINE_LOOP'),
				(t[(t.LINE_STRIP = 3)] = 'LINE_STRIP'),
				(t[(t.TRIANGLES = 4)] = 'TRIANGLES'),
				(t[(t.TRIANGLE_STRIP = 5)] = 'TRIANGLE_STRIP'),
				(t[(t.TRIANGLE_FAN = 6)] = 'TRIANGLE_FAN');
		})(DRAW_MODES$6 || (DRAW_MODES$6 = {})),
		(function (t) {
			(t[(t.RGBA = 6408)] = 'RGBA'),
				(t[(t.RGB = 6407)] = 'RGB'),
				(t[(t.RG = 33319)] = 'RG'),
				(t[(t.RED = 6403)] = 'RED'),
				(t[(t.RGBA_INTEGER = 36249)] = 'RGBA_INTEGER'),
				(t[(t.RGB_INTEGER = 36248)] = 'RGB_INTEGER'),
				(t[(t.RG_INTEGER = 33320)] = 'RG_INTEGER'),
				(t[(t.RED_INTEGER = 36244)] = 'RED_INTEGER'),
				(t[(t.ALPHA = 6406)] = 'ALPHA'),
				(t[(t.LUMINANCE = 6409)] = 'LUMINANCE'),
				(t[(t.LUMINANCE_ALPHA = 6410)] = 'LUMINANCE_ALPHA'),
				(t[(t.DEPTH_COMPONENT = 6402)] = 'DEPTH_COMPONENT'),
				(t[(t.DEPTH_STENCIL = 34041)] = 'DEPTH_STENCIL');
		})(FORMATS$6 || (FORMATS$6 = {})),
		(function (t) {
			(t[(t.TEXTURE_2D = 3553)] = 'TEXTURE_2D'),
				(t[(t.TEXTURE_CUBE_MAP = 34067)] = 'TEXTURE_CUBE_MAP'),
				(t[(t.TEXTURE_2D_ARRAY = 35866)] = 'TEXTURE_2D_ARRAY'),
				(t[(t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069)] =
					'TEXTURE_CUBE_MAP_POSITIVE_X'),
				(t[(t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070)] =
					'TEXTURE_CUBE_MAP_NEGATIVE_X'),
				(t[(t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071)] =
					'TEXTURE_CUBE_MAP_POSITIVE_Y'),
				(t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072)] =
					'TEXTURE_CUBE_MAP_NEGATIVE_Y'),
				(t[(t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073)] =
					'TEXTURE_CUBE_MAP_POSITIVE_Z'),
				(t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074)] =
					'TEXTURE_CUBE_MAP_NEGATIVE_Z');
		})(TARGETS$6 || (TARGETS$6 = {})),
		(function (t) {
			(t[(t.UNSIGNED_BYTE = 5121)] = 'UNSIGNED_BYTE'),
				(t[(t.UNSIGNED_SHORT = 5123)] = 'UNSIGNED_SHORT'),
				(t[(t.UNSIGNED_SHORT_5_6_5 = 33635)] = 'UNSIGNED_SHORT_5_6_5'),
				(t[(t.UNSIGNED_SHORT_4_4_4_4 = 32819)] = 'UNSIGNED_SHORT_4_4_4_4'),
				(t[(t.UNSIGNED_SHORT_5_5_5_1 = 32820)] = 'UNSIGNED_SHORT_5_5_5_1'),
				(t[(t.UNSIGNED_INT = 5125)] = 'UNSIGNED_INT'),
				(t[(t.UNSIGNED_INT_10F_11F_11F_REV = 35899)] =
					'UNSIGNED_INT_10F_11F_11F_REV'),
				(t[(t.UNSIGNED_INT_2_10_10_10_REV = 33640)] =
					'UNSIGNED_INT_2_10_10_10_REV'),
				(t[(t.UNSIGNED_INT_24_8 = 34042)] = 'UNSIGNED_INT_24_8'),
				(t[(t.UNSIGNED_INT_5_9_9_9_REV = 35902)] = 'UNSIGNED_INT_5_9_9_9_REV'),
				(t[(t.BYTE = 5120)] = 'BYTE'),
				(t[(t.SHORT = 5122)] = 'SHORT'),
				(t[(t.INT = 5124)] = 'INT'),
				(t[(t.FLOAT = 5126)] = 'FLOAT'),
				(t[(t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269)] =
					'FLOAT_32_UNSIGNED_INT_24_8_REV'),
				(t[(t.HALF_FLOAT = 36193)] = 'HALF_FLOAT');
		})(TYPES$6 || (TYPES$6 = {})),
		(function (t) {
			(t[(t.FLOAT = 0)] = 'FLOAT'),
				(t[(t.INT = 1)] = 'INT'),
				(t[(t.UINT = 2)] = 'UINT');
		})(SAMPLER_TYPES$6 || (SAMPLER_TYPES$6 = {})),
		(function (t) {
			(t[(t.NEAREST = 0)] = 'NEAREST'), (t[(t.LINEAR = 1)] = 'LINEAR');
		})(SCALE_MODES$6 || (SCALE_MODES$6 = {})),
		(function (t) {
			(t[(t.CLAMP = 33071)] = 'CLAMP'),
				(t[(t.REPEAT = 10497)] = 'REPEAT'),
				(t[(t.MIRRORED_REPEAT = 33648)] = 'MIRRORED_REPEAT');
		})(WRAP_MODES$6 || (WRAP_MODES$6 = {})),
		(function (t) {
			(t[(t.OFF = 0)] = 'OFF'),
				(t[(t.POW2 = 1)] = 'POW2'),
				(t[(t.ON = 2)] = 'ON'),
				(t[(t.ON_MANUAL = 3)] = 'ON_MANUAL');
		})(MIPMAP_MODES$6 || (MIPMAP_MODES$6 = {})),
		(function (t) {
			(t[(t.NPM = 0)] = 'NPM'),
				(t[(t.UNPACK = 1)] = 'UNPACK'),
				(t[(t.PMA = 2)] = 'PMA'),
				(t[(t.NO_PREMULTIPLIED_ALPHA = 0)] = 'NO_PREMULTIPLIED_ALPHA'),
				(t[(t.PREMULTIPLY_ON_UPLOAD = 1)] = 'PREMULTIPLY_ON_UPLOAD'),
				(t[(t.PREMULTIPLY_ALPHA = 2)] = 'PREMULTIPLY_ALPHA'),
				(t[(t.PREMULTIPLIED_ALPHA = 2)] = 'PREMULTIPLIED_ALPHA');
		})(ALPHA_MODES$6 || (ALPHA_MODES$6 = {})),
		(function (t) {
			(t[(t.NO = 0)] = 'NO'),
				(t[(t.YES = 1)] = 'YES'),
				(t[(t.AUTO = 2)] = 'AUTO'),
				(t[(t.BLEND = 0)] = 'BLEND'),
				(t[(t.CLEAR = 1)] = 'CLEAR'),
				(t[(t.BLIT = 2)] = 'BLIT');
		})(CLEAR_MODES$6 || (CLEAR_MODES$6 = {})),
		(function (t) {
			(t[(t.AUTO = 0)] = 'AUTO'), (t[(t.MANUAL = 1)] = 'MANUAL');
		})(GC_MODES$6 || (GC_MODES$6 = {})),
		(function (t) {
			(t.LOW = 'lowp'), (t.MEDIUM = 'mediump'), (t.HIGH = 'highp');
		})(PRECISION$6 || (PRECISION$6 = {})),
		(function (t) {
			(t[(t.NONE = 0)] = 'NONE'),
				(t[(t.SCISSOR = 1)] = 'SCISSOR'),
				(t[(t.STENCIL = 2)] = 'STENCIL'),
				(t[(t.SPRITE = 3)] = 'SPRITE');
		})(MASK_TYPES$6 || (MASK_TYPES$6 = {})),
		(function (t) {
			(t[(t.NONE = 0)] = 'NONE'),
				(t[(t.LOW = 2)] = 'LOW'),
				(t[(t.MEDIUM = 4)] = 'MEDIUM'),
				(t[(t.HIGH = 8)] = 'HIGH');
		})(MSAA_QUALITY$6 || (MSAA_QUALITY$6 = {})),
		(function (t) {
			(t[(t.ELEMENT_ARRAY_BUFFER = 34963)] = 'ELEMENT_ARRAY_BUFFER'),
				(t[(t.ARRAY_BUFFER = 34962)] = 'ARRAY_BUFFER'),
				(t[(t.UNIFORM_BUFFER = 35345)] = 'UNIFORM_BUFFER');
		})(BUFFER_TYPE$6 || (BUFFER_TYPE$6 = {}));
	var Container$1 = (function (t) {
		function e() {
			var e = t.call(this) || this;
			return (
				(e.children = []),
				(e.sortableChildren = settings$3.SORTABLE_CHILDREN),
				(e.sortDirty = !1),
				e
			);
		}
		return (
			__extends$m(e, t),
			(e.prototype.onChildrenChange = function (t) {}),
			(e.prototype.addChild = function () {
				for (var t = arguments, e = [], i = 0; i < arguments.length; i++)
					e[i] = t[i];
				if (e.length > 1)
					for (var r = 0; r < e.length; r++) this.addChild(e[r]);
				else {
					var s = e[0];
					s.parent && s.parent.removeChild(s),
						(s.parent = this),
						(this.sortDirty = !0),
						(s.transform._parentID = -1),
						this.children.push(s),
						this._boundsID++,
						this.onChildrenChange(this.children.length - 1),
						this.emit('childAdded', s, this, this.children.length - 1),
						s.emit('added', this);
				}
				return e[0];
			}),
			(e.prototype.addChildAt = function (t, e) {
				if (e < 0 || e > this.children.length)
					throw new Error(
						t +
							'addChildAt: The index ' +
							e +
							' supplied is out of bounds ' +
							this.children.length
					);
				return (
					t.parent && t.parent.removeChild(t),
					(t.parent = this),
					(this.sortDirty = !0),
					(t.transform._parentID = -1),
					this.children.splice(e, 0, t),
					this._boundsID++,
					this.onChildrenChange(e),
					t.emit('added', this),
					this.emit('childAdded', t, this, e),
					t
				);
			}),
			(e.prototype.swapChildren = function (t, e) {
				if (t !== e) {
					var i = this.getChildIndex(t),
						r = this.getChildIndex(e);
					(this.children[i] = e),
						(this.children[r] = t),
						this.onChildrenChange(i < r ? i : r);
				}
			}),
			(e.prototype.getChildIndex = function (t) {
				var e = this.children.indexOf(t);
				if (-1 === e)
					throw new Error(
						'The supplied DisplayObject must be a child of the caller'
					);
				return e;
			}),
			(e.prototype.setChildIndex = function (t, e) {
				if (e < 0 || e >= this.children.length)
					throw new Error(
						'The index ' +
							e +
							' supplied is out of bounds ' +
							this.children.length
					);
				var i = this.getChildIndex(t);
				removeItems$3(this.children, i, 1),
					this.children.splice(e, 0, t),
					this.onChildrenChange(e);
			}),
			(e.prototype.getChildAt = function (t) {
				if (t < 0 || t >= this.children.length)
					throw new Error('getChildAt: Index (' + t + ') does not exist.');
				return this.children[t];
			}),
			(e.prototype.removeChild = function () {
				for (var t = arguments, e = [], i = 0; i < arguments.length; i++)
					e[i] = t[i];
				if (e.length > 1)
					for (var r = 0; r < e.length; r++) this.removeChild(e[r]);
				else {
					var s = e[0],
						n = this.children.indexOf(s);
					if (-1 === n) return null;
					(s.parent = null),
						(s.transform._parentID = -1),
						removeItems$3(this.children, n, 1),
						this._boundsID++,
						this.onChildrenChange(n),
						s.emit('removed', this),
						this.emit('childRemoved', s, this, n);
				}
				return e[0];
			}),
			(e.prototype.removeChildAt = function (t) {
				var e = this.getChildAt(t);
				return (
					(e.parent = null),
					(e.transform._parentID = -1),
					removeItems$3(this.children, t, 1),
					this._boundsID++,
					this.onChildrenChange(t),
					e.emit('removed', this),
					this.emit('childRemoved', e, this, t),
					e
				);
			}),
			(e.prototype.removeChildren = function (t, e) {
				void 0 === t && (t = 0), void 0 === e && (e = this.children.length);
				var i,
					r = t,
					s = e - r;
				if (s > 0 && s <= e) {
					i = this.children.splice(r, s);
					for (var n = 0; n < i.length; ++n)
						(i[n].parent = null),
							i[n].transform && (i[n].transform._parentID = -1);
					for (
						this._boundsID++, this.onChildrenChange(t), n = 0;
						n < i.length;
						++n
					)
						i[n].emit('removed', this),
							this.emit('childRemoved', i[n], this, n);
					return i;
				}
				if (0 === s && 0 === this.children.length) return [];
				throw new RangeError(
					'removeChildren: numeric values are outside the acceptable range.'
				);
			}),
			(e.prototype.sortChildren = function () {
				for (var t = !1, e = 0, i = this.children.length; e < i; ++e) {
					var r = this.children[e];
					(r._lastSortedIndex = e), t || 0 === r.zIndex || (t = !0);
				}
				t && this.children.length > 1 && this.children.sort(sortChildren$1),
					(this.sortDirty = !1);
			}),
			(e.prototype.updateTransform = function () {
				this.sortableChildren && this.sortDirty && this.sortChildren(),
					this._boundsID++,
					this.transform.updateTransform(this.parent.transform),
					(this.worldAlpha = this.alpha * this.parent.worldAlpha);
				for (var t = 0, e = this.children.length; t < e; ++t) {
					var i = this.children[t];
					i.visible && i.updateTransform();
				}
			}),
			(e.prototype.calculateBounds = function () {
				this._bounds.clear(), this._calculateBounds();
				for (var t = 0; t < this.children.length; t++) {
					var e = this.children[t];
					if (e.visible && e.renderable)
						if ((e.calculateBounds(), e._mask)) {
							var i = e._mask.maskObject || e._mask;
							i.calculateBounds(),
								this._bounds.addBoundsMask(e._bounds, i._bounds);
						} else
							e.filterArea
								? this._bounds.addBoundsArea(e._bounds, e.filterArea)
								: this._bounds.addBounds(e._bounds);
				}
				this._bounds.updateID = this._boundsID;
			}),
			(e.prototype.getLocalBounds = function (e, i) {
				void 0 === i && (i = !1);
				var r = t.prototype.getLocalBounds.call(this, e);
				if (!i)
					for (var s = 0, n = this.children.length; s < n; ++s) {
						var a = this.children[s];
						a.visible && a.updateTransform();
					}
				return r;
			}),
			(e.prototype._calculateBounds = function () {}),
			(e.prototype._renderWithCulling = function (t) {
				var i = t.renderTexture.sourceFrame;
				if (i.width > 0 && i.height > 0) {
					var r, s;
					if (
						(this.cullArea
							? ((r = this.cullArea), (s = this.worldTransform))
							: this._render !== e.prototype._render &&
							  (r = this.getBounds(!0)),
						r && i.intersects(r, s))
					)
						this._render(t);
					else if (this.cullArea) return;
					for (var n = 0, a = this.children.length; n < a; ++n) {
						var o = this.children[n],
							h = o.cullable;
						(o.cullable = h || !this.cullArea), o.render(t), (o.cullable = h);
					}
				}
			}),
			(e.prototype.render = function (t) {
				if (this.visible && !(this.worldAlpha <= 0) && this.renderable)
					if (this._mask || (this.filters && this.filters.length))
						this.renderAdvanced(t);
					else if (this.cullable) this._renderWithCulling(t);
					else {
						this._render(t);
						for (var e = 0, i = this.children.length; e < i; ++e)
							this.children[e].render(t);
					}
			}),
			(e.prototype.renderAdvanced = function (t) {
				var e = this.filters,
					i = this._mask;
				if (e) {
					this._enabledFilters || (this._enabledFilters = []),
						(this._enabledFilters.length = 0);
					for (var r = 0; r < e.length; r++)
						e[r].enabled && this._enabledFilters.push(e[r]);
				}
				var s =
					(e && this._enabledFilters && this._enabledFilters.length) ||
					(i &&
						(!i.isMaskData ||
							(i.enabled && (i.autoDetect || i.type !== MASK_TYPES$6.NONE))));
				if (
					(s && t.batch.flush(),
					e &&
						this._enabledFilters &&
						this._enabledFilters.length &&
						t.filter.push(this, this._enabledFilters),
					i && t.mask.push(this, this._mask),
					this.cullable)
				)
					this._renderWithCulling(t);
				else {
					this._render(t), (r = 0);
					for (var n = this.children.length; r < n; ++r)
						this.children[r].render(t);
				}
				s && t.batch.flush(),
					i && t.mask.pop(this),
					e &&
						this._enabledFilters &&
						this._enabledFilters.length &&
						t.filter.pop();
			}),
			(e.prototype._render = function (t) {}),
			(e.prototype.destroy = function (e) {
				t.prototype.destroy.call(this), (this.sortDirty = !1);
				var i = 'boolean' == typeof e ? e : e && e.children,
					r = this.removeChildren(0, this.children.length);
				if (i) for (var s = 0; s < r.length; ++s) r[s].destroy(e);
			}),
			Object.defineProperty(e.prototype, 'width', {
				get: function () {
					return this.scale.x * this.getLocalBounds().width;
				},
				set: function (t) {
					var e = this.getLocalBounds().width;
					(this.scale.x = 0 !== e ? t / e : 1), (this._width = t);
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(e.prototype, 'height', {
				get: function () {
					return this.scale.y * this.getLocalBounds().height;
				},
				set: function (t) {
					var e = this.getLocalBounds().height;
					(this.scale.y = 0 !== e ? t / e : 1), (this._height = t);
				},
				enumerable: !1,
				configurable: !0,
			}),
			e
		);
	})(DisplayObject$1);
	Container$1.prototype.containerUpdateTransform =
		Container$1.prototype.updateTransform;
	var TEMP_RECT$1 = new Rectangle$4(),
		BYTES_PER_PIXEL = 4,
		Extract = (function () {
			function t(t) {
				this.renderer = t;
			}
			return (
				(t.prototype.image = function (t, e, i) {
					var r = new Image();
					return (r.src = this.base64(t, e, i)), r;
				}),
				(t.prototype.base64 = function (t, e, i) {
					return this.canvas(t).toDataURL(e, i);
				}),
				(t.prototype.canvas = function (e) {
					var i,
						r,
						s,
						n = this.renderer,
						a = !1,
						o = !1;
					e &&
						(e instanceof RenderTexture$3
							? (s = e)
							: ((s = this.renderer.generateTexture(e)), (o = !0))),
						s
							? ((i = s.baseTexture.resolution),
							  (r = s.frame),
							  (a = !1),
							  n.renderTexture.bind(s))
							: ((i = this.renderer.resolution),
							  (a = !0),
							  ((r = TEMP_RECT$1).width = this.renderer.width),
							  (r.height = this.renderer.height),
							  n.renderTexture.bind(null));
					var h = Math.floor(r.width * i + 1e-4),
						u = Math.floor(r.height * i + 1e-4),
						l = new CanvasRenderTarget(h, u, 1),
						c = new Uint8Array(BYTES_PER_PIXEL * h * u),
						d = n.gl;
					d.readPixels(r.x * i, r.y * i, h, u, d.RGBA, d.UNSIGNED_BYTE, c);
					var p = l.context.getImageData(0, 0, h, u);
					if (
						(t.arrayPostDivide(c, p.data), l.context.putImageData(p, 0, 0), a)
					) {
						var f = new CanvasRenderTarget(l.width, l.height, 1);
						f.context.scale(1, -1),
							f.context.drawImage(l.canvas, 0, -u),
							l.destroy(),
							(l = f);
					}
					return o && s.destroy(!0), l.canvas;
				}),
				(t.prototype.pixels = function (e, i) {
					var r,
						s,
						n,
						a = this.renderer,
						o = !1;
					e &&
						(e instanceof RenderTexture$3
							? (n = e)
							: e instanceof DisplayObject$1 &&
							  ((n = this.renderer.generateTexture(e)), (o = !0))),
						n
							? i
								? ((r = i.resolution), (s = n.frame), a.renderTexture.bind(n))
								: ((r = n.baseTexture.resolution),
								  (s = n.frame),
								  a.renderTexture.bind(n))
							: i
							? ((r = i.resolution),
							  ((s = TEMP_RECT$1).width = i.width),
							  (s.height = i.height),
							  a.renderTexture.bind(null))
							: ((r = a.resolution),
							  ((s = TEMP_RECT$1).width = a.width),
							  (s.height = a.height),
							  a.renderTexture.bind(null));
					var h = s.width * r,
						u = s.height * r,
						l = new Uint8Array(BYTES_PER_PIXEL * h * u),
						c = a.gl;
					return (
						c.readPixels(s.x * r, s.y * r, h, u, c.RGBA, c.UNSIGNED_BYTE, l),
						o && n.destroy(!0),
						t.arrayPostDivide(l, l),
						l
					);
				}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				(t.arrayPostDivide = function (t, e) {
					for (var i = 0; i < t.length; i += 4) {
						var r = (e[i + 3] = t[i + 3]);
						0 !== r
							? ((e[i] = Math.round(Math.min((255 * t[i]) / r, 255))),
							  (e[i + 1] = Math.round(Math.min((255 * t[i + 1]) / r, 255))),
							  (e[i + 2] = Math.round(Math.min((255 * t[i + 2]) / r, 255))))
							: ((e[i] = t[i]), (e[i + 1] = t[i + 1]), (e[i + 2] = t[i + 2]));
					}
				}),
				t
			);
		})(),
		extendStatics$l = function (t, e) {
			return (extendStatics$l =
				Object.setPrototypeOf ||
				({ __proto__: [] } instanceof Array &&
					function (t, e) {
						t.__proto__ = e;
					}) ||
				function (t, e) {
					for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
				})(t, e);
		};
	function __extends$l(t, e) {
		function i() {
			this.constructor = t;
		}
		extendStatics$l(t, e),
			(t.prototype =
				null === e ? Object.create(e) : ((i.prototype = e.prototype), new i()));
	}
	var MeshBatchUvs = (function () {
			function t(t, e) {
				(this.uvBuffer = t),
					(this.uvMatrix = e),
					(this.data = null),
					(this._bufferUpdateId = -1),
					(this._textureUpdateId = -1),
					(this._updateID = 0);
			}
			return (
				(t.prototype.update = function (t) {
					if (
						t ||
						this._bufferUpdateId !== this.uvBuffer._updateID ||
						this._textureUpdateId !== this.uvMatrix._updateID
					) {
						(this._bufferUpdateId = this.uvBuffer._updateID),
							(this._textureUpdateId = this.uvMatrix._updateID);
						var e = this.uvBuffer.data;
						(this.data && this.data.length === e.length) ||
							(this.data = new Float32Array(e.length)),
							this.uvMatrix.multiplyUvs(e, this.data),
							this._updateID++;
					}
				}),
				t
			);
		})(),
		tempPoint$2 = new Point$4(),
		tempPolygon = new Polygon(),
		Mesh = (function (t) {
			function e(e, i, r, s) {
				void 0 === s && (s = DRAW_MODES$9.TRIANGLES);
				var n = t.call(this) || this;
				return (
					(n.geometry = e),
					(n.shader = i),
					(n.state = r || State$3.for2d()),
					(n.drawMode = s),
					(n.start = 0),
					(n.size = 0),
					(n.uvs = null),
					(n.indices = null),
					(n.vertexData = new Float32Array(1)),
					(n.vertexDirty = -1),
					(n._transformID = -1),
					(n._roundPixels = settings$4.ROUND_PIXELS),
					(n.batchUvs = null),
					n
				);
			}
			return (
				__extends$l(e, t),
				Object.defineProperty(e.prototype, 'geometry', {
					get: function () {
						return this._geometry;
					},
					set: function (t) {
						this._geometry !== t &&
							(this._geometry &&
								(this._geometry.refCount--,
								0 === this._geometry.refCount && this._geometry.dispose()),
							(this._geometry = t),
							this._geometry && this._geometry.refCount++,
							(this.vertexDirty = -1));
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'uvBuffer', {
					get: function () {
						return this.geometry.buffers[1];
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'verticesBuffer', {
					get: function () {
						return this.geometry.buffers[0];
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'material', {
					get: function () {
						return this.shader;
					},
					set: function (t) {
						this.shader = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'blendMode', {
					get: function () {
						return this.state.blendMode;
					},
					set: function (t) {
						this.state.blendMode = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'roundPixels', {
					get: function () {
						return this._roundPixels;
					},
					set: function (t) {
						this._roundPixels !== t && (this._transformID = -1),
							(this._roundPixels = t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'tint', {
					get: function () {
						return 'tint' in this.shader ? this.shader.tint : null;
					},
					set: function (t) {
						this.shader.tint = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'texture', {
					get: function () {
						return 'texture' in this.shader ? this.shader.texture : null;
					},
					set: function (t) {
						this.shader.texture = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype._render = function (t) {
					var i = this.geometry.buffers[0].data;
					this.shader.batchable &&
					this.drawMode === DRAW_MODES$9.TRIANGLES &&
					i.length < 2 * e.BATCHABLE_SIZE
						? this._renderToBatch(t)
						: this._renderDefault(t);
				}),
				(e.prototype._renderDefault = function (t) {
					var e = this.shader;
					(e.alpha = this.worldAlpha),
						e.update && e.update(),
						t.batch.flush(),
						(e.uniforms.translationMatrix =
							this.transform.worldTransform.toArray(!0)),
						t.shader.bind(e),
						t.state.set(this.state),
						t.geometry.bind(this.geometry, e),
						t.geometry.draw(
							this.drawMode,
							this.size,
							this.start,
							this.geometry.instanceCount
						);
				}),
				(e.prototype._renderToBatch = function (t) {
					var e = this.geometry,
						i = this.shader;
					i.uvMatrix && (i.uvMatrix.update(), this.calculateUvs()),
						this.calculateVertices(),
						(this.indices = e.indexBuffer.data),
						(this._tintRGB = i._tintRGB),
						(this._texture = i.texture);
					var r = this.material.pluginName;
					t.batch.setObjectRenderer(t.plugins[r]), t.plugins[r].render(this);
				}),
				(e.prototype.calculateVertices = function () {
					var t = this.geometry.buffers[0],
						e = t.data,
						i = t._updateID;
					if (
						i !== this.vertexDirty ||
						this._transformID !== this.transform._worldID
					) {
						(this._transformID = this.transform._worldID),
							this.vertexData.length !== e.length &&
								(this.vertexData = new Float32Array(e.length));
						for (
							var r = this.transform.worldTransform,
								s = r.a,
								n = r.b,
								a = r.c,
								o = r.d,
								h = r.tx,
								u = r.ty,
								l = this.vertexData,
								c = 0;
							c < l.length / 2;
							c++
						) {
							var d = e[2 * c],
								p = e[2 * c + 1];
							(l[2 * c] = s * d + a * p + h),
								(l[2 * c + 1] = n * d + o * p + u);
						}
						if (this._roundPixels) {
							var f = settings$4.RESOLUTION;
							for (c = 0; c < l.length; ++c)
								l[c] = Math.round(((l[c] * f) | 0) / f);
						}
						this.vertexDirty = i;
					}
				}),
				(e.prototype.calculateUvs = function () {
					var t = this.geometry.buffers[1],
						e = this.shader;
					e.uvMatrix.isSimple
						? (this.uvs = t.data)
						: (this.batchUvs ||
								(this.batchUvs = new MeshBatchUvs(t, e.uvMatrix)),
						  this.batchUvs.update(),
						  (this.uvs = this.batchUvs.data));
				}),
				(e.prototype._calculateBounds = function () {
					this.calculateVertices(),
						this._bounds.addVertexData(
							this.vertexData,
							0,
							this.vertexData.length
						);
				}),
				(e.prototype.containsPoint = function (t) {
					if (!this.getBounds().contains(t.x, t.y)) return !1;
					this.worldTransform.applyInverse(t, tempPoint$2);
					for (
						var e = this.geometry.getBuffer('aVertexPosition').data,
							i = tempPolygon.points,
							r = this.geometry.getIndex().data,
							s = r.length,
							n = 4 === this.drawMode ? 3 : 1,
							a = 0;
						a + 2 < s;
						a += n
					) {
						var o = 2 * r[a],
							h = 2 * r[a + 1],
							u = 2 * r[a + 2];
						if (
							((i[0] = e[o]),
							(i[1] = e[o + 1]),
							(i[2] = e[h]),
							(i[3] = e[h + 1]),
							(i[4] = e[u]),
							(i[5] = e[u + 1]),
							tempPolygon.contains(tempPoint$2.x, tempPoint$2.y))
						)
							return !0;
					}
					return !1;
				}),
				(e.prototype.destroy = function (e) {
					t.prototype.destroy.call(this, e),
						this._cachedTexture &&
							(this._cachedTexture.destroy(), (this._cachedTexture = null)),
						(this.geometry = null),
						(this.shader = null),
						(this.state = null),
						(this.uvs = null),
						(this.indices = null),
						(this.vertexData = null);
				}),
				(e.BATCHABLE_SIZE = 100),
				e
			);
		})(Container$2),
		fragment$d =
			'varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n',
		vertex$b =
			'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n',
		MeshMaterial = (function (t) {
			function e(e, i) {
				var r = this,
					s = {
						uSampler: e,
						alpha: 1,
						uTextureMatrix: Matrix$3.IDENTITY,
						uColor: new Float32Array([1, 1, 1, 1]),
					};
				return (
					(i = Object.assign(
						{ tint: 16777215, alpha: 1, pluginName: 'batch' },
						i
					)).uniforms && Object.assign(s, i.uniforms),
					((r =
						t.call(
							this,
							i.program || Program$3.from(vertex$b, fragment$d),
							s
						) || this)._colorDirty = !1),
					(r.uvMatrix = new TextureMatrix$3(e)),
					(r.batchable = void 0 === i.program),
					(r.pluginName = i.pluginName),
					(r.tint = i.tint),
					(r.alpha = i.alpha),
					r
				);
			}
			return (
				__extends$l(e, t),
				Object.defineProperty(e.prototype, 'texture', {
					get: function () {
						return this.uniforms.uSampler;
					},
					set: function (t) {
						this.uniforms.uSampler !== t &&
							(!this.uniforms.uSampler.baseTexture.alphaMode !=
								!t.baseTexture.alphaMode && (this._colorDirty = !0),
							(this.uniforms.uSampler = t),
							(this.uvMatrix.texture = t));
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'alpha', {
					get: function () {
						return this._alpha;
					},
					set: function (t) {
						t !== this._alpha && ((this._alpha = t), (this._colorDirty = !0));
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'tint', {
					get: function () {
						return this._tint;
					},
					set: function (t) {
						t !== this._tint &&
							((this._tint = t),
							(this._tintRGB = (t >> 16) + (65280 & t) + ((255 & t) << 16)),
							(this._colorDirty = !0));
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.update = function () {
					if (this._colorDirty) {
						this._colorDirty = !1;
						var t = this.texture.baseTexture;
						premultiplyTintToRgba(
							this._tint,
							this._alpha,
							this.uniforms.uColor,
							t.alphaMode
						);
					}
					this.uvMatrix.update() &&
						(this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord);
				}),
				e
			);
		})(Shader$3),
		MeshGeometry = (function (t) {
			function e(e, i, r) {
				var s = t.call(this) || this,
					n = new Buffer$3(e),
					a = new Buffer$3(i, !0),
					o = new Buffer$3(r, !0, !0);
				return (
					s
						.addAttribute('aVertexPosition', n, 2, !1, TYPES$9.FLOAT)
						.addAttribute('aTextureCoord', a, 2, !1, TYPES$9.FLOAT)
						.addIndex(o),
					(s._updateId = -1),
					s
				);
			}
			return (
				__extends$l(e, t),
				Object.defineProperty(e.prototype, 'vertexDirtyId', {
					get: function () {
						return this.buffers[0]._updateID;
					},
					enumerable: !1,
					configurable: !0,
				}),
				e
			);
		})(Geometry$3),
		extendStatics$k = function (t, e) {
			return (extendStatics$k =
				Object.setPrototypeOf ||
				({ __proto__: [] } instanceof Array &&
					function (t, e) {
						t.__proto__ = e;
					}) ||
				function (t, e) {
					for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
				})(t, e);
		};
	function __extends$k(t, e) {
		function i() {
			this.constructor = t;
		}
		extendStatics$k(t, e),
			(t.prototype =
				null === e ? Object.create(e) : ((i.prototype = e.prototype), new i()));
	}
	var tempPoint$1 = new Point$4(),
		indices = new Uint16Array([0, 1, 2, 0, 2, 3]),
		Sprite$1 = (function (t) {
			function e(e) {
				var i = t.call(this) || this;
				return (
					(i._anchor = new ObservablePoint$3(
						i._onAnchorUpdate,
						i,
						e ? e.defaultAnchor.x : 0,
						e ? e.defaultAnchor.y : 0
					)),
					(i._texture = null),
					(i._width = 0),
					(i._height = 0),
					(i._tint = null),
					(i._tintRGB = null),
					(i.tint = 16777215),
					(i.blendMode = BLEND_MODES$9.NORMAL),
					(i._cachedTint = 16777215),
					(i.uvs = null),
					(i.texture = e || Texture$3.EMPTY),
					(i.vertexData = new Float32Array(8)),
					(i.vertexTrimmedData = null),
					(i._transformID = -1),
					(i._textureID = -1),
					(i._transformTrimmedID = -1),
					(i._textureTrimmedID = -1),
					(i.indices = indices),
					(i.pluginName = 'batch'),
					(i.isSprite = !0),
					(i._roundPixels = settings$4.ROUND_PIXELS),
					i
				);
			}
			return (
				__extends$k(e, t),
				(e.prototype._onTextureUpdate = function () {
					(this._textureID = -1),
						(this._textureTrimmedID = -1),
						(this._cachedTint = 16777215),
						this._width &&
							(this.scale.x =
								(sign(this.scale.x) * this._width) / this._texture.orig.width),
						this._height &&
							(this.scale.y =
								(sign(this.scale.y) * this._height) /
								this._texture.orig.height);
				}),
				(e.prototype._onAnchorUpdate = function () {
					(this._transformID = -1), (this._transformTrimmedID = -1);
				}),
				(e.prototype.calculateVertices = function () {
					var t = this._texture;
					if (
						this._transformID !== this.transform._worldID ||
						this._textureID !== t._updateID
					) {
						this._textureID !== t._updateID &&
							(this.uvs = this._texture._uvs.uvsFloat32),
							(this._transformID = this.transform._worldID),
							(this._textureID = t._updateID);
						var e = this.transform.worldTransform,
							i = e.a,
							r = e.b,
							s = e.c,
							n = e.d,
							a = e.tx,
							o = e.ty,
							h = this.vertexData,
							u = t.trim,
							l = t.orig,
							c = this._anchor,
							d = 0,
							p = 0,
							f = 0,
							m = 0;
						if (
							(u
								? ((d = (p = u.x - c._x * l.width) + u.width),
								  (f = (m = u.y - c._y * l.height) + u.height))
								: ((d = (p = -c._x * l.width) + l.width),
								  (f = (m = -c._y * l.height) + l.height)),
							(h[0] = i * p + s * m + a),
							(h[1] = n * m + r * p + o),
							(h[2] = i * d + s * m + a),
							(h[3] = n * m + r * d + o),
							(h[4] = i * d + s * f + a),
							(h[5] = n * f + r * d + o),
							(h[6] = i * p + s * f + a),
							(h[7] = n * f + r * p + o),
							this._roundPixels)
						)
							for (var _ = settings$4.RESOLUTION, g = 0; g < h.length; ++g)
								h[g] = Math.round(((h[g] * _) | 0) / _);
					}
				}),
				(e.prototype.calculateTrimmedVertices = function () {
					if (this.vertexTrimmedData) {
						if (
							this._transformTrimmedID === this.transform._worldID &&
							this._textureTrimmedID === this._texture._updateID
						)
							return;
					} else this.vertexTrimmedData = new Float32Array(8);
					(this._transformTrimmedID = this.transform._worldID),
						(this._textureTrimmedID = this._texture._updateID);
					var t = this._texture,
						e = this.vertexTrimmedData,
						i = t.orig,
						r = this._anchor,
						s = this.transform.worldTransform,
						n = s.a,
						a = s.b,
						o = s.c,
						h = s.d,
						u = s.tx,
						l = s.ty,
						c = -r._x * i.width,
						d = c + i.width,
						p = -r._y * i.height,
						f = p + i.height;
					(e[0] = n * c + o * p + u),
						(e[1] = h * p + a * c + l),
						(e[2] = n * d + o * p + u),
						(e[3] = h * p + a * d + l),
						(e[4] = n * d + o * f + u),
						(e[5] = h * f + a * d + l),
						(e[6] = n * c + o * f + u),
						(e[7] = h * f + a * c + l);
				}),
				(e.prototype._render = function (t) {
					this.calculateVertices(),
						t.batch.setObjectRenderer(t.plugins[this.pluginName]),
						t.plugins[this.pluginName].render(this);
				}),
				(e.prototype._calculateBounds = function () {
					var t = this._texture.trim,
						e = this._texture.orig;
					!t || (t.width === e.width && t.height === e.height)
						? (this.calculateVertices(), this._bounds.addQuad(this.vertexData))
						: (this.calculateTrimmedVertices(),
						  this._bounds.addQuad(this.vertexTrimmedData));
				}),
				(e.prototype.getLocalBounds = function (e) {
					return 0 === this.children.length
						? (this._localBounds || (this._localBounds = new Bounds$2()),
						  (this._localBounds.minX =
								this._texture.orig.width * -this._anchor._x),
						  (this._localBounds.minY =
								this._texture.orig.height * -this._anchor._y),
						  (this._localBounds.maxX =
								this._texture.orig.width * (1 - this._anchor._x)),
						  (this._localBounds.maxY =
								this._texture.orig.height * (1 - this._anchor._y)),
						  e ||
								(this._localBoundsRect ||
									(this._localBoundsRect = new Rectangle$4()),
								(e = this._localBoundsRect)),
						  this._localBounds.getRectangle(e))
						: t.prototype.getLocalBounds.call(this, e);
				}),
				(e.prototype.containsPoint = function (t) {
					this.worldTransform.applyInverse(t, tempPoint$1);
					var e = this._texture.orig.width,
						i = this._texture.orig.height,
						r = -e * this.anchor.x,
						s = 0;
					return (
						tempPoint$1.x >= r &&
						tempPoint$1.x < r + e &&
						((s = -i * this.anchor.y),
						tempPoint$1.y >= s && tempPoint$1.y < s + i)
					);
				}),
				(e.prototype.destroy = function (e) {
					if (
						(t.prototype.destroy.call(this, e),
						this._texture.off('update', this._onTextureUpdate, this),
						(this._anchor = null),
						'boolean' == typeof e ? e : e && e.texture)
					) {
						var i = 'boolean' == typeof e ? e : e && e.baseTexture;
						this._texture.destroy(!!i);
					}
					this._texture = null;
				}),
				(e.from = function (t, i) {
					return new e(t instanceof Texture$3 ? t : Texture$3.from(t, i));
				}),
				Object.defineProperty(e.prototype, 'roundPixels', {
					get: function () {
						return this._roundPixels;
					},
					set: function (t) {
						this._roundPixels !== t && (this._transformID = -1),
							(this._roundPixels = t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'width', {
					get: function () {
						return Math.abs(this.scale.x) * this._texture.orig.width;
					},
					set: function (t) {
						var e = sign(this.scale.x) || 1;
						(this.scale.x = (e * t) / this._texture.orig.width),
							(this._width = t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'height', {
					get: function () {
						return Math.abs(this.scale.y) * this._texture.orig.height;
					},
					set: function (t) {
						var e = sign(this.scale.y) || 1;
						(this.scale.y = (e * t) / this._texture.orig.height),
							(this._height = t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'anchor', {
					get: function () {
						return this._anchor;
					},
					set: function (t) {
						this._anchor.copyFrom(t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'tint', {
					get: function () {
						return this._tint;
					},
					set: function (t) {
						(this._tint = t),
							(this._tintRGB = (t >> 16) + (65280 & t) + ((255 & t) << 16));
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'texture', {
					get: function () {
						return this._texture;
					},
					set: function (t) {
						this._texture !== t &&
							(this._texture &&
								this._texture.off('update', this._onTextureUpdate, this),
							(this._texture = t || Texture$3.EMPTY),
							(this._cachedTint = 16777215),
							(this._textureID = -1),
							(this._textureTrimmedID = -1),
							t &&
								(t.baseTexture.valid
									? this._onTextureUpdate()
									: t.once('update', this._onTextureUpdate, this)));
					},
					enumerable: !1,
					configurable: !0,
				}),
				e
			);
		})(Container$2),
		extendStatics$j = function (t, e) {
			return (extendStatics$j =
				Object.setPrototypeOf ||
				({ __proto__: [] } instanceof Array &&
					function (t, e) {
						t.__proto__ = e;
					}) ||
				function (t, e) {
					for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
				})(t, e);
		};
	function __extends$j(t, e) {
		function i() {
			this.constructor = t;
		}
		extendStatics$j(t, e),
			(t.prototype =
				null === e ? Object.create(e) : ((i.prototype = e.prototype), new i()));
	}
	var CanvasMaskManager = (function () {
		function t(t) {
			(this._foundShapes = []), (this.renderer = t);
		}
		return (
			(t.prototype.pushMask = function (t) {
				var e = this.renderer,
					i = t.maskObject || t;
				e.context.save();
				var r = this._foundShapes;
				if ((this.recursiveFindShapes(i, r), r.length > 0)) {
					var s = e.context;
					s.beginPath();
					for (var n = 0; n < r.length; n++) {
						var a = r[n],
							o = a.transform.worldTransform;
						this.renderer.setContextTransform(o), this.renderGraphicsShape(a);
					}
					(r.length = 0), s.clip();
				}
			}),
			(t.prototype.recursiveFindShapes = function (t, e) {
				t.geometry && t.geometry.graphicsData && e.push(t);
				var i = t.children;
				if (i)
					for (var r = 0; r < i.length; r++) this.recursiveFindShapes(i[r], e);
			}),
			(t.prototype.renderGraphicsShape = function (t) {
				t.finishPoly();
				var e = this.renderer.context,
					i = t.geometry.graphicsData,
					r = i.length;
				if (0 !== r)
					for (var s = 0; s < r; s++) {
						var n = i[s],
							a = n.shape;
						if (a.type === SHAPES$3.POLY) {
							var o = a.points,
								h = n.holes,
								u = void 0,
								l = void 0,
								c = void 0,
								d = void 0;
							e.moveTo(o[0], o[1]);
							for (var p = 1; p < o.length / 2; p++)
								e.lineTo(o[2 * p], o[2 * p + 1]);
							if (h.length > 0) {
								for (u = 0, c = o[0], d = o[1], p = 2; p + 2 < o.length; p += 2)
									u +=
										(o[p] - c) * (o[p + 3] - d) -
										(o[p + 2] - c) * (o[p + 1] - d);
								for (var f = 0; f < h.length; f++)
									if ((o = h[f].shape.points)) {
										for (
											l = 0, c = o[0], d = o[1], p = 2;
											p + 2 < o.length;
											p += 2
										)
											l +=
												(o[p] - c) * (o[p + 3] - d) -
												(o[p + 2] - c) * (o[p + 1] - d);
										if (l * u < 0)
											for (e.moveTo(o[0], o[1]), p = 2; p < o.length; p += 2)
												e.lineTo(o[p], o[p + 1]);
										else
											for (
												e.moveTo(o[o.length - 2], o[o.length - 1]),
													p = o.length - 4;
												p >= 0;
												p -= 2
											)
												e.lineTo(o[p], o[p + 1]);
										h[f].shape.closeStroke && e.closePath();
									}
							}
							o[0] === o[o.length - 2] &&
								o[1] === o[o.length - 1] &&
								e.closePath();
						} else if (a.type === SHAPES$3.RECT)
							e.rect(a.x, a.y, a.width, a.height), e.closePath();
						else if (a.type === SHAPES$3.CIRC)
							e.arc(a.x, a.y, a.radius, 0, 2 * Math.PI), e.closePath();
						else if (a.type === SHAPES$3.ELIP) {
							var m = 2 * a.width,
								_ = 2 * a.height,
								g = a.x - m / 2,
								E = a.y - _ / 2,
								y = 0.5522848,
								T = (m / 2) * y,
								v = (_ / 2) * y,
								S = g + m,
								x = E + _,
								b = g + m / 2,
								A = E + _ / 2;
							e.moveTo(g, A),
								e.bezierCurveTo(g, A - v, b - T, E, b, E),
								e.bezierCurveTo(b + T, E, S, A - v, S, A),
								e.bezierCurveTo(S, A + v, b + T, x, b, x),
								e.bezierCurveTo(b - T, x, g, A + v, g, A),
								e.closePath();
						} else if (a.type === SHAPES$3.RREC) {
							var R = a.x,
								I = a.y,
								M = a.width,
								w = a.height,
								C = a.radius,
								P = Math.min(M, w) / 2;
							(C = C > P ? P : C),
								e.moveTo(R, I + C),
								e.lineTo(R, I + w - C),
								e.quadraticCurveTo(R, I + w, R + C, I + w),
								e.lineTo(R + M - C, I + w),
								e.quadraticCurveTo(R + M, I + w, R + M, I + w - C),
								e.lineTo(R + M, I + C),
								e.quadraticCurveTo(R + M, I, R + M - C, I),
								e.lineTo(R + C, I),
								e.quadraticCurveTo(R, I, R, I + C),
								e.closePath();
						}
					}
			}),
			(t.prototype.popMask = function (t) {
				t.context.restore(), t.invalidateBlendMode();
			}),
			(t.prototype.destroy = function () {}),
			t
		);
	})();
	function createColoredCanvas(t) {
		var e = document.createElement('canvas');
		(e.width = 6), (e.height = 1);
		var i = e.getContext('2d');
		return (i.fillStyle = t), i.fillRect(0, 0, 6, 1), e;
	}
	function canUseNewCanvasBlendModes() {
		if ('undefined' == typeof document) return !1;
		var t = createColoredCanvas('#ff00ff'),
			e = createColoredCanvas('#ffff00'),
			i = document.createElement('canvas');
		(i.width = 6), (i.height = 1);
		var r = i.getContext('2d');
		(r.globalCompositeOperation = 'multiply'),
			r.drawImage(t, 0, 0),
			r.drawImage(e, 2, 0);
		var s = r.getImageData(2, 0, 1, 1);
		if (!s) return !1;
		var n = s.data;
		return 255 === n[0] && 0 === n[1] && 0 === n[2];
	}
	function mapCanvasBlendModesToPixi(t) {
		return (
			void 0 === t && (t = []),
			canUseNewCanvasBlendModes()
				? ((t[BLEND_MODES$9.NORMAL] = 'source-over'),
				  (t[BLEND_MODES$9.ADD] = 'lighter'),
				  (t[BLEND_MODES$9.MULTIPLY] = 'multiply'),
				  (t[BLEND_MODES$9.SCREEN] = 'screen'),
				  (t[BLEND_MODES$9.OVERLAY] = 'overlay'),
				  (t[BLEND_MODES$9.DARKEN] = 'darken'),
				  (t[BLEND_MODES$9.LIGHTEN] = 'lighten'),
				  (t[BLEND_MODES$9.COLOR_DODGE] = 'color-dodge'),
				  (t[BLEND_MODES$9.COLOR_BURN] = 'color-burn'),
				  (t[BLEND_MODES$9.HARD_LIGHT] = 'hard-light'),
				  (t[BLEND_MODES$9.SOFT_LIGHT] = 'soft-light'),
				  (t[BLEND_MODES$9.DIFFERENCE] = 'difference'),
				  (t[BLEND_MODES$9.EXCLUSION] = 'exclusion'),
				  (t[BLEND_MODES$9.HUE] = 'hue'),
				  (t[BLEND_MODES$9.SATURATION] = 'saturate'),
				  (t[BLEND_MODES$9.COLOR] = 'color'),
				  (t[BLEND_MODES$9.LUMINOSITY] = 'luminosity'))
				: ((t[BLEND_MODES$9.NORMAL] = 'source-over'),
				  (t[BLEND_MODES$9.ADD] = 'lighter'),
				  (t[BLEND_MODES$9.MULTIPLY] = 'source-over'),
				  (t[BLEND_MODES$9.SCREEN] = 'source-over'),
				  (t[BLEND_MODES$9.OVERLAY] = 'source-over'),
				  (t[BLEND_MODES$9.DARKEN] = 'source-over'),
				  (t[BLEND_MODES$9.LIGHTEN] = 'source-over'),
				  (t[BLEND_MODES$9.COLOR_DODGE] = 'source-over'),
				  (t[BLEND_MODES$9.COLOR_BURN] = 'source-over'),
				  (t[BLEND_MODES$9.HARD_LIGHT] = 'source-over'),
				  (t[BLEND_MODES$9.SOFT_LIGHT] = 'source-over'),
				  (t[BLEND_MODES$9.DIFFERENCE] = 'source-over'),
				  (t[BLEND_MODES$9.EXCLUSION] = 'source-over'),
				  (t[BLEND_MODES$9.HUE] = 'source-over'),
				  (t[BLEND_MODES$9.SATURATION] = 'source-over'),
				  (t[BLEND_MODES$9.COLOR] = 'source-over'),
				  (t[BLEND_MODES$9.LUMINOSITY] = 'source-over')),
			(t[BLEND_MODES$9.NORMAL_NPM] = t[BLEND_MODES$9.NORMAL]),
			(t[BLEND_MODES$9.ADD_NPM] = t[BLEND_MODES$9.ADD]),
			(t[BLEND_MODES$9.SCREEN_NPM] = t[BLEND_MODES$9.SCREEN]),
			(t[BLEND_MODES$9.SRC_IN] = 'source-in'),
			(t[BLEND_MODES$9.SRC_OUT] = 'source-out'),
			(t[BLEND_MODES$9.SRC_ATOP] = 'source-atop'),
			(t[BLEND_MODES$9.DST_OVER] = 'destination-over'),
			(t[BLEND_MODES$9.DST_IN] = 'destination-in'),
			(t[BLEND_MODES$9.DST_OUT] = 'destination-out'),
			(t[BLEND_MODES$9.DST_ATOP] = 'destination-atop'),
			(t[BLEND_MODES$9.XOR] = 'xor'),
			(t[BLEND_MODES$9.SUBTRACT] = 'source-over'),
			t
		);
	}
	var tempMatrix$6 = new Matrix$3(),
		CanvasRenderer = (function (t) {
			function e(i) {
				var r = t.call(this, RENDERER_TYPE$9.CANVAS, i) || this;
				if (
					((r.refresh = !0),
					(r.maskManager = new CanvasMaskManager(r)),
					(r.smoothProperty = 'imageSmoothingEnabled'),
					(r.blendModes = mapCanvasBlendModesToPixi()),
					(r.renderingToScreen = !1),
					(r._activeBlendMode = null),
					(r._projTransform = null),
					(r._outerBlend = !1),
					(r.rootContext = r.view.getContext('2d', {
						alpha: r.useContextAlpha,
					})),
					(r.context = r.rootContext),
					!r.rootContext.imageSmoothingEnabled)
				) {
					var s = r.rootContext;
					s.webkitImageSmoothingEnabled
						? (r.smoothProperty = 'webkitImageSmoothingEnabled')
						: s.mozImageSmoothingEnabled
						? (r.smoothProperty = 'mozImageSmoothingEnabled')
						: s.oImageSmoothingEnabled
						? (r.smoothProperty = 'oImageSmoothingEnabled')
						: s.msImageSmoothingEnabled &&
						  (r.smoothProperty = 'msImageSmoothingEnabled');
				}
				return (
					r.initPlugins(e.__plugins),
					sayHello$3('Canvas'),
					r.resize(r.options.width, r.options.height),
					r
				);
			}
			return (
				__extends$j(e, t),
				(e.prototype.addSystem = function () {
					return this;
				}),
				(e.prototype.render = function (t, e) {
					if (this.view) {
						var i, r, s, n;
						e &&
							(e instanceof RenderTexture$3 || e instanceof BaseRenderTexture$3
								? (deprecation$3(
										'6.0.0',
										'CanvasRenderer#render arguments changed, use options instead.'
								  ),
								  (i = e),
								  (r = arguments[2]),
								  (s = arguments[3]),
								  (n = arguments[4]))
								: ((i = e.renderTexture),
								  (r = e.clear),
								  (s = e.transform),
								  (n = e.skipUpdateTransform))),
							(this.renderingToScreen = !i),
							this.emit('prerender');
						var a = this.resolution;
						i
							? ((i = i.castToBaseTexture())._canvasRenderTarget ||
									((i._canvasRenderTarget = new CanvasRenderTarget(
										i.width,
										i.height,
										i.resolution
									)),
									(i.resource = new CanvasResource$3(
										i._canvasRenderTarget.canvas
									)),
									(i.valid = !0)),
							  (this.context = i._canvasRenderTarget.context),
							  (this.resolution = i._canvasRenderTarget.resolution))
							: (this.context = this.rootContext);
						var o = this.context;
						if (
							((this._projTransform = s || null),
							i || (this._lastObjectRendered = t),
							!n)
						) {
							var h = t.enableTempParent();
							t.updateTransform(), t.disableTempParent(h);
						}
						if (
							(o.save(),
							o.setTransform(1, 0, 0, 1, 0, 0),
							(o.globalAlpha = 1),
							(this._activeBlendMode = BLEND_MODES$9.NORMAL),
							(this._outerBlend = !1),
							(o.globalCompositeOperation =
								this.blendModes[BLEND_MODES$9.NORMAL]),
							void 0 !== r ? r : this.clearBeforeRender)
						)
							if (this.renderingToScreen)
								o.clearRect(0, 0, this.width, this.height),
									this.backgroundAlpha > 0 &&
										((o.globalAlpha = this.useContextAlpha
											? this.backgroundAlpha
											: 1),
										(o.fillStyle = this._backgroundColorString),
										o.fillRect(0, 0, this.width, this.height),
										(o.globalAlpha = 1));
							else {
								(i = i)._canvasRenderTarget.clear();
								var u = i.clearColor;
								u[3] > 0 &&
									((o.globalAlpha = this.useContextAlpha ? u[3] : 1),
									(o.fillStyle = hex2string$3(rgb2hex(u))),
									o.fillRect(0, 0, i.realWidth, i.realHeight),
									(o.globalAlpha = 1));
							}
						var l = this.context;
						(this.context = o),
							t.renderCanvas(this),
							(this.context = l),
							o.restore(),
							(this.resolution = a),
							(this._projTransform = null),
							this.emit('postrender');
					}
				}),
				(e.prototype.setContextTransform = function (t, e, i) {
					var r = t,
						s = this._projTransform,
						n = this.resolution;
					(i = i || n),
						s && ((r = tempMatrix$6).copyFrom(t), r.prepend(s)),
						e
							? this.context.setTransform(
									r.a * i,
									r.b * i,
									r.c * i,
									r.d * i,
									(r.tx * n) | 0,
									(r.ty * n) | 0
							  )
							: this.context.setTransform(
									r.a * i,
									r.b * i,
									r.c * i,
									r.d * i,
									r.tx * n,
									r.ty * n
							  );
				}),
				(e.prototype.clear = function (t, e) {
					void 0 === t && (t = this._backgroundColorString),
						void 0 === e && (e = this.backgroundAlpha);
					var i = this.context;
					i.clearRect(0, 0, this.width, this.height),
						t &&
							((i.globalAlpha = this.useContextAlpha ? e : 1),
							(i.fillStyle = t),
							i.fillRect(0, 0, this.width, this.height),
							(i.globalAlpha = 1));
				}),
				(e.prototype.setBlendMode = function (t, e) {
					var i =
						t === BLEND_MODES$9.SRC_IN ||
						t === BLEND_MODES$9.SRC_OUT ||
						t === BLEND_MODES$9.DST_IN ||
						t === BLEND_MODES$9.DST_ATOP;
					!e && i && (t = BLEND_MODES$9.NORMAL),
						this._activeBlendMode !== t &&
							((this._activeBlendMode = t),
							(this._outerBlend = i),
							(this.context.globalCompositeOperation = this.blendModes[t]));
				}),
				(e.prototype.destroy = function (e) {
					t.prototype.destroy.call(this, e),
						(this.context = null),
						(this.refresh = !0),
						this.maskManager.destroy(),
						(this.maskManager = null),
						(this.smoothProperty = null);
				}),
				(e.prototype.resize = function (e, i) {
					t.prototype.resize.call(this, e, i),
						this.smoothProperty &&
							(this.rootContext[this.smoothProperty] =
								settings$4.SCALE_MODE === SCALE_MODES$9.LINEAR);
				}),
				(e.prototype.invalidateBlendMode = function () {
					this._activeBlendMode = this.blendModes.indexOf(
						this.context.globalCompositeOperation
					);
				}),
				(e.registerPlugin = function (t, i) {
					(e.__plugins = e.__plugins || {}), (e.__plugins[t] = i);
				}),
				e
			);
		})(AbstractRenderer$3),
		canvasUtils = {
			canvas: null,
			getTintedCanvas: function (t, e) {
				var i = t.texture,
					r =
						'#' +
						(
							'00000' + (0 | (e = canvasUtils.roundColor(e))).toString(16)
						).slice(-6);
				i.tintCache = i.tintCache || {};
				var s,
					n = i.tintCache[r];
				if (n) {
					if (n.tintId === i._updateID) return i.tintCache[r];
					s = i.tintCache[r];
				} else s = document.createElement('canvas');
				if (
					(canvasUtils.tintMethod(i, e, s),
					(s.tintId = i._updateID),
					canvasUtils.convertTintToImage)
				) {
					var a = new Image();
					(a.src = s.toDataURL()), (i.tintCache[r] = a);
				} else i.tintCache[r] = s;
				return s;
			},
			getTintedPattern: function (t, e) {
				var i =
					'#' +
					('00000' + (0 | (e = canvasUtils.roundColor(e))).toString(16)).slice(
						-6
					);
				t.patternCache = t.patternCache || {};
				var r = t.patternCache[i];
				return (
					(r && r.tintId === t._updateID) ||
						(canvasUtils.canvas ||
							(canvasUtils.canvas = document.createElement('canvas')),
						canvasUtils.tintMethod(t, e, canvasUtils.canvas),
						((r = canvasUtils.canvas
							.getContext('2d')
							.createPattern(canvasUtils.canvas, 'repeat')).tintId =
							t._updateID),
						(t.patternCache[i] = r)),
					r
				);
			},
			tintWithMultiply: function (t, e, i) {
				var r = i.getContext('2d'),
					s = t._frame.clone(),
					n = t.baseTexture.resolution;
				(s.x *= n),
					(s.y *= n),
					(s.width *= n),
					(s.height *= n),
					(i.width = Math.ceil(s.width)),
					(i.height = Math.ceil(s.height)),
					r.save(),
					(r.fillStyle = '#' + ('00000' + (0 | e).toString(16)).slice(-6)),
					r.fillRect(0, 0, s.width, s.height),
					(r.globalCompositeOperation = 'multiply');
				var a = t.baseTexture.getDrawableSource();
				r.drawImage(a, s.x, s.y, s.width, s.height, 0, 0, s.width, s.height),
					(r.globalCompositeOperation = 'destination-atop'),
					r.drawImage(a, s.x, s.y, s.width, s.height, 0, 0, s.width, s.height),
					r.restore();
			},
			tintWithOverlay: function (t, e, i) {
				var r = i.getContext('2d'),
					s = t._frame.clone(),
					n = t.baseTexture.resolution;
				(s.x *= n),
					(s.y *= n),
					(s.width *= n),
					(s.height *= n),
					(i.width = Math.ceil(s.width)),
					(i.height = Math.ceil(s.height)),
					r.save(),
					(r.globalCompositeOperation = 'copy'),
					(r.fillStyle = '#' + ('00000' + (0 | e).toString(16)).slice(-6)),
					r.fillRect(0, 0, s.width, s.height),
					(r.globalCompositeOperation = 'destination-atop'),
					r.drawImage(
						t.baseTexture.getDrawableSource(),
						s.x,
						s.y,
						s.width,
						s.height,
						0,
						0,
						s.width,
						s.height
					),
					r.restore();
			},
			tintWithPerPixel: function (t, e, i) {
				var r = i.getContext('2d'),
					s = t._frame.clone(),
					n = t.baseTexture.resolution;
				(s.x *= n),
					(s.y *= n),
					(s.width *= n),
					(s.height *= n),
					(i.width = Math.ceil(s.width)),
					(i.height = Math.ceil(s.height)),
					r.save(),
					(r.globalCompositeOperation = 'copy'),
					r.drawImage(
						t.baseTexture.getDrawableSource(),
						s.x,
						s.y,
						s.width,
						s.height,
						0,
						0,
						s.width,
						s.height
					),
					r.restore();
				for (
					var a = hex2rgb$3(e),
						o = a[0],
						h = a[1],
						u = a[2],
						l = r.getImageData(0, 0, s.width, s.height),
						c = l.data,
						d = 0;
					d < c.length;
					d += 4
				)
					(c[d + 0] *= o), (c[d + 1] *= h), (c[d + 2] *= u);
				r.putImageData(l, 0, 0);
			},
			roundColor: function (t) {
				var e = canvasUtils.cacheStepsPerColorChannel,
					i = hex2rgb$3(t);
				return (
					(i[0] = Math.min(255, (i[0] / e) * e)),
					(i[1] = Math.min(255, (i[1] / e) * e)),
					(i[2] = Math.min(255, (i[2] / e) * e)),
					rgb2hex(i)
				);
			},
			cacheStepsPerColorChannel: 8,
			convertTintToImage: !1,
			canUseMultiply: canUseNewCanvasBlendModes(),
			tintMethod: null,
		};
	canvasUtils.tintMethod = canvasUtils.canUseMultiply
		? canvasUtils.tintWithMultiply
		: canvasUtils.tintWithPerPixel;
	var parentCreate = Renderer$1.create;
	(Renderer$1.create = function (t) {
		if (!t || !t.forceCanvas)
			try {
				return parentCreate(t);
			} catch (t) {}
		return new CanvasRenderer(t);
	}),
		(BaseTexture$3.prototype.getDrawableSource = function () {
			var t = this.resource;
			return t ? t.bitmap || t.source : null;
		}),
		(BaseRenderTexture$3.prototype._canvasRenderTarget = null),
		(Texture$3.prototype.patternCache = null),
		(Texture$3.prototype.tintCache = null);
	/*!
	 * @pixi/canvas-extract - v6.4.2
	 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
	 *
	 * @pixi/canvas-extract is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 */
	var TEMP_RECT = new Rectangle$4(),
		CanvasExtract = (function () {
			function t(t) {
				this.renderer = t;
			}
			return (
				(t.prototype.image = function (t, e, i) {
					var r = new Image();
					return (r.src = this.base64(t, e, i)), r;
				}),
				(t.prototype.base64 = function (t, e, i) {
					return this.canvas(t).toDataURL(e, i);
				}),
				(t.prototype.canvas = function (t) {
					var e,
						i,
						r,
						s,
						n = this.renderer;
					t && (s = t instanceof RenderTexture$3 ? t : n.generateTexture(t)),
						s
							? ((e = s.baseTexture._canvasRenderTarget.context),
							  (i = s.baseTexture._canvasRenderTarget.resolution),
							  (r = s.frame))
							: ((e = n.rootContext),
							  (i = n.resolution),
							  ((r = TEMP_RECT).width = this.renderer.width),
							  (r.height = this.renderer.height));
					var a = Math.floor(r.width * i + 1e-4),
						o = Math.floor(r.height * i + 1e-4),
						h = new CanvasRenderTarget(a, o, 1),
						u = e.getImageData(r.x * i, r.y * i, a, o);
					return h.context.putImageData(u, 0, 0), h.canvas;
				}),
				(t.prototype.pixels = function (t) {
					var e,
						i,
						r,
						s,
						n = this.renderer;
					t && (s = t instanceof RenderTexture$3 ? t : n.generateTexture(t)),
						s
							? ((e = s.baseTexture._canvasRenderTarget.context),
							  (i = s.baseTexture._canvasRenderTarget.resolution),
							  (r = s.frame))
							: ((e = n.rootContext),
							  (i = n.resolution),
							  ((r = TEMP_RECT).width = n.width),
							  (r.height = n.height));
					var a = r.x * i,
						o = r.y * i,
						h = r.width * i,
						u = r.height * i;
					return e.getImageData(a, o, h, u).data;
				}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})(),
		Application = (function () {
			function t(e) {
				var i = this;
				(this.stage = new Container$2()),
					(e = Object.assign({ forceCanvas: !1 }, e)),
					(this.renderer = autoDetectRenderer(e)),
					t._plugins.forEach(function (t) {
						t.init.call(i, e);
					});
			}
			return (
				(t.registerPlugin = function (e) {
					t._plugins.push(e);
				}),
				(t.prototype.render = function () {
					this.renderer.render(this.stage);
				}),
				Object.defineProperty(t.prototype, 'view', {
					get: function () {
						return this.renderer.view;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'screen', {
					get: function () {
						return this.renderer.screen;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.destroy = function (e, i) {
					var r = this,
						s = t._plugins.slice(0);
					s.reverse(),
						s.forEach(function (t) {
							t.destroy.call(r);
						}),
						this.stage.destroy(i),
						(this.stage = null),
						this.renderer.destroy(e),
						(this.renderer = null);
				}),
				(t._plugins = []),
				t
			);
		})(),
		ResizePlugin = (function () {
			function t() {}
			return (
				(t.init = function (t) {
					var e = this;
					Object.defineProperty(this, 'resizeTo', {
						set: function (t) {
							globalThis.removeEventListener('resize', this.queueResize),
								(this._resizeTo = t),
								t &&
									(globalThis.addEventListener('resize', this.queueResize),
									this.resize());
						},
						get: function () {
							return this._resizeTo;
						},
					}),
						(this.queueResize = function () {
							e._resizeTo &&
								(e.cancelResize(),
								(e._resizeId = requestAnimationFrame(function () {
									return e.resize();
								})));
						}),
						(this.cancelResize = function () {
							e._resizeId &&
								(cancelAnimationFrame(e._resizeId), (e._resizeId = null));
						}),
						(this.resize = function () {
							if (e._resizeTo) {
								var t, i;
								if ((e.cancelResize(), e._resizeTo === globalThis.window))
									(t = globalThis.innerWidth), (i = globalThis.innerHeight);
								else {
									var r = e._resizeTo;
									(t = r.clientWidth), (i = r.clientHeight);
								}
								e.renderer.resize(t, i);
							}
						}),
						(this._resizeId = null),
						(this._resizeTo = null),
						(this.resizeTo = t.resizeTo || null);
				}),
				(t.destroy = function () {
					globalThis.removeEventListener('resize', this.queueResize),
						this.cancelResize(),
						(this.cancelResize = null),
						(this.queueResize = null),
						(this.resizeTo = null),
						(this.resize = null);
				}),
				t
			);
		})(),
		LINE_JOIN,
		LINE_JOIN2,
		LINE_CAP,
		LINE_CAP2;
	Application.registerPlugin(ResizePlugin),
		(LINE_JOIN2 = LINE_JOIN || (LINE_JOIN = {})),
		(LINE_JOIN2.MITER = 'miter'),
		(LINE_JOIN2.BEVEL = 'bevel'),
		(LINE_JOIN2.ROUND = 'round'),
		(LINE_CAP2 = LINE_CAP || (LINE_CAP = {})),
		(LINE_CAP2.BUTT = 'butt'),
		(LINE_CAP2.ROUND = 'round'),
		(LINE_CAP2.SQUARE = 'square');
	var GRAPHICS_CURVES = {
			adaptive: !0,
			maxLength: 10,
			minSegments: 8,
			maxSegments: 2048,
			epsilon: 1e-4,
			_segmentsCount: function (t, e) {
				if ((void 0 === e && (e = 20), !this.adaptive || !t || isNaN(t)))
					return e;
				var i = Math.ceil(t / this.maxLength);
				return (
					i < this.minSegments
						? (i = this.minSegments)
						: i > this.maxSegments && (i = this.maxSegments),
					i
				);
			},
		},
		FillStyle = (function () {
			function t() {
				(this.color = 16777215),
					(this.alpha = 1),
					(this.texture = Texture$3.WHITE),
					(this.matrix = null),
					(this.visible = !1),
					this.reset();
			}
			return (
				(t.prototype.clone = function () {
					var e = new t();
					return (
						(e.color = this.color),
						(e.alpha = this.alpha),
						(e.texture = this.texture),
						(e.matrix = this.matrix),
						(e.visible = this.visible),
						e
					);
				}),
				(t.prototype.reset = function () {
					(this.color = 16777215),
						(this.alpha = 1),
						(this.texture = Texture$3.WHITE),
						(this.matrix = null),
						(this.visible = !1);
				}),
				(t.prototype.destroy = function () {
					(this.texture = null), (this.matrix = null);
				}),
				t
			);
		})(),
		extendStatics$i = function (t, e) {
			return (extendStatics$i =
				Object.setPrototypeOf ||
				({ __proto__: [] } instanceof Array &&
					function (t, e) {
						t.__proto__ = e;
					}) ||
				function (t, e) {
					for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
				})(t, e);
		};
	function __extends$i(t, e) {
		function i() {
			this.constructor = t;
		}
		extendStatics$i(t, e),
			(t.prototype =
				null === e ? Object.create(e) : ((i.prototype = e.prototype), new i()));
	}
	function fixOrientation(t, e) {
		var i, r;
		void 0 === e && (e = !1);
		var s = t.length;
		if (!(s < 6)) {
			for (var n = 0, a = 0, o = t[s - 2], h = t[s - 1]; a < s; a += 2) {
				var u = t[a],
					l = t[a + 1];
				(n += (u - o) * (l + h)), (o = u), (h = l);
			}
			if ((!e && n > 0) || (e && n <= 0)) {
				var c = s / 2;
				for (a = c + (c % 2); a < s; a += 2) {
					var d = s - a - 2,
						p = s - a - 1,
						f = a,
						m = a + 1;
					(i = [t[f], t[d]]),
						(t[d] = i[0]),
						(t[f] = i[1]),
						(r = [t[m], t[p]]),
						(t[p] = r[0]),
						(t[m] = r[1]);
				}
			}
		}
	}
	var buildPoly = {
			build: function (t) {
				t.points = t.shape.points.slice();
			},
			triangulate: function (t, e) {
				var i = t.points,
					r = t.holes,
					s = e.points,
					n = e.indices;
				if (i.length >= 6) {
					fixOrientation(i, !1);
					for (var a = [], o = 0; o < r.length; o++) {
						var h = r[o];
						fixOrientation(h.points, !0),
							a.push(i.length / 2),
							(i = i.concat(h.points));
					}
					var u = earcut_1(i, a, 2);
					if (!u) return;
					var l = s.length / 2;
					for (o = 0; o < u.length; o += 3)
						n.push(u[o] + l), n.push(u[o + 1] + l), n.push(u[o + 2] + l);
					for (o = 0; o < i.length; o++) s.push(i[o]);
				}
			},
		},
		buildCircle = {
			build: function (t) {
				var e,
					i,
					r,
					s,
					n,
					a,
					o = t.points;
				if (t.type === SHAPES$3.CIRC) {
					var h = t.shape;
					(e = h.x), (i = h.y), (n = a = h.radius), (r = s = 0);
				} else if (t.type === SHAPES$3.ELIP) {
					var u = t.shape;
					(e = u.x), (i = u.y), (n = u.width), (a = u.height), (r = s = 0);
				} else {
					var l = t.shape,
						c = l.width / 2,
						d = l.height / 2;
					(e = l.x + c),
						(i = l.y + d),
						(r = c - (n = a = Math.max(0, Math.min(l.radius, Math.min(c, d))))),
						(s = d - a);
				}
				if (n >= 0 && a >= 0 && r >= 0 && s >= 0) {
					var p = Math.ceil(2.3 * Math.sqrt(n + a)),
						f = 8 * p + (r ? 4 : 0) + (s ? 4 : 0);
					if (((o.length = f), 0 !== f)) {
						if (0 === p)
							return (
								(o.length = 8),
								(o[0] = o[6] = e + r),
								(o[1] = o[3] = i + s),
								(o[2] = o[4] = e - r),
								void (o[5] = o[7] = i - s)
							);
						var m,
							_,
							g = 0,
							E = 4 * p + (r ? 2 : 0) + 2,
							y = E,
							T = f,
							v = e + (m = r + n),
							S = e - m,
							x = i + (_ = s);
						if (((o[g++] = v), (o[g++] = x), (o[--E] = x), (o[--E] = S), s)) {
							var b = i - _;
							(o[y++] = S), (o[y++] = b), (o[--T] = b), (o[--T] = v);
						}
						for (var A = 1; A < p; A++) {
							var R = (Math.PI / 2) * (A / p);
							(v = e + (m = r + Math.cos(R) * n)),
								(S = e - m),
								(x = i + (_ = s + Math.sin(R) * a)),
								(b = i - _),
								(o[g++] = v),
								(o[g++] = x),
								(o[--E] = x),
								(o[--E] = S),
								(o[y++] = S),
								(o[y++] = b),
								(o[--T] = b),
								(o[--T] = v);
						}
						(v = e + (m = r)),
							(S = e - m),
							(x = i + (_ = s + a)),
							(b = i - _),
							(o[g++] = v),
							(o[g++] = x),
							(o[--T] = b),
							(o[--T] = v),
							r && ((o[g++] = S), (o[g++] = x), (o[--T] = b), (o[--T] = S));
					}
				} else o.length = 0;
			},
			triangulate: function (t, e) {
				var i,
					r,
					s = t.points,
					n = e.points,
					a = e.indices,
					o = n.length / 2,
					h = o;
				if (t.type !== SHAPES$3.RREC) {
					var u = t.shape;
					(i = u.x), (r = u.y);
				} else {
					var l = t.shape;
					(i = l.x + l.width / 2), (r = l.y + l.height / 2);
				}
				var c = t.matrix;
				n.push(
					t.matrix ? c.a * i + c.c * r + c.tx : i,
					t.matrix ? c.b * i + c.d * r + c.ty : r
				),
					o++,
					n.push(s[0], s[1]);
				for (var d = 2; d < s.length; d += 2)
					n.push(s[d], s[d + 1]), a.push(o++, h, o);
				a.push(h + 1, h, o);
			},
		},
		buildRectangle = {
			build: function (t) {
				var e = t.shape,
					i = e.x,
					r = e.y,
					s = e.width,
					n = e.height,
					a = t.points;
				(a.length = 0), a.push(i, r, i + s, r, i + s, r + n, i, r + n);
			},
			triangulate: function (t, e) {
				var i = t.points,
					r = e.points,
					s = r.length / 2;
				r.push(i[0], i[1], i[2], i[3], i[6], i[7], i[4], i[5]),
					e.indices.push(s, s + 1, s + 2, s + 1, s + 2, s + 3);
			},
		};
	function getPt(t, e, i) {
		return t + (e - t) * i;
	}
	function quadraticBezierCurve(t, e, i, r, s, n, a) {
		void 0 === a && (a = []);
		for (
			var o = a, h = 0, u = 0, l = 0, c = 0, d = 0, p = 0, f = 0, m = 0;
			f <= 20;
			++f
		)
			(h = getPt(t, i, (m = f / 20))),
				(u = getPt(e, r, m)),
				(l = getPt(i, s, m)),
				(c = getPt(r, n, m)),
				(d = getPt(h, l, m)),
				(p = getPt(u, c, m)),
				(0 === f && o[o.length - 2] === d && o[o.length - 1] === p) ||
					o.push(d, p);
		return o;
	}
	var buildRoundedRectangle = {
		build: function (t) {
			if (Graphics$1.nextRoundedRectBehavior) buildCircle.build(t);
			else {
				var e = t.shape,
					i = t.points,
					r = e.x,
					s = e.y,
					n = e.width,
					a = e.height,
					o = Math.max(0, Math.min(e.radius, Math.min(n, a) / 2));
				(i.length = 0),
					o
						? (quadraticBezierCurve(r, s + o, r, s, r + o, s, i),
						  quadraticBezierCurve(r + n - o, s, r + n, s, r + n, s + o, i),
						  quadraticBezierCurve(
								r + n,
								s + a - o,
								r + n,
								s + a,
								r + n - o,
								s + a,
								i
						  ),
						  quadraticBezierCurve(r + o, s + a, r, s + a, r, s + a - o, i))
						: i.push(r, s, r + n, s, r + n, s + a, r, s + a);
			}
		},
		triangulate: function (t, e) {
			if (Graphics$1.nextRoundedRectBehavior) buildCircle.triangulate(t, e);
			else {
				for (
					var i = t.points,
						r = e.points,
						s = e.indices,
						n = r.length / 2,
						a = earcut_1(i, null, 2),
						o = 0,
						h = a.length;
					o < h;
					o += 3
				)
					s.push(a[o] + n), s.push(a[o + 1] + n), s.push(a[o + 2] + n);
				for (o = 0, h = i.length; o < h; o++) r.push(i[o], i[++o]);
			}
		},
	};
	function square(t, e, i, r, s, n, a, o) {
		var h, u;
		a ? ((h = r), (u = -i)) : ((h = -r), (u = i));
		var l = t - i * s + h,
			c = e - r * s + u,
			d = t + i * n + h,
			p = e + r * n + u;
		return o.push(l, c), o.push(d, p), 2;
	}
	function round(t, e, i, r, s, n, a, o) {
		var h = i - t,
			u = r - e,
			l = Math.atan2(h, u),
			c = Math.atan2(s - t, n - e);
		o && l < c ? (l += 2 * Math.PI) : !o && l > c && (c += 2 * Math.PI);
		var d = l,
			p = c - l,
			f = Math.abs(p),
			m = Math.sqrt(h * h + u * u),
			_ = 1 + (((15 * f * Math.sqrt(m)) / Math.PI) >> 0),
			g = p / _;
		if (((d += g), o)) {
			a.push(t, e), a.push(i, r);
			for (var E = 1, y = d; E < _; E++, y += g)
				a.push(t, e), a.push(t + Math.sin(y) * m, e + Math.cos(y) * m);
			a.push(t, e), a.push(s, n);
		} else {
			for (a.push(i, r), a.push(t, e), E = 1, y = d; E < _; E++, y += g)
				a.push(t + Math.sin(y) * m, e + Math.cos(y) * m), a.push(t, e);
			a.push(s, n), a.push(t, e);
		}
		return 2 * _;
	}
	function buildNonNativeLine(t, e) {
		var i = t.shape,
			r = t.points || i.points.slice(),
			s = e.closePointEps;
		if (0 !== r.length) {
			var n = t.lineStyle,
				a = new Point$4(r[0], r[1]),
				o = new Point$4(r[r.length - 2], r[r.length - 1]),
				h = i.type !== SHAPES$3.POLY || i.closeStroke,
				u = Math.abs(a.x - o.x) < s && Math.abs(a.y - o.y) < s;
			if (h) {
				(r = r.slice()),
					u && (r.pop(), r.pop(), o.set(r[r.length - 2], r[r.length - 1]));
				var l = 0.5 * (a.x + o.x),
					c = 0.5 * (o.y + a.y);
				r.unshift(l, c), r.push(l, c);
			}
			var d = e.points,
				p = r.length / 2,
				f = r.length,
				m = d.length / 2,
				_ = n.width / 2,
				g = _ * _,
				E = n.miterLimit * n.miterLimit,
				y = r[0],
				T = r[1],
				v = r[2],
				S = r[3],
				x = 0,
				b = 0,
				A = -(T - S),
				R = y - v,
				I = 0,
				M = 0,
				w = Math.sqrt(A * A + R * R);
			(A /= w), (R /= w), (A *= _), (R *= _);
			var C = n.alignment,
				P = 2 * (1 - C),
				O = 2 * C;
			h ||
				(n.cap === LINE_CAP.ROUND
					? (f +=
							round(
								y - A * (P - O) * 0.5,
								T - R * (P - O) * 0.5,
								y - A * P,
								T - R * P,
								y + A * O,
								T + R * O,
								d,
								!0
							) + 2)
					: n.cap === LINE_CAP.SQUARE &&
					  (f += square(y, T, A, R, P, O, !0, d))),
				d.push(y - A * P, T - R * P),
				d.push(y + A * O, T + R * O);
			for (var $ = 1; $ < p - 1; ++$) {
				(y = r[2 * ($ - 1)]),
					(T = r[2 * ($ - 1) + 1]),
					(v = r[2 * $]),
					(S = r[2 * $ + 1]),
					(x = r[2 * ($ + 1)]),
					(b = r[2 * ($ + 1) + 1]),
					(A = -(T - S)),
					(R = y - v),
					(A /= w = Math.sqrt(A * A + R * R)),
					(R /= w),
					(A *= _),
					(R *= _),
					(I = -(S - b)),
					(M = v - x),
					(I /= w = Math.sqrt(I * I + M * M)),
					(M /= w),
					(I *= _),
					(M *= _);
				var N = v - y,
					D = T - S,
					L = v - x,
					B = b - S,
					F = D * L - B * N,
					U = F < 0;
				if (Math.abs(F) < 0.1)
					d.push(v - A * P, S - R * P), d.push(v + A * O, S + R * O);
				else {
					var G = (-A + y) * (-R + S) - (-A + v) * (-R + T),
						k = (-I + x) * (-M + S) - (-I + v) * (-M + b),
						W = (N * k - L * G) / F,
						H = (B * G - D * k) / F,
						Y = (W - v) * (W - v) + (H - S) * (H - S),
						V = v + (W - v) * P,
						X = S + (H - S) * P,
						j = v - (W - v) * O,
						z = S - (H - S) * O,
						q = U ? P : O;
					Y <= Math.min(N * N + D * D, L * L + B * B) + q * q * g
						? n.join === LINE_JOIN.BEVEL || Y / g > E
							? (U
									? (d.push(V, X),
									  d.push(v + A * O, S + R * O),
									  d.push(V, X),
									  d.push(v + I * O, S + M * O))
									: (d.push(v - A * P, S - R * P),
									  d.push(j, z),
									  d.push(v - I * P, S - M * P),
									  d.push(j, z)),
							  (f += 2))
							: n.join === LINE_JOIN.ROUND
							? U
								? (d.push(V, X),
								  d.push(v + A * O, S + R * O),
								  (f +=
										round(
											v,
											S,
											v + A * O,
											S + R * O,
											v + I * O,
											S + M * O,
											d,
											!0
										) + 4),
								  d.push(V, X),
								  d.push(v + I * O, S + M * O))
								: (d.push(v - A * P, S - R * P),
								  d.push(j, z),
								  (f +=
										round(
											v,
											S,
											v - A * P,
											S - R * P,
											v - I * P,
											S - M * P,
											d,
											!1
										) + 4),
								  d.push(v - I * P, S - M * P),
								  d.push(j, z))
							: (d.push(V, X), d.push(j, z))
						: (d.push(v - A * P, S - R * P),
						  d.push(v + A * O, S + R * O),
						  n.join === LINE_JOIN.ROUND
								? (f += U
										? round(
												v,
												S,
												v + A * O,
												S + R * O,
												v + I * O,
												S + M * O,
												d,
												!0
										  ) + 2
										: round(
												v,
												S,
												v - A * P,
												S - R * P,
												v - I * P,
												S - M * P,
												d,
												!1
										  ) + 2)
								: n.join === LINE_JOIN.MITER &&
								  Y / g <= E &&
								  (U
										? (d.push(j, z), d.push(j, z))
										: (d.push(V, X), d.push(V, X)),
								  (f += 2)),
						  d.push(v - I * P, S - M * P),
						  d.push(v + I * O, S + M * O),
						  (f += 2));
				}
			}
			(y = r[2 * (p - 2)]),
				(T = r[2 * (p - 2) + 1]),
				(v = r[2 * (p - 1)]),
				(A = -(T - (S = r[2 * (p - 1) + 1]))),
				(R = y - v),
				(A /= w = Math.sqrt(A * A + R * R)),
				(R /= w),
				(A *= _),
				(R *= _),
				d.push(v - A * P, S - R * P),
				d.push(v + A * O, S + R * O),
				h ||
					(n.cap === LINE_CAP.ROUND
						? (f +=
								round(
									v - A * (P - O) * 0.5,
									S - R * (P - O) * 0.5,
									v - A * P,
									S - R * P,
									v + A * O,
									S + R * O,
									d,
									!1
								) + 2)
						: n.cap === LINE_CAP.SQUARE &&
						  (f += square(v, S, A, R, P, O, !1, d)));
			var K = e.indices,
				Z = GRAPHICS_CURVES.epsilon * GRAPHICS_CURVES.epsilon;
			for ($ = m; $ < f + m - 2; ++$)
				(y = d[2 * $]),
					(T = d[2 * $ + 1]),
					(v = d[2 * ($ + 1)]),
					(S = d[2 * ($ + 1) + 1]),
					(x = d[2 * ($ + 2)]),
					(b = d[2 * ($ + 2) + 1]),
					Math.abs(y * (S - b) + v * (b - T) + x * (T - S)) < Z ||
						K.push($, $ + 1, $ + 2);
		}
	}
	function buildNativeLine(t, e) {
		var i = 0,
			r = t.shape,
			s = t.points || r.points,
			n = r.type !== SHAPES$3.POLY || r.closeStroke;
		if (0 !== s.length) {
			var a = e.points,
				o = e.indices,
				h = s.length / 2,
				u = a.length / 2,
				l = u;
			for (a.push(s[0], s[1]), i = 1; i < h; i++)
				a.push(s[2 * i], s[2 * i + 1]), o.push(l, l + 1), l++;
			n && o.push(l, u);
		}
	}
	function buildLine(t, e) {
		t.lineStyle.native ? buildNativeLine(t, e) : buildNonNativeLine(t, e);
	}
	var ArcUtils = (function () {
			function t() {}
			return (
				(t.curveTo = function (t, e, i, r, s, n) {
					var a = n[n.length - 2],
						o = n[n.length - 1] - e,
						h = a - t,
						u = r - e,
						l = i - t,
						c = Math.abs(o * l - h * u);
					if (c < 1e-8 || 0 === s)
						return (
							(n[n.length - 2] === t && n[n.length - 1] === e) || n.push(t, e),
							null
						);
					var d = o * o + h * h,
						p = u * u + l * l,
						f = o * u + h * l,
						m = (s * Math.sqrt(d)) / c,
						_ = (s * Math.sqrt(p)) / c,
						g = (m * f) / d,
						E = (_ * f) / p,
						y = m * l + _ * h,
						T = m * u + _ * o,
						v = h * (_ + g),
						S = o * (_ + g),
						x = l * (m + E),
						b = u * (m + E);
					return {
						cx: y + t,
						cy: T + e,
						radius: s,
						startAngle: Math.atan2(S - T, v - y),
						endAngle: Math.atan2(b - T, x - y),
						anticlockwise: h * u > l * o,
					};
				}),
				(t.arc = function (t, e, i, r, s, n, a, o, h) {
					for (
						var u = a - n,
							l = GRAPHICS_CURVES._segmentsCount(
								Math.abs(u) * s,
								40 * Math.ceil(Math.abs(u) / PI_2$3)
							),
							c = u / (2 * l),
							d = 2 * c,
							p = Math.cos(c),
							f = Math.sin(c),
							m = l - 1,
							_ = (m % 1) / m,
							g = 0;
						g <= m;
						++g
					) {
						var E = c + n + d * (g + _ * g),
							y = Math.cos(E),
							T = -Math.sin(E);
						h.push((p * y + f * T) * s + i, (p * -T + f * y) * s + r);
					}
				}),
				t
			);
		})(),
		BezierUtils = (function () {
			function t() {}
			return (
				(t.curveLength = function (t, e, i, r, s, n, a, o) {
					for (
						var h = 0,
							u = 0,
							l = 0,
							c = 0,
							d = 0,
							p = 0,
							f = 0,
							m = 0,
							_ = 0,
							g = 0,
							E = 0,
							y = t,
							T = e,
							v = 1;
						v <= 10;
						++v
					)
						(g =
							y -
							(m =
								(f = (p = (d = 1 - (u = v / 10)) * d) * d) * t +
								3 * p * u * i +
								3 * d * (l = u * u) * s +
								(c = l * u) * a)),
							(E = T - (_ = f * e + 3 * p * u * r + 3 * d * l * n + c * o)),
							(y = m),
							(T = _),
							(h += Math.sqrt(g * g + E * E));
					return h;
				}),
				(t.curveTo = function (e, i, r, s, n, a, o) {
					var h = o[o.length - 2],
						u = o[o.length - 1];
					o.length -= 2;
					var l = GRAPHICS_CURVES._segmentsCount(
							t.curveLength(h, u, e, i, r, s, n, a)
						),
						c = 0,
						d = 0,
						p = 0,
						f = 0,
						m = 0;
					o.push(h, u);
					for (var _ = 1, g = 0; _ <= l; ++_)
						(p = (d = (c = 1 - (g = _ / l)) * c) * c),
							(m = (f = g * g) * g),
							o.push(
								p * h + 3 * d * g * e + 3 * c * f * r + m * n,
								p * u + 3 * d * g * i + 3 * c * f * s + m * a
							);
				}),
				t
			);
		})(),
		QuadraticUtils = (function () {
			function t() {}
			return (
				(t.curveLength = function (t, e, i, r, s, n) {
					var a = t - 2 * i + s,
						o = e - 2 * r + n,
						h = 2 * i - 2 * t,
						u = 2 * r - 2 * e,
						l = 4 * (a * a + o * o),
						c = 4 * (a * h + o * u),
						d = h * h + u * u,
						p = 2 * Math.sqrt(l + c + d),
						f = Math.sqrt(l),
						m = 2 * l * f,
						_ = 2 * Math.sqrt(d),
						g = c / f;
					return (
						(m * p +
							f * c * (p - _) +
							(4 * d * l - c * c) * Math.log((2 * f + g + p) / (g + _))) /
						(4 * m)
					);
				}),
				(t.curveTo = function (e, i, r, s, n) {
					for (
						var a = n[n.length - 2],
							o = n[n.length - 1],
							h = GRAPHICS_CURVES._segmentsCount(
								t.curveLength(a, o, e, i, r, s)
							),
							u = 0,
							l = 0,
							c = 1;
						c <= h;
						++c
					) {
						var d = c / h;
						(u = a + (e - a) * d),
							(l = o + (i - o) * d),
							n.push(
								u + (e + (r - e) * d - u) * d,
								l + (i + (s - i) * d - l) * d
							);
					}
				}),
				t
			);
		})(),
		BatchPart = (function () {
			function t() {
				this.reset();
			}
			return (
				(t.prototype.begin = function (t, e, i) {
					this.reset(),
						(this.style = t),
						(this.start = e),
						(this.attribStart = i);
				}),
				(t.prototype.end = function (t, e) {
					(this.attribSize = e - this.attribStart),
						(this.size = t - this.start);
				}),
				(t.prototype.reset = function () {
					(this.style = null),
						(this.size = 0),
						(this.start = 0),
						(this.attribStart = 0),
						(this.attribSize = 0);
				}),
				t
			);
		})(),
		_a,
		FILL_COMMANDS =
			((_a = {}),
			(_a[SHAPES$3.POLY] = buildPoly),
			(_a[SHAPES$3.CIRC] = buildCircle),
			(_a[SHAPES$3.ELIP] = buildCircle),
			(_a[SHAPES$3.RECT] = buildRectangle),
			(_a[SHAPES$3.RREC] = buildRoundedRectangle),
			_a),
		BATCH_POOL = [],
		DRAW_CALL_POOL = [],
		GraphicsData = (function () {
			function t(t, e, i, r) {
				void 0 === e && (e = null),
					void 0 === i && (i = null),
					void 0 === r && (r = null),
					(this.points = []),
					(this.holes = []),
					(this.shape = t),
					(this.lineStyle = i),
					(this.fillStyle = e),
					(this.matrix = r),
					(this.type = t.type);
			}
			return (
				(t.prototype.clone = function () {
					return new t(this.shape, this.fillStyle, this.lineStyle, this.matrix);
				}),
				(t.prototype.destroy = function () {
					(this.shape = null),
						(this.holes.length = 0),
						(this.holes = null),
						(this.points.length = 0),
						(this.points = null),
						(this.lineStyle = null),
						(this.fillStyle = null);
				}),
				t
			);
		})(),
		tmpPoint = new Point$4(),
		tmpBounds = new Bounds$2(),
		GraphicsGeometry = (function (t) {
			function e() {
				var e = t.call(this) || this;
				return (
					(e.closePointEps = 1e-4),
					(e.boundsPadding = 0),
					(e.uvsFloat32 = null),
					(e.indicesUint16 = null),
					(e.batchable = !1),
					(e.points = []),
					(e.colors = []),
					(e.uvs = []),
					(e.indices = []),
					(e.textureIds = []),
					(e.graphicsData = []),
					(e.drawCalls = []),
					(e.batchDirty = -1),
					(e.batches = []),
					(e.dirty = 0),
					(e.cacheDirty = -1),
					(e.clearDirty = 0),
					(e.shapeIndex = 0),
					(e._bounds = new Bounds$2()),
					(e.boundsDirty = -1),
					e
				);
			}
			return (
				__extends$i(e, t),
				Object.defineProperty(e.prototype, 'bounds', {
					get: function () {
						return (
							this.boundsDirty !== this.dirty &&
								((this.boundsDirty = this.dirty), this.calculateBounds()),
							this._bounds
						);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.invalidate = function () {
					(this.boundsDirty = -1),
						this.dirty++,
						this.batchDirty++,
						(this.shapeIndex = 0),
						(this.points.length = 0),
						(this.colors.length = 0),
						(this.uvs.length = 0),
						(this.indices.length = 0),
						(this.textureIds.length = 0);
					for (var t = 0; t < this.drawCalls.length; t++)
						this.drawCalls[t].texArray.clear(),
							DRAW_CALL_POOL.push(this.drawCalls[t]);
					for (this.drawCalls.length = 0, t = 0; t < this.batches.length; t++) {
						var e = this.batches[t];
						e.reset(), BATCH_POOL.push(e);
					}
					this.batches.length = 0;
				}),
				(e.prototype.clear = function () {
					return (
						this.graphicsData.length > 0 &&
							(this.invalidate(),
							this.clearDirty++,
							(this.graphicsData.length = 0)),
						this
					);
				}),
				(e.prototype.drawShape = function (t, e, i, r) {
					void 0 === e && (e = null),
						void 0 === i && (i = null),
						void 0 === r && (r = null);
					var s = new GraphicsData(t, e, i, r);
					return this.graphicsData.push(s), this.dirty++, this;
				}),
				(e.prototype.drawHole = function (t, e) {
					if ((void 0 === e && (e = null), !this.graphicsData.length))
						return null;
					var i = new GraphicsData(t, null, null, e),
						r = this.graphicsData[this.graphicsData.length - 1];
					return (
						(i.lineStyle = r.lineStyle), r.holes.push(i), this.dirty++, this
					);
				}),
				(e.prototype.destroy = function () {
					t.prototype.destroy.call(this);
					for (var e = 0; e < this.graphicsData.length; ++e)
						this.graphicsData[e].destroy();
					(this.points.length = 0),
						(this.points = null),
						(this.colors.length = 0),
						(this.colors = null),
						(this.uvs.length = 0),
						(this.uvs = null),
						(this.indices.length = 0),
						(this.indices = null),
						this.indexBuffer.destroy(),
						(this.indexBuffer = null),
						(this.graphicsData.length = 0),
						(this.graphicsData = null),
						(this.drawCalls.length = 0),
						(this.drawCalls = null),
						(this.batches.length = 0),
						(this.batches = null),
						(this._bounds = null);
				}),
				(e.prototype.containsPoint = function (t) {
					for (var e = this.graphicsData, i = 0; i < e.length; ++i) {
						var r = e[i];
						if (
							r.fillStyle.visible &&
							r.shape &&
							(r.matrix
								? r.matrix.applyInverse(t, tmpPoint)
								: tmpPoint.copyFrom(t),
							r.shape.contains(tmpPoint.x, tmpPoint.y))
						) {
							var s = !1;
							if (r.holes)
								for (var n = 0; n < r.holes.length; n++)
									if (r.holes[n].shape.contains(tmpPoint.x, tmpPoint.y)) {
										s = !0;
										break;
									}
							if (!s) return !0;
						}
					}
					return !1;
				}),
				(e.prototype.updateBatches = function (t) {
					if (this.graphicsData.length) {
						if (this.validateBatching()) {
							this.cacheDirty = this.dirty;
							var e = this.uvs,
								i = this.graphicsData,
								r = null,
								s = null;
							this.batches.length > 0 &&
								(s = (r = this.batches[this.batches.length - 1]).style);
							for (var n = this.shapeIndex; n < i.length; n++) {
								this.shapeIndex++;
								var a = i[n],
									o = a.fillStyle,
									h = a.lineStyle;
								FILL_COMMANDS[a.type].build(a),
									a.matrix && this.transformPoints(a.points, a.matrix),
									(o.visible || h.visible) && this.processHoles(a.holes);
								for (var u = 0; u < 2; u++) {
									var l = 0 === u ? o : h;
									if (l.visible) {
										var c = l.texture.baseTexture,
											d = this.indices.length,
											p = this.points.length / 2;
										(c.wrapMode = WRAP_MODES$9.REPEAT),
											0 === u ? this.processFill(a) : this.processLine(a);
										var f = this.points.length / 2 - p;
										0 !== f &&
											(r &&
												!this._compareStyles(s, l) &&
												(r.end(d, p), (r = null)),
											r ||
												((r = BATCH_POOL.pop() || new BatchPart()).begin(
													l,
													d,
													p
												),
												this.batches.push(r),
												(s = l)),
											this.addUvs(this.points, e, l.texture, p, f, l.matrix));
									}
								}
							}
							var m = this.indices.length,
								_ = this.points.length / 2;
							if ((r && r.end(m, _), 0 !== this.batches.length)) {
								if (
									this.indicesUint16 &&
									this.indices.length === this.indicesUint16.length
								)
									this.indicesUint16.set(this.indices);
								else {
									var g = _ > 65535 && t;
									this.indicesUint16 = g
										? new Uint32Array(this.indices)
										: new Uint16Array(this.indices);
								}
								(this.batchable = this.isBatchable()),
									this.batchable ? this.packBatches() : this.buildDrawCalls();
							} else this.batchable = !0;
						}
					} else this.batchable = !0;
				}),
				(e.prototype._compareStyles = function (t, e) {
					return (
						!(!t || !e) &&
						t.texture.baseTexture === e.texture.baseTexture &&
						t.color + t.alpha === e.color + e.alpha &&
						!!t.native == !!e.native
					);
				}),
				(e.prototype.validateBatching = function () {
					if (this.dirty === this.cacheDirty || !this.graphicsData.length)
						return !1;
					for (var t = 0, e = this.graphicsData.length; t < e; t++) {
						var i = this.graphicsData[t],
							r = i.fillStyle,
							s = i.lineStyle;
						if (r && !r.texture.baseTexture.valid) return !1;
						if (s && !s.texture.baseTexture.valid) return !1;
					}
					return !0;
				}),
				(e.prototype.packBatches = function () {
					this.batchDirty++, (this.uvsFloat32 = new Float32Array(this.uvs));
					for (var t = this.batches, e = 0, i = t.length; e < i; e++)
						for (var r = t[e], s = 0; s < r.size; s++) {
							var n = r.start + s;
							this.indicesUint16[n] = this.indicesUint16[n] - r.attribStart;
						}
				}),
				(e.prototype.isBatchable = function () {
					if (this.points.length > 131070) return !1;
					for (var t = this.batches, i = 0; i < t.length; i++)
						if (t[i].style.native) return !1;
					return this.points.length < 2 * e.BATCHABLE_SIZE;
				}),
				(e.prototype.buildDrawCalls = function () {
					for (
						var t = ++BaseTexture$3._globalBatch, e = 0;
						e < this.drawCalls.length;
						e++
					)
						this.drawCalls[e].texArray.clear(),
							DRAW_CALL_POOL.push(this.drawCalls[e]);
					this.drawCalls.length = 0;
					var i = this.colors,
						r = this.textureIds,
						s = DRAW_CALL_POOL.pop();
					s ||
						((s = new BatchDrawCall$3()).texArray = new BatchTextureArray$3()),
						(s.texArray.count = 0),
						(s.start = 0),
						(s.size = 0),
						(s.type = DRAW_MODES$9.TRIANGLES);
					var n = 0,
						a = null,
						o = 0,
						h = !1,
						u = DRAW_MODES$9.TRIANGLES,
						l = 0;
					for (this.drawCalls.push(s), e = 0; e < this.batches.length; e++) {
						var c = this.batches[e],
							d = c.style,
							p = d.texture.baseTexture;
						h !== !!d.native &&
							((u = (h = !!d.native)
								? DRAW_MODES$9.LINES
								: DRAW_MODES$9.TRIANGLES),
							(a = null),
							(n = 8),
							t++),
							a !== p &&
								((a = p),
								p._batchEnabled !== t &&
									(8 === n &&
										(t++,
										(n = 0),
										s.size > 0 &&
											((s = DRAW_CALL_POOL.pop()) ||
												((s = new BatchDrawCall$3()).texArray =
													new BatchTextureArray$3()),
											this.drawCalls.push(s)),
										(s.start = l),
										(s.size = 0),
										(s.texArray.count = 0),
										(s.type = u)),
									(p.touched = 1),
									(p._batchEnabled = t),
									(p._batchLocation = n),
									(p.wrapMode = WRAP_MODES$9.REPEAT),
									(s.texArray.elements[s.texArray.count++] = p),
									n++)),
							(s.size += c.size),
							(l += c.size),
							(o = p._batchLocation),
							this.addColors(i, d.color, d.alpha, c.attribSize, c.attribStart),
							this.addTextureIds(r, o, c.attribSize, c.attribStart);
					}
					(BaseTexture$3._globalBatch = t), this.packAttributes();
				}),
				(e.prototype.packAttributes = function () {
					for (
						var t = this.points,
							e = this.uvs,
							i = this.colors,
							r = this.textureIds,
							s = new ArrayBuffer(3 * t.length * 4),
							n = new Float32Array(s),
							a = new Uint32Array(s),
							o = 0,
							h = 0;
						h < t.length / 2;
						h++
					)
						(n[o++] = t[2 * h]),
							(n[o++] = t[2 * h + 1]),
							(n[o++] = e[2 * h]),
							(n[o++] = e[2 * h + 1]),
							(a[o++] = i[h]),
							(n[o++] = r[h]);
					this._buffer.update(s), this._indexBuffer.update(this.indicesUint16);
				}),
				(e.prototype.processFill = function (t) {
					t.holes.length
						? buildPoly.triangulate(t, this)
						: FILL_COMMANDS[t.type].triangulate(t, this);
				}),
				(e.prototype.processLine = function (t) {
					buildLine(t, this);
					for (var e = 0; e < t.holes.length; e++) buildLine(t.holes[e], this);
				}),
				(e.prototype.processHoles = function (t) {
					for (var e = 0; e < t.length; e++) {
						var i = t[e];
						FILL_COMMANDS[i.type].build(i),
							i.matrix && this.transformPoints(i.points, i.matrix);
					}
				}),
				(e.prototype.calculateBounds = function () {
					var t = this._bounds,
						e = tmpBounds,
						i = Matrix$3.IDENTITY;
					this._bounds.clear(), e.clear();
					for (var r = 0; r < this.graphicsData.length; r++) {
						var s = this.graphicsData[r],
							n = s.shape,
							a = s.type,
							o = s.lineStyle,
							h = s.matrix || Matrix$3.IDENTITY,
							u = 0;
						if (
							(o &&
								o.visible &&
								((u = o.width),
								a !== SHAPES$3.POLY || s.fillStyle.visible
									? (u *= Math.max(0, o.alignment))
									: (u *= Math.max(o.alignment, 1 - o.alignment))),
							i !== h &&
								(e.isEmpty() || (t.addBoundsMatrix(e, i), e.clear()), (i = h)),
							a === SHAPES$3.RECT || a === SHAPES$3.RREC)
						) {
							var l = n;
							e.addFramePad(l.x, l.y, l.x + l.width, l.y + l.height, u, u);
						} else if (a === SHAPES$3.CIRC) {
							var c = n;
							e.addFramePad(c.x, c.y, c.x, c.y, c.radius + u, c.radius + u);
						} else if (a === SHAPES$3.ELIP) {
							var d = n;
							e.addFramePad(d.x, d.y, d.x, d.y, d.width + u, d.height + u);
						} else {
							var p = n;
							t.addVerticesMatrix(i, p.points, 0, p.points.length, u, u);
						}
					}
					e.isEmpty() || t.addBoundsMatrix(e, i),
						t.pad(this.boundsPadding, this.boundsPadding);
				}),
				(e.prototype.transformPoints = function (t, e) {
					for (var i = 0; i < t.length / 2; i++) {
						var r = t[2 * i],
							s = t[2 * i + 1];
						(t[2 * i] = e.a * r + e.c * s + e.tx),
							(t[2 * i + 1] = e.b * r + e.d * s + e.ty);
					}
				}),
				(e.prototype.addColors = function (t, e, i, r, s) {
					void 0 === s && (s = 0);
					var n = premultiplyTint$3(
						(e >> 16) + (65280 & e) + ((255 & e) << 16),
						i
					);
					t.length = Math.max(t.length, s + r);
					for (var a = 0; a < r; a++) t[s + a] = n;
				}),
				(e.prototype.addTextureIds = function (t, e, i, r) {
					void 0 === r && (r = 0), (t.length = Math.max(t.length, r + i));
					for (var s = 0; s < i; s++) t[r + s] = e;
				}),
				(e.prototype.addUvs = function (t, e, i, r, s, n) {
					void 0 === n && (n = null);
					for (var a = 0, o = e.length, h = i.frame; a < s; ) {
						var u = t[2 * (r + a)],
							l = t[2 * (r + a) + 1];
						if (n) {
							var c = n.a * u + n.c * l + n.tx;
							(l = n.b * u + n.d * l + n.ty), (u = c);
						}
						a++, e.push(u / h.width, l / h.height);
					}
					var d = i.baseTexture;
					(h.width < d.width || h.height < d.height) &&
						this.adjustUvs(e, i, o, s);
				}),
				(e.prototype.adjustUvs = function (t, e, i, r) {
					for (
						var s = e.baseTexture,
							n = 1e-6,
							a = i + 2 * r,
							o = e.frame,
							h = o.width / s.width,
							u = o.height / s.height,
							l = o.x / o.width,
							c = o.y / o.height,
							d = Math.floor(t[i] + n),
							p = Math.floor(t[i + 1] + n),
							f = i + 2;
						f < a;
						f += 2
					)
						(d = Math.min(d, Math.floor(t[f] + n))),
							(p = Math.min(p, Math.floor(t[f + 1] + n)));
					for (l -= d, c -= p, f = i; f < a; f += 2)
						(t[f] = (t[f] + l) * h), (t[f + 1] = (t[f + 1] + c) * u);
				}),
				(e.BATCHABLE_SIZE = 100),
				e
			);
		})(BatchGeometry$3),
		LineStyle = (function (t) {
			function e() {
				var e = (null !== t && t.apply(this, arguments)) || this;
				return (
					(e.width = 0),
					(e.alignment = 0.5),
					(e.native = !1),
					(e.cap = LINE_CAP.BUTT),
					(e.join = LINE_JOIN.MITER),
					(e.miterLimit = 10),
					e
				);
			}
			return (
				__extends$i(e, t),
				(e.prototype.clone = function () {
					var t = new e();
					return (
						(t.color = this.color),
						(t.alpha = this.alpha),
						(t.texture = this.texture),
						(t.matrix = this.matrix),
						(t.visible = this.visible),
						(t.width = this.width),
						(t.alignment = this.alignment),
						(t.native = this.native),
						(t.cap = this.cap),
						(t.join = this.join),
						(t.miterLimit = this.miterLimit),
						t
					);
				}),
				(e.prototype.reset = function () {
					t.prototype.reset.call(this),
						(this.color = 0),
						(this.alignment = 0.5),
						(this.width = 0),
						(this.native = !1);
				}),
				e
			);
		})(FillStyle),
		temp = new Float32Array(3),
		DEFAULT_SHADERS = {},
		Graphics$1 = (function (t) {
			function e(e) {
				void 0 === e && (e = null);
				var i = t.call(this) || this;
				return (
					(i.shader = null),
					(i.pluginName = 'batch'),
					(i.currentPath = null),
					(i.batches = []),
					(i.batchTint = -1),
					(i.batchDirty = -1),
					(i.vertexData = null),
					(i._fillStyle = new FillStyle()),
					(i._lineStyle = new LineStyle()),
					(i._matrix = null),
					(i._holeMode = !1),
					(i.state = State$3.for2d()),
					(i._geometry = e || new GraphicsGeometry()),
					i._geometry.refCount++,
					(i._transformID = -1),
					(i.tint = 16777215),
					(i.blendMode = BLEND_MODES$9.NORMAL),
					i
				);
			}
			return (
				__extends$i(e, t),
				Object.defineProperty(e.prototype, 'geometry', {
					get: function () {
						return this._geometry;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.clone = function () {
					return this.finishPoly(), new e(this._geometry);
				}),
				Object.defineProperty(e.prototype, 'blendMode', {
					get: function () {
						return this.state.blendMode;
					},
					set: function (t) {
						this.state.blendMode = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'tint', {
					get: function () {
						return this._tint;
					},
					set: function (t) {
						this._tint = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'fill', {
					get: function () {
						return this._fillStyle;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'line', {
					get: function () {
						return this._lineStyle;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.lineStyle = function (t, e, i, r, s) {
					return (
						void 0 === t && (t = null),
						void 0 === e && (e = 0),
						void 0 === i && (i = 1),
						void 0 === r && (r = 0.5),
						void 0 === s && (s = !1),
						'number' == typeof t &&
							(t = { width: t, color: e, alpha: i, alignment: r, native: s }),
						this.lineTextureStyle(t)
					);
				}),
				(e.prototype.lineTextureStyle = function (t) {
					(t = Object.assign(
						{
							width: 0,
							texture: Texture$3.WHITE,
							color: t && t.texture ? 16777215 : 0,
							alpha: 1,
							matrix: null,
							alignment: 0.5,
							native: !1,
							cap: LINE_CAP.BUTT,
							join: LINE_JOIN.MITER,
							miterLimit: 10,
						},
						t
					)),
						this.currentPath && this.startPoly();
					var e = t.width > 0 && t.alpha > 0;
					return (
						e
							? (t.matrix && ((t.matrix = t.matrix.clone()), t.matrix.invert()),
							  Object.assign(this._lineStyle, { visible: e }, t))
							: this._lineStyle.reset(),
						this
					);
				}),
				(e.prototype.startPoly = function () {
					if (this.currentPath) {
						var t = this.currentPath.points,
							e = this.currentPath.points.length;
						e > 2 &&
							(this.drawShape(this.currentPath),
							(this.currentPath = new Polygon()),
							(this.currentPath.closeStroke = !1),
							this.currentPath.points.push(t[e - 2], t[e - 1]));
					} else
						(this.currentPath = new Polygon()),
							(this.currentPath.closeStroke = !1);
				}),
				(e.prototype.finishPoly = function () {
					this.currentPath &&
						(this.currentPath.points.length > 2
							? (this.drawShape(this.currentPath), (this.currentPath = null))
							: (this.currentPath.points.length = 0));
				}),
				(e.prototype.moveTo = function (t, e) {
					return (
						this.startPoly(),
						(this.currentPath.points[0] = t),
						(this.currentPath.points[1] = e),
						this
					);
				}),
				(e.prototype.lineTo = function (t, e) {
					this.currentPath || this.moveTo(0, 0);
					var i = this.currentPath.points,
						r = i[i.length - 2],
						s = i[i.length - 1];
					return (r === t && s === e) || i.push(t, e), this;
				}),
				(e.prototype._initCurve = function (t, e) {
					void 0 === t && (t = 0),
						void 0 === e && (e = 0),
						this.currentPath
							? 0 === this.currentPath.points.length &&
							  (this.currentPath.points = [t, e])
							: this.moveTo(t, e);
				}),
				(e.prototype.quadraticCurveTo = function (t, e, i, r) {
					this._initCurve();
					var s = this.currentPath.points;
					return (
						0 === s.length && this.moveTo(0, 0),
						QuadraticUtils.curveTo(t, e, i, r, s),
						this
					);
				}),
				(e.prototype.bezierCurveTo = function (t, e, i, r, s, n) {
					return (
						this._initCurve(),
						BezierUtils.curveTo(t, e, i, r, s, n, this.currentPath.points),
						this
					);
				}),
				(e.prototype.arcTo = function (t, e, i, r, s) {
					this._initCurve(t, e);
					var n = this.currentPath.points,
						a = ArcUtils.curveTo(t, e, i, r, s, n);
					if (a) {
						var o = a.cx,
							h = a.cy,
							u = a.radius,
							l = a.startAngle,
							c = a.endAngle,
							d = a.anticlockwise;
						this.arc(o, h, u, l, c, d);
					}
					return this;
				}),
				(e.prototype.arc = function (t, e, i, r, s, n) {
					if ((void 0 === n && (n = !1), r === s)) return this;
					if (
						(!n && s <= r ? (s += PI_2$3) : n && r <= s && (r += PI_2$3),
						0 == s - r)
					)
						return this;
					var a = t + Math.cos(r) * i,
						o = e + Math.sin(r) * i,
						h = this._geometry.closePointEps,
						u = this.currentPath ? this.currentPath.points : null;
					if (u) {
						var l = Math.abs(u[u.length - 2] - a),
							c = Math.abs(u[u.length - 1] - o);
						(l < h && c < h) || u.push(a, o);
					} else this.moveTo(a, o), (u = this.currentPath.points);
					return ArcUtils.arc(a, o, t, e, i, r, s, n, u), this;
				}),
				(e.prototype.beginFill = function (t, e) {
					return (
						void 0 === t && (t = 0),
						void 0 === e && (e = 1),
						this.beginTextureFill({
							texture: Texture$3.WHITE,
							color: t,
							alpha: e,
						})
					);
				}),
				(e.prototype.beginTextureFill = function (t) {
					(t = Object.assign(
						{
							texture: Texture$3.WHITE,
							color: 16777215,
							alpha: 1,
							matrix: null,
						},
						t
					)),
						this.currentPath && this.startPoly();
					var e = t.alpha > 0;
					return (
						e
							? (t.matrix && ((t.matrix = t.matrix.clone()), t.matrix.invert()),
							  Object.assign(this._fillStyle, { visible: e }, t))
							: this._fillStyle.reset(),
						this
					);
				}),
				(e.prototype.endFill = function () {
					return this.finishPoly(), this._fillStyle.reset(), this;
				}),
				(e.prototype.drawRect = function (t, e, i, r) {
					return this.drawShape(new Rectangle$4(t, e, i, r));
				}),
				(e.prototype.drawRoundedRect = function (t, e, i, r, s) {
					return this.drawShape(new RoundedRectangle(t, e, i, r, s));
				}),
				(e.prototype.drawCircle = function (t, e, i) {
					return this.drawShape(new Circle(t, e, i));
				}),
				(e.prototype.drawEllipse = function (t, e, i, r) {
					return this.drawShape(new Ellipse(t, e, i, r));
				}),
				(e.prototype.drawPolygon = function () {
					for (var t, e = arguments, i = [], r = 0; r < arguments.length; r++)
						i[r] = e[r];
					var s = !0,
						n = i[0];
					n.points
						? ((s = n.closeStroke), (t = n.points))
						: (t = Array.isArray(i[0]) ? i[0] : i);
					var a = new Polygon(t);
					return (a.closeStroke = s), this.drawShape(a), this;
				}),
				(e.prototype.drawShape = function (t) {
					return (
						this._holeMode
							? this._geometry.drawHole(t, this._matrix)
							: this._geometry.drawShape(
									t,
									this._fillStyle.clone(),
									this._lineStyle.clone(),
									this._matrix
							  ),
						this
					);
				}),
				(e.prototype.clear = function () {
					return (
						this._geometry.clear(),
						this._lineStyle.reset(),
						this._fillStyle.reset(),
						this._boundsID++,
						(this._matrix = null),
						(this._holeMode = !1),
						(this.currentPath = null),
						this
					);
				}),
				(e.prototype.isFastRect = function () {
					var t = this._geometry.graphicsData;
					return !(
						1 !== t.length ||
						t[0].shape.type !== SHAPES$3.RECT ||
						t[0].matrix ||
						t[0].holes.length ||
						(t[0].lineStyle.visible && t[0].lineStyle.width)
					);
				}),
				(e.prototype._render = function (t) {
					this.finishPoly();
					var e = this._geometry,
						i = t.context.supports.uint32Indices;
					e.updateBatches(i),
						e.batchable
							? (this.batchDirty !== e.batchDirty && this._populateBatches(),
							  this._renderBatched(t))
							: (t.batch.flush(), this._renderDirect(t));
				}),
				(e.prototype._populateBatches = function () {
					var t = this._geometry,
						e = this.blendMode,
						i = t.batches.length;
					(this.batchTint = -1),
						(this._transformID = -1),
						(this.batchDirty = t.batchDirty),
						(this.batches.length = i),
						(this.vertexData = new Float32Array(t.points));
					for (var r = 0; r < i; r++) {
						var s = t.batches[r],
							n = s.style.color,
							a = new Float32Array(
								this.vertexData.buffer,
								4 * s.attribStart * 2,
								2 * s.attribSize
							),
							o = new Float32Array(
								t.uvsFloat32.buffer,
								4 * s.attribStart * 2,
								2 * s.attribSize
							),
							h = {
								vertexData: a,
								blendMode: e,
								indices: new Uint16Array(
									t.indicesUint16.buffer,
									2 * s.start,
									s.size
								),
								uvs: o,
								_batchRGB: hex2rgb$3(n),
								_tintRGB: n,
								_texture: s.style.texture,
								alpha: s.style.alpha,
								worldAlpha: 1,
							};
						this.batches[r] = h;
					}
				}),
				(e.prototype._renderBatched = function (t) {
					if (this.batches.length) {
						t.batch.setObjectRenderer(t.plugins[this.pluginName]),
							this.calculateVertices(),
							this.calculateTints();
						for (var e = 0, i = this.batches.length; e < i; e++) {
							var r = this.batches[e];
							(r.worldAlpha = this.worldAlpha * r.alpha),
								t.plugins[this.pluginName].render(r);
						}
					}
				}),
				(e.prototype._renderDirect = function (t) {
					var e = this._resolveDirectShader(t),
						i = this._geometry,
						r = this.tint,
						s = this.worldAlpha,
						n = e.uniforms,
						a = i.drawCalls;
					(n.translationMatrix = this.transform.worldTransform),
						(n.tint[0] = (((r >> 16) & 255) / 255) * s),
						(n.tint[1] = (((r >> 8) & 255) / 255) * s),
						(n.tint[2] = ((255 & r) / 255) * s),
						(n.tint[3] = s),
						t.shader.bind(e),
						t.geometry.bind(i, e),
						t.state.set(this.state);
					for (var o = 0, h = a.length; o < h; o++)
						this._renderDrawCallDirect(t, i.drawCalls[o]);
				}),
				(e.prototype._renderDrawCallDirect = function (t, e) {
					for (
						var i = e.texArray,
							r = e.type,
							s = e.size,
							n = e.start,
							a = i.count,
							o = 0;
						o < a;
						o++
					)
						t.texture.bind(i.elements[o], o);
					t.geometry.draw(r, s, n);
				}),
				(e.prototype._resolveDirectShader = function (t) {
					var e = this.shader,
						i = this.pluginName;
					if (!e) {
						if (!DEFAULT_SHADERS[i]) {
							for (
								var r = t.plugins[i].MAX_TEXTURES, s = new Int32Array(r), n = 0;
								n < r;
								n++
							)
								s[n] = n;
							var a = {
									tint: new Float32Array([1, 1, 1, 1]),
									translationMatrix: new Matrix$3(),
									default: UniformGroup$3.from({ uSamplers: s }, !0),
								},
								o = t.plugins[i]._shader.program;
							DEFAULT_SHADERS[i] = new Shader$3(o, a);
						}
						e = DEFAULT_SHADERS[i];
					}
					return e;
				}),
				(e.prototype._calculateBounds = function () {
					this.finishPoly();
					var t = this._geometry;
					if (t.graphicsData.length) {
						var e = t.bounds,
							i = e.minX,
							r = e.minY,
							s = e.maxX,
							n = e.maxY;
						this._bounds.addFrame(this.transform, i, r, s, n);
					}
				}),
				(e.prototype.containsPoint = function (t) {
					return (
						this.worldTransform.applyInverse(t, e._TEMP_POINT),
						this._geometry.containsPoint(e._TEMP_POINT)
					);
				}),
				(e.prototype.calculateTints = function () {
					if (this.batchTint !== this.tint) {
						this.batchTint = this.tint;
						for (
							var t = hex2rgb$3(this.tint, temp), e = 0;
							e < this.batches.length;
							e++
						) {
							var i = this.batches[e],
								r = i._batchRGB,
								s =
									((t[0] * r[0] * 255) << 16) +
									((t[1] * r[1] * 255) << 8) +
									(0 | (t[2] * r[2] * 255));
							i._tintRGB = (s >> 16) + (65280 & s) + ((255 & s) << 16);
						}
					}
				}),
				(e.prototype.calculateVertices = function () {
					var t = this.transform._worldID;
					if (this._transformID !== t) {
						this._transformID = t;
						for (
							var e = this.transform.worldTransform,
								i = e.a,
								r = e.b,
								s = e.c,
								n = e.d,
								a = e.tx,
								o = e.ty,
								h = this._geometry.points,
								u = this.vertexData,
								l = 0,
								c = 0;
							c < h.length;
							c += 2
						) {
							var d = h[c],
								p = h[c + 1];
							(u[l++] = i * d + s * p + a), (u[l++] = n * p + r * d + o);
						}
					}
				}),
				(e.prototype.closePath = function () {
					var t = this.currentPath;
					return t && ((t.closeStroke = !0), this.finishPoly()), this;
				}),
				(e.prototype.setMatrix = function (t) {
					return (this._matrix = t), this;
				}),
				(e.prototype.beginHole = function () {
					return this.finishPoly(), (this._holeMode = !0), this;
				}),
				(e.prototype.endHole = function () {
					return this.finishPoly(), (this._holeMode = !1), this;
				}),
				(e.prototype.destroy = function (e) {
					this._geometry.refCount--,
						0 === this._geometry.refCount && this._geometry.dispose(),
						(this._matrix = null),
						(this.currentPath = null),
						this._lineStyle.destroy(),
						(this._lineStyle = null),
						this._fillStyle.destroy(),
						(this._fillStyle = null),
						(this._geometry = null),
						(this.shader = null),
						(this.vertexData = null),
						(this.batches.length = 0),
						(this.batches = null),
						t.prototype.destroy.call(this, e);
				}),
				(e.nextRoundedRectBehavior = !1),
				(e._TEMP_POINT = new Point$4()),
				e
			);
		})(Container$2),
		graphicsUtils = {
			buildPoly,
			buildCircle,
			buildRectangle,
			buildRoundedRectangle,
			buildLine,
			ArcUtils,
			BezierUtils,
			QuadraticUtils,
			BatchPart,
			FILL_COMMANDS,
			BATCH_POOL,
			DRAW_CALL_POOL,
		},
		extendStatics$h = function (t, e) {
			return (extendStatics$h =
				Object.setPrototypeOf ||
				({ __proto__: [] } instanceof Array &&
					function (t, e) {
						t.__proto__ = e;
					}) ||
				function (t, e) {
					for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
				})(t, e);
		};
	function __extends$h(t, e) {
		function i() {
			this.constructor = t;
		}
		extendStatics$h(t, e),
			(t.prototype =
				null === e ? Object.create(e) : ((i.prototype = e.prototype), new i()));
	}
	var PlaneGeometry = (function (t) {
			function e(e, i, r, s) {
				void 0 === e && (e = 100),
					void 0 === i && (i = 100),
					void 0 === r && (r = 10),
					void 0 === s && (s = 10);
				var n = t.call(this) || this;
				return (
					(n.segWidth = r),
					(n.segHeight = s),
					(n.width = e),
					(n.height = i),
					n.build(),
					n
				);
			}
			return (
				__extends$h(e, t),
				(e.prototype.build = function () {
					for (
						var t = this.segWidth * this.segHeight,
							e = [],
							i = [],
							r = [],
							s = this.segWidth - 1,
							n = this.segHeight - 1,
							a = this.width / s,
							o = this.height / n,
							h = 0;
						h < t;
						h++
					) {
						var u = h % this.segWidth,
							l = (h / this.segWidth) | 0;
						e.push(u * a, l * o), i.push(u / s, l / n);
					}
					var c = s * n;
					for (h = 0; h < c; h++) {
						var d = h % s,
							p = (h / s) | 0,
							f = p * this.segWidth + d,
							m = p * this.segWidth + d + 1,
							_ = (p + 1) * this.segWidth + d,
							g = (p + 1) * this.segWidth + d + 1;
						r.push(f, m, _, m, g, _);
					}
					(this.buffers[0].data = new Float32Array(e)),
						(this.buffers[1].data = new Float32Array(i)),
						(this.indexBuffer.data = new Uint16Array(r)),
						this.buffers[0].update(),
						this.buffers[1].update(),
						this.indexBuffer.update();
				}),
				e
			);
		})(MeshGeometry),
		RopeGeometry = (function (t) {
			function e(e, i, r) {
				void 0 === e && (e = 200), void 0 === r && (r = 0);
				var s =
					t.call(
						this,
						new Float32Array(4 * i.length),
						new Float32Array(4 * i.length),
						new Uint16Array(6 * (i.length - 1))
					) || this;
				return (
					(s.points = i), (s._width = e), (s.textureScale = r), s.build(), s
				);
			}
			return (
				__extends$h(e, t),
				Object.defineProperty(e.prototype, 'width', {
					get: function () {
						return this._width;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.build = function () {
					var t = this.points;
					if (t) {
						var e = this.getBuffer('aVertexPosition'),
							i = this.getBuffer('aTextureCoord'),
							r = this.getIndex();
						if (!(t.length < 1)) {
							e.data.length / 4 !== t.length &&
								((e.data = new Float32Array(4 * t.length)),
								(i.data = new Float32Array(4 * t.length)),
								(r.data = new Uint16Array(6 * (t.length - 1))));
							var s = i.data,
								n = r.data;
							(s[0] = 0), (s[1] = 0), (s[2] = 0), (s[3] = 1);
							for (
								var a = 0,
									o = t[0],
									h = this._width * this.textureScale,
									u = t.length,
									l = 0;
								l < u;
								l++
							) {
								var c = 4 * l;
								if (this.textureScale > 0) {
									var d = o.x - t[l].x,
										p = o.y - t[l].y,
										f = Math.sqrt(d * d + p * p);
									(o = t[l]), (a += f / h);
								} else a = l / (u - 1);
								(s[c] = a), (s[c + 1] = 0), (s[c + 2] = a), (s[c + 3] = 1);
							}
							var m = 0;
							for (l = 0; l < u - 1; l++)
								(c = 2 * l),
									(n[m++] = c),
									(n[m++] = c + 1),
									(n[m++] = c + 2),
									(n[m++] = c + 2),
									(n[m++] = c + 1),
									(n[m++] = c + 3);
							i.update(), r.update(), this.updateVertices();
						}
					}
				}),
				(e.prototype.updateVertices = function () {
					var t = this.points;
					if (!(t.length < 1)) {
						for (
							var e,
								i = t[0],
								r = 0,
								s = 0,
								n = this.buffers[0].data,
								a = t.length,
								o = 0;
							o < a;
							o++
						) {
							var h = t[o],
								u = 4 * o;
							(s = -((e = o < t.length - 1 ? t[o + 1] : h).x - i.x)),
								(r = e.y - i.y);
							var l = Math.sqrt(r * r + s * s),
								c =
									this.textureScale > 0
										? (this.textureScale * this._width) / 2
										: this._width / 2;
							(r /= l),
								(s /= l),
								(r *= c),
								(s *= c),
								(n[u] = h.x + r),
								(n[u + 1] = h.y + s),
								(n[u + 2] = h.x - r),
								(n[u + 3] = h.y - s),
								(i = h);
						}
						this.buffers[0].update();
					}
				}),
				(e.prototype.update = function () {
					this.textureScale > 0 ? this.build() : this.updateVertices();
				}),
				e
			);
		})(MeshGeometry),
		SimpleRope = (function (t) {
			function e(e, i, r) {
				void 0 === r && (r = 0);
				var s = this,
					n = new RopeGeometry(e.height, i, r),
					a = new MeshMaterial(e);
				return (
					r > 0 && (e.baseTexture.wrapMode = WRAP_MODES$9.REPEAT),
					((s = t.call(this, n, a) || this).autoUpdate = !0),
					s
				);
			}
			return (
				__extends$h(e, t),
				(e.prototype._render = function (e) {
					var i = this.geometry;
					(this.autoUpdate || i._width !== this.shader.texture.height) &&
						((i._width = this.shader.texture.height), i.update()),
						t.prototype._render.call(this, e);
				}),
				e
			);
		})(Mesh),
		SimplePlane = (function (t) {
			function e(e, i, r) {
				var s = this,
					n = new PlaneGeometry(e.width, e.height, i, r),
					a = new MeshMaterial(Texture$3.WHITE);
				return (
					((s = t.call(this, n, a) || this).texture = e), (s.autoResize = !0), s
				);
			}
			return (
				__extends$h(e, t),
				(e.prototype.textureUpdated = function () {
					this._textureID = this.shader.texture._updateID;
					var t = this.geometry,
						e = this.shader.texture,
						i = e.width,
						r = e.height;
					!this.autoResize ||
						(t.width === i && t.height === r) ||
						((t.width = this.shader.texture.width),
						(t.height = this.shader.texture.height),
						t.build());
				}),
				Object.defineProperty(e.prototype, 'texture', {
					get: function () {
						return this.shader.texture;
					},
					set: function (t) {
						this.shader.texture !== t &&
							((this.shader.texture = t),
							(this._textureID = -1),
							t.baseTexture.valid
								? this.textureUpdated()
								: t.once('update', this.textureUpdated, this));
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype._render = function (e) {
					this._textureID !== this.shader.texture._updateID &&
						this.textureUpdated(),
						t.prototype._render.call(this, e);
				}),
				(e.prototype.destroy = function (e) {
					this.shader.texture.off('update', this.textureUpdated, this),
						t.prototype.destroy.call(this, e);
				}),
				e
			);
		})(Mesh),
		SimpleMesh = (function (t) {
			function e(e, i, r, s, n) {
				void 0 === e && (e = Texture$3.EMPTY);
				var a = this,
					o = new MeshGeometry(i, r, s);
				o.getBuffer('aVertexPosition').static = !1;
				var h = new MeshMaterial(e);
				return ((a = t.call(this, o, h, null, n) || this).autoUpdate = !0), a;
			}
			return (
				__extends$h(e, t),
				Object.defineProperty(e.prototype, 'vertices', {
					get: function () {
						return this.geometry.getBuffer('aVertexPosition').data;
					},
					set: function (t) {
						this.geometry.getBuffer('aVertexPosition').data = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype._render = function (e) {
					this.autoUpdate &&
						this.geometry.getBuffer('aVertexPosition').update(),
						t.prototype._render.call(this, e);
				}),
				e
			);
		})(Mesh),
		DEFAULT_BORDER_SIZE = 10,
		NineSlicePlane = (function (t) {
			function e(e, i, r, s, n) {
				void 0 === i && (i = DEFAULT_BORDER_SIZE),
					void 0 === r && (r = DEFAULT_BORDER_SIZE),
					void 0 === s && (s = DEFAULT_BORDER_SIZE),
					void 0 === n && (n = DEFAULT_BORDER_SIZE);
				var a = t.call(this, Texture$3.WHITE, 4, 4) || this;
				return (
					(a._origWidth = e.orig.width),
					(a._origHeight = e.orig.height),
					(a._width = a._origWidth),
					(a._height = a._origHeight),
					(a._leftWidth = i),
					(a._rightWidth = s),
					(a._topHeight = r),
					(a._bottomHeight = n),
					(a.texture = e),
					a
				);
			}
			return (
				__extends$h(e, t),
				(e.prototype.textureUpdated = function () {
					(this._textureID = this.shader.texture._updateID), this._refresh();
				}),
				Object.defineProperty(e.prototype, 'vertices', {
					get: function () {
						return this.geometry.getBuffer('aVertexPosition').data;
					},
					set: function (t) {
						this.geometry.getBuffer('aVertexPosition').data = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.updateHorizontalVertices = function () {
					var t = this.vertices,
						e = this._getMinScale();
					(t[9] = t[11] = t[13] = t[15] = this._topHeight * e),
						(t[17] =
							t[19] =
							t[21] =
							t[23] =
								this._height - this._bottomHeight * e),
						(t[25] = t[27] = t[29] = t[31] = this._height);
				}),
				(e.prototype.updateVerticalVertices = function () {
					var t = this.vertices,
						e = this._getMinScale();
					(t[2] = t[10] = t[18] = t[26] = this._leftWidth * e),
						(t[4] = t[12] = t[20] = t[28] = this._width - this._rightWidth * e),
						(t[6] = t[14] = t[22] = t[30] = this._width);
				}),
				(e.prototype._getMinScale = function () {
					var t = this._leftWidth + this._rightWidth,
						e = this._width > t ? 1 : this._width / t,
						i = this._topHeight + this._bottomHeight,
						r = this._height > i ? 1 : this._height / i;
					return Math.min(e, r);
				}),
				Object.defineProperty(e.prototype, 'width', {
					get: function () {
						return this._width;
					},
					set: function (t) {
						(this._width = t), this._refresh();
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'height', {
					get: function () {
						return this._height;
					},
					set: function (t) {
						(this._height = t), this._refresh();
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'leftWidth', {
					get: function () {
						return this._leftWidth;
					},
					set: function (t) {
						(this._leftWidth = t), this._refresh();
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'rightWidth', {
					get: function () {
						return this._rightWidth;
					},
					set: function (t) {
						(this._rightWidth = t), this._refresh();
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'topHeight', {
					get: function () {
						return this._topHeight;
					},
					set: function (t) {
						(this._topHeight = t), this._refresh();
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'bottomHeight', {
					get: function () {
						return this._bottomHeight;
					},
					set: function (t) {
						(this._bottomHeight = t), this._refresh();
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype._refresh = function () {
					var t = this.texture,
						e = this.geometry.buffers[1].data;
					(this._origWidth = t.orig.width), (this._origHeight = t.orig.height);
					var i = 1 / this._origWidth,
						r = 1 / this._origHeight;
					(e[0] = e[8] = e[16] = e[24] = 0),
						(e[1] = e[3] = e[5] = e[7] = 0),
						(e[6] = e[14] = e[22] = e[30] = 1),
						(e[25] = e[27] = e[29] = e[31] = 1),
						(e[2] = e[10] = e[18] = e[26] = i * this._leftWidth),
						(e[4] = e[12] = e[20] = e[28] = 1 - i * this._rightWidth),
						(e[9] = e[11] = e[13] = e[15] = r * this._topHeight),
						(e[17] = e[19] = e[21] = e[23] = 1 - r * this._bottomHeight),
						this.updateHorizontalVertices(),
						this.updateVerticalVertices(),
						this.geometry.buffers[0].update(),
						this.geometry.buffers[1].update();
				}),
				e
			);
		})(SimplePlane),
		ENV$5,
		RENDERER_TYPE$5,
		BUFFER_BITS$5,
		BLEND_MODES$5,
		DRAW_MODES$5,
		FORMATS$5,
		TARGETS$5,
		TYPES$5,
		SAMPLER_TYPES$5,
		SCALE_MODES$5,
		WRAP_MODES$5,
		MIPMAP_MODES$5,
		ALPHA_MODES$5,
		CLEAR_MODES$5,
		GC_MODES$5,
		PRECISION$5,
		MASK_TYPES$5,
		MSAA_QUALITY$5,
		BUFFER_TYPE$5;
	!(function (t) {
		(t[(t.WEBGL_LEGACY = 0)] = 'WEBGL_LEGACY'),
			(t[(t.WEBGL = 1)] = 'WEBGL'),
			(t[(t.WEBGL2 = 2)] = 'WEBGL2');
	})(ENV$5 || (ENV$5 = {})),
		(function (t) {
			(t[(t.UNKNOWN = 0)] = 'UNKNOWN'),
				(t[(t.WEBGL = 1)] = 'WEBGL'),
				(t[(t.CANVAS = 2)] = 'CANVAS');
		})(RENDERER_TYPE$5 || (RENDERER_TYPE$5 = {})),
		(function (t) {
			(t[(t.COLOR = 16384)] = 'COLOR'),
				(t[(t.DEPTH = 256)] = 'DEPTH'),
				(t[(t.STENCIL = 1024)] = 'STENCIL');
		})(BUFFER_BITS$5 || (BUFFER_BITS$5 = {})),
		(function (t) {
			(t[(t.NORMAL = 0)] = 'NORMAL'),
				(t[(t.ADD = 1)] = 'ADD'),
				(t[(t.MULTIPLY = 2)] = 'MULTIPLY'),
				(t[(t.SCREEN = 3)] = 'SCREEN'),
				(t[(t.OVERLAY = 4)] = 'OVERLAY'),
				(t[(t.DARKEN = 5)] = 'DARKEN'),
				(t[(t.LIGHTEN = 6)] = 'LIGHTEN'),
				(t[(t.COLOR_DODGE = 7)] = 'COLOR_DODGE'),
				(t[(t.COLOR_BURN = 8)] = 'COLOR_BURN'),
				(t[(t.HARD_LIGHT = 9)] = 'HARD_LIGHT'),
				(t[(t.SOFT_LIGHT = 10)] = 'SOFT_LIGHT'),
				(t[(t.DIFFERENCE = 11)] = 'DIFFERENCE'),
				(t[(t.EXCLUSION = 12)] = 'EXCLUSION'),
				(t[(t.HUE = 13)] = 'HUE'),
				(t[(t.SATURATION = 14)] = 'SATURATION'),
				(t[(t.COLOR = 15)] = 'COLOR'),
				(t[(t.LUMINOSITY = 16)] = 'LUMINOSITY'),
				(t[(t.NORMAL_NPM = 17)] = 'NORMAL_NPM'),
				(t[(t.ADD_NPM = 18)] = 'ADD_NPM'),
				(t[(t.SCREEN_NPM = 19)] = 'SCREEN_NPM'),
				(t[(t.NONE = 20)] = 'NONE'),
				(t[(t.SRC_OVER = 0)] = 'SRC_OVER'),
				(t[(t.SRC_IN = 21)] = 'SRC_IN'),
				(t[(t.SRC_OUT = 22)] = 'SRC_OUT'),
				(t[(t.SRC_ATOP = 23)] = 'SRC_ATOP'),
				(t[(t.DST_OVER = 24)] = 'DST_OVER'),
				(t[(t.DST_IN = 25)] = 'DST_IN'),
				(t[(t.DST_OUT = 26)] = 'DST_OUT'),
				(t[(t.DST_ATOP = 27)] = 'DST_ATOP'),
				(t[(t.ERASE = 26)] = 'ERASE'),
				(t[(t.SUBTRACT = 28)] = 'SUBTRACT'),
				(t[(t.XOR = 29)] = 'XOR');
		})(BLEND_MODES$5 || (BLEND_MODES$5 = {})),
		(function (t) {
			(t[(t.POINTS = 0)] = 'POINTS'),
				(t[(t.LINES = 1)] = 'LINES'),
				(t[(t.LINE_LOOP = 2)] = 'LINE_LOOP'),
				(t[(t.LINE_STRIP = 3)] = 'LINE_STRIP'),
				(t[(t.TRIANGLES = 4)] = 'TRIANGLES'),
				(t[(t.TRIANGLE_STRIP = 5)] = 'TRIANGLE_STRIP'),
				(t[(t.TRIANGLE_FAN = 6)] = 'TRIANGLE_FAN');
		})(DRAW_MODES$5 || (DRAW_MODES$5 = {})),
		(function (t) {
			(t[(t.RGBA = 6408)] = 'RGBA'),
				(t[(t.RGB = 6407)] = 'RGB'),
				(t[(t.RG = 33319)] = 'RG'),
				(t[(t.RED = 6403)] = 'RED'),
				(t[(t.RGBA_INTEGER = 36249)] = 'RGBA_INTEGER'),
				(t[(t.RGB_INTEGER = 36248)] = 'RGB_INTEGER'),
				(t[(t.RG_INTEGER = 33320)] = 'RG_INTEGER'),
				(t[(t.RED_INTEGER = 36244)] = 'RED_INTEGER'),
				(t[(t.ALPHA = 6406)] = 'ALPHA'),
				(t[(t.LUMINANCE = 6409)] = 'LUMINANCE'),
				(t[(t.LUMINANCE_ALPHA = 6410)] = 'LUMINANCE_ALPHA'),
				(t[(t.DEPTH_COMPONENT = 6402)] = 'DEPTH_COMPONENT'),
				(t[(t.DEPTH_STENCIL = 34041)] = 'DEPTH_STENCIL');
		})(FORMATS$5 || (FORMATS$5 = {})),
		(function (t) {
			(t[(t.TEXTURE_2D = 3553)] = 'TEXTURE_2D'),
				(t[(t.TEXTURE_CUBE_MAP = 34067)] = 'TEXTURE_CUBE_MAP'),
				(t[(t.TEXTURE_2D_ARRAY = 35866)] = 'TEXTURE_2D_ARRAY'),
				(t[(t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069)] =
					'TEXTURE_CUBE_MAP_POSITIVE_X'),
				(t[(t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070)] =
					'TEXTURE_CUBE_MAP_NEGATIVE_X'),
				(t[(t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071)] =
					'TEXTURE_CUBE_MAP_POSITIVE_Y'),
				(t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072)] =
					'TEXTURE_CUBE_MAP_NEGATIVE_Y'),
				(t[(t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073)] =
					'TEXTURE_CUBE_MAP_POSITIVE_Z'),
				(t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074)] =
					'TEXTURE_CUBE_MAP_NEGATIVE_Z');
		})(TARGETS$5 || (TARGETS$5 = {})),
		(function (t) {
			(t[(t.UNSIGNED_BYTE = 5121)] = 'UNSIGNED_BYTE'),
				(t[(t.UNSIGNED_SHORT = 5123)] = 'UNSIGNED_SHORT'),
				(t[(t.UNSIGNED_SHORT_5_6_5 = 33635)] = 'UNSIGNED_SHORT_5_6_5'),
				(t[(t.UNSIGNED_SHORT_4_4_4_4 = 32819)] = 'UNSIGNED_SHORT_4_4_4_4'),
				(t[(t.UNSIGNED_SHORT_5_5_5_1 = 32820)] = 'UNSIGNED_SHORT_5_5_5_1'),
				(t[(t.UNSIGNED_INT = 5125)] = 'UNSIGNED_INT'),
				(t[(t.UNSIGNED_INT_10F_11F_11F_REV = 35899)] =
					'UNSIGNED_INT_10F_11F_11F_REV'),
				(t[(t.UNSIGNED_INT_2_10_10_10_REV = 33640)] =
					'UNSIGNED_INT_2_10_10_10_REV'),
				(t[(t.UNSIGNED_INT_24_8 = 34042)] = 'UNSIGNED_INT_24_8'),
				(t[(t.UNSIGNED_INT_5_9_9_9_REV = 35902)] = 'UNSIGNED_INT_5_9_9_9_REV'),
				(t[(t.BYTE = 5120)] = 'BYTE'),
				(t[(t.SHORT = 5122)] = 'SHORT'),
				(t[(t.INT = 5124)] = 'INT'),
				(t[(t.FLOAT = 5126)] = 'FLOAT'),
				(t[(t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269)] =
					'FLOAT_32_UNSIGNED_INT_24_8_REV'),
				(t[(t.HALF_FLOAT = 36193)] = 'HALF_FLOAT');
		})(TYPES$5 || (TYPES$5 = {})),
		(function (t) {
			(t[(t.FLOAT = 0)] = 'FLOAT'),
				(t[(t.INT = 1)] = 'INT'),
				(t[(t.UINT = 2)] = 'UINT');
		})(SAMPLER_TYPES$5 || (SAMPLER_TYPES$5 = {})),
		(function (t) {
			(t[(t.NEAREST = 0)] = 'NEAREST'), (t[(t.LINEAR = 1)] = 'LINEAR');
		})(SCALE_MODES$5 || (SCALE_MODES$5 = {})),
		(function (t) {
			(t[(t.CLAMP = 33071)] = 'CLAMP'),
				(t[(t.REPEAT = 10497)] = 'REPEAT'),
				(t[(t.MIRRORED_REPEAT = 33648)] = 'MIRRORED_REPEAT');
		})(WRAP_MODES$5 || (WRAP_MODES$5 = {})),
		(function (t) {
			(t[(t.OFF = 0)] = 'OFF'),
				(t[(t.POW2 = 1)] = 'POW2'),
				(t[(t.ON = 2)] = 'ON'),
				(t[(t.ON_MANUAL = 3)] = 'ON_MANUAL');
		})(MIPMAP_MODES$5 || (MIPMAP_MODES$5 = {})),
		(function (t) {
			(t[(t.NPM = 0)] = 'NPM'),
				(t[(t.UNPACK = 1)] = 'UNPACK'),
				(t[(t.PMA = 2)] = 'PMA'),
				(t[(t.NO_PREMULTIPLIED_ALPHA = 0)] = 'NO_PREMULTIPLIED_ALPHA'),
				(t[(t.PREMULTIPLY_ON_UPLOAD = 1)] = 'PREMULTIPLY_ON_UPLOAD'),
				(t[(t.PREMULTIPLY_ALPHA = 2)] = 'PREMULTIPLY_ALPHA'),
				(t[(t.PREMULTIPLIED_ALPHA = 2)] = 'PREMULTIPLIED_ALPHA');
		})(ALPHA_MODES$5 || (ALPHA_MODES$5 = {})),
		(function (t) {
			(t[(t.NO = 0)] = 'NO'),
				(t[(t.YES = 1)] = 'YES'),
				(t[(t.AUTO = 2)] = 'AUTO'),
				(t[(t.BLEND = 0)] = 'BLEND'),
				(t[(t.CLEAR = 1)] = 'CLEAR'),
				(t[(t.BLIT = 2)] = 'BLIT');
		})(CLEAR_MODES$5 || (CLEAR_MODES$5 = {})),
		(function (t) {
			(t[(t.AUTO = 0)] = 'AUTO'), (t[(t.MANUAL = 1)] = 'MANUAL');
		})(GC_MODES$5 || (GC_MODES$5 = {})),
		(function (t) {
			(t.LOW = 'lowp'), (t.MEDIUM = 'mediump'), (t.HIGH = 'highp');
		})(PRECISION$5 || (PRECISION$5 = {})),
		(function (t) {
			(t[(t.NONE = 0)] = 'NONE'),
				(t[(t.SCISSOR = 1)] = 'SCISSOR'),
				(t[(t.STENCIL = 2)] = 'STENCIL'),
				(t[(t.SPRITE = 3)] = 'SPRITE');
		})(MASK_TYPES$5 || (MASK_TYPES$5 = {})),
		(function (t) {
			(t[(t.NONE = 0)] = 'NONE'),
				(t[(t.LOW = 2)] = 'LOW'),
				(t[(t.MEDIUM = 4)] = 'MEDIUM'),
				(t[(t.HIGH = 8)] = 'HIGH');
		})(MSAA_QUALITY$5 || (MSAA_QUALITY$5 = {})),
		(function (t) {
			(t[(t.ELEMENT_ARRAY_BUFFER = 34963)] = 'ELEMENT_ARRAY_BUFFER'),
				(t[(t.ARRAY_BUFFER = 34962)] = 'ARRAY_BUFFER'),
				(t[(t.UNIFORM_BUFFER = 35345)] = 'UNIFORM_BUFFER');
		})(BUFFER_TYPE$5 || (BUFFER_TYPE$5 = {}));
	var _tempMatrix = new Matrix$3();
	(DisplayObject$2.prototype._cacheAsBitmap = !1),
		(DisplayObject$2.prototype._cacheData = null),
		(DisplayObject$2.prototype._cacheAsBitmapResolution = null),
		(DisplayObject$2.prototype._cacheAsBitmapMultisample = MSAA_QUALITY$5.NONE);
	var CacheData = function () {
		(this.textureCacheId = null),
			(this.originalRender = null),
			(this.originalRenderCanvas = null),
			(this.originalCalculateBounds = null),
			(this.originalGetLocalBounds = null),
			(this.originalUpdateTransform = null),
			(this.originalDestroy = null),
			(this.originalMask = null),
			(this.originalFilterArea = null),
			(this.originalContainsPoint = null),
			(this.sprite = null);
	};
	Object.defineProperties(DisplayObject$2.prototype, {
		cacheAsBitmapResolution: {
			get: function () {
				return this._cacheAsBitmapResolution;
			},
			set: function (t) {
				t !== this._cacheAsBitmapResolution &&
					((this._cacheAsBitmapResolution = t),
					this.cacheAsBitmap &&
						((this.cacheAsBitmap = !1), (this.cacheAsBitmap = !0)));
			},
		},
		cacheAsBitmapMultisample: {
			get: function () {
				return this._cacheAsBitmapMultisample;
			},
			set: function (t) {
				t !== this._cacheAsBitmapMultisample &&
					((this._cacheAsBitmapMultisample = t),
					this.cacheAsBitmap &&
						((this.cacheAsBitmap = !1), (this.cacheAsBitmap = !0)));
			},
		},
		cacheAsBitmap: {
			get: function () {
				return this._cacheAsBitmap;
			},
			set: function (t) {
				var e;
				this._cacheAsBitmap !== t &&
					((this._cacheAsBitmap = t),
					t
						? (this._cacheData || (this._cacheData = new CacheData()),
						  ((e = this._cacheData).originalRender = this.render),
						  (e.originalRenderCanvas = this.renderCanvas),
						  (e.originalUpdateTransform = this.updateTransform),
						  (e.originalCalculateBounds = this.calculateBounds),
						  (e.originalGetLocalBounds = this.getLocalBounds),
						  (e.originalDestroy = this.destroy),
						  (e.originalContainsPoint = this.containsPoint),
						  (e.originalMask = this._mask),
						  (e.originalFilterArea = this.filterArea),
						  (this.render = this._renderCached),
						  (this.renderCanvas = this._renderCachedCanvas),
						  (this.destroy = this._cacheAsBitmapDestroy))
						: ((e = this._cacheData).sprite &&
								this._destroyCachedDisplayObject(),
						  (this.render = e.originalRender),
						  (this.renderCanvas = e.originalRenderCanvas),
						  (this.calculateBounds = e.originalCalculateBounds),
						  (this.getLocalBounds = e.originalGetLocalBounds),
						  (this.destroy = e.originalDestroy),
						  (this.updateTransform = e.originalUpdateTransform),
						  (this.containsPoint = e.originalContainsPoint),
						  (this._mask = e.originalMask),
						  (this.filterArea = e.originalFilterArea)));
			},
		},
	}),
		(DisplayObject$2.prototype._renderCached = function (t) {
			!this.visible ||
				this.worldAlpha <= 0 ||
				!this.renderable ||
				(this._initCachedDisplayObject(t),
				(this._cacheData.sprite.transform._worldID = this.transform._worldID),
				(this._cacheData.sprite.worldAlpha = this.worldAlpha),
				this._cacheData.sprite._render(t));
		}),
		(DisplayObject$2.prototype._initCachedDisplayObject = function (t) {
			var e;
			if (!this._cacheData || !this._cacheData.sprite) {
				var i = this.alpha;
				(this.alpha = 1), t.batch.flush();
				var r = this.getLocalBounds(null, !0).clone();
				if (this.filters && this.filters.length) {
					var s = this.filters[0].padding;
					r.pad(s);
				}
				r.ceil(settings$4.RESOLUTION);
				var n = t.renderTexture.current,
					a = t.renderTexture.sourceFrame.clone(),
					o = t.renderTexture.destinationFrame.clone(),
					h = t.projection.transform,
					u = RenderTexture$3.create({
						width: r.width,
						height: r.height,
						resolution: this.cacheAsBitmapResolution || t.resolution,
						multisample:
							null !== (e = this.cacheAsBitmapMultisample) && void 0 !== e
								? e
								: t.multisample,
					}),
					l = 'cacheAsBitmap_' + uid$3();
				(this._cacheData.textureCacheId = l),
					BaseTexture$3.addToCache(u.baseTexture, l),
					Texture$3.addToCache(u, l);
				var c = this.transform.localTransform
					.copyTo(_tempMatrix)
					.invert()
					.translate(-r.x, -r.y);
				(this.render = this._cacheData.originalRender),
					t.render(this, {
						renderTexture: u,
						clear: !0,
						transform: c,
						skipUpdateTransform: !1,
					}),
					t.framebuffer.blit(),
					(t.projection.transform = h),
					t.renderTexture.bind(n, a, o),
					(this.render = this._renderCached),
					(this.updateTransform = this.displayObjectUpdateTransform),
					(this.calculateBounds = this._calculateCachedBounds),
					(this.getLocalBounds = this._getCachedLocalBounds),
					(this._mask = null),
					(this.filterArea = null),
					(this.alpha = i);
				var d = new Sprite$1(u);
				(d.transform.worldTransform = this.transform.worldTransform),
					(d.anchor.x = -r.x / r.width),
					(d.anchor.y = -r.y / r.height),
					(d.alpha = i),
					(d._bounds = this._bounds),
					(this._cacheData.sprite = d),
					(this.transform._parentID = -1),
					this.parent
						? this.updateTransform()
						: (this.enableTempParent(),
						  this.updateTransform(),
						  this.disableTempParent(null)),
					(this.containsPoint = d.containsPoint.bind(d));
			}
		}),
		(DisplayObject$2.prototype._renderCachedCanvas = function (t) {
			!this.visible ||
				this.worldAlpha <= 0 ||
				!this.renderable ||
				(this._initCachedDisplayObjectCanvas(t),
				(this._cacheData.sprite.worldAlpha = this.worldAlpha),
				this._cacheData.sprite._renderCanvas(t));
		}),
		(DisplayObject$2.prototype._initCachedDisplayObjectCanvas = function (t) {
			if (!this._cacheData || !this._cacheData.sprite) {
				var e = this.getLocalBounds(null, !0),
					i = this.alpha;
				this.alpha = 1;
				var r = t.context,
					s = t._projTransform;
				e.ceil(settings$4.RESOLUTION);
				var n = RenderTexture$3.create({ width: e.width, height: e.height }),
					a = 'cacheAsBitmap_' + uid$3();
				(this._cacheData.textureCacheId = a),
					BaseTexture$3.addToCache(n.baseTexture, a),
					Texture$3.addToCache(n, a);
				var o = _tempMatrix;
				this.transform.localTransform.copyTo(o),
					o.invert(),
					(o.tx -= e.x),
					(o.ty -= e.y),
					(this.renderCanvas = this._cacheData.originalRenderCanvas),
					t.render(this, {
						renderTexture: n,
						clear: !0,
						transform: o,
						skipUpdateTransform: !1,
					}),
					(t.context = r),
					(t._projTransform = s),
					(this.renderCanvas = this._renderCachedCanvas),
					(this.updateTransform = this.displayObjectUpdateTransform),
					(this.calculateBounds = this._calculateCachedBounds),
					(this.getLocalBounds = this._getCachedLocalBounds),
					(this._mask = null),
					(this.filterArea = null),
					(this.alpha = i);
				var h = new Sprite$1(n);
				(h.transform.worldTransform = this.transform.worldTransform),
					(h.anchor.x = -e.x / e.width),
					(h.anchor.y = -e.y / e.height),
					(h.alpha = i),
					(h._bounds = this._bounds),
					(this._cacheData.sprite = h),
					(this.transform._parentID = -1),
					this.parent
						? this.updateTransform()
						: ((this.parent = t._tempDisplayObjectParent),
						  this.updateTransform(),
						  (this.parent = null)),
					(this.containsPoint = h.containsPoint.bind(h));
			}
		}),
		(DisplayObject$2.prototype._calculateCachedBounds = function () {
			this._bounds.clear(),
				(this._cacheData.sprite.transform._worldID = this.transform._worldID),
				this._cacheData.sprite._calculateBounds(),
				(this._bounds.updateID = this._boundsID);
		}),
		(DisplayObject$2.prototype._getCachedLocalBounds = function () {
			return this._cacheData.sprite.getLocalBounds(null);
		}),
		(DisplayObject$2.prototype._destroyCachedDisplayObject = function () {
			this._cacheData.sprite._texture.destroy(!0),
				(this._cacheData.sprite = null),
				BaseTexture$3.removeFromCache(this._cacheData.textureCacheId),
				Texture$3.removeFromCache(this._cacheData.textureCacheId),
				(this._cacheData.textureCacheId = null);
		}),
		(DisplayObject$2.prototype._cacheAsBitmapDestroy = function (t) {
			(this.cacheAsBitmap = !1), this.destroy(t);
		});
	/*!
	 * @pixi/sprite-tiling - v6.4.2
	 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
	 *
	 * @pixi/sprite-tiling is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 */
	/*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
	var extendStatics$g = function (t, e) {
		return (extendStatics$g =
			Object.setPrototypeOf ||
			({ __proto__: [] } instanceof Array &&
				function (t, e) {
					t.__proto__ = e;
				}) ||
			function (t, e) {
				for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
			})(t, e);
	};
	function __extends$g(t, e) {
		function i() {
			this.constructor = t;
		}
		extendStatics$g(t, e),
			(t.prototype =
				null === e ? Object.create(e) : ((i.prototype = e.prototype), new i()));
	}
	var tempPoint = new Point$4(),
		TilingSprite$1 = (function (t) {
			function e(e, i, r) {
				void 0 === i && (i = 100), void 0 === r && (r = 100);
				var s = t.call(this, e) || this;
				return (
					(s.tileTransform = new Transform$1()),
					(s._width = i),
					(s._height = r),
					(s.uvMatrix = s.texture.uvMatrix || new TextureMatrix$3(e)),
					(s.pluginName = 'tilingSprite'),
					(s.uvRespectAnchor = !1),
					s
				);
			}
			return (
				__extends$g(e, t),
				Object.defineProperty(e.prototype, 'clampMargin', {
					get: function () {
						return this.uvMatrix.clampMargin;
					},
					set: function (t) {
						(this.uvMatrix.clampMargin = t), this.uvMatrix.update(!0);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'tileScale', {
					get: function () {
						return this.tileTransform.scale;
					},
					set: function (t) {
						this.tileTransform.scale.copyFrom(t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'tilePosition', {
					get: function () {
						return this.tileTransform.position;
					},
					set: function (t) {
						this.tileTransform.position.copyFrom(t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype._onTextureUpdate = function () {
					this.uvMatrix && (this.uvMatrix.texture = this._texture),
						(this._cachedTint = 16777215);
				}),
				(e.prototype._render = function (t) {
					var e = this._texture;
					e &&
						e.valid &&
						(this.tileTransform.updateLocalTransform(),
						this.uvMatrix.update(),
						t.batch.setObjectRenderer(t.plugins[this.pluginName]),
						t.plugins[this.pluginName].render(this));
				}),
				(e.prototype._calculateBounds = function () {
					var t = this._width * -this._anchor._x,
						e = this._height * -this._anchor._y,
						i = this._width * (1 - this._anchor._x),
						r = this._height * (1 - this._anchor._y);
					this._bounds.addFrame(this.transform, t, e, i, r);
				}),
				(e.prototype.getLocalBounds = function (e) {
					return 0 === this.children.length
						? ((this._bounds.minX = this._width * -this._anchor._x),
						  (this._bounds.minY = this._height * -this._anchor._y),
						  (this._bounds.maxX = this._width * (1 - this._anchor._x)),
						  (this._bounds.maxY = this._height * (1 - this._anchor._y)),
						  e ||
								(this._localBoundsRect ||
									(this._localBoundsRect = new Rectangle$4()),
								(e = this._localBoundsRect)),
						  this._bounds.getRectangle(e))
						: t.prototype.getLocalBounds.call(this, e);
				}),
				(e.prototype.containsPoint = function (t) {
					this.worldTransform.applyInverse(t, tempPoint);
					var e = this._width,
						i = this._height,
						r = -e * this.anchor._x;
					if (tempPoint.x >= r && tempPoint.x < r + e) {
						var s = -i * this.anchor._y;
						if (tempPoint.y >= s && tempPoint.y < s + i) return !0;
					}
					return !1;
				}),
				(e.prototype.destroy = function (e) {
					t.prototype.destroy.call(this, e),
						(this.tileTransform = null),
						(this.uvMatrix = null);
				}),
				(e.from = function (t, i) {
					return new e(
						t instanceof Texture$3 ? t : Texture$3.from(t, i),
						i.width,
						i.height
					);
				}),
				Object.defineProperty(e.prototype, 'width', {
					get: function () {
						return this._width;
					},
					set: function (t) {
						this._width = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'height', {
					get: function () {
						return this._height;
					},
					set: function (t) {
						this._height = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				e
			);
		})(Sprite$1),
		fragmentSimpleSrc =
			'#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n',
		gl1VertexSrc =
			'#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n',
		gl1FragmentSrc =
			'#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n',
		gl2VertexSrc =
			'#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n',
		gl2FragmentSrc =
			'#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n',
		tempMat$3 = new Matrix$3(),
		TilingSpriteRenderer = (function (t) {
			function e(e) {
				var i = t.call(this, e) || this;
				return (
					e.runners.contextChange.add(i),
					(i.quad = new QuadUv$3()),
					(i.state = State$3.for2d()),
					i
				);
			}
			return (
				__extends$g(e, t),
				(e.prototype.contextChange = function () {
					var t = this.renderer,
						e = { globals: t.globalUniforms };
					(this.simpleShader = Shader$3.from(
						gl1VertexSrc,
						fragmentSimpleSrc,
						e
					)),
						(this.shader =
							t.context.webGLVersion > 1
								? Shader$3.from(gl2VertexSrc, gl2FragmentSrc, e)
								: Shader$3.from(gl1VertexSrc, gl1FragmentSrc, e));
				}),
				(e.prototype.render = function (t) {
					var e = this.renderer,
						i = this.quad,
						r = i.vertices;
					(r[0] = r[6] = t._width * -t.anchor.x),
						(r[1] = r[3] = t._height * -t.anchor.y),
						(r[2] = r[4] = t._width * (1 - t.anchor.x)),
						(r[5] = r[7] = t._height * (1 - t.anchor.y));
					var s = t.uvRespectAnchor ? t.anchor.x : 0,
						n = t.uvRespectAnchor ? t.anchor.y : 0;
					((r = i.uvs)[0] = r[6] = -s),
						(r[1] = r[3] = -n),
						(r[2] = r[4] = 1 - s),
						(r[5] = r[7] = 1 - n),
						i.invalidate();
					var a = t._texture,
						o = a.baseTexture,
						h = t.tileTransform.localTransform,
						u = t.uvMatrix,
						l =
							o.isPowerOfTwo &&
							a.frame.width === o.width &&
							a.frame.height === o.height;
					l &&
						(o._glTextures[e.CONTEXT_UID]
							? (l = o.wrapMode !== WRAP_MODES$9.CLAMP)
							: o.wrapMode === WRAP_MODES$9.CLAMP &&
							  (o.wrapMode = WRAP_MODES$9.REPEAT));
					var c = l ? this.simpleShader : this.shader,
						d = a.width,
						p = a.height,
						f = t._width,
						m = t._height;
					tempMat$3.set(
						(h.a * d) / f,
						(h.b * d) / m,
						(h.c * p) / f,
						(h.d * p) / m,
						h.tx / f,
						h.ty / m
					),
						tempMat$3.invert(),
						l
							? tempMat$3.prepend(u.mapCoord)
							: ((c.uniforms.uMapCoord = u.mapCoord.toArray(!0)),
							  (c.uniforms.uClampFrame = u.uClampFrame),
							  (c.uniforms.uClampOffset = u.uClampOffset)),
						(c.uniforms.uTransform = tempMat$3.toArray(!0)),
						(c.uniforms.uColor = premultiplyTintToRgba(
							t.tint,
							t.worldAlpha,
							c.uniforms.uColor,
							o.alphaMode
						)),
						(c.uniforms.translationMatrix = t.transform.worldTransform.toArray(
							!0
						)),
						(c.uniforms.uSampler = a),
						e.shader.bind(c),
						e.geometry.bind(i),
						(this.state.blendMode = correctBlendMode(t.blendMode, o.alphaMode)),
						e.state.set(this.state),
						e.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
				}),
				e
			);
		})(ObjectRenderer$3),
		canvasRenderWorldTransform = new Matrix$3(),
		CanvasSpriteRenderer = (function () {
			function t(t) {
				this.renderer = t;
			}
			return (
				(t.prototype.render = function (t) {
					var e = t._texture,
						i = this.renderer,
						r = i.context;
					if (e.valid) {
						var s = e._frame.width,
							n = e._frame.height,
							a = t.transform.worldTransform,
							o = 0,
							h = 0,
							u = e.baseTexture.getDrawableSource();
						if (!(e.orig.width <= 0 || e.orig.height <= 0) && e.valid && u) {
							i.setBlendMode(t.blendMode, !0),
								(i.context.globalAlpha = t.worldAlpha);
							var l = e.baseTexture.scaleMode === SCALE_MODES$9.LINEAR;
							i.smoothProperty &&
								i.context[i.smoothProperty] !== l &&
								(r[i.smoothProperty] = l),
								e.trim
									? ((o =
											e.trim.width / 2 + e.trim.x - t.anchor.x * e.orig.width),
									  (h =
											e.trim.height / 2 +
											e.trim.y -
											t.anchor.y * e.orig.height))
									: ((o = (0.5 - t.anchor.x) * e.orig.width),
									  (h = (0.5 - t.anchor.y) * e.orig.height)),
								e.rotate &&
									(a.copyTo(canvasRenderWorldTransform),
									(a = canvasRenderWorldTransform),
									groupD8$3.matrixAppendRotationInv(a, e.rotate, o, h),
									(o = 0),
									(h = 0)),
								(o -= s / 2),
								(h -= n / 2),
								i.setContextTransform(a, t.roundPixels, 1),
								t.roundPixels && ((o |= 0), (h |= 0));
							var c = e.baseTexture.resolution,
								d = i._outerBlend;
							d &&
								(r.save(),
								r.beginPath(),
								r.rect(
									o * i.resolution,
									h * i.resolution,
									s * i.resolution,
									n * i.resolution
								),
								r.clip()),
								16777215 !== t.tint
									? ((t._cachedTint === t.tint &&
											t._tintedCanvas.tintId === t._texture._updateID) ||
											((t._cachedTint = t.tint),
											(t._tintedCanvas = canvasUtils.getTintedCanvas(
												t,
												t.tint
											))),
									  r.drawImage(
											t._tintedCanvas,
											0,
											0,
											Math.floor(s * c),
											Math.floor(n * c),
											Math.floor(o * i.resolution),
											Math.floor(h * i.resolution),
											Math.floor(s * i.resolution),
											Math.floor(n * i.resolution)
									  ))
									: r.drawImage(
											u,
											e._frame.x * c,
											e._frame.y * c,
											Math.floor(s * c),
											Math.floor(n * c),
											Math.floor(o * i.resolution),
											Math.floor(h * i.resolution),
											Math.floor(s * i.resolution),
											Math.floor(n * i.resolution)
									  ),
								d && r.restore(),
								i.setBlendMode(BLEND_MODES$9.NORMAL);
						}
					}
				}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})();
	(Sprite$1.prototype._tintedCanvas = null),
		(Sprite$1.prototype._renderCanvas = function (t) {
			t.plugins.sprite.render(this);
		});
	/*!
	 * @pixi/text - v6.4.2
	 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
	 *
	 * @pixi/text is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 */
	/*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
	var extendStatics$f = function (t, e) {
			return (extendStatics$f =
				Object.setPrototypeOf ||
				({ __proto__: [] } instanceof Array &&
					function (t, e) {
						t.__proto__ = e;
					}) ||
				function (t, e) {
					for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
				})(t, e);
		},
		TEXT_GRADIENT,
		TEXT_GRADIENT2;
	function __extends$f(t, e) {
		function i() {
			this.constructor = t;
		}
		extendStatics$f(t, e),
			(t.prototype =
				null === e ? Object.create(e) : ((i.prototype = e.prototype), new i()));
	}
	(TEXT_GRADIENT2 = TEXT_GRADIENT || (TEXT_GRADIENT = {})),
		(TEXT_GRADIENT2[(TEXT_GRADIENT2.LINEAR_VERTICAL = 0)] = 'LINEAR_VERTICAL'),
		(TEXT_GRADIENT2[(TEXT_GRADIENT2.LINEAR_HORIZONTAL = 1)] =
			'LINEAR_HORIZONTAL');
	var defaultStyle = {
			align: 'left',
			breakWords: !1,
			dropShadow: !1,
			dropShadowAlpha: 1,
			dropShadowAngle: Math.PI / 6,
			dropShadowBlur: 0,
			dropShadowColor: 'black',
			dropShadowDistance: 5,
			fill: 'black',
			fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,
			fillGradientStops: [],
			fontFamily: 'Arial',
			fontSize: 26,
			fontStyle: 'normal',
			fontVariant: 'normal',
			fontWeight: 'normal',
			letterSpacing: 0,
			lineHeight: 0,
			lineJoin: 'miter',
			miterLimit: 10,
			padding: 0,
			stroke: 'black',
			strokeThickness: 0,
			textBaseline: 'alphabetic',
			trim: !1,
			whiteSpace: 'pre',
			wordWrap: !1,
			wordWrapWidth: 100,
			leading: 0,
		},
		genericFontFamilies = [
			'serif',
			'sans-serif',
			'monospace',
			'cursive',
			'fantasy',
			'system-ui',
		],
		TextStyle = (function () {
			function t(t) {
				(this.styleID = 0), this.reset(), deepCopyProperties(this, t, t);
			}
			return (
				(t.prototype.clone = function () {
					var e = {};
					return deepCopyProperties(e, this, defaultStyle), new t(e);
				}),
				(t.prototype.reset = function () {
					deepCopyProperties(this, defaultStyle, defaultStyle);
				}),
				Object.defineProperty(t.prototype, 'align', {
					get: function () {
						return this._align;
					},
					set: function (t) {
						this._align !== t && ((this._align = t), this.styleID++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'breakWords', {
					get: function () {
						return this._breakWords;
					},
					set: function (t) {
						this._breakWords !== t && ((this._breakWords = t), this.styleID++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'dropShadow', {
					get: function () {
						return this._dropShadow;
					},
					set: function (t) {
						this._dropShadow !== t && ((this._dropShadow = t), this.styleID++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'dropShadowAlpha', {
					get: function () {
						return this._dropShadowAlpha;
					},
					set: function (t) {
						this._dropShadowAlpha !== t &&
							((this._dropShadowAlpha = t), this.styleID++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'dropShadowAngle', {
					get: function () {
						return this._dropShadowAngle;
					},
					set: function (t) {
						this._dropShadowAngle !== t &&
							((this._dropShadowAngle = t), this.styleID++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'dropShadowBlur', {
					get: function () {
						return this._dropShadowBlur;
					},
					set: function (t) {
						this._dropShadowBlur !== t &&
							((this._dropShadowBlur = t), this.styleID++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'dropShadowColor', {
					get: function () {
						return this._dropShadowColor;
					},
					set: function (t) {
						var e = getColor(t);
						this._dropShadowColor !== e &&
							((this._dropShadowColor = e), this.styleID++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'dropShadowDistance', {
					get: function () {
						return this._dropShadowDistance;
					},
					set: function (t) {
						this._dropShadowDistance !== t &&
							((this._dropShadowDistance = t), this.styleID++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'fill', {
					get: function () {
						return this._fill;
					},
					set: function (t) {
						var e = getColor(t);
						this._fill !== e && ((this._fill = e), this.styleID++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'fillGradientType', {
					get: function () {
						return this._fillGradientType;
					},
					set: function (t) {
						this._fillGradientType !== t &&
							((this._fillGradientType = t), this.styleID++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'fillGradientStops', {
					get: function () {
						return this._fillGradientStops;
					},
					set: function (t) {
						areArraysEqual(this._fillGradientStops, t) ||
							((this._fillGradientStops = t), this.styleID++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'fontFamily', {
					get: function () {
						return this._fontFamily;
					},
					set: function (t) {
						this.fontFamily !== t && ((this._fontFamily = t), this.styleID++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'fontSize', {
					get: function () {
						return this._fontSize;
					},
					set: function (t) {
						this._fontSize !== t && ((this._fontSize = t), this.styleID++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'fontStyle', {
					get: function () {
						return this._fontStyle;
					},
					set: function (t) {
						this._fontStyle !== t && ((this._fontStyle = t), this.styleID++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'fontVariant', {
					get: function () {
						return this._fontVariant;
					},
					set: function (t) {
						this._fontVariant !== t &&
							((this._fontVariant = t), this.styleID++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'fontWeight', {
					get: function () {
						return this._fontWeight;
					},
					set: function (t) {
						this._fontWeight !== t && ((this._fontWeight = t), this.styleID++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'letterSpacing', {
					get: function () {
						return this._letterSpacing;
					},
					set: function (t) {
						this._letterSpacing !== t &&
							((this._letterSpacing = t), this.styleID++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'lineHeight', {
					get: function () {
						return this._lineHeight;
					},
					set: function (t) {
						this._lineHeight !== t && ((this._lineHeight = t), this.styleID++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'leading', {
					get: function () {
						return this._leading;
					},
					set: function (t) {
						this._leading !== t && ((this._leading = t), this.styleID++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'lineJoin', {
					get: function () {
						return this._lineJoin;
					},
					set: function (t) {
						this._lineJoin !== t && ((this._lineJoin = t), this.styleID++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'miterLimit', {
					get: function () {
						return this._miterLimit;
					},
					set: function (t) {
						this._miterLimit !== t && ((this._miterLimit = t), this.styleID++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'padding', {
					get: function () {
						return this._padding;
					},
					set: function (t) {
						this._padding !== t && ((this._padding = t), this.styleID++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'stroke', {
					get: function () {
						return this._stroke;
					},
					set: function (t) {
						var e = getColor(t);
						this._stroke !== e && ((this._stroke = e), this.styleID++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'strokeThickness', {
					get: function () {
						return this._strokeThickness;
					},
					set: function (t) {
						this._strokeThickness !== t &&
							((this._strokeThickness = t), this.styleID++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'textBaseline', {
					get: function () {
						return this._textBaseline;
					},
					set: function (t) {
						this._textBaseline !== t &&
							((this._textBaseline = t), this.styleID++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'trim', {
					get: function () {
						return this._trim;
					},
					set: function (t) {
						this._trim !== t && ((this._trim = t), this.styleID++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'whiteSpace', {
					get: function () {
						return this._whiteSpace;
					},
					set: function (t) {
						this._whiteSpace !== t && ((this._whiteSpace = t), this.styleID++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'wordWrap', {
					get: function () {
						return this._wordWrap;
					},
					set: function (t) {
						this._wordWrap !== t && ((this._wordWrap = t), this.styleID++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'wordWrapWidth', {
					get: function () {
						return this._wordWrapWidth;
					},
					set: function (t) {
						this._wordWrapWidth !== t &&
							((this._wordWrapWidth = t), this.styleID++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.toFontString = function () {
					var t =
							'number' == typeof this.fontSize
								? this.fontSize + 'px'
								: this.fontSize,
						e = this.fontFamily;
					Array.isArray(this.fontFamily) || (e = this.fontFamily.split(','));
					for (var i = e.length - 1; i >= 0; i--) {
						var r = e[i].trim();
						!/([\"\'])[^\'\"]+\1/.test(r) &&
							genericFontFamilies.indexOf(r) < 0 &&
							(r = '"' + r + '"'),
							(e[i] = r);
					}
					return (
						this.fontStyle +
						' ' +
						this.fontVariant +
						' ' +
						this.fontWeight +
						' ' +
						t +
						' ' +
						e.join(',')
					);
				}),
				t
			);
		})();
	function getSingleColor(t) {
		return 'number' == typeof t
			? hex2string$3(t)
			: ('string' == typeof t &&
					0 === t.indexOf('0x') &&
					(t = t.replace('0x', '#')),
			  t);
	}
	function getColor(t) {
		if (Array.isArray(t)) {
			for (var e = 0; e < t.length; ++e) t[e] = getSingleColor(t[e]);
			return t;
		}
		return getSingleColor(t);
	}
	function areArraysEqual(t, e) {
		if (!Array.isArray(t) || !Array.isArray(e)) return !1;
		if (t.length !== e.length) return !1;
		for (var i = 0; i < t.length; ++i) if (t[i] !== e[i]) return !1;
		return !0;
	}
	function deepCopyProperties(t, e, i) {
		for (var r in i)
			Array.isArray(e[r]) ? (t[r] = e[r].slice()) : (t[r] = e[r]);
	}
	var TextMetrics = (function () {
		function t(t, e, i, r, s, n, a, o, h) {
			(this.text = t),
				(this.style = e),
				(this.width = i),
				(this.height = r),
				(this.lines = s),
				(this.lineWidths = n),
				(this.lineHeight = a),
				(this.maxLineWidth = o),
				(this.fontProperties = h);
		}
		return (
			(t.measureText = function (e, i, r, s) {
				void 0 === s && (s = t._canvas), (r = null == r ? i.wordWrap : r);
				var n = i.toFontString(),
					a = t.measureFont(n);
				0 === a.fontSize &&
					((a.fontSize = i.fontSize), (a.ascent = i.fontSize));
				var o = s.getContext('2d');
				o.font = n;
				for (
					var h = (r ? t.wordWrap(e, i, s) : e).split(/(?:\r\n|\r|\n)/),
						u = new Array(h.length),
						l = 0,
						c = 0;
					c < h.length;
					c++
				) {
					var d =
						o.measureText(h[c]).width + (h[c].length - 1) * i.letterSpacing;
					(u[c] = d), (l = Math.max(l, d));
				}
				var p = l + i.strokeThickness;
				i.dropShadow && (p += i.dropShadowDistance);
				var f = i.lineHeight || a.fontSize + i.strokeThickness,
					m =
						Math.max(f, a.fontSize + i.strokeThickness) +
						(h.length - 1) * (f + i.leading);
				return (
					i.dropShadow && (m += i.dropShadowDistance),
					new t(e, i, p, m, h, u, f + i.leading, l, a)
				);
			}),
			(t.wordWrap = function (e, i, r) {
				void 0 === r && (r = t._canvas);
				for (
					var s = r.getContext('2d'),
						n = 0,
						a = '',
						o = '',
						h = Object.create(null),
						u = i.letterSpacing,
						l = i.whiteSpace,
						c = t.collapseSpaces(l),
						d = t.collapseNewlines(l),
						p = !c,
						f = i.wordWrapWidth + u,
						m = t.tokenize(e),
						_ = 0;
					_ < m.length;
					_++
				) {
					var g = m[_];
					if (t.isNewline(g)) {
						if (!d) {
							(o += t.addLine(a)), (p = !c), (a = ''), (n = 0);
							continue;
						}
						g = ' ';
					}
					if (c) {
						var E = t.isBreakingSpace(g),
							y = t.isBreakingSpace(a[a.length - 1]);
						if (E && y) continue;
					}
					var T = t.getFromCache(g, u, h, s);
					if (T > f)
						if (
							('' !== a && ((o += t.addLine(a)), (a = ''), (n = 0)),
							t.canBreakWords(g, i.breakWords))
						)
							for (var v = t.wordWrapSplit(g), S = 0; S < v.length; S++) {
								for (var x = v[S], b = 1; v[S + b]; ) {
									var A = v[S + b],
										R = x[x.length - 1];
									if (t.canBreakChars(R, A, g, S, i.breakWords)) break;
									(x += A), b++;
								}
								S += x.length - 1;
								var I = t.getFromCache(x, u, h, s);
								I + n > f && ((o += t.addLine(a)), (p = !1), (a = ''), (n = 0)),
									(a += x),
									(n += I);
							}
						else {
							a.length > 0 && ((o += t.addLine(a)), (a = ''), (n = 0));
							var M = _ === m.length - 1;
							(o += t.addLine(g, !M)), (p = !1), (a = ''), (n = 0);
						}
					else
						T + n > f && ((p = !1), (o += t.addLine(a)), (a = ''), (n = 0)),
							(a.length > 0 || !t.isBreakingSpace(g) || p) &&
								((a += g), (n += T));
				}
				return o + t.addLine(a, !1);
			}),
			(t.addLine = function (e, i) {
				return void 0 === i && (i = !0), (e = t.trimRight(e)), i ? e + '\n' : e;
			}),
			(t.getFromCache = function (t, e, i, r) {
				var s = i[t];
				if ('number' != typeof s) {
					var n = t.length * e;
					(s = r.measureText(t).width + n), (i[t] = s);
				}
				return s;
			}),
			(t.collapseSpaces = function (t) {
				return 'normal' === t || 'pre-line' === t;
			}),
			(t.collapseNewlines = function (t) {
				return 'normal' === t;
			}),
			(t.trimRight = function (e) {
				if ('string' != typeof e) return '';
				for (var i = e.length - 1; i >= 0; i--) {
					var r = e[i];
					if (!t.isBreakingSpace(r)) break;
					e = e.slice(0, -1);
				}
				return e;
			}),
			(t.isNewline = function (e) {
				return (
					'string' == typeof e && t._newlines.indexOf(e.charCodeAt(0)) >= 0
				);
			}),
			(t.isBreakingSpace = function (e, i) {
				return (
					'string' == typeof e &&
					t._breakingSpaces.indexOf(e.charCodeAt(0)) >= 0
				);
			}),
			(t.tokenize = function (e) {
				var i = [],
					r = '';
				if ('string' != typeof e) return i;
				for (var s = 0; s < e.length; s++) {
					var n = e[s],
						a = e[s + 1];
					t.isBreakingSpace(n, a) || t.isNewline(n)
						? ('' !== r && (i.push(r), (r = '')), i.push(n))
						: (r += n);
				}
				return '' !== r && i.push(r), i;
			}),
			(t.canBreakWords = function (t, e) {
				return e;
			}),
			(t.canBreakChars = function (t, e, i, r, s) {
				return !0;
			}),
			(t.wordWrapSplit = function (t) {
				return t.split('');
			}),
			(t.measureFont = function (e) {
				if (t._fonts[e]) return t._fonts[e];
				var i = { ascent: 0, descent: 0, fontSize: 0 },
					r = t._canvas,
					s = t._context;
				s.font = e;
				var n = t.METRICS_STRING + t.BASELINE_SYMBOL,
					a = Math.ceil(s.measureText(n).width),
					o = Math.ceil(s.measureText(t.BASELINE_SYMBOL).width),
					h = Math.ceil(t.HEIGHT_MULTIPLIER * o);
				(o = (o * t.BASELINE_MULTIPLIER) | 0),
					(r.width = a),
					(r.height = h),
					(s.fillStyle = '#f00'),
					s.fillRect(0, 0, a, h),
					(s.font = e),
					(s.textBaseline = 'alphabetic'),
					(s.fillStyle = '#000'),
					s.fillText(n, 0, o);
				var u = s.getImageData(0, 0, a, h).data,
					l = u.length,
					c = 4 * a,
					d = 0,
					p = 0,
					f = !1;
				for (d = 0; d < o; ++d) {
					for (var m = 0; m < c; m += 4)
						if (255 !== u[p + m]) {
							f = !0;
							break;
						}
					if (f) break;
					p += c;
				}
				for (i.ascent = o - d, p = l - c, f = !1, d = h; d > o; --d) {
					for (m = 0; m < c; m += 4)
						if (255 !== u[p + m]) {
							f = !0;
							break;
						}
					if (f) break;
					p -= c;
				}
				return (
					(i.descent = d - o),
					(i.fontSize = i.ascent + i.descent),
					(t._fonts[e] = i),
					i
				);
			}),
			(t.clearMetrics = function (e) {
				void 0 === e && (e = ''), e ? delete t._fonts[e] : (t._fonts = {});
			}),
			Object.defineProperty(t, '_canvas', {
				get: function () {
					if (!t.__canvas) {
						var e = void 0;
						try {
							var i = new OffscreenCanvas(0, 0),
								r = i.getContext('2d');
							if (r && r.measureText) return (t.__canvas = i), i;
							e = document.createElement('canvas');
						} catch (t) {
							e = document.createElement('canvas');
						}
						(e.width = e.height = 10), (t.__canvas = e);
					}
					return t.__canvas;
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(t, '_context', {
				get: function () {
					return (
						t.__context || (t.__context = t._canvas.getContext('2d')),
						t.__context
					);
				},
				enumerable: !1,
				configurable: !0,
			}),
			t
		);
	})();
	(TextMetrics._fonts = {}),
		(TextMetrics.METRICS_STRING = '|ÉqÅ'),
		(TextMetrics.BASELINE_SYMBOL = 'M'),
		(TextMetrics.BASELINE_MULTIPLIER = 1.4),
		(TextMetrics.HEIGHT_MULTIPLIER = 2),
		(TextMetrics._newlines = [10, 13]),
		(TextMetrics._breakingSpaces = [
			9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287,
			12288,
		]);
	var defaultDestroyOptions = { texture: !0, children: !1, baseTexture: !0 },
		Text = (function (t) {
			function e(e, i, r) {
				var s = this,
					n = !1;
				r || ((r = document.createElement('canvas')), (n = !0)),
					(r.width = 3),
					(r.height = 3);
				var a = Texture$3.from(r);
				return (
					(a.orig = new Rectangle$4()),
					(a.trim = new Rectangle$4()),
					((s = t.call(this, a) || this)._ownCanvas = n),
					(s.canvas = r),
					(s.context = s.canvas.getContext('2d')),
					(s._resolution = settings$4.RESOLUTION),
					(s._autoResolution = !0),
					(s._text = null),
					(s._style = null),
					(s._styleListener = null),
					(s._font = ''),
					(s.text = e),
					(s.style = i),
					(s.localStyleID = -1),
					s
				);
			}
			return (
				__extends$f(e, t),
				(e.prototype.updateText = function (t) {
					var i = this._style;
					if (
						(this.localStyleID !== i.styleID &&
							((this.dirty = !0), (this.localStyleID = i.styleID)),
						this.dirty || !t)
					) {
						this._font = this._style.toFontString();
						var r,
							s,
							n = this.context,
							a = TextMetrics.measureText(
								this._text || ' ',
								this._style,
								this._style.wordWrap,
								this.canvas
							),
							o = a.width,
							h = a.height,
							u = a.lines,
							l = a.lineHeight,
							c = a.lineWidths,
							d = a.maxLineWidth,
							p = a.fontProperties;
						(this.canvas.width = Math.ceil(
							Math.ceil(Math.max(1, o) + 2 * i.padding) * this._resolution
						)),
							(this.canvas.height = Math.ceil(
								Math.ceil(Math.max(1, h) + 2 * i.padding) * this._resolution
							)),
							n.scale(this._resolution, this._resolution),
							n.clearRect(0, 0, this.canvas.width, this.canvas.height),
							(n.font = this._font),
							(n.lineWidth = i.strokeThickness),
							(n.textBaseline = i.textBaseline),
							(n.lineJoin = i.lineJoin),
							(n.miterLimit = i.miterLimit);
						for (var f = i.dropShadow ? 2 : 1, m = 0; m < f; ++m) {
							var _ = i.dropShadow && 0 === m,
								g = _ ? Math.ceil(Math.max(1, h) + 2 * i.padding) : 0,
								E = g * this._resolution;
							if (_) {
								(n.fillStyle = 'black'), (n.strokeStyle = 'black');
								var y = i.dropShadowColor,
									T = hex2rgb$3('number' == typeof y ? y : string2hex(y)),
									v = i.dropShadowBlur * this._resolution,
									S = i.dropShadowDistance * this._resolution;
								(n.shadowColor =
									'rgba(' +
									255 * T[0] +
									',' +
									255 * T[1] +
									',' +
									255 * T[2] +
									',' +
									i.dropShadowAlpha +
									')'),
									(n.shadowBlur = v),
									(n.shadowOffsetX = Math.cos(i.dropShadowAngle) * S),
									(n.shadowOffsetY = Math.sin(i.dropShadowAngle) * S + E);
							} else
								(n.fillStyle = this._generateFillStyle(i, u, a)),
									(n.strokeStyle = i.stroke),
									(n.shadowColor = 'black'),
									(n.shadowBlur = 0),
									(n.shadowOffsetX = 0),
									(n.shadowOffsetY = 0);
							var x = (l - p.fontSize) / 2;
							(!e.nextLineHeightBehavior || l - p.fontSize < 0) && (x = 0);
							for (var b = 0; b < u.length; b++)
								(r = i.strokeThickness / 2),
									(s = i.strokeThickness / 2 + b * l + p.ascent + x),
									'right' === i.align
										? (r += d - c[b])
										: 'center' === i.align && (r += (d - c[b]) / 2),
									i.stroke &&
										i.strokeThickness &&
										this.drawLetterSpacing(
											u[b],
											r + i.padding,
											s + i.padding - g,
											!0
										),
									i.fill &&
										this.drawLetterSpacing(
											u[b],
											r + i.padding,
											s + i.padding - g
										);
						}
						this.updateTexture();
					}
				}),
				(e.prototype.drawLetterSpacing = function (t, i, r, s) {
					void 0 === s && (s = !1);
					var n = this._style.letterSpacing,
						a =
							e.experimentalLetterSpacing &&
							('letterSpacing' in CanvasRenderingContext2D.prototype ||
								'textLetterSpacing' in CanvasRenderingContext2D.prototype);
					if (0 === n || a)
						return (
							a &&
								((this.context.letterSpacing = n),
								(this.context.textLetterSpacing = n)),
							void (s
								? this.context.strokeText(t, i, r)
								: this.context.fillText(t, i, r))
						);
					for (
						var o = i,
							h = Array.from ? Array.from(t) : t.split(''),
							u = this.context.measureText(t).width,
							l = 0,
							c = 0;
						c < h.length;
						++c
					) {
						var d = h[c];
						s
							? this.context.strokeText(d, o, r)
							: this.context.fillText(d, o, r);
						for (var p = '', f = c + 1; f < h.length; ++f) p += h[f];
						(o += u - (l = this.context.measureText(p).width) + n), (u = l);
					}
				}),
				(e.prototype.updateTexture = function () {
					var t = this.canvas;
					if (this._style.trim) {
						var e = trimCanvas(t);
						e.data &&
							((t.width = e.width),
							(t.height = e.height),
							this.context.putImageData(e.data, 0, 0));
					}
					var i = this._texture,
						r = this._style,
						s = r.trim ? 0 : r.padding,
						n = i.baseTexture;
					(i.trim.width = i._frame.width = t.width / this._resolution),
						(i.trim.height = i._frame.height = t.height / this._resolution),
						(i.trim.x = -s),
						(i.trim.y = -s),
						(i.orig.width = i._frame.width - 2 * s),
						(i.orig.height = i._frame.height - 2 * s),
						this._onTextureUpdate(),
						n.setRealSize(t.width, t.height, this._resolution),
						i.updateUvs(),
						(this.dirty = !1);
				}),
				(e.prototype._render = function (e) {
					this._autoResolution &&
						this._resolution !== e.resolution &&
						((this._resolution = e.resolution), (this.dirty = !0)),
						this.updateText(!0),
						t.prototype._render.call(this, e);
				}),
				(e.prototype.updateTransform = function () {
					this.updateText(!0), t.prototype.updateTransform.call(this);
				}),
				(e.prototype.getBounds = function (e, i) {
					return (
						this.updateText(!0),
						-1 === this._textureID && (e = !1),
						t.prototype.getBounds.call(this, e, i)
					);
				}),
				(e.prototype.getLocalBounds = function (e) {
					return this.updateText(!0), t.prototype.getLocalBounds.call(this, e);
				}),
				(e.prototype._calculateBounds = function () {
					this.calculateVertices(), this._bounds.addQuad(this.vertexData);
				}),
				(e.prototype._generateFillStyle = function (t, e, i) {
					var r,
						s = t.fill;
					if (!Array.isArray(s)) return s;
					if (1 === s.length) return s[0];
					var n = t.dropShadow ? t.dropShadowDistance : 0,
						a = t.padding || 0,
						o = this.canvas.width / this._resolution - n - 2 * a,
						h = this.canvas.height / this._resolution - n - 2 * a,
						u = s.slice(),
						l = t.fillGradientStops.slice();
					if (!l.length)
						for (var c = u.length + 1, d = 1; d < c; ++d) l.push(d / c);
					if (
						(u.unshift(s[0]),
						l.unshift(0),
						u.push(s[s.length - 1]),
						l.push(1),
						t.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL)
					) {
						r = this.context.createLinearGradient(o / 2, a, o / 2, h + a);
						var p = i.fontProperties.fontSize + t.strokeThickness;
						for (d = 0; d < e.length; d++) {
							var f = i.lineHeight * (d - 1) + p,
								m = i.lineHeight * d,
								_ = m;
							d > 0 && f > m && (_ = (m + f) / 2);
							var g = m + p,
								E = i.lineHeight * (d + 1),
								y = g;
							d + 1 < e.length && E < g && (y = (g + E) / 2);
							for (var T = (y - _) / h, v = 0; v < u.length; v++) {
								var S;
								S = 'number' == typeof l[v] ? l[v] : v / u.length;
								var x = Math.min(1, Math.max(0, _ / h + S * T));
								(x = Number(x.toFixed(5))), r.addColorStop(x, u[v]);
							}
						}
					} else {
						r = this.context.createLinearGradient(a, h / 2, o + a, h / 2);
						var b = u.length + 1,
							A = 1;
						for (d = 0; d < u.length; d++) {
							var R;
							(R = 'number' == typeof l[d] ? l[d] : A / b),
								r.addColorStop(R, u[d]),
								A++;
						}
					}
					return r;
				}),
				(e.prototype.destroy = function (e) {
					'boolean' == typeof e && (e = { children: e }),
						(e = Object.assign({}, defaultDestroyOptions, e)),
						t.prototype.destroy.call(this, e),
						this._ownCanvas && (this.canvas.height = this.canvas.width = 0),
						(this.context = null),
						(this.canvas = null),
						(this._style = null);
				}),
				Object.defineProperty(e.prototype, 'width', {
					get: function () {
						return (
							this.updateText(!0),
							Math.abs(this.scale.x) * this._texture.orig.width
						);
					},
					set: function (t) {
						this.updateText(!0);
						var e = sign(this.scale.x) || 1;
						(this.scale.x = (e * t) / this._texture.orig.width),
							(this._width = t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'height', {
					get: function () {
						return (
							this.updateText(!0),
							Math.abs(this.scale.y) * this._texture.orig.height
						);
					},
					set: function (t) {
						this.updateText(!0);
						var e = sign(this.scale.y) || 1;
						(this.scale.y = (e * t) / this._texture.orig.height),
							(this._height = t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'style', {
					get: function () {
						return this._style;
					},
					set: function (t) {
						(t = t || {}),
							(this._style = t instanceof TextStyle ? t : new TextStyle(t)),
							(this.localStyleID = -1),
							(this.dirty = !0);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'text', {
					get: function () {
						return this._text;
					},
					set: function (t) {
						(t = String(null == t ? '' : t)),
							this._text !== t && ((this._text = t), (this.dirty = !0));
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'resolution', {
					get: function () {
						return this._resolution;
					},
					set: function (t) {
						(this._autoResolution = !1),
							this._resolution !== t &&
								((this._resolution = t), (this.dirty = !0));
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.nextLineHeightBehavior = !1),
				(e.experimentalLetterSpacing = !1),
				e
			);
		})(Sprite$1),
		SignalBinding = (function () {
			function t(t, e, i) {
				void 0 === e && (e = !1),
					(this._fn = t),
					(this._once = e),
					(this._thisArg = i),
					(this._next = this._prev = this._owner = null);
			}
			return (
				(t.prototype.detach = function () {
					return null !== this._owner && (this._owner.detach(this), !0);
				}),
				t
			);
		})();
	function _addSignalBinding(t, e) {
		return (
			t._head
				? ((t._tail._next = e), (e._prev = t._tail), (t._tail = e))
				: ((t._head = e), (t._tail = e)),
			(e._owner = t),
			e
		);
	}
	var Signal = (function () {
			function t() {
				this._head = this._tail = void 0;
			}
			return (
				(t.prototype.handlers = function (t) {
					void 0 === t && (t = !1);
					var e = this._head;
					if (t) return !!e;
					for (var i = []; e; ) i.push(e), (e = e._next);
					return i;
				}),
				(t.prototype.has = function (t) {
					if (!(t instanceof SignalBinding))
						throw new Error(
							'MiniSignal#has(): First arg must be a SignalBinding object.'
						);
					return t._owner === this;
				}),
				(t.prototype.dispatch = function () {
					for (var t = arguments, e = [], i = 0; i < arguments.length; i++)
						e[i] = t[i];
					var r = this._head;
					if (!r) return !1;
					for (; r; )
						r._once && this.detach(r),
							r._fn.apply(r._thisArg, e),
							(r = r._next);
					return !0;
				}),
				(t.prototype.add = function (t, e) {
					if ((void 0 === e && (e = null), 'function' != typeof t))
						throw new Error('MiniSignal#add(): First arg must be a Function.');
					return _addSignalBinding(this, new SignalBinding(t, !1, e));
				}),
				(t.prototype.once = function (t, e) {
					if ((void 0 === e && (e = null), 'function' != typeof t))
						throw new Error('MiniSignal#once(): First arg must be a Function.');
					return _addSignalBinding(this, new SignalBinding(t, !0, e));
				}),
				(t.prototype.detach = function (t) {
					if (!(t instanceof SignalBinding))
						throw new Error(
							'MiniSignal#detach(): First arg must be a SignalBinding object.'
						);
					return (
						t._owner !== this ||
							(t._prev && (t._prev._next = t._next),
							t._next && (t._next._prev = t._prev),
							t === this._head
								? ((this._head = t._next),
								  null === t._next && (this._tail = null))
								: t === this._tail &&
								  ((this._tail = t._prev), (this._tail._next = null)),
							(t._owner = null)),
						this
					);
				}),
				(t.prototype.detachAll = function () {
					var t = this._head;
					if (!t) return this;
					for (this._head = this._tail = null; t; )
						(t._owner = null), (t = t._next);
					return this;
				}),
				t
			);
		})(),
		useXdr;
	function parseUri(t, e) {
		e = e || {};
		for (
			var i = {
					key: [
						'source',
						'protocol',
						'authority',
						'userInfo',
						'user',
						'password',
						'host',
						'port',
						'relative',
						'path',
						'directory',
						'file',
						'query',
						'anchor',
					],
					q: { name: 'queryKey', parser: /(?:^|&)([^&=]*)=?([^&]*)/g },
					parser: {
						strict:
							/^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
						loose:
							/^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
					},
				},
				r = i.parser[e.strictMode ? 'strict' : 'loose'].exec(t),
				s = {},
				n = 14;
			n--;

		)
			s[i.key[n]] = r[n] || '';
		return (
			(s[i.q.name] = {}),
			s[i.key[12]].replace(i.q.parser, function (t, e, r) {
				e && (s[i.q.name][e] = r);
			}),
			s
		);
	}
	var tempAnchor$3 = null,
		STATUS_NONE = 0,
		STATUS_OK = 200,
		STATUS_EMPTY = 204,
		STATUS_IE_BUG_EMPTY = 1223,
		STATUS_TYPE_OK = 2;
	function _noop$1() {}
	function setExtMap(t, e, i) {
		e && 0 === e.indexOf('.') && (e = e.substring(1)), e && (t[e] = i);
	}
	function reqType(t) {
		return t.toString().replace('object ', '');
	}
	var LoaderResource = (function () {
			function t(e, i, r) {
				if (
					((this._dequeue = _noop$1),
					(this._onLoadBinding = null),
					(this._elementTimer = 0),
					(this._boundComplete = null),
					(this._boundOnError = null),
					(this._boundOnProgress = null),
					(this._boundOnTimeout = null),
					(this._boundXhrOnError = null),
					(this._boundXhrOnTimeout = null),
					(this._boundXhrOnAbort = null),
					(this._boundXhrOnLoad = null),
					'string' != typeof e || 'string' != typeof i)
				)
					throw new Error(
						'Both name and url are required for constructing a resource.'
					);
				(r = r || {}),
					(this._flags = 0),
					this._setFlag(t.STATUS_FLAGS.DATA_URL, 0 === i.indexOf('data:')),
					(this.name = e),
					(this.url = i),
					(this.extension = this._getExtension()),
					(this.data = null),
					(this.crossOrigin =
						!0 === r.crossOrigin ? 'anonymous' : r.crossOrigin),
					(this.timeout = r.timeout || 0),
					(this.loadType = r.loadType || this._determineLoadType()),
					(this.xhrType = r.xhrType),
					(this.metadata = r.metadata || {}),
					(this.error = null),
					(this.xhr = null),
					(this.children = []),
					(this.type = t.TYPE.UNKNOWN),
					(this.progressChunk = 0),
					(this._dequeue = _noop$1),
					(this._onLoadBinding = null),
					(this._elementTimer = 0),
					(this._boundComplete = this.complete.bind(this)),
					(this._boundOnError = this._onError.bind(this)),
					(this._boundOnProgress = this._onProgress.bind(this)),
					(this._boundOnTimeout = this._onTimeout.bind(this)),
					(this._boundXhrOnError = this._xhrOnError.bind(this)),
					(this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this)),
					(this._boundXhrOnAbort = this._xhrOnAbort.bind(this)),
					(this._boundXhrOnLoad = this._xhrOnLoad.bind(this)),
					(this.onStart = new Signal()),
					(this.onProgress = new Signal()),
					(this.onComplete = new Signal()),
					(this.onAfterMiddleware = new Signal());
			}
			return (
				(t.setExtensionLoadType = function (e, i) {
					setExtMap(t._loadTypeMap, e, i);
				}),
				(t.setExtensionXhrType = function (e, i) {
					setExtMap(t._xhrTypeMap, e, i);
				}),
				Object.defineProperty(t.prototype, 'isDataUrl', {
					get: function () {
						return this._hasFlag(t.STATUS_FLAGS.DATA_URL);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'isComplete', {
					get: function () {
						return this._hasFlag(t.STATUS_FLAGS.COMPLETE);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'isLoading', {
					get: function () {
						return this._hasFlag(t.STATUS_FLAGS.LOADING);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.complete = function () {
					this._clearEvents(), this._finish();
				}),
				(t.prototype.abort = function (e) {
					if (!this.error) {
						if (((this.error = new Error(e)), this._clearEvents(), this.xhr))
							this.xhr.abort();
						else if (this.xdr) this.xdr.abort();
						else if (this.data)
							if (this.data.src) this.data.src = t.EMPTY_GIF;
							else
								for (; this.data.firstChild; )
									this.data.removeChild(this.data.firstChild);
						this._finish();
					}
				}),
				(t.prototype.load = function (e) {
					var i = this;
					if (!this.isLoading)
						if (this.isComplete)
							e &&
								setTimeout(function () {
									return e(i);
								}, 1);
						else
							switch (
								(e && this.onComplete.once(e),
								this._setFlag(t.STATUS_FLAGS.LOADING, !0),
								this.onStart.dispatch(this),
								(!1 !== this.crossOrigin &&
									'string' == typeof this.crossOrigin) ||
									(this.crossOrigin = this._determineCrossOrigin(this.url)),
								this.loadType)
							) {
								case t.LOAD_TYPE.IMAGE:
									(this.type = t.TYPE.IMAGE), this._loadElement('image');
									break;
								case t.LOAD_TYPE.AUDIO:
									(this.type = t.TYPE.AUDIO), this._loadSourceElement('audio');
									break;
								case t.LOAD_TYPE.VIDEO:
									(this.type = t.TYPE.VIDEO), this._loadSourceElement('video');
									break;
								case t.LOAD_TYPE.XHR:
								default:
									void 0 === useXdr &&
										(useXdr = !(
											!globalThis.XDomainRequest ||
											'withCredentials' in new XMLHttpRequest()
										)),
										useXdr && this.crossOrigin
											? this._loadXdr()
											: this._loadXhr();
							}
				}),
				(t.prototype._hasFlag = function (t) {
					return 0 != (this._flags & t);
				}),
				(t.prototype._setFlag = function (t, e) {
					this._flags = e ? this._flags | t : this._flags & ~t;
				}),
				(t.prototype._clearEvents = function () {
					clearTimeout(this._elementTimer),
						this.data &&
							this.data.removeEventListener &&
							(this.data.removeEventListener('error', this._boundOnError, !1),
							this.data.removeEventListener('load', this._boundComplete, !1),
							this.data.removeEventListener(
								'progress',
								this._boundOnProgress,
								!1
							),
							this.data.removeEventListener(
								'canplaythrough',
								this._boundComplete,
								!1
							)),
						this.xhr &&
							(this.xhr.removeEventListener
								? (this.xhr.removeEventListener(
										'error',
										this._boundXhrOnError,
										!1
								  ),
								  this.xhr.removeEventListener(
										'timeout',
										this._boundXhrOnTimeout,
										!1
								  ),
								  this.xhr.removeEventListener(
										'abort',
										this._boundXhrOnAbort,
										!1
								  ),
								  this.xhr.removeEventListener(
										'progress',
										this._boundOnProgress,
										!1
								  ),
								  this.xhr.removeEventListener(
										'load',
										this._boundXhrOnLoad,
										!1
								  ))
								: ((this.xhr.onerror = null),
								  (this.xhr.ontimeout = null),
								  (this.xhr.onprogress = null),
								  (this.xhr.onload = null)));
				}),
				(t.prototype._finish = function () {
					if (this.isComplete)
						throw new Error(
							'Complete called again for an already completed resource.'
						);
					this._setFlag(t.STATUS_FLAGS.COMPLETE, !0),
						this._setFlag(t.STATUS_FLAGS.LOADING, !1),
						this.onComplete.dispatch(this);
				}),
				(t.prototype._loadElement = function (t) {
					this.metadata.loadElement
						? (this.data = this.metadata.loadElement)
						: 'image' === t && void 0 !== globalThis.Image
						? (this.data = new Image())
						: (this.data = document.createElement(t)),
						this.crossOrigin && (this.data.crossOrigin = this.crossOrigin),
						this.metadata.skipSource || (this.data.src = this.url),
						this.data.addEventListener('error', this._boundOnError, !1),
						this.data.addEventListener('load', this._boundComplete, !1),
						this.data.addEventListener('progress', this._boundOnProgress, !1),
						this.timeout &&
							(this._elementTimer = setTimeout(
								this._boundOnTimeout,
								this.timeout
							));
				}),
				(t.prototype._loadSourceElement = function (t) {
					if (
						(this.metadata.loadElement
							? (this.data = this.metadata.loadElement)
							: 'audio' === t && void 0 !== globalThis.Audio
							? (this.data = new Audio())
							: (this.data = document.createElement(t)),
						null !== this.data)
					) {
						if (
							(this.crossOrigin && (this.data.crossOrigin = this.crossOrigin),
							!this.metadata.skipSource)
						)
							if (navigator.isCocoonJS)
								this.data.src = Array.isArray(this.url)
									? this.url[0]
									: this.url;
							else if (Array.isArray(this.url))
								for (
									var e = this.metadata.mimeType, i = 0;
									i < this.url.length;
									++i
								)
									this.data.appendChild(
										this._createSource(
											t,
											this.url[i],
											Array.isArray(e) ? e[i] : e
										)
									);
							else
								(e = this.metadata.mimeType),
									this.data.appendChild(
										this._createSource(t, this.url, Array.isArray(e) ? e[0] : e)
									);
						this.data.addEventListener('error', this._boundOnError, !1),
							this.data.addEventListener('load', this._boundComplete, !1),
							this.data.addEventListener('progress', this._boundOnProgress, !1),
							this.data.addEventListener(
								'canplaythrough',
								this._boundComplete,
								!1
							),
							this.data.load(),
							this.timeout &&
								(this._elementTimer = setTimeout(
									this._boundOnTimeout,
									this.timeout
								));
					} else this.abort('Unsupported element: ' + t);
				}),
				(t.prototype._loadXhr = function () {
					'string' != typeof this.xhrType &&
						(this.xhrType = this._determineXhrType());
					var e = (this.xhr = new XMLHttpRequest());
					'use-credentials' === this.crossOrigin && (e.withCredentials = !0),
						e.open('GET', this.url, !0),
						(e.timeout = this.timeout),
						this.xhrType === t.XHR_RESPONSE_TYPE.JSON ||
						this.xhrType === t.XHR_RESPONSE_TYPE.DOCUMENT
							? (e.responseType = t.XHR_RESPONSE_TYPE.TEXT)
							: (e.responseType = this.xhrType),
						e.addEventListener('error', this._boundXhrOnError, !1),
						e.addEventListener('timeout', this._boundXhrOnTimeout, !1),
						e.addEventListener('abort', this._boundXhrOnAbort, !1),
						e.addEventListener('progress', this._boundOnProgress, !1),
						e.addEventListener('load', this._boundXhrOnLoad, !1),
						e.send();
				}),
				(t.prototype._loadXdr = function () {
					'string' != typeof this.xhrType &&
						(this.xhrType = this._determineXhrType());
					var t = (this.xhr = new globalThis.XDomainRequest());
					(t.timeout = this.timeout || 5e3),
						(t.onerror = this._boundXhrOnError),
						(t.ontimeout = this._boundXhrOnTimeout),
						(t.onprogress = this._boundOnProgress),
						(t.onload = this._boundXhrOnLoad),
						t.open('GET', this.url, !0),
						setTimeout(function () {
							return t.send();
						}, 1);
				}),
				(t.prototype._createSource = function (t, e, i) {
					i || (i = t + '/' + this._getExtension(e));
					var r = document.createElement('source');
					return (r.src = e), (r.type = i), r;
				}),
				(t.prototype._onError = function (t) {
					this.abort('Failed to load element using: ' + t.target.nodeName);
				}),
				(t.prototype._onProgress = function (t) {
					t &&
						t.lengthComputable &&
						this.onProgress.dispatch(this, t.loaded / t.total);
				}),
				(t.prototype._onTimeout = function () {
					this.abort('Load timed out.');
				}),
				(t.prototype._xhrOnError = function () {
					var t = this.xhr;
					this.abort(
						reqType(t) +
							' Request failed. Status: ' +
							t.status +
							', text: "' +
							t.statusText +
							'"'
					);
				}),
				(t.prototype._xhrOnTimeout = function () {
					var t = this.xhr;
					this.abort(reqType(t) + ' Request timed out.');
				}),
				(t.prototype._xhrOnAbort = function () {
					var t = this.xhr;
					this.abort(reqType(t) + ' Request was aborted by the user.');
				}),
				(t.prototype._xhrOnLoad = function () {
					var e = this.xhr,
						i = '',
						r = void 0 === e.status ? STATUS_OK : e.status;
					if (
						(('' !== e.responseType &&
							'text' !== e.responseType &&
							void 0 !== e.responseType) ||
							(i = e.responseText),
						r === STATUS_NONE &&
						(i.length > 0 || e.responseType === t.XHR_RESPONSE_TYPE.BUFFER)
							? (r = STATUS_OK)
							: r === STATUS_IE_BUG_EMPTY && (r = STATUS_EMPTY),
						((r / 100) | 0) === STATUS_TYPE_OK)
					) {
						if (this.xhrType === t.XHR_RESPONSE_TYPE.TEXT)
							(this.data = i), (this.type = t.TYPE.TEXT);
						else if (this.xhrType === t.XHR_RESPONSE_TYPE.JSON)
							try {
								(this.data = JSON.parse(i)), (this.type = t.TYPE.JSON);
							} catch (t) {
								return void this.abort(
									'Error trying to parse loaded json: ' + t
								);
							}
						else if (this.xhrType === t.XHR_RESPONSE_TYPE.DOCUMENT)
							try {
								if (globalThis.DOMParser) {
									var s = new DOMParser();
									this.data = s.parseFromString(i, 'text/xml');
								} else {
									var n = document.createElement('div');
									(n.innerHTML = i), (this.data = n);
								}
								this.type = t.TYPE.XML;
							} catch (t) {
								return void this.abort(
									'Error trying to parse loaded xml: ' + t
								);
							}
						else this.data = e.response || i;
						this.complete();
					} else
						this.abort(
							'[' + e.status + '] ' + e.statusText + ': ' + e.responseURL
						);
				}),
				(t.prototype._determineCrossOrigin = function (t, e) {
					if (0 === t.indexOf('data:')) return '';
					if (globalThis.origin !== globalThis.location.origin)
						return 'anonymous';
					(e = e || globalThis.location),
						tempAnchor$3 || (tempAnchor$3 = document.createElement('a')),
						(tempAnchor$3.href = t);
					var i = parseUri(tempAnchor$3.href, { strictMode: !0 }),
						r = (!i.port && '' === e.port) || i.port === e.port,
						s = i.protocol ? i.protocol + ':' : '';
					return i.host === e.hostname && r && s === e.protocol
						? ''
						: 'anonymous';
				}),
				(t.prototype._determineXhrType = function () {
					return t._xhrTypeMap[this.extension] || t.XHR_RESPONSE_TYPE.TEXT;
				}),
				(t.prototype._determineLoadType = function () {
					return t._loadTypeMap[this.extension] || t.LOAD_TYPE.XHR;
				}),
				(t.prototype._getExtension = function (t) {
					void 0 === t && (t = this.url);
					var e = '';
					if (this.isDataUrl) {
						var i = t.indexOf('/');
						e = t.substring(i + 1, t.indexOf(';', i));
					} else {
						var r = t.indexOf('?'),
							s = t.indexOf('#'),
							n = Math.min(r > -1 ? r : t.length, s > -1 ? s : t.length);
						e = (t = t.substring(0, n)).substring(t.lastIndexOf('.') + 1);
					}
					return e.toLowerCase();
				}),
				(t.prototype._getMimeFromXhrType = function (e) {
					switch (e) {
						case t.XHR_RESPONSE_TYPE.BUFFER:
							return 'application/octet-binary';
						case t.XHR_RESPONSE_TYPE.BLOB:
							return 'application/blob';
						case t.XHR_RESPONSE_TYPE.DOCUMENT:
							return 'application/xml';
						case t.XHR_RESPONSE_TYPE.JSON:
							return 'application/json';
						case t.XHR_RESPONSE_TYPE.DEFAULT:
						case t.XHR_RESPONSE_TYPE.TEXT:
						default:
							return 'text/plain';
					}
				}),
				t
			);
		})(),
		LoaderResource2,
		STATUS_FLAGS,
		TYPE,
		LOAD_TYPE,
		XHR_RESPONSE_TYPE;
	function _noop() {}
	function onlyOnce(t) {
		return function () {
			for (var e = arguments, i = [], r = 0; r < arguments.length; r++)
				i[r] = e[r];
			if (null === t) throw new Error('Callback was already called.');
			var s = t;
			(t = null), s.apply(this, i);
		};
	}
	(LoaderResource2 = LoaderResource || (LoaderResource = {})),
		((STATUS_FLAGS =
			LoaderResource2.STATUS_FLAGS || (LoaderResource2.STATUS_FLAGS = {}))[
			(STATUS_FLAGS.NONE = 0)
		] = 'NONE'),
		(STATUS_FLAGS[(STATUS_FLAGS.DATA_URL = 1)] = 'DATA_URL'),
		(STATUS_FLAGS[(STATUS_FLAGS.COMPLETE = 2)] = 'COMPLETE'),
		(STATUS_FLAGS[(STATUS_FLAGS.LOADING = 4)] = 'LOADING'),
		((TYPE = LoaderResource2.TYPE || (LoaderResource2.TYPE = {}))[
			(TYPE.UNKNOWN = 0)
		] = 'UNKNOWN'),
		(TYPE[(TYPE.JSON = 1)] = 'JSON'),
		(TYPE[(TYPE.XML = 2)] = 'XML'),
		(TYPE[(TYPE.IMAGE = 3)] = 'IMAGE'),
		(TYPE[(TYPE.AUDIO = 4)] = 'AUDIO'),
		(TYPE[(TYPE.VIDEO = 5)] = 'VIDEO'),
		(TYPE[(TYPE.TEXT = 6)] = 'TEXT'),
		((LOAD_TYPE =
			LoaderResource2.LOAD_TYPE || (LoaderResource2.LOAD_TYPE = {}))[
			(LOAD_TYPE.XHR = 1)
		] = 'XHR'),
		(LOAD_TYPE[(LOAD_TYPE.IMAGE = 2)] = 'IMAGE'),
		(LOAD_TYPE[(LOAD_TYPE.AUDIO = 3)] = 'AUDIO'),
		(LOAD_TYPE[(LOAD_TYPE.VIDEO = 4)] = 'VIDEO'),
		((XHR_RESPONSE_TYPE =
			LoaderResource2.XHR_RESPONSE_TYPE ||
			(LoaderResource2.XHR_RESPONSE_TYPE = {})).DEFAULT = 'text'),
		(XHR_RESPONSE_TYPE.BUFFER = 'arraybuffer'),
		(XHR_RESPONSE_TYPE.BLOB = 'blob'),
		(XHR_RESPONSE_TYPE.DOCUMENT = 'document'),
		(XHR_RESPONSE_TYPE.JSON = 'json'),
		(XHR_RESPONSE_TYPE.TEXT = 'text'),
		(LoaderResource2._loadTypeMap = {
			gif: LoaderResource2.LOAD_TYPE.IMAGE,
			png: LoaderResource2.LOAD_TYPE.IMAGE,
			bmp: LoaderResource2.LOAD_TYPE.IMAGE,
			jpg: LoaderResource2.LOAD_TYPE.IMAGE,
			jpeg: LoaderResource2.LOAD_TYPE.IMAGE,
			tif: LoaderResource2.LOAD_TYPE.IMAGE,
			tiff: LoaderResource2.LOAD_TYPE.IMAGE,
			webp: LoaderResource2.LOAD_TYPE.IMAGE,
			tga: LoaderResource2.LOAD_TYPE.IMAGE,
			svg: LoaderResource2.LOAD_TYPE.IMAGE,
			'svg+xml': LoaderResource2.LOAD_TYPE.IMAGE,
			mp3: LoaderResource2.LOAD_TYPE.AUDIO,
			ogg: LoaderResource2.LOAD_TYPE.AUDIO,
			wav: LoaderResource2.LOAD_TYPE.AUDIO,
			mp4: LoaderResource2.LOAD_TYPE.VIDEO,
			webm: LoaderResource2.LOAD_TYPE.VIDEO,
		}),
		(LoaderResource2._xhrTypeMap = {
			xhtml: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
			html: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
			htm: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
			xml: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
			tmx: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
			svg: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
			tsx: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
			gif: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
			png: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
			bmp: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
			jpg: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
			jpeg: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
			tif: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
			tiff: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
			webp: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
			tga: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
			json: LoaderResource2.XHR_RESPONSE_TYPE.JSON,
			text: LoaderResource2.XHR_RESPONSE_TYPE.TEXT,
			txt: LoaderResource2.XHR_RESPONSE_TYPE.TEXT,
			ttf: LoaderResource2.XHR_RESPONSE_TYPE.BUFFER,
			otf: LoaderResource2.XHR_RESPONSE_TYPE.BUFFER,
		}),
		(LoaderResource2.EMPTY_GIF =
			'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==');
	var AsyncQueueItem = function (t, e) {
			(this.data = t), (this.callback = e);
		},
		AsyncQueue = (function () {
			function t(t, e) {
				var i = this;
				if (
					(void 0 === e && (e = 1),
					(this.workers = 0),
					(this.saturated = _noop),
					(this.unsaturated = _noop),
					(this.empty = _noop),
					(this.drain = _noop),
					(this.error = _noop),
					(this.started = !1),
					(this.paused = !1),
					(this._tasks = []),
					(this._insert = function (t, e, r) {
						if (r && 'function' != typeof r)
							throw new Error('task callback must be a function');
						if (((i.started = !0), null == t && i.idle()))
							setTimeout(function () {
								return i.drain();
							}, 1);
						else {
							var s = new AsyncQueueItem(t, 'function' == typeof r ? r : _noop);
							e ? i._tasks.unshift(s) : i._tasks.push(s),
								setTimeout(i.process, 1);
						}
					}),
					(this.process = function () {
						for (
							;
							!i.paused && i.workers < i.concurrency && i._tasks.length;

						) {
							var t = i._tasks.shift();
							0 === i._tasks.length && i.empty(),
								(i.workers += 1),
								i.workers === i.concurrency && i.saturated(),
								i._worker(t.data, onlyOnce(i._next(t)));
						}
					}),
					(this._worker = t),
					0 === e)
				)
					throw new Error('Concurrency must not be zero');
				(this.concurrency = e), (this.buffer = e / 4);
			}
			return (
				(t.prototype._next = function (t) {
					var e = this;
					return function () {
						for (var i = arguments, r = [], s = 0; s < arguments.length; s++)
							r[s] = i[s];
						(e.workers -= 1),
							t.callback.apply(t, r),
							null != r[0] && e.error(r[0], t.data),
							e.workers <= e.concurrency - e.buffer && e.unsaturated(),
							e.idle() && e.drain(),
							e.process();
					};
				}),
				(t.prototype.push = function (t, e) {
					this._insert(t, !1, e);
				}),
				(t.prototype.kill = function () {
					(this.workers = 0),
						(this.drain = _noop),
						(this.started = !1),
						(this._tasks = []);
				}),
				(t.prototype.unshift = function (t, e) {
					this._insert(t, !0, e);
				}),
				(t.prototype.length = function () {
					return this._tasks.length;
				}),
				(t.prototype.running = function () {
					return this.workers;
				}),
				(t.prototype.idle = function () {
					return this._tasks.length + this.workers === 0;
				}),
				(t.prototype.pause = function () {
					!0 !== this.paused && (this.paused = !0);
				}),
				(t.prototype.resume = function () {
					if (!1 !== this.paused) {
						this.paused = !1;
						for (var t = 1; t <= this.concurrency; t++) this.process();
					}
				}),
				(t.eachSeries = function (t, e, i, r) {
					var s = 0,
						n = t.length;
					!(function a(o) {
						o || s === n
							? i && i(o)
							: r
							? setTimeout(function () {
									e(t[s++], a);
							  }, 1)
							: e(t[s++], a);
					})();
				}),
				(t.queue = function (e, i) {
					return new t(e, i);
				}),
				t
			);
		})(),
		MAX_PROGRESS = 100,
		rgxExtractUrlHash = /(#[\w-]+)?$/,
		Loader = (function () {
			function t(e, i) {
				var r = this;
				void 0 === e && (e = ''),
					void 0 === i && (i = 10),
					(this.progress = 0),
					(this.loading = !1),
					(this.defaultQueryString = ''),
					(this._beforeMiddleware = []),
					(this._afterMiddleware = []),
					(this._resourcesParsing = []),
					(this._boundLoadResource = function (t, e) {
						return r._loadResource(t, e);
					}),
					(this.resources = {}),
					(this.baseUrl = e),
					(this._beforeMiddleware = []),
					(this._afterMiddleware = []),
					(this._resourcesParsing = []),
					(this._boundLoadResource = function (t, e) {
						return r._loadResource(t, e);
					}),
					(this._queue = AsyncQueue.queue(this._boundLoadResource, i)),
					this._queue.pause(),
					(this.resources = {}),
					(this.onProgress = new Signal()),
					(this.onError = new Signal()),
					(this.onLoad = new Signal()),
					(this.onStart = new Signal()),
					(this.onComplete = new Signal());
				for (var s = 0; s < t._plugins.length; ++s) {
					var n = t._plugins[s],
						a = n.pre,
						o = n.use;
					a && this.pre(a), o && this.use(o);
				}
				this._protected = !1;
			}
			return (
				(t.prototype._add = function (t, e, i, r) {
					if (this.loading && (!i || !i.parentResource))
						throw new Error(
							'Cannot add resources while the loader is running.'
						);
					if (this.resources[t])
						throw new Error('Resource named "' + t + '" already exists.');
					if (
						((e = this._prepareUrl(e)),
						(this.resources[t] = new LoaderResource(t, e, i)),
						'function' == typeof r &&
							this.resources[t].onAfterMiddleware.once(r),
						this.loading)
					) {
						for (
							var s = i.parentResource, n = [], a = 0;
							a < s.children.length;
							++a
						)
							s.children[a].isComplete || n.push(s.children[a]);
						var o = (s.progressChunk * (n.length + 1)) / (n.length + 2);
						for (
							s.children.push(this.resources[t]), s.progressChunk = o, a = 0;
							a < n.length;
							++a
						)
							n[a].progressChunk = o;
						this.resources[t].progressChunk = o;
					}
					return this._queue.push(this.resources[t]), this;
				}),
				(t.prototype.pre = function (t) {
					return this._beforeMiddleware.push(t), this;
				}),
				(t.prototype.use = function (t) {
					return this._afterMiddleware.push(t), this;
				}),
				(t.prototype.reset = function () {
					for (var t in ((this.progress = 0),
					(this.loading = !1),
					this._queue.kill(),
					this._queue.pause(),
					this.resources)) {
						var e = this.resources[t];
						e._onLoadBinding && e._onLoadBinding.detach(),
							e.isLoading && e.abort('loader reset');
					}
					return (this.resources = {}), this;
				}),
				(t.prototype.load = function (t) {
					if (('function' == typeof t && this.onComplete.once(t), this.loading))
						return this;
					if (this._queue.idle()) this._onStart(), this._onComplete();
					else {
						for (
							var e = this._queue._tasks.length, i = MAX_PROGRESS / e, r = 0;
							r < this._queue._tasks.length;
							++r
						)
							this._queue._tasks[r].data.progressChunk = i;
						this._onStart(), this._queue.resume();
					}
					return this;
				}),
				Object.defineProperty(t.prototype, 'concurrency', {
					get: function () {
						return this._queue.concurrency;
					},
					set: function (t) {
						this._queue.concurrency = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype._prepareUrl = function (t) {
					var e,
						i = parseUri(t, { strictMode: !0 });
					if (
						((e =
							i.protocol || !i.path || 0 === t.indexOf('//')
								? t
								: this.baseUrl.length &&
								  this.baseUrl.lastIndexOf('/') !== this.baseUrl.length - 1 &&
								  '/' !== t.charAt(0)
								? this.baseUrl + '/' + t
								: this.baseUrl + t),
						this.defaultQueryString)
					) {
						var r = rgxExtractUrlHash.exec(e)[0];
						-1 !== (e = e.slice(0, e.length - r.length)).indexOf('?')
							? (e += '&' + this.defaultQueryString)
							: (e += '?' + this.defaultQueryString),
							(e += r);
					}
					return e;
				}),
				(t.prototype._loadResource = function (t, e) {
					var i = this;
					(t._dequeue = e),
						AsyncQueue.eachSeries(
							this._beforeMiddleware,
							function (e, r) {
								e.call(i, t, function () {
									r(t.isComplete ? {} : null);
								});
							},
							function () {
								t.isComplete
									? i._onLoad(t)
									: ((t._onLoadBinding = t.onComplete.once(i._onLoad, i)),
									  t.load());
							},
							!0
						);
				}),
				(t.prototype._onStart = function () {
					(this.progress = 0), (this.loading = !0), this.onStart.dispatch(this);
				}),
				(t.prototype._onComplete = function () {
					(this.progress = MAX_PROGRESS),
						(this.loading = !1),
						this.onComplete.dispatch(this, this.resources);
				}),
				(t.prototype._onLoad = function (t) {
					var e = this;
					(t._onLoadBinding = null),
						this._resourcesParsing.push(t),
						t._dequeue(),
						AsyncQueue.eachSeries(
							this._afterMiddleware,
							function (i, r) {
								i.call(e, t, r);
							},
							function () {
								t.onAfterMiddleware.dispatch(t),
									(e.progress = Math.min(
										MAX_PROGRESS,
										e.progress + t.progressChunk
									)),
									e.onProgress.dispatch(e, t),
									t.error
										? e.onError.dispatch(t.error, e, t)
										: e.onLoad.dispatch(e, t),
									e._resourcesParsing.splice(e._resourcesParsing.indexOf(t), 1),
									e._queue.idle() &&
										0 === e._resourcesParsing.length &&
										e._onComplete();
							},
							!0
						);
				}),
				(t.prototype.destroy = function () {
					this._protected || this.reset();
				}),
				Object.defineProperty(t, 'shared', {
					get: function () {
						var e = t._shared;
						return e || (((e = new t())._protected = !0), (t._shared = e)), e;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.registerPlugin = function (e) {
					return t._plugins.push(e), e.add && e.add(), t;
				}),
				(t._plugins = []),
				t
			);
		})();
	Loader.prototype.add = function (t, e, i, r) {
		if (Array.isArray(t)) {
			for (var s = 0; s < t.length; ++s) this.add(t[s]);
			return this;
		}
		if (
			('object' == typeof t &&
				((i = t),
				(r = e || i.callback || i.onComplete),
				(e = i.url),
				(t = i.name || i.key || i.url)),
			'string' != typeof e && ((r = i), (i = e), (e = t)),
			'string' != typeof e)
		)
			throw new Error('No url passed to add resource to loader.');
		return (
			'function' == typeof i && ((r = i), (i = null)), this._add(t, e, i, r)
		);
	};
	var TextureLoader = (function () {
			function t() {}
			return (
				(t.add = function () {
					LoaderResource.setExtensionLoadType(
						'svg',
						LoaderResource.LOAD_TYPE.XHR
					),
						LoaderResource.setExtensionXhrType(
							'svg',
							LoaderResource.XHR_RESPONSE_TYPE.TEXT
						);
				}),
				(t.use = function (t, e) {
					if (
						!t.data ||
						(t.type !== LoaderResource.TYPE.IMAGE && 'svg' !== t.extension)
					)
						e();
					else {
						var i = t.data,
							r = t.url,
							s = t.name,
							n = t.metadata;
						Texture$3.fromLoader(i, r, s, n)
							.then(function (i) {
								(t.texture = i), e();
							})
							.catch(e);
					}
				}),
				t
			);
		})(),
		_keyStr =
			'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	function encodeBinary(t) {
		for (var e = '', i = 0; i < t.length; ) {
			for (var r = [0, 0, 0], s = [0, 0, 0, 0], n = 0; n < r.length; ++n)
				i < t.length ? (r[n] = 255 & t.charCodeAt(i++)) : (r[n] = 0);
			switch (
				((s[0] = r[0] >> 2),
				(s[1] = ((3 & r[0]) << 4) | (r[1] >> 4)),
				(s[2] = ((15 & r[1]) << 2) | (r[2] >> 6)),
				(s[3] = 63 & r[2]),
				i - (t.length - 1))
			) {
				case 2:
					(s[3] = 64), (s[2] = 64);
					break;
				case 1:
					s[3] = 64;
			}
			for (n = 0; n < s.length; ++n) e += _keyStr.charAt(s[n]);
		}
		return e;
	}
	function parsing(t, e) {
		if (t.data) {
			if (t.xhr && t.xhrType === LoaderResource.XHR_RESPONSE_TYPE.BLOB)
				if (self.Blob && 'string' != typeof t.data) {
					if (0 === t.data.type.indexOf('image')) {
						var i = globalThis.URL || globalThis.webkitURL,
							r = i.createObjectURL(t.data);
						return (
							(t.blob = t.data),
							(t.data = new Image()),
							(t.data.src = r),
							(t.type = LoaderResource.TYPE.IMAGE),
							void (t.data.onload = function () {
								i.revokeObjectURL(r), (t.data.onload = null), e();
							})
						);
					}
				} else {
					var s = t.xhr.getResponseHeader('content-type');
					if (s && 0 === s.indexOf('image'))
						return (
							(t.data = new Image()),
							(t.data.src =
								'data:' + s + ';base64,' + encodeBinary(t.xhr.responseText)),
							(t.type = LoaderResource.TYPE.IMAGE),
							void (t.data.onload = function () {
								(t.data.onload = null), e();
							})
						);
				}
			e();
		} else e();
	}
	Loader.registerPlugin({ use: parsing }), Loader.registerPlugin(TextureLoader);
	/*!
	 * @pixi/text-bitmap - v6.4.2
	 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
	 *
	 * @pixi/text-bitmap is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 */
	/*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
	var extendStatics$e = function (t, e) {
		return (extendStatics$e =
			Object.setPrototypeOf ||
			({ __proto__: [] } instanceof Array &&
				function (t, e) {
					t.__proto__ = e;
				}) ||
			function (t, e) {
				for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
			})(t, e);
	};
	function __extends$e(t, e) {
		function i() {
			this.constructor = t;
		}
		extendStatics$e(t, e),
			(t.prototype =
				null === e ? Object.create(e) : ((i.prototype = e.prototype), new i()));
	}
	var BitmapFontData = function () {
			(this.info = []),
				(this.common = []),
				(this.page = []),
				(this.char = []),
				(this.kerning = []),
				(this.distanceField = []);
		},
		TextFormat = (function () {
			function t() {}
			return (
				(t.test = function (t) {
					return 'string' == typeof t && 0 === t.indexOf('info face=');
				}),
				(t.parse = function (t) {
					var e = t.match(/^[a-z]+\s+.+$/gm),
						i = {
							info: [],
							common: [],
							page: [],
							char: [],
							chars: [],
							kerning: [],
							kernings: [],
							distanceField: [],
						};
					for (var r in e) {
						var s = e[r].match(/^[a-z]+/gm)[0],
							n = e[r].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm),
							a = {};
						for (var o in n) {
							var h = n[o].split('='),
								u = h[0],
								l = h[1].replace(/"/gm, ''),
								c = parseFloat(l),
								d = isNaN(c) ? l : c;
							a[u] = d;
						}
						i[s].push(a);
					}
					var p = new BitmapFontData();
					return (
						i.info.forEach(function (t) {
							return p.info.push({ face: t.face, size: parseInt(t.size, 10) });
						}),
						i.common.forEach(function (t) {
							return p.common.push({ lineHeight: parseInt(t.lineHeight, 10) });
						}),
						i.page.forEach(function (t) {
							return p.page.push({ id: parseInt(t.id, 10), file: t.file });
						}),
						i.char.forEach(function (t) {
							return p.char.push({
								id: parseInt(t.id, 10),
								page: parseInt(t.page, 10),
								x: parseInt(t.x, 10),
								y: parseInt(t.y, 10),
								width: parseInt(t.width, 10),
								height: parseInt(t.height, 10),
								xoffset: parseInt(t.xoffset, 10),
								yoffset: parseInt(t.yoffset, 10),
								xadvance: parseInt(t.xadvance, 10),
							});
						}),
						i.kerning.forEach(function (t) {
							return p.kerning.push({
								first: parseInt(t.first, 10),
								second: parseInt(t.second, 10),
								amount: parseInt(t.amount, 10),
							});
						}),
						i.distanceField.forEach(function (t) {
							return p.distanceField.push({
								distanceRange: parseInt(t.distanceRange, 10),
								fieldType: t.fieldType,
							});
						}),
						p
					);
				}),
				t
			);
		})(),
		XMLFormat = (function () {
			function t() {}
			return (
				(t.test = function (t) {
					return (
						t instanceof XMLDocument &&
						t.getElementsByTagName('page').length &&
						null !== t.getElementsByTagName('info')[0].getAttribute('face')
					);
				}),
				(t.parse = function (t) {
					for (
						var e = new BitmapFontData(),
							i = t.getElementsByTagName('info'),
							r = t.getElementsByTagName('common'),
							s = t.getElementsByTagName('page'),
							n = t.getElementsByTagName('char'),
							a = t.getElementsByTagName('kerning'),
							o = t.getElementsByTagName('distanceField'),
							h = 0;
						h < i.length;
						h++
					)
						e.info.push({
							face: i[h].getAttribute('face'),
							size: parseInt(i[h].getAttribute('size'), 10),
						});
					for (h = 0; h < r.length; h++)
						e.common.push({
							lineHeight: parseInt(r[h].getAttribute('lineHeight'), 10),
						});
					for (h = 0; h < s.length; h++)
						e.page.push({
							id: parseInt(s[h].getAttribute('id'), 10) || 0,
							file: s[h].getAttribute('file'),
						});
					for (h = 0; h < n.length; h++) {
						var u = n[h];
						e.char.push({
							id: parseInt(u.getAttribute('id'), 10),
							page: parseInt(u.getAttribute('page'), 10) || 0,
							x: parseInt(u.getAttribute('x'), 10),
							y: parseInt(u.getAttribute('y'), 10),
							width: parseInt(u.getAttribute('width'), 10),
							height: parseInt(u.getAttribute('height'), 10),
							xoffset: parseInt(u.getAttribute('xoffset'), 10),
							yoffset: parseInt(u.getAttribute('yoffset'), 10),
							xadvance: parseInt(u.getAttribute('xadvance'), 10),
						});
					}
					for (h = 0; h < a.length; h++)
						e.kerning.push({
							first: parseInt(a[h].getAttribute('first'), 10),
							second: parseInt(a[h].getAttribute('second'), 10),
							amount: parseInt(a[h].getAttribute('amount'), 10),
						});
					for (h = 0; h < o.length; h++)
						e.distanceField.push({
							fieldType: o[h].getAttribute('fieldType'),
							distanceRange: parseInt(o[h].getAttribute('distanceRange'), 10),
						});
					return e;
				}),
				t
			);
		})(),
		XMLStringFormat = (function () {
			function t() {}
			return (
				(t.test = function (t) {
					if ('string' == typeof t && t.indexOf('<font>') > -1) {
						var e = new globalThis.DOMParser().parseFromString(t, 'text/xml');
						return XMLFormat.test(e);
					}
					return !1;
				}),
				(t.parse = function (t) {
					var e = new globalThis.DOMParser().parseFromString(t, 'text/xml');
					return XMLFormat.parse(e);
				}),
				t
			);
		})(),
		formats = [TextFormat, XMLFormat, XMLStringFormat];
	function autoDetectFormat(t) {
		for (var e = 0; e < formats.length; e++)
			if (formats[e].test(t)) return formats[e];
		return null;
	}
	function generateFillStyle(t, e, i, r, s, n) {
		var a,
			o = i.fill;
		if (!Array.isArray(o)) return o;
		if (1 === o.length) return o[0];
		var h = i.dropShadow ? i.dropShadowDistance : 0,
			u = i.padding || 0,
			l = t.width / r - h - 2 * u,
			c = t.height / r - h - 2 * u,
			d = o.slice(),
			p = i.fillGradientStops.slice();
		if (!p.length) for (var f = d.length + 1, m = 1; m < f; ++m) p.push(m / f);
		if (
			(d.unshift(o[0]),
			p.unshift(0),
			d.push(o[o.length - 1]),
			p.push(1),
			i.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL)
		) {
			a = e.createLinearGradient(l / 2, u, l / 2, c + u);
			var _ = 0,
				g = (n.fontProperties.fontSize + i.strokeThickness) / c;
			for (m = 0; m < s.length; m++)
				for (var E = n.lineHeight * m, y = 0; y < d.length; y++) {
					var T = E / c + ('number' == typeof p[y] ? p[y] : y / d.length) * g,
						v = Math.max(_, T);
					(v = Math.min(v, 1)), a.addColorStop(v, d[y]), (_ = v);
				}
		} else {
			a = e.createLinearGradient(u, c / 2, l + u, c / 2);
			var S = d.length + 1,
				x = 1;
			for (m = 0; m < d.length; m++) {
				var b;
				(b = 'number' == typeof p[m] ? p[m] : x / S),
					a.addColorStop(b, d[m]),
					x++;
			}
		}
		return a;
	}
	function drawGlyph(t, e, i, r, s, n, a) {
		var o = i.text,
			h = i.fontProperties;
		e.translate(r, s), e.scale(n, n);
		var u = a.strokeThickness / 2,
			l = -a.strokeThickness / 2;
		if (
			((e.font = a.toFontString()),
			(e.lineWidth = a.strokeThickness),
			(e.textBaseline = a.textBaseline),
			(e.lineJoin = a.lineJoin),
			(e.miterLimit = a.miterLimit),
			(e.fillStyle = generateFillStyle(t, e, a, n, [o], i)),
			(e.strokeStyle = a.stroke),
			a.dropShadow)
		) {
			var c = a.dropShadowColor,
				d = hex2rgb$3('number' == typeof c ? c : string2hex(c)),
				p = a.dropShadowBlur * n,
				f = a.dropShadowDistance * n;
			(e.shadowColor =
				'rgba(' +
				255 * d[0] +
				',' +
				255 * d[1] +
				',' +
				255 * d[2] +
				',' +
				a.dropShadowAlpha +
				')'),
				(e.shadowBlur = p),
				(e.shadowOffsetX = Math.cos(a.dropShadowAngle) * f),
				(e.shadowOffsetY = Math.sin(a.dropShadowAngle) * f);
		} else
			(e.shadowColor = 'black'),
				(e.shadowBlur = 0),
				(e.shadowOffsetX = 0),
				(e.shadowOffsetY = 0);
		a.stroke &&
			a.strokeThickness &&
			e.strokeText(o, u, l + i.lineHeight - h.descent),
			a.fill && e.fillText(o, u, l + i.lineHeight - h.descent),
			e.setTransform(1, 0, 0, 1, 0, 0),
			(e.fillStyle = 'rgba(0, 0, 0, 0)');
	}
	function splitTextToCharacters(t) {
		return Array.from ? Array.from(t) : t.split('');
	}
	function resolveCharacters(t) {
		'string' == typeof t && (t = [t]);
		for (var e = [], i = 0, r = t.length; i < r; i++) {
			var s = t[i];
			if (Array.isArray(s)) {
				if (2 !== s.length)
					throw new Error(
						'[BitmapFont]: Invalid character range length, expecting 2 got ' +
							s.length +
							'.'
					);
				var n = s[0].charCodeAt(0),
					a = s[1].charCodeAt(0);
				if (a < n) throw new Error('[BitmapFont]: Invalid character range.');
				for (var o = n, h = a; o <= h; o++) e.push(String.fromCharCode(o));
			} else e.push.apply(e, splitTextToCharacters(s));
		}
		if (0 === e.length)
			throw new Error('[BitmapFont]: Empty set when resolving characters.');
		return e;
	}
	function extractCharCode(t) {
		return t.codePointAt ? t.codePointAt(0) : t.charCodeAt(0);
	}
	var BitmapFont = (function () {
			function t(t, e, i) {
				var r,
					s,
					n = t.info[0],
					a = t.common[0],
					o = t.page[0],
					h = t.distanceField[0],
					u = getResolutionOfUrl$3(o.file),
					l = {};
				(this._ownsTextures = i),
					(this.font = n.face),
					(this.size = n.size),
					(this.lineHeight = a.lineHeight / u),
					(this.chars = {}),
					(this.pageTextures = l);
				for (var c = 0; c < t.page.length; c++) {
					var d = t.page[c],
						p = d.id,
						f = d.file;
					(l[p] = e instanceof Array ? e[c] : e[f]),
						(null == h ? void 0 : h.fieldType) &&
							'none' !== h.fieldType &&
							(l[p].baseTexture.alphaMode =
								ALPHA_MODES$9.NO_PREMULTIPLIED_ALPHA);
				}
				for (c = 0; c < t.char.length; c++) {
					var m = t.char[c],
						_ = ((p = m.id), m.page),
						g = t.char[c],
						E = g.x,
						y = g.y,
						T = g.width,
						v = g.height,
						S = g.xoffset,
						x = g.yoffset,
						b = g.xadvance;
					(y /= u), (T /= u), (v /= u), (S /= u), (x /= u), (b /= u);
					var A = new Rectangle$4(
						(E /= u) + l[_].frame.x / u,
						y + l[_].frame.y / u,
						T,
						v
					);
					this.chars[p] = {
						xOffset: S,
						yOffset: x,
						xAdvance: b,
						kerning: {},
						texture: new Texture$3(l[_].baseTexture, A),
						page: _,
					};
				}
				for (c = 0; c < t.kerning.length; c++) {
					var R = t.kerning[c],
						I = R.first,
						M = R.second,
						w = R.amount;
					(I /= u),
						(M /= u),
						(w /= u),
						this.chars[M] && (this.chars[M].kerning[I] = w);
				}
				(this.distanceFieldRange = null == h ? void 0 : h.distanceRange),
					(this.distanceFieldType =
						null !==
							(s =
								null === (r = null == h ? void 0 : h.fieldType) || void 0 === r
									? void 0
									: r.toLowerCase()) && void 0 !== s
							? s
							: 'none');
			}
			return (
				(t.prototype.destroy = function () {
					for (var t in this.chars)
						this.chars[t].texture.destroy(), (this.chars[t].texture = null);
					for (var t in this.pageTextures)
						this._ownsTextures && this.pageTextures[t].destroy(!0),
							(this.pageTextures[t] = null);
					(this.chars = null), (this.pageTextures = null);
				}),
				(t.install = function (e, i, r) {
					var s;
					if (e instanceof BitmapFontData) s = e;
					else {
						var n = autoDetectFormat(e);
						if (!n) throw new Error('Unrecognized data format for font.');
						s = n.parse(e);
					}
					i instanceof Texture$3 && (i = [i]);
					var a = new t(s, i, r);
					return (t.available[a.font] = a), a;
				}),
				(t.uninstall = function (e) {
					var i = t.available[e];
					if (!i) throw new Error("No font found named '" + e + "'");
					i.destroy(), delete t.available[e];
				}),
				(t.from = function (e, i, r) {
					if (!e) throw new Error('[BitmapFont] Property `name` is required.');
					var s = Object.assign({}, t.defaultOptions, r),
						n = s.chars,
						a = s.padding,
						o = s.resolution,
						h = s.textureWidth,
						u = s.textureHeight,
						l = resolveCharacters(n),
						c = i instanceof TextStyle ? i : new TextStyle(i),
						d = h,
						p = new BitmapFontData();
					(p.info[0] = { face: c.fontFamily, size: c.fontSize }),
						(p.common[0] = { lineHeight: c.fontSize });
					for (
						var f, m, _, g = 0, E = 0, y = 0, T = [], v = 0;
						v < l.length;
						v++
					) {
						f ||
							(((f = document.createElement('canvas')).width = h),
							(f.height = u),
							(m = f.getContext('2d')),
							(_ = new BaseTexture$3(f, { resolution: o })),
							T.push(new Texture$3(_)),
							p.page.push({ id: T.length - 1, file: '' }));
						var S = TextMetrics.measureText(l[v], c, !1, f),
							x = S.width,
							b = Math.ceil(S.height),
							A = Math.ceil(('italic' === c.fontStyle ? 2 : 1) * x);
						if (E >= u - b * o) {
							if (0 === E)
								throw new Error(
									'[BitmapFont] textureHeight ' +
										u +
										'px is too small for ' +
										c.fontSize +
										'px fonts'
								);
							--v,
								(f = null),
								(m = null),
								(_ = null),
								(E = 0),
								(g = 0),
								(y = 0);
						} else if (
							((y = Math.max(b + S.fontProperties.descent, y)), A * o + g >= d)
						)
							--v, (E += y * o), (E = Math.ceil(E)), (g = 0), (y = 0);
						else {
							drawGlyph(f, m, S, g, E, o, c);
							var R = extractCharCode(S.text);
							p.char.push({
								id: R,
								page: T.length - 1,
								x: g / o,
								y: E / o,
								width: A,
								height: b,
								xoffset: 0,
								yoffset: 0,
								xadvance: Math.ceil(
									x -
										(c.dropShadow ? c.dropShadowDistance : 0) -
										(c.stroke ? c.strokeThickness : 0)
								),
							}),
								(g += (A + 2 * a) * o),
								(g = Math.ceil(g));
						}
					}
					v = 0;
					for (var I = l.length; v < I; v++)
						for (var M = l[v], w = 0; w < I; w++) {
							var C = l[w],
								P = m.measureText(M).width,
								O = m.measureText(C).width,
								$ = m.measureText(M + C).width - (P + O);
							$ &&
								p.kerning.push({
									first: extractCharCode(M),
									second: extractCharCode(C),
									amount: $,
								});
						}
					var N = new t(p, T, !0);
					return (
						void 0 !== t.available[e] && t.uninstall(e), (t.available[e] = N), N
					);
				}),
				(t.ALPHA = [['a', 'z'], ['A', 'Z'], ' ']),
				(t.NUMERIC = [['0', '9']]),
				(t.ALPHANUMERIC = [['a', 'z'], ['A', 'Z'], ['0', '9'], ' ']),
				(t.ASCII = [[' ', '~']]),
				(t.defaultOptions = {
					resolution: 1,
					textureWidth: 512,
					textureHeight: 512,
					padding: 4,
					chars: t.ALPHANUMERIC,
				}),
				(t.available = {}),
				t
			);
		})(),
		msdfFrag =
			'// Pixi texture info\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\n// Tint\r\nuniform vec4 uColor;\r\n\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r\nuniform float uFWidth;\r\n\r\nvoid main(void) {\r\n\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\r\n\r\n  // MSDF\r\n  float median = texColor.r + texColor.g + texColor.b -\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\r\n                  max(texColor.r, max(texColor.g, texColor.b));\r\n  // SDF\r\n  median = min(median, texColor.a);\r\n\r\n  float screenPxDistance = uFWidth * (median - 0.5);\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r\n\r\n  // NPM Textures, NPM outputs\r\n  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\r\n\r\n}\r\n',
		msdfVert =
			'// Mesh material default fragment\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n',
		pageMeshDataDefaultPageMeshData = [],
		pageMeshDataMSDFPageMeshData = [],
		charRenderDataPool = [],
		BitmapText = (function (t) {
			function e(i, r) {
				void 0 === r && (r = {});
				var s = t.call(this) || this;
				s._tint = 16777215;
				var n = Object.assign({}, e.styleDefaults, r),
					a = n.align,
					o = n.tint,
					h = n.maxWidth,
					u = n.letterSpacing,
					l = n.fontName,
					c = n.fontSize;
				if (!BitmapFont.available[l])
					throw new Error('Missing BitmapFont "' + l + '"');
				return (
					(s._activePagesMeshData = []),
					(s._textWidth = 0),
					(s._textHeight = 0),
					(s._align = a),
					(s._tint = o),
					(s._fontName = l),
					(s._fontSize = c || BitmapFont.available[l].size),
					(s.text = i),
					(s._maxWidth = h),
					(s._maxLineHeight = 0),
					(s._letterSpacing = u),
					(s._anchor = new ObservablePoint$3(
						function () {
							s.dirty = !0;
						},
						s,
						0,
						0
					)),
					(s._roundPixels = settings$4.ROUND_PIXELS),
					(s.dirty = !0),
					(s._resolution = settings$4.RESOLUTION),
					(s._autoResolution = !0),
					(s._textureCache = {}),
					s
				);
			}
			return (
				__extends$e(e, t),
				(e.prototype.updateText = function () {
					for (
						var t,
							e = BitmapFont.available[this._fontName],
							i = this._fontSize / e.size,
							r = new Point$4(),
							s = [],
							n = [],
							a = [],
							o = splitTextToCharacters(
								this._text.replace(/(?:\r\n|\r)/g, '\n') || ' '
							),
							h = (this._maxWidth * e.size) / this._fontSize,
							u =
								'none' === e.distanceFieldType
									? pageMeshDataDefaultPageMeshData
									: pageMeshDataMSDFPageMeshData,
							l = null,
							c = 0,
							d = 0,
							p = 0,
							f = -1,
							m = 0,
							_ = 0,
							g = 0,
							E = 0,
							y = 0;
						y < o.length;
						y++
					) {
						var T = extractCharCode((G = o[y]));
						if (
							(/(?:\s)/.test(G) && ((f = y), (m = c), E++),
							'\r' !== G && '\n' !== G)
						) {
							var v = e.chars[T];
							if (v) {
								l && v.kerning[l] && (r.x += v.kerning[l]);
								var S = charRenderDataPool.pop() || {
									texture: Texture$3.EMPTY,
									line: 0,
									charCode: 0,
									prevSpaces: 0,
									position: new Point$4(),
								};
								(S.texture = v.texture),
									(S.line = p),
									(S.charCode = T),
									(S.position.x = r.x + v.xOffset + this._letterSpacing / 2),
									(S.position.y = r.y + v.yOffset),
									(S.prevSpaces = E),
									s.push(S),
									(c =
										S.position.x + Math.max(v.xAdvance, v.texture.orig.width)),
									(r.x += v.xAdvance + this._letterSpacing),
									(g = Math.max(g, v.yOffset + v.texture.height)),
									(l = T),
									-1 !== f &&
										h > 0 &&
										r.x > h &&
										(removeItems$3(s, 1 + f - ++_, 1 + y - f),
										(y = f),
										(f = -1),
										n.push(m),
										a.push(s.length > 0 ? s[s.length - 1].prevSpaces : 0),
										(d = Math.max(d, m)),
										p++,
										(r.x = 0),
										(r.y += e.lineHeight),
										(l = null),
										(E = 0));
							}
						} else
							n.push(c),
								a.push(-1),
								(d = Math.max(d, c)),
								++p,
								++_,
								(r.x = 0),
								(r.y += e.lineHeight),
								(l = null),
								(E = 0);
					}
					var x = o[o.length - 1];
					'\r' !== x &&
						'\n' !== x &&
						(/(?:\s)/.test(x) && (c = m),
						n.push(c),
						(d = Math.max(d, c)),
						a.push(-1));
					var b = [];
					for (y = 0; y <= p; y++) {
						var A = 0;
						'right' === this._align
							? (A = d - n[y])
							: 'center' === this._align
							? (A = (d - n[y]) / 2)
							: 'justify' === this._align &&
							  (A = a[y] < 0 ? 0 : (d - n[y]) / a[y]),
							b.push(A);
					}
					var R = s.length,
						I = {},
						M = [],
						w = this._activePagesMeshData;
					for (y = 0; y < w.length; y++) u.push(w[y]);
					for (y = 0; y < R; y++) {
						var C = (W = s[y].texture).baseTexture.uid;
						if (!I[C]) {
							if (!(q = u.pop())) {
								var P = new MeshGeometry(),
									O = void 0,
									$ = void 0;
								'none' === e.distanceFieldType
									? ((O = new MeshMaterial(Texture$3.EMPTY)),
									  ($ = BLEND_MODES$9.NORMAL))
									: ((O = new MeshMaterial(Texture$3.EMPTY, {
											program: Program$3.from(msdfVert, msdfFrag),
											uniforms: { uFWidth: 0 },
									  })),
									  ($ = BLEND_MODES$9.NORMAL_NPM));
								var N = new Mesh(P, O);
								(N.blendMode = $),
									(q = {
										index: 0,
										indexCount: 0,
										vertexCount: 0,
										uvsCount: 0,
										total: 0,
										mesh: N,
										vertices: null,
										uvs: null,
										indices: null,
									});
							}
							(q.index = 0),
								(q.indexCount = 0),
								(q.vertexCount = 0),
								(q.uvsCount = 0),
								(q.total = 0);
							var D = this._textureCache;
							(D[C] = D[C] || new Texture$3(W.baseTexture)),
								(q.mesh.texture = D[C]),
								(q.mesh.tint = this._tint),
								M.push(q),
								(I[C] = q);
						}
						I[C].total++;
					}
					for (y = 0; y < w.length; y++)
						-1 === M.indexOf(w[y]) && this.removeChild(w[y].mesh);
					for (y = 0; y < M.length; y++)
						M[y].mesh.parent !== this && this.addChild(M[y].mesh);
					for (var y in ((this._activePagesMeshData = M), I)) {
						var L = (q = I[y]).total;
						if (
							!(
								(null === (t = q.indices) || void 0 === t ? void 0 : t.length) >
								6 * L
							) ||
							q.vertices.length < 2 * Mesh.BATCHABLE_SIZE
						)
							(q.vertices = new Float32Array(8 * L)),
								(q.uvs = new Float32Array(8 * L)),
								(q.indices = new Uint16Array(6 * L));
						else
							for (
								var B = q.total, F = q.vertices, U = 4 * B * 2;
								U < F.length;
								U++
							)
								F[U] = 0;
						q.mesh.size = 6 * L;
					}
					for (y = 0; y < R; y++) {
						var G,
							k =
								(G = s[y]).position.x +
								b[G.line] * ('justify' === this._align ? G.prevSpaces : 1);
						this._roundPixels && (k = Math.round(k));
						var W,
							H = k * i,
							Y = G.position.y * i,
							V = I[(W = G.texture).baseTexture.uid],
							X = W.frame,
							j = W._uvs,
							z = V.index++;
						(V.indices[6 * z + 0] = 0 + 4 * z),
							(V.indices[6 * z + 1] = 1 + 4 * z),
							(V.indices[6 * z + 2] = 2 + 4 * z),
							(V.indices[6 * z + 3] = 0 + 4 * z),
							(V.indices[6 * z + 4] = 2 + 4 * z),
							(V.indices[6 * z + 5] = 3 + 4 * z),
							(V.vertices[8 * z + 0] = H),
							(V.vertices[8 * z + 1] = Y),
							(V.vertices[8 * z + 2] = H + X.width * i),
							(V.vertices[8 * z + 3] = Y),
							(V.vertices[8 * z + 4] = H + X.width * i),
							(V.vertices[8 * z + 5] = Y + X.height * i),
							(V.vertices[8 * z + 6] = H),
							(V.vertices[8 * z + 7] = Y + X.height * i),
							(V.uvs[8 * z + 0] = j.x0),
							(V.uvs[8 * z + 1] = j.y0),
							(V.uvs[8 * z + 2] = j.x1),
							(V.uvs[8 * z + 3] = j.y1),
							(V.uvs[8 * z + 4] = j.x2),
							(V.uvs[8 * z + 5] = j.y2),
							(V.uvs[8 * z + 6] = j.x3),
							(V.uvs[8 * z + 7] = j.y3);
					}
					for (var y in ((this._textWidth = d * i),
					(this._textHeight = (r.y + e.lineHeight) * i),
					I)) {
						var q = I[y];
						if (0 !== this.anchor.x || 0 !== this.anchor.y)
							for (
								var K = 0,
									Z = this._textWidth * this.anchor.x,
									Q = this._textHeight * this.anchor.y,
									J = 0;
								J < q.total;
								J++
							)
								(q.vertices[K++] -= Z),
									(q.vertices[K++] -= Q),
									(q.vertices[K++] -= Z),
									(q.vertices[K++] -= Q),
									(q.vertices[K++] -= Z),
									(q.vertices[K++] -= Q),
									(q.vertices[K++] -= Z),
									(q.vertices[K++] -= Q);
						this._maxLineHeight = g * i;
						var tt = q.mesh.geometry.getBuffer('aVertexPosition'),
							et = q.mesh.geometry.getBuffer('aTextureCoord'),
							it = q.mesh.geometry.getIndex();
						(tt.data = q.vertices),
							(et.data = q.uvs),
							(it.data = q.indices),
							tt.update(),
							et.update(),
							it.update();
					}
					for (y = 0; y < s.length; y++) charRenderDataPool.push(s[y]);
				}),
				(e.prototype.updateTransform = function () {
					this.validate(), this.containerUpdateTransform();
				}),
				(e.prototype._render = function (e) {
					this._autoResolution &&
						this._resolution !== e.resolution &&
						((this._resolution = e.resolution), (this.dirty = !0));
					var i = BitmapFont.available[this._fontName],
						r = i.distanceFieldRange,
						s = i.distanceFieldType,
						n = i.size;
					if ('none' !== s)
						for (
							var a = this.worldTransform,
								o = a.a,
								h = a.b,
								u = a.c,
								l = a.d,
								c = Math.sqrt(o * o + h * h),
								d = Math.sqrt(u * u + l * l),
								p = (Math.abs(c) + Math.abs(d)) / 2,
								f = this._fontSize / n,
								m = 0,
								_ = this._activePagesMeshData;
							m < _.length;
							m++
						)
							_[m].mesh.shader.uniforms.uFWidth = p * r * f * this._resolution;
					t.prototype._render.call(this, e);
				}),
				(e.prototype.getLocalBounds = function () {
					return this.validate(), t.prototype.getLocalBounds.call(this);
				}),
				(e.prototype.validate = function () {
					this.dirty && (this.updateText(), (this.dirty = !1));
				}),
				Object.defineProperty(e.prototype, 'tint', {
					get: function () {
						return this._tint;
					},
					set: function (t) {
						if (this._tint !== t) {
							this._tint = t;
							for (var e = 0; e < this._activePagesMeshData.length; e++)
								this._activePagesMeshData[e].mesh.tint = t;
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'align', {
					get: function () {
						return this._align;
					},
					set: function (t) {
						this._align !== t && ((this._align = t), (this.dirty = !0));
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'fontName', {
					get: function () {
						return this._fontName;
					},
					set: function (t) {
						if (!BitmapFont.available[t])
							throw new Error('Missing BitmapFont "' + t + '"');
						this._fontName !== t && ((this._fontName = t), (this.dirty = !0));
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'fontSize', {
					get: function () {
						return this._fontSize;
					},
					set: function (t) {
						this._fontSize !== t && ((this._fontSize = t), (this.dirty = !0));
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'anchor', {
					get: function () {
						return this._anchor;
					},
					set: function (t) {
						'number' == typeof t
							? this._anchor.set(t)
							: this._anchor.copyFrom(t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'text', {
					get: function () {
						return this._text;
					},
					set: function (t) {
						(t = String(null == t ? '' : t)),
							this._text !== t && ((this._text = t), (this.dirty = !0));
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'maxWidth', {
					get: function () {
						return this._maxWidth;
					},
					set: function (t) {
						this._maxWidth !== t && ((this._maxWidth = t), (this.dirty = !0));
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'maxLineHeight', {
					get: function () {
						return this.validate(), this._maxLineHeight;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'textWidth', {
					get: function () {
						return this.validate(), this._textWidth;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'letterSpacing', {
					get: function () {
						return this._letterSpacing;
					},
					set: function (t) {
						this._letterSpacing !== t &&
							((this._letterSpacing = t), (this.dirty = !0));
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'roundPixels', {
					get: function () {
						return this._roundPixels;
					},
					set: function (t) {
						t !== this._roundPixels &&
							((this._roundPixels = t), (this.dirty = !0));
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'textHeight', {
					get: function () {
						return this.validate(), this._textHeight;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'resolution', {
					get: function () {
						return this._resolution;
					},
					set: function (t) {
						(this._autoResolution = !1),
							this._resolution !== t &&
								((this._resolution = t), (this.dirty = !0));
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.destroy = function (e) {
					var i = this._textureCache;
					for (var r in i) i[r].destroy(), delete i[r];
					(this._textureCache = null), t.prototype.destroy.call(this, e);
				}),
				(e.styleDefaults = {
					align: 'left',
					tint: 16777215,
					maxWidth: 0,
					letterSpacing: 0,
				}),
				e
			);
		})(Container$2),
		BitmapFontLoader = (function () {
			function t() {}
			return (
				(t.add = function () {
					LoaderResource.setExtensionXhrType(
						'fnt',
						LoaderResource.XHR_RESPONSE_TYPE.TEXT
					);
				}),
				(t.use = function (e, i) {
					var r = autoDetectFormat(e.data);
					if (r)
						for (
							var s = t.getBaseUrl(this, e),
								n = r.parse(e.data),
								a = {},
								o = function (t) {
									(a[t.metadata.pageFile] = t.texture),
										Object.keys(a).length === n.page.length &&
											((e.bitmapFont = BitmapFont.install(n, a, !0)), i());
								},
								h = 0;
							h < n.page.length;
							++h
						) {
							var u = n.page[h].file,
								l = s + u,
								c = !1;
							for (var d in this.resources) {
								var p = this.resources[d];
								if (p.url === l) {
									(p.metadata.pageFile = u),
										p.texture ? o(p) : p.onAfterMiddleware.add(o),
										(c = !0);
									break;
								}
							}
							if (!c) {
								var f = {
									crossOrigin: e.crossOrigin,
									loadType: LoaderResource.LOAD_TYPE.IMAGE,
									metadata: Object.assign(
										{ pageFile: u },
										e.metadata.imageMetadata
									),
									parentResource: e,
								};
								this.add(l, f, o);
							}
						}
					else i();
				}),
				(t.getBaseUrl = function (e, i) {
					var r = i.isDataUrl ? '' : t.dirname(i.url);
					return (
						i.isDataUrl &&
							('.' === r && (r = ''),
							e.baseUrl &&
								r &&
								'/' === e.baseUrl.charAt(e.baseUrl.length - 1) &&
								(r += '/')),
						(r = r.replace(e.baseUrl, '')) &&
							'/' !== r.charAt(r.length - 1) &&
							(r += '/'),
						r
					);
				}),
				(t.dirname = function (t) {
					var e = t
						.replace(/\\/g, '/')
						.replace(/\/$/, '')
						.replace(/\/[^\/]*$/, '');
					return e === t ? '.' : '' === e ? '/' : e;
				}),
				t
			);
		})(),
		PolygonUtils = (function () {
			function t() {}
			return (
				(t.offsetPolygon = function (e, i) {
					var r = [],
						s = e.length;
					i = t.isPolygonClockwise(e) ? i : -1 * i;
					for (var n = 0; n < s; n += 2) {
						var a = n - 2;
						a < 0 && (a += s);
						var o = (n + 2) % s,
							h = e[n] - e[a],
							u = e[n + 1] - e[a + 1],
							l = Math.sqrt(h * h + u * u);
						(h /= l), (u /= l);
						var c = -(u *= i),
							d = (h *= i),
							p = [e[a] + c, e[a + 1] + d],
							f = [e[n] + c, e[n + 1] + d],
							m = e[o] - e[n],
							_ = e[o + 1] - e[n + 1];
						(m /= l = Math.sqrt(m * m + _ * _)), (_ /= l);
						var g = -(_ *= i),
							E = (m *= i),
							y = [e[n] + g, e[n + 1] + E],
							T = [e[o] + g, e[o + 1] + E],
							v = t.findIntersection(
								p[0],
								p[1],
								f[0],
								f[1],
								y[0],
								y[1],
								T[0],
								T[1]
							);
						v && r.push.apply(r, v);
					}
					return r;
				}),
				(t.findIntersection = function (t, e, i, r, s, n, a, o) {
					var h = (o - n) * (i - t) - (a - s) * (r - e),
						u = (a - s) * (e - n) - (o - n) * (t - s);
					if (0 === h)
						return 0 === u && 0 == (i - t) * (e - n) - (r - e) * (t - s)
							? [(t + i) / 2, (e + r) / 2]
							: null;
					var l = u / h;
					return [t + l * (i - t), e + l * (r - e)];
				}),
				(t.isPolygonClockwise = function (t) {
					for (var e = 0, i = 0, r = t.length - 2; i < t.length; r = i, i += 2)
						e += (t[i] - t[r]) * (t[i + 1] + t[r + 1]);
					return e > 0;
				}),
				t
			);
		})(),
		CanvasGraphicsRenderer = (function () {
			function t(t) {
				(this._svgMatrix = null),
					(this._tempMatrix = new Matrix$3()),
					(this.renderer = t);
			}
			return (
				(t.prototype._calcCanvasStyle = function (t, e) {
					var i;
					return (
						t.texture && t.texture.baseTexture !== Texture$3.WHITE.baseTexture
							? t.texture.valid
								? ((i = canvasUtils.getTintedPattern(t.texture, e)),
								  this.setPatternTransform(i, t.matrix || Matrix$3.IDENTITY))
								: (i = '#808080')
							: (i = '#' + ('00000' + (0 | e).toString(16)).slice(-6)),
						i
					);
				}),
				(t.prototype.render = function (t) {
					var e = this.renderer,
						i = e.context,
						r = t.worldAlpha,
						s = t.transform.worldTransform;
					e.setContextTransform(s), e.setBlendMode(t.blendMode);
					for (
						var n,
							a,
							o = t.geometry.graphicsData,
							h = ((t.tint >> 16) & 255) / 255,
							u = ((t.tint >> 8) & 255) / 255,
							l = (255 & t.tint) / 255,
							c = 0;
						c < o.length;
						c++
					) {
						var d = o[c],
							p = d.shape,
							f = d.fillStyle,
							m = d.lineStyle,
							_ = 0 | d.fillStyle.color,
							g = 0 | d.lineStyle.color;
						if (
							(d.matrix &&
								e.setContextTransform(
									s.copyTo(this._tempMatrix).append(d.matrix)
								),
							f.visible)
						) {
							var E =
								(((((_ >> 16) & 255) / 255) * h * 255) << 16) +
								(((((_ >> 8) & 255) / 255) * u * 255) << 8) +
								((255 & _) / 255) * l * 255;
							n = this._calcCanvasStyle(f, E);
						}
						if (m.visible) {
							var y =
								(((((g >> 16) & 255) / 255) * h * 255) << 16) +
								(((((g >> 8) & 255) / 255) * u * 255) << 8) +
								((255 & g) / 255) * l * 255;
							a = this._calcCanvasStyle(m, y);
						}
						if (
							((i.lineWidth = m.width),
							(i.lineCap = m.cap),
							(i.lineJoin = m.join),
							(i.miterLimit = m.miterLimit),
							d.type === SHAPES$3.POLY)
						) {
							i.beginPath();
							var T = (w = p).points,
								v = d.holes,
								S = void 0,
								x = void 0,
								b = void 0,
								A = void 0,
								R = void 0;
							i.moveTo(T[0], T[1]);
							for (var I = 2; I < T.length; I += 2) i.lineTo(T[I], T[I + 1]);
							if ((w.closeStroke && i.closePath(), v.length > 0)) {
								for (
									R = [], S = 0, b = T[0], A = T[1], I = 2;
									I + 2 < T.length;
									I += 2
								)
									S +=
										(T[I] - b) * (T[I + 3] - A) -
										(T[I + 2] - b) * (T[I + 1] - A);
								for (var M = 0; M < v.length; M++)
									if ((T = v[M].shape.points)) {
										for (
											x = 0, b = T[0], A = T[1], I = 2;
											I + 2 < T.length;
											I += 2
										)
											x +=
												(T[I] - b) * (T[I + 3] - A) -
												(T[I + 2] - b) * (T[I + 1] - A);
										if (x * S < 0)
											for (i.moveTo(T[0], T[1]), I = 2; I < T.length; I += 2)
												i.lineTo(T[I], T[I + 1]);
										else
											for (
												i.moveTo(T[T.length - 2], T[T.length - 1]),
													I = T.length - 4;
												I >= 0;
												I -= 2
											)
												i.lineTo(T[I], T[I + 1]);
										v[M].shape.closeStroke && i.closePath(), (R[M] = x * S < 0);
									}
							}
							f.visible &&
								((i.globalAlpha = f.alpha * r), (i.fillStyle = n), i.fill()),
								m.visible && this.paintPolygonStroke(w, m, a, v, R, r, i);
						} else if (d.type === SHAPES$3.RECT) {
							var w = p;
							if (
								(f.visible &&
									((i.globalAlpha = f.alpha * r),
									(i.fillStyle = n),
									i.fillRect(w.x, w.y, w.width, w.height)),
								m.visible)
							) {
								var C = m.width * (0.5 - (1 - m.alignment)),
									P = w.width + 2 * C,
									O = w.height + 2 * C;
								(i.globalAlpha = m.alpha * r),
									(i.strokeStyle = a),
									i.strokeRect(w.x - C, w.y - C, P, O);
							}
						} else if (d.type === SHAPES$3.CIRC)
							(w = p),
								i.beginPath(),
								i.arc(w.x, w.y, w.radius, 0, 2 * Math.PI),
								i.closePath(),
								f.visible &&
									((i.globalAlpha = f.alpha * r), (i.fillStyle = n), i.fill()),
								m.visible &&
									(0.5 !== m.alignment &&
										((C = m.width * (0.5 - (1 - m.alignment))),
										i.beginPath(),
										i.arc(w.x, w.y, w.radius + C, 0, 2 * Math.PI),
										i.closePath()),
									(i.globalAlpha = m.alpha * r),
									(i.strokeStyle = a),
									i.stroke());
						else if (d.type === SHAPES$3.ELIP) {
							if (
								((w = p),
								(Y = 1 === m.alignment) || this.paintEllipse(w, f, m, n, r, i),
								m.visible)
							) {
								if (0.5 !== m.alignment) {
									var $ = 0.5522848,
										N =
											((C = m.width * (0.5 - (1 - m.alignment))),
											2 * (w.width + C)),
										D = 2 * (w.height + C),
										L = w.x - N / 2,
										B = w.y - D / 2,
										F = (N / 2) * $,
										U = (D / 2) * $,
										G = L + N,
										k = B + D,
										W = L + N / 2,
										H = B + D / 2;
									i.beginPath(),
										i.moveTo(L, H),
										i.bezierCurveTo(L, H - U, W - F, B, W, B),
										i.bezierCurveTo(W + F, B, G, H - U, G, H),
										i.bezierCurveTo(G, H + U, W + F, k, W, k),
										i.bezierCurveTo(W - F, k, L, H + U, L, H),
										i.closePath();
								}
								(i.globalAlpha = m.alpha * r), (i.strokeStyle = a), i.stroke();
							}
							Y && this.paintEllipse(w, f, m, n, r, i);
						} else if (d.type === SHAPES$3.RREC) {
							var Y;
							if (
								((w = p),
								(Y = 1 === m.alignment) ||
									this.paintRoundedRectangle(w, f, m, n, r, i),
								m.visible)
							) {
								if (0.5 !== m.alignment) {
									(P = w.width),
										(O = w.height),
										(C = m.width * (0.5 - (1 - m.alignment)));
									var V = w.x - C,
										X = w.y - C,
										j = w.width + 2 * C,
										z = w.height + 2 * C,
										q =
											C *
											(m.alignment >= 1
												? Math.min(j / P, z / O)
												: Math.min(P / j, O / z)),
										K = w.radius + q,
										Z = Math.min(j, z) / 2;
									(K = K > Z ? Z : K),
										i.beginPath(),
										i.moveTo(V, X + K),
										i.lineTo(V, X + z - K),
										i.quadraticCurveTo(V, X + z, V + K, X + z),
										i.lineTo(V + j - K, X + z),
										i.quadraticCurveTo(V + j, X + z, V + j, X + z - K),
										i.lineTo(V + j, X + K),
										i.quadraticCurveTo(V + j, X, V + j - K, X),
										i.lineTo(V + K, X),
										i.quadraticCurveTo(V, X, V, X + K),
										i.closePath();
								}
								(i.globalAlpha = m.alpha * r), (i.strokeStyle = a), i.stroke();
							}
							Y && this.paintRoundedRectangle(w, f, m, n, r, i);
						}
					}
				}),
				(t.prototype.paintPolygonStroke = function (t, e, i, r, s, n, a) {
					if (0.5 !== e.alignment) {
						var o = e.width * (0.5 - (1 - e.alignment)),
							h = PolygonUtils.offsetPolygon(t.points, o),
							u = void 0;
						a.beginPath(), a.moveTo(h[0], h[1]);
						for (var l = 2; l < h.length; l += 2) a.lineTo(h[l], h[l + 1]);
						t.closeStroke && a.closePath();
						for (var c = 0; c < r.length; c++) {
							if (
								((u = r[c].shape.points),
								(h = PolygonUtils.offsetPolygon(u, o)),
								s[c])
							)
								for (a.moveTo(h[0], h[1]), l = 2; l < h.length; l += 2)
									a.lineTo(h[l], h[l + 1]);
							else
								for (
									a.moveTo(h[h.length - 2], h[h.length - 1]), l = h.length - 4;
									l >= 0;
									l -= 2
								)
									a.lineTo(h[l], h[l + 1]);
							r[c].shape.closeStroke && a.closePath();
						}
					}
					(a.globalAlpha = e.alpha * n), (a.strokeStyle = i), a.stroke();
				}),
				(t.prototype.paintEllipse = function (t, e, i, r, s, n) {
					var a = 2 * t.width,
						o = 2 * t.height,
						h = t.x - a / 2,
						u = t.y - o / 2,
						l = 0.5522848,
						c = (a / 2) * l,
						d = (o / 2) * l,
						p = h + a,
						f = u + o,
						m = h + a / 2,
						_ = u + o / 2;
					0 === i.alignment && n.save(),
						n.beginPath(),
						n.moveTo(h, _),
						n.bezierCurveTo(h, _ - d, m - c, u, m, u),
						n.bezierCurveTo(m + c, u, p, _ - d, p, _),
						n.bezierCurveTo(p, _ + d, m + c, f, m, f),
						n.bezierCurveTo(m - c, f, h, _ + d, h, _),
						n.closePath(),
						0 === i.alignment && n.clip(),
						e.visible &&
							((n.globalAlpha = e.alpha * s), (n.fillStyle = r), n.fill()),
						0 === i.alignment && n.restore();
				}),
				(t.prototype.paintRoundedRectangle = function (t, e, i, r, s, n) {
					var a = t.x,
						o = t.y,
						h = t.width,
						u = t.height,
						l = t.radius,
						c = Math.min(h, u) / 2;
					(l = l > c ? c : l),
						0 === i.alignment && n.save(),
						n.beginPath(),
						n.moveTo(a, o + l),
						n.lineTo(a, o + u - l),
						n.quadraticCurveTo(a, o + u, a + l, o + u),
						n.lineTo(a + h - l, o + u),
						n.quadraticCurveTo(a + h, o + u, a + h, o + u - l),
						n.lineTo(a + h, o + l),
						n.quadraticCurveTo(a + h, o, a + h - l, o),
						n.lineTo(a + l, o),
						n.quadraticCurveTo(a, o, a, o + l),
						n.closePath(),
						0 === i.alignment && n.clip(),
						e.visible &&
							((n.globalAlpha = e.alpha * s), (n.fillStyle = r), n.fill()),
						0 === i.alignment && n.restore();
				}),
				(t.prototype.setPatternTransform = function (t, e) {
					if (!1 !== this._svgMatrix) {
						if (!this._svgMatrix) {
							var i = document.createElementNS(
								'http://www.w3.org/2000/svg',
								'svg'
							);
							if (
								(i &&
									i.createSVGMatrix &&
									(this._svgMatrix = i.createSVGMatrix()),
								!this._svgMatrix || !t.setTransform)
							)
								return void (this._svgMatrix = !1);
						}
						(this._svgMatrix.a = e.a),
							(this._svgMatrix.b = e.b),
							(this._svgMatrix.c = e.c),
							(this._svgMatrix.d = e.d),
							(this._svgMatrix.e = e.tx),
							(this._svgMatrix.f = e.ty),
							t.setTransform(this._svgMatrix.inverse());
					}
				}),
				(t.prototype.destroy = function () {
					(this.renderer = null),
						(this._svgMatrix = null),
						(this._tempMatrix = null);
				}),
				t
			);
		})(),
		canvasRenderer,
		tempMatrix$5 = new Matrix$3();
	(Graphics$1.prototype.generateCanvasTexture = function (t, e) {
		void 0 === e && (e = 1);
		var i = this.getLocalBounds(),
			r = RenderTexture$3.create({
				width: i.width,
				height: i.height,
				scaleMode: t,
				resolution: e,
			});
		canvasRenderer || (canvasRenderer = new CanvasRenderer()),
			this.transform.updateLocalTransform(),
			this.transform.localTransform.copyTo(tempMatrix$5),
			tempMatrix$5.invert(),
			(tempMatrix$5.tx -= i.x),
			(tempMatrix$5.ty -= i.y),
			canvasRenderer.render(this, {
				renderTexture: r,
				clear: !0,
				transform: tempMatrix$5,
			});
		var s = Texture$3.from(r.baseTexture._canvasRenderTarget.canvas, {
			scaleMode: t,
		});
		return s.baseTexture.setResolution(e), s;
	}),
		(Graphics$1.prototype.cachedGraphicsData = []),
		(Graphics$1.prototype._renderCanvas = function (t) {
			!0 !== this.isMask &&
				(this.finishPoly(), t.plugins.graphics.render(this));
		});
	var global$1 =
			'undefined' != typeof global
				? global
				: 'undefined' != typeof self
				? self
				: 'undefined' != typeof window
				? window
				: {},
		commonjsGlobal =
			'undefined' != typeof globalThis
				? globalThis
				: 'undefined' != typeof window
				? window
				: void 0 !== global$1
				? global$1
				: 'undefined' != typeof self
				? self
				: {};
	function createCommonjsModule$1(t, e, i) {
		return (
			t(
				(i = {
					path: e,
					exports: {},
					require: function (t, e) {
						return commonjsRequire(t, null == e ? i.path : e);
					},
				}),
				i.exports
			),
			i.exports
		);
	}
	function commonjsRequire() {
		throw new Error(
			'Dynamic requires are not currently supported by @rollup/plugin-commonjs'
		);
	}
	var eventemitter3 = createCommonjsModule$1(function (t) {
			var e = Object.prototype.hasOwnProperty,
				i = '~';
			function r() {}
			function s(t, e, i) {
				(this.fn = t), (this.context = e), (this.once = i || !1);
			}
			function n(t, e, r, n, a) {
				if ('function' != typeof r)
					throw new TypeError('The listener must be a function');
				var o = new s(r, n || t, a),
					h = i ? i + e : e;
				return (
					t._events[h]
						? t._events[h].fn
							? (t._events[h] = [t._events[h], o])
							: t._events[h].push(o)
						: ((t._events[h] = o), t._eventsCount++),
					t
				);
			}
			function a(t, e) {
				0 == --t._eventsCount ? (t._events = new r()) : delete t._events[e];
			}
			function o() {
				(this._events = new r()), (this._eventsCount = 0);
			}
			Object.create &&
				((r.prototype = Object.create(null)), new r().__proto__ || (i = !1)),
				(o.prototype.eventNames = function () {
					var t,
						r,
						s = [];
					if (0 === this._eventsCount) return s;
					for (r in (t = this._events))
						e.call(t, r) && s.push(i ? r.slice(1) : r);
					return Object.getOwnPropertySymbols
						? s.concat(Object.getOwnPropertySymbols(t))
						: s;
				}),
				(o.prototype.listeners = function (t) {
					var e = i ? i + t : t,
						r = this._events[e];
					if (!r) return [];
					if (r.fn) return [r.fn];
					for (var s = 0, n = r.length, a = new Array(n); s < n; s++)
						a[s] = r[s].fn;
					return a;
				}),
				(o.prototype.listenerCount = function (t) {
					var e = i ? i + t : t,
						r = this._events[e];
					return r ? (r.fn ? 1 : r.length) : 0;
				}),
				(o.prototype.emit = function (t, e, r, s, n, a) {
					var o = arguments,
						h = i ? i + t : t;
					if (!this._events[h]) return !1;
					var u,
						l,
						c = this._events[h],
						d = arguments.length;
					if (c.fn) {
						switch ((c.once && this.removeListener(t, c.fn, void 0, !0), d)) {
							case 1:
								return c.fn.call(c.context), !0;
							case 2:
								return c.fn.call(c.context, e), !0;
							case 3:
								return c.fn.call(c.context, e, r), !0;
							case 4:
								return c.fn.call(c.context, e, r, s), !0;
							case 5:
								return c.fn.call(c.context, e, r, s, n), !0;
							case 6:
								return c.fn.call(c.context, e, r, s, n, a), !0;
						}
						for (l = 1, u = new Array(d - 1); l < d; l++) u[l - 1] = o[l];
						c.fn.apply(c.context, u);
					} else {
						var p,
							f = c.length;
						for (l = 0; l < f; l++)
							switch (
								(c[l].once && this.removeListener(t, c[l].fn, void 0, !0), d)
							) {
								case 1:
									c[l].fn.call(c[l].context);
									break;
								case 2:
									c[l].fn.call(c[l].context, e);
									break;
								case 3:
									c[l].fn.call(c[l].context, e, r);
									break;
								case 4:
									c[l].fn.call(c[l].context, e, r, s);
									break;
								default:
									if (!u)
										for (p = 1, u = new Array(d - 1); p < d; p++)
											u[p - 1] = o[p];
									c[l].fn.apply(c[l].context, u);
							}
					}
					return !0;
				}),
				(o.prototype.on = function (t, e, i) {
					return n(this, t, e, i, !1);
				}),
				(o.prototype.once = function (t, e, i) {
					return n(this, t, e, i, !0);
				}),
				(o.prototype.removeListener = function (t, e, r, s) {
					var n = i ? i + t : t;
					if (!this._events[n]) return this;
					if (!e) return a(this, n), this;
					var o = this._events[n];
					if (o.fn)
						o.fn !== e ||
							(s && !o.once) ||
							(r && o.context !== r) ||
							a(this, n);
					else {
						for (var h = 0, u = [], l = o.length; h < l; h++)
							(o[h].fn !== e ||
								(s && !o[h].once) ||
								(r && o[h].context !== r)) &&
								u.push(o[h]);
						u.length
							? (this._events[n] = 1 === u.length ? u[0] : u)
							: a(this, n);
					}
					return this;
				}),
				(o.prototype.removeAllListeners = function (t) {
					var e;
					return (
						t
							? ((e = i ? i + t : t), this._events[e] && a(this, e))
							: ((this._events = new r()), (this._eventsCount = 0)),
						this
					);
				}),
				(o.prototype.off = o.prototype.removeListener),
				(o.prototype.addListener = o.prototype.on),
				(o.prefixed = i),
				(o.EventEmitter = o),
				(t.exports = o);
		}),
		punycode = createCommonjsModule$1(function (t, e) {
			!(function (i) {
				var r = e && !e.nodeType && e,
					s = t && !t.nodeType && t,
					n = 'object' == typeof commonjsGlobal && commonjsGlobal;
				(n.global !== n && n.window !== n && n.self !== n) || (i = n);
				var a,
					o,
					h = 2147483647,
					u = 36,
					l = /^xn--/,
					c = /[^\x20-\x7E]/,
					d = /[\x2E\u3002\uFF0E\uFF61]/g,
					p = {
						overflow: 'Overflow: input needs wider integers to process',
						'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
						'invalid-input': 'Invalid input',
					},
					f = Math.floor,
					m = String.fromCharCode;
				function _(t) {
					throw RangeError(p[t]);
				}
				function g(t, e) {
					for (var i = t.length, r = []; i--; ) r[i] = e(t[i]);
					return r;
				}
				function E(t, e) {
					var i = t.split('@'),
						r = '';
					return (
						i.length > 1 && ((r = i[0] + '@'), (t = i[1])),
						r + g((t = t.replace(d, '.')).split('.'), e).join('.')
					);
				}
				function y(t) {
					for (var e, i, r = [], s = 0, n = t.length; s < n; )
						(e = t.charCodeAt(s++)) >= 55296 && e <= 56319 && s < n
							? 56320 == (64512 & (i = t.charCodeAt(s++)))
								? r.push(((1023 & e) << 10) + (1023 & i) + 65536)
								: (r.push(e), s--)
							: r.push(e);
					return r;
				}
				function T(t) {
					return g(t, function (t) {
						var e = '';
						return (
							t > 65535 &&
								((e += m((((t -= 65536) >>> 10) & 1023) | 55296)),
								(t = 56320 | (1023 & t))),
							e + m(t)
						);
					}).join('');
				}
				function v(t, e) {
					return t + 22 + 75 * (t < 26) - ((0 != e) << 5);
				}
				function S(t, e, i) {
					var r = 0;
					for (t = i ? f(t / 700) : t >> 1, t += f(t / e); t > 455; r += u)
						t = f(t / 35);
					return f(r + (36 * t) / (t + 38));
				}
				function x(t) {
					var e,
						i,
						r,
						s,
						n,
						a,
						o,
						l,
						c,
						d,
						p,
						m = [],
						g = t.length,
						E = 0,
						y = 128,
						v = 72;
					for ((i = t.lastIndexOf('-')) < 0 && (i = 0), r = 0; r < i; ++r)
						t.charCodeAt(r) >= 128 && _('not-basic'), m.push(t.charCodeAt(r));
					for (s = i > 0 ? i + 1 : 0; s < g; ) {
						for (
							n = E, a = 1, o = u;
							s >= g && _('invalid-input'),
								((l =
									(p = t.charCodeAt(s++)) - 48 < 10
										? p - 22
										: p - 65 < 26
										? p - 65
										: p - 97 < 26
										? p - 97
										: u) >= u ||
									l > f((h - E) / a)) &&
									_('overflow'),
								(E += l * a),
								!(l < (c = o <= v ? 1 : o >= v + 26 ? 26 : o - v));
							o += u
						)
							a > f(h / (d = u - c)) && _('overflow'), (a *= d);
						(v = S(E - n, (e = m.length + 1), 0 == n)),
							f(E / e) > h - y && _('overflow'),
							(y += f(E / e)),
							(E %= e),
							m.splice(E++, 0, y);
					}
					return T(m);
				}
				function b(t) {
					var e,
						i,
						r,
						s,
						n,
						a,
						o,
						l,
						c,
						d,
						p,
						g,
						E,
						T,
						x,
						b = [];
					for (g = (t = y(t)).length, e = 128, i = 0, n = 72, a = 0; a < g; ++a)
						(p = t[a]) < 128 && b.push(m(p));
					for (r = s = b.length, s && b.push('-'); r < g; ) {
						for (o = h, a = 0; a < g; ++a) (p = t[a]) >= e && p < o && (o = p);
						for (
							o - e > f((h - i) / (E = r + 1)) && _('overflow'),
								i += (o - e) * E,
								e = o,
								a = 0;
							a < g;
							++a
						)
							if (((p = t[a]) < e && ++i > h && _('overflow'), p == e)) {
								for (
									l = i, c = u;
									!(l < (d = c <= n ? 1 : c >= n + 26 ? 26 : c - n));
									c += u
								)
									(x = l - d),
										(T = u - d),
										b.push(m(v(d + (x % T), 0))),
										(l = f(x / T));
								b.push(m(v(l, 0))), (n = S(i, E, r == s)), (i = 0), ++r;
							}
						++i, ++e;
					}
					return b.join('');
				}
				if (
					((a = {
						version: '1.3.2',
						ucs2: { decode: y, encode: T },
						decode: x,
						encode: b,
						toASCII: function (t) {
							return E(t, function (t) {
								return c.test(t) ? 'xn--' + b(t) : t;
							});
						},
						toUnicode: function (t) {
							return E(t, function (t) {
								return l.test(t) ? x(t.slice(4).toLowerCase()) : t;
							});
						},
					}),
					r && s)
				)
					if (t.exports == r) s.exports = a;
					else for (o in a) a.hasOwnProperty(o) && (r[o] = a[o]);
				else i.punycode = a;
			})(commonjsGlobal);
		}),
		util = {
			isString: function (t) {
				return 'string' == typeof t;
			},
			isObject: function (t) {
				return 'object' == typeof t && null !== t;
			},
			isNull: function (t) {
				return null === t;
			},
			isNullOrUndefined: function (t) {
				return null == t;
			},
		};
	function hasOwnProperty(t, e) {
		return Object.prototype.hasOwnProperty.call(t, e);
	}
	var decode = function (t, e, i, r) {
			(e = e || '&'), (i = i || '=');
			var s = {};
			if ('string' != typeof t || 0 === t.length) return s;
			var n = /\+/g;
			t = t.split(e);
			var a = 1e3;
			r && 'number' == typeof r.maxKeys && (a = r.maxKeys);
			var o = t.length;
			a > 0 && o > a && (o = a);
			for (var h = 0; h < o; ++h) {
				var u,
					l,
					c,
					d,
					p = t[h].replace(n, '%20'),
					f = p.indexOf(i);
				f >= 0
					? ((u = p.substr(0, f)), (l = p.substr(f + 1)))
					: ((u = p), (l = '')),
					(c = decodeURIComponent(u)),
					(d = decodeURIComponent(l)),
					hasOwnProperty(s, c)
						? Array.isArray(s[c])
							? s[c].push(d)
							: (s[c] = [s[c], d])
						: (s[c] = d);
			}
			return s;
		},
		stringifyPrimitive = function (t) {
			switch (typeof t) {
				case 'string':
					return t;
				case 'boolean':
					return t ? 'true' : 'false';
				case 'number':
					return isFinite(t) ? t : '';
				default:
					return '';
			}
		},
		encode = function (t, e, i, r) {
			return (
				(e = e || '&'),
				(i = i || '='),
				null === t && (t = void 0),
				'object' == typeof t
					? Object.keys(t)
							.map(function (r) {
								var s = encodeURIComponent(stringifyPrimitive(r)) + i;
								return Array.isArray(t[r])
									? t[r]
											.map(function (t) {
												return s + encodeURIComponent(stringifyPrimitive(t));
											})
											.join(e)
									: s + encodeURIComponent(stringifyPrimitive(t[r]));
							})
							.join(e)
					: r
					? encodeURIComponent(stringifyPrimitive(r)) +
					  i +
					  encodeURIComponent(stringifyPrimitive(t))
					: ''
			);
		},
		querystring = createCommonjsModule$1(function (t, e) {
			(e.decode = e.parse = decode), (e.encode = e.stringify = encode);
		}),
		parse$2 = urlParse,
		resolve$2 = urlResolve,
		format$2 = urlFormat;
	function Url() {
		(this.protocol = null),
			(this.slashes = null),
			(this.auth = null),
			(this.host = null),
			(this.port = null),
			(this.hostname = null),
			(this.hash = null),
			(this.search = null),
			(this.query = null),
			(this.pathname = null),
			(this.path = null),
			(this.href = null);
	}
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
		portPattern = /:[0-9]*$/,
		simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
		delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
		unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
		autoEscape = ["'"].concat(unwise),
		nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
		hostEndingChars = ['/', '?', '#'],
		hostnameMaxLen = 255,
		hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
		hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
		unsafeProtocol = { javascript: !0, 'javascript:': !0 },
		hostlessProtocol = { javascript: !0, 'javascript:': !0 },
		slashedProtocol = {
			http: !0,
			https: !0,
			ftp: !0,
			gopher: !0,
			file: !0,
			'http:': !0,
			'https:': !0,
			'ftp:': !0,
			'gopher:': !0,
			'file:': !0,
		};
	function urlParse(t, e, i) {
		if (t && util.isObject(t) && t instanceof Url) return t;
		var r = new Url();
		return r.parse(t, e, i), r;
	}
	function urlFormat(t) {
		return (
			util.isString(t) && (t = urlParse(t)),
			t instanceof Url ? t.format() : Url.prototype.format.call(t)
		);
	}
	function urlResolve(t, e) {
		return urlParse(t, !1, !0).resolve(e);
	}
	(Url.prototype.parse = function (t, e, i) {
		if (!util.isString(t))
			throw new TypeError("Parameter 'url' must be a string, not " + typeof t);
		var r = t.indexOf('?'),
			s = -1 !== r && r < t.indexOf('#') ? '?' : '#',
			n = t.split(s);
		n[0] = n[0].replace(/\\/g, '/');
		var a = (t = n.join(s));
		if (((a = a.trim()), !i && 1 === t.split('#').length)) {
			var o = simplePathPattern.exec(a);
			if (o)
				return (
					(this.path = a),
					(this.href = a),
					(this.pathname = o[1]),
					o[2]
						? ((this.search = o[2]),
						  (this.query = e
								? querystring.parse(this.search.substr(1))
								: this.search.substr(1)))
						: e && ((this.search = ''), (this.query = {})),
					this
				);
		}
		var h = protocolPattern.exec(a);
		if (h) {
			var u = (h = h[0]).toLowerCase();
			(this.protocol = u), (a = a.substr(h.length));
		}
		if (i || h || a.match(/^\/\/[^@\/]+@[^@\/]+/)) {
			var l = '//' === a.substr(0, 2);
			!l ||
				(h && hostlessProtocol[h]) ||
				((a = a.substr(2)), (this.slashes = !0));
		}
		if (!hostlessProtocol[h] && (l || (h && !slashedProtocol[h]))) {
			for (var c, d, p = -1, f = 0; f < hostEndingChars.length; f++)
				-1 !== (m = a.indexOf(hostEndingChars[f])) &&
					(-1 === p || m < p) &&
					(p = m);
			for (
				-1 !== (d = -1 === p ? a.lastIndexOf('@') : a.lastIndexOf('@', p)) &&
					((c = a.slice(0, d)),
					(a = a.slice(d + 1)),
					(this.auth = decodeURIComponent(c))),
					p = -1,
					f = 0;
				f < nonHostChars.length;
				f++
			) {
				var m;
				-1 !== (m = a.indexOf(nonHostChars[f])) &&
					(-1 === p || m < p) &&
					(p = m);
			}
			-1 === p && (p = a.length),
				(this.host = a.slice(0, p)),
				(a = a.slice(p)),
				this.parseHost(),
				(this.hostname = this.hostname || '');
			var _ =
				'[' === this.hostname[0] &&
				']' === this.hostname[this.hostname.length - 1];
			if (!_)
				for (
					var g = this.hostname.split(/\./), E = ((f = 0), g.length);
					f < E;
					f++
				) {
					var y = g[f];
					if (y && !y.match(hostnamePartPattern)) {
						for (var T = '', v = 0, S = y.length; v < S; v++)
							y.charCodeAt(v) > 127 ? (T += 'x') : (T += y[v]);
						if (!T.match(hostnamePartPattern)) {
							var x = g.slice(0, f),
								b = g.slice(f + 1),
								A = y.match(hostnamePartStart);
							A && (x.push(A[1]), b.unshift(A[2])),
								b.length && (a = '/' + b.join('.') + a),
								(this.hostname = x.join('.'));
							break;
						}
					}
				}
			this.hostname.length > hostnameMaxLen
				? (this.hostname = '')
				: (this.hostname = this.hostname.toLowerCase()),
				_ || (this.hostname = punycode.toASCII(this.hostname));
			var R = this.port ? ':' + this.port : '',
				I = this.hostname || '';
			(this.host = I + R),
				(this.href += this.host),
				_ &&
					((this.hostname = this.hostname.substr(1, this.hostname.length - 2)),
					'/' !== a[0] && (a = '/' + a));
		}
		if (!unsafeProtocol[u])
			for (f = 0, E = autoEscape.length; f < E; f++) {
				var M = autoEscape[f];
				if (-1 !== a.indexOf(M)) {
					var w = encodeURIComponent(M);
					w === M && (w = escape(M)), (a = a.split(M).join(w));
				}
			}
		var C = a.indexOf('#');
		-1 !== C && ((this.hash = a.substr(C)), (a = a.slice(0, C)));
		var P = a.indexOf('?');
		if (
			(-1 !== P
				? ((this.search = a.substr(P)),
				  (this.query = a.substr(P + 1)),
				  e && (this.query = querystring.parse(this.query)),
				  (a = a.slice(0, P)))
				: e && ((this.search = ''), (this.query = {})),
			a && (this.pathname = a),
			slashedProtocol[u] &&
				this.hostname &&
				!this.pathname &&
				(this.pathname = '/'),
			this.pathname || this.search)
		) {
			R = this.pathname || '';
			var O = this.search || '';
			this.path = R + O;
		}
		return (this.href = this.format()), this;
	}),
		(Url.prototype.format = function () {
			var t = this.auth || '';
			t && ((t = (t = encodeURIComponent(t)).replace(/%3A/i, ':')), (t += '@'));
			var e = this.protocol || '',
				i = this.pathname || '',
				r = this.hash || '',
				s = !1,
				n = '';
			this.host
				? (s = t + this.host)
				: this.hostname &&
				  ((s =
						t +
						(-1 === this.hostname.indexOf(':')
							? this.hostname
							: '[' + this.hostname + ']')),
				  this.port && (s += ':' + this.port)),
				this.query &&
					util.isObject(this.query) &&
					Object.keys(this.query).length &&
					(n = querystring.stringify(this.query));
			var a = this.search || (n && '?' + n) || '';
			return (
				e && ':' !== e.substr(-1) && (e += ':'),
				this.slashes || ((!e || slashedProtocol[e]) && !1 !== s)
					? ((s = '//' + (s || '')), i && '/' !== i.charAt(0) && (i = '/' + i))
					: s || (s = ''),
				r && '#' !== r.charAt(0) && (r = '#' + r),
				a && '?' !== a.charAt(0) && (a = '?' + a),
				e +
					s +
					(i = i.replace(/[?#]/g, function (t) {
						return encodeURIComponent(t);
					})) +
					(a = a.replace('#', '%23')) +
					r
			);
		}),
		(Url.prototype.resolve = function (t) {
			return this.resolveObject(urlParse(t, !1, !0)).format();
		}),
		(Url.prototype.resolveObject = function (t) {
			if (util.isString(t)) {
				var e = new Url();
				e.parse(t, !1, !0), (t = e);
			}
			for (var i = new Url(), r = Object.keys(this), s = 0; s < r.length; s++) {
				var n = r[s];
				i[n] = this[n];
			}
			if (((i.hash = t.hash), '' === t.href)) return (i.href = i.format()), i;
			if (t.slashes && !t.protocol) {
				for (var a = Object.keys(t), o = 0; o < a.length; o++) {
					var h = a[o];
					'protocol' !== h && (i[h] = t[h]);
				}
				return (
					slashedProtocol[i.protocol] &&
						i.hostname &&
						!i.pathname &&
						(i.path = i.pathname = '/'),
					(i.href = i.format()),
					i
				);
			}
			if (t.protocol && t.protocol !== i.protocol) {
				if (!slashedProtocol[t.protocol]) {
					for (var u = Object.keys(t), l = 0; l < u.length; l++) {
						var c = u[l];
						i[c] = t[c];
					}
					return (i.href = i.format()), i;
				}
				if (((i.protocol = t.protocol), t.host || hostlessProtocol[t.protocol]))
					i.pathname = t.pathname;
				else {
					for (
						var d = (t.pathname || '').split('/');
						d.length && !(t.host = d.shift());

					);
					t.host || (t.host = ''),
						t.hostname || (t.hostname = ''),
						'' !== d[0] && d.unshift(''),
						d.length < 2 && d.unshift(''),
						(i.pathname = d.join('/'));
				}
				if (
					((i.search = t.search),
					(i.query = t.query),
					(i.host = t.host || ''),
					(i.auth = t.auth),
					(i.hostname = t.hostname || t.host),
					(i.port = t.port),
					i.pathname || i.search)
				) {
					var p = i.pathname || '',
						f = i.search || '';
					i.path = p + f;
				}
				return (i.slashes = i.slashes || t.slashes), (i.href = i.format()), i;
			}
			var m = i.pathname && '/' === i.pathname.charAt(0),
				_ = t.host || (t.pathname && '/' === t.pathname.charAt(0)),
				g = _ || m || (i.host && t.pathname),
				E = g,
				y = (i.pathname && i.pathname.split('/')) || [],
				T =
					((d = (t.pathname && t.pathname.split('/')) || []),
					i.protocol && !slashedProtocol[i.protocol]);
			if (
				(T &&
					((i.hostname = ''),
					(i.port = null),
					i.host && ('' === y[0] ? (y[0] = i.host) : y.unshift(i.host)),
					(i.host = ''),
					t.protocol &&
						((t.hostname = null),
						(t.port = null),
						t.host && ('' === d[0] ? (d[0] = t.host) : d.unshift(t.host)),
						(t.host = null)),
					(g = g && ('' === d[0] || '' === y[0]))),
				_)
			)
				(i.host = t.host || '' === t.host ? t.host : i.host),
					(i.hostname =
						t.hostname || '' === t.hostname ? t.hostname : i.hostname),
					(i.search = t.search),
					(i.query = t.query),
					(y = d);
			else if (d.length)
				y || (y = []),
					y.pop(),
					(y = y.concat(d)),
					(i.search = t.search),
					(i.query = t.query);
			else if (!util.isNullOrUndefined(t.search))
				return (
					T &&
						((i.hostname = i.host = y.shift()),
						(A = !!(i.host && i.host.indexOf('@') > 0) && i.host.split('@')) &&
							((i.auth = A.shift()), (i.host = i.hostname = A.shift()))),
					(i.search = t.search),
					(i.query = t.query),
					(util.isNull(i.pathname) && util.isNull(i.search)) ||
						(i.path =
							(i.pathname ? i.pathname : '') + (i.search ? i.search : '')),
					(i.href = i.format()),
					i
				);
			if (!y.length)
				return (
					(i.pathname = null),
					i.search ? (i.path = '/' + i.search) : (i.path = null),
					(i.href = i.format()),
					i
				);
			for (
				var v = y.slice(-1)[0],
					S =
						((i.host || t.host || y.length > 1) && ('.' === v || '..' === v)) ||
						'' === v,
					x = 0,
					b = y.length;
				b >= 0;
				b--
			)
				'.' === (v = y[b])
					? y.splice(b, 1)
					: '..' === v
					? (y.splice(b, 1), x++)
					: x && (y.splice(b, 1), x--);
			if (!g && !E) for (; x--; x) y.unshift('..');
			!g || '' === y[0] || (y[0] && '/' === y[0].charAt(0)) || y.unshift(''),
				S && '/' !== y.join('/').substr(-1) && y.push('');
			var A,
				R = '' === y[0] || (y[0] && '/' === y[0].charAt(0));
			return (
				T &&
					((i.hostname = i.host = R ? '' : y.length ? y.shift() : ''),
					(A = !!(i.host && i.host.indexOf('@') > 0) && i.host.split('@')) &&
						((i.auth = A.shift()), (i.host = i.hostname = A.shift()))),
				(g = g || (i.host && y.length)) && !R && y.unshift(''),
				y.length
					? (i.pathname = y.join('/'))
					: ((i.pathname = null), (i.path = null)),
				(util.isNull(i.pathname) && util.isNull(i.search)) ||
					(i.path =
						(i.pathname ? i.pathname : '') + (i.search ? i.search : '')),
				(i.auth = t.auth || i.auth),
				(i.slashes = i.slashes || t.slashes),
				(i.href = i.format()),
				i
			);
		}),
		(Url.prototype.parseHost = function () {
			var t = this.host,
				e = portPattern.exec(t);
			e &&
				(':' !== (e = e[0]) && (this.port = e.substr(1)),
				(t = t.substr(0, t.length - e.length))),
				t && (this.hostname = t);
		});
	/*!
	 * @pixi/utils - v6.4.2
	 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
	 *
	 * @pixi/utils is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 */
	var url = { parse: parse$2, format: format$2, resolve: resolve$2 };
	(settings$4.RETINA_PREFIX = /@([0-9\.]+)x/),
		(settings$4.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1);
	var saidHello$2 = !1,
		VERSION$2 = '6.4.2',
		supported$2;
	function sayHello$2(t) {
		var e;
		if (!saidHello$2) {
			if (navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
				var i = [
					'\n %c %c %c PixiJS ' +
						VERSION$2 +
						' - ✰ ' +
						t +
						' ✰  %c  %c  http://www.pixijs.com/  %c %c ♥%c♥%c♥ \n\n',
					'background: #ff66a5; padding:5px 0;',
					'background: #ff66a5; padding:5px 0;',
					'color: #ff66a5; background: #030307; padding:5px 0;',
					'background: #ff66a5; padding:5px 0;',
					'background: #ffc3dc; padding:5px 0;',
					'background: #ff66a5; padding:5px 0;',
					'color: #ff2424; background: #fff; padding:5px 0;',
					'color: #ff2424; background: #fff; padding:5px 0;',
					'color: #ff2424; background: #fff; padding:5px 0;',
				];
				(e = globalThis.console).log.apply(e, i);
			} else
				globalThis.console &&
					globalThis.console.log(
						'PixiJS ' + VERSION$2 + ' - ' + t + ' - http://www.pixijs.com/'
					);
			saidHello$2 = !0;
		}
	}
	function isWebGLSupported$2() {
		return (
			void 0 === supported$2 &&
				(supported$2 = (function () {
					var t = {
						stencil: !0,
						failIfMajorPerformanceCaveat:
							settings$4.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT,
					};
					try {
						if (!globalThis.WebGLRenderingContext) return !1;
						var e = document.createElement('canvas'),
							i =
								e.getContext('webgl', t) ||
								e.getContext('experimental-webgl', t),
							r = !(!i || !i.getContextAttributes().stencil);
						if (i) {
							var s = i.getExtension('WEBGL_lose_context');
							s && s.loseContext();
						}
						return (i = null), r;
					} catch (t) {
						return !1;
					}
				})()),
			supported$2
		);
	}
	function hex2rgb$2(t, e) {
		return (
			void 0 === e && (e = []),
			(e[0] = ((t >> 16) & 255) / 255),
			(e[1] = ((t >> 8) & 255) / 255),
			(e[2] = (255 & t) / 255),
			e
		);
	}
	function hex2string$2(t) {
		var e = t.toString(16);
		return '#' + ('000000'.substring(0, 6 - e.length) + e);
	}
	function mapPremultipliedBlendModes$2() {
		for (var t = [], e = [], i = 0; i < 32; i++) (t[i] = i), (e[i] = i);
		(t[BLEND_MODES$9.NORMAL_NPM] = BLEND_MODES$9.NORMAL),
			(t[BLEND_MODES$9.ADD_NPM] = BLEND_MODES$9.ADD),
			(t[BLEND_MODES$9.SCREEN_NPM] = BLEND_MODES$9.SCREEN),
			(e[BLEND_MODES$9.NORMAL] = BLEND_MODES$9.NORMAL_NPM),
			(e[BLEND_MODES$9.ADD] = BLEND_MODES$9.ADD_NPM),
			(e[BLEND_MODES$9.SCREEN] = BLEND_MODES$9.SCREEN_NPM);
		var r = [];
		return r.push(e), r.push(t), r;
	}
	var premultiplyBlendMode$2 = mapPremultipliedBlendModes$2();
	function premultiplyTint$2(t, e) {
		if (1 === e) return ((255 * e) << 24) + t;
		if (0 === e) return 0;
		var i = (t >> 16) & 255,
			r = (t >> 8) & 255,
			s = 255 & t;
		return (
			((255 * e) << 24) +
			((i = (i * e + 0.5) | 0) << 16) +
			((r = (r * e + 0.5) | 0) << 8) +
			((s * e + 0.5) | 0)
		);
	}
	function getBufferType$2(t) {
		if (4 === t.BYTES_PER_ELEMENT)
			return t instanceof Float32Array
				? 'Float32Array'
				: t instanceof Uint32Array
				? 'Uint32Array'
				: 'Int32Array';
		if (2 === t.BYTES_PER_ELEMENT) {
			if (t instanceof Uint16Array) return 'Uint16Array';
		} else if (1 === t.BYTES_PER_ELEMENT && t instanceof Uint8Array)
			return 'Uint8Array';
		return null;
	}
	function nextPow2$2(t) {
		return (
			(t += 0 === t ? 1 : 0),
			--t,
			(t |= t >>> 1),
			(t |= t >>> 2),
			(t |= t >>> 4),
			(t |= t >>> 8),
			1 + (t |= t >>> 16)
		);
	}
	function isPow2$2(t) {
		return !(t & (t - 1) || !t);
	}
	function log2$2(t) {
		var e = (t > 65535 ? 1 : 0) << 4,
			i = ((t >>>= e) > 255 ? 1 : 0) << 3;
		return (
			(e |= i),
			(e |= i = ((t >>>= i) > 15 ? 1 : 0) << 2),
			(e |= i = ((t >>>= i) > 3 ? 1 : 0) << 1) | ((t >>>= i) >> 1)
		);
	}
	function removeItems$2(t, e, i) {
		var r,
			s = t.length;
		if (!(e >= s || 0 === i)) {
			var n = s - (i = e + i > s ? s - e : i);
			for (r = e; r < n; ++r) t[r] = t[r + i];
			t.length = n;
		}
	}
	var nextUid$2 = 0;
	function uid$2() {
		return ++nextUid$2;
	}
	var warnings$2 = {};
	function deprecation$2(t, e, i) {
		if ((void 0 === i && (i = 3), !warnings$2[e])) {
			var r = new Error().stack;
			void 0 === r ||
				((r = r.split('\n').splice(i).join('\n')), console.groupCollapsed),
				(warnings$2[e] = !0);
		}
	}
	var ProgramCache$2 = {},
		TextureCache$2 = Object.create(null),
		BaseTextureCache$2 = Object.create(null),
		tempAnchor$2;
	function determineCrossOrigin$2(t, e) {
		if ((void 0 === e && (e = globalThis.location), 0 === t.indexOf('data:')))
			return '';
		(e = e || globalThis.location),
			tempAnchor$2 || (tempAnchor$2 = document.createElement('a')),
			(tempAnchor$2.href = t);
		var i = url.parse(tempAnchor$2.href),
			r = (!i.port && '' === e.port) || i.port === e.port;
		return i.hostname === e.hostname && r && i.protocol === e.protocol
			? ''
			: 'anonymous';
	}
	function getResolutionOfUrl$2(t, e) {
		var i = settings$4.RETINA_PREFIX.exec(t);
		return i ? parseFloat(i[1]) : void 0 !== e ? e : 1;
	}
	/*!
	 * @pixi/runner - v6.4.2
	 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
	 *
	 * @pixi/runner is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 */ !(function () {
		function t(t, e, i) {
			(this.canvas = document.createElement('canvas')),
				(this.context = this.canvas.getContext('2d')),
				(this.resolution = i || settings$4.RESOLUTION),
				this.resize(t, e);
		}
		(t.prototype.clear = function () {
			this.context.setTransform(1, 0, 0, 1, 0, 0),
				this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
		}),
			(t.prototype.resize = function (t, e) {
				(this.canvas.width = Math.round(t * this.resolution)),
					(this.canvas.height = Math.round(e * this.resolution));
			}),
			(t.prototype.destroy = function () {
				(this.context = null), (this.canvas = null);
			}),
			Object.defineProperty(t.prototype, 'width', {
				get: function () {
					return this.canvas.width;
				},
				set: function (t) {
					this.canvas.width = Math.round(t);
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(t.prototype, 'height', {
				get: function () {
					return this.canvas.height;
				},
				set: function (t) {
					this.canvas.height = Math.round(t);
				},
				enumerable: !1,
				configurable: !0,
			});
	})();
	var Runner$2 = (function () {
			function t(t) {
				(this.items = []), (this._name = t), (this._aliasCount = 0);
			}
			return (
				(t.prototype.emit = function (t, e, i, r, s, n, a, o) {
					if (arguments.length > 8) throw new Error('max arguments reached');
					var h = this,
						u = h.name,
						l = h.items;
					this._aliasCount++;
					for (var c = 0, d = l.length; c < d; c++)
						l[c][u](t, e, i, r, s, n, a, o);
					return l === this.items && this._aliasCount--, this;
				}),
				(t.prototype.ensureNonAliasedItems = function () {
					this._aliasCount > 0 &&
						this.items.length > 1 &&
						((this._aliasCount = 0), (this.items = this.items.slice(0)));
				}),
				(t.prototype.add = function (t) {
					return (
						t[this._name] &&
							(this.ensureNonAliasedItems(),
							this.remove(t),
							this.items.push(t)),
						this
					);
				}),
				(t.prototype.remove = function (t) {
					var e = this.items.indexOf(t);
					return (
						-1 !== e && (this.ensureNonAliasedItems(), this.items.splice(e, 1)),
						this
					);
				}),
				(t.prototype.contains = function (t) {
					return -1 !== this.items.indexOf(t);
				}),
				(t.prototype.removeAll = function () {
					return this.ensureNonAliasedItems(), (this.items.length = 0), this;
				}),
				(t.prototype.destroy = function () {
					this.removeAll(), (this.items = null), (this._name = null);
				}),
				Object.defineProperty(t.prototype, 'empty', {
					get: function () {
						return 0 === this.items.length;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'name', {
					get: function () {
						return this._name;
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			);
		})(),
		UPDATE_PRIORITY$2;
	Object.defineProperties(Runner$2.prototype, {
		dispatch: { value: Runner$2.prototype.emit },
		run: { value: Runner$2.prototype.emit },
	}),
		/*!
		 * @pixi/ticker - v6.4.2
		 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
		 *
		 * @pixi/ticker is licensed under the MIT License.
		 * http://www.opensource.org/licenses/mit-license
		 */
		(settings$4.TARGET_FPMS = 0.06),
		(function (t) {
			(t[(t.INTERACTION = 50)] = 'INTERACTION'),
				(t[(t.HIGH = 25)] = 'HIGH'),
				(t[(t.NORMAL = 0)] = 'NORMAL'),
				(t[(t.LOW = -25)] = 'LOW'),
				(t[(t.UTILITY = -50)] = 'UTILITY');
		})(UPDATE_PRIORITY$2 || (UPDATE_PRIORITY$2 = {}));
	var TickerListener$2 = (function () {
			function t(t, e, i, r) {
				void 0 === e && (e = null),
					void 0 === i && (i = 0),
					void 0 === r && (r = !1),
					(this.next = null),
					(this.previous = null),
					(this._destroyed = !1),
					(this.fn = t),
					(this.context = e),
					(this.priority = i),
					(this.once = r);
			}
			return (
				(t.prototype.match = function (t, e) {
					return (
						void 0 === e && (e = null), this.fn === t && this.context === e
					);
				}),
				(t.prototype.emit = function (t) {
					this.fn &&
						(this.context ? this.fn.call(this.context, t) : this.fn(t));
					var e = this.next;
					return (
						this.once && this.destroy(!0),
						this._destroyed && (this.next = null),
						e
					);
				}),
				(t.prototype.connect = function (t) {
					(this.previous = t),
						t.next && (t.next.previous = this),
						(this.next = t.next),
						(t.next = this);
				}),
				(t.prototype.destroy = function (t) {
					void 0 === t && (t = !1),
						(this._destroyed = !0),
						(this.fn = null),
						(this.context = null),
						this.previous && (this.previous.next = this.next),
						this.next && (this.next.previous = this.previous);
					var e = this.next;
					return (this.next = t ? null : e), (this.previous = null), e;
				}),
				t
			);
		})(),
		Ticker$2 = (function () {
			function t() {
				var t = this;
				(this.autoStart = !1),
					(this.deltaTime = 1),
					(this.lastTime = -1),
					(this.speed = 1),
					(this.started = !1),
					(this._requestId = null),
					(this._maxElapsedMS = 100),
					(this._minElapsedMS = 0),
					(this._protected = !1),
					(this._lastFrame = -1),
					(this._head = new TickerListener$2(null, null, 1 / 0)),
					(this.deltaMS = 1 / settings$4.TARGET_FPMS),
					(this.elapsedMS = 1 / settings$4.TARGET_FPMS),
					(this._tick = function (e) {
						(t._requestId = null),
							t.started &&
								(t.update(e),
								t.started &&
									null === t._requestId &&
									t._head.next &&
									(t._requestId = requestAnimationFrame(t._tick)));
					});
			}
			return (
				(t.prototype._requestIfNeeded = function () {
					null === this._requestId &&
						this._head.next &&
						((this.lastTime = performance.now()),
						(this._lastFrame = this.lastTime),
						(this._requestId = requestAnimationFrame(this._tick)));
				}),
				(t.prototype._cancelIfNeeded = function () {
					null !== this._requestId &&
						(cancelAnimationFrame(this._requestId), (this._requestId = null));
				}),
				(t.prototype._startIfPossible = function () {
					this.started
						? this._requestIfNeeded()
						: this.autoStart && this.start();
				}),
				(t.prototype.add = function (t, e, i) {
					return (
						void 0 === i && (i = UPDATE_PRIORITY$2.NORMAL),
						this._addListener(new TickerListener$2(t, e, i))
					);
				}),
				(t.prototype.addOnce = function (t, e, i) {
					return (
						void 0 === i && (i = UPDATE_PRIORITY$2.NORMAL),
						this._addListener(new TickerListener$2(t, e, i, !0))
					);
				}),
				(t.prototype._addListener = function (t) {
					var e = this._head.next,
						i = this._head;
					if (e) {
						for (; e; ) {
							if (t.priority > e.priority) {
								t.connect(i);
								break;
							}
							(i = e), (e = e.next);
						}
						t.previous || t.connect(i);
					} else t.connect(i);
					return this._startIfPossible(), this;
				}),
				(t.prototype.remove = function (t, e) {
					for (var i = this._head.next; i; )
						i = i.match(t, e) ? i.destroy() : i.next;
					return this._head.next || this._cancelIfNeeded(), this;
				}),
				Object.defineProperty(t.prototype, 'count', {
					get: function () {
						if (!this._head) return 0;
						for (var t = 0, e = this._head; (e = e.next); ) t++;
						return t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.start = function () {
					this.started || ((this.started = !0), this._requestIfNeeded());
				}),
				(t.prototype.stop = function () {
					this.started && ((this.started = !1), this._cancelIfNeeded());
				}),
				(t.prototype.destroy = function () {
					if (!this._protected) {
						this.stop();
						for (var t = this._head.next; t; ) t = t.destroy(!0);
						this._head.destroy(), (this._head = null);
					}
				}),
				(t.prototype.update = function (t) {
					var e;
					if ((void 0 === t && (t = performance.now()), t > this.lastTime)) {
						if (
							((e = this.elapsedMS = t - this.lastTime) > this._maxElapsedMS &&
								(e = this._maxElapsedMS),
							(e *= this.speed),
							this._minElapsedMS)
						) {
							var i = (t - this._lastFrame) | 0;
							if (i < this._minElapsedMS) return;
							this._lastFrame = t - (i % this._minElapsedMS);
						}
						(this.deltaMS = e),
							(this.deltaTime = this.deltaMS * settings$4.TARGET_FPMS);
						for (var r = this._head, s = r.next; s; )
							s = s.emit(this.deltaTime);
						r.next || this._cancelIfNeeded();
					} else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
					this.lastTime = t;
				}),
				Object.defineProperty(t.prototype, 'FPS', {
					get: function () {
						return 1e3 / this.elapsedMS;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'minFPS', {
					get: function () {
						return 1e3 / this._maxElapsedMS;
					},
					set: function (t) {
						var e = Math.min(this.maxFPS, t),
							i = Math.min(Math.max(0, e) / 1e3, settings$4.TARGET_FPMS);
						this._maxElapsedMS = 1 / i;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'maxFPS', {
					get: function () {
						return this._minElapsedMS
							? Math.round(1e3 / this._minElapsedMS)
							: 0;
					},
					set: function (t) {
						if (0 === t) this._minElapsedMS = 0;
						else {
							var e = Math.max(this.minFPS, t);
							this._minElapsedMS = 1 / (e / 1e3);
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t, 'shared', {
					get: function () {
						if (!t._shared) {
							var e = (t._shared = new t());
							(e.autoStart = !0), (e._protected = !0);
						}
						return t._shared;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t, 'system', {
					get: function () {
						if (!t._system) {
							var e = (t._system = new t());
							(e.autoStart = !0), (e._protected = !0);
						}
						return t._system;
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			);
		})(),
		PI_2$2 = 2 * Math.PI,
		SHAPES$2;
	!(function (t) {
		(t[(t.POLY = 0)] = 'POLY'),
			(t[(t.RECT = 1)] = 'RECT'),
			(t[(t.CIRC = 2)] = 'CIRC'),
			(t[(t.ELIP = 3)] = 'ELIP'),
			(t[(t.RREC = 4)] = 'RREC');
	})(SHAPES$2 || (SHAPES$2 = {}));
	var Point$3 = (function () {
			function t(t, e) {
				void 0 === t && (t = 0),
					void 0 === e && (e = 0),
					(this.x = 0),
					(this.y = 0),
					(this.x = t),
					(this.y = e);
			}
			return (
				(t.prototype.clone = function () {
					return new t(this.x, this.y);
				}),
				(t.prototype.copyFrom = function (t) {
					return this.set(t.x, t.y), this;
				}),
				(t.prototype.copyTo = function (t) {
					return t.set(this.x, this.y), t;
				}),
				(t.prototype.equals = function (t) {
					return t.x === this.x && t.y === this.y;
				}),
				(t.prototype.set = function (t, e) {
					return (
						void 0 === t && (t = 0),
						void 0 === e && (e = t),
						(this.x = t),
						(this.y = e),
						this
					);
				}),
				(t.prototype.toString = function () {
					return '[@pixi/math:Point x=' + this.x + ' y=' + this.y + ']';
				}),
				t
			);
		})(),
		tempPoints$1$1 = [
			new Point$3(),
			new Point$3(),
			new Point$3(),
			new Point$3(),
		],
		Rectangle$3 = (function () {
			function t(t, e, i, r) {
				void 0 === t && (t = 0),
					void 0 === e && (e = 0),
					void 0 === i && (i = 0),
					void 0 === r && (r = 0),
					(this.x = Number(t)),
					(this.y = Number(e)),
					(this.width = Number(i)),
					(this.height = Number(r)),
					(this.type = SHAPES$2.RECT);
			}
			return (
				Object.defineProperty(t.prototype, 'left', {
					get: function () {
						return this.x;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'right', {
					get: function () {
						return this.x + this.width;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'top', {
					get: function () {
						return this.y;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'bottom', {
					get: function () {
						return this.y + this.height;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t, 'EMPTY', {
					get: function () {
						return new t(0, 0, 0, 0);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.clone = function () {
					return new t(this.x, this.y, this.width, this.height);
				}),
				(t.prototype.copyFrom = function (t) {
					return (
						(this.x = t.x),
						(this.y = t.y),
						(this.width = t.width),
						(this.height = t.height),
						this
					);
				}),
				(t.prototype.copyTo = function (t) {
					return (
						(t.x = this.x),
						(t.y = this.y),
						(t.width = this.width),
						(t.height = this.height),
						t
					);
				}),
				(t.prototype.contains = function (t, e) {
					return (
						!(this.width <= 0 || this.height <= 0) &&
						t >= this.x &&
						t < this.x + this.width &&
						e >= this.y &&
						e < this.y + this.height
					);
				}),
				(t.prototype.intersects = function (t, e) {
					if (!e) {
						var i = this.x < t.x ? t.x : this.x;
						if ((this.right > t.right ? t.right : this.right) <= i) return !1;
						var r = this.y < t.y ? t.y : this.y;
						return (this.bottom > t.bottom ? t.bottom : this.bottom) > r;
					}
					var s = this.left,
						n = this.right,
						a = this.top,
						o = this.bottom;
					if (n <= s || o <= a) return !1;
					var h = tempPoints$1$1[0].set(t.left, t.top),
						u = tempPoints$1$1[1].set(t.left, t.bottom),
						l = tempPoints$1$1[2].set(t.right, t.top),
						c = tempPoints$1$1[3].set(t.right, t.bottom);
					if (l.x <= h.x || u.y <= h.y) return !1;
					var d = Math.sign(e.a * e.d - e.b * e.c);
					if (0 === d) return !1;
					if (
						(e.apply(h, h),
						e.apply(u, u),
						e.apply(l, l),
						e.apply(c, c),
						Math.max(h.x, u.x, l.x, c.x) <= s ||
							Math.min(h.x, u.x, l.x, c.x) >= n ||
							Math.max(h.y, u.y, l.y, c.y) <= a ||
							Math.min(h.y, u.y, l.y, c.y) >= o)
					)
						return !1;
					var p = d * (u.y - h.y),
						f = d * (h.x - u.x),
						m = p * s + f * a,
						_ = p * n + f * a,
						g = p * s + f * o,
						E = p * n + f * o;
					if (
						Math.max(m, _, g, E) <= p * h.x + f * h.y ||
						Math.min(m, _, g, E) >= p * c.x + f * c.y
					)
						return !1;
					var y = d * (h.y - l.y),
						T = d * (l.x - h.x),
						v = y * s + T * a,
						S = y * n + T * a,
						x = y * s + T * o,
						b = y * n + T * o;
					return !(
						Math.max(v, S, x, b) <= y * h.x + T * h.y ||
						Math.min(v, S, x, b) >= y * c.x + T * c.y
					);
				}),
				(t.prototype.pad = function (t, e) {
					return (
						void 0 === t && (t = 0),
						void 0 === e && (e = t),
						(this.x -= t),
						(this.y -= e),
						(this.width += 2 * t),
						(this.height += 2 * e),
						this
					);
				}),
				(t.prototype.fit = function (t) {
					var e = Math.max(this.x, t.x),
						i = Math.min(this.x + this.width, t.x + t.width),
						r = Math.max(this.y, t.y),
						s = Math.min(this.y + this.height, t.y + t.height);
					return (
						(this.x = e),
						(this.width = Math.max(i - e, 0)),
						(this.y = r),
						(this.height = Math.max(s - r, 0)),
						this
					);
				}),
				(t.prototype.ceil = function (t, e) {
					void 0 === t && (t = 1), void 0 === e && (e = 0.001);
					var i = Math.ceil((this.x + this.width - e) * t) / t,
						r = Math.ceil((this.y + this.height - e) * t) / t;
					return (
						(this.x = Math.floor((this.x + e) * t) / t),
						(this.y = Math.floor((this.y + e) * t) / t),
						(this.width = i - this.x),
						(this.height = r - this.y),
						this
					);
				}),
				(t.prototype.enlarge = function (t) {
					var e = Math.min(this.x, t.x),
						i = Math.max(this.x + this.width, t.x + t.width),
						r = Math.min(this.y, t.y),
						s = Math.max(this.y + this.height, t.y + t.height);
					return (
						(this.x = e),
						(this.width = i - e),
						(this.y = r),
						(this.height = s - r),
						this
					);
				}),
				(t.prototype.toString = function () {
					return (
						'[@pixi/math:Rectangle x=' +
						this.x +
						' y=' +
						this.y +
						' width=' +
						this.width +
						' height=' +
						this.height +
						']'
					);
				}),
				t
			);
		})(),
		ObservablePoint$2 = (function () {
			function t(t, e, i, r) {
				void 0 === i && (i = 0),
					void 0 === r && (r = 0),
					(this._x = i),
					(this._y = r),
					(this.cb = t),
					(this.scope = e);
			}
			return (
				(t.prototype.clone = function (e, i) {
					return (
						void 0 === e && (e = this.cb),
						void 0 === i && (i = this.scope),
						new t(e, i, this._x, this._y)
					);
				}),
				(t.prototype.set = function (t, e) {
					return (
						void 0 === t && (t = 0),
						void 0 === e && (e = t),
						(this._x === t && this._y === e) ||
							((this._x = t), (this._y = e), this.cb.call(this.scope)),
						this
					);
				}),
				(t.prototype.copyFrom = function (t) {
					return (
						(this._x === t.x && this._y === t.y) ||
							((this._x = t.x), (this._y = t.y), this.cb.call(this.scope)),
						this
					);
				}),
				(t.prototype.copyTo = function (t) {
					return t.set(this._x, this._y), t;
				}),
				(t.prototype.equals = function (t) {
					return t.x === this._x && t.y === this._y;
				}),
				(t.prototype.toString = function () {
					return (
						'[@pixi/math:ObservablePoint x=0 y=0 scope=' + this.scope + ']'
					);
				}),
				Object.defineProperty(t.prototype, 'x', {
					get: function () {
						return this._x;
					},
					set: function (t) {
						this._x !== t && ((this._x = t), this.cb.call(this.scope));
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'y', {
					get: function () {
						return this._y;
					},
					set: function (t) {
						this._y !== t && ((this._y = t), this.cb.call(this.scope));
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			);
		})(),
		Matrix$2 = (function () {
			function t(t, e, i, r, s, n) {
				void 0 === t && (t = 1),
					void 0 === e && (e = 0),
					void 0 === i && (i = 0),
					void 0 === r && (r = 1),
					void 0 === s && (s = 0),
					void 0 === n && (n = 0),
					(this.array = null),
					(this.a = t),
					(this.b = e),
					(this.c = i),
					(this.d = r),
					(this.tx = s),
					(this.ty = n);
			}
			return (
				(t.prototype.fromArray = function (t) {
					(this.a = t[0]),
						(this.b = t[1]),
						(this.c = t[3]),
						(this.d = t[4]),
						(this.tx = t[2]),
						(this.ty = t[5]);
				}),
				(t.prototype.set = function (t, e, i, r, s, n) {
					return (
						(this.a = t),
						(this.b = e),
						(this.c = i),
						(this.d = r),
						(this.tx = s),
						(this.ty = n),
						this
					);
				}),
				(t.prototype.toArray = function (t, e) {
					this.array || (this.array = new Float32Array(9));
					var i = e || this.array;
					return (
						t
							? ((i[0] = this.a),
							  (i[1] = this.b),
							  (i[2] = 0),
							  (i[3] = this.c),
							  (i[4] = this.d),
							  (i[5] = 0),
							  (i[6] = this.tx),
							  (i[7] = this.ty),
							  (i[8] = 1))
							: ((i[0] = this.a),
							  (i[1] = this.c),
							  (i[2] = this.tx),
							  (i[3] = this.b),
							  (i[4] = this.d),
							  (i[5] = this.ty),
							  (i[6] = 0),
							  (i[7] = 0),
							  (i[8] = 1)),
						i
					);
				}),
				(t.prototype.apply = function (t, e) {
					e = e || new Point$3();
					var i = t.x,
						r = t.y;
					return (
						(e.x = this.a * i + this.c * r + this.tx),
						(e.y = this.b * i + this.d * r + this.ty),
						e
					);
				}),
				(t.prototype.applyInverse = function (t, e) {
					e = e || new Point$3();
					var i = 1 / (this.a * this.d + this.c * -this.b),
						r = t.x,
						s = t.y;
					return (
						(e.x =
							this.d * i * r +
							-this.c * i * s +
							(this.ty * this.c - this.tx * this.d) * i),
						(e.y =
							this.a * i * s +
							-this.b * i * r +
							(-this.ty * this.a + this.tx * this.b) * i),
						e
					);
				}),
				(t.prototype.translate = function (t, e) {
					return (this.tx += t), (this.ty += e), this;
				}),
				(t.prototype.scale = function (t, e) {
					return (
						(this.a *= t),
						(this.d *= e),
						(this.c *= t),
						(this.b *= e),
						(this.tx *= t),
						(this.ty *= e),
						this
					);
				}),
				(t.prototype.rotate = function (t) {
					var e = Math.cos(t),
						i = Math.sin(t),
						r = this.a,
						s = this.c,
						n = this.tx;
					return (
						(this.a = r * e - this.b * i),
						(this.b = r * i + this.b * e),
						(this.c = s * e - this.d * i),
						(this.d = s * i + this.d * e),
						(this.tx = n * e - this.ty * i),
						(this.ty = n * i + this.ty * e),
						this
					);
				}),
				(t.prototype.append = function (t) {
					var e = this.a,
						i = this.b,
						r = this.c,
						s = this.d;
					return (
						(this.a = t.a * e + t.b * r),
						(this.b = t.a * i + t.b * s),
						(this.c = t.c * e + t.d * r),
						(this.d = t.c * i + t.d * s),
						(this.tx = t.tx * e + t.ty * r + this.tx),
						(this.ty = t.tx * i + t.ty * s + this.ty),
						this
					);
				}),
				(t.prototype.setTransform = function (t, e, i, r, s, n, a, o, h) {
					return (
						(this.a = Math.cos(a + h) * s),
						(this.b = Math.sin(a + h) * s),
						(this.c = -Math.sin(a - o) * n),
						(this.d = Math.cos(a - o) * n),
						(this.tx = t - (i * this.a + r * this.c)),
						(this.ty = e - (i * this.b + r * this.d)),
						this
					);
				}),
				(t.prototype.prepend = function (t) {
					var e = this.tx;
					if (1 !== t.a || 0 !== t.b || 0 !== t.c || 1 !== t.d) {
						var i = this.a,
							r = this.c;
						(this.a = i * t.a + this.b * t.c),
							(this.b = i * t.b + this.b * t.d),
							(this.c = r * t.a + this.d * t.c),
							(this.d = r * t.b + this.d * t.d);
					}
					return (
						(this.tx = e * t.a + this.ty * t.c + t.tx),
						(this.ty = e * t.b + this.ty * t.d + t.ty),
						this
					);
				}),
				(t.prototype.decompose = function (t) {
					var e = this.a,
						i = this.b,
						r = this.c,
						s = this.d,
						n = t.pivot,
						a = -Math.atan2(-r, s),
						o = Math.atan2(i, e),
						h = Math.abs(a + o);
					return (
						h < 1e-5 || Math.abs(PI_2$2 - h) < 1e-5
							? ((t.rotation = o), (t.skew.x = t.skew.y = 0))
							: ((t.rotation = 0), (t.skew.x = a), (t.skew.y = o)),
						(t.scale.x = Math.sqrt(e * e + i * i)),
						(t.scale.y = Math.sqrt(r * r + s * s)),
						(t.position.x = this.tx + (n.x * e + n.y * r)),
						(t.position.y = this.ty + (n.x * i + n.y * s)),
						t
					);
				}),
				(t.prototype.invert = function () {
					var t = this.a,
						e = this.b,
						i = this.c,
						r = this.d,
						s = this.tx,
						n = t * r - e * i;
					return (
						(this.a = r / n),
						(this.b = -e / n),
						(this.c = -i / n),
						(this.d = t / n),
						(this.tx = (i * this.ty - r * s) / n),
						(this.ty = -(t * this.ty - e * s) / n),
						this
					);
				}),
				(t.prototype.identity = function () {
					return (
						(this.a = 1),
						(this.b = 0),
						(this.c = 0),
						(this.d = 1),
						(this.tx = 0),
						(this.ty = 0),
						this
					);
				}),
				(t.prototype.clone = function () {
					var e = new t();
					return (
						(e.a = this.a),
						(e.b = this.b),
						(e.c = this.c),
						(e.d = this.d),
						(e.tx = this.tx),
						(e.ty = this.ty),
						e
					);
				}),
				(t.prototype.copyTo = function (t) {
					return (
						(t.a = this.a),
						(t.b = this.b),
						(t.c = this.c),
						(t.d = this.d),
						(t.tx = this.tx),
						(t.ty = this.ty),
						t
					);
				}),
				(t.prototype.copyFrom = function (t) {
					return (
						(this.a = t.a),
						(this.b = t.b),
						(this.c = t.c),
						(this.d = t.d),
						(this.tx = t.tx),
						(this.ty = t.ty),
						this
					);
				}),
				(t.prototype.toString = function () {
					return (
						'[@pixi/math:Matrix a=' +
						this.a +
						' b=' +
						this.b +
						' c=' +
						this.c +
						' d=' +
						this.d +
						' tx=' +
						this.tx +
						' ty=' +
						this.ty +
						']'
					);
				}),
				Object.defineProperty(t, 'IDENTITY', {
					get: function () {
						return new t();
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t, 'TEMP_MATRIX', {
					get: function () {
						return new t();
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			);
		})(),
		ux$2 = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1],
		uy$2 = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1],
		vx$2 = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1],
		vy$2 = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1],
		rotationCayley$2 = [],
		rotationMatrices$2 = [],
		signum$2 = Math.sign;
	function init$2() {
		for (var t = 0; t < 16; t++) {
			var e = [];
			rotationCayley$2.push(e);
			for (var i = 0; i < 16; i++)
				for (
					var r = signum$2(ux$2[t] * ux$2[i] + vx$2[t] * uy$2[i]),
						s = signum$2(uy$2[t] * ux$2[i] + vy$2[t] * uy$2[i]),
						n = signum$2(ux$2[t] * vx$2[i] + vx$2[t] * vy$2[i]),
						a = signum$2(uy$2[t] * vx$2[i] + vy$2[t] * vy$2[i]),
						o = 0;
					o < 16;
					o++
				)
					if (
						ux$2[o] === r &&
						uy$2[o] === s &&
						vx$2[o] === n &&
						vy$2[o] === a
					) {
						e.push(o);
						break;
					}
		}
		for (t = 0; t < 16; t++) {
			var h = new Matrix$2();
			h.set(ux$2[t], uy$2[t], vx$2[t], vy$2[t], 0, 0),
				rotationMatrices$2.push(h);
		}
	}
	init$2();
	var groupD8$2 = {
		E: 0,
		SE: 1,
		S: 2,
		SW: 3,
		W: 4,
		NW: 5,
		N: 6,
		NE: 7,
		MIRROR_VERTICAL: 8,
		MAIN_DIAGONAL: 10,
		MIRROR_HORIZONTAL: 12,
		REVERSE_DIAGONAL: 14,
		uX: function (t) {
			return ux$2[t];
		},
		uY: function (t) {
			return uy$2[t];
		},
		vX: function (t) {
			return vx$2[t];
		},
		vY: function (t) {
			return vy$2[t];
		},
		inv: function (t) {
			return 8 & t ? 15 & t : 7 & -t;
		},
		add: function (t, e) {
			return rotationCayley$2[t][e];
		},
		sub: function (t, e) {
			return rotationCayley$2[t][groupD8$2.inv(e)];
		},
		rotate180: function (t) {
			return 4 ^ t;
		},
		isVertical: function (t) {
			return 2 == (3 & t);
		},
		byDirection: function (t, e) {
			return 2 * Math.abs(t) <= Math.abs(e)
				? e >= 0
					? groupD8$2.S
					: groupD8$2.N
				: 2 * Math.abs(e) <= Math.abs(t)
				? t > 0
					? groupD8$2.E
					: groupD8$2.W
				: e > 0
				? t > 0
					? groupD8$2.SE
					: groupD8$2.SW
				: t > 0
				? groupD8$2.NE
				: groupD8$2.NW;
		},
		matrixAppendRotationInv: function (t, e, i, r) {
			void 0 === i && (i = 0), void 0 === r && (r = 0);
			var s = rotationMatrices$2[groupD8$2.inv(e)];
			(s.tx = i), (s.ty = r), t.append(s);
		},
	};
	!(function () {
		function t() {
			(this.worldTransform = new Matrix$2()),
				(this.localTransform = new Matrix$2()),
				(this.position = new ObservablePoint$2(this.onChange, this, 0, 0)),
				(this.scale = new ObservablePoint$2(this.onChange, this, 1, 1)),
				(this.pivot = new ObservablePoint$2(this.onChange, this, 0, 0)),
				(this.skew = new ObservablePoint$2(this.updateSkew, this, 0, 0)),
				(this._rotation = 0),
				(this._cx = 1),
				(this._sx = 0),
				(this._cy = 0),
				(this._sy = 1),
				(this._localID = 0),
				(this._currentLocalID = 0),
				(this._worldID = 0),
				(this._parentID = 0);
		}
		(t.prototype.onChange = function () {
			this._localID++;
		}),
			(t.prototype.updateSkew = function () {
				(this._cx = Math.cos(this._rotation + this.skew.y)),
					(this._sx = Math.sin(this._rotation + this.skew.y)),
					(this._cy = -Math.sin(this._rotation - this.skew.x)),
					(this._sy = Math.cos(this._rotation - this.skew.x)),
					this._localID++;
			}),
			(t.prototype.toString = function () {
				return (
					'[@pixi/math:Transform position=(' +
					this.position.x +
					', ' +
					this.position.y +
					') rotation=' +
					this.rotation +
					' scale=(' +
					this.scale.x +
					', ' +
					this.scale.y +
					') skew=(' +
					this.skew.x +
					', ' +
					this.skew.y +
					') ]'
				);
			}),
			(t.prototype.updateLocalTransform = function () {
				var t = this.localTransform;
				this._localID !== this._currentLocalID &&
					((t.a = this._cx * this.scale.x),
					(t.b = this._sx * this.scale.x),
					(t.c = this._cy * this.scale.y),
					(t.d = this._sy * this.scale.y),
					(t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c)),
					(t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d)),
					(this._currentLocalID = this._localID),
					(this._parentID = -1));
			}),
			(t.prototype.updateTransform = function (t) {
				var e = this.localTransform;
				if (
					(this._localID !== this._currentLocalID &&
						((e.a = this._cx * this.scale.x),
						(e.b = this._sx * this.scale.x),
						(e.c = this._cy * this.scale.y),
						(e.d = this._sy * this.scale.y),
						(e.tx =
							this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c)),
						(e.ty =
							this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d)),
						(this._currentLocalID = this._localID),
						(this._parentID = -1)),
					this._parentID !== t._worldID)
				) {
					var i = t.worldTransform,
						r = this.worldTransform;
					(r.a = e.a * i.a + e.b * i.c),
						(r.b = e.a * i.b + e.b * i.d),
						(r.c = e.c * i.a + e.d * i.c),
						(r.d = e.c * i.b + e.d * i.d),
						(r.tx = e.tx * i.a + e.ty * i.c + i.tx),
						(r.ty = e.tx * i.b + e.ty * i.d + i.ty),
						(this._parentID = t._worldID),
						this._worldID++;
				}
			}),
			(t.prototype.setFromMatrix = function (t) {
				t.decompose(this), this._localID++;
			}),
			Object.defineProperty(t.prototype, 'rotation', {
				get: function () {
					return this._rotation;
				},
				set: function (t) {
					this._rotation !== t && ((this._rotation = t), this.updateSkew());
				},
				enumerable: !1,
				configurable: !0,
			}),
			(t.IDENTITY = new t());
	})(),
		/*!
		 * @pixi/core - v6.4.2
		 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
		 *
		 * @pixi/core is licensed under the MIT License.
		 * http://www.opensource.org/licenses/mit-license
		 */
		(settings$4.PREFER_ENV = isMobile$3.any ? ENV$9.WEBGL : ENV$9.WEBGL2),
		(settings$4.STRICT_TEXTURE_CACHE = !1);
	var INSTALLED$2 = [];
	function autoDetectResource$2(t, e) {
		if (!t) return null;
		var i = '';
		if ('string' == typeof t) {
			var r = /\.(\w{3,4})(?:$|\?|#)/i.exec(t);
			r && (i = r[1].toLowerCase());
		}
		for (var s = INSTALLED$2.length - 1; s >= 0; --s) {
			var n = INSTALLED$2[s];
			if (n.test && n.test(t, i)) return new n(t, e);
		}
		throw new Error('Unrecognized source type to auto-detect Resource');
	}
	/*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */ var extendStatics$d =
		function (t, e) {
			return (extendStatics$d =
				Object.setPrototypeOf ||
				({ __proto__: [] } instanceof Array &&
					function (t, e) {
						t.__proto__ = e;
					}) ||
				function (t, e) {
					for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
				})(t, e);
		};
	function __extends$d(t, e) {
		function i() {
			this.constructor = t;
		}
		extendStatics$d(t, e),
			(t.prototype =
				null === e ? Object.create(e) : ((i.prototype = e.prototype), new i()));
	}
	var __assign$2 = function () {
		return (
			(__assign$2 =
				Object.assign ||
				function (t) {
					for (var e, i = arguments, r = 1, s = arguments.length; r < s; r++)
						for (var n in (e = i[r]))
							Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
					return t;
				}),
			__assign$2.apply(this, arguments)
		);
	};
	function __rest$2(t, e) {
		var i = {};
		for (var r in t)
			Object.prototype.hasOwnProperty.call(t, r) &&
				e.indexOf(r) < 0 &&
				(i[r] = t[r]);
		if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
			var s = 0;
			for (r = Object.getOwnPropertySymbols(t); s < r.length; s++)
				e.indexOf(r[s]) < 0 && (i[r[s]] = t[r[s]]);
		}
		return i;
	}
	var Resource$2 = (function () {
			function t(t, e) {
				void 0 === t && (t = 0),
					void 0 === e && (e = 0),
					(this._width = t),
					(this._height = e),
					(this.destroyed = !1),
					(this.internal = !1),
					(this.onResize = new Runner$2('setRealSize')),
					(this.onUpdate = new Runner$2('update')),
					(this.onError = new Runner$2('onError'));
			}
			return (
				(t.prototype.bind = function (t) {
					this.onResize.add(t),
						this.onUpdate.add(t),
						this.onError.add(t),
						(this._width || this._height) &&
							this.onResize.emit(this._width, this._height);
				}),
				(t.prototype.unbind = function (t) {
					this.onResize.remove(t),
						this.onUpdate.remove(t),
						this.onError.remove(t);
				}),
				(t.prototype.resize = function (t, e) {
					(t === this._width && e === this._height) ||
						((this._width = t), (this._height = e), this.onResize.emit(t, e));
				}),
				Object.defineProperty(t.prototype, 'valid', {
					get: function () {
						return !!this._width && !!this._height;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.update = function () {
					this.destroyed || this.onUpdate.emit();
				}),
				(t.prototype.load = function () {
					return Promise.resolve(this);
				}),
				Object.defineProperty(t.prototype, 'width', {
					get: function () {
						return this._width;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'height', {
					get: function () {
						return this._height;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.style = function (t, e, i) {
					return !1;
				}),
				(t.prototype.dispose = function () {}),
				(t.prototype.destroy = function () {
					this.destroyed ||
						((this.destroyed = !0),
						this.dispose(),
						this.onError.removeAll(),
						(this.onError = null),
						this.onResize.removeAll(),
						(this.onResize = null),
						this.onUpdate.removeAll(),
						(this.onUpdate = null));
				}),
				(t.test = function (t, e) {
					return !1;
				}),
				t
			);
		})(),
		BufferResource$2 = (function (t) {
			function e(e, i) {
				var r = this,
					s = i || {},
					n = s.width,
					a = s.height;
				if (!n || !a) throw new Error('BufferResource width or height invalid');
				return ((r = t.call(this, n, a) || this).data = e), r;
			}
			return (
				__extends$d(e, t),
				(e.prototype.upload = function (t, e, i) {
					var r = t.gl;
					r.pixelStorei(
						r.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
						e.alphaMode === ALPHA_MODES$9.UNPACK
					);
					var s = e.realWidth,
						n = e.realHeight;
					return (
						i.width === s && i.height === n
							? r.texSubImage2D(
									e.target,
									0,
									0,
									0,
									s,
									n,
									e.format,
									i.type,
									this.data
							  )
							: ((i.width = s),
							  (i.height = n),
							  r.texImage2D(
									e.target,
									0,
									i.internalFormat,
									s,
									n,
									0,
									e.format,
									i.type,
									this.data
							  )),
						!0
					);
				}),
				(e.prototype.dispose = function () {
					this.data = null;
				}),
				(e.test = function (t) {
					return (
						t instanceof Float32Array ||
						t instanceof Uint8Array ||
						t instanceof Uint32Array
					);
				}),
				e
			);
		})(Resource$2),
		defaultBufferOptions$2 = {
			scaleMode: SCALE_MODES$9.NEAREST,
			format: FORMATS$9.RGBA,
			alphaMode: ALPHA_MODES$9.NPM,
		},
		BaseTexture$2 = (function (t) {
			function e(e, i) {
				void 0 === e && (e = null), void 0 === i && (i = null);
				var r = t.call(this) || this,
					s = (i = i || {}).alphaMode,
					n = i.mipmap,
					a = i.anisotropicLevel,
					o = i.scaleMode,
					h = i.width,
					u = i.height,
					l = i.wrapMode,
					c = i.format,
					d = i.type,
					p = i.target,
					f = i.resolution,
					m = i.resourceOptions;
				return (
					!e ||
						e instanceof Resource$2 ||
						((e = autoDetectResource$2(e, m)).internal = !0),
					(r.resolution = f || settings$4.RESOLUTION),
					(r.width = Math.round((h || 0) * r.resolution) / r.resolution),
					(r.height = Math.round((u || 0) * r.resolution) / r.resolution),
					(r._mipmap = void 0 !== n ? n : settings$4.MIPMAP_TEXTURES),
					(r.anisotropicLevel =
						void 0 !== a ? a : settings$4.ANISOTROPIC_LEVEL),
					(r._wrapMode = l || settings$4.WRAP_MODE),
					(r._scaleMode = void 0 !== o ? o : settings$4.SCALE_MODE),
					(r.format = c || FORMATS$9.RGBA),
					(r.type = d || TYPES$9.UNSIGNED_BYTE),
					(r.target = p || TARGETS$9.TEXTURE_2D),
					(r.alphaMode = void 0 !== s ? s : ALPHA_MODES$9.UNPACK),
					(r.uid = uid$2()),
					(r.touched = 0),
					(r.isPowerOfTwo = !1),
					r._refreshPOT(),
					(r._glTextures = {}),
					(r.dirtyId = 0),
					(r.dirtyStyleId = 0),
					(r.cacheId = null),
					(r.valid = h > 0 && u > 0),
					(r.textureCacheIds = []),
					(r.destroyed = !1),
					(r.resource = null),
					(r._batchEnabled = 0),
					(r._batchLocation = 0),
					(r.parentTextureArray = null),
					r.setResource(e),
					r
				);
			}
			return (
				__extends$d(e, t),
				Object.defineProperty(e.prototype, 'realWidth', {
					get: function () {
						return Math.round(this.width * this.resolution);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'realHeight', {
					get: function () {
						return Math.round(this.height * this.resolution);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'mipmap', {
					get: function () {
						return this._mipmap;
					},
					set: function (t) {
						this._mipmap !== t && ((this._mipmap = t), this.dirtyStyleId++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'scaleMode', {
					get: function () {
						return this._scaleMode;
					},
					set: function (t) {
						this._scaleMode !== t &&
							((this._scaleMode = t), this.dirtyStyleId++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'wrapMode', {
					get: function () {
						return this._wrapMode;
					},
					set: function (t) {
						this._wrapMode !== t && ((this._wrapMode = t), this.dirtyStyleId++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.setStyle = function (t, e) {
					var i;
					return (
						void 0 !== t &&
							t !== this.scaleMode &&
							((this.scaleMode = t), (i = !0)),
						void 0 !== e && e !== this.mipmap && ((this.mipmap = e), (i = !0)),
						i && this.dirtyStyleId++,
						this
					);
				}),
				(e.prototype.setSize = function (t, e, i) {
					return (i = i || this.resolution), this.setRealSize(t * i, e * i, i);
				}),
				(e.prototype.setRealSize = function (t, e, i) {
					return (
						(this.resolution = i || this.resolution),
						(this.width = Math.round(t) / this.resolution),
						(this.height = Math.round(e) / this.resolution),
						this._refreshPOT(),
						this.update(),
						this
					);
				}),
				(e.prototype._refreshPOT = function () {
					this.isPowerOfTwo =
						isPow2$2(this.realWidth) && isPow2$2(this.realHeight);
				}),
				(e.prototype.setResolution = function (t) {
					var e = this.resolution;
					return (
						e === t ||
							((this.resolution = t),
							this.valid &&
								((this.width = Math.round(this.width * e) / t),
								(this.height = Math.round(this.height * e) / t),
								this.emit('update', this)),
							this._refreshPOT()),
						this
					);
				}),
				(e.prototype.setResource = function (t) {
					if (this.resource === t) return this;
					if (this.resource) throw new Error('Resource can be set only once');
					return t.bind(this), (this.resource = t), this;
				}),
				(e.prototype.update = function () {
					this.valid
						? (this.dirtyId++, this.dirtyStyleId++, this.emit('update', this))
						: this.width > 0 &&
						  this.height > 0 &&
						  ((this.valid = !0),
						  this.emit('loaded', this),
						  this.emit('update', this));
				}),
				(e.prototype.onError = function (t) {
					this.emit('error', this, t);
				}),
				(e.prototype.destroy = function () {
					this.resource &&
						(this.resource.unbind(this),
						this.resource.internal && this.resource.destroy(),
						(this.resource = null)),
						this.cacheId &&
							(delete BaseTextureCache$2[this.cacheId],
							delete TextureCache$2[this.cacheId],
							(this.cacheId = null)),
						this.dispose(),
						e.removeFromCache(this),
						(this.textureCacheIds = null),
						(this.destroyed = !0);
				}),
				(e.prototype.dispose = function () {
					this.emit('dispose', this);
				}),
				(e.prototype.castToBaseTexture = function () {
					return this;
				}),
				(e.from = function (t, i, r) {
					void 0 === r && (r = settings$4.STRICT_TEXTURE_CACHE);
					var s = 'string' == typeof t,
						n = null;
					if (s) n = t;
					else {
						if (!t._pixiId) {
							var a = (i && i.pixiIdPrefix) || 'pixiid';
							t._pixiId = a + '_' + uid$2();
						}
						n = t._pixiId;
					}
					var o = BaseTextureCache$2[n];
					if (s && r && !o)
						throw new Error(
							'The cacheId "' + n + '" does not exist in BaseTextureCache.'
						);
					return o || (((o = new e(t, i)).cacheId = n), e.addToCache(o, n)), o;
				}),
				(e.fromBuffer = function (t, i, r, s) {
					t = t || new Float32Array(i * r * 4);
					var n = new BufferResource$2(t, { width: i, height: r }),
						a =
							t instanceof Float32Array ? TYPES$9.FLOAT : TYPES$9.UNSIGNED_BYTE;
					return new e(
						n,
						Object.assign(
							defaultBufferOptions$2,
							s || { width: i, height: r, type: a }
						)
					);
				}),
				(e.addToCache = function (t, e) {
					e &&
						(-1 === t.textureCacheIds.indexOf(e) && t.textureCacheIds.push(e),
						BaseTextureCache$2[e],
						(BaseTextureCache$2[e] = t));
				}),
				(e.removeFromCache = function (t) {
					if ('string' == typeof t) {
						var e = BaseTextureCache$2[t];
						if (e) {
							var i = e.textureCacheIds.indexOf(t);
							return (
								i > -1 && e.textureCacheIds.splice(i, 1),
								delete BaseTextureCache$2[t],
								e
							);
						}
					} else if (t && t.textureCacheIds) {
						for (var r = 0; r < t.textureCacheIds.length; ++r)
							delete BaseTextureCache$2[t.textureCacheIds[r]];
						return (t.textureCacheIds.length = 0), t;
					}
					return null;
				}),
				(e._globalBatch = 0),
				e
			);
		})(eventemitter3),
		AbstractMultiResource$2 = (function (t) {
			function e(e, i) {
				var r = this,
					s = i || {},
					n = s.width,
					a = s.height;
				((r = t.call(this, n, a) || this).items = []), (r.itemDirtyIds = []);
				for (var o = 0; o < e; o++) {
					var h = new BaseTexture$2();
					r.items.push(h), r.itemDirtyIds.push(-2);
				}
				return (r.length = e), (r._load = null), (r.baseTexture = null), r;
			}
			return (
				__extends$d(e, t),
				(e.prototype.initFromArray = function (t, e) {
					for (var i = 0; i < this.length; i++)
						t[i] &&
							(t[i].castToBaseTexture
								? this.addBaseTextureAt(t[i].castToBaseTexture(), i)
								: t[i] instanceof Resource$2
								? this.addResourceAt(t[i], i)
								: this.addResourceAt(autoDetectResource$2(t[i], e), i));
				}),
				(e.prototype.dispose = function () {
					for (var t = 0, e = this.length; t < e; t++) this.items[t].destroy();
					(this.items = null), (this.itemDirtyIds = null), (this._load = null);
				}),
				(e.prototype.addResourceAt = function (t, e) {
					if (!this.items[e])
						throw new Error('Index ' + e + ' is out of bounds');
					return (
						t.valid && !this.valid && this.resize(t.width, t.height),
						this.items[e].setResource(t),
						this
					);
				}),
				(e.prototype.bind = function (e) {
					if (null !== this.baseTexture)
						throw new Error(
							'Only one base texture per TextureArray is allowed'
						);
					t.prototype.bind.call(this, e);
					for (var i = 0; i < this.length; i++)
						(this.items[i].parentTextureArray = e),
							this.items[i].on('update', e.update, e);
				}),
				(e.prototype.unbind = function (e) {
					t.prototype.unbind.call(this, e);
					for (var i = 0; i < this.length; i++)
						(this.items[i].parentTextureArray = null),
							this.items[i].off('update', e.update, e);
				}),
				(e.prototype.load = function () {
					var t = this;
					if (this._load) return this._load;
					var e = this.items
						.map(function (t) {
							return t.resource;
						})
						.filter(function (t) {
							return t;
						})
						.map(function (t) {
							return t.load();
						});
					return (
						(this._load = Promise.all(e).then(function () {
							var e = t.items[0],
								i = e.realWidth,
								r = e.realHeight;
							return t.resize(i, r), Promise.resolve(t);
						})),
						this._load
					);
				}),
				e
			);
		})(Resource$2),
		ArrayResource$2 = (function (t) {
			function e(e, i) {
				var r,
					s,
					n = this,
					a = i || {},
					o = a.width,
					h = a.height;
				return (
					Array.isArray(e) ? ((r = e), (s = e.length)) : (s = e),
					(n = t.call(this, s, { width: o, height: h }) || this),
					r && n.initFromArray(r, i),
					n
				);
			}
			return (
				__extends$d(e, t),
				(e.prototype.addBaseTextureAt = function (t, e) {
					if (!t.resource)
						throw new Error('ArrayResource does not support RenderTexture');
					return this.addResourceAt(t.resource, e), this;
				}),
				(e.prototype.bind = function (e) {
					t.prototype.bind.call(this, e),
						(e.target = TARGETS$9.TEXTURE_2D_ARRAY);
				}),
				(e.prototype.upload = function (t, e, i) {
					var r = this,
						s = r.length,
						n = r.itemDirtyIds,
						a = r.items,
						o = t.gl;
					i.dirtyId < 0 &&
						o.texImage3D(
							o.TEXTURE_2D_ARRAY,
							0,
							i.internalFormat,
							this._width,
							this._height,
							s,
							0,
							e.format,
							i.type,
							null
						);
					for (var h = 0; h < s; h++) {
						var u = a[h];
						n[h] < u.dirtyId &&
							((n[h] = u.dirtyId),
							u.valid &&
								o.texSubImage3D(
									o.TEXTURE_2D_ARRAY,
									0,
									0,
									0,
									h,
									u.resource.width,
									u.resource.height,
									1,
									e.format,
									i.type,
									u.resource.source
								));
					}
					return !0;
				}),
				e
			);
		})(AbstractMultiResource$2),
		BaseImageResource$2 = (function (t) {
			function e(e) {
				var i = this,
					r = e,
					s = r.naturalWidth || r.videoWidth || r.width,
					n = r.naturalHeight || r.videoHeight || r.height;
				return (
					((i = t.call(this, s, n) || this).source = e), (i.noSubImage = !1), i
				);
			}
			return (
				__extends$d(e, t),
				(e.crossOrigin = function (t, e, i) {
					void 0 === i && 0 !== e.indexOf('data:')
						? (t.crossOrigin = determineCrossOrigin$2(e))
						: !1 !== i &&
						  (t.crossOrigin = 'string' == typeof i ? i : 'anonymous');
				}),
				(e.prototype.upload = function (t, e, i, r) {
					var s = t.gl,
						n = e.realWidth,
						a = e.realHeight;
					if ((r = r || this.source) instanceof HTMLImageElement) {
						if (!r.complete || 0 === r.naturalWidth) return !1;
					} else if (r instanceof HTMLVideoElement && r.readyState <= 1)
						return !1;
					return (
						s.pixelStorei(
							s.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
							e.alphaMode === ALPHA_MODES$9.UNPACK
						),
						this.noSubImage ||
						e.target !== s.TEXTURE_2D ||
						i.width !== n ||
						i.height !== a
							? ((i.width = n),
							  (i.height = a),
							  s.texImage2D(
									e.target,
									0,
									i.internalFormat,
									e.format,
									i.type,
									r
							  ))
							: s.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, e.format, i.type, r),
						!0
					);
				}),
				(e.prototype.update = function () {
					if (!this.destroyed) {
						var e = this.source,
							i = e.naturalWidth || e.videoWidth || e.width,
							r = e.naturalHeight || e.videoHeight || e.height;
						this.resize(i, r), t.prototype.update.call(this);
					}
				}),
				(e.prototype.dispose = function () {
					this.source = null;
				}),
				e
			);
		})(Resource$2),
		CanvasResource$2 = (function (t) {
			function e(e) {
				return t.call(this, e) || this;
			}
			return (
				__extends$d(e, t),
				(e.test = function (t) {
					var e = globalThis.OffscreenCanvas;
					return (
						!!(e && t instanceof e) ||
						(globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement)
					);
				}),
				e
			);
		})(BaseImageResource$2),
		CubeResource$2 = (function (t) {
			function e(i, r) {
				var s = this,
					n = r || {},
					a = n.width,
					o = n.height,
					h = n.autoLoad,
					u = n.linkBaseTexture;
				if (i && i.length !== e.SIDES)
					throw new Error('Invalid length. Got ' + i.length + ', expected 6');
				s = t.call(this, 6, { width: a, height: o }) || this;
				for (var l = 0; l < e.SIDES; l++)
					s.items[l].target = TARGETS$9.TEXTURE_CUBE_MAP_POSITIVE_X + l;
				return (
					(s.linkBaseTexture = !1 !== u),
					i && s.initFromArray(i, r),
					!1 !== h && s.load(),
					s
				);
			}
			return (
				__extends$d(e, t),
				(e.prototype.bind = function (e) {
					t.prototype.bind.call(this, e),
						(e.target = TARGETS$9.TEXTURE_CUBE_MAP);
				}),
				(e.prototype.addBaseTextureAt = function (t, e, i) {
					if (!this.items[e])
						throw new Error('Index ' + e + ' is out of bounds');
					if (
						!this.linkBaseTexture ||
						t.parentTextureArray ||
						Object.keys(t._glTextures).length > 0
					) {
						if (!t.resource)
							throw new Error(
								'CubeResource does not support copying of renderTexture.'
							);
						this.addResourceAt(t.resource, e);
					} else
						(t.target = TARGETS$9.TEXTURE_CUBE_MAP_POSITIVE_X + e),
							(t.parentTextureArray = this.baseTexture),
							(this.items[e] = t);
					return (
						t.valid && !this.valid && this.resize(t.realWidth, t.realHeight),
						(this.items[e] = t),
						this
					);
				}),
				(e.prototype.upload = function (t, i, r) {
					for (var s = this.itemDirtyIds, n = 0; n < e.SIDES; n++) {
						var a = this.items[n];
						s[n] < a.dirtyId &&
							(a.valid && a.resource
								? (a.resource.upload(t, a, r), (s[n] = a.dirtyId))
								: s[n] < -1 &&
								  (t.gl.texImage2D(
										a.target,
										0,
										r.internalFormat,
										i.realWidth,
										i.realHeight,
										0,
										i.format,
										r.type,
										null
								  ),
								  (s[n] = -1)));
					}
					return !0;
				}),
				(e.test = function (t) {
					return Array.isArray(t) && t.length === e.SIDES;
				}),
				(e.SIDES = 6),
				e
			);
		})(AbstractMultiResource$2),
		ImageResource$2 = (function (t) {
			function e(e, i) {
				var r = this;
				if (((i = i || {}), !(e instanceof HTMLImageElement))) {
					var s = new Image();
					BaseImageResource$2.crossOrigin(s, e, i.crossorigin),
						(s.src = e),
						(e = s);
				}
				return (
					(r = t.call(this, e) || this),
					!e.complete &&
						r._width &&
						r._height &&
						((r._width = 0), (r._height = 0)),
					(r.url = e.src),
					(r._process = null),
					(r.preserveBitmap = !1),
					(r.createBitmap =
						(void 0 !== i.createBitmap
							? i.createBitmap
							: settings$4.CREATE_IMAGE_BITMAP) &&
						!!globalThis.createImageBitmap),
					(r.alphaMode = 'number' == typeof i.alphaMode ? i.alphaMode : null),
					(r.bitmap = null),
					(r._load = null),
					!1 !== i.autoLoad && r.load(),
					r
				);
			}
			return (
				__extends$d(e, t),
				(e.prototype.load = function (t) {
					var e = this;
					return (
						this._load ||
							(void 0 !== t && (this.createBitmap = t),
							(this._load = new Promise(function (t, i) {
								var r = e.source;
								e.url = r.src;
								var s = function () {
									e.destroyed ||
										((r.onload = null),
										(r.onerror = null),
										e.resize(r.width, r.height),
										(e._load = null),
										e.createBitmap ? t(e.process()) : t(e));
								};
								r.complete && r.src
									? s()
									: ((r.onload = s),
									  (r.onerror = function (t) {
											i(t), e.onError.emit(t);
									  }));
							}))),
						this._load
					);
				}),
				(e.prototype.process = function () {
					var t = this,
						e = this.source;
					if (null !== this._process) return this._process;
					if (null !== this.bitmap || !globalThis.createImageBitmap)
						return Promise.resolve(this);
					var i = globalThis.createImageBitmap,
						r = !e.crossOrigin || 'anonymous' === e.crossOrigin;
					return (
						(this._process = fetch(e.src, { mode: r ? 'cors' : 'no-cors' })
							.then(function (t) {
								return t.blob();
							})
							.then(function (r) {
								return i(r, 0, 0, e.width, e.height, {
									premultiplyAlpha:
										t.alphaMode === ALPHA_MODES$9.UNPACK
											? 'premultiply'
											: 'none',
								});
							})
							.then(function (e) {
								return t.destroyed
									? Promise.reject()
									: ((t.bitmap = e),
									  t.update(),
									  (t._process = null),
									  Promise.resolve(t));
							})),
						this._process
					);
				}),
				(e.prototype.upload = function (e, i, r) {
					if (
						('number' == typeof this.alphaMode &&
							(i.alphaMode = this.alphaMode),
						!this.createBitmap)
					)
						return t.prototype.upload.call(this, e, i, r);
					if (!this.bitmap && (this.process(), !this.bitmap)) return !1;
					if (
						(t.prototype.upload.call(this, e, i, r, this.bitmap),
						!this.preserveBitmap)
					) {
						var s = !0,
							n = i._glTextures;
						for (var a in n) {
							var o = n[a];
							if (o !== r && o.dirtyId !== i.dirtyId) {
								s = !1;
								break;
							}
						}
						s &&
							(this.bitmap.close && this.bitmap.close(), (this.bitmap = null));
					}
					return !0;
				}),
				(e.prototype.dispose = function () {
					(this.source.onload = null),
						(this.source.onerror = null),
						t.prototype.dispose.call(this),
						this.bitmap && (this.bitmap.close(), (this.bitmap = null)),
						(this._process = null),
						(this._load = null);
				}),
				(e.test = function (t) {
					return 'string' == typeof t || t instanceof HTMLImageElement;
				}),
				e
			);
		})(BaseImageResource$2),
		SVGResource$2 = (function (t) {
			function e(e, i) {
				var r = this;
				return (
					(i = i || {}),
					((r =
						t.call(this, document.createElement('canvas')) || this)._width = 0),
					(r._height = 0),
					(r.svg = e),
					(r.scale = i.scale || 1),
					(r._overrideWidth = i.width),
					(r._overrideHeight = i.height),
					(r._resolve = null),
					(r._crossorigin = i.crossorigin),
					(r._load = null),
					!1 !== i.autoLoad && r.load(),
					r
				);
			}
			return (
				__extends$d(e, t),
				(e.prototype.load = function () {
					var t = this;
					return (
						this._load ||
							(this._load = new Promise(function (i) {
								if (
									((t._resolve = function () {
										t.resize(t.source.width, t.source.height), i(t);
									}),
									e.SVG_XML.test(t.svg.trim()))
								) {
									if (!btoa)
										throw new Error(
											"Your browser doesn't support base64 conversions."
										);
									t.svg =
										'data:image/svg+xml;base64,' +
										btoa(unescape(encodeURIComponent(t.svg)));
								}
								t._loadSvg();
							})),
						this._load
					);
				}),
				(e.prototype._loadSvg = function () {
					var t = this,
						e = new Image();
					BaseImageResource$2.crossOrigin(e, this.svg, this._crossorigin),
						(e.src = this.svg),
						(e.onerror = function (i) {
							t._resolve && ((e.onerror = null), t.onError.emit(i));
						}),
						(e.onload = function () {
							if (t._resolve) {
								var i = e.width,
									r = e.height;
								if (!i || !r)
									throw new Error(
										'The SVG image must have width and height defined (in pixels), canvas API needs them.'
									);
								var s = i * t.scale,
									n = r * t.scale;
								(t._overrideWidth || t._overrideHeight) &&
									((s = t._overrideWidth || (t._overrideHeight / r) * i),
									(n = t._overrideHeight || (t._overrideWidth / i) * r)),
									(s = Math.round(s)),
									(n = Math.round(n));
								var a = t.source;
								(a.width = s),
									(a.height = n),
									(a._pixiId = 'canvas_' + uid$2()),
									a.getContext('2d').drawImage(e, 0, 0, i, r, 0, 0, s, n),
									t._resolve(),
									(t._resolve = null);
							}
						});
				}),
				(e.getSize = function (t) {
					var i = e.SVG_SIZE.exec(t),
						r = {};
					return (
						i &&
							((r[i[1]] = Math.round(parseFloat(i[3]))),
							(r[i[5]] = Math.round(parseFloat(i[7])))),
						r
					);
				}),
				(e.prototype.dispose = function () {
					t.prototype.dispose.call(this),
						(this._resolve = null),
						(this._crossorigin = null);
				}),
				(e.test = function (t, i) {
					return (
						'svg' === i ||
						('string' == typeof t &&
							/^data:image\/svg\+xml(;(charset=utf8|utf8))?;base64/.test(t)) ||
						('string' == typeof t && e.SVG_XML.test(t))
					);
				}),
				(e.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m),
				(e.SVG_SIZE =
					/<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i),
				e
			);
		})(BaseImageResource$2),
		VideoResource$2 = (function (t) {
			function e(i, r) {
				var s = this;
				if (((r = r || {}), !(i instanceof HTMLVideoElement))) {
					var n = document.createElement('video');
					n.setAttribute('preload', 'auto'),
						n.setAttribute('webkit-playsinline', ''),
						n.setAttribute('playsinline', ''),
						'string' == typeof i && (i = [i]);
					var a = i[0].src || i[0];
					BaseImageResource$2.crossOrigin(n, a, r.crossorigin);
					for (var o = 0; o < i.length; ++o) {
						var h = document.createElement('source'),
							u = i[o],
							l = u.src,
							c = u.mime,
							d = (l = l || i[o]).split('?').shift().toLowerCase(),
							p = d.slice(d.lastIndexOf('.') + 1);
						(c = c || e.MIME_TYPES[p] || 'video/' + p),
							(h.src = l),
							(h.type = c),
							n.appendChild(h);
					}
					i = n;
				}
				return (
					((s = t.call(this, i) || this).noSubImage = !0),
					(s._autoUpdate = !0),
					(s._isConnectedToTicker = !1),
					(s._updateFPS = r.updateFPS || 0),
					(s._msToNextUpdate = 0),
					(s.autoPlay = !1 !== r.autoPlay),
					(s._load = null),
					(s._resolve = null),
					(s._onCanPlay = s._onCanPlay.bind(s)),
					(s._onError = s._onError.bind(s)),
					!1 !== r.autoLoad && s.load(),
					s
				);
			}
			return (
				__extends$d(e, t),
				(e.prototype.update = function (e) {
					if (!this.destroyed) {
						var i = Ticker$2.shared.elapsedMS * this.source.playbackRate;
						(this._msToNextUpdate = Math.floor(this._msToNextUpdate - i)),
							(!this._updateFPS || this._msToNextUpdate <= 0) &&
								(t.prototype.update.call(this),
								(this._msToNextUpdate = this._updateFPS
									? Math.floor(1e3 / this._updateFPS)
									: 0));
					}
				}),
				(e.prototype.load = function () {
					var t = this;
					if (this._load) return this._load;
					var e = this.source;
					return (
						(e.readyState === e.HAVE_ENOUGH_DATA ||
							e.readyState === e.HAVE_FUTURE_DATA) &&
							e.width &&
							e.height &&
							(e.complete = !0),
						e.addEventListener('play', this._onPlayStart.bind(this)),
						e.addEventListener('pause', this._onPlayStop.bind(this)),
						this._isSourceReady()
							? this._onCanPlay()
							: (e.addEventListener('canplay', this._onCanPlay),
							  e.addEventListener('canplaythrough', this._onCanPlay),
							  e.addEventListener('error', this._onError, !0)),
						(this._load = new Promise(function (i) {
							t.valid ? i(t) : ((t._resolve = i), e.load());
						})),
						this._load
					);
				}),
				(e.prototype._onError = function (t) {
					this.source.removeEventListener('error', this._onError, !0),
						this.onError.emit(t);
				}),
				(e.prototype._isSourcePlaying = function () {
					var t = this.source;
					return (
						t.currentTime > 0 &&
						!1 === t.paused &&
						!1 === t.ended &&
						t.readyState > 2
					);
				}),
				(e.prototype._isSourceReady = function () {
					var t = this.source;
					return 3 === t.readyState || 4 === t.readyState;
				}),
				(e.prototype._onPlayStart = function () {
					this.valid || this._onCanPlay(),
						this.autoUpdate &&
							!this._isConnectedToTicker &&
							(Ticker$2.shared.add(this.update, this),
							(this._isConnectedToTicker = !0));
				}),
				(e.prototype._onPlayStop = function () {
					this._isConnectedToTicker &&
						(Ticker$2.shared.remove(this.update, this),
						(this._isConnectedToTicker = !1));
				}),
				(e.prototype._onCanPlay = function () {
					var t = this.source;
					t.removeEventListener('canplay', this._onCanPlay),
						t.removeEventListener('canplaythrough', this._onCanPlay);
					var e = this.valid;
					this.resize(t.videoWidth, t.videoHeight),
						!e &&
							this._resolve &&
							(this._resolve(this), (this._resolve = null)),
						this._isSourcePlaying()
							? this._onPlayStart()
							: this.autoPlay && t.play();
				}),
				(e.prototype.dispose = function () {
					this._isConnectedToTicker &&
						(Ticker$2.shared.remove(this.update, this),
						(this._isConnectedToTicker = !1));
					var e = this.source;
					e &&
						(e.removeEventListener('error', this._onError, !0),
						e.pause(),
						(e.src = ''),
						e.load()),
						t.prototype.dispose.call(this);
				}),
				Object.defineProperty(e.prototype, 'autoUpdate', {
					get: function () {
						return this._autoUpdate;
					},
					set: function (t) {
						t !== this._autoUpdate &&
							((this._autoUpdate = t),
							!this._autoUpdate && this._isConnectedToTicker
								? (Ticker$2.shared.remove(this.update, this),
								  (this._isConnectedToTicker = !1))
								: this._autoUpdate &&
								  !this._isConnectedToTicker &&
								  this._isSourcePlaying() &&
								  (Ticker$2.shared.add(this.update, this),
								  (this._isConnectedToTicker = !0)));
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'updateFPS', {
					get: function () {
						return this._updateFPS;
					},
					set: function (t) {
						t !== this._updateFPS && (this._updateFPS = t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.test = function (t, i) {
					return (
						(globalThis.HTMLVideoElement && t instanceof HTMLVideoElement) ||
						e.TYPES.indexOf(i) > -1
					);
				}),
				(e.TYPES = ['mp4', 'm4v', 'webm', 'ogg', 'ogv', 'h264', 'avi', 'mov']),
				(e.MIME_TYPES = {
					ogv: 'video/ogg',
					mov: 'video/quicktime',
					m4v: 'video/mp4',
				}),
				e
			);
		})(BaseImageResource$2),
		ImageBitmapResource$2 = (function (t) {
			function e(e) {
				return t.call(this, e) || this;
			}
			return (
				__extends$d(e, t),
				(e.test = function (t) {
					return !!globalThis.createImageBitmap && t instanceof ImageBitmap;
				}),
				e
			);
		})(BaseImageResource$2);
	INSTALLED$2.push(
		ImageResource$2,
		ImageBitmapResource$2,
		CanvasResource$2,
		VideoResource$2,
		SVGResource$2,
		BufferResource$2,
		CubeResource$2,
		ArrayResource$2
	);
	var DepthResource$2 = (function (t) {
			function e() {
				return (null !== t && t.apply(this, arguments)) || this;
			}
			return (
				__extends$d(e, t),
				(e.prototype.upload = function (t, e, i) {
					var r = t.gl;
					r.pixelStorei(
						r.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
						e.alphaMode === ALPHA_MODES$9.UNPACK
					);
					var s = e.realWidth,
						n = e.realHeight;
					return (
						i.width === s && i.height === n
							? r.texSubImage2D(
									e.target,
									0,
									0,
									0,
									s,
									n,
									e.format,
									i.type,
									this.data
							  )
							: ((i.width = s),
							  (i.height = n),
							  r.texImage2D(
									e.target,
									0,
									i.internalFormat,
									s,
									n,
									0,
									e.format,
									i.type,
									this.data
							  )),
						!0
					);
				}),
				e
			);
		})(BufferResource$2),
		Framebuffer$2 = (function () {
			function t(t, e) {
				(this.width = Math.round(t || 100)),
					(this.height = Math.round(e || 100)),
					(this.stencil = !1),
					(this.depth = !1),
					(this.dirtyId = 0),
					(this.dirtyFormat = 0),
					(this.dirtySize = 0),
					(this.depthTexture = null),
					(this.colorTextures = []),
					(this.glFramebuffers = {}),
					(this.disposeRunner = new Runner$2('disposeFramebuffer')),
					(this.multisample = MSAA_QUALITY$9.NONE);
			}
			return (
				Object.defineProperty(t.prototype, 'colorTexture', {
					get: function () {
						return this.colorTextures[0];
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.addColorTexture = function (t, e) {
					return (
						void 0 === t && (t = 0),
						(this.colorTextures[t] =
							e ||
							new BaseTexture$2(null, {
								scaleMode: SCALE_MODES$9.NEAREST,
								resolution: 1,
								mipmap: MIPMAP_MODES$9.OFF,
								width: this.width,
								height: this.height,
							})),
						this.dirtyId++,
						this.dirtyFormat++,
						this
					);
				}),
				(t.prototype.addDepthTexture = function (t) {
					return (
						(this.depthTexture =
							t ||
							new BaseTexture$2(
								new DepthResource$2(null, {
									width: this.width,
									height: this.height,
								}),
								{
									scaleMode: SCALE_MODES$9.NEAREST,
									resolution: 1,
									width: this.width,
									height: this.height,
									mipmap: MIPMAP_MODES$9.OFF,
									format: FORMATS$9.DEPTH_COMPONENT,
									type: TYPES$9.UNSIGNED_SHORT,
								}
							)),
						this.dirtyId++,
						this.dirtyFormat++,
						this
					);
				}),
				(t.prototype.enableDepth = function () {
					return (this.depth = !0), this.dirtyId++, this.dirtyFormat++, this;
				}),
				(t.prototype.enableStencil = function () {
					return (this.stencil = !0), this.dirtyId++, this.dirtyFormat++, this;
				}),
				(t.prototype.resize = function (t, e) {
					if (
						((t = Math.round(t)),
						(e = Math.round(e)),
						t !== this.width || e !== this.height)
					) {
						(this.width = t),
							(this.height = e),
							this.dirtyId++,
							this.dirtySize++;
						for (var i = 0; i < this.colorTextures.length; i++) {
							var r = this.colorTextures[i],
								s = r.resolution;
							r.setSize(t / s, e / s);
						}
						this.depthTexture &&
							((s = this.depthTexture.resolution),
							this.depthTexture.setSize(t / s, e / s));
					}
				}),
				(t.prototype.dispose = function () {
					this.disposeRunner.emit(this, !1);
				}),
				(t.prototype.destroyDepthTexture = function () {
					this.depthTexture &&
						(this.depthTexture.destroy(),
						(this.depthTexture = null),
						++this.dirtyId,
						++this.dirtyFormat);
				}),
				t
			);
		})(),
		BaseRenderTexture$2 = (function (t) {
			function e(e) {
				void 0 === e && (e = {});
				var i = this;
				if ('number' == typeof e) {
					var r = arguments[0],
						s = arguments[1],
						n = arguments[2],
						a = arguments[3];
					e = { width: r, height: s, scaleMode: n, resolution: a };
				}
				return (
					(e.width = e.width || 100),
					(e.height = e.height || 100),
					(e.multisample =
						void 0 !== e.multisample ? e.multisample : MSAA_QUALITY$9.NONE),
					((i = t.call(this, null, e) || this).mipmap = MIPMAP_MODES$9.OFF),
					(i.valid = !0),
					(i.clearColor = [0, 0, 0, 0]),
					(i.framebuffer = new Framebuffer$2(
						i.realWidth,
						i.realHeight
					).addColorTexture(0, i)),
					(i.framebuffer.multisample = e.multisample),
					(i.maskStack = []),
					(i.filterStack = [{}]),
					i
				);
			}
			return (
				__extends$d(e, t),
				(e.prototype.resize = function (t, e) {
					this.framebuffer.resize(t * this.resolution, e * this.resolution),
						this.setRealSize(this.framebuffer.width, this.framebuffer.height);
				}),
				(e.prototype.dispose = function () {
					this.framebuffer.dispose(), t.prototype.dispose.call(this);
				}),
				(e.prototype.destroy = function () {
					t.prototype.destroy.call(this),
						this.framebuffer.destroyDepthTexture(),
						(this.framebuffer = null);
				}),
				e
			);
		})(BaseTexture$2),
		TextureUvs$2 = (function () {
			function t() {
				(this.x0 = 0),
					(this.y0 = 0),
					(this.x1 = 1),
					(this.y1 = 0),
					(this.x2 = 1),
					(this.y2 = 1),
					(this.x3 = 0),
					(this.y3 = 1),
					(this.uvsFloat32 = new Float32Array(8));
			}
			return (
				(t.prototype.set = function (t, e, i) {
					var r = e.width,
						s = e.height;
					if (i) {
						var n = t.width / 2 / r,
							a = t.height / 2 / s,
							o = t.x / r + n,
							h = t.y / s + a;
						(i = groupD8$2.add(i, groupD8$2.NW)),
							(this.x0 = o + n * groupD8$2.uX(i)),
							(this.y0 = h + a * groupD8$2.uY(i)),
							(i = groupD8$2.add(i, 2)),
							(this.x1 = o + n * groupD8$2.uX(i)),
							(this.y1 = h + a * groupD8$2.uY(i)),
							(i = groupD8$2.add(i, 2)),
							(this.x2 = o + n * groupD8$2.uX(i)),
							(this.y2 = h + a * groupD8$2.uY(i)),
							(i = groupD8$2.add(i, 2)),
							(this.x3 = o + n * groupD8$2.uX(i)),
							(this.y3 = h + a * groupD8$2.uY(i));
					} else
						(this.x0 = t.x / r),
							(this.y0 = t.y / s),
							(this.x1 = (t.x + t.width) / r),
							(this.y1 = t.y / s),
							(this.x2 = (t.x + t.width) / r),
							(this.y2 = (t.y + t.height) / s),
							(this.x3 = t.x / r),
							(this.y3 = (t.y + t.height) / s);
					(this.uvsFloat32[0] = this.x0),
						(this.uvsFloat32[1] = this.y0),
						(this.uvsFloat32[2] = this.x1),
						(this.uvsFloat32[3] = this.y1),
						(this.uvsFloat32[4] = this.x2),
						(this.uvsFloat32[5] = this.y2),
						(this.uvsFloat32[6] = this.x3),
						(this.uvsFloat32[7] = this.y3);
				}),
				(t.prototype.toString = function () {
					return (
						'[@pixi/core:TextureUvs x0=' +
						this.x0 +
						' y0=' +
						this.y0 +
						' x1=' +
						this.x1 +
						' y1=' +
						this.y1 +
						' x2=' +
						this.x2 +
						' y2=' +
						this.y2 +
						' x3=' +
						this.x3 +
						' y3=' +
						this.y3 +
						']'
					);
				}),
				t
			);
		})(),
		DEFAULT_UVS$2 = new TextureUvs$2();
	function removeAllHandlers$2(t) {
		(t.destroy = function () {}),
			(t.on = function () {}),
			(t.once = function () {}),
			(t.emit = function () {});
	}
	var Texture$2 = (function (t) {
			function e(i, r, s, n, a, o) {
				var h = t.call(this) || this;
				if (
					((h.noFrame = !1),
					r || ((h.noFrame = !0), (r = new Rectangle$3(0, 0, 1, 1))),
					i instanceof e && (i = i.baseTexture),
					(h.baseTexture = i),
					(h._frame = r),
					(h.trim = n),
					(h.valid = !1),
					(h._uvs = DEFAULT_UVS$2),
					(h.uvMatrix = null),
					(h.orig = s || r),
					(h._rotate = Number(a || 0)),
					!0 === a)
				)
					h._rotate = 2;
				else if (h._rotate % 2 != 0)
					throw new Error(
						'attempt to use diamond-shaped UVs. If you are sure, set rotation manually'
					);
				return (
					(h.defaultAnchor = o ? new Point$3(o.x, o.y) : new Point$3(0, 0)),
					(h._updateID = 0),
					(h.textureCacheIds = []),
					i.valid
						? h.noFrame
							? i.valid && h.onBaseTextureUpdated(i)
							: (h.frame = r)
						: i.once('loaded', h.onBaseTextureUpdated, h),
					h.noFrame && i.on('update', h.onBaseTextureUpdated, h),
					h
				);
			}
			return (
				__extends$d(e, t),
				(e.prototype.update = function () {
					this.baseTexture.resource && this.baseTexture.resource.update();
				}),
				(e.prototype.onBaseTextureUpdated = function (t) {
					if (this.noFrame) {
						if (!this.baseTexture.valid) return;
						(this._frame.width = t.width),
							(this._frame.height = t.height),
							(this.valid = !0),
							this.updateUvs();
					} else this.frame = this._frame;
					this.emit('update', this);
				}),
				(e.prototype.destroy = function (t) {
					if (this.baseTexture) {
						if (t) {
							var i = this.baseTexture.resource;
							i && i.url && TextureCache$2[i.url] && e.removeFromCache(i.url),
								this.baseTexture.destroy();
						}
						this.baseTexture.off('loaded', this.onBaseTextureUpdated, this),
							this.baseTexture.off('update', this.onBaseTextureUpdated, this),
							(this.baseTexture = null);
					}
					(this._frame = null),
						(this._uvs = null),
						(this.trim = null),
						(this.orig = null),
						(this.valid = !1),
						e.removeFromCache(this),
						(this.textureCacheIds = null);
				}),
				(e.prototype.clone = function () {
					var t = this._frame.clone(),
						i = this._frame === this.orig ? t : this.orig.clone(),
						r = new e(
							this.baseTexture,
							!this.noFrame && t,
							i,
							this.trim && this.trim.clone(),
							this.rotate,
							this.defaultAnchor
						);
					return this.noFrame && (r._frame = t), r;
				}),
				(e.prototype.updateUvs = function () {
					this._uvs === DEFAULT_UVS$2 && (this._uvs = new TextureUvs$2()),
						this._uvs.set(this._frame, this.baseTexture, this.rotate),
						this._updateID++;
				}),
				(e.from = function (t, i, r) {
					void 0 === i && (i = {}),
						void 0 === r && (r = settings$4.STRICT_TEXTURE_CACHE);
					var s = 'string' == typeof t,
						n = null;
					if (s) n = t;
					else if (t instanceof BaseTexture$2) {
						if (!t.cacheId) {
							var a = (i && i.pixiIdPrefix) || 'pixiid';
							(t.cacheId = a + '-' + uid$2()),
								BaseTexture$2.addToCache(t, t.cacheId);
						}
						n = t.cacheId;
					} else
						t._pixiId ||
							((a = (i && i.pixiIdPrefix) || 'pixiid'),
							(t._pixiId = a + '_' + uid$2())),
							(n = t._pixiId);
					var o = TextureCache$2[n];
					if (s && r && !o)
						throw new Error(
							'The cacheId "' + n + '" does not exist in TextureCache.'
						);
					return (
						o || t instanceof BaseTexture$2
							? !o &&
							  t instanceof BaseTexture$2 &&
							  ((o = new e(t)), e.addToCache(o, n))
							: (i.resolution || (i.resolution = getResolutionOfUrl$2(t)),
							  ((o = new e(new BaseTexture$2(t, i))).baseTexture.cacheId = n),
							  BaseTexture$2.addToCache(o.baseTexture, n),
							  e.addToCache(o, n)),
						o
					);
				}),
				(e.fromURL = function (t, i) {
					var r = Object.assign(
							{ autoLoad: !1 },
							null == i ? void 0 : i.resourceOptions
						),
						s = e.from(t, Object.assign({ resourceOptions: r }, i), !1),
						n = s.baseTexture.resource;
					return s.baseTexture.valid
						? Promise.resolve(s)
						: n.load().then(function () {
								return Promise.resolve(s);
						  });
				}),
				(e.fromBuffer = function (t, i, r, s) {
					return new e(BaseTexture$2.fromBuffer(t, i, r, s));
				}),
				(e.fromLoader = function (t, i, r, s) {
					var n = new BaseTexture$2(
							t,
							Object.assign(
								{
									scaleMode: settings$4.SCALE_MODE,
									resolution: getResolutionOfUrl$2(i),
								},
								s
							)
						),
						a = n.resource;
					a instanceof ImageResource$2 && (a.url = i);
					var o = new e(n);
					return (
						r || (r = i),
						BaseTexture$2.addToCache(o.baseTexture, r),
						e.addToCache(o, r),
						r !== i &&
							(BaseTexture$2.addToCache(o.baseTexture, i), e.addToCache(o, i)),
						o.baseTexture.valid
							? Promise.resolve(o)
							: new Promise(function (t) {
									o.baseTexture.once('loaded', function () {
										return t(o);
									});
							  })
					);
				}),
				(e.addToCache = function (t, e) {
					e &&
						(-1 === t.textureCacheIds.indexOf(e) && t.textureCacheIds.push(e),
						TextureCache$2[e],
						(TextureCache$2[e] = t));
				}),
				(e.removeFromCache = function (t) {
					if ('string' == typeof t) {
						var e = TextureCache$2[t];
						if (e) {
							var i = e.textureCacheIds.indexOf(t);
							return (
								i > -1 && e.textureCacheIds.splice(i, 1),
								delete TextureCache$2[t],
								e
							);
						}
					} else if (t && t.textureCacheIds) {
						for (var r = 0; r < t.textureCacheIds.length; ++r)
							TextureCache$2[t.textureCacheIds[r]] === t &&
								delete TextureCache$2[t.textureCacheIds[r]];
						return (t.textureCacheIds.length = 0), t;
					}
					return null;
				}),
				Object.defineProperty(e.prototype, 'resolution', {
					get: function () {
						return this.baseTexture.resolution;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'frame', {
					get: function () {
						return this._frame;
					},
					set: function (t) {
						(this._frame = t), (this.noFrame = !1);
						var e = t.x,
							i = t.y,
							r = t.width,
							s = t.height,
							n = e + r > this.baseTexture.width,
							a = i + s > this.baseTexture.height;
						if (n || a) {
							var o = n && a ? 'and' : 'or',
								h =
									'X: ' +
									e +
									' + ' +
									r +
									' = ' +
									(e + r) +
									' > ' +
									this.baseTexture.width,
								u =
									'Y: ' +
									i +
									' + ' +
									s +
									' = ' +
									(i + s) +
									' > ' +
									this.baseTexture.height;
							throw new Error(
								'Texture Error: frame does not fit inside the base Texture dimensions: ' +
									h +
									' ' +
									o +
									' ' +
									u
							);
						}
						(this.valid = r && s && this.baseTexture.valid),
							this.trim || this.rotate || (this.orig = t),
							this.valid && this.updateUvs();
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'rotate', {
					get: function () {
						return this._rotate;
					},
					set: function (t) {
						(this._rotate = t), this.valid && this.updateUvs();
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'width', {
					get: function () {
						return this.orig.width;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'height', {
					get: function () {
						return this.orig.height;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.castToBaseTexture = function () {
					return this.baseTexture;
				}),
				Object.defineProperty(e, 'EMPTY', {
					get: function () {
						return (
							e._EMPTY ||
								((e._EMPTY = new e(new BaseTexture$2())),
								removeAllHandlers$2(e._EMPTY),
								removeAllHandlers$2(e._EMPTY.baseTexture)),
							e._EMPTY
						);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e, 'WHITE', {
					get: function () {
						if (!e._WHITE) {
							var t = document.createElement('canvas'),
								i = t.getContext('2d');
							(t.width = 16),
								(t.height = 16),
								(i.fillStyle = 'white'),
								i.fillRect(0, 0, 16, 16),
								(e._WHITE = new e(new BaseTexture$2(new CanvasResource$2(t)))),
								removeAllHandlers$2(e._WHITE),
								removeAllHandlers$2(e._WHITE.baseTexture);
						}
						return e._WHITE;
					},
					enumerable: !1,
					configurable: !0,
				}),
				e
			);
		})(eventemitter3),
		RenderTexture$2 = (function (t) {
			function e(e, i) {
				var r = t.call(this, e, i) || this;
				return (
					(r.valid = !0),
					(r.filterFrame = null),
					(r.filterPoolKey = null),
					r.updateUvs(),
					r
				);
			}
			return (
				__extends$d(e, t),
				Object.defineProperty(e.prototype, 'framebuffer', {
					get: function () {
						return this.baseTexture.framebuffer;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'multisample', {
					get: function () {
						return this.framebuffer.multisample;
					},
					set: function (t) {
						this.framebuffer.multisample = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.resize = function (t, e, i) {
					void 0 === i && (i = !0);
					var r = this.baseTexture.resolution,
						s = Math.round(t * r) / r,
						n = Math.round(e * r) / r;
					(this.valid = s > 0 && n > 0),
						(this._frame.width = this.orig.width = s),
						(this._frame.height = this.orig.height = n),
						i && this.baseTexture.resize(s, n),
						this.updateUvs();
				}),
				(e.prototype.setResolution = function (t) {
					var e = this.baseTexture;
					e.resolution !== t &&
						(e.setResolution(t), this.resize(e.width, e.height, !1));
				}),
				(e.create = function (t) {
					for (var i = arguments, r = [], s = 1; s < arguments.length; s++)
						r[s - 1] = i[s];
					return (
						'number' == typeof t &&
							(deprecation$2(
								'6.0.0',
								'Arguments (width, height, scaleMode, resolution) have been deprecated.'
							),
							(t = {
								width: t,
								height: r[0],
								scaleMode: r[1],
								resolution: r[2],
							})),
						new e(new BaseRenderTexture$2(t))
					);
				}),
				e
			);
		})(Texture$2),
		RenderTexturePool$2 = (function () {
			function t(t) {
				(this.texturePool = {}),
					(this.textureOptions = t || {}),
					(this.enableFullScreen = !1),
					(this._pixelsWidth = 0),
					(this._pixelsHeight = 0);
			}
			return (
				(t.prototype.createTexture = function (t, e, i) {
					void 0 === i && (i = MSAA_QUALITY$9.NONE);
					var r = new BaseRenderTexture$2(
						Object.assign(
							{ width: t, height: e, resolution: 1, multisample: i },
							this.textureOptions
						)
					);
					return new RenderTexture$2(r);
				}),
				(t.prototype.getOptimalTexture = function (t, e, i, r) {
					var s;
					void 0 === i && (i = 1),
						void 0 === r && (r = MSAA_QUALITY$9.NONE),
						(t = Math.ceil(t * i - 1e-6)),
						(e = Math.ceil(e * i - 1e-6)),
						this.enableFullScreen &&
						t === this._pixelsWidth &&
						e === this._pixelsHeight
							? (s = r > 1 ? -r : -1)
							: ((s =
									(((65535 & (t = nextPow2$2(t))) << 16) |
										(65535 & (e = nextPow2$2(e)))) >>>
									0),
							  r > 1 && (s += 4294967296 * r)),
						this.texturePool[s] || (this.texturePool[s] = []);
					var n = this.texturePool[s].pop();
					return (
						n || (n = this.createTexture(t, e, r)),
						(n.filterPoolKey = s),
						n.setResolution(i),
						n
					);
				}),
				(t.prototype.getFilterTexture = function (t, e, i) {
					var r = this.getOptimalTexture(
						t.width,
						t.height,
						e || t.resolution,
						i || MSAA_QUALITY$9.NONE
					);
					return (r.filterFrame = t.filterFrame), r;
				}),
				(t.prototype.returnTexture = function (t) {
					var e = t.filterPoolKey;
					(t.filterFrame = null), this.texturePool[e].push(t);
				}),
				(t.prototype.returnFilterTexture = function (t) {
					this.returnTexture(t);
				}),
				(t.prototype.clear = function (t) {
					if ((t = !1 !== t))
						for (var e in this.texturePool) {
							var i = this.texturePool[e];
							if (i) for (var r = 0; r < i.length; r++) i[r].destroy(!0);
						}
					this.texturePool = {};
				}),
				(t.prototype.setScreenSize = function (t) {
					if (
						t.width !== this._pixelsWidth ||
						t.height !== this._pixelsHeight
					) {
						for (var e in ((this.enableFullScreen =
							t.width > 0 && t.height > 0),
						this.texturePool))
							if (Number(e) < 0) {
								var i = this.texturePool[e];
								if (i) for (var r = 0; r < i.length; r++) i[r].destroy(!0);
								this.texturePool[e] = [];
							}
						(this._pixelsWidth = t.width), (this._pixelsHeight = t.height);
					}
				}),
				(t.SCREEN_KEY = -1),
				t
			);
		})(),
		Attribute$2 = (function () {
			function t(t, e, i, r, s, n, a) {
				void 0 === e && (e = 0),
					void 0 === i && (i = !1),
					void 0 === r && (r = TYPES$9.FLOAT),
					(this.buffer = t),
					(this.size = e),
					(this.normalized = i),
					(this.type = r),
					(this.stride = s),
					(this.start = n),
					(this.instance = a);
			}
			return (
				(t.prototype.destroy = function () {
					this.buffer = null;
				}),
				(t.from = function (e, i, r, s, n) {
					return new t(e, i, r, s, n);
				}),
				t
			);
		})(),
		UID$4$2 = 0,
		Buffer$2 = (function () {
			function t(t, e, i) {
				void 0 === e && (e = !0),
					void 0 === i && (i = !1),
					(this.data = t || new Float32Array(1)),
					(this._glBuffers = {}),
					(this._updateID = 0),
					(this.index = i),
					(this.static = e),
					(this.id = UID$4$2++),
					(this.disposeRunner = new Runner$2('disposeBuffer'));
			}
			return (
				(t.prototype.update = function (t) {
					t instanceof Array && (t = new Float32Array(t)),
						(this.data = t || this.data),
						this._updateID++;
				}),
				(t.prototype.dispose = function () {
					this.disposeRunner.emit(this, !1);
				}),
				(t.prototype.destroy = function () {
					this.dispose(), (this.data = null);
				}),
				Object.defineProperty(t.prototype, 'index', {
					get: function () {
						return this.type === BUFFER_TYPE$9.ELEMENT_ARRAY_BUFFER;
					},
					set: function (t) {
						this.type = t
							? BUFFER_TYPE$9.ELEMENT_ARRAY_BUFFER
							: BUFFER_TYPE$9.ARRAY_BUFFER;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.from = function (e) {
					return e instanceof Array && (e = new Float32Array(e)), new t(e);
				}),
				t
			);
		})(),
		map$1$2 = { Float32Array, Uint32Array, Int32Array, Uint8Array };
	function interleaveTypedArrays$2(t, e) {
		for (var i = 0, r = 0, s = {}, n = 0; n < t.length; n++)
			(r += e[n]), (i += t[n].length);
		var a = new ArrayBuffer(4 * i),
			o = null,
			h = 0;
		for (n = 0; n < t.length; n++) {
			var u = e[n],
				l = t[n],
				c = getBufferType$2(l);
			s[c] || (s[c] = new map$1$2[c](a)), (o = s[c]);
			for (var d = 0; d < l.length; d++)
				o[((d / u) | 0) * r + h + (d % u)] = l[d];
			h += u;
		}
		return new Float32Array(a);
	}
	var byteSizeMap$1$2 = { 5126: 4, 5123: 2, 5121: 1 },
		UID$3$2 = 0,
		map$3 = { Float32Array, Uint32Array, Int32Array, Uint8Array, Uint16Array },
		Geometry$2 = (function () {
			function t(t, e) {
				void 0 === t && (t = []),
					void 0 === e && (e = {}),
					(this.buffers = t),
					(this.indexBuffer = null),
					(this.attributes = e),
					(this.glVertexArrayObjects = {}),
					(this.id = UID$3$2++),
					(this.instanced = !1),
					(this.instanceCount = 1),
					(this.disposeRunner = new Runner$2('disposeGeometry')),
					(this.refCount = 0);
			}
			return (
				(t.prototype.addAttribute = function (t, e, i, r, s, n, a, o) {
					if (
						(void 0 === i && (i = 0),
						void 0 === r && (r = !1),
						void 0 === o && (o = !1),
						!e)
					)
						throw new Error(
							'You must pass a buffer when creating an attribute'
						);
					e instanceof Buffer$2 ||
						(e instanceof Array && (e = new Float32Array(e)),
						(e = new Buffer$2(e)));
					var h = t.split('|');
					if (h.length > 1) {
						for (var u = 0; u < h.length; u++)
							this.addAttribute(h[u], e, i, r, s);
						return this;
					}
					var l = this.buffers.indexOf(e);
					return (
						-1 === l && (this.buffers.push(e), (l = this.buffers.length - 1)),
						(this.attributes[t] = new Attribute$2(l, i, r, s, n, a, o)),
						(this.instanced = this.instanced || o),
						this
					);
				}),
				(t.prototype.getAttribute = function (t) {
					return this.attributes[t];
				}),
				(t.prototype.getBuffer = function (t) {
					return this.buffers[this.getAttribute(t).buffer];
				}),
				(t.prototype.addIndex = function (t) {
					return (
						t instanceof Buffer$2 ||
							(t instanceof Array && (t = new Uint16Array(t)),
							(t = new Buffer$2(t))),
						(t.type = BUFFER_TYPE$9.ELEMENT_ARRAY_BUFFER),
						(this.indexBuffer = t),
						-1 === this.buffers.indexOf(t) && this.buffers.push(t),
						this
					);
				}),
				(t.prototype.getIndex = function () {
					return this.indexBuffer;
				}),
				(t.prototype.interleave = function () {
					if (
						1 === this.buffers.length ||
						(2 === this.buffers.length && this.indexBuffer)
					)
						return this;
					var t,
						e = [],
						i = [],
						r = new Buffer$2();
					for (t in this.attributes) {
						var s = this.attributes[t],
							n = this.buffers[s.buffer];
						e.push(n.data),
							i.push((s.size * byteSizeMap$1$2[s.type]) / 4),
							(s.buffer = 0);
					}
					for (
						r.data = interleaveTypedArrays$2(e, i), t = 0;
						t < this.buffers.length;
						t++
					)
						this.buffers[t] !== this.indexBuffer && this.buffers[t].destroy();
					return (
						(this.buffers = [r]),
						this.indexBuffer && this.buffers.push(this.indexBuffer),
						this
					);
				}),
				(t.prototype.getSize = function () {
					for (var t in this.attributes) {
						var e = this.attributes[t];
						return (
							this.buffers[e.buffer].data.length / (e.stride / 4 || e.size)
						);
					}
					return 0;
				}),
				(t.prototype.dispose = function () {
					this.disposeRunner.emit(this, !1);
				}),
				(t.prototype.destroy = function () {
					this.dispose(),
						(this.buffers = null),
						(this.indexBuffer = null),
						(this.attributes = null);
				}),
				(t.prototype.clone = function () {
					for (var e = new t(), i = 0; i < this.buffers.length; i++)
						e.buffers[i] = new Buffer$2(this.buffers[i].data.slice(0));
					for (var i in this.attributes) {
						var r = this.attributes[i];
						e.attributes[i] = new Attribute$2(
							r.buffer,
							r.size,
							r.normalized,
							r.type,
							r.stride,
							r.start,
							r.instance
						);
					}
					return (
						this.indexBuffer &&
							((e.indexBuffer =
								e.buffers[this.buffers.indexOf(this.indexBuffer)]),
							(e.indexBuffer.type = BUFFER_TYPE$9.ELEMENT_ARRAY_BUFFER)),
						e
					);
				}),
				(t.merge = function (e) {
					for (
						var i, r = new t(), s = [], n = [], a = [], o = 0;
						o < e.length;
						o++
					) {
						i = e[o];
						for (var h = 0; h < i.buffers.length; h++)
							(n[h] = n[h] || 0),
								(n[h] += i.buffers[h].data.length),
								(a[h] = 0);
					}
					for (o = 0; o < i.buffers.length; o++)
						(s[o] = new map$3[getBufferType$2(i.buffers[o].data)](n[o])),
							(r.buffers[o] = new Buffer$2(s[o]));
					for (o = 0; o < e.length; o++)
						for (i = e[o], h = 0; h < i.buffers.length; h++)
							s[h].set(i.buffers[h].data, a[h]),
								(a[h] += i.buffers[h].data.length);
					if (((r.attributes = i.attributes), i.indexBuffer)) {
						(r.indexBuffer = r.buffers[i.buffers.indexOf(i.indexBuffer)]),
							(r.indexBuffer.type = BUFFER_TYPE$9.ELEMENT_ARRAY_BUFFER);
						var u = 0,
							l = 0,
							c = 0,
							d = 0;
						for (o = 0; o < i.buffers.length; o++)
							if (i.buffers[o] !== i.indexBuffer) {
								d = o;
								break;
							}
						for (var o in i.attributes) {
							var p = i.attributes[o];
							(0 | p.buffer) === d &&
								(l += (p.size * byteSizeMap$1$2[p.type]) / 4);
						}
						for (o = 0; o < e.length; o++) {
							var f = e[o].indexBuffer.data;
							for (h = 0; h < f.length; h++) r.indexBuffer.data[h + c] += u;
							(u += e[o].buffers[d].data.length / l), (c += f.length);
						}
					}
					return r;
				}),
				t
			);
		})(),
		Quad$2 = (function (t) {
			function e() {
				var e = t.call(this) || this;
				return (
					e
						.addAttribute(
							'aVertexPosition',
							new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])
						)
						.addIndex([0, 1, 3, 2]),
					e
				);
			}
			return __extends$d(e, t), e;
		})(Geometry$2),
		QuadUv$2 = (function (t) {
			function e() {
				var e = t.call(this) || this;
				return (
					(e.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1])),
					(e.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])),
					(e.vertexBuffer = new Buffer$2(e.vertices)),
					(e.uvBuffer = new Buffer$2(e.uvs)),
					e
						.addAttribute('aVertexPosition', e.vertexBuffer)
						.addAttribute('aTextureCoord', e.uvBuffer)
						.addIndex([0, 1, 2, 0, 2, 3]),
					e
				);
			}
			return (
				__extends$d(e, t),
				(e.prototype.map = function (t, e) {
					var i = 0,
						r = 0;
					return (
						(this.uvs[0] = i),
						(this.uvs[1] = r),
						(this.uvs[2] = i + e.width / t.width),
						(this.uvs[3] = r),
						(this.uvs[4] = i + e.width / t.width),
						(this.uvs[5] = r + e.height / t.height),
						(this.uvs[6] = i),
						(this.uvs[7] = r + e.height / t.height),
						(i = e.x),
						(r = e.y),
						(this.vertices[0] = i),
						(this.vertices[1] = r),
						(this.vertices[2] = i + e.width),
						(this.vertices[3] = r),
						(this.vertices[4] = i + e.width),
						(this.vertices[5] = r + e.height),
						(this.vertices[6] = i),
						(this.vertices[7] = r + e.height),
						this.invalidate(),
						this
					);
				}),
				(e.prototype.invalidate = function () {
					return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;
				}),
				e
			);
		})(Geometry$2),
		UID$2$2 = 0,
		UniformGroup$2 = (function () {
			function t(t, e, i) {
				(this.group = !0),
					(this.syncUniforms = {}),
					(this.dirtyId = 0),
					(this.id = UID$2$2++),
					(this.static = !!e),
					(this.ubo = !!i),
					t instanceof Buffer$2
						? ((this.buffer = t),
						  (this.buffer.type = BUFFER_TYPE$9.UNIFORM_BUFFER),
						  (this.autoManage = !1),
						  (this.ubo = !0))
						: ((this.uniforms = t),
						  this.ubo &&
								((this.buffer = new Buffer$2(new Float32Array(1))),
								(this.buffer.type = BUFFER_TYPE$9.UNIFORM_BUFFER),
								(this.autoManage = !0)));
			}
			return (
				(t.prototype.update = function () {
					this.dirtyId++,
						!this.autoManage && this.buffer && this.buffer.update();
				}),
				(t.prototype.add = function (e, i, r) {
					if (this.ubo)
						throw new Error(
							'[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them'
						);
					this.uniforms[e] = new t(i, r);
				}),
				(t.from = function (e, i, r) {
					return new t(e, i, r);
				}),
				(t.uboFrom = function (e, i) {
					return new t(e, null == i || i, !0);
				}),
				t
			);
		})(),
		FilterState$2 = (function () {
			function t() {
				(this.renderTexture = null),
					(this.target = null),
					(this.legacy = !1),
					(this.resolution = 1),
					(this.multisample = MSAA_QUALITY$9.NONE),
					(this.sourceFrame = new Rectangle$3()),
					(this.destinationFrame = new Rectangle$3()),
					(this.bindingSourceFrame = new Rectangle$3()),
					(this.bindingDestinationFrame = new Rectangle$3()),
					(this.filters = []),
					(this.transform = null);
			}
			return (
				(t.prototype.clear = function () {
					(this.target = null),
						(this.filters = null),
						(this.renderTexture = null);
				}),
				t
			);
		})(),
		tempPoints$2 = [new Point$3(), new Point$3(), new Point$3(), new Point$3()],
		tempMatrix$2$2 = new Matrix$2(),
		FilterSystem$2 = (function () {
			function t(t) {
				(this.renderer = t),
					(this.defaultFilterStack = [{}]),
					(this.texturePool = new RenderTexturePool$2()),
					this.texturePool.setScreenSize(t.view),
					(this.statePool = []),
					(this.quad = new Quad$2()),
					(this.quadUv = new QuadUv$2()),
					(this.tempRect = new Rectangle$3()),
					(this.activeState = {}),
					(this.globalUniforms = new UniformGroup$2(
						{
							outputFrame: new Rectangle$3(),
							inputSize: new Float32Array(4),
							inputPixel: new Float32Array(4),
							inputClamp: new Float32Array(4),
							resolution: 1,
							filterArea: new Float32Array(4),
							filterClamp: new Float32Array(4),
						},
						!0
					)),
					(this.forceClear = !1),
					(this.useMaxPadding = !1);
			}
			return (
				(t.prototype.push = function (t, e) {
					for (
						var i,
							r,
							s = this.renderer,
							n = this.defaultFilterStack,
							a = this.statePool.pop() || new FilterState$2(),
							o = this.renderer.renderTexture,
							h = e[0].resolution,
							u = e[0].multisample,
							l = e[0].padding,
							c = e[0].autoFit,
							d = null === (i = e[0].legacy) || void 0 === i || i,
							p = 1;
						p < e.length;
						p++
					) {
						var f = e[p];
						(h = Math.min(h, f.resolution)),
							(u = Math.min(u, f.multisample)),
							(l = this.useMaxPadding ? Math.max(l, f.padding) : l + f.padding),
							(c = c && f.autoFit),
							(d = d || null === (r = f.legacy) || void 0 === r || r);
					}
					1 === n.length &&
						(this.defaultFilterStack[0].renderTexture = o.current),
						n.push(a),
						(a.resolution = h),
						(a.multisample = u),
						(a.legacy = d),
						(a.target = t),
						a.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)),
						a.sourceFrame.pad(l);
					var m = this.tempRect.copyFrom(o.sourceFrame);
					s.projection.transform &&
						this.transformAABB(
							tempMatrix$2$2.copyFrom(s.projection.transform).invert(),
							m
						),
						c
							? (a.sourceFrame.fit(m),
							  (a.sourceFrame.width <= 0 || a.sourceFrame.height <= 0) &&
									((a.sourceFrame.width = 0), (a.sourceFrame.height = 0)))
							: a.sourceFrame.intersects(m) ||
							  ((a.sourceFrame.width = 0), (a.sourceFrame.height = 0)),
						this.roundFrame(
							a.sourceFrame,
							o.current ? o.current.resolution : s.resolution,
							o.sourceFrame,
							o.destinationFrame,
							s.projection.transform
						),
						(a.renderTexture = this.getOptimalFilterTexture(
							a.sourceFrame.width,
							a.sourceFrame.height,
							h,
							u
						)),
						(a.filters = e),
						(a.destinationFrame.width = a.renderTexture.width),
						(a.destinationFrame.height = a.renderTexture.height);
					var _ = this.tempRect;
					(_.x = 0),
						(_.y = 0),
						(_.width = a.sourceFrame.width),
						(_.height = a.sourceFrame.height),
						(a.renderTexture.filterFrame = a.sourceFrame),
						a.bindingSourceFrame.copyFrom(o.sourceFrame),
						a.bindingDestinationFrame.copyFrom(o.destinationFrame),
						(a.transform = s.projection.transform),
						(s.projection.transform = null),
						o.bind(a.renderTexture, a.sourceFrame, _),
						s.framebuffer.clear(0, 0, 0, 0);
				}),
				(t.prototype.pop = function () {
					var t = this.defaultFilterStack,
						e = t.pop(),
						i = e.filters;
					this.activeState = e;
					var r = this.globalUniforms.uniforms;
					(r.outputFrame = e.sourceFrame), (r.resolution = e.resolution);
					var s = r.inputSize,
						n = r.inputPixel,
						a = r.inputClamp;
					if (
						((s[0] = e.destinationFrame.width),
						(s[1] = e.destinationFrame.height),
						(s[2] = 1 / s[0]),
						(s[3] = 1 / s[1]),
						(n[0] = Math.round(s[0] * e.resolution)),
						(n[1] = Math.round(s[1] * e.resolution)),
						(n[2] = 1 / n[0]),
						(n[3] = 1 / n[1]),
						(a[0] = 0.5 * n[2]),
						(a[1] = 0.5 * n[3]),
						(a[2] = e.sourceFrame.width * s[2] - 0.5 * n[2]),
						(a[3] = e.sourceFrame.height * s[3] - 0.5 * n[3]),
						e.legacy)
					) {
						var o = r.filterArea;
						(o[0] = e.destinationFrame.width),
							(o[1] = e.destinationFrame.height),
							(o[2] = e.sourceFrame.x),
							(o[3] = e.sourceFrame.y),
							(r.filterClamp = r.inputClamp);
					}
					this.globalUniforms.update();
					var h = t[t.length - 1];
					if ((this.renderer.framebuffer.blit(), 1 === i.length))
						i[0].apply(
							this,
							e.renderTexture,
							h.renderTexture,
							CLEAR_MODES$9.BLEND,
							e
						),
							this.returnFilterTexture(e.renderTexture);
					else {
						var u = e.renderTexture,
							l = this.getOptimalFilterTexture(u.width, u.height, e.resolution);
						l.filterFrame = u.filterFrame;
						var c = 0;
						for (c = 0; c < i.length - 1; ++c) {
							1 === c &&
								e.multisample > 1 &&
								((l = this.getOptimalFilterTexture(
									u.width,
									u.height,
									e.resolution
								)).filterFrame = u.filterFrame),
								i[c].apply(this, u, l, CLEAR_MODES$9.CLEAR, e);
							var d = u;
							(u = l), (l = d);
						}
						i[c].apply(this, u, h.renderTexture, CLEAR_MODES$9.BLEND, e),
							c > 1 &&
								e.multisample > 1 &&
								this.returnFilterTexture(e.renderTexture),
							this.returnFilterTexture(u),
							this.returnFilterTexture(l);
					}
					e.clear(), this.statePool.push(e);
				}),
				(t.prototype.bindAndClear = function (t, e) {
					void 0 === e && (e = CLEAR_MODES$9.CLEAR);
					var i = this.renderer,
						r = i.renderTexture,
						s = i.state;
					if (
						(t ===
						this.defaultFilterStack[this.defaultFilterStack.length - 1]
							.renderTexture
							? (this.renderer.projection.transform =
									this.activeState.transform)
							: (this.renderer.projection.transform = null),
						t && t.filterFrame)
					) {
						var n = this.tempRect;
						(n.x = 0),
							(n.y = 0),
							(n.width = t.filterFrame.width),
							(n.height = t.filterFrame.height),
							r.bind(t, t.filterFrame, n);
					} else
						t !==
						this.defaultFilterStack[this.defaultFilterStack.length - 1]
							.renderTexture
							? r.bind(t)
							: this.renderer.renderTexture.bind(
									t,
									this.activeState.bindingSourceFrame,
									this.activeState.bindingDestinationFrame
							  );
					var a = 1 & s.stateId || this.forceClear;
					(e === CLEAR_MODES$9.CLEAR || (e === CLEAR_MODES$9.BLIT && a)) &&
						this.renderer.framebuffer.clear(0, 0, 0, 0);
				}),
				(t.prototype.applyFilter = function (t, e, i, r) {
					var s = this.renderer;
					s.state.set(t.state),
						this.bindAndClear(i, r),
						(t.uniforms.uSampler = e),
						(t.uniforms.filterGlobals = this.globalUniforms),
						s.shader.bind(t),
						(t.legacy = !!t.program.attributeData.aTextureCoord),
						t.legacy
							? (this.quadUv.map(e._frame, e.filterFrame),
							  s.geometry.bind(this.quadUv),
							  s.geometry.draw(DRAW_MODES$9.TRIANGLES))
							: (s.geometry.bind(this.quad),
							  s.geometry.draw(DRAW_MODES$9.TRIANGLE_STRIP));
				}),
				(t.prototype.calculateSpriteMatrix = function (t, e) {
					var i = this.activeState,
						r = i.sourceFrame,
						s = i.destinationFrame,
						n = e._texture.orig,
						a = t.set(s.width, 0, 0, s.height, r.x, r.y),
						o = e.worldTransform.copyTo(Matrix$2.TEMP_MATRIX);
					return (
						o.invert(),
						a.prepend(o),
						a.scale(1 / n.width, 1 / n.height),
						a.translate(e.anchor.x, e.anchor.y),
						a
					);
				}),
				(t.prototype.destroy = function () {
					(this.renderer = null), this.texturePool.clear(!1);
				}),
				(t.prototype.getOptimalFilterTexture = function (t, e, i, r) {
					return (
						void 0 === i && (i = 1),
						void 0 === r && (r = MSAA_QUALITY$9.NONE),
						this.texturePool.getOptimalTexture(t, e, i, r)
					);
				}),
				(t.prototype.getFilterTexture = function (t, e, i) {
					if ('number' == typeof t) {
						var r = t;
						(t = e), (e = r);
					}
					t = t || this.activeState.renderTexture;
					var s = this.texturePool.getOptimalTexture(
						t.width,
						t.height,
						e || t.resolution,
						i || MSAA_QUALITY$9.NONE
					);
					return (s.filterFrame = t.filterFrame), s;
				}),
				(t.prototype.returnFilterTexture = function (t) {
					this.texturePool.returnTexture(t);
				}),
				(t.prototype.emptyPool = function () {
					this.texturePool.clear(!0);
				}),
				(t.prototype.resize = function () {
					this.texturePool.setScreenSize(this.renderer.view);
				}),
				(t.prototype.transformAABB = function (t, e) {
					var i = tempPoints$2[0],
						r = tempPoints$2[1],
						s = tempPoints$2[2],
						n = tempPoints$2[3];
					i.set(e.left, e.top),
						r.set(e.left, e.bottom),
						s.set(e.right, e.top),
						n.set(e.right, e.bottom),
						t.apply(i, i),
						t.apply(r, r),
						t.apply(s, s),
						t.apply(n, n);
					var a = Math.min(i.x, r.x, s.x, n.x),
						o = Math.min(i.y, r.y, s.y, n.y),
						h = Math.max(i.x, r.x, s.x, n.x),
						u = Math.max(i.y, r.y, s.y, n.y);
					(e.x = a), (e.y = o), (e.width = h - a), (e.height = u - o);
				}),
				(t.prototype.roundFrame = function (t, e, i, r, s) {
					if (
						!(t.width <= 0 || t.height <= 0 || i.width <= 0 || i.height <= 0)
					) {
						if (s) {
							var n = s.a,
								a = s.b,
								o = s.c,
								h = s.d;
							if (
								(Math.abs(a) > 1e-4 || Math.abs(o) > 1e-4) &&
								(Math.abs(n) > 1e-4 || Math.abs(h) > 1e-4)
							)
								return;
						}
						(s = s ? tempMatrix$2$2.copyFrom(s) : tempMatrix$2$2.identity())
							.translate(-i.x, -i.y)
							.scale(r.width / i.width, r.height / i.height)
							.translate(r.x, r.y),
							this.transformAABB(s, t),
							t.ceil(e),
							this.transformAABB(s.invert(), t);
					}
				}),
				t
			);
		})(),
		ObjectRenderer$2 = (function () {
			function t(t) {
				this.renderer = t;
			}
			return (
				(t.prototype.flush = function () {}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				(t.prototype.start = function () {}),
				(t.prototype.stop = function () {
					this.flush();
				}),
				(t.prototype.render = function (t) {}),
				t
			);
		})(),
		BatchSystem$2 = (function () {
			function t(t) {
				(this.renderer = t),
					(this.emptyRenderer = new ObjectRenderer$2(t)),
					(this.currentRenderer = this.emptyRenderer);
			}
			return (
				(t.prototype.setObjectRenderer = function (t) {
					this.currentRenderer !== t &&
						(this.currentRenderer.stop(),
						(this.currentRenderer = t),
						this.currentRenderer.start());
				}),
				(t.prototype.flush = function () {
					this.setObjectRenderer(this.emptyRenderer);
				}),
				(t.prototype.reset = function () {
					this.setObjectRenderer(this.emptyRenderer);
				}),
				(t.prototype.copyBoundTextures = function (t, e) {
					for (
						var i = this.renderer.texture.boundTextures, r = e - 1;
						r >= 0;
						--r
					)
						(t[r] = i[r] || null), t[r] && (t[r]._batchLocation = r);
				}),
				(t.prototype.boundArray = function (t, e, i, r) {
					for (
						var s = t.elements, n = t.ids, a = t.count, o = 0, h = 0;
						h < a;
						h++
					) {
						var u = s[h],
							l = u._batchLocation;
						if (l >= 0 && l < r && e[l] === u) n[h] = l;
						else
							for (; o < r; ) {
								var c = e[o];
								if (!c || c._batchEnabled !== i || c._batchLocation !== o) {
									(n[h] = o), (u._batchLocation = o), (e[o] = u);
									break;
								}
								o++;
							}
					}
				}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})(),
		CONTEXT_UID_COUNTER$2 = 0,
		ContextSystem$2 = (function () {
			function t(t) {
				(this.renderer = t),
					(this.webGLVersion = 1),
					(this.extensions = {}),
					(this.supports = { uint32Indices: !1 }),
					(this.handleContextLost = this.handleContextLost.bind(this)),
					(this.handleContextRestored = this.handleContextRestored.bind(this)),
					t.view.addEventListener(
						'webglcontextlost',
						this.handleContextLost,
						!1
					),
					t.view.addEventListener(
						'webglcontextrestored',
						this.handleContextRestored,
						!1
					);
			}
			return (
				Object.defineProperty(t.prototype, 'isLost', {
					get: function () {
						return !this.gl || this.gl.isContextLost();
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.contextChange = function (t) {
					(this.gl = t),
						(this.renderer.gl = t),
						(this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER$2++),
						t.isContextLost() &&
							t.getExtension('WEBGL_lose_context') &&
							t.getExtension('WEBGL_lose_context').restoreContext();
				}),
				(t.prototype.initFromContext = function (t) {
					(this.gl = t),
						this.validateContext(t),
						(this.renderer.gl = t),
						(this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER$2++),
						this.renderer.runners.contextChange.emit(t);
				}),
				(t.prototype.initFromOptions = function (t) {
					var e = this.createContext(this.renderer.view, t);
					this.initFromContext(e);
				}),
				(t.prototype.createContext = function (t, e) {
					var i;
					if (
						(settings$4.PREFER_ENV >= ENV$9.WEBGL2 &&
							(i = t.getContext('webgl2', e)),
						i)
					)
						this.webGLVersion = 2;
					else if (
						((this.webGLVersion = 1),
						!(i =
							t.getContext('webgl', e) ||
							t.getContext('experimental-webgl', e)))
					)
						throw new Error(
							'This browser does not support WebGL. Try using the canvas renderer'
						);
					return (this.gl = i), this.getExtensions(), this.gl;
				}),
				(t.prototype.getExtensions = function () {
					var t = this.gl,
						e = {
							anisotropicFiltering: t.getExtension(
								'EXT_texture_filter_anisotropic'
							),
							floatTextureLinear: t.getExtension('OES_texture_float_linear'),
							s3tc: t.getExtension('WEBGL_compressed_texture_s3tc'),
							s3tc_sRGB: t.getExtension('WEBGL_compressed_texture_s3tc_srgb'),
							etc: t.getExtension('WEBGL_compressed_texture_etc'),
							etc1: t.getExtension('WEBGL_compressed_texture_etc1'),
							pvrtc:
								t.getExtension('WEBGL_compressed_texture_pvrtc') ||
								t.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),
							atc: t.getExtension('WEBGL_compressed_texture_atc'),
							astc: t.getExtension('WEBGL_compressed_texture_astc'),
						};
					1 === this.webGLVersion
						? Object.assign(this.extensions, e, {
								drawBuffers: t.getExtension('WEBGL_draw_buffers'),
								depthTexture: t.getExtension('WEBGL_depth_texture'),
								loseContext: t.getExtension('WEBGL_lose_context'),
								vertexArrayObject:
									t.getExtension('OES_vertex_array_object') ||
									t.getExtension('MOZ_OES_vertex_array_object') ||
									t.getExtension('WEBKIT_OES_vertex_array_object'),
								uint32ElementIndex: t.getExtension('OES_element_index_uint'),
								floatTexture: t.getExtension('OES_texture_float'),
								floatTextureLinear: t.getExtension('OES_texture_float_linear'),
								textureHalfFloat: t.getExtension('OES_texture_half_float'),
								textureHalfFloatLinear: t.getExtension(
									'OES_texture_half_float_linear'
								),
						  })
						: 2 === this.webGLVersion &&
						  Object.assign(this.extensions, e, {
								colorBufferFloat: t.getExtension('EXT_color_buffer_float'),
						  });
				}),
				(t.prototype.handleContextLost = function (t) {
					t.preventDefault();
				}),
				(t.prototype.handleContextRestored = function () {
					this.renderer.runners.contextChange.emit(this.gl);
				}),
				(t.prototype.destroy = function () {
					var t = this.renderer.view;
					(this.renderer = null),
						t.removeEventListener('webglcontextlost', this.handleContextLost),
						t.removeEventListener(
							'webglcontextrestored',
							this.handleContextRestored
						),
						this.gl.useProgram(null),
						this.extensions.loseContext &&
							this.extensions.loseContext.loseContext();
				}),
				(t.prototype.postrender = function () {
					this.renderer.renderingToScreen && this.gl.flush();
				}),
				(t.prototype.validateContext = function (t) {
					var e = t.getContextAttributes(),
						i =
							'WebGL2RenderingContext' in globalThis &&
							t instanceof globalThis.WebGL2RenderingContext;
					i && (this.webGLVersion = 2), e && e.stencil;
					var r = i || !!t.getExtension('OES_element_index_uint');
					this.supports.uint32Indices = r;
				}),
				t
			);
		})(),
		GLFramebuffer$2 = function (t) {
			(this.framebuffer = t),
				(this.stencil = null),
				(this.dirtyId = -1),
				(this.dirtyFormat = -1),
				(this.dirtySize = -1),
				(this.multisample = MSAA_QUALITY$9.NONE),
				(this.msaaBuffer = null),
				(this.blitFramebuffer = null),
				(this.mipLevel = 0);
		},
		tempRectangle$2 = new Rectangle$3(),
		FramebufferSystem$2 = (function () {
			function t(t) {
				(this.renderer = t),
					(this.managedFramebuffers = []),
					(this.unknownFramebuffer = new Framebuffer$2(10, 10)),
					(this.msaaSamples = null);
			}
			return (
				(t.prototype.contextChange = function () {
					var t = (this.gl = this.renderer.gl);
					if (
						((this.CONTEXT_UID = this.renderer.CONTEXT_UID),
						(this.current = this.unknownFramebuffer),
						(this.viewport = new Rectangle$3()),
						(this.hasMRT = !0),
						(this.writeDepthTexture = !0),
						this.disposeAll(!0),
						1 === this.renderer.context.webGLVersion)
					) {
						var e = this.renderer.context.extensions.drawBuffers,
							i = this.renderer.context.extensions.depthTexture;
						settings$4.PREFER_ENV === ENV$9.WEBGL_LEGACY &&
							((e = null), (i = null)),
							e
								? (t.drawBuffers = function (t) {
										return e.drawBuffersWEBGL(t);
								  })
								: ((this.hasMRT = !1), (t.drawBuffers = function () {})),
							i || (this.writeDepthTexture = !1);
					} else
						this.msaaSamples = t.getInternalformatParameter(
							t.RENDERBUFFER,
							t.RGBA8,
							t.SAMPLES
						);
				}),
				(t.prototype.bind = function (t, e, i) {
					void 0 === i && (i = 0);
					var r = this.gl;
					if (t) {
						var s =
							t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t);
						this.current !== t &&
							((this.current = t),
							r.bindFramebuffer(r.FRAMEBUFFER, s.framebuffer)),
							s.mipLevel !== i &&
								(t.dirtyId++, t.dirtyFormat++, (s.mipLevel = i)),
							s.dirtyId !== t.dirtyId &&
								((s.dirtyId = t.dirtyId),
								s.dirtyFormat !== t.dirtyFormat
									? ((s.dirtyFormat = t.dirtyFormat),
									  (s.dirtySize = t.dirtySize),
									  this.updateFramebuffer(t, i))
									: s.dirtySize !== t.dirtySize &&
									  ((s.dirtySize = t.dirtySize), this.resizeFramebuffer(t)));
						for (var n = 0; n < t.colorTextures.length; n++) {
							var a = t.colorTextures[n];
							this.renderer.texture.unbind(a.parentTextureArray || a);
						}
						if (
							(t.depthTexture && this.renderer.texture.unbind(t.depthTexture),
							e)
						) {
							var o = e.width >> i,
								h = e.height >> i,
								u = o / e.width;
							this.setViewport(e.x * u, e.y * u, o, h);
						} else
							(o = t.width >> i),
								(h = t.height >> i),
								this.setViewport(0, 0, o, h);
					} else
						this.current &&
							((this.current = null), r.bindFramebuffer(r.FRAMEBUFFER, null)),
							e
								? this.setViewport(e.x, e.y, e.width, e.height)
								: this.setViewport(
										0,
										0,
										this.renderer.width,
										this.renderer.height
								  );
				}),
				(t.prototype.setViewport = function (t, e, i, r) {
					var s = this.viewport;
					(t = Math.round(t)),
						(e = Math.round(e)),
						(i = Math.round(i)),
						(r = Math.round(r)),
						(s.width === i && s.height === r && s.x === t && s.y === e) ||
							((s.x = t),
							(s.y = e),
							(s.width = i),
							(s.height = r),
							this.gl.viewport(t, e, i, r));
				}),
				Object.defineProperty(t.prototype, 'size', {
					get: function () {
						return this.current
							? {
									x: 0,
									y: 0,
									width: this.current.width,
									height: this.current.height,
							  }
							: {
									x: 0,
									y: 0,
									width: this.renderer.width,
									height: this.renderer.height,
							  };
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.clear = function (t, e, i, r, s) {
					void 0 === s && (s = BUFFER_BITS$9.COLOR | BUFFER_BITS$9.DEPTH);
					var n = this.gl;
					n.clearColor(t, e, i, r), n.clear(s);
				}),
				(t.prototype.initFramebuffer = function (t) {
					var e = this.gl,
						i = new GLFramebuffer$2(e.createFramebuffer());
					return (
						(i.multisample = this.detectSamples(t.multisample)),
						(t.glFramebuffers[this.CONTEXT_UID] = i),
						this.managedFramebuffers.push(t),
						t.disposeRunner.add(this),
						i
					);
				}),
				(t.prototype.resizeFramebuffer = function (t) {
					var e = this.gl,
						i = t.glFramebuffers[this.CONTEXT_UID];
					i.msaaBuffer &&
						(e.bindRenderbuffer(e.RENDERBUFFER, i.msaaBuffer),
						e.renderbufferStorageMultisample(
							e.RENDERBUFFER,
							i.multisample,
							e.RGBA8,
							t.width,
							t.height
						)),
						i.stencil &&
							(e.bindRenderbuffer(e.RENDERBUFFER, i.stencil),
							i.msaaBuffer
								? e.renderbufferStorageMultisample(
										e.RENDERBUFFER,
										i.multisample,
										e.DEPTH24_STENCIL8,
										t.width,
										t.height
								  )
								: e.renderbufferStorage(
										e.RENDERBUFFER,
										e.DEPTH_STENCIL,
										t.width,
										t.height
								  ));
					var r = t.colorTextures,
						s = r.length;
					e.drawBuffers || (s = Math.min(s, 1));
					for (var n = 0; n < s; n++) {
						var a = r[n],
							o = a.parentTextureArray || a;
						this.renderer.texture.bind(o, 0);
					}
					t.depthTexture &&
						this.writeDepthTexture &&
						this.renderer.texture.bind(t.depthTexture, 0);
				}),
				(t.prototype.updateFramebuffer = function (t, e) {
					var i = this.gl,
						r = t.glFramebuffers[this.CONTEXT_UID],
						s = t.colorTextures,
						n = s.length;
					i.drawBuffers || (n = Math.min(n, 1)),
						r.multisample > 1 && this.canMultisampleFramebuffer(t)
							? ((r.msaaBuffer = r.msaaBuffer || i.createRenderbuffer()),
							  i.bindRenderbuffer(i.RENDERBUFFER, r.msaaBuffer),
							  i.renderbufferStorageMultisample(
									i.RENDERBUFFER,
									r.multisample,
									i.RGBA8,
									t.width,
									t.height
							  ),
							  i.framebufferRenderbuffer(
									i.FRAMEBUFFER,
									i.COLOR_ATTACHMENT0,
									i.RENDERBUFFER,
									r.msaaBuffer
							  ))
							: r.msaaBuffer &&
							  (i.deleteRenderbuffer(r.msaaBuffer),
							  (r.msaaBuffer = null),
							  r.blitFramebuffer &&
									(r.blitFramebuffer.dispose(), (r.blitFramebuffer = null)));
					for (var a = [], o = 0; o < n; o++) {
						var h = s[o],
							u = h.parentTextureArray || h;
						this.renderer.texture.bind(u, 0),
							(0 === o && r.msaaBuffer) ||
								(i.framebufferTexture2D(
									i.FRAMEBUFFER,
									i.COLOR_ATTACHMENT0 + o,
									h.target,
									u._glTextures[this.CONTEXT_UID].texture,
									e
								),
								a.push(i.COLOR_ATTACHMENT0 + o));
					}
					if (
						(a.length > 1 && i.drawBuffers(a),
						t.depthTexture && this.writeDepthTexture)
					) {
						var l = t.depthTexture;
						this.renderer.texture.bind(l, 0),
							i.framebufferTexture2D(
								i.FRAMEBUFFER,
								i.DEPTH_ATTACHMENT,
								i.TEXTURE_2D,
								l._glTextures[this.CONTEXT_UID].texture,
								e
							);
					}
					(!t.stencil && !t.depth) || (t.depthTexture && this.writeDepthTexture)
						? r.stencil && (i.deleteRenderbuffer(r.stencil), (r.stencil = null))
						: ((r.stencil = r.stencil || i.createRenderbuffer()),
						  i.bindRenderbuffer(i.RENDERBUFFER, r.stencil),
						  r.msaaBuffer
								? i.renderbufferStorageMultisample(
										i.RENDERBUFFER,
										r.multisample,
										i.DEPTH24_STENCIL8,
										t.width,
										t.height
								  )
								: i.renderbufferStorage(
										i.RENDERBUFFER,
										i.DEPTH_STENCIL,
										t.width,
										t.height
								  ),
						  i.framebufferRenderbuffer(
								i.FRAMEBUFFER,
								i.DEPTH_STENCIL_ATTACHMENT,
								i.RENDERBUFFER,
								r.stencil
						  ));
				}),
				(t.prototype.canMultisampleFramebuffer = function (t) {
					return (
						1 !== this.renderer.context.webGLVersion &&
						t.colorTextures.length <= 1 &&
						!t.depthTexture
					);
				}),
				(t.prototype.detectSamples = function (t) {
					var e = this.msaaSamples,
						i = MSAA_QUALITY$9.NONE;
					if (t <= 1 || null === e) return i;
					for (var r = 0; r < e.length; r++)
						if (e[r] <= t) {
							i = e[r];
							break;
						}
					return 1 === i && (i = MSAA_QUALITY$9.NONE), i;
				}),
				(t.prototype.blit = function (t, e, i) {
					var r = this,
						s = r.current,
						n = r.renderer,
						a = r.gl,
						o = r.CONTEXT_UID;
					if (2 === n.context.webGLVersion && s) {
						var h = s.glFramebuffers[o];
						if (h) {
							if (!t) {
								if (!h.msaaBuffer) return;
								var u = s.colorTextures[0];
								if (!u) return;
								h.blitFramebuffer ||
									((h.blitFramebuffer = new Framebuffer$2(s.width, s.height)),
									h.blitFramebuffer.addColorTexture(0, u)),
									(t = h.blitFramebuffer).colorTextures[0] !== u &&
										((t.colorTextures[0] = u), t.dirtyId++, t.dirtyFormat++),
									(t.width === s.width && t.height === s.height) ||
										((t.width = s.width),
										(t.height = s.height),
										t.dirtyId++,
										t.dirtySize++);
							}
							e ||
								(((e = tempRectangle$2).width = s.width),
								(e.height = s.height)),
								i || (i = e);
							var l = e.width === i.width && e.height === i.height;
							this.bind(t),
								a.bindFramebuffer(a.READ_FRAMEBUFFER, h.framebuffer),
								a.blitFramebuffer(
									e.left,
									e.top,
									e.right,
									e.bottom,
									i.left,
									i.top,
									i.right,
									i.bottom,
									a.COLOR_BUFFER_BIT,
									l ? a.NEAREST : a.LINEAR
								);
						}
					}
				}),
				(t.prototype.disposeFramebuffer = function (t, e) {
					var i = t.glFramebuffers[this.CONTEXT_UID],
						r = this.gl;
					if (i) {
						delete t.glFramebuffers[this.CONTEXT_UID];
						var s = this.managedFramebuffers.indexOf(t);
						s >= 0 && this.managedFramebuffers.splice(s, 1),
							t.disposeRunner.remove(this),
							e ||
								(r.deleteFramebuffer(i.framebuffer),
								i.msaaBuffer && r.deleteRenderbuffer(i.msaaBuffer),
								i.stencil && r.deleteRenderbuffer(i.stencil)),
							i.blitFramebuffer && i.blitFramebuffer.dispose();
					}
				}),
				(t.prototype.disposeAll = function (t) {
					var e = this.managedFramebuffers;
					this.managedFramebuffers = [];
					for (var i = 0; i < e.length; i++) this.disposeFramebuffer(e[i], t);
				}),
				(t.prototype.forceStencil = function () {
					var t = this.current;
					if (t) {
						var e = t.glFramebuffers[this.CONTEXT_UID];
						if (e && !e.stencil) {
							t.stencil = !0;
							var i = t.width,
								r = t.height,
								s = this.gl,
								n = s.createRenderbuffer();
							s.bindRenderbuffer(s.RENDERBUFFER, n),
								e.msaaBuffer
									? s.renderbufferStorageMultisample(
											s.RENDERBUFFER,
											e.multisample,
											s.DEPTH24_STENCIL8,
											i,
											r
									  )
									: s.renderbufferStorage(
											s.RENDERBUFFER,
											s.DEPTH_STENCIL,
											i,
											r
									  ),
								(e.stencil = n),
								s.framebufferRenderbuffer(
									s.FRAMEBUFFER,
									s.DEPTH_STENCIL_ATTACHMENT,
									s.RENDERBUFFER,
									n
								);
						}
					}
				}),
				(t.prototype.reset = function () {
					(this.current = this.unknownFramebuffer),
						(this.viewport = new Rectangle$3());
				}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})(),
		byteSizeMap$3 = { 5126: 4, 5123: 2, 5121: 1 },
		GeometrySystem$2 = (function () {
			function t(t) {
				(this.renderer = t),
					(this._activeGeometry = null),
					(this._activeVao = null),
					(this.hasVao = !0),
					(this.hasInstance = !0),
					(this.canUseUInt32ElementIndex = !1),
					(this.managedGeometries = {});
			}
			return (
				(t.prototype.contextChange = function () {
					this.disposeAll(!0);
					var t = (this.gl = this.renderer.gl),
						e = this.renderer.context;
					if (
						((this.CONTEXT_UID = this.renderer.CONTEXT_UID),
						2 !== e.webGLVersion)
					) {
						var i = this.renderer.context.extensions.vertexArrayObject;
						settings$4.PREFER_ENV === ENV$9.WEBGL_LEGACY && (i = null),
							i
								? ((t.createVertexArray = function () {
										return i.createVertexArrayOES();
								  }),
								  (t.bindVertexArray = function (t) {
										return i.bindVertexArrayOES(t);
								  }),
								  (t.deleteVertexArray = function (t) {
										return i.deleteVertexArrayOES(t);
								  }))
								: ((this.hasVao = !1),
								  (t.createVertexArray = function () {
										return null;
								  }),
								  (t.bindVertexArray = function () {
										return null;
								  }),
								  (t.deleteVertexArray = function () {
										return null;
								  }));
					}
					if (2 !== e.webGLVersion) {
						var r = t.getExtension('ANGLE_instanced_arrays');
						r
							? ((t.vertexAttribDivisor = function (t, e) {
									return r.vertexAttribDivisorANGLE(t, e);
							  }),
							  (t.drawElementsInstanced = function (t, e, i, s, n) {
									return r.drawElementsInstancedANGLE(t, e, i, s, n);
							  }),
							  (t.drawArraysInstanced = function (t, e, i, s) {
									return r.drawArraysInstancedANGLE(t, e, i, s);
							  }))
							: (this.hasInstance = !1);
					}
					this.canUseUInt32ElementIndex =
						2 === e.webGLVersion || !!e.extensions.uint32ElementIndex;
				}),
				(t.prototype.bind = function (t, e) {
					e = e || this.renderer.shader.shader;
					var i = this.gl,
						r = t.glVertexArrayObjects[this.CONTEXT_UID],
						s = !1;
					r ||
						((this.managedGeometries[t.id] = t),
						t.disposeRunner.add(this),
						(t.glVertexArrayObjects[this.CONTEXT_UID] = r = {}),
						(s = !0));
					var n = r[e.program.id] || this.initGeometryVao(t, e, s);
					(this._activeGeometry = t),
						this._activeVao !== n &&
							((this._activeVao = n),
							this.hasVao
								? i.bindVertexArray(n)
								: this.activateVao(t, e.program)),
						this.updateBuffers();
				}),
				(t.prototype.reset = function () {
					this.unbind();
				}),
				(t.prototype.updateBuffers = function () {
					for (
						var t = this._activeGeometry, e = this.renderer.buffer, i = 0;
						i < t.buffers.length;
						i++
					) {
						var r = t.buffers[i];
						e.update(r);
					}
				}),
				(t.prototype.checkCompatibility = function (t, e) {
					var i = t.attributes,
						r = e.attributeData;
					for (var s in r)
						if (!i[s])
							throw new Error(
								'shader and geometry incompatible, geometry missing the "' +
									s +
									'" attribute'
							);
				}),
				(t.prototype.getSignature = function (t, e) {
					var i = t.attributes,
						r = e.attributeData,
						s = ['g', t.id];
					for (var n in i) r[n] && s.push(n, r[n].location);
					return s.join('-');
				}),
				(t.prototype.initGeometryVao = function (t, e, i) {
					void 0 === i && (i = !0);
					var r = this.gl,
						s = this.CONTEXT_UID,
						n = this.renderer.buffer,
						a = e.program;
					a.glPrograms[s] || this.renderer.shader.generateProgram(e),
						this.checkCompatibility(t, a);
					var o = this.getSignature(t, a),
						h = t.glVertexArrayObjects[this.CONTEXT_UID],
						u = h[o];
					if (u) return (h[a.id] = u), u;
					var l = t.buffers,
						c = t.attributes,
						d = {},
						p = {};
					for (var f in l) (d[f] = 0), (p[f] = 0);
					for (var f in c)
						!c[f].size && a.attributeData[f]
							? (c[f].size = a.attributeData[f].size)
							: c[f].size,
							(d[c[f].buffer] += c[f].size * byteSizeMap$3[c[f].type]);
					for (var f in c) {
						var m = c[f],
							_ = m.size;
						void 0 === m.stride &&
							(d[m.buffer] === _ * byteSizeMap$3[m.type]
								? (m.stride = 0)
								: (m.stride = d[m.buffer])),
							void 0 === m.start &&
								((m.start = p[m.buffer]),
								(p[m.buffer] += _ * byteSizeMap$3[m.type]));
					}
					(u = r.createVertexArray()), r.bindVertexArray(u);
					for (var g = 0; g < l.length; g++) {
						var E = l[g];
						n.bind(E), i && E._glBuffers[s].refCount++;
					}
					return (
						this.activateVao(t, a),
						(this._activeVao = u),
						(h[a.id] = u),
						(h[o] = u),
						u
					);
				}),
				(t.prototype.disposeGeometry = function (t, e) {
					var i;
					if (this.managedGeometries[t.id]) {
						delete this.managedGeometries[t.id];
						var r = t.glVertexArrayObjects[this.CONTEXT_UID],
							s = this.gl,
							n = t.buffers,
							a =
								null === (i = this.renderer) || void 0 === i
									? void 0
									: i.buffer;
						if ((t.disposeRunner.remove(this), r)) {
							if (a)
								for (var o = 0; o < n.length; o++) {
									var h = n[o]._glBuffers[this.CONTEXT_UID];
									h &&
										(h.refCount--, 0 !== h.refCount || e || a.dispose(n[o], e));
								}
							if (!e)
								for (var u in r)
									if ('g' === u[0]) {
										var l = r[u];
										this._activeVao === l && this.unbind(),
											s.deleteVertexArray(l);
									}
							delete t.glVertexArrayObjects[this.CONTEXT_UID];
						}
					}
				}),
				(t.prototype.disposeAll = function (t) {
					for (
						var e = Object.keys(this.managedGeometries), i = 0;
						i < e.length;
						i++
					)
						this.disposeGeometry(this.managedGeometries[e[i]], t);
				}),
				(t.prototype.activateVao = function (t, e) {
					var i = this.gl,
						r = this.CONTEXT_UID,
						s = this.renderer.buffer,
						n = t.buffers,
						a = t.attributes;
					t.indexBuffer && s.bind(t.indexBuffer);
					var o = null;
					for (var h in a) {
						var u = a[h],
							l = n[u.buffer],
							c = l._glBuffers[r];
						if (e.attributeData[h]) {
							o !== c && (s.bind(l), (o = c));
							var d = e.attributeData[h].location;
							if (
								(i.enableVertexAttribArray(d),
								i.vertexAttribPointer(
									d,
									u.size,
									u.type || i.FLOAT,
									u.normalized,
									u.stride,
									u.start
								),
								u.instance)
							) {
								if (!this.hasInstance)
									throw new Error(
										'geometry error, GPU Instancing is not supported on this device'
									);
								i.vertexAttribDivisor(d, 1);
							}
						}
					}
				}),
				(t.prototype.draw = function (t, e, i, r) {
					var s = this.gl,
						n = this._activeGeometry;
					if (n.indexBuffer) {
						var a = n.indexBuffer.data.BYTES_PER_ELEMENT,
							o = 2 === a ? s.UNSIGNED_SHORT : s.UNSIGNED_INT;
						(2 === a || (4 === a && this.canUseUInt32ElementIndex)) &&
							(n.instanced
								? s.drawElementsInstanced(
										t,
										e || n.indexBuffer.data.length,
										o,
										(i || 0) * a,
										r || 1
								  )
								: s.drawElements(
										t,
										e || n.indexBuffer.data.length,
										o,
										(i || 0) * a
								  ));
					} else
						n.instanced
							? s.drawArraysInstanced(t, i, e || n.getSize(), r || 1)
							: s.drawArrays(t, i, e || n.getSize());
					return this;
				}),
				(t.prototype.unbind = function () {
					this.gl.bindVertexArray(null),
						(this._activeVao = null),
						(this._activeGeometry = null);
				}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})(),
		MaskData$2 = (function () {
			function t(t) {
				void 0 === t && (t = null),
					(this.type = MASK_TYPES$9.NONE),
					(this.autoDetect = !0),
					(this.maskObject = t || null),
					(this.pooled = !1),
					(this.isMaskData = !0),
					(this.resolution = null),
					(this.multisample = settings$4.FILTER_MULTISAMPLE),
					(this.enabled = !0),
					(this._filters = null),
					(this._stencilCounter = 0),
					(this._scissorCounter = 0),
					(this._scissorRect = null),
					(this._scissorRectLocal = null),
					(this._target = null);
			}
			return (
				Object.defineProperty(t.prototype, 'filter', {
					get: function () {
						return this._filters ? this._filters[0] : null;
					},
					set: function (t) {
						t
							? this._filters
								? (this._filters[0] = t)
								: (this._filters = [t])
							: (this._filters = null);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.reset = function () {
					this.pooled &&
						((this.maskObject = null),
						(this.type = MASK_TYPES$9.NONE),
						(this.autoDetect = !0)),
						(this._target = null),
						(this._scissorRectLocal = null);
				}),
				(t.prototype.copyCountersOrReset = function (t) {
					t
						? ((this._stencilCounter = t._stencilCounter),
						  (this._scissorCounter = t._scissorCounter),
						  (this._scissorRect = t._scissorRect))
						: ((this._stencilCounter = 0),
						  (this._scissorCounter = 0),
						  (this._scissorRect = null));
				}),
				t
			);
		})();
	function compileShader$2(t, e, i) {
		var r = t.createShader(e);
		return t.shaderSource(r, i), t.compileShader(r), r;
	}
	function logPrettyShaderError$2(t, e) {
		var i = t
				.getShaderSource(e)
				.split('\n')
				.map(function (t, e) {
					return e + ': ' + t;
				}),
			r = t.getShaderInfoLog(e).split('\n'),
			s = {},
			n = r
				.map(function (t) {
					return parseFloat(t.replace(/^ERROR\: 0\:([\d]+)\:.*$/, '$1'));
				})
				.filter(function (t) {
					return !(!t || s[t] || ((s[t] = !0), 0));
				}),
			a = [''];
		n.forEach(function (t) {
			(i[t - 1] = '%c' + i[t - 1] + '%c'),
				a.push(
					'background: #FF0000; color:#FFFFFF; font-size: 10px',
					'font-size: 10px'
				);
		});
		var o = i.join('\n');
		a[0] = o;
	}
	function logProgramError$2(t, e, i, r) {
		t.getProgramParameter(e, t.LINK_STATUS) ||
			(t.getShaderParameter(i, t.COMPILE_STATUS) ||
				logPrettyShaderError$2(t, i),
			t.getShaderParameter(r, t.COMPILE_STATUS) || logPrettyShaderError$2(t, r),
			t.getProgramInfoLog(e));
	}
	function booleanArray$2(t) {
		for (var e = new Array(t), i = 0; i < e.length; i++) e[i] = !1;
		return e;
	}
	function defaultValue$2(t, e) {
		switch (t) {
			case 'float':
			case 'int':
			case 'uint':
			case 'sampler2D':
			case 'sampler2DArray':
				return 0;
			case 'vec2':
				return new Float32Array(2 * e);
			case 'vec3':
				return new Float32Array(3 * e);
			case 'vec4':
				return new Float32Array(4 * e);
			case 'ivec2':
				return new Int32Array(2 * e);
			case 'ivec3':
				return new Int32Array(3 * e);
			case 'ivec4':
				return new Int32Array(4 * e);
			case 'uvec2':
				return new Uint32Array(2 * e);
			case 'uvec3':
				return new Uint32Array(3 * e);
			case 'uvec4':
				return new Uint32Array(4 * e);
			case 'bool':
				return !1;
			case 'bvec2':
				return booleanArray$2(2 * e);
			case 'bvec3':
				return booleanArray$2(3 * e);
			case 'bvec4':
				return booleanArray$2(4 * e);
			case 'mat2':
				return new Float32Array([1, 0, 0, 1]);
			case 'mat3':
				return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
			case 'mat4':
				return new Float32Array([
					1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
				]);
		}
		return null;
	}
	var unknownContext$2 = {},
		context$2 = unknownContext$2,
		maxFragmentPrecision$2;
	function getTestContext$2() {
		if (
			context$2 === unknownContext$2 ||
			(context$2 && context$2.isContextLost())
		) {
			var t = document.createElement('canvas'),
				e = void 0;
			settings$4.PREFER_ENV >= ENV$9.WEBGL2 && (e = t.getContext('webgl2', {})),
				e ||
					((e =
						t.getContext('webgl', {}) || t.getContext('experimental-webgl', {}))
						? e.getExtension('WEBGL_draw_buffers')
						: (e = null)),
				(context$2 = e);
		}
		return context$2;
	}
	function getMaxFragmentPrecision$2() {
		if (!maxFragmentPrecision$2) {
			maxFragmentPrecision$2 = PRECISION$9.MEDIUM;
			var t = getTestContext$2();
			if (t && t.getShaderPrecisionFormat) {
				var e = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT);
				maxFragmentPrecision$2 = e.precision
					? PRECISION$9.HIGH
					: PRECISION$9.MEDIUM;
			}
		}
		return maxFragmentPrecision$2;
	}
	function setPrecision$2(t, e, i) {
		if ('precision' !== t.substring(0, 9)) {
			var r = e;
			return (
				e === PRECISION$9.HIGH &&
					i !== PRECISION$9.HIGH &&
					(r = PRECISION$9.MEDIUM),
				'precision ' + r + ' float;\n' + t
			);
		}
		return i !== PRECISION$9.HIGH && 'precision highp' === t.substring(0, 15)
			? t.replace('precision highp', 'precision mediump')
			: t;
	}
	var GLSL_TO_SIZE$2 = {
		float: 1,
		vec2: 2,
		vec3: 3,
		vec4: 4,
		int: 1,
		ivec2: 2,
		ivec3: 3,
		ivec4: 4,
		uint: 1,
		uvec2: 2,
		uvec3: 3,
		uvec4: 4,
		bool: 1,
		bvec2: 2,
		bvec3: 3,
		bvec4: 4,
		mat2: 4,
		mat3: 9,
		mat4: 16,
		sampler2D: 1,
	};
	function mapSize$2(t) {
		return GLSL_TO_SIZE$2[t];
	}
	var GL_TABLE$2 = null,
		GL_TO_GLSL_TYPES$2 = {
			FLOAT: 'float',
			FLOAT_VEC2: 'vec2',
			FLOAT_VEC3: 'vec3',
			FLOAT_VEC4: 'vec4',
			INT: 'int',
			INT_VEC2: 'ivec2',
			INT_VEC3: 'ivec3',
			INT_VEC4: 'ivec4',
			UNSIGNED_INT: 'uint',
			UNSIGNED_INT_VEC2: 'uvec2',
			UNSIGNED_INT_VEC3: 'uvec3',
			UNSIGNED_INT_VEC4: 'uvec4',
			BOOL: 'bool',
			BOOL_VEC2: 'bvec2',
			BOOL_VEC3: 'bvec3',
			BOOL_VEC4: 'bvec4',
			FLOAT_MAT2: 'mat2',
			FLOAT_MAT3: 'mat3',
			FLOAT_MAT4: 'mat4',
			SAMPLER_2D: 'sampler2D',
			INT_SAMPLER_2D: 'sampler2D',
			UNSIGNED_INT_SAMPLER_2D: 'sampler2D',
			SAMPLER_CUBE: 'samplerCube',
			INT_SAMPLER_CUBE: 'samplerCube',
			UNSIGNED_INT_SAMPLER_CUBE: 'samplerCube',
			SAMPLER_2D_ARRAY: 'sampler2DArray',
			INT_SAMPLER_2D_ARRAY: 'sampler2DArray',
			UNSIGNED_INT_SAMPLER_2D_ARRAY: 'sampler2DArray',
		};
	function mapType$2(t, e) {
		if (!GL_TABLE$2) {
			var i = Object.keys(GL_TO_GLSL_TYPES$2);
			GL_TABLE$2 = {};
			for (var r = 0; r < i.length; ++r) {
				var s = i[r];
				GL_TABLE$2[t[s]] = GL_TO_GLSL_TYPES$2[s];
			}
		}
		return GL_TABLE$2[e];
	}
	var uniformParsers$2 = [
			{
				test: function (t) {
					return 'float' === t.type && 1 === t.size;
				},
				code: function (t) {
					return (
						'\n            if(uv["' +
						t +
						'"] !== ud["' +
						t +
						'"].value)\n            {\n                ud["' +
						t +
						'"].value = uv["' +
						t +
						'"]\n                gl.uniform1f(ud["' +
						t +
						'"].location, uv["' +
						t +
						'"])\n            }\n            '
					);
				},
			},
			{
				test: function (t) {
					return (
						('sampler2D' === t.type ||
							'samplerCube' === t.type ||
							'sampler2DArray' === t.type) &&
						1 === t.size &&
						!t.isArray
					);
				},
				code: function (t) {
					return (
						't = syncData.textureCount++;\n\n            renderer.texture.bind(uv["' +
						t +
						'"], t);\n\n            if(ud["' +
						t +
						'"].value !== t)\n            {\n                ud["' +
						t +
						'"].value = t;\n                gl.uniform1i(ud["' +
						t +
						'"].location, t);\n; // eslint-disable-line max-len\n            }'
					);
				},
			},
			{
				test: function (t, e) {
					return 'mat3' === t.type && 1 === t.size && void 0 !== e.a;
				},
				code: function (t) {
					return (
						'\n            gl.uniformMatrix3fv(ud["' +
						t +
						'"].location, false, uv["' +
						t +
						'"].toArray(true));\n            '
					);
				},
				codeUbo: function (t) {
					return (
						'\n                var ' +
						t +
						'_matrix = uv.' +
						t +
						'.toArray(true);\n\n                data[offset] = ' +
						t +
						'_matrix[0];\n                data[offset+1] = ' +
						t +
						'_matrix[1];\n                data[offset+2] = ' +
						t +
						'_matrix[2];\n        \n                data[offset + 4] = ' +
						t +
						'_matrix[3];\n                data[offset + 5] = ' +
						t +
						'_matrix[4];\n                data[offset + 6] = ' +
						t +
						'_matrix[5];\n        \n                data[offset + 8] = ' +
						t +
						'_matrix[6];\n                data[offset + 9] = ' +
						t +
						'_matrix[7];\n                data[offset + 10] = ' +
						t +
						'_matrix[8];\n            '
					);
				},
			},
			{
				test: function (t, e) {
					return 'vec2' === t.type && 1 === t.size && void 0 !== e.x;
				},
				code: function (t) {
					return (
						'\n                cv = ud["' +
						t +
						'"].value;\n                v = uv["' +
						t +
						'"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["' +
						t +
						'"].location, v.x, v.y);\n                }'
					);
				},
				codeUbo: function (t) {
					return (
						'\n                v = uv.' +
						t +
						';\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            '
					);
				},
			},
			{
				test: function (t) {
					return 'vec2' === t.type && 1 === t.size;
				},
				code: function (t) {
					return (
						'\n                cv = ud["' +
						t +
						'"].value;\n                v = uv["' +
						t +
						'"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["' +
						t +
						'"].location, v[0], v[1]);\n                }\n            '
					);
				},
			},
			{
				test: function (t, e) {
					return 'vec4' === t.type && 1 === t.size && void 0 !== e.width;
				},
				code: function (t) {
					return (
						'\n                cv = ud["' +
						t +
						'"].value;\n                v = uv["' +
						t +
						'"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["' +
						t +
						'"].location, v.x, v.y, v.width, v.height)\n                }'
					);
				},
				codeUbo: function (t) {
					return (
						'\n                    v = uv.' +
						t +
						';\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                '
					);
				},
			},
			{
				test: function (t) {
					return 'vec4' === t.type && 1 === t.size;
				},
				code: function (t) {
					return (
						'\n                cv = ud["' +
						t +
						'"].value;\n                v = uv["' +
						t +
						'"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["' +
						t +
						'"].location, v[0], v[1], v[2], v[3])\n                }'
					);
				},
			},
		],
		GLSL_TO_SINGLE_SETTERS_CACHED$2 = {
			float:
				'\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }',
			vec2: '\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }',
			vec3: '\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }',
			vec4: '\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }',
			int: '\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }',
			ivec2:
				'\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }',
			ivec3:
				'\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }',
			ivec4:
				'\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }',
			uint: '\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }',
			uvec2:
				'\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }',
			uvec3:
				'\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }',
			uvec4:
				'\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }',
			bool: '\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }',
			bvec2:
				'\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }',
			bvec3:
				'\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }',
			bvec4:
				'\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }',
			mat2: 'gl.uniformMatrix2fv(location, false, v)',
			mat3: 'gl.uniformMatrix3fv(location, false, v)',
			mat4: 'gl.uniformMatrix4fv(location, false, v)',
			sampler2D: 'gl.uniform1i(location, v)',
			samplerCube: 'gl.uniform1i(location, v)',
			sampler2DArray: 'gl.uniform1i(location, v)',
		},
		GLSL_TO_ARRAY_SETTERS$2 = {
			float: 'gl.uniform1fv(location, v)',
			vec2: 'gl.uniform2fv(location, v)',
			vec3: 'gl.uniform3fv(location, v)',
			vec4: 'gl.uniform4fv(location, v)',
			mat4: 'gl.uniformMatrix4fv(location, false, v)',
			mat3: 'gl.uniformMatrix3fv(location, false, v)',
			mat2: 'gl.uniformMatrix2fv(location, false, v)',
			int: 'gl.uniform1iv(location, v)',
			ivec2: 'gl.uniform2iv(location, v)',
			ivec3: 'gl.uniform3iv(location, v)',
			ivec4: 'gl.uniform4iv(location, v)',
			uint: 'gl.uniform1uiv(location, v)',
			uvec2: 'gl.uniform2uiv(location, v)',
			uvec3: 'gl.uniform3uiv(location, v)',
			uvec4: 'gl.uniform4uiv(location, v)',
			bool: 'gl.uniform1iv(location, v)',
			bvec2: 'gl.uniform2iv(location, v)',
			bvec3: 'gl.uniform3iv(location, v)',
			bvec4: 'gl.uniform4iv(location, v)',
			sampler2D: 'gl.uniform1iv(location, v)',
			samplerCube: 'gl.uniform1iv(location, v)',
			sampler2DArray: 'gl.uniform1iv(location, v)',
		};
	function generateUniformsSync$2(t, e) {
		var i,
			r = [
				'\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    ',
			];
		for (var s in t.uniforms) {
			var n = e[s];
			if (n) {
				for (
					var a = t.uniforms[s], o = !1, h = 0;
					h < uniformParsers$2.length;
					h++
				)
					if (uniformParsers$2[h].test(n, a)) {
						r.push(uniformParsers$2[h].code(s, a)), (o = !0);
						break;
					}
				if (!o) {
					var u = (
						1 === n.size
							? GLSL_TO_SINGLE_SETTERS_CACHED$2
							: GLSL_TO_ARRAY_SETTERS$2
					)[n.type].replace('location', 'ud["' + s + '"].location');
					r.push(
						'\n            cu = ud["' +
							s +
							'"];\n            cv = cu.value;\n            v = uv["' +
							s +
							'"];\n            ' +
							u +
							';'
					);
				}
			} else
				(null === (i = t.uniforms[s]) || void 0 === i ? void 0 : i.group) &&
					(t.uniforms[s].ubo
						? r.push(
								'\n                        renderer.shader.syncUniformBufferGroup(uv.' +
									s +
									", '" +
									s +
									"');\n                    "
						  )
						: r.push(
								'\n                        renderer.shader.syncUniformGroup(uv.' +
									s +
									', syncData);\n                    '
						  ));
		}
		return new Function('ud', 'uv', 'renderer', 'syncData', r.join('\n'));
	}
	var fragTemplate$2 = [
			'precision mediump float;',
			'void main(void){',
			'float test = 0.1;',
			'%forloop%',
			'gl_FragColor = vec4(0.0);',
			'}',
		].join('\n'),
		unsafeEval$2;
	function generateIfTestSrc$2(t) {
		for (var e = '', i = 0; i < t; ++i)
			i > 0 && (e += '\nelse '),
				i < t - 1 && (e += 'if(test == ' + i + '.0){}');
		return e;
	}
	function checkMaxIfStatementsInShader$2(t, e) {
		if (0 === t)
			throw new Error(
				'Invalid value of `0` passed to `checkMaxIfStatementsInShader`'
			);
		for (var i = e.createShader(e.FRAGMENT_SHADER); ; ) {
			var r = fragTemplate$2.replace(/%forloop%/gi, generateIfTestSrc$2(t));
			if (
				(e.shaderSource(i, r),
				e.compileShader(i),
				e.getShaderParameter(i, e.COMPILE_STATUS))
			)
				break;
			t = (t / 2) | 0;
		}
		return t;
	}
	function unsafeEvalSupported$2() {
		if ('boolean' == typeof unsafeEval$2) return unsafeEval$2;
		try {
			var t = new Function(
				'param1',
				'param2',
				'param3',
				'return param1[param2] === param3;'
			);
			unsafeEval$2 = !0 === t({ a: 'b' }, 'a', 'b');
		} catch (t) {
			unsafeEval$2 = !1;
		}
		return unsafeEval$2;
	}
	var defaultFragment$2$2 =
			'varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}',
		defaultVertex$3$2 =
			'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n',
		UID$1$2 = 0,
		nameCache$2 = {},
		Program$2 = (function () {
			function t(e, i, r) {
				void 0 === r && (r = 'pixi-shader'),
					(this.id = UID$1$2++),
					(this.vertexSrc = e || t.defaultVertexSrc),
					(this.fragmentSrc = i || t.defaultFragmentSrc),
					(this.vertexSrc = this.vertexSrc.trim()),
					(this.fragmentSrc = this.fragmentSrc.trim()),
					'#version' !== this.vertexSrc.substring(0, 8) &&
						((r = r.replace(/\s+/g, '-')),
						nameCache$2[r]
							? (nameCache$2[r]++, (r += '-' + nameCache$2[r]))
							: (nameCache$2[r] = 1),
						(this.vertexSrc =
							'#define SHADER_NAME ' + r + '\n' + this.vertexSrc),
						(this.fragmentSrc =
							'#define SHADER_NAME ' + r + '\n' + this.fragmentSrc),
						(this.vertexSrc = setPrecision$2(
							this.vertexSrc,
							settings$4.PRECISION_VERTEX,
							PRECISION$9.HIGH
						)),
						(this.fragmentSrc = setPrecision$2(
							this.fragmentSrc,
							settings$4.PRECISION_FRAGMENT,
							getMaxFragmentPrecision$2()
						))),
					(this.glPrograms = {}),
					(this.syncUniforms = null);
			}
			return (
				Object.defineProperty(t, 'defaultVertexSrc', {
					get: function () {
						return defaultVertex$3$2;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t, 'defaultFragmentSrc', {
					get: function () {
						return defaultFragment$2$2;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.from = function (e, i, r) {
					var s = e + i,
						n = ProgramCache$2[s];
					return n || (ProgramCache$2[s] = n = new t(e, i, r)), n;
				}),
				t
			);
		})(),
		Shader$2 = (function () {
			function t(t, e) {
				(this.uniformBindCount = 0),
					(this.program = t),
					(this.uniformGroup = e
						? e instanceof UniformGroup$2
							? e
							: new UniformGroup$2(e)
						: new UniformGroup$2({}));
			}
			return (
				(t.prototype.checkUniformExists = function (t, e) {
					if (e.uniforms[t]) return !0;
					for (var i in e.uniforms) {
						var r = e.uniforms[i];
						if (r.group && this.checkUniformExists(t, r)) return !0;
					}
					return !1;
				}),
				(t.prototype.destroy = function () {
					this.uniformGroup = null;
				}),
				Object.defineProperty(t.prototype, 'uniforms', {
					get: function () {
						return this.uniformGroup.uniforms;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.from = function (e, i, r) {
					return new t(Program$2.from(e, i), r);
				}),
				t
			);
		})(),
		BLEND$1$2 = 0,
		OFFSET$1$2 = 1,
		CULLING$1$2 = 2,
		DEPTH_TEST$1$2 = 3,
		WINDING$1$2 = 4,
		DEPTH_MASK$1$2 = 5,
		State$2 = (function () {
			function t() {
				(this.data = 0),
					(this.blendMode = BLEND_MODES$9.NORMAL),
					(this.polygonOffset = 0),
					(this.blend = !0),
					(this.depthMask = !0);
			}
			return (
				Object.defineProperty(t.prototype, 'blend', {
					get: function () {
						return !!(this.data & (1 << BLEND$1$2));
					},
					set: function (t) {
						!!(this.data & (1 << BLEND$1$2)) !== t &&
							(this.data ^= 1 << BLEND$1$2);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'offsets', {
					get: function () {
						return !!(this.data & (1 << OFFSET$1$2));
					},
					set: function (t) {
						!!(this.data & (1 << OFFSET$1$2)) !== t &&
							(this.data ^= 1 << OFFSET$1$2);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'culling', {
					get: function () {
						return !!(this.data & (1 << CULLING$1$2));
					},
					set: function (t) {
						!!(this.data & (1 << CULLING$1$2)) !== t &&
							(this.data ^= 1 << CULLING$1$2);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'depthTest', {
					get: function () {
						return !!(this.data & (1 << DEPTH_TEST$1$2));
					},
					set: function (t) {
						!!(this.data & (1 << DEPTH_TEST$1$2)) !== t &&
							(this.data ^= 1 << DEPTH_TEST$1$2);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'depthMask', {
					get: function () {
						return !!(this.data & (1 << DEPTH_MASK$1$2));
					},
					set: function (t) {
						!!(this.data & (1 << DEPTH_MASK$1$2)) !== t &&
							(this.data ^= 1 << DEPTH_MASK$1$2);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'clockwiseFrontFace', {
					get: function () {
						return !!(this.data & (1 << WINDING$1$2));
					},
					set: function (t) {
						!!(this.data & (1 << WINDING$1$2)) !== t &&
							(this.data ^= 1 << WINDING$1$2);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'blendMode', {
					get: function () {
						return this._blendMode;
					},
					set: function (t) {
						(this.blend = t !== BLEND_MODES$9.NONE), (this._blendMode = t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'polygonOffset', {
					get: function () {
						return this._polygonOffset;
					},
					set: function (t) {
						(this.offsets = !!t), (this._polygonOffset = t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.toString = function () {
					return (
						'[@pixi/core:State blendMode=' +
						this.blendMode +
						' clockwiseFrontFace=' +
						this.clockwiseFrontFace +
						' culling=' +
						this.culling +
						' depthMask=' +
						this.depthMask +
						' polygonOffset=' +
						this.polygonOffset +
						']'
					);
				}),
				(t.for2d = function () {
					var e = new t();
					return (e.depthTest = !1), (e.blend = !0), e;
				}),
				t
			);
		})(),
		defaultVertex$2$1 =
			'attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n',
		defaultFragment$1$2 =
			'varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n',
		Filter$2 = (function (t) {
			function e(i, r, s) {
				var n = this,
					a = Program$2.from(
						i || e.defaultVertexSrc,
						r || e.defaultFragmentSrc
					);
				return (
					((n = t.call(this, a, s) || this).padding = 0),
					(n.resolution = settings$4.FILTER_RESOLUTION),
					(n.multisample = settings$4.FILTER_MULTISAMPLE),
					(n.enabled = !0),
					(n.autoFit = !0),
					(n.state = new State$2()),
					n
				);
			}
			return (
				__extends$d(e, t),
				(e.prototype.apply = function (t, e, i, r, s) {
					t.applyFilter(this, e, i, r);
				}),
				Object.defineProperty(e.prototype, 'blendMode', {
					get: function () {
						return this.state.blendMode;
					},
					set: function (t) {
						this.state.blendMode = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'resolution', {
					get: function () {
						return this._resolution;
					},
					set: function (t) {
						this._resolution = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e, 'defaultVertexSrc', {
					get: function () {
						return defaultVertex$2$1;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e, 'defaultFragmentSrc', {
					get: function () {
						return defaultFragment$1$2;
					},
					enumerable: !1,
					configurable: !0,
				}),
				e
			);
		})(Shader$2),
		vertex$a =
			'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n',
		fragment$c =
			'varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n',
		tempMat$2 = new Matrix$2(),
		TextureMatrix$2 = (function () {
			function t(t, e) {
				(this._texture = t),
					(this.mapCoord = new Matrix$2()),
					(this.uClampFrame = new Float32Array(4)),
					(this.uClampOffset = new Float32Array(2)),
					(this._textureID = -1),
					(this._updateID = 0),
					(this.clampOffset = 0),
					(this.clampMargin = void 0 === e ? 0.5 : e),
					(this.isSimple = !1);
			}
			return (
				Object.defineProperty(t.prototype, 'texture', {
					get: function () {
						return this._texture;
					},
					set: function (t) {
						(this._texture = t), (this._textureID = -1);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.multiplyUvs = function (t, e) {
					void 0 === e && (e = t);
					for (var i = this.mapCoord, r = 0; r < t.length; r += 2) {
						var s = t[r],
							n = t[r + 1];
						(e[r] = s * i.a + n * i.c + i.tx),
							(e[r + 1] = s * i.b + n * i.d + i.ty);
					}
					return e;
				}),
				(t.prototype.update = function (t) {
					var e = this._texture;
					if (!e || !e.valid) return !1;
					if (!t && this._textureID === e._updateID) return !1;
					(this._textureID = e._updateID), this._updateID++;
					var i = e._uvs;
					this.mapCoord.set(
						i.x1 - i.x0,
						i.y1 - i.y0,
						i.x3 - i.x0,
						i.y3 - i.y0,
						i.x0,
						i.y0
					);
					var r = e.orig,
						s = e.trim;
					s &&
						(tempMat$2.set(
							r.width / s.width,
							0,
							0,
							r.height / s.height,
							-s.x / s.width,
							-s.y / s.height
						),
						this.mapCoord.append(tempMat$2));
					var n = e.baseTexture,
						a = this.uClampFrame,
						o = this.clampMargin / n.resolution,
						h = this.clampOffset;
					return (
						(a[0] = (e._frame.x + o + h) / n.width),
						(a[1] = (e._frame.y + o + h) / n.height),
						(a[2] = (e._frame.x + e._frame.width - o + h) / n.width),
						(a[3] = (e._frame.y + e._frame.height - o + h) / n.height),
						(this.uClampOffset[0] = h / n.realWidth),
						(this.uClampOffset[1] = h / n.realHeight),
						(this.isSimple =
							e._frame.width === n.width &&
							e._frame.height === n.height &&
							0 === e.rotate),
						!0
					);
				}),
				t
			);
		})(),
		SpriteMaskFilter$2 = (function (t) {
			function e(e, i, r) {
				var s = this,
					n = null;
				return (
					'string' != typeof e &&
						void 0 === i &&
						void 0 === r &&
						((n = e), (e = void 0), (i = void 0), (r = void 0)),
					((s =
						t.call(this, e || vertex$a, i || fragment$c, r) ||
						this).maskSprite = n),
					(s.maskMatrix = new Matrix$2()),
					s
				);
			}
			return (
				__extends$d(e, t),
				Object.defineProperty(e.prototype, 'maskSprite', {
					get: function () {
						return this._maskSprite;
					},
					set: function (t) {
						(this._maskSprite = t),
							this._maskSprite && (this._maskSprite.renderable = !1);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.apply = function (t, e, i, r) {
					var s = this._maskSprite,
						n = s._texture;
					n.valid &&
						(n.uvMatrix || (n.uvMatrix = new TextureMatrix$2(n, 0)),
						n.uvMatrix.update(),
						(this.uniforms.npmAlpha = n.baseTexture.alphaMode ? 0 : 1),
						(this.uniforms.mask = n),
						(this.uniforms.otherMatrix = t
							.calculateSpriteMatrix(this.maskMatrix, s)
							.prepend(n.uvMatrix.mapCoord)),
						(this.uniforms.alpha = s.worldAlpha),
						(this.uniforms.maskClamp = n.uvMatrix.uClampFrame),
						t.applyFilter(this, e, i, r));
				}),
				e
			);
		})(Filter$2),
		MaskSystem$2 = (function () {
			function t(t) {
				(this.renderer = t),
					(this.enableScissor = !0),
					(this.alphaMaskPool = []),
					(this.maskDataPool = []),
					(this.maskStack = []),
					(this.alphaMaskIndex = 0);
			}
			return (
				(t.prototype.setMaskStack = function (t) {
					(this.maskStack = t),
						this.renderer.scissor.setMaskStack(t),
						this.renderer.stencil.setMaskStack(t);
				}),
				(t.prototype.push = function (t, e) {
					var i = e;
					if (!i.isMaskData) {
						var r = this.maskDataPool.pop() || new MaskData$2();
						(r.pooled = !0), (r.maskObject = e), (i = r);
					}
					var s =
						0 !== this.maskStack.length
							? this.maskStack[this.maskStack.length - 1]
							: null;
					if (
						(i.copyCountersOrReset(s),
						i.autoDetect && this.detect(i),
						(i._target = t),
						i.type !== MASK_TYPES$9.SPRITE && this.maskStack.push(i),
						i.enabled)
					)
						switch (i.type) {
							case MASK_TYPES$9.SCISSOR:
								this.renderer.scissor.push(i);
								break;
							case MASK_TYPES$9.STENCIL:
								this.renderer.stencil.push(i);
								break;
							case MASK_TYPES$9.SPRITE:
								i.copyCountersOrReset(null), this.pushSpriteMask(i);
						}
					i.type === MASK_TYPES$9.SPRITE && this.maskStack.push(i);
				}),
				(t.prototype.pop = function (t) {
					var e = this.maskStack.pop();
					if (e && e._target === t) {
						if (e.enabled)
							switch (e.type) {
								case MASK_TYPES$9.SCISSOR:
									this.renderer.scissor.pop();
									break;
								case MASK_TYPES$9.STENCIL:
									this.renderer.stencil.pop(e.maskObject);
									break;
								case MASK_TYPES$9.SPRITE:
									this.popSpriteMask(e);
							}
						if (
							(e.reset(),
							e.pooled && this.maskDataPool.push(e),
							0 !== this.maskStack.length)
						) {
							var i = this.maskStack[this.maskStack.length - 1];
							i.type === MASK_TYPES$9.SPRITE &&
								i._filters &&
								(i._filters[0].maskSprite = i.maskObject);
						}
					}
				}),
				(t.prototype.detect = function (t) {
					t.maskObject.isSprite
						? (t.type = MASK_TYPES$9.SPRITE)
						: this.enableScissor && this.renderer.scissor.testScissor(t)
						? (t.type = MASK_TYPES$9.SCISSOR)
						: (t.type = MASK_TYPES$9.STENCIL);
				}),
				(t.prototype.pushSpriteMask = function (t) {
					var e,
						i,
						r = t.maskObject,
						s = t._target,
						n = t._filters;
					n ||
						(n = this.alphaMaskPool[this.alphaMaskIndex]) ||
						(n = this.alphaMaskPool[this.alphaMaskIndex] =
							[new SpriteMaskFilter$2()]);
					var a,
						o,
						h = this.renderer,
						u = h.renderTexture;
					if (u.current) {
						var l = u.current;
						(a = t.resolution || l.resolution),
							(o =
								null !== (e = t.multisample) && void 0 !== e
									? e
									: l.multisample);
					} else
						(a = t.resolution || h.resolution),
							(o =
								null !== (i = t.multisample) && void 0 !== i
									? i
									: h.multisample);
					(n[0].resolution = a), (n[0].multisample = o), (n[0].maskSprite = r);
					var c = s.filterArea;
					(s.filterArea = r.getBounds(!0)),
						h.filter.push(s, n),
						(s.filterArea = c),
						t._filters || this.alphaMaskIndex++;
				}),
				(t.prototype.popSpriteMask = function (t) {
					this.renderer.filter.pop(),
						t._filters
							? (t._filters[0].maskSprite = null)
							: (this.alphaMaskIndex--,
							  (this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null));
				}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})(),
		AbstractMaskSystem$2 = (function () {
			function t(t) {
				(this.renderer = t), (this.maskStack = []), (this.glConst = 0);
			}
			return (
				(t.prototype.getStackLength = function () {
					return this.maskStack.length;
				}),
				(t.prototype.setMaskStack = function (t) {
					var e = this.renderer.gl,
						i = this.getStackLength();
					this.maskStack = t;
					var r = this.getStackLength();
					r !== i &&
						(0 === r
							? e.disable(this.glConst)
							: (e.enable(this.glConst), this._useCurrent()));
				}),
				(t.prototype._useCurrent = function () {}),
				(t.prototype.destroy = function () {
					(this.renderer = null), (this.maskStack = null);
				}),
				t
			);
		})(),
		tempMatrix$1$2 = new Matrix$2(),
		ScissorSystem$2 = (function (t) {
			function e(e) {
				var i = t.call(this, e) || this;
				return (i.glConst = WebGLRenderingContext.SCISSOR_TEST), i;
			}
			return (
				__extends$d(e, t),
				(e.prototype.getStackLength = function () {
					var t = this.maskStack[this.maskStack.length - 1];
					return t ? t._scissorCounter : 0;
				}),
				(e.prototype.calcScissorRect = function (t) {
					if (!t._scissorRectLocal) {
						var e = t._scissorRect,
							i = t.maskObject,
							r = this.renderer,
							s = r.renderTexture;
						i.renderable = !0;
						var n = i.getBounds();
						this.roundFrameToPixels(
							n,
							s.current ? s.current.resolution : r.resolution,
							s.sourceFrame,
							s.destinationFrame,
							r.projection.transform
						),
							(i.renderable = !1),
							e && n.fit(e),
							(t._scissorRectLocal = n);
					}
				}),
				(e.isMatrixRotated = function (t) {
					if (!t) return !1;
					var e = t.a,
						i = t.b,
						r = t.c,
						s = t.d;
					return (
						(Math.abs(i) > 1e-4 || Math.abs(r) > 1e-4) &&
						(Math.abs(e) > 1e-4 || Math.abs(s) > 1e-4)
					);
				}),
				(e.prototype.testScissor = function (t) {
					var i = t.maskObject;
					if (!i.isFastRect || !i.isFastRect()) return !1;
					if (e.isMatrixRotated(i.worldTransform)) return !1;
					if (e.isMatrixRotated(this.renderer.projection.transform)) return !1;
					this.calcScissorRect(t);
					var r = t._scissorRectLocal;
					return r.width > 0 && r.height > 0;
				}),
				(e.prototype.roundFrameToPixels = function (t, i, r, s, n) {
					e.isMatrixRotated(n) ||
						((n = n ? tempMatrix$1$2.copyFrom(n) : tempMatrix$1$2.identity())
							.translate(-r.x, -r.y)
							.scale(s.width / r.width, s.height / r.height)
							.translate(s.x, s.y),
						this.renderer.filter.transformAABB(n, t),
						t.fit(s),
						(t.x = Math.round(t.x * i)),
						(t.y = Math.round(t.y * i)),
						(t.width = Math.round(t.width * i)),
						(t.height = Math.round(t.height * i)));
				}),
				(e.prototype.push = function (t) {
					t._scissorRectLocal || this.calcScissorRect(t);
					var e = this.renderer.gl;
					t._scissorRect || e.enable(e.SCISSOR_TEST),
						t._scissorCounter++,
						(t._scissorRect = t._scissorRectLocal),
						this._useCurrent();
				}),
				(e.prototype.pop = function () {
					var t = this.renderer.gl;
					this.getStackLength() > 0
						? this._useCurrent()
						: t.disable(t.SCISSOR_TEST);
				}),
				(e.prototype._useCurrent = function () {
					var t,
						e = this.maskStack[this.maskStack.length - 1]._scissorRect;
					(t = this.renderer.renderTexture.current
						? e.y
						: this.renderer.height - e.height - e.y),
						this.renderer.gl.scissor(e.x, t, e.width, e.height);
				}),
				e
			);
		})(AbstractMaskSystem$2),
		StencilSystem$2 = (function (t) {
			function e(e) {
				var i = t.call(this, e) || this;
				return (i.glConst = WebGLRenderingContext.STENCIL_TEST), i;
			}
			return (
				__extends$d(e, t),
				(e.prototype.getStackLength = function () {
					var t = this.maskStack[this.maskStack.length - 1];
					return t ? t._stencilCounter : 0;
				}),
				(e.prototype.push = function (t) {
					var e = t.maskObject,
						i = this.renderer.gl,
						r = t._stencilCounter;
					0 === r &&
						(this.renderer.framebuffer.forceStencil(),
						i.clearStencil(0),
						i.clear(i.STENCIL_BUFFER_BIT),
						i.enable(i.STENCIL_TEST)),
						t._stencilCounter++,
						i.colorMask(!1, !1, !1, !1),
						i.stencilFunc(i.EQUAL, r, 4294967295),
						i.stencilOp(i.KEEP, i.KEEP, i.INCR),
						(e.renderable = !0),
						e.render(this.renderer),
						this.renderer.batch.flush(),
						(e.renderable = !1),
						this._useCurrent();
				}),
				(e.prototype.pop = function (t) {
					var e = this.renderer.gl;
					0 === this.getStackLength()
						? e.disable(e.STENCIL_TEST)
						: (e.colorMask(!1, !1, !1, !1),
						  e.stencilOp(e.KEEP, e.KEEP, e.DECR),
						  (t.renderable = !0),
						  t.render(this.renderer),
						  this.renderer.batch.flush(),
						  (t.renderable = !1),
						  this._useCurrent());
				}),
				(e.prototype._useCurrent = function () {
					var t = this.renderer.gl;
					t.colorMask(!0, !0, !0, !0),
						t.stencilFunc(t.EQUAL, this.getStackLength(), 4294967295),
						t.stencilOp(t.KEEP, t.KEEP, t.KEEP);
				}),
				e
			);
		})(AbstractMaskSystem$2),
		ProjectionSystem$2 = (function () {
			function t(t) {
				(this.renderer = t),
					(this.destinationFrame = null),
					(this.sourceFrame = null),
					(this.defaultFrame = null),
					(this.projectionMatrix = new Matrix$2()),
					(this.transform = null);
			}
			return (
				(t.prototype.update = function (t, e, i, r) {
					(this.destinationFrame =
						t || this.destinationFrame || this.defaultFrame),
						(this.sourceFrame = e || this.sourceFrame || t),
						this.calculateProjection(
							this.destinationFrame,
							this.sourceFrame,
							i,
							r
						),
						this.transform && this.projectionMatrix.append(this.transform);
					var s = this.renderer;
					(s.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix),
						s.globalUniforms.update(),
						s.shader.shader &&
							s.shader.syncUniformGroup(s.shader.shader.uniforms.globals);
				}),
				(t.prototype.calculateProjection = function (t, e, i, r) {
					var s = this.projectionMatrix,
						n = r ? -1 : 1;
					s.identity(),
						(s.a = (1 / e.width) * 2),
						(s.d = n * ((1 / e.height) * 2)),
						(s.tx = -1 - e.x * s.a),
						(s.ty = -n - e.y * s.d);
				}),
				(t.prototype.setTransform = function (t) {}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})(),
		tempRect$2 = new Rectangle$3(),
		tempRect2$2 = new Rectangle$3(),
		RenderTextureSystem$2 = (function () {
			function t(t) {
				(this.renderer = t),
					(this.clearColor = t._backgroundColorRgba),
					(this.defaultMaskStack = []),
					(this.current = null),
					(this.sourceFrame = new Rectangle$3()),
					(this.destinationFrame = new Rectangle$3()),
					(this.viewportFrame = new Rectangle$3());
			}
			return (
				(t.prototype.bind = function (t, e, i) {
					void 0 === t && (t = null);
					var r,
						s,
						n,
						a = this.renderer;
					(this.current = t),
						t
							? ((n = (r = t.baseTexture).resolution),
							  e ||
									((tempRect$2.width = t.frame.width),
									(tempRect$2.height = t.frame.height),
									(e = tempRect$2)),
							  i ||
									((tempRect2$2.x = t.frame.x),
									(tempRect2$2.y = t.frame.y),
									(tempRect2$2.width = e.width),
									(tempRect2$2.height = e.height),
									(i = tempRect2$2)),
							  (s = r.framebuffer))
							: ((n = a.resolution),
							  e ||
									((tempRect$2.width = a.screen.width),
									(tempRect$2.height = a.screen.height),
									(e = tempRect$2)),
							  i ||
									(((i = tempRect$2).width = e.width), (i.height = e.height)));
					var o = this.viewportFrame;
					(o.x = i.x * n),
						(o.y = i.y * n),
						(o.width = i.width * n),
						(o.height = i.height * n),
						t || (o.y = a.view.height - (o.y + o.height)),
						o.ceil(),
						this.renderer.framebuffer.bind(s, o),
						this.renderer.projection.update(i, e, n, !s),
						t
							? this.renderer.mask.setMaskStack(r.maskStack)
							: this.renderer.mask.setMaskStack(this.defaultMaskStack),
						this.sourceFrame.copyFrom(e),
						this.destinationFrame.copyFrom(i);
				}),
				(t.prototype.clear = function (t, e) {
					t = this.current
						? t || this.current.baseTexture.clearColor
						: t || this.clearColor;
					var i = this.destinationFrame,
						r = this.current ? this.current.baseTexture : this.renderer.screen,
						s = i.width !== r.width || i.height !== r.height;
					if (s) {
						var n = this.viewportFrame,
							a = n.x,
							o = n.y,
							h = n.width,
							u = n.height;
						(a = Math.round(a)),
							(o = Math.round(o)),
							(h = Math.round(h)),
							(u = Math.round(u)),
							this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST),
							this.renderer.gl.scissor(a, o, h, u);
					}
					this.renderer.framebuffer.clear(t[0], t[1], t[2], t[3], e),
						s && this.renderer.scissor.pop();
				}),
				(t.prototype.resize = function () {
					this.bind(null);
				}),
				(t.prototype.reset = function () {
					this.bind(null);
				}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})();
	function uboUpdate$2(t, e, i, r, s) {
		i.buffer.update(s);
	}
	var UBO_TO_SINGLE_SETTERS$2 = {
			float: '\n        data[offset] = v;\n    ',
			vec2: '\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    ',
			vec3: '\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    ',
			vec4: '\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    ',
			mat2: '\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    ',
			mat3: '\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    ',
			mat4: '\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    ',
		},
		GLSL_TO_STD40_SIZE$2 = {
			float: 4,
			vec2: 8,
			vec3: 12,
			vec4: 16,
			int: 4,
			ivec2: 8,
			ivec3: 12,
			ivec4: 16,
			uint: 4,
			uvec2: 8,
			uvec3: 12,
			uvec4: 16,
			bool: 4,
			bvec2: 8,
			bvec3: 12,
			bvec4: 16,
			mat2: 32,
			mat3: 48,
			mat4: 64,
		};
	function createUBOElements$2(t) {
		for (
			var e = t.map(function (t) {
					return { data: t, offset: 0, dataLen: 0, dirty: 0 };
				}),
				i = 0,
				r = 0,
				s = 0,
				n = 0;
			n < e.length;
			n++
		) {
			var a = e[n];
			if (
				((i = GLSL_TO_STD40_SIZE$2[a.data.type]),
				a.data.size > 1 && (i = Math.max(i, 16) * a.data.size),
				(a.dataLen = i),
				r % i != 0 && r < 16)
			) {
				var o = (r % i) % 16;
				(r += o), (s += o);
			}
			r + i > 16
				? ((s = 16 * Math.ceil(s / 16)), (a.offset = s), (s += i), (r = i))
				: ((a.offset = s), (r += i), (s += i));
		}
		return { uboElements: e, size: (s = 16 * Math.ceil(s / 16)) };
	}
	function getUBOData$2(t, e) {
		var i = [];
		for (var r in t) e[r] && i.push(e[r]);
		return (
			i.sort(function (t, e) {
				return t.index - e.index;
			}),
			i
		);
	}
	function generateUniformBufferSync$2(t, e) {
		if (!t.autoManage) return { size: 0, syncFunc: uboUpdate$2 };
		for (
			var i = createUBOElements$2(getUBOData$2(t.uniforms, e)),
				r = i.uboElements,
				s = i.size,
				n = [
					'\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    ',
				],
				a = 0;
			a < r.length;
			a++
		) {
			for (
				var o = r[a],
					h = t.uniforms[o.data.name],
					u = o.data.name,
					l = !1,
					c = 0;
				c < uniformParsers$2.length;
				c++
			) {
				var d = uniformParsers$2[c];
				if (d.codeUbo && d.test(o.data, h)) {
					n.push(
						'offset = ' + o.offset / 4 + ';',
						uniformParsers$2[c].codeUbo(o.data.name, h)
					),
						(l = !0);
					break;
				}
			}
			if (!l)
				if (o.data.size > 1) {
					var p = mapSize$2(o.data.type),
						f = Math.max(GLSL_TO_STD40_SIZE$2[o.data.type] / 16, 1),
						m = p / f,
						_ = (4 - (m % 4)) % 4;
					n.push(
						'\n                cv = ud.' +
							u +
							'.value;\n                v = uv.' +
							u +
							';\n                offset = ' +
							o.offset / 4 +
							';\n\n                t = 0;\n\n                for(var i=0; i < ' +
							o.data.size * f +
							'; i++)\n                {\n                    for(var j = 0; j < ' +
							m +
							'; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += ' +
							_ +
							';\n                }\n\n                '
					);
				} else {
					var g = UBO_TO_SINGLE_SETTERS$2[o.data.type];
					n.push(
						'\n                cv = ud.' +
							u +
							'.value;\n                v = uv.' +
							u +
							';\n                offset = ' +
							o.offset / 4 +
							';\n                ' +
							g +
							';\n                '
					);
				}
		}
		return (
			n.push('\n       renderer.buffer.update(buffer);\n    '),
			{
				size: s,
				syncFunc: new Function(
					'ud',
					'uv',
					'renderer',
					'syncData',
					'buffer',
					n.join('\n')
				),
			}
		);
	}
	var GLProgram$2 = (function () {
		function t(t, e) {
			(this.program = t),
				(this.uniformData = e),
				(this.uniformGroups = {}),
				(this.uniformDirtyGroups = {}),
				(this.uniformBufferBindings = {});
		}
		return (
			(t.prototype.destroy = function () {
				(this.uniformData = null),
					(this.uniformGroups = null),
					(this.uniformDirtyGroups = null),
					(this.uniformBufferBindings = null),
					(this.program = null);
			}),
			t
		);
	})();
	function getAttributeData$2(t, e) {
		for (
			var i = {}, r = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES), s = 0;
			s < r;
			s++
		) {
			var n = e.getActiveAttrib(t, s);
			if (0 !== n.name.indexOf('gl_')) {
				var a = mapType$2(e, n.type),
					o = {
						type: a,
						name: n.name,
						size: mapSize$2(a),
						location: e.getAttribLocation(t, n.name),
					};
				i[n.name] = o;
			}
		}
		return i;
	}
	function getUniformData$2(t, e) {
		for (
			var i = {}, r = e.getProgramParameter(t, e.ACTIVE_UNIFORMS), s = 0;
			s < r;
			s++
		) {
			var n = e.getActiveUniform(t, s),
				a = n.name.replace(/\[.*?\]$/, ''),
				o = !!n.name.match(/\[.*?\]$/),
				h = mapType$2(e, n.type);
			i[a] = {
				name: a,
				index: s,
				type: h,
				size: n.size,
				isArray: o,
				value: defaultValue$2(h, n.size),
			};
		}
		return i;
	}
	function generateProgram$2(t, e) {
		var i = compileShader$2(t, t.VERTEX_SHADER, e.vertexSrc),
			r = compileShader$2(t, t.FRAGMENT_SHADER, e.fragmentSrc),
			s = t.createProgram();
		if (
			(t.attachShader(s, i),
			t.attachShader(s, r),
			t.linkProgram(s),
			t.getProgramParameter(s, t.LINK_STATUS) || logProgramError$2(t, s, i, r),
			(e.attributeData = getAttributeData$2(s, t)),
			(e.uniformData = getUniformData$2(s, t)),
			!/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e.vertexSrc))
		) {
			var n = Object.keys(e.attributeData);
			n.sort(function (t, e) {
				return t > e ? 1 : -1;
			});
			for (var a = 0; a < n.length; a++)
				(e.attributeData[n[a]].location = a), t.bindAttribLocation(s, a, n[a]);
			t.linkProgram(s);
		}
		t.deleteShader(i), t.deleteShader(r);
		var o = {};
		for (var a in e.uniformData) {
			var h = e.uniformData[a];
			o[a] = {
				location: t.getUniformLocation(s, a),
				value: defaultValue$2(h.type, h.size),
			};
		}
		return new GLProgram$2(s, o);
	}
	var UID$6 = 0,
		defaultSyncData$2 = { textureCount: 0, uboCount: 0 },
		ShaderSystem$2 = (function () {
			function t(t) {
				(this.destroyed = !1),
					(this.renderer = t),
					this.systemCheck(),
					(this.gl = null),
					(this.shader = null),
					(this.program = null),
					(this.cache = {}),
					(this._uboCache = {}),
					(this.id = UID$6++);
			}
			return (
				(t.prototype.systemCheck = function () {
					if (!unsafeEvalSupported$2())
						throw new Error(
							'Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.'
						);
				}),
				(t.prototype.contextChange = function (t) {
					(this.gl = t), this.reset();
				}),
				(t.prototype.bind = function (t, e) {
					t.uniforms.globals = this.renderer.globalUniforms;
					var i = t.program,
						r =
							i.glPrograms[this.renderer.CONTEXT_UID] ||
							this.generateProgram(t);
					return (
						(this.shader = t),
						this.program !== i &&
							((this.program = i), this.gl.useProgram(r.program)),
						e ||
							((defaultSyncData$2.textureCount = 0),
							(defaultSyncData$2.uboCount = 0),
							this.syncUniformGroup(t.uniformGroup, defaultSyncData$2)),
						r
					);
				}),
				(t.prototype.setUniforms = function (t) {
					var e = this.shader.program,
						i = e.glPrograms[this.renderer.CONTEXT_UID];
					e.syncUniforms(i.uniformData, t, this.renderer);
				}),
				(t.prototype.syncUniformGroup = function (t, e) {
					var i = this.getGlProgram();
					(t.static && t.dirtyId === i.uniformDirtyGroups[t.id]) ||
						((i.uniformDirtyGroups[t.id] = t.dirtyId),
						this.syncUniforms(t, i, e));
				}),
				(t.prototype.syncUniforms = function (t, e, i) {
					(t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t))(
						e.uniformData,
						t.uniforms,
						this.renderer,
						i
					);
				}),
				(t.prototype.createSyncGroups = function (t) {
					var e = this.getSignature(t, this.shader.program.uniformData, 'u');
					return (
						this.cache[e] ||
							(this.cache[e] = generateUniformsSync$2(
								t,
								this.shader.program.uniformData
							)),
						(t.syncUniforms[this.shader.program.id] = this.cache[e]),
						t.syncUniforms[this.shader.program.id]
					);
				}),
				(t.prototype.syncUniformBufferGroup = function (t, e) {
					var i = this.getGlProgram();
					if (!t.static || 0 !== t.dirtyId || !i.uniformGroups[t.id]) {
						t.dirtyId = 0;
						var r =
							i.uniformGroups[t.id] || this.createSyncBufferGroup(t, i, e);
						t.buffer.update(),
							r(
								i.uniformData,
								t.uniforms,
								this.renderer,
								defaultSyncData$2,
								t.buffer
							);
					}
					this.renderer.buffer.bindBufferBase(
						t.buffer,
						i.uniformBufferBindings[e]
					);
				}),
				(t.prototype.createSyncBufferGroup = function (t, e, i) {
					var r = this.renderer.gl;
					this.renderer.buffer.bind(t.buffer);
					var s = this.gl.getUniformBlockIndex(e.program, i);
					(e.uniformBufferBindings[i] = this.shader.uniformBindCount),
						r.uniformBlockBinding(e.program, s, this.shader.uniformBindCount),
						this.shader.uniformBindCount++;
					var n = this.getSignature(t, this.shader.program.uniformData, 'ubo'),
						a = this._uboCache[n];
					if (
						(a ||
							(a = this._uboCache[n] =
								generateUniformBufferSync$2(
									t,
									this.shader.program.uniformData
								)),
						t.autoManage)
					) {
						var o = new Float32Array(a.size / 4);
						t.buffer.update(o);
					}
					return (e.uniformGroups[t.id] = a.syncFunc), e.uniformGroups[t.id];
				}),
				(t.prototype.getSignature = function (t, e, i) {
					var r = t.uniforms,
						s = [i + '-'];
					for (var n in r) s.push(n), e[n] && s.push(e[n].type);
					return s.join('-');
				}),
				(t.prototype.getGlProgram = function () {
					return this.shader
						? this.shader.program.glPrograms[this.renderer.CONTEXT_UID]
						: null;
				}),
				(t.prototype.generateProgram = function (t) {
					var e = this.gl,
						i = t.program,
						r = generateProgram$2(e, i);
					return (i.glPrograms[this.renderer.CONTEXT_UID] = r), r;
				}),
				(t.prototype.reset = function () {
					(this.program = null), (this.shader = null);
				}),
				(t.prototype.destroy = function () {
					(this.renderer = null), (this.destroyed = !0);
				}),
				t
			);
		})();
	function mapWebGLBlendModesToPixi$2(t, e) {
		return (
			void 0 === e && (e = []),
			(e[BLEND_MODES$9.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.ADD] = [t.ONE, t.ONE]),
			(e[BLEND_MODES$9.MULTIPLY] = [
				t.DST_COLOR,
				t.ONE_MINUS_SRC_ALPHA,
				t.ONE,
				t.ONE_MINUS_SRC_ALPHA,
			]),
			(e[BLEND_MODES$9.SCREEN] = [
				t.ONE,
				t.ONE_MINUS_SRC_COLOR,
				t.ONE,
				t.ONE_MINUS_SRC_ALPHA,
			]),
			(e[BLEND_MODES$9.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.NONE] = [0, 0]),
			(e[BLEND_MODES$9.NORMAL_NPM] = [
				t.SRC_ALPHA,
				t.ONE_MINUS_SRC_ALPHA,
				t.ONE,
				t.ONE_MINUS_SRC_ALPHA,
			]),
			(e[BLEND_MODES$9.ADD_NPM] = [t.SRC_ALPHA, t.ONE, t.ONE, t.ONE]),
			(e[BLEND_MODES$9.SCREEN_NPM] = [
				t.SRC_ALPHA,
				t.ONE_MINUS_SRC_COLOR,
				t.ONE,
				t.ONE_MINUS_SRC_ALPHA,
			]),
			(e[BLEND_MODES$9.SRC_IN] = [t.DST_ALPHA, t.ZERO]),
			(e[BLEND_MODES$9.SRC_OUT] = [t.ONE_MINUS_DST_ALPHA, t.ZERO]),
			(e[BLEND_MODES$9.SRC_ATOP] = [t.DST_ALPHA, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.DST_OVER] = [t.ONE_MINUS_DST_ALPHA, t.ONE]),
			(e[BLEND_MODES$9.DST_IN] = [t.ZERO, t.SRC_ALPHA]),
			(e[BLEND_MODES$9.DST_OUT] = [t.ZERO, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.DST_ATOP] = [t.ONE_MINUS_DST_ALPHA, t.SRC_ALPHA]),
			(e[BLEND_MODES$9.XOR] = [t.ONE_MINUS_DST_ALPHA, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$9.SUBTRACT] = [
				t.ONE,
				t.ONE,
				t.ONE,
				t.ONE,
				t.FUNC_REVERSE_SUBTRACT,
				t.FUNC_ADD,
			]),
			e
		);
	}
	var BLEND$3 = 0,
		OFFSET$3 = 1,
		CULLING$3 = 2,
		DEPTH_TEST$3 = 3,
		WINDING$3 = 4,
		DEPTH_MASK$3 = 5,
		StateSystem$2 = (function () {
			function t() {
				(this.gl = null),
					(this.stateId = 0),
					(this.polygonOffset = 0),
					(this.blendMode = BLEND_MODES$9.NONE),
					(this._blendEq = !1),
					(this.map = []),
					(this.map[BLEND$3] = this.setBlend),
					(this.map[OFFSET$3] = this.setOffset),
					(this.map[CULLING$3] = this.setCullFace),
					(this.map[DEPTH_TEST$3] = this.setDepthTest),
					(this.map[WINDING$3] = this.setFrontFace),
					(this.map[DEPTH_MASK$3] = this.setDepthMask),
					(this.checks = []),
					(this.defaultState = new State$2()),
					(this.defaultState.blend = !0);
			}
			return (
				(t.prototype.contextChange = function (t) {
					(this.gl = t),
						(this.blendModes = mapWebGLBlendModesToPixi$2(t)),
						this.set(this.defaultState),
						this.reset();
				}),
				(t.prototype.set = function (t) {
					if (((t = t || this.defaultState), this.stateId !== t.data)) {
						for (var e = this.stateId ^ t.data, i = 0; e; )
							1 & e && this.map[i].call(this, !!(t.data & (1 << i))),
								(e >>= 1),
								i++;
						this.stateId = t.data;
					}
					for (i = 0; i < this.checks.length; i++) this.checks[i](this, t);
				}),
				(t.prototype.forceState = function (t) {
					t = t || this.defaultState;
					for (var e = 0; e < this.map.length; e++)
						this.map[e].call(this, !!(t.data & (1 << e)));
					for (e = 0; e < this.checks.length; e++) this.checks[e](this, t);
					this.stateId = t.data;
				}),
				(t.prototype.setBlend = function (e) {
					this.updateCheck(t.checkBlendMode, e),
						this.gl[e ? 'enable' : 'disable'](this.gl.BLEND);
				}),
				(t.prototype.setOffset = function (e) {
					this.updateCheck(t.checkPolygonOffset, e),
						this.gl[e ? 'enable' : 'disable'](this.gl.POLYGON_OFFSET_FILL);
				}),
				(t.prototype.setDepthTest = function (t) {
					this.gl[t ? 'enable' : 'disable'](this.gl.DEPTH_TEST);
				}),
				(t.prototype.setDepthMask = function (t) {
					this.gl.depthMask(t);
				}),
				(t.prototype.setCullFace = function (t) {
					this.gl[t ? 'enable' : 'disable'](this.gl.CULL_FACE);
				}),
				(t.prototype.setFrontFace = function (t) {
					this.gl.frontFace(this.gl[t ? 'CW' : 'CCW']);
				}),
				(t.prototype.setBlendMode = function (t) {
					if (t !== this.blendMode) {
						this.blendMode = t;
						var e = this.blendModes[t],
							i = this.gl;
						2 === e.length
							? i.blendFunc(e[0], e[1])
							: i.blendFuncSeparate(e[0], e[1], e[2], e[3]),
							6 === e.length
								? ((this._blendEq = !0), i.blendEquationSeparate(e[4], e[5]))
								: this._blendEq &&
								  ((this._blendEq = !1),
								  i.blendEquationSeparate(i.FUNC_ADD, i.FUNC_ADD));
					}
				}),
				(t.prototype.setPolygonOffset = function (t, e) {
					this.gl.polygonOffset(t, e);
				}),
				(t.prototype.reset = function () {
					this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1),
						this.forceState(this.defaultState),
						(this._blendEq = !0),
						(this.blendMode = -1),
						this.setBlendMode(0);
				}),
				(t.prototype.updateCheck = function (t, e) {
					var i = this.checks.indexOf(t);
					e && -1 === i
						? this.checks.push(t)
						: e || -1 === i || this.checks.splice(i, 1);
				}),
				(t.checkBlendMode = function (t, e) {
					t.setBlendMode(e.blendMode);
				}),
				(t.checkPolygonOffset = function (t, e) {
					t.setPolygonOffset(1, e.polygonOffset);
				}),
				(t.prototype.destroy = function () {
					this.gl = null;
				}),
				t
			);
		})(),
		TextureGCSystem$2 = (function () {
			function t(t) {
				(this.renderer = t),
					(this.count = 0),
					(this.checkCount = 0),
					(this.maxIdle = settings$4.GC_MAX_IDLE),
					(this.checkCountMax = settings$4.GC_MAX_CHECK_COUNT),
					(this.mode = settings$4.GC_MODE);
			}
			return (
				(t.prototype.postrender = function () {
					this.renderer.renderingToScreen &&
						(this.count++,
						this.mode !== GC_MODES$9.MANUAL &&
							(this.checkCount++,
							this.checkCount > this.checkCountMax &&
								((this.checkCount = 0), this.run())));
				}),
				(t.prototype.run = function () {
					for (
						var t = this.renderer.texture, e = t.managedTextures, i = !1, r = 0;
						r < e.length;
						r++
					) {
						var s = e[r];
						!s.framebuffer &&
							this.count - s.touched > this.maxIdle &&
							(t.destroyTexture(s, !0), (e[r] = null), (i = !0));
					}
					if (i) {
						var n = 0;
						for (r = 0; r < e.length; r++) null !== e[r] && (e[n++] = e[r]);
						e.length = n;
					}
				}),
				(t.prototype.unload = function (t) {
					var e = this.renderer.texture,
						i = t._texture;
					i && !i.framebuffer && e.destroyTexture(i);
					for (var r = t.children.length - 1; r >= 0; r--)
						this.unload(t.children[r]);
				}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})();
	function mapTypeAndFormatToInternalFormat$2(t) {
		var e, i, r, s, n, a, o, h, u, l, c, d, p, f, m, _, g, E, y, T, v, S, x;
		return (
			'WebGL2RenderingContext' in globalThis &&
			t instanceof globalThis.WebGL2RenderingContext
				? (((e = {})[TYPES$9.UNSIGNED_BYTE] =
						(((i = {})[FORMATS$9.RGBA] = t.RGBA8),
						(i[FORMATS$9.RGB] = t.RGB8),
						(i[FORMATS$9.RG] = t.RG8),
						(i[FORMATS$9.RED] = t.R8),
						(i[FORMATS$9.RGBA_INTEGER] = t.RGBA8UI),
						(i[FORMATS$9.RGB_INTEGER] = t.RGB8UI),
						(i[FORMATS$9.RG_INTEGER] = t.RG8UI),
						(i[FORMATS$9.RED_INTEGER] = t.R8UI),
						(i[FORMATS$9.ALPHA] = t.ALPHA),
						(i[FORMATS$9.LUMINANCE] = t.LUMINANCE),
						(i[FORMATS$9.LUMINANCE_ALPHA] = t.LUMINANCE_ALPHA),
						i)),
				  (e[TYPES$9.BYTE] =
						(((r = {})[FORMATS$9.RGBA] = t.RGBA8_SNORM),
						(r[FORMATS$9.RGB] = t.RGB8_SNORM),
						(r[FORMATS$9.RG] = t.RG8_SNORM),
						(r[FORMATS$9.RED] = t.R8_SNORM),
						(r[FORMATS$9.RGBA_INTEGER] = t.RGBA8I),
						(r[FORMATS$9.RGB_INTEGER] = t.RGB8I),
						(r[FORMATS$9.RG_INTEGER] = t.RG8I),
						(r[FORMATS$9.RED_INTEGER] = t.R8I),
						r)),
				  (e[TYPES$9.UNSIGNED_SHORT] =
						(((s = {})[FORMATS$9.RGBA_INTEGER] = t.RGBA16UI),
						(s[FORMATS$9.RGB_INTEGER] = t.RGB16UI),
						(s[FORMATS$9.RG_INTEGER] = t.RG16UI),
						(s[FORMATS$9.RED_INTEGER] = t.R16UI),
						(s[FORMATS$9.DEPTH_COMPONENT] = t.DEPTH_COMPONENT16),
						s)),
				  (e[TYPES$9.SHORT] =
						(((n = {})[FORMATS$9.RGBA_INTEGER] = t.RGBA16I),
						(n[FORMATS$9.RGB_INTEGER] = t.RGB16I),
						(n[FORMATS$9.RG_INTEGER] = t.RG16I),
						(n[FORMATS$9.RED_INTEGER] = t.R16I),
						n)),
				  (e[TYPES$9.UNSIGNED_INT] =
						(((a = {})[FORMATS$9.RGBA_INTEGER] = t.RGBA32UI),
						(a[FORMATS$9.RGB_INTEGER] = t.RGB32UI),
						(a[FORMATS$9.RG_INTEGER] = t.RG32UI),
						(a[FORMATS$9.RED_INTEGER] = t.R32UI),
						(a[FORMATS$9.DEPTH_COMPONENT] = t.DEPTH_COMPONENT24),
						a)),
				  (e[TYPES$9.INT] =
						(((o = {})[FORMATS$9.RGBA_INTEGER] = t.RGBA32I),
						(o[FORMATS$9.RGB_INTEGER] = t.RGB32I),
						(o[FORMATS$9.RG_INTEGER] = t.RG32I),
						(o[FORMATS$9.RED_INTEGER] = t.R32I),
						o)),
				  (e[TYPES$9.FLOAT] =
						(((h = {})[FORMATS$9.RGBA] = t.RGBA32F),
						(h[FORMATS$9.RGB] = t.RGB32F),
						(h[FORMATS$9.RG] = t.RG32F),
						(h[FORMATS$9.RED] = t.R32F),
						(h[FORMATS$9.DEPTH_COMPONENT] = t.DEPTH_COMPONENT32F),
						h)),
				  (e[TYPES$9.HALF_FLOAT] =
						(((u = {})[FORMATS$9.RGBA] = t.RGBA16F),
						(u[FORMATS$9.RGB] = t.RGB16F),
						(u[FORMATS$9.RG] = t.RG16F),
						(u[FORMATS$9.RED] = t.R16F),
						u)),
				  (e[TYPES$9.UNSIGNED_SHORT_5_6_5] =
						(((l = {})[FORMATS$9.RGB] = t.RGB565), l)),
				  (e[TYPES$9.UNSIGNED_SHORT_4_4_4_4] =
						(((c = {})[FORMATS$9.RGBA] = t.RGBA4), c)),
				  (e[TYPES$9.UNSIGNED_SHORT_5_5_5_1] =
						(((d = {})[FORMATS$9.RGBA] = t.RGB5_A1), d)),
				  (e[TYPES$9.UNSIGNED_INT_2_10_10_10_REV] =
						(((p = {})[FORMATS$9.RGBA] = t.RGB10_A2),
						(p[FORMATS$9.RGBA_INTEGER] = t.RGB10_A2UI),
						p)),
				  (e[TYPES$9.UNSIGNED_INT_10F_11F_11F_REV] =
						(((f = {})[FORMATS$9.RGB] = t.R11F_G11F_B10F), f)),
				  (e[TYPES$9.UNSIGNED_INT_5_9_9_9_REV] =
						(((m = {})[FORMATS$9.RGB] = t.RGB9_E5), m)),
				  (e[TYPES$9.UNSIGNED_INT_24_8] =
						(((_ = {})[FORMATS$9.DEPTH_STENCIL] = t.DEPTH24_STENCIL8), _)),
				  (e[TYPES$9.FLOAT_32_UNSIGNED_INT_24_8_REV] =
						(((g = {})[FORMATS$9.DEPTH_STENCIL] = t.DEPTH32F_STENCIL8), g)),
				  (x = e))
				: (((E = {})[TYPES$9.UNSIGNED_BYTE] =
						(((y = {})[FORMATS$9.RGBA] = t.RGBA),
						(y[FORMATS$9.RGB] = t.RGB),
						(y[FORMATS$9.ALPHA] = t.ALPHA),
						(y[FORMATS$9.LUMINANCE] = t.LUMINANCE),
						(y[FORMATS$9.LUMINANCE_ALPHA] = t.LUMINANCE_ALPHA),
						y)),
				  (E[TYPES$9.UNSIGNED_SHORT_5_6_5] =
						(((T = {})[FORMATS$9.RGB] = t.RGB), T)),
				  (E[TYPES$9.UNSIGNED_SHORT_4_4_4_4] =
						(((v = {})[FORMATS$9.RGBA] = t.RGBA), v)),
				  (E[TYPES$9.UNSIGNED_SHORT_5_5_5_1] =
						(((S = {})[FORMATS$9.RGBA] = t.RGBA), S)),
				  (x = E)),
			x
		);
	}
	var GLTexture$2 = function (t) {
			(this.texture = t),
				(this.width = -1),
				(this.height = -1),
				(this.dirtyId = -1),
				(this.dirtyStyleId = -1),
				(this.mipmap = !1),
				(this.wrapMode = 33071),
				(this.type = TYPES$9.UNSIGNED_BYTE),
				(this.internalFormat = FORMATS$9.RGBA),
				(this.samplerType = 0);
		},
		TextureSystem$2 = (function () {
			function t(t) {
				(this.renderer = t),
					(this.boundTextures = []),
					(this.currentLocation = -1),
					(this.managedTextures = []),
					(this._unknownBoundTextures = !1),
					(this.unknownTexture = new BaseTexture$2()),
					(this.hasIntegerTextures = !1);
			}
			return (
				(t.prototype.contextChange = function () {
					var t = (this.gl = this.renderer.gl);
					(this.CONTEXT_UID = this.renderer.CONTEXT_UID),
						(this.webGLVersion = this.renderer.context.webGLVersion),
						(this.internalFormats = mapTypeAndFormatToInternalFormat$2(t));
					var e = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
					this.boundTextures.length = e;
					for (var i = 0; i < e; i++) this.boundTextures[i] = null;
					this.emptyTextures = {};
					var r = new GLTexture$2(t.createTexture());
					for (
						t.bindTexture(t.TEXTURE_2D, r.texture),
							t.texImage2D(
								t.TEXTURE_2D,
								0,
								t.RGBA,
								1,
								1,
								0,
								t.RGBA,
								t.UNSIGNED_BYTE,
								new Uint8Array(4)
							),
							this.emptyTextures[t.TEXTURE_2D] = r,
							this.emptyTextures[t.TEXTURE_CUBE_MAP] = new GLTexture$2(
								t.createTexture()
							),
							t.bindTexture(
								t.TEXTURE_CUBE_MAP,
								this.emptyTextures[t.TEXTURE_CUBE_MAP].texture
							),
							i = 0;
						i < 6;
						i++
					)
						t.texImage2D(
							t.TEXTURE_CUBE_MAP_POSITIVE_X + i,
							0,
							t.RGBA,
							1,
							1,
							0,
							t.RGBA,
							t.UNSIGNED_BYTE,
							null
						);
					for (
						t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR),
							t.texParameteri(
								t.TEXTURE_CUBE_MAP,
								t.TEXTURE_MIN_FILTER,
								t.LINEAR
							),
							i = 0;
						i < this.boundTextures.length;
						i++
					)
						this.bind(null, i);
				}),
				(t.prototype.bind = function (t, e) {
					void 0 === e && (e = 0);
					var i = this.gl;
					if (
						(t = null == t ? void 0 : t.castToBaseTexture()) &&
						t.valid &&
						!t.parentTextureArray
					) {
						t.touched = this.renderer.textureGC.count;
						var r = t._glTextures[this.CONTEXT_UID] || this.initTexture(t);
						this.boundTextures[e] !== t &&
							(this.currentLocation !== e &&
								((this.currentLocation = e), i.activeTexture(i.TEXTURE0 + e)),
							i.bindTexture(t.target, r.texture)),
							r.dirtyId !== t.dirtyId &&
								(this.currentLocation !== e &&
									((this.currentLocation = e), i.activeTexture(i.TEXTURE0 + e)),
								this.updateTexture(t)),
							(this.boundTextures[e] = t);
					} else
						this.currentLocation !== e &&
							((this.currentLocation = e), i.activeTexture(i.TEXTURE0 + e)),
							i.bindTexture(
								i.TEXTURE_2D,
								this.emptyTextures[i.TEXTURE_2D].texture
							),
							(this.boundTextures[e] = null);
				}),
				(t.prototype.reset = function () {
					(this._unknownBoundTextures = !0),
						(this.hasIntegerTextures = !1),
						(this.currentLocation = -1);
					for (var t = 0; t < this.boundTextures.length; t++)
						this.boundTextures[t] = this.unknownTexture;
				}),
				(t.prototype.unbind = function (t) {
					var e = this.gl,
						i = this.boundTextures;
					if (this._unknownBoundTextures) {
						this._unknownBoundTextures = !1;
						for (var r = 0; r < i.length; r++)
							i[r] === this.unknownTexture && this.bind(null, r);
					}
					for (r = 0; r < i.length; r++)
						i[r] === t &&
							(this.currentLocation !== r &&
								(e.activeTexture(e.TEXTURE0 + r), (this.currentLocation = r)),
							e.bindTexture(t.target, this.emptyTextures[t.target].texture),
							(i[r] = null));
				}),
				(t.prototype.ensureSamplerType = function (t) {
					var e = this,
						i = e.boundTextures,
						r = e.hasIntegerTextures,
						s = e.CONTEXT_UID;
					if (r)
						for (var n = t - 1; n >= 0; --n) {
							var a = i[n];
							a &&
								a._glTextures[s].samplerType !== SAMPLER_TYPES$9.FLOAT &&
								this.renderer.texture.unbind(a);
						}
				}),
				(t.prototype.initTexture = function (t) {
					var e = new GLTexture$2(this.gl.createTexture());
					return (
						(e.dirtyId = -1),
						(t._glTextures[this.CONTEXT_UID] = e),
						this.managedTextures.push(t),
						t.on('dispose', this.destroyTexture, this),
						e
					);
				}),
				(t.prototype.initTextureType = function (t, e) {
					var i, r;
					(e.internalFormat =
						null !==
							(r =
								null === (i = this.internalFormats[t.type]) || void 0 === i
									? void 0
									: i[t.format]) && void 0 !== r
							? r
							: t.format),
						2 === this.webGLVersion && t.type === TYPES$9.HALF_FLOAT
							? (e.type = this.gl.HALF_FLOAT)
							: (e.type = t.type);
				}),
				(t.prototype.updateTexture = function (t) {
					var e = t._glTextures[this.CONTEXT_UID];
					if (e) {
						var i = this.renderer;
						if (
							(this.initTextureType(t, e),
							t.resource && t.resource.upload(i, t, e))
						)
							e.samplerType !== SAMPLER_TYPES$9.FLOAT &&
								(this.hasIntegerTextures = !0);
						else {
							var r = t.realWidth,
								s = t.realHeight,
								n = i.gl;
							(e.width !== r || e.height !== s || e.dirtyId < 0) &&
								((e.width = r),
								(e.height = s),
								n.texImage2D(
									t.target,
									0,
									e.internalFormat,
									r,
									s,
									0,
									t.format,
									e.type,
									null
								));
						}
						t.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(t),
							(e.dirtyId = t.dirtyId);
					}
				}),
				(t.prototype.destroyTexture = function (t, e) {
					var i = this.gl;
					if (
						(t = t.castToBaseTexture())._glTextures[this.CONTEXT_UID] &&
						(this.unbind(t),
						i.deleteTexture(t._glTextures[this.CONTEXT_UID].texture),
						t.off('dispose', this.destroyTexture, this),
						delete t._glTextures[this.CONTEXT_UID],
						!e)
					) {
						var r = this.managedTextures.indexOf(t);
						-1 !== r && removeItems$2(this.managedTextures, r, 1);
					}
				}),
				(t.prototype.updateTextureStyle = function (t) {
					var e = t._glTextures[this.CONTEXT_UID];
					e &&
						((t.mipmap !== MIPMAP_MODES$9.POW2 && 2 === this.webGLVersion) ||
						t.isPowerOfTwo
							? (e.mipmap = t.mipmap >= 1)
							: (e.mipmap = !1),
						2 === this.webGLVersion || t.isPowerOfTwo
							? (e.wrapMode = t.wrapMode)
							: (e.wrapMode = WRAP_MODES$9.CLAMP),
						(t.resource && t.resource.style(this.renderer, t, e)) ||
							this.setStyle(t, e),
						(e.dirtyStyleId = t.dirtyStyleId));
				}),
				(t.prototype.setStyle = function (t, e) {
					var i = this.gl;
					if (
						(e.mipmap &&
							t.mipmap !== MIPMAP_MODES$9.ON_MANUAL &&
							i.generateMipmap(t.target),
						i.texParameteri(t.target, i.TEXTURE_WRAP_S, e.wrapMode),
						i.texParameteri(t.target, i.TEXTURE_WRAP_T, e.wrapMode),
						e.mipmap)
					) {
						i.texParameteri(
							t.target,
							i.TEXTURE_MIN_FILTER,
							t.scaleMode === SCALE_MODES$9.LINEAR
								? i.LINEAR_MIPMAP_LINEAR
								: i.NEAREST_MIPMAP_NEAREST
						);
						var r = this.renderer.context.extensions.anisotropicFiltering;
						if (
							r &&
							t.anisotropicLevel > 0 &&
							t.scaleMode === SCALE_MODES$9.LINEAR
						) {
							var s = Math.min(
								t.anisotropicLevel,
								i.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
							);
							i.texParameterf(t.target, r.TEXTURE_MAX_ANISOTROPY_EXT, s);
						}
					} else
						i.texParameteri(
							t.target,
							i.TEXTURE_MIN_FILTER,
							t.scaleMode === SCALE_MODES$9.LINEAR ? i.LINEAR : i.NEAREST
						);
					i.texParameteri(
						t.target,
						i.TEXTURE_MAG_FILTER,
						t.scaleMode === SCALE_MODES$9.LINEAR ? i.LINEAR : i.NEAREST
					);
				}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})(),
		tempMatrix$4 = new Matrix$2(),
		AbstractRenderer$2 = (function (t) {
			function e(e, i) {
				void 0 === e && (e = RENDERER_TYPE$9.UNKNOWN);
				var r = t.call(this) || this;
				return (
					(i = Object.assign({}, settings$4.RENDER_OPTIONS, i)),
					(r.options = i),
					(r.type = e),
					(r.screen = new Rectangle$3(0, 0, i.width, i.height)),
					(r.view = i.view || document.createElement('canvas')),
					(r.resolution = i.resolution || settings$4.RESOLUTION),
					(r.useContextAlpha = i.useContextAlpha),
					(r.autoDensity = !!i.autoDensity),
					(r.preserveDrawingBuffer = i.preserveDrawingBuffer),
					(r.clearBeforeRender = i.clearBeforeRender),
					(r._backgroundColor = 0),
					(r._backgroundColorRgba = [0, 0, 0, 1]),
					(r._backgroundColorString = '#000000'),
					(r.backgroundColor = i.backgroundColor || r._backgroundColor),
					(r.backgroundAlpha = i.backgroundAlpha),
					void 0 !== i.transparent &&
						(deprecation$2(
							'6.0.0',
							'Option transparent is deprecated, please use backgroundAlpha instead.'
						),
						(r.useContextAlpha = i.transparent),
						(r.backgroundAlpha = i.transparent ? 0 : 1)),
					(r._lastObjectRendered = null),
					(r.plugins = {}),
					r
				);
			}
			return (
				__extends$d(e, t),
				(e.prototype.initPlugins = function (t) {
					for (var e in t) this.plugins[e] = new t[e](this);
				}),
				Object.defineProperty(e.prototype, 'width', {
					get: function () {
						return this.view.width;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'height', {
					get: function () {
						return this.view.height;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.resize = function (t, e) {
					(this.view.width = Math.round(t * this.resolution)),
						(this.view.height = Math.round(e * this.resolution));
					var i = this.view.width / this.resolution,
						r = this.view.height / this.resolution;
					(this.screen.width = i),
						(this.screen.height = r),
						this.autoDensity &&
							((this.view.style.width = i + 'px'),
							(this.view.style.height = r + 'px')),
						this.emit('resize', i, r);
				}),
				(e.prototype.generateTexture = function (t, e, i, r) {
					void 0 === e && (e = {}),
						'number' == typeof e &&
							(deprecation$2(
								'6.1.0',
								'generateTexture options (scaleMode, resolution, region) are now object options.'
							),
							(e = { scaleMode: e, resolution: i, region: r }));
					var s = e.region,
						n = __rest$2(e, ['region']);
					0 === (r = s || t.getLocalBounds(null, !0)).width && (r.width = 1),
						0 === r.height && (r.height = 1);
					var a = RenderTexture$2.create(
						__assign$2({ width: r.width, height: r.height }, n)
					);
					return (
						(tempMatrix$4.tx = -r.x),
						(tempMatrix$4.ty = -r.y),
						this.render(t, {
							renderTexture: a,
							clear: !1,
							transform: tempMatrix$4,
							skipUpdateTransform: !!t.parent,
						}),
						a
					);
				}),
				(e.prototype.destroy = function (t) {
					for (var e in this.plugins)
						this.plugins[e].destroy(), (this.plugins[e] = null);
					t &&
						this.view.parentNode &&
						this.view.parentNode.removeChild(this.view);
					var i = this;
					(i.plugins = null),
						(i.type = RENDERER_TYPE$9.UNKNOWN),
						(i.view = null),
						(i.screen = null),
						(i._tempDisplayObjectParent = null),
						(i.options = null),
						(this._backgroundColorRgba = null),
						(this._backgroundColorString = null),
						(this._lastObjectRendered = null);
				}),
				Object.defineProperty(e.prototype, 'backgroundColor', {
					get: function () {
						return this._backgroundColor;
					},
					set: function (t) {
						(this._backgroundColor = t),
							(this._backgroundColorString = hex2string$2(t)),
							hex2rgb$2(t, this._backgroundColorRgba);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'backgroundAlpha', {
					get: function () {
						return this._backgroundColorRgba[3];
					},
					set: function (t) {
						this._backgroundColorRgba[3] = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				e
			);
		})(eventemitter3),
		GLBuffer$2 = function (t) {
			(this.buffer = t || null),
				(this.updateID = -1),
				(this.byteLength = -1),
				(this.refCount = 0);
		},
		BufferSystem$2 = (function () {
			function t(t) {
				(this.renderer = t),
					(this.managedBuffers = {}),
					(this.boundBufferBases = {});
			}
			return (
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				(t.prototype.contextChange = function () {
					this.disposeAll(!0),
						(this.gl = this.renderer.gl),
						(this.CONTEXT_UID = this.renderer.CONTEXT_UID);
				}),
				(t.prototype.bind = function (t) {
					var e = this.gl,
						i = this.CONTEXT_UID,
						r = t._glBuffers[i] || this.createGLBuffer(t);
					e.bindBuffer(t.type, r.buffer);
				}),
				(t.prototype.bindBufferBase = function (t, e) {
					var i = this.gl,
						r = this.CONTEXT_UID;
					if (this.boundBufferBases[e] !== t) {
						var s = t._glBuffers[r] || this.createGLBuffer(t);
						(this.boundBufferBases[e] = t),
							i.bindBufferBase(i.UNIFORM_BUFFER, e, s.buffer);
					}
				}),
				(t.prototype.bindBufferRange = function (t, e, i) {
					var r = this.gl,
						s = this.CONTEXT_UID;
					i = i || 0;
					var n = t._glBuffers[s] || this.createGLBuffer(t);
					r.bindBufferRange(r.UNIFORM_BUFFER, e || 0, n.buffer, 256 * i, 256);
				}),
				(t.prototype.update = function (t) {
					var e = this.gl,
						i = this.CONTEXT_UID,
						r = t._glBuffers[i];
					if (t._updateID !== r.updateID)
						if (
							((r.updateID = t._updateID),
							e.bindBuffer(t.type, r.buffer),
							r.byteLength >= t.data.byteLength)
						)
							e.bufferSubData(t.type, 0, t.data);
						else {
							var s = t.static ? e.STATIC_DRAW : e.DYNAMIC_DRAW;
							(r.byteLength = t.data.byteLength),
								e.bufferData(t.type, t.data, s);
						}
				}),
				(t.prototype.dispose = function (t, e) {
					if (this.managedBuffers[t.id]) {
						delete this.managedBuffers[t.id];
						var i = t._glBuffers[this.CONTEXT_UID],
							r = this.gl;
						t.disposeRunner.remove(this),
							i &&
								(e || r.deleteBuffer(i.buffer),
								delete t._glBuffers[this.CONTEXT_UID]);
					}
				}),
				(t.prototype.disposeAll = function (t) {
					for (
						var e = Object.keys(this.managedBuffers), i = 0;
						i < e.length;
						i++
					)
						this.dispose(this.managedBuffers[e[i]], t);
				}),
				(t.prototype.createGLBuffer = function (t) {
					var e = this.CONTEXT_UID,
						i = this.gl;
					return (
						(t._glBuffers[e] = new GLBuffer$2(i.createBuffer())),
						(this.managedBuffers[t.id] = t),
						t.disposeRunner.add(this),
						t._glBuffers[e]
					);
				}),
				t
			);
		})();
	!(function (t) {
		function e(i) {
			var r = t.call(this, RENDERER_TYPE$9.WEBGL, i) || this;
			return (
				(i = r.options),
				(r.gl = null),
				(r.CONTEXT_UID = 0),
				(r.runners = {
					destroy: new Runner$2('destroy'),
					contextChange: new Runner$2('contextChange'),
					reset: new Runner$2('reset'),
					update: new Runner$2('update'),
					postrender: new Runner$2('postrender'),
					prerender: new Runner$2('prerender'),
					resize: new Runner$2('resize'),
				}),
				r.runners.contextChange.add(r),
				(r.globalUniforms = new UniformGroup$2(
					{ projectionMatrix: new Matrix$2() },
					!0
				)),
				r
					.addSystem(MaskSystem$2, 'mask')
					.addSystem(ContextSystem$2, 'context')
					.addSystem(StateSystem$2, 'state')
					.addSystem(ShaderSystem$2, 'shader')
					.addSystem(TextureSystem$2, 'texture')
					.addSystem(BufferSystem$2, 'buffer')
					.addSystem(GeometrySystem$2, 'geometry')
					.addSystem(FramebufferSystem$2, 'framebuffer')
					.addSystem(ScissorSystem$2, 'scissor')
					.addSystem(StencilSystem$2, 'stencil')
					.addSystem(ProjectionSystem$2, 'projection')
					.addSystem(TextureGCSystem$2, 'textureGC')
					.addSystem(FilterSystem$2, 'filter')
					.addSystem(RenderTextureSystem$2, 'renderTexture')
					.addSystem(BatchSystem$2, 'batch'),
				r.initPlugins(e.__plugins),
				(r.multisample = void 0),
				i.context
					? r.context.initFromContext(i.context)
					: r.context.initFromOptions({
							alpha: !!r.useContextAlpha,
							antialias: i.antialias,
							premultipliedAlpha:
								r.useContextAlpha && 'notMultiplied' !== r.useContextAlpha,
							stencil: !0,
							preserveDrawingBuffer: i.preserveDrawingBuffer,
							powerPreference: r.options.powerPreference,
					  }),
				(r.renderingToScreen = !0),
				sayHello$2(2 === r.context.webGLVersion ? 'WebGL 2' : 'WebGL 1'),
				r.resize(r.options.width, r.options.height),
				r
			);
		}
		__extends$d(e, t),
			(e.create = function (t) {
				if (isWebGLSupported$2()) return new e(t);
				throw new Error(
					'WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.'
				);
			}),
			(e.prototype.contextChange = function () {
				var t,
					e = this.gl;
				if (1 === this.context.webGLVersion) {
					var i = e.getParameter(e.FRAMEBUFFER_BINDING);
					e.bindFramebuffer(e.FRAMEBUFFER, null),
						(t = e.getParameter(e.SAMPLES)),
						e.bindFramebuffer(e.FRAMEBUFFER, i);
				} else
					(i = e.getParameter(e.DRAW_FRAMEBUFFER_BINDING)),
						e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
						(t = e.getParameter(e.SAMPLES)),
						e.bindFramebuffer(e.DRAW_FRAMEBUFFER, i);
				t >= MSAA_QUALITY$9.HIGH
					? (this.multisample = MSAA_QUALITY$9.HIGH)
					: t >= MSAA_QUALITY$9.MEDIUM
					? (this.multisample = MSAA_QUALITY$9.MEDIUM)
					: t >= MSAA_QUALITY$9.LOW
					? (this.multisample = MSAA_QUALITY$9.LOW)
					: (this.multisample = MSAA_QUALITY$9.NONE);
			}),
			(e.prototype.addSystem = function (t, e) {
				var i = new t(this);
				if (this[e])
					throw new Error('Whoops! The name "' + e + '" is already in use');
				for (var r in ((this[e] = i), this.runners)) this.runners[r].add(i);
				return this;
			}),
			(e.prototype.render = function (t, e) {
				var i, r, s, n;
				if (
					(e &&
						(e instanceof RenderTexture$2
							? (deprecation$2(
									'6.0.0',
									'Renderer#render arguments changed, use options instead.'
							  ),
							  (i = e),
							  (r = arguments[2]),
							  (s = arguments[3]),
							  (n = arguments[4]))
							: ((i = e.renderTexture),
							  (r = e.clear),
							  (s = e.transform),
							  (n = e.skipUpdateTransform))),
					(this.renderingToScreen = !i),
					this.runners.prerender.emit(),
					this.emit('prerender'),
					(this.projection.transform = s),
					!this.context.isLost)
				) {
					if ((i || (this._lastObjectRendered = t), !n)) {
						var a = t.enableTempParent();
						t.updateTransform(), t.disableTempParent(a);
					}
					this.renderTexture.bind(i),
						this.batch.currentRenderer.start(),
						(void 0 !== r ? r : this.clearBeforeRender) &&
							this.renderTexture.clear(),
						t.render(this),
						this.batch.currentRenderer.flush(),
						i && i.baseTexture.update(),
						this.runners.postrender.emit(),
						(this.projection.transform = null),
						this.emit('postrender');
				}
			}),
			(e.prototype.generateTexture = function (e, i, r, s) {
				void 0 === i && (i = {});
				var n = t.prototype.generateTexture.call(this, e, i, r, s);
				return this.framebuffer.blit(), n;
			}),
			(e.prototype.resize = function (e, i) {
				t.prototype.resize.call(this, e, i),
					this.runners.resize.emit(this.screen.height, this.screen.width);
			}),
			(e.prototype.reset = function () {
				return this.runners.reset.emit(), this;
			}),
			(e.prototype.clear = function () {
				this.renderTexture.bind(), this.renderTexture.clear();
			}),
			(e.prototype.destroy = function (e) {
				for (var i in (this.runners.destroy.emit(), this.runners))
					this.runners[i].destroy();
				t.prototype.destroy.call(this, e), (this.gl = null);
			}),
			Object.defineProperty(e.prototype, 'extract', {
				get: function () {
					return (
						deprecation$2(
							'6.0.0',
							'Renderer#extract has been deprecated, please use Renderer#plugins.extract instead.'
						),
						this.plugins.extract
					);
				},
				enumerable: !1,
				configurable: !0,
			}),
			(e.registerPlugin = function (t, i) {
				(e.__plugins = e.__plugins || {}), (e.__plugins[t] = i);
			});
	})(AbstractRenderer$2);
	var BatchDrawCall$2 = function () {
			(this.texArray = null),
				(this.blend = 0),
				(this.type = DRAW_MODES$9.TRIANGLES),
				(this.start = 0),
				(this.size = 0),
				(this.data = null);
		},
		BatchTextureArray$2 = (function () {
			function t() {
				(this.elements = []), (this.ids = []), (this.count = 0);
			}
			return (
				(t.prototype.clear = function () {
					for (var t = 0; t < this.count; t++) this.elements[t] = null;
					this.count = 0;
				}),
				t
			);
		})(),
		ViewableBuffer$2 = (function () {
			function t(t) {
				'number' == typeof t
					? (this.rawBinaryData = new ArrayBuffer(t))
					: t instanceof Uint8Array
					? (this.rawBinaryData = t.buffer)
					: (this.rawBinaryData = t),
					(this.uint32View = new Uint32Array(this.rawBinaryData)),
					(this.float32View = new Float32Array(this.rawBinaryData));
			}
			return (
				Object.defineProperty(t.prototype, 'int8View', {
					get: function () {
						return (
							this._int8View ||
								(this._int8View = new Int8Array(this.rawBinaryData)),
							this._int8View
						);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'uint8View', {
					get: function () {
						return (
							this._uint8View ||
								(this._uint8View = new Uint8Array(this.rawBinaryData)),
							this._uint8View
						);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'int16View', {
					get: function () {
						return (
							this._int16View ||
								(this._int16View = new Int16Array(this.rawBinaryData)),
							this._int16View
						);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'uint16View', {
					get: function () {
						return (
							this._uint16View ||
								(this._uint16View = new Uint16Array(this.rawBinaryData)),
							this._uint16View
						);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'int32View', {
					get: function () {
						return (
							this._int32View ||
								(this._int32View = new Int32Array(this.rawBinaryData)),
							this._int32View
						);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.view = function (t) {
					return this[t + 'View'];
				}),
				(t.prototype.destroy = function () {
					(this.rawBinaryData = null),
						(this._int8View = null),
						(this._uint8View = null),
						(this._int16View = null),
						(this._uint16View = null),
						(this._int32View = null),
						(this.uint32View = null),
						(this.float32View = null);
				}),
				(t.sizeOf = function (t) {
					switch (t) {
						case 'int8':
						case 'uint8':
							return 1;
						case 'int16':
						case 'uint16':
							return 2;
						case 'int32':
						case 'uint32':
						case 'float32':
							return 4;
						default:
							throw new Error(t + " isn't a valid view type");
					}
				}),
				t
			);
		})(),
		AbstractBatchRenderer$2 = (function (t) {
			function e(e) {
				var i = t.call(this, e) || this;
				return (
					(i.shaderGenerator = null),
					(i.geometryClass = null),
					(i.vertexSize = null),
					(i.state = State$2.for2d()),
					(i.size = 4 * settings$4.SPRITE_BATCH_SIZE),
					(i._vertexCount = 0),
					(i._indexCount = 0),
					(i._bufferedElements = []),
					(i._bufferedTextures = []),
					(i._bufferSize = 0),
					(i._shader = null),
					(i._packedGeometries = []),
					(i._packedGeometryPoolSize = 2),
					(i._flushId = 0),
					(i._aBuffers = {}),
					(i._iBuffers = {}),
					(i.MAX_TEXTURES = 1),
					i.renderer.on('prerender', i.onPrerender, i),
					e.runners.contextChange.add(i),
					(i._dcIndex = 0),
					(i._aIndex = 0),
					(i._iIndex = 0),
					(i._attributeBuffer = null),
					(i._indexBuffer = null),
					(i._tempBoundTextures = []),
					i
				);
			}
			return (
				__extends$d(e, t),
				(e.prototype.contextChange = function () {
					var t = this.renderer.gl;
					settings$4.PREFER_ENV === ENV$9.WEBGL_LEGACY
						? (this.MAX_TEXTURES = 1)
						: ((this.MAX_TEXTURES = Math.min(
								t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
								settings$4.SPRITE_MAX_TEXTURES
						  )),
						  (this.MAX_TEXTURES = checkMaxIfStatementsInShader$2(
								this.MAX_TEXTURES,
								t
						  ))),
						(this._shader = this.shaderGenerator.generateShader(
							this.MAX_TEXTURES
						));
					for (var e = 0; e < this._packedGeometryPoolSize; e++)
						this._packedGeometries[e] = new this.geometryClass();
					this.initFlushBuffers();
				}),
				(e.prototype.initFlushBuffers = function () {
					for (
						var t = e._drawCallPool,
							i = e._textureArrayPool,
							r = this.size / 4,
							s = Math.floor(r / this.MAX_TEXTURES) + 1;
						t.length < r;

					)
						t.push(new BatchDrawCall$2());
					for (; i.length < s; ) i.push(new BatchTextureArray$2());
					for (var n = 0; n < this.MAX_TEXTURES; n++)
						this._tempBoundTextures[n] = null;
				}),
				(e.prototype.onPrerender = function () {
					this._flushId = 0;
				}),
				(e.prototype.render = function (t) {
					t._texture.valid &&
						(this._vertexCount + t.vertexData.length / 2 > this.size &&
							this.flush(),
						(this._vertexCount += t.vertexData.length / 2),
						(this._indexCount += t.indices.length),
						(this._bufferedTextures[this._bufferSize] = t._texture.baseTexture),
						(this._bufferedElements[this._bufferSize++] = t));
				}),
				(e.prototype.buildTexturesAndDrawCalls = function () {
					var t = this._bufferedTextures,
						i = this.MAX_TEXTURES,
						r = e._textureArrayPool,
						s = this.renderer.batch,
						n = this._tempBoundTextures,
						a = this.renderer.textureGC.count,
						o = ++BaseTexture$2._globalBatch,
						h = 0,
						u = r[0],
						l = 0;
					s.copyBoundTextures(n, i);
					for (var c = 0; c < this._bufferSize; ++c) {
						var d = t[c];
						(t[c] = null),
							d._batchEnabled !== o &&
								(u.count >= i &&
									(s.boundArray(u, n, o, i),
									this.buildDrawCalls(u, l, c),
									(l = c),
									(u = r[++h]),
									++o),
								(d._batchEnabled = o),
								(d.touched = a),
								(u.elements[u.count++] = d));
					}
					for (
						u.count > 0 &&
							(s.boundArray(u, n, o, i),
							this.buildDrawCalls(u, l, this._bufferSize),
							++h,
							++o),
							c = 0;
						c < n.length;
						c++
					)
						n[c] = null;
					BaseTexture$2._globalBatch = o;
				}),
				(e.prototype.buildDrawCalls = function (t, i, r) {
					var s = this,
						n = s._bufferedElements,
						a = s._attributeBuffer,
						o = s._indexBuffer,
						h = s.vertexSize,
						u = e._drawCallPool,
						l = this._dcIndex,
						c = this._aIndex,
						d = this._iIndex,
						p = u[l];
					(p.start = this._iIndex), (p.texArray = t);
					for (var f = i; f < r; ++f) {
						var m = n[f],
							_ = m._texture.baseTexture,
							g = premultiplyBlendMode$2[_.alphaMode ? 1 : 0][m.blendMode];
						(n[f] = null),
							i < f &&
								p.blend !== g &&
								((p.size = d - p.start),
								(i = f),
								((p = u[++l]).texArray = t),
								(p.start = d)),
							this.packInterleavedGeometry(m, a, o, c, d),
							(c += (m.vertexData.length / 2) * h),
							(d += m.indices.length),
							(p.blend = g);
					}
					i < r && ((p.size = d - p.start), ++l),
						(this._dcIndex = l),
						(this._aIndex = c),
						(this._iIndex = d);
				}),
				(e.prototype.bindAndClearTexArray = function (t) {
					for (var e = this.renderer.texture, i = 0; i < t.count; i++)
						e.bind(t.elements[i], t.ids[i]), (t.elements[i] = null);
					t.count = 0;
				}),
				(e.prototype.updateGeometry = function () {
					var t = this,
						e = t._packedGeometries,
						i = t._attributeBuffer,
						r = t._indexBuffer;
					settings$4.CAN_UPLOAD_SAME_BUFFER
						? (e[this._flushId]._buffer.update(i.rawBinaryData),
						  e[this._flushId]._indexBuffer.update(r),
						  this.renderer.geometry.updateBuffers())
						: (this._packedGeometryPoolSize <= this._flushId &&
								(this._packedGeometryPoolSize++,
								(e[this._flushId] = new this.geometryClass())),
						  e[this._flushId]._buffer.update(i.rawBinaryData),
						  e[this._flushId]._indexBuffer.update(r),
						  this.renderer.geometry.bind(e[this._flushId]),
						  this.renderer.geometry.updateBuffers(),
						  this._flushId++);
				}),
				(e.prototype.drawBatches = function () {
					for (
						var t = this._dcIndex,
							i = this.renderer,
							r = i.gl,
							s = i.state,
							n = e._drawCallPool,
							a = null,
							o = 0;
						o < t;
						o++
					) {
						var h = n[o],
							u = h.texArray,
							l = h.type,
							c = h.size,
							d = h.start,
							p = h.blend;
						a !== u && ((a = u), this.bindAndClearTexArray(u)),
							(this.state.blendMode = p),
							s.set(this.state),
							r.drawElements(l, c, r.UNSIGNED_SHORT, 2 * d);
					}
				}),
				(e.prototype.flush = function () {
					0 !== this._vertexCount &&
						((this._attributeBuffer = this.getAttributeBuffer(
							this._vertexCount
						)),
						(this._indexBuffer = this.getIndexBuffer(this._indexCount)),
						(this._aIndex = 0),
						(this._iIndex = 0),
						(this._dcIndex = 0),
						this.buildTexturesAndDrawCalls(),
						this.updateGeometry(),
						this.drawBatches(),
						(this._bufferSize = 0),
						(this._vertexCount = 0),
						(this._indexCount = 0));
				}),
				(e.prototype.start = function () {
					this.renderer.state.set(this.state),
						this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES),
						this.renderer.shader.bind(this._shader),
						settings$4.CAN_UPLOAD_SAME_BUFFER &&
							this.renderer.geometry.bind(
								this._packedGeometries[this._flushId]
							);
				}),
				(e.prototype.stop = function () {
					this.flush();
				}),
				(e.prototype.destroy = function () {
					for (var e = 0; e < this._packedGeometryPoolSize; e++)
						this._packedGeometries[e] && this._packedGeometries[e].destroy();
					this.renderer.off('prerender', this.onPrerender, this),
						(this._aBuffers = null),
						(this._iBuffers = null),
						(this._packedGeometries = null),
						(this._attributeBuffer = null),
						(this._indexBuffer = null),
						this._shader && (this._shader.destroy(), (this._shader = null)),
						t.prototype.destroy.call(this);
				}),
				(e.prototype.getAttributeBuffer = function (t) {
					var e = nextPow2$2(Math.ceil(t / 8)),
						i = log2$2(e),
						r = 8 * e;
					this._aBuffers.length <= i && (this._iBuffers.length = i + 1);
					var s = this._aBuffers[r];
					return (
						s ||
							(this._aBuffers[r] = s =
								new ViewableBuffer$2(r * this.vertexSize * 4)),
						s
					);
				}),
				(e.prototype.getIndexBuffer = function (t) {
					var e = nextPow2$2(Math.ceil(t / 12)),
						i = log2$2(e),
						r = 12 * e;
					this._iBuffers.length <= i && (this._iBuffers.length = i + 1);
					var s = this._iBuffers[i];
					return s || (this._iBuffers[i] = s = new Uint16Array(r)), s;
				}),
				(e.prototype.packInterleavedGeometry = function (t, e, i, r, s) {
					for (
						var n = e.uint32View,
							a = e.float32View,
							o = r / this.vertexSize,
							h = t.uvs,
							u = t.indices,
							l = t.vertexData,
							c = t._texture.baseTexture._batchLocation,
							d = Math.min(t.worldAlpha, 1),
							p =
								d < 1 && t._texture.baseTexture.alphaMode
									? premultiplyTint$2(t._tintRGB, d)
									: t._tintRGB + ((255 * d) << 24),
							f = 0;
						f < l.length;
						f += 2
					)
						(a[r++] = l[f]),
							(a[r++] = l[f + 1]),
							(a[r++] = h[f]),
							(a[r++] = h[f + 1]),
							(n[r++] = p),
							(a[r++] = c);
					for (f = 0; f < u.length; f++) i[s++] = o + u[f];
				}),
				(e._drawCallPool = []),
				(e._textureArrayPool = []),
				e
			);
		})(ObjectRenderer$2),
		BatchShaderGenerator$2 = (function () {
			function t(t, e) {
				if (
					((this.vertexSrc = t),
					(this.fragTemplate = e),
					(this.programCache = {}),
					(this.defaultGroupCache = {}),
					e.indexOf('%count%') < 0)
				)
					throw new Error('Fragment template must contain "%count%".');
				if (e.indexOf('%forloop%') < 0)
					throw new Error('Fragment template must contain "%forloop%".');
			}
			return (
				(t.prototype.generateShader = function (t) {
					if (!this.programCache[t]) {
						for (var e = new Int32Array(t), i = 0; i < t; i++) e[i] = i;
						this.defaultGroupCache[t] = UniformGroup$2.from(
							{ uSamplers: e },
							!0
						);
						var r = this.fragTemplate;
						(r = (r = r.replace(/%count%/gi, '' + t)).replace(
							/%forloop%/gi,
							this.generateSampleSrc(t)
						)),
							(this.programCache[t] = new Program$2(this.vertexSrc, r));
					}
					var s = {
						tint: new Float32Array([1, 1, 1, 1]),
						translationMatrix: new Matrix$2(),
						default: this.defaultGroupCache[t],
					};
					return new Shader$2(this.programCache[t], s);
				}),
				(t.prototype.generateSampleSrc = function (t) {
					var e = '';
					(e += '\n'), (e += '\n');
					for (var i = 0; i < t; i++)
						i > 0 && (e += '\nelse '),
							i < t - 1 && (e += 'if(vTextureId < ' + i + '.5)'),
							(e += '\n{'),
							(e +=
								'\n\tcolor = texture2D(uSamplers[' + i + '], vTextureCoord);'),
							(e += '\n}');
					return (e += '\n') + '\n';
				}),
				t
			);
		})(),
		BatchGeometry$2 = (function (t) {
			function e(e) {
				void 0 === e && (e = !1);
				var i = t.call(this) || this;
				return (
					(i._buffer = new Buffer$2(null, e, !1)),
					(i._indexBuffer = new Buffer$2(null, e, !0)),
					i
						.addAttribute('aVertexPosition', i._buffer, 2, !1, TYPES$9.FLOAT)
						.addAttribute('aTextureCoord', i._buffer, 2, !1, TYPES$9.FLOAT)
						.addAttribute('aColor', i._buffer, 4, !0, TYPES$9.UNSIGNED_BYTE)
						.addAttribute('aTextureId', i._buffer, 1, !0, TYPES$9.FLOAT)
						.addIndex(i._indexBuffer),
					i
				);
			}
			return __extends$d(e, t), e;
		})(Geometry$2),
		defaultVertex$4 =
			'precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n',
		defaultFragment$4 =
			'varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n',
		BatchPluginFactory$2 = (function () {
			function t() {}
			return (
				(t.create = function (t) {
					var e = Object.assign(
							{
								vertex: defaultVertex$4,
								fragment: defaultFragment$4,
								geometryClass: BatchGeometry$2,
								vertexSize: 6,
							},
							t
						),
						i = e.vertex,
						r = e.fragment,
						s = e.vertexSize,
						n = e.geometryClass;
					return (function (t) {
						function e(e) {
							var a = t.call(this, e) || this;
							return (
								(a.shaderGenerator = new BatchShaderGenerator$2(i, r)),
								(a.geometryClass = n),
								(a.vertexSize = s),
								a
							);
						}
						return __extends$d(e, t), e;
					})(AbstractBatchRenderer$2);
				}),
				Object.defineProperty(t, 'defaultVertexSrc', {
					get: function () {
						return defaultVertex$4;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t, 'defaultFragmentTemplate', {
					get: function () {
						return defaultFragment$4;
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			);
		})();
	BatchPluginFactory$2.create();
	var CanvasMeshRenderer = (function () {
		function t(t) {
			this.renderer = t;
		}
		return (
			(t.prototype.render = function (t) {
				var e = this.renderer,
					i = t.worldTransform;
				(e.context.globalAlpha = t.worldAlpha),
					e.setBlendMode(t.blendMode),
					e.setContextTransform(i, t.roundPixels),
					t.drawMode !== DRAW_MODES$9.TRIANGLES
						? this._renderTriangleMesh(t)
						: this._renderTriangles(t);
			}),
			(t.prototype._renderTriangleMesh = function (t) {
				for (var e = t.geometry.buffers[0].data.length, i = 0; i < e - 2; i++) {
					var r = 2 * i;
					this._renderDrawTriangle(t, r, r + 2, r + 4);
				}
			}),
			(t.prototype._renderTriangles = function (t) {
				for (
					var e = t.geometry.getIndex().data, i = e.length, r = 0;
					r < i;
					r += 3
				) {
					var s = 2 * e[r],
						n = 2 * e[r + 1],
						a = 2 * e[r + 2];
					this._renderDrawTriangle(t, s, n, a);
				}
			}),
			(t.prototype._renderDrawTriangle = function (t, e, i, r) {
				var s = this.renderer.context,
					n = t.geometry.buffers[0].data,
					a = t.uvs,
					o = t.texture;
				if (o.valid) {
					var h = 16777215 !== t.tint,
						u = o.baseTexture,
						l = u.width,
						c = u.height;
					h &&
						t._cachedTint !== t.tint &&
						((t._cachedTint = t.tint),
						(t._cachedTexture = t._cachedTexture || new Texture$2(u)),
						(t._tintedCanvas = canvasUtils.getTintedCanvas(
							{ texture: t._cachedTexture },
							t.tint
						)));
					var d = h ? t._tintedCanvas : u.getDrawableSource(),
						p = a[e] * u.width,
						f = a[i] * u.width,
						m = a[r] * u.width,
						_ = a[e + 1] * u.height,
						g = a[i + 1] * u.height,
						E = a[r + 1] * u.height,
						y = n[e],
						T = n[i],
						v = n[r],
						S = n[e + 1],
						x = n[i + 1],
						b = n[r + 1],
						A = t.canvasPadding / this.renderer.resolution;
					if (A > 0) {
						var R = t.worldTransform,
							I = R.a,
							M = R.b,
							w = R.c,
							C = R.d,
							P = (y + T + v) / 3,
							O = (S + x + b) / 3,
							$ = y - P,
							N = S - O,
							D = I * $ + w * N,
							L = M * $ + C * N,
							B = Math.sqrt(D * D + L * L),
							F = 1 + A / B;
						(y = P + $ * F),
							(S = O + N * F),
							(D = I * ($ = T - P) + w * (N = x - O)),
							(L = M * $ + C * N),
							(T = P + $ * (F = 1 + A / (B = Math.sqrt(D * D + L * L)))),
							(x = O + N * F),
							(D = I * ($ = v - P) + w * (N = b - O)),
							(L = M * $ + C * N),
							(v = P + $ * (F = 1 + A / (B = Math.sqrt(D * D + L * L)))),
							(b = O + N * F);
					}
					s.save(),
						s.beginPath(),
						s.moveTo(y, S),
						s.lineTo(T, x),
						s.lineTo(v, b),
						s.closePath(),
						s.clip();
					var U = p * g + _ * m + f * E - g * m - _ * f - p * E,
						G = y * g + _ * v + T * E - g * v - _ * T - y * E,
						k = p * T + y * m + f * v - T * m - y * f - p * v,
						W =
							p * g * v +
							_ * T * m +
							y * f * E -
							y * g * m -
							_ * f * v -
							p * T * E,
						H = S * g + _ * b + x * E - g * b - _ * x - S * E,
						Y = p * x + S * m + f * b - x * m - S * f - p * b,
						V =
							p * g * b +
							_ * x * m +
							S * f * E -
							S * g * m -
							_ * f * b -
							p * x * E;
					s.transform(G / U, H / U, k / U, Y / U, W / U, V / U),
						s.drawImage(
							d,
							0,
							0,
							l * u.resolution,
							c * u.resolution,
							0,
							0,
							l,
							c
						),
						s.restore(),
						this.renderer.invalidateBlendMode();
				}
			}),
			(t.prototype.renderMeshFlat = function (t) {
				var e = this.renderer.context,
					i = t.geometry.getBuffer('aVertexPosition').data,
					r = i.length / 2;
				e.beginPath();
				for (var s = 1; s < r - 2; ++s) {
					var n = 2 * s,
						a = i[n],
						o = i[n + 1],
						h = i[n + 2],
						u = i[n + 3],
						l = i[n + 4],
						c = i[n + 5];
					e.moveTo(a, o), e.lineTo(h, u), e.lineTo(l, c);
				}
				(e.fillStyle = '#FF0000'), e.fill(), e.closePath();
			}),
			(t.prototype.destroy = function () {
				this.renderer = null;
			}),
			t
		);
	})();
	(settings$4.MESH_CANVAS_PADDING = 0),
		(MeshMaterial.prototype._renderCanvas = function (t, e) {
			t.plugins.mesh.render(e);
		}),
		(NineSlicePlane.prototype._cachedTint = 16777215),
		(NineSlicePlane.prototype._tintedCanvas = null),
		(NineSlicePlane.prototype._canvasUvs = null),
		(NineSlicePlane.prototype._renderCanvas = function (t) {
			var e = t.context,
				i = this.worldTransform,
				r = 16777215 !== this.tint,
				s = this.texture;
			if (s.valid) {
				r &&
					this._cachedTint !== this.tint &&
					((this._cachedTint = this.tint),
					(this._tintedCanvas = canvasUtils.getTintedCanvas(this, this.tint)));
				var n = r ? this._tintedCanvas : s.baseTexture.getDrawableSource();
				this._canvasUvs || (this._canvasUvs = [0, 0, 0, 0, 0, 0, 0, 0]);
				var a = this.vertices,
					o = this._canvasUvs,
					h = r ? 0 : s.frame.x,
					u = r ? 0 : s.frame.y,
					l = h + s.frame.width,
					c = u + s.frame.height;
				(o[0] = h),
					(o[1] = h + this._leftWidth),
					(o[2] = l - this._rightWidth),
					(o[3] = l),
					(o[4] = u),
					(o[5] = u + this._topHeight),
					(o[6] = c - this._bottomHeight),
					(o[7] = c);
				for (var d = 0; d < 8; d++) o[d] *= s.baseTexture.resolution;
				(e.globalAlpha = this.worldAlpha),
					t.setBlendMode(this.blendMode),
					t.setContextTransform(i, this.roundPixels);
				for (var p = 0; p < 3; p++)
					for (var f = 0; f < 3; f++) {
						var m = 2 * f + 8 * p,
							_ = Math.max(1, o[f + 1] - o[f]),
							g = Math.max(1, o[p + 5] - o[p + 4]),
							E = Math.max(1, a[m + 10] - a[m]),
							y = Math.max(1, a[m + 11] - a[m + 1]);
						e.drawImage(n, o[f], o[p + 4], _, g, a[m], a[m + 1], E, y);
					}
			}
		});
	var warned = !1;
	(Mesh.prototype._cachedTint = 16777215),
		(Mesh.prototype._tintedCanvas = null),
		(Mesh.prototype._cachedTexture = null),
		(Mesh.prototype._renderCanvas = function (t) {
			this.shader.uvMatrix &&
				(this.shader.uvMatrix.update(), this.calculateUvs()),
				this.material._renderCanvas
					? this.material._renderCanvas(t, this)
					: warned || ((warned = !0), globalThis.console);
		}),
		(Mesh.prototype._canvasPadding = null),
		Object.defineProperty(Mesh.prototype, 'canvasPadding', {
			get: function () {
				return null !== this._canvasPadding
					? this._canvasPadding
					: settings$4.MESH_CANVAS_PADDING;
			},
			set: function (t) {
				this._canvasPadding = t;
			},
		}),
		(SimpleMesh.prototype._renderCanvas = function (t) {
			this.autoUpdate && this.geometry.getBuffer('aVertexPosition').update(),
				this.shader.update && this.shader.update(),
				this.calculateUvs(),
				this.material._renderCanvas(t, this);
		}),
		(SimpleRope.prototype._renderCanvas = function (t) {
			(this.autoUpdate ||
				this.geometry._width !== this.shader.texture.height) &&
				((this.geometry._width = this.shader.texture.height),
				this.geometry.update()),
				this.shader.update && this.shader.update(),
				this.calculateUvs(),
				this.material._renderCanvas(t, this);
		});
	/*!
	 * @pixi/canvas-sprite-tiling - v6.4.2
	 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
	 *
	 * @pixi/canvas-sprite-tiling is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 */
	var worldMatrix = new Matrix$3(),
		patternMatrix = new Matrix$3(),
		patternRect = [new Point$4(), new Point$4(), new Point$4(), new Point$4()];
	TilingSprite$1.prototype._renderCanvas = function (t) {
		var e = this._texture;
		if (e.baseTexture.valid) {
			var i = t.context,
				r = this.worldTransform,
				s = e.baseTexture,
				n = s.getDrawableSource(),
				a = s.resolution;
			if (
				this._textureID !== this._texture._updateID ||
				this._cachedTint !== this.tint
			) {
				this._textureID = this._texture._updateID;
				var o = new CanvasRenderTarget(e._frame.width, e._frame.height, a);
				16777215 !== this.tint
					? ((this._tintedCanvas = canvasUtils.getTintedCanvas(
							this,
							this.tint
					  )),
					  o.context.drawImage(this._tintedCanvas, 0, 0))
					: o.context.drawImage(n, -e._frame.x * a, -e._frame.y * a),
					(this._cachedTint = this.tint),
					(this._canvasPattern = o.context.createPattern(o.canvas, 'repeat'));
			}
			(i.globalAlpha = this.worldAlpha),
				t.setBlendMode(this.blendMode),
				this.tileTransform.updateLocalTransform();
			var h = this.tileTransform.localTransform,
				u = this._width,
				l = this._height;
			worldMatrix.identity(),
				patternMatrix.copyFrom(h),
				this.uvRespectAnchor ||
					patternMatrix.translate(-this.anchor.x * u, -this.anchor.y * l),
				patternMatrix.scale(this.tileScale.x / a, this.tileScale.y / a),
				worldMatrix.prepend(patternMatrix),
				worldMatrix.prepend(r),
				t.setContextTransform(worldMatrix),
				(i.fillStyle = this._canvasPattern);
			var c = this.anchor.x * -u,
				d = this.anchor.y * -l;
			patternRect[0].set(c, d),
				patternRect[1].set(c + u, d),
				patternRect[2].set(c + u, d + l),
				patternRect[3].set(c, d + l);
			for (var p = 0; p < 4; p++)
				patternMatrix.applyInverse(patternRect[p], patternRect[p]);
			for (
				i.beginPath(), i.moveTo(patternRect[0].x, patternRect[0].y), p = 1;
				p < 4;
				p++
			)
				i.lineTo(patternRect[p].x, patternRect[p].y);
			i.closePath(), i.fill();
		}
	};
	/*!
	 * @pixi/settings - v6.2.1
	 * Compiled Tue, 21 Dec 2021 19:56:15 UTC
	 *
	 * @pixi/settings is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 */
	var isMobile$1 = isMobile$4(self.navigator),
		ENV$4,
		RENDERER_TYPE$4,
		BUFFER_BITS$4,
		BLEND_MODES$4,
		DRAW_MODES$4,
		FORMATS$4,
		TARGETS$4,
		TYPES$4,
		SAMPLER_TYPES$4,
		SCALE_MODES$4,
		WRAP_MODES$4,
		MIPMAP_MODES$4,
		ALPHA_MODES$4,
		CLEAR_MODES$4,
		GC_MODES$4,
		PRECISION$4,
		MASK_TYPES$4,
		MSAA_QUALITY$4,
		BUFFER_TYPE$4;
	function maxRecommendedTextures$1(t) {
		var e,
			i = !0;
		(isMobile$1.tablet || isMobile$1.phone) &&
			(isMobile$1.apple.device &&
				(e = navigator.userAgent.match(/OS (\d+)_(\d+)?/)) &&
				parseInt(e[1], 10) < 11 &&
				(i = !1),
			isMobile$1.android.device &&
				(e = navigator.userAgent.match(/Android\s([0-9.]*)/)) &&
				parseInt(e[1], 10) < 7 &&
				(i = !1));
		return i ? t : 4;
	}
	function canUploadSameBuffer$1() {
		return !isMobile$1.apple.device;
	}
	/*!
	 * @pixi/constants - v6.2.1
	 * Compiled Tue, 21 Dec 2021 19:56:15 UTC
	 *
	 * @pixi/constants is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 */ !(function (t) {
		(t[(t.WEBGL_LEGACY = 0)] = 'WEBGL_LEGACY'),
			(t[(t.WEBGL = 1)] = 'WEBGL'),
			(t[(t.WEBGL2 = 2)] = 'WEBGL2');
	})(ENV$4 || (ENV$4 = {})),
		(function (t) {
			(t[(t.UNKNOWN = 0)] = 'UNKNOWN'),
				(t[(t.WEBGL = 1)] = 'WEBGL'),
				(t[(t.CANVAS = 2)] = 'CANVAS');
		})(RENDERER_TYPE$4 || (RENDERER_TYPE$4 = {})),
		(function (t) {
			(t[(t.COLOR = 16384)] = 'COLOR'),
				(t[(t.DEPTH = 256)] = 'DEPTH'),
				(t[(t.STENCIL = 1024)] = 'STENCIL');
		})(BUFFER_BITS$4 || (BUFFER_BITS$4 = {})),
		(function (t) {
			(t[(t.NORMAL = 0)] = 'NORMAL'),
				(t[(t.ADD = 1)] = 'ADD'),
				(t[(t.MULTIPLY = 2)] = 'MULTIPLY'),
				(t[(t.SCREEN = 3)] = 'SCREEN'),
				(t[(t.OVERLAY = 4)] = 'OVERLAY'),
				(t[(t.DARKEN = 5)] = 'DARKEN'),
				(t[(t.LIGHTEN = 6)] = 'LIGHTEN'),
				(t[(t.COLOR_DODGE = 7)] = 'COLOR_DODGE'),
				(t[(t.COLOR_BURN = 8)] = 'COLOR_BURN'),
				(t[(t.HARD_LIGHT = 9)] = 'HARD_LIGHT'),
				(t[(t.SOFT_LIGHT = 10)] = 'SOFT_LIGHT'),
				(t[(t.DIFFERENCE = 11)] = 'DIFFERENCE'),
				(t[(t.EXCLUSION = 12)] = 'EXCLUSION'),
				(t[(t.HUE = 13)] = 'HUE'),
				(t[(t.SATURATION = 14)] = 'SATURATION'),
				(t[(t.COLOR = 15)] = 'COLOR'),
				(t[(t.LUMINOSITY = 16)] = 'LUMINOSITY'),
				(t[(t.NORMAL_NPM = 17)] = 'NORMAL_NPM'),
				(t[(t.ADD_NPM = 18)] = 'ADD_NPM'),
				(t[(t.SCREEN_NPM = 19)] = 'SCREEN_NPM'),
				(t[(t.NONE = 20)] = 'NONE'),
				(t[(t.SRC_OVER = 0)] = 'SRC_OVER'),
				(t[(t.SRC_IN = 21)] = 'SRC_IN'),
				(t[(t.SRC_OUT = 22)] = 'SRC_OUT'),
				(t[(t.SRC_ATOP = 23)] = 'SRC_ATOP'),
				(t[(t.DST_OVER = 24)] = 'DST_OVER'),
				(t[(t.DST_IN = 25)] = 'DST_IN'),
				(t[(t.DST_OUT = 26)] = 'DST_OUT'),
				(t[(t.DST_ATOP = 27)] = 'DST_ATOP'),
				(t[(t.ERASE = 26)] = 'ERASE'),
				(t[(t.SUBTRACT = 28)] = 'SUBTRACT'),
				(t[(t.XOR = 29)] = 'XOR');
		})(BLEND_MODES$4 || (BLEND_MODES$4 = {})),
		(function (t) {
			(t[(t.POINTS = 0)] = 'POINTS'),
				(t[(t.LINES = 1)] = 'LINES'),
				(t[(t.LINE_LOOP = 2)] = 'LINE_LOOP'),
				(t[(t.LINE_STRIP = 3)] = 'LINE_STRIP'),
				(t[(t.TRIANGLES = 4)] = 'TRIANGLES'),
				(t[(t.TRIANGLE_STRIP = 5)] = 'TRIANGLE_STRIP'),
				(t[(t.TRIANGLE_FAN = 6)] = 'TRIANGLE_FAN');
		})(DRAW_MODES$4 || (DRAW_MODES$4 = {})),
		(function (t) {
			(t[(t.RGBA = 6408)] = 'RGBA'),
				(t[(t.RGB = 6407)] = 'RGB'),
				(t[(t.RG = 33319)] = 'RG'),
				(t[(t.RED = 6403)] = 'RED'),
				(t[(t.RGBA_INTEGER = 36249)] = 'RGBA_INTEGER'),
				(t[(t.RGB_INTEGER = 36248)] = 'RGB_INTEGER'),
				(t[(t.RG_INTEGER = 33320)] = 'RG_INTEGER'),
				(t[(t.RED_INTEGER = 36244)] = 'RED_INTEGER'),
				(t[(t.ALPHA = 6406)] = 'ALPHA'),
				(t[(t.LUMINANCE = 6409)] = 'LUMINANCE'),
				(t[(t.LUMINANCE_ALPHA = 6410)] = 'LUMINANCE_ALPHA'),
				(t[(t.DEPTH_COMPONENT = 6402)] = 'DEPTH_COMPONENT'),
				(t[(t.DEPTH_STENCIL = 34041)] = 'DEPTH_STENCIL');
		})(FORMATS$4 || (FORMATS$4 = {})),
		(function (t) {
			(t[(t.TEXTURE_2D = 3553)] = 'TEXTURE_2D'),
				(t[(t.TEXTURE_CUBE_MAP = 34067)] = 'TEXTURE_CUBE_MAP'),
				(t[(t.TEXTURE_2D_ARRAY = 35866)] = 'TEXTURE_2D_ARRAY'),
				(t[(t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069)] =
					'TEXTURE_CUBE_MAP_POSITIVE_X'),
				(t[(t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070)] =
					'TEXTURE_CUBE_MAP_NEGATIVE_X'),
				(t[(t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071)] =
					'TEXTURE_CUBE_MAP_POSITIVE_Y'),
				(t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072)] =
					'TEXTURE_CUBE_MAP_NEGATIVE_Y'),
				(t[(t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073)] =
					'TEXTURE_CUBE_MAP_POSITIVE_Z'),
				(t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074)] =
					'TEXTURE_CUBE_MAP_NEGATIVE_Z');
		})(TARGETS$4 || (TARGETS$4 = {})),
		(function (t) {
			(t[(t.UNSIGNED_BYTE = 5121)] = 'UNSIGNED_BYTE'),
				(t[(t.UNSIGNED_SHORT = 5123)] = 'UNSIGNED_SHORT'),
				(t[(t.UNSIGNED_SHORT_5_6_5 = 33635)] = 'UNSIGNED_SHORT_5_6_5'),
				(t[(t.UNSIGNED_SHORT_4_4_4_4 = 32819)] = 'UNSIGNED_SHORT_4_4_4_4'),
				(t[(t.UNSIGNED_SHORT_5_5_5_1 = 32820)] = 'UNSIGNED_SHORT_5_5_5_1'),
				(t[(t.UNSIGNED_INT = 5125)] = 'UNSIGNED_INT'),
				(t[(t.UNSIGNED_INT_10F_11F_11F_REV = 35899)] =
					'UNSIGNED_INT_10F_11F_11F_REV'),
				(t[(t.UNSIGNED_INT_2_10_10_10_REV = 33640)] =
					'UNSIGNED_INT_2_10_10_10_REV'),
				(t[(t.UNSIGNED_INT_24_8 = 34042)] = 'UNSIGNED_INT_24_8'),
				(t[(t.UNSIGNED_INT_5_9_9_9_REV = 35902)] = 'UNSIGNED_INT_5_9_9_9_REV'),
				(t[(t.BYTE = 5120)] = 'BYTE'),
				(t[(t.SHORT = 5122)] = 'SHORT'),
				(t[(t.INT = 5124)] = 'INT'),
				(t[(t.FLOAT = 5126)] = 'FLOAT'),
				(t[(t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269)] =
					'FLOAT_32_UNSIGNED_INT_24_8_REV'),
				(t[(t.HALF_FLOAT = 36193)] = 'HALF_FLOAT');
		})(TYPES$4 || (TYPES$4 = {})),
		(function (t) {
			(t[(t.FLOAT = 0)] = 'FLOAT'),
				(t[(t.INT = 1)] = 'INT'),
				(t[(t.UINT = 2)] = 'UINT');
		})(SAMPLER_TYPES$4 || (SAMPLER_TYPES$4 = {})),
		(function (t) {
			(t[(t.NEAREST = 0)] = 'NEAREST'), (t[(t.LINEAR = 1)] = 'LINEAR');
		})(SCALE_MODES$4 || (SCALE_MODES$4 = {})),
		(function (t) {
			(t[(t.CLAMP = 33071)] = 'CLAMP'),
				(t[(t.REPEAT = 10497)] = 'REPEAT'),
				(t[(t.MIRRORED_REPEAT = 33648)] = 'MIRRORED_REPEAT');
		})(WRAP_MODES$4 || (WRAP_MODES$4 = {})),
		(function (t) {
			(t[(t.OFF = 0)] = 'OFF'),
				(t[(t.POW2 = 1)] = 'POW2'),
				(t[(t.ON = 2)] = 'ON'),
				(t[(t.ON_MANUAL = 3)] = 'ON_MANUAL');
		})(MIPMAP_MODES$4 || (MIPMAP_MODES$4 = {})),
		(function (t) {
			(t[(t.NPM = 0)] = 'NPM'),
				(t[(t.UNPACK = 1)] = 'UNPACK'),
				(t[(t.PMA = 2)] = 'PMA'),
				(t[(t.NO_PREMULTIPLIED_ALPHA = 0)] = 'NO_PREMULTIPLIED_ALPHA'),
				(t[(t.PREMULTIPLY_ON_UPLOAD = 1)] = 'PREMULTIPLY_ON_UPLOAD'),
				(t[(t.PREMULTIPLY_ALPHA = 2)] = 'PREMULTIPLY_ALPHA'),
				(t[(t.PREMULTIPLIED_ALPHA = 2)] = 'PREMULTIPLIED_ALPHA');
		})(ALPHA_MODES$4 || (ALPHA_MODES$4 = {})),
		(function (t) {
			(t[(t.NO = 0)] = 'NO'),
				(t[(t.YES = 1)] = 'YES'),
				(t[(t.AUTO = 2)] = 'AUTO'),
				(t[(t.BLEND = 0)] = 'BLEND'),
				(t[(t.CLEAR = 1)] = 'CLEAR'),
				(t[(t.BLIT = 2)] = 'BLIT');
		})(CLEAR_MODES$4 || (CLEAR_MODES$4 = {})),
		(function (t) {
			(t[(t.AUTO = 0)] = 'AUTO'), (t[(t.MANUAL = 1)] = 'MANUAL');
		})(GC_MODES$4 || (GC_MODES$4 = {})),
		(function (t) {
			(t.LOW = 'lowp'), (t.MEDIUM = 'mediump'), (t.HIGH = 'highp');
		})(PRECISION$4 || (PRECISION$4 = {})),
		(function (t) {
			(t[(t.NONE = 0)] = 'NONE'),
				(t[(t.SCISSOR = 1)] = 'SCISSOR'),
				(t[(t.STENCIL = 2)] = 'STENCIL'),
				(t[(t.SPRITE = 3)] = 'SPRITE');
		})(MASK_TYPES$4 || (MASK_TYPES$4 = {})),
		(function (t) {
			(t[(t.NONE = 0)] = 'NONE'),
				(t[(t.LOW = 2)] = 'LOW'),
				(t[(t.MEDIUM = 4)] = 'MEDIUM'),
				(t[(t.HIGH = 8)] = 'HIGH');
		})(MSAA_QUALITY$4 || (MSAA_QUALITY$4 = {})),
		(function (t) {
			(t[(t.ELEMENT_ARRAY_BUFFER = 34963)] = 'ELEMENT_ARRAY_BUFFER'),
				(t[(t.ARRAY_BUFFER = 34962)] = 'ARRAY_BUFFER'),
				(t[(t.UNIFORM_BUFFER = 35345)] = 'UNIFORM_BUFFER');
		})(BUFFER_TYPE$4 || (BUFFER_TYPE$4 = {}));
	var settings$2 = {
			MIPMAP_TEXTURES: MIPMAP_MODES$4.POW2,
			ANISOTROPIC_LEVEL: 0,
			RESOLUTION: 1,
			FILTER_RESOLUTION: 1,
			FILTER_MULTISAMPLE: MSAA_QUALITY$4.NONE,
			SPRITE_MAX_TEXTURES: maxRecommendedTextures$1(32),
			SPRITE_BATCH_SIZE: 4096,
			RENDER_OPTIONS: {
				view: null,
				antialias: !1,
				autoDensity: !1,
				backgroundColor: 0,
				backgroundAlpha: 1,
				useContextAlpha: !0,
				clearBeforeRender: !0,
				preserveDrawingBuffer: !1,
				width: 800,
				height: 600,
				legacy: !1,
			},
			GC_MODE: GC_MODES$4.AUTO,
			GC_MAX_IDLE: 3600,
			GC_MAX_CHECK_COUNT: 600,
			WRAP_MODE: WRAP_MODES$4.CLAMP,
			SCALE_MODE: SCALE_MODES$4.LINEAR,
			PRECISION_VERTEX: PRECISION$4.HIGH,
			PRECISION_FRAGMENT: isMobile$1.apple.device
				? PRECISION$4.HIGH
				: PRECISION$4.MEDIUM,
			CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer$1(),
			CREATE_IMAGE_BITMAP: !1,
			ROUND_PIXELS: !1,
		},
		PI_2$1 = 2 * Math.PI,
		RAD_TO_DEG = 180 / Math.PI,
		DEG_TO_RAD = Math.PI / 180,
		SHAPES$1;
	/*!
	 * @pixi/math - v6.2.1
	 * Compiled Tue, 21 Dec 2021 19:56:15 UTC
	 *
	 * @pixi/math is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 */ !(function (t) {
		(t[(t.POLY = 0)] = 'POLY'),
			(t[(t.RECT = 1)] = 'RECT'),
			(t[(t.CIRC = 2)] = 'CIRC'),
			(t[(t.ELIP = 3)] = 'ELIP'),
			(t[(t.RREC = 4)] = 'RREC');
	})(SHAPES$1 || (SHAPES$1 = {}));
	var Rectangle$2 = (function () {
			function t(t, e, i, r) {
				void 0 === t && (t = 0),
					void 0 === e && (e = 0),
					void 0 === i && (i = 0),
					void 0 === r && (r = 0),
					(this.x = Number(t)),
					(this.y = Number(e)),
					(this.width = Number(i)),
					(this.height = Number(r)),
					(this.type = SHAPES$1.RECT);
			}
			return (
				Object.defineProperty(t.prototype, 'left', {
					get: function () {
						return this.x;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'right', {
					get: function () {
						return this.x + this.width;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'top', {
					get: function () {
						return this.y;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'bottom', {
					get: function () {
						return this.y + this.height;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t, 'EMPTY', {
					get: function () {
						return new t(0, 0, 0, 0);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.clone = function () {
					return new t(this.x, this.y, this.width, this.height);
				}),
				(t.prototype.copyFrom = function (t) {
					return (
						(this.x = t.x),
						(this.y = t.y),
						(this.width = t.width),
						(this.height = t.height),
						this
					);
				}),
				(t.prototype.copyTo = function (t) {
					return (
						(t.x = this.x),
						(t.y = this.y),
						(t.width = this.width),
						(t.height = this.height),
						t
					);
				}),
				(t.prototype.contains = function (t, e) {
					return (
						!(this.width <= 0 || this.height <= 0) &&
						t >= this.x &&
						t < this.x + this.width &&
						e >= this.y &&
						e < this.y + this.height
					);
				}),
				(t.prototype.pad = function (t, e) {
					return (
						void 0 === t && (t = 0),
						void 0 === e && (e = t),
						(this.x -= t),
						(this.y -= e),
						(this.width += 2 * t),
						(this.height += 2 * e),
						this
					);
				}),
				(t.prototype.fit = function (t) {
					var e = Math.max(this.x, t.x),
						i = Math.min(this.x + this.width, t.x + t.width),
						r = Math.max(this.y, t.y),
						s = Math.min(this.y + this.height, t.y + t.height);
					return (
						(this.x = e),
						(this.width = Math.max(i - e, 0)),
						(this.y = r),
						(this.height = Math.max(s - r, 0)),
						this
					);
				}),
				(t.prototype.ceil = function (t, e) {
					void 0 === t && (t = 1), void 0 === e && (e = 0.001);
					var i = Math.ceil((this.x + this.width - e) * t) / t,
						r = Math.ceil((this.y + this.height - e) * t) / t;
					return (
						(this.x = Math.floor((this.x + e) * t) / t),
						(this.y = Math.floor((this.y + e) * t) / t),
						(this.width = i - this.x),
						(this.height = r - this.y),
						this
					);
				}),
				(t.prototype.enlarge = function (t) {
					var e = Math.min(this.x, t.x),
						i = Math.max(this.x + this.width, t.x + t.width),
						r = Math.min(this.y, t.y),
						s = Math.max(this.y + this.height, t.y + t.height);
					return (
						(this.x = e),
						(this.width = i - e),
						(this.y = r),
						(this.height = s - r),
						this
					);
				}),
				(t.prototype.toString = function () {
					return (
						'[@pixi/math:Rectangle x=' +
						this.x +
						' y=' +
						this.y +
						' width=' +
						this.width +
						' height=' +
						this.height +
						']'
					);
				}),
				t
			);
		})(),
		Point$2 = (function () {
			function t(t, e) {
				void 0 === t && (t = 0),
					void 0 === e && (e = 0),
					(this.x = 0),
					(this.y = 0),
					(this.x = t),
					(this.y = e);
			}
			return (
				(t.prototype.clone = function () {
					return new t(this.x, this.y);
				}),
				(t.prototype.copyFrom = function (t) {
					return this.set(t.x, t.y), this;
				}),
				(t.prototype.copyTo = function (t) {
					return t.set(this.x, this.y), t;
				}),
				(t.prototype.equals = function (t) {
					return t.x === this.x && t.y === this.y;
				}),
				(t.prototype.set = function (t, e) {
					return (
						void 0 === t && (t = 0),
						void 0 === e && (e = t),
						(this.x = t),
						(this.y = e),
						this
					);
				}),
				(t.prototype.toString = function () {
					return '[@pixi/math:Point x=' + this.x + ' y=' + this.y + ']';
				}),
				t
			);
		})(),
		ObservablePoint$1 = (function () {
			function t(t, e, i, r) {
				void 0 === i && (i = 0),
					void 0 === r && (r = 0),
					(this._x = i),
					(this._y = r),
					(this.cb = t),
					(this.scope = e);
			}
			return (
				(t.prototype.clone = function (e, i) {
					return (
						void 0 === e && (e = this.cb),
						void 0 === i && (i = this.scope),
						new t(e, i, this._x, this._y)
					);
				}),
				(t.prototype.set = function (t, e) {
					return (
						void 0 === t && (t = 0),
						void 0 === e && (e = t),
						(this._x === t && this._y === e) ||
							((this._x = t), (this._y = e), this.cb.call(this.scope)),
						this
					);
				}),
				(t.prototype.copyFrom = function (t) {
					return (
						(this._x === t.x && this._y === t.y) ||
							((this._x = t.x), (this._y = t.y), this.cb.call(this.scope)),
						this
					);
				}),
				(t.prototype.copyTo = function (t) {
					return t.set(this._x, this._y), t;
				}),
				(t.prototype.equals = function (t) {
					return t.x === this._x && t.y === this._y;
				}),
				(t.prototype.toString = function () {
					return (
						'[@pixi/math:ObservablePoint x=0 y=0 scope=' + this.scope + ']'
					);
				}),
				Object.defineProperty(t.prototype, 'x', {
					get: function () {
						return this._x;
					},
					set: function (t) {
						this._x !== t && ((this._x = t), this.cb.call(this.scope));
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'y', {
					get: function () {
						return this._y;
					},
					set: function (t) {
						this._y !== t && ((this._y = t), this.cb.call(this.scope));
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			);
		})(),
		Matrix$1 = (function () {
			function t(t, e, i, r, s, n) {
				void 0 === t && (t = 1),
					void 0 === e && (e = 0),
					void 0 === i && (i = 0),
					void 0 === r && (r = 1),
					void 0 === s && (s = 0),
					void 0 === n && (n = 0),
					(this.array = null),
					(this.a = t),
					(this.b = e),
					(this.c = i),
					(this.d = r),
					(this.tx = s),
					(this.ty = n);
			}
			return (
				(t.prototype.fromArray = function (t) {
					(this.a = t[0]),
						(this.b = t[1]),
						(this.c = t[3]),
						(this.d = t[4]),
						(this.tx = t[2]),
						(this.ty = t[5]);
				}),
				(t.prototype.set = function (t, e, i, r, s, n) {
					return (
						(this.a = t),
						(this.b = e),
						(this.c = i),
						(this.d = r),
						(this.tx = s),
						(this.ty = n),
						this
					);
				}),
				(t.prototype.toArray = function (t, e) {
					this.array || (this.array = new Float32Array(9));
					var i = e || this.array;
					return (
						t
							? ((i[0] = this.a),
							  (i[1] = this.b),
							  (i[2] = 0),
							  (i[3] = this.c),
							  (i[4] = this.d),
							  (i[5] = 0),
							  (i[6] = this.tx),
							  (i[7] = this.ty),
							  (i[8] = 1))
							: ((i[0] = this.a),
							  (i[1] = this.c),
							  (i[2] = this.tx),
							  (i[3] = this.b),
							  (i[4] = this.d),
							  (i[5] = this.ty),
							  (i[6] = 0),
							  (i[7] = 0),
							  (i[8] = 1)),
						i
					);
				}),
				(t.prototype.apply = function (t, e) {
					e = e || new Point$2();
					var i = t.x,
						r = t.y;
					return (
						(e.x = this.a * i + this.c * r + this.tx),
						(e.y = this.b * i + this.d * r + this.ty),
						e
					);
				}),
				(t.prototype.applyInverse = function (t, e) {
					e = e || new Point$2();
					var i = 1 / (this.a * this.d + this.c * -this.b),
						r = t.x,
						s = t.y;
					return (
						(e.x =
							this.d * i * r +
							-this.c * i * s +
							(this.ty * this.c - this.tx * this.d) * i),
						(e.y =
							this.a * i * s +
							-this.b * i * r +
							(-this.ty * this.a + this.tx * this.b) * i),
						e
					);
				}),
				(t.prototype.translate = function (t, e) {
					return (this.tx += t), (this.ty += e), this;
				}),
				(t.prototype.scale = function (t, e) {
					return (
						(this.a *= t),
						(this.d *= e),
						(this.c *= t),
						(this.b *= e),
						(this.tx *= t),
						(this.ty *= e),
						this
					);
				}),
				(t.prototype.rotate = function (t) {
					var e = Math.cos(t),
						i = Math.sin(t),
						r = this.a,
						s = this.c,
						n = this.tx;
					return (
						(this.a = r * e - this.b * i),
						(this.b = r * i + this.b * e),
						(this.c = s * e - this.d * i),
						(this.d = s * i + this.d * e),
						(this.tx = n * e - this.ty * i),
						(this.ty = n * i + this.ty * e),
						this
					);
				}),
				(t.prototype.append = function (t) {
					var e = this.a,
						i = this.b,
						r = this.c,
						s = this.d;
					return (
						(this.a = t.a * e + t.b * r),
						(this.b = t.a * i + t.b * s),
						(this.c = t.c * e + t.d * r),
						(this.d = t.c * i + t.d * s),
						(this.tx = t.tx * e + t.ty * r + this.tx),
						(this.ty = t.tx * i + t.ty * s + this.ty),
						this
					);
				}),
				(t.prototype.setTransform = function (t, e, i, r, s, n, a, o, h) {
					return (
						(this.a = Math.cos(a + h) * s),
						(this.b = Math.sin(a + h) * s),
						(this.c = -Math.sin(a - o) * n),
						(this.d = Math.cos(a - o) * n),
						(this.tx = t - (i * this.a + r * this.c)),
						(this.ty = e - (i * this.b + r * this.d)),
						this
					);
				}),
				(t.prototype.prepend = function (t) {
					var e = this.tx;
					if (1 !== t.a || 0 !== t.b || 0 !== t.c || 1 !== t.d) {
						var i = this.a,
							r = this.c;
						(this.a = i * t.a + this.b * t.c),
							(this.b = i * t.b + this.b * t.d),
							(this.c = r * t.a + this.d * t.c),
							(this.d = r * t.b + this.d * t.d);
					}
					return (
						(this.tx = e * t.a + this.ty * t.c + t.tx),
						(this.ty = e * t.b + this.ty * t.d + t.ty),
						this
					);
				}),
				(t.prototype.decompose = function (t) {
					var e = this.a,
						i = this.b,
						r = this.c,
						s = this.d,
						n = t.pivot,
						a = -Math.atan2(-r, s),
						o = Math.atan2(i, e),
						h = Math.abs(a + o);
					return (
						h < 1e-5 || Math.abs(PI_2$1 - h) < 1e-5
							? ((t.rotation = o), (t.skew.x = t.skew.y = 0))
							: ((t.rotation = 0), (t.skew.x = a), (t.skew.y = o)),
						(t.scale.x = Math.sqrt(e * e + i * i)),
						(t.scale.y = Math.sqrt(r * r + s * s)),
						(t.position.x = this.tx + (n.x * e + n.y * r)),
						(t.position.y = this.ty + (n.x * i + n.y * s)),
						t
					);
				}),
				(t.prototype.invert = function () {
					var t = this.a,
						e = this.b,
						i = this.c,
						r = this.d,
						s = this.tx,
						n = t * r - e * i;
					return (
						(this.a = r / n),
						(this.b = -e / n),
						(this.c = -i / n),
						(this.d = t / n),
						(this.tx = (i * this.ty - r * s) / n),
						(this.ty = -(t * this.ty - e * s) / n),
						this
					);
				}),
				(t.prototype.identity = function () {
					return (
						(this.a = 1),
						(this.b = 0),
						(this.c = 0),
						(this.d = 1),
						(this.tx = 0),
						(this.ty = 0),
						this
					);
				}),
				(t.prototype.clone = function () {
					var e = new t();
					return (
						(e.a = this.a),
						(e.b = this.b),
						(e.c = this.c),
						(e.d = this.d),
						(e.tx = this.tx),
						(e.ty = this.ty),
						e
					);
				}),
				(t.prototype.copyTo = function (t) {
					return (
						(t.a = this.a),
						(t.b = this.b),
						(t.c = this.c),
						(t.d = this.d),
						(t.tx = this.tx),
						(t.ty = this.ty),
						t
					);
				}),
				(t.prototype.copyFrom = function (t) {
					return (
						(this.a = t.a),
						(this.b = t.b),
						(this.c = t.c),
						(this.d = t.d),
						(this.tx = t.tx),
						(this.ty = t.ty),
						this
					);
				}),
				(t.prototype.toString = function () {
					return (
						'[@pixi/math:Matrix a=' +
						this.a +
						' b=' +
						this.b +
						' c=' +
						this.c +
						' d=' +
						this.d +
						' tx=' +
						this.tx +
						' ty=' +
						this.ty +
						']'
					);
				}),
				Object.defineProperty(t, 'IDENTITY', {
					get: function () {
						return new t();
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t, 'TEMP_MATRIX', {
					get: function () {
						return new t();
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			);
		})(),
		ux$1 = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1],
		uy$1 = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1],
		vx$1 = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1],
		vy$1 = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1],
		rotationCayley$1 = [],
		rotationMatrices$1 = [],
		signum$1 = Math.sign;
	function init$1() {
		for (var t = 0; t < 16; t++) {
			var e = [];
			rotationCayley$1.push(e);
			for (var i = 0; i < 16; i++)
				for (
					var r = signum$1(ux$1[t] * ux$1[i] + vx$1[t] * uy$1[i]),
						s = signum$1(uy$1[t] * ux$1[i] + vy$1[t] * uy$1[i]),
						n = signum$1(ux$1[t] * vx$1[i] + vx$1[t] * vy$1[i]),
						a = signum$1(uy$1[t] * vx$1[i] + vy$1[t] * vy$1[i]),
						o = 0;
					o < 16;
					o++
				)
					if (
						ux$1[o] === r &&
						uy$1[o] === s &&
						vx$1[o] === n &&
						vy$1[o] === a
					) {
						e.push(o);
						break;
					}
		}
		for (t = 0; t < 16; t++) {
			var h = new Matrix$1();
			h.set(ux$1[t], uy$1[t], vx$1[t], vy$1[t], 0, 0),
				rotationMatrices$1.push(h);
		}
	}
	init$1();
	var groupD8$1 = {
			E: 0,
			SE: 1,
			S: 2,
			SW: 3,
			W: 4,
			NW: 5,
			N: 6,
			NE: 7,
			MIRROR_VERTICAL: 8,
			MAIN_DIAGONAL: 10,
			MIRROR_HORIZONTAL: 12,
			REVERSE_DIAGONAL: 14,
			uX: function (t) {
				return ux$1[t];
			},
			uY: function (t) {
				return uy$1[t];
			},
			vX: function (t) {
				return vx$1[t];
			},
			vY: function (t) {
				return vy$1[t];
			},
			inv: function (t) {
				return 8 & t ? 15 & t : 7 & -t;
			},
			add: function (t, e) {
				return rotationCayley$1[t][e];
			},
			sub: function (t, e) {
				return rotationCayley$1[t][groupD8$1.inv(e)];
			},
			rotate180: function (t) {
				return 4 ^ t;
			},
			isVertical: function (t) {
				return 2 == (3 & t);
			},
			byDirection: function (t, e) {
				return 2 * Math.abs(t) <= Math.abs(e)
					? e >= 0
						? groupD8$1.S
						: groupD8$1.N
					: 2 * Math.abs(e) <= Math.abs(t)
					? t > 0
						? groupD8$1.E
						: groupD8$1.W
					: e > 0
					? t > 0
						? groupD8$1.SE
						: groupD8$1.SW
					: t > 0
					? groupD8$1.NE
					: groupD8$1.NW;
			},
			matrixAppendRotationInv: function (t, e, i, r) {
				void 0 === i && (i = 0), void 0 === r && (r = 0);
				var s = rotationMatrices$1[groupD8$1.inv(e)];
				(s.tx = i), (s.ty = r), t.append(s);
			},
		},
		Transform = (function () {
			function t() {
				(this.worldTransform = new Matrix$1()),
					(this.localTransform = new Matrix$1()),
					(this.position = new ObservablePoint$1(this.onChange, this, 0, 0)),
					(this.scale = new ObservablePoint$1(this.onChange, this, 1, 1)),
					(this.pivot = new ObservablePoint$1(this.onChange, this, 0, 0)),
					(this.skew = new ObservablePoint$1(this.updateSkew, this, 0, 0)),
					(this._rotation = 0),
					(this._cx = 1),
					(this._sx = 0),
					(this._cy = 0),
					(this._sy = 1),
					(this._localID = 0),
					(this._currentLocalID = 0),
					(this._worldID = 0),
					(this._parentID = 0);
			}
			return (
				(t.prototype.onChange = function () {
					this._localID++;
				}),
				(t.prototype.updateSkew = function () {
					(this._cx = Math.cos(this._rotation + this.skew.y)),
						(this._sx = Math.sin(this._rotation + this.skew.y)),
						(this._cy = -Math.sin(this._rotation - this.skew.x)),
						(this._sy = Math.cos(this._rotation - this.skew.x)),
						this._localID++;
				}),
				(t.prototype.toString = function () {
					return (
						'[@pixi/math:Transform position=(' +
						this.position.x +
						', ' +
						this.position.y +
						') rotation=' +
						this.rotation +
						' scale=(' +
						this.scale.x +
						', ' +
						this.scale.y +
						') skew=(' +
						this.skew.x +
						', ' +
						this.skew.y +
						') ]'
					);
				}),
				(t.prototype.updateLocalTransform = function () {
					var t = this.localTransform;
					this._localID !== this._currentLocalID &&
						((t.a = this._cx * this.scale.x),
						(t.b = this._sx * this.scale.x),
						(t.c = this._cy * this.scale.y),
						(t.d = this._sy * this.scale.y),
						(t.tx =
							this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c)),
						(t.ty =
							this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d)),
						(this._currentLocalID = this._localID),
						(this._parentID = -1));
				}),
				(t.prototype.updateTransform = function (t) {
					var e = this.localTransform;
					if (
						(this._localID !== this._currentLocalID &&
							((e.a = this._cx * this.scale.x),
							(e.b = this._sx * this.scale.x),
							(e.c = this._cy * this.scale.y),
							(e.d = this._sy * this.scale.y),
							(e.tx =
								this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c)),
							(e.ty =
								this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d)),
							(this._currentLocalID = this._localID),
							(this._parentID = -1)),
						this._parentID !== t._worldID)
					) {
						var i = t.worldTransform,
							r = this.worldTransform;
						(r.a = e.a * i.a + e.b * i.c),
							(r.b = e.a * i.b + e.b * i.d),
							(r.c = e.c * i.a + e.d * i.c),
							(r.d = e.c * i.b + e.d * i.d),
							(r.tx = e.tx * i.a + e.ty * i.c + i.tx),
							(r.ty = e.tx * i.b + e.ty * i.d + i.ty),
							(this._parentID = t._worldID),
							this._worldID++;
					}
				}),
				(t.prototype.setFromMatrix = function (t) {
					t.decompose(this), this._localID++;
				}),
				Object.defineProperty(t.prototype, 'rotation', {
					get: function () {
						return this._rotation;
					},
					set: function (t) {
						this._rotation !== t && ((this._rotation = t), this.updateSkew());
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.IDENTITY = new t()),
				t
			);
		})(),
		ENV$3,
		RENDERER_TYPE$3,
		BUFFER_BITS$3,
		BLEND_MODES$3,
		DRAW_MODES$3,
		FORMATS$3,
		TARGETS$3,
		TYPES$3,
		SAMPLER_TYPES$3,
		SCALE_MODES$3,
		WRAP_MODES$3,
		MIPMAP_MODES$3,
		ALPHA_MODES$3,
		CLEAR_MODES$3,
		GC_MODES$3,
		PRECISION$3,
		MASK_TYPES$3,
		MSAA_QUALITY$3,
		BUFFER_TYPE$3;
	!(function (t) {
		(t[(t.WEBGL_LEGACY = 0)] = 'WEBGL_LEGACY'),
			(t[(t.WEBGL = 1)] = 'WEBGL'),
			(t[(t.WEBGL2 = 2)] = 'WEBGL2');
	})(ENV$3 || (ENV$3 = {})),
		(function (t) {
			(t[(t.UNKNOWN = 0)] = 'UNKNOWN'),
				(t[(t.WEBGL = 1)] = 'WEBGL'),
				(t[(t.CANVAS = 2)] = 'CANVAS');
		})(RENDERER_TYPE$3 || (RENDERER_TYPE$3 = {})),
		(function (t) {
			(t[(t.COLOR = 16384)] = 'COLOR'),
				(t[(t.DEPTH = 256)] = 'DEPTH'),
				(t[(t.STENCIL = 1024)] = 'STENCIL');
		})(BUFFER_BITS$3 || (BUFFER_BITS$3 = {})),
		(function (t) {
			(t[(t.NORMAL = 0)] = 'NORMAL'),
				(t[(t.ADD = 1)] = 'ADD'),
				(t[(t.MULTIPLY = 2)] = 'MULTIPLY'),
				(t[(t.SCREEN = 3)] = 'SCREEN'),
				(t[(t.OVERLAY = 4)] = 'OVERLAY'),
				(t[(t.DARKEN = 5)] = 'DARKEN'),
				(t[(t.LIGHTEN = 6)] = 'LIGHTEN'),
				(t[(t.COLOR_DODGE = 7)] = 'COLOR_DODGE'),
				(t[(t.COLOR_BURN = 8)] = 'COLOR_BURN'),
				(t[(t.HARD_LIGHT = 9)] = 'HARD_LIGHT'),
				(t[(t.SOFT_LIGHT = 10)] = 'SOFT_LIGHT'),
				(t[(t.DIFFERENCE = 11)] = 'DIFFERENCE'),
				(t[(t.EXCLUSION = 12)] = 'EXCLUSION'),
				(t[(t.HUE = 13)] = 'HUE'),
				(t[(t.SATURATION = 14)] = 'SATURATION'),
				(t[(t.COLOR = 15)] = 'COLOR'),
				(t[(t.LUMINOSITY = 16)] = 'LUMINOSITY'),
				(t[(t.NORMAL_NPM = 17)] = 'NORMAL_NPM'),
				(t[(t.ADD_NPM = 18)] = 'ADD_NPM'),
				(t[(t.SCREEN_NPM = 19)] = 'SCREEN_NPM'),
				(t[(t.NONE = 20)] = 'NONE'),
				(t[(t.SRC_OVER = 0)] = 'SRC_OVER'),
				(t[(t.SRC_IN = 21)] = 'SRC_IN'),
				(t[(t.SRC_OUT = 22)] = 'SRC_OUT'),
				(t[(t.SRC_ATOP = 23)] = 'SRC_ATOP'),
				(t[(t.DST_OVER = 24)] = 'DST_OVER'),
				(t[(t.DST_IN = 25)] = 'DST_IN'),
				(t[(t.DST_OUT = 26)] = 'DST_OUT'),
				(t[(t.DST_ATOP = 27)] = 'DST_ATOP'),
				(t[(t.ERASE = 26)] = 'ERASE'),
				(t[(t.SUBTRACT = 28)] = 'SUBTRACT'),
				(t[(t.XOR = 29)] = 'XOR');
		})(BLEND_MODES$3 || (BLEND_MODES$3 = {})),
		(function (t) {
			(t[(t.POINTS = 0)] = 'POINTS'),
				(t[(t.LINES = 1)] = 'LINES'),
				(t[(t.LINE_LOOP = 2)] = 'LINE_LOOP'),
				(t[(t.LINE_STRIP = 3)] = 'LINE_STRIP'),
				(t[(t.TRIANGLES = 4)] = 'TRIANGLES'),
				(t[(t.TRIANGLE_STRIP = 5)] = 'TRIANGLE_STRIP'),
				(t[(t.TRIANGLE_FAN = 6)] = 'TRIANGLE_FAN');
		})(DRAW_MODES$3 || (DRAW_MODES$3 = {})),
		(function (t) {
			(t[(t.RGBA = 6408)] = 'RGBA'),
				(t[(t.RGB = 6407)] = 'RGB'),
				(t[(t.RG = 33319)] = 'RG'),
				(t[(t.RED = 6403)] = 'RED'),
				(t[(t.RGBA_INTEGER = 36249)] = 'RGBA_INTEGER'),
				(t[(t.RGB_INTEGER = 36248)] = 'RGB_INTEGER'),
				(t[(t.RG_INTEGER = 33320)] = 'RG_INTEGER'),
				(t[(t.RED_INTEGER = 36244)] = 'RED_INTEGER'),
				(t[(t.ALPHA = 6406)] = 'ALPHA'),
				(t[(t.LUMINANCE = 6409)] = 'LUMINANCE'),
				(t[(t.LUMINANCE_ALPHA = 6410)] = 'LUMINANCE_ALPHA'),
				(t[(t.DEPTH_COMPONENT = 6402)] = 'DEPTH_COMPONENT'),
				(t[(t.DEPTH_STENCIL = 34041)] = 'DEPTH_STENCIL');
		})(FORMATS$3 || (FORMATS$3 = {})),
		(function (t) {
			(t[(t.TEXTURE_2D = 3553)] = 'TEXTURE_2D'),
				(t[(t.TEXTURE_CUBE_MAP = 34067)] = 'TEXTURE_CUBE_MAP'),
				(t[(t.TEXTURE_2D_ARRAY = 35866)] = 'TEXTURE_2D_ARRAY'),
				(t[(t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069)] =
					'TEXTURE_CUBE_MAP_POSITIVE_X'),
				(t[(t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070)] =
					'TEXTURE_CUBE_MAP_NEGATIVE_X'),
				(t[(t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071)] =
					'TEXTURE_CUBE_MAP_POSITIVE_Y'),
				(t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072)] =
					'TEXTURE_CUBE_MAP_NEGATIVE_Y'),
				(t[(t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073)] =
					'TEXTURE_CUBE_MAP_POSITIVE_Z'),
				(t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074)] =
					'TEXTURE_CUBE_MAP_NEGATIVE_Z');
		})(TARGETS$3 || (TARGETS$3 = {})),
		(function (t) {
			(t[(t.UNSIGNED_BYTE = 5121)] = 'UNSIGNED_BYTE'),
				(t[(t.UNSIGNED_SHORT = 5123)] = 'UNSIGNED_SHORT'),
				(t[(t.UNSIGNED_SHORT_5_6_5 = 33635)] = 'UNSIGNED_SHORT_5_6_5'),
				(t[(t.UNSIGNED_SHORT_4_4_4_4 = 32819)] = 'UNSIGNED_SHORT_4_4_4_4'),
				(t[(t.UNSIGNED_SHORT_5_5_5_1 = 32820)] = 'UNSIGNED_SHORT_5_5_5_1'),
				(t[(t.UNSIGNED_INT = 5125)] = 'UNSIGNED_INT'),
				(t[(t.UNSIGNED_INT_10F_11F_11F_REV = 35899)] =
					'UNSIGNED_INT_10F_11F_11F_REV'),
				(t[(t.UNSIGNED_INT_2_10_10_10_REV = 33640)] =
					'UNSIGNED_INT_2_10_10_10_REV'),
				(t[(t.UNSIGNED_INT_24_8 = 34042)] = 'UNSIGNED_INT_24_8'),
				(t[(t.UNSIGNED_INT_5_9_9_9_REV = 35902)] = 'UNSIGNED_INT_5_9_9_9_REV'),
				(t[(t.BYTE = 5120)] = 'BYTE'),
				(t[(t.SHORT = 5122)] = 'SHORT'),
				(t[(t.INT = 5124)] = 'INT'),
				(t[(t.FLOAT = 5126)] = 'FLOAT'),
				(t[(t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269)] =
					'FLOAT_32_UNSIGNED_INT_24_8_REV'),
				(t[(t.HALF_FLOAT = 36193)] = 'HALF_FLOAT');
		})(TYPES$3 || (TYPES$3 = {})),
		(function (t) {
			(t[(t.FLOAT = 0)] = 'FLOAT'),
				(t[(t.INT = 1)] = 'INT'),
				(t[(t.UINT = 2)] = 'UINT');
		})(SAMPLER_TYPES$3 || (SAMPLER_TYPES$3 = {})),
		(function (t) {
			(t[(t.NEAREST = 0)] = 'NEAREST'), (t[(t.LINEAR = 1)] = 'LINEAR');
		})(SCALE_MODES$3 || (SCALE_MODES$3 = {})),
		(function (t) {
			(t[(t.CLAMP = 33071)] = 'CLAMP'),
				(t[(t.REPEAT = 10497)] = 'REPEAT'),
				(t[(t.MIRRORED_REPEAT = 33648)] = 'MIRRORED_REPEAT');
		})(WRAP_MODES$3 || (WRAP_MODES$3 = {})),
		(function (t) {
			(t[(t.OFF = 0)] = 'OFF'),
				(t[(t.POW2 = 1)] = 'POW2'),
				(t[(t.ON = 2)] = 'ON'),
				(t[(t.ON_MANUAL = 3)] = 'ON_MANUAL');
		})(MIPMAP_MODES$3 || (MIPMAP_MODES$3 = {})),
		(function (t) {
			(t[(t.NPM = 0)] = 'NPM'),
				(t[(t.UNPACK = 1)] = 'UNPACK'),
				(t[(t.PMA = 2)] = 'PMA'),
				(t[(t.NO_PREMULTIPLIED_ALPHA = 0)] = 'NO_PREMULTIPLIED_ALPHA'),
				(t[(t.PREMULTIPLY_ON_UPLOAD = 1)] = 'PREMULTIPLY_ON_UPLOAD'),
				(t[(t.PREMULTIPLY_ALPHA = 2)] = 'PREMULTIPLY_ALPHA'),
				(t[(t.PREMULTIPLIED_ALPHA = 2)] = 'PREMULTIPLIED_ALPHA');
		})(ALPHA_MODES$3 || (ALPHA_MODES$3 = {})),
		(function (t) {
			(t[(t.NO = 0)] = 'NO'),
				(t[(t.YES = 1)] = 'YES'),
				(t[(t.AUTO = 2)] = 'AUTO'),
				(t[(t.BLEND = 0)] = 'BLEND'),
				(t[(t.CLEAR = 1)] = 'CLEAR'),
				(t[(t.BLIT = 2)] = 'BLIT');
		})(CLEAR_MODES$3 || (CLEAR_MODES$3 = {})),
		(function (t) {
			(t[(t.AUTO = 0)] = 'AUTO'), (t[(t.MANUAL = 1)] = 'MANUAL');
		})(GC_MODES$3 || (GC_MODES$3 = {})),
		(function (t) {
			(t.LOW = 'lowp'), (t.MEDIUM = 'mediump'), (t.HIGH = 'highp');
		})(PRECISION$3 || (PRECISION$3 = {})),
		(function (t) {
			(t[(t.NONE = 0)] = 'NONE'),
				(t[(t.SCISSOR = 1)] = 'SCISSOR'),
				(t[(t.STENCIL = 2)] = 'STENCIL'),
				(t[(t.SPRITE = 3)] = 'SPRITE');
		})(MASK_TYPES$3 || (MASK_TYPES$3 = {})),
		(function (t) {
			(t[(t.NONE = 0)] = 'NONE'),
				(t[(t.LOW = 2)] = 'LOW'),
				(t[(t.MEDIUM = 4)] = 'MEDIUM'),
				(t[(t.HIGH = 8)] = 'HIGH');
		})(MSAA_QUALITY$3 || (MSAA_QUALITY$3 = {})),
		(function (t) {
			(t[(t.ELEMENT_ARRAY_BUFFER = 34963)] = 'ELEMENT_ARRAY_BUFFER'),
				(t[(t.ARRAY_BUFFER = 34962)] = 'ARRAY_BUFFER'),
				(t[(t.UNIFORM_BUFFER = 35345)] = 'UNIFORM_BUFFER');
		})(BUFFER_TYPE$3 || (BUFFER_TYPE$3 = {}));
	const { parse: parse$1 } = url$1,
		{ format: format$1 } = url$1,
		{ resolve: resolve$1 } = url$1;
	/*!
	 * @pixi/utils - v6.2.1
	 * Compiled Tue, 21 Dec 2021 19:56:15 UTC
	 *
	 * @pixi/utils is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 */
	var url2$1 = { parse: parse$1, format: format$1, resolve: resolve$1 };
	(settings$2.RETINA_PREFIX = /@([0-9\.]+)x/),
		(settings$2.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1);
	var saidHello$1 = !1,
		VERSION$1 = '6.2.1',
		supported$1;
	function sayHello$1(t) {
		var e;
		if (!saidHello$1) {
			if (navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
				var i = [
					'\n %c %c %c PixiJS ' +
						VERSION$1 +
						' - ✰ ' +
						t +
						' ✰  %c  %c  http://www.pixijs.com/  %c %c ♥%c♥%c♥ \n\n',
					'background: #ff66a5; padding:5px 0;',
					'background: #ff66a5; padding:5px 0;',
					'color: #ff66a5; background: #030307; padding:5px 0;',
					'background: #ff66a5; padding:5px 0;',
					'background: #ffc3dc; padding:5px 0;',
					'background: #ff66a5; padding:5px 0;',
					'color: #ff2424; background: #fff; padding:5px 0;',
					'color: #ff2424; background: #fff; padding:5px 0;',
					'color: #ff2424; background: #fff; padding:5px 0;',
				];
				(e = self.console).log.apply(e, i);
			} else
				self.console &&
					self.console.log(
						'PixiJS ' + VERSION$1 + ' - ' + t + ' - http://www.pixijs.com/'
					);
			saidHello$1 = !0;
		}
	}
	function isWebGLSupported$1() {
		return (
			void 0 === supported$1 &&
				(supported$1 = (function () {
					var t = {
						stencil: !0,
						failIfMajorPerformanceCaveat:
							settings$2.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT,
					};
					try {
						if (!self.WebGLRenderingContext) return !1;
						var e = document.createElement('canvas'),
							i =
								e.getContext('webgl', t) ||
								e.getContext('experimental-webgl', t),
							r = !(!i || !i.getContextAttributes().stencil);
						if (i) {
							var s = i.getExtension('WEBGL_lose_context');
							s && s.loseContext();
						}
						return (i = null), r;
					} catch (t) {
						return !1;
					}
				})()),
			supported$1
		);
	}
	function hex2rgb$1(t, e) {
		return (
			void 0 === e && (e = []),
			(e[0] = ((t >> 16) & 255) / 255),
			(e[1] = ((t >> 8) & 255) / 255),
			(e[2] = (255 & t) / 255),
			e
		);
	}
	function hex2string$1(t) {
		var e = t.toString(16);
		return '#' + ('000000'.substr(0, 6 - e.length) + e);
	}
	function mapPremultipliedBlendModes$1() {
		for (var t = [], e = [], i = 0; i < 32; i++) (t[i] = i), (e[i] = i);
		(t[BLEND_MODES$3.NORMAL_NPM] = BLEND_MODES$3.NORMAL),
			(t[BLEND_MODES$3.ADD_NPM] = BLEND_MODES$3.ADD),
			(t[BLEND_MODES$3.SCREEN_NPM] = BLEND_MODES$3.SCREEN),
			(e[BLEND_MODES$3.NORMAL] = BLEND_MODES$3.NORMAL_NPM),
			(e[BLEND_MODES$3.ADD] = BLEND_MODES$3.ADD_NPM),
			(e[BLEND_MODES$3.SCREEN] = BLEND_MODES$3.SCREEN_NPM);
		var r = [];
		return r.push(e), r.push(t), r;
	}
	var premultiplyBlendMode$1 = mapPremultipliedBlendModes$1();
	function premultiplyTint$1(t, e) {
		if (1 === e) return ((255 * e) << 24) + t;
		if (0 === e) return 0;
		var i = (t >> 16) & 255,
			r = (t >> 8) & 255,
			s = 255 & t;
		return (
			((255 * e) << 24) +
			((i = (i * e + 0.5) | 0) << 16) +
			((r = (r * e + 0.5) | 0) << 8) +
			((s * e + 0.5) | 0)
		);
	}
	function createIndicesForQuads(t, e) {
		void 0 === e && (e = null);
		var i = 6 * t;
		if ((e = e || new Uint16Array(i)).length !== i)
			throw new Error(
				'Out buffer length is incorrect, got ' + e.length + ' and expected ' + i
			);
		for (var r = 0, s = 0; r < i; r += 6, s += 4)
			(e[r + 0] = s + 0),
				(e[r + 1] = s + 1),
				(e[r + 2] = s + 2),
				(e[r + 3] = s + 0),
				(e[r + 4] = s + 2),
				(e[r + 5] = s + 3);
		return e;
	}
	function getBufferType$1(t) {
		if (4 === t.BYTES_PER_ELEMENT)
			return t instanceof Float32Array
				? 'Float32Array'
				: t instanceof Uint32Array
				? 'Uint32Array'
				: 'Int32Array';
		if (2 === t.BYTES_PER_ELEMENT) {
			if (t instanceof Uint16Array) return 'Uint16Array';
		} else if (1 === t.BYTES_PER_ELEMENT && t instanceof Uint8Array)
			return 'Uint8Array';
		return null;
	}
	function nextPow2$1(t) {
		return (
			(t += 0 === t ? 1 : 0),
			--t,
			(t |= t >>> 1),
			(t |= t >>> 2),
			(t |= t >>> 4),
			(t |= t >>> 8),
			1 + (t |= t >>> 16)
		);
	}
	function isPow2$1(t) {
		return !(t & (t - 1) || !t);
	}
	function log2$1(t) {
		var e = (t > 65535 ? 1 : 0) << 4,
			i = ((t >>>= e) > 255 ? 1 : 0) << 3;
		return (
			(e |= i),
			(e |= i = ((t >>>= i) > 15 ? 1 : 0) << 2),
			(e |= i = ((t >>>= i) > 3 ? 1 : 0) << 1) | ((t >>>= i) >> 1)
		);
	}
	function removeItems$1(t, e, i) {
		var r,
			s = t.length;
		if (!(e >= s || 0 === i)) {
			var n = s - (i = e + i > s ? s - e : i);
			for (r = e; r < n; ++r) t[r] = t[r + i];
			t.length = n;
		}
	}
	var nextUid$1 = 0;
	function uid$1() {
		return ++nextUid$1;
	}
	var warnings$1 = {};
	function deprecation$1(t, e, i) {
		if ((void 0 === i && (i = 3), !warnings$1[e])) {
			var r = new Error().stack;
			void 0 === r ||
				((r = r.split('\n').splice(i).join('\n')), console.groupCollapsed),
				(warnings$1[e] = !0);
		}
	}
	var ProgramCache$1 = {},
		TextureCache$1 = Object.create(null),
		BaseTextureCache$1 = Object.create(null),
		tempAnchor$1;
	function determineCrossOrigin$1(t, e) {
		if ((void 0 === e && (e = self.location), 0 === t.indexOf('data:')))
			return '';
		(e = e || self.location),
			tempAnchor$1 || (tempAnchor$1 = document.createElement('a')),
			(tempAnchor$1.href = t);
		var i = url2$1.parse(tempAnchor$1.href),
			r = (!i.port && '' === e.port) || i.port === e.port;
		return i.hostname === e.hostname && r && i.protocol === e.protocol
			? ''
			: 'anonymous';
	}
	function getResolutionOfUrl$1(t, e) {
		var i = settings$2.RETINA_PREFIX.exec(t);
		return i ? parseFloat(i[1]) : void 0 !== e ? e : 1;
	}
	/*!
	 * @pixi/display - v6.2.1
	 * Compiled Tue, 21 Dec 2021 19:56:15 UTC
	 *
	 * @pixi/display is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 */ !(function () {
		function t(t, e, i) {
			(this.canvas = document.createElement('canvas')),
				(this.context = this.canvas.getContext('2d')),
				(this.resolution = i || settings$2.RESOLUTION),
				this.resize(t, e);
		}
		(t.prototype.clear = function () {
			this.context.setTransform(1, 0, 0, 1, 0, 0),
				this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
		}),
			(t.prototype.resize = function (t, e) {
				(this.canvas.width = Math.round(t * this.resolution)),
					(this.canvas.height = Math.round(e * this.resolution));
			}),
			(t.prototype.destroy = function () {
				(this.context = null), (this.canvas = null);
			}),
			Object.defineProperty(t.prototype, 'width', {
				get: function () {
					return this.canvas.width;
				},
				set: function (t) {
					this.canvas.width = Math.round(t);
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(t.prototype, 'height', {
				get: function () {
					return this.canvas.height;
				},
				set: function (t) {
					this.canvas.height = Math.round(t);
				},
				enumerable: !1,
				configurable: !0,
			});
	})(),
		(settings$2.SORTABLE_CHILDREN = !1);
	var Bounds = (function () {
			function t() {
				(this.minX = 1 / 0),
					(this.minY = 1 / 0),
					(this.maxX = -1 / 0),
					(this.maxY = -1 / 0),
					(this.rect = null),
					(this.updateID = -1);
			}
			return (
				(t.prototype.isEmpty = function () {
					return this.minX > this.maxX || this.minY > this.maxY;
				}),
				(t.prototype.clear = function () {
					(this.minX = 1 / 0),
						(this.minY = 1 / 0),
						(this.maxX = -1 / 0),
						(this.maxY = -1 / 0);
				}),
				(t.prototype.getRectangle = function (t) {
					return this.minX > this.maxX || this.minY > this.maxY
						? Rectangle$2.EMPTY
						: (((t = t || new Rectangle$2(0, 0, 1, 1)).x = this.minX),
						  (t.y = this.minY),
						  (t.width = this.maxX - this.minX),
						  (t.height = this.maxY - this.minY),
						  t);
				}),
				(t.prototype.addPoint = function (t) {
					(this.minX = Math.min(this.minX, t.x)),
						(this.maxX = Math.max(this.maxX, t.x)),
						(this.minY = Math.min(this.minY, t.y)),
						(this.maxY = Math.max(this.maxY, t.y));
				}),
				(t.prototype.addPointMatrix = function (t, e) {
					var i = t.a,
						r = t.b,
						s = t.c,
						n = t.d,
						a = t.tx,
						o = t.ty,
						h = i * e.x + s * e.y + a,
						u = r * e.x + n * e.y + o;
					(this.minX = Math.min(this.minX, h)),
						(this.maxX = Math.max(this.maxX, h)),
						(this.minY = Math.min(this.minY, u)),
						(this.maxY = Math.max(this.maxY, u));
				}),
				(t.prototype.addQuad = function (t) {
					var e = this.minX,
						i = this.minY,
						r = this.maxX,
						s = this.maxY,
						n = t[0],
						a = t[1];
					(e = n < e ? n : e),
						(i = a < i ? a : i),
						(r = n > r ? n : r),
						(s = a > s ? a : s),
						(e = (n = t[2]) < e ? n : e),
						(i = (a = t[3]) < i ? a : i),
						(r = n > r ? n : r),
						(s = a > s ? a : s),
						(e = (n = t[4]) < e ? n : e),
						(i = (a = t[5]) < i ? a : i),
						(r = n > r ? n : r),
						(s = a > s ? a : s),
						(e = (n = t[6]) < e ? n : e),
						(i = (a = t[7]) < i ? a : i),
						(r = n > r ? n : r),
						(s = a > s ? a : s),
						(this.minX = e),
						(this.minY = i),
						(this.maxX = r),
						(this.maxY = s);
				}),
				(t.prototype.addFrame = function (t, e, i, r, s) {
					this.addFrameMatrix(t.worldTransform, e, i, r, s);
				}),
				(t.prototype.addFrameMatrix = function (t, e, i, r, s) {
					var n = t.a,
						a = t.b,
						o = t.c,
						h = t.d,
						u = t.tx,
						l = t.ty,
						c = this.minX,
						d = this.minY,
						p = this.maxX,
						f = this.maxY,
						m = n * e + o * i + u,
						_ = a * e + h * i + l;
					(c = m < c ? m : c),
						(d = _ < d ? _ : d),
						(p = m > p ? m : p),
						(f = _ > f ? _ : f),
						(c = (m = n * r + o * i + u) < c ? m : c),
						(d = (_ = a * r + h * i + l) < d ? _ : d),
						(p = m > p ? m : p),
						(f = _ > f ? _ : f),
						(c = (m = n * e + o * s + u) < c ? m : c),
						(d = (_ = a * e + h * s + l) < d ? _ : d),
						(p = m > p ? m : p),
						(f = _ > f ? _ : f),
						(c = (m = n * r + o * s + u) < c ? m : c),
						(d = (_ = a * r + h * s + l) < d ? _ : d),
						(p = m > p ? m : p),
						(f = _ > f ? _ : f),
						(this.minX = c),
						(this.minY = d),
						(this.maxX = p),
						(this.maxY = f);
				}),
				(t.prototype.addVertexData = function (t, e, i) {
					for (
						var r = this.minX,
							s = this.minY,
							n = this.maxX,
							a = this.maxY,
							o = e;
						o < i;
						o += 2
					) {
						var h = t[o],
							u = t[o + 1];
						(r = h < r ? h : r),
							(s = u < s ? u : s),
							(n = h > n ? h : n),
							(a = u > a ? u : a);
					}
					(this.minX = r), (this.minY = s), (this.maxX = n), (this.maxY = a);
				}),
				(t.prototype.addVertices = function (t, e, i, r) {
					this.addVerticesMatrix(t.worldTransform, e, i, r);
				}),
				(t.prototype.addVerticesMatrix = function (t, e, i, r, s, n) {
					void 0 === s && (s = 0), void 0 === n && (n = s);
					for (
						var a = t.a,
							o = t.b,
							h = t.c,
							u = t.d,
							l = t.tx,
							c = t.ty,
							d = this.minX,
							p = this.minY,
							f = this.maxX,
							m = this.maxY,
							_ = i;
						_ < r;
						_ += 2
					) {
						var g = e[_],
							E = e[_ + 1],
							y = a * g + h * E + l,
							T = u * E + o * g + c;
						(d = Math.min(d, y - s)),
							(f = Math.max(f, y + s)),
							(p = Math.min(p, T - n)),
							(m = Math.max(m, T + n));
					}
					(this.minX = d), (this.minY = p), (this.maxX = f), (this.maxY = m);
				}),
				(t.prototype.addBounds = function (t) {
					var e = this.minX,
						i = this.minY,
						r = this.maxX,
						s = this.maxY;
					(this.minX = t.minX < e ? t.minX : e),
						(this.minY = t.minY < i ? t.minY : i),
						(this.maxX = t.maxX > r ? t.maxX : r),
						(this.maxY = t.maxY > s ? t.maxY : s);
				}),
				(t.prototype.addBoundsMask = function (t, e) {
					var i = t.minX > e.minX ? t.minX : e.minX,
						r = t.minY > e.minY ? t.minY : e.minY,
						s = t.maxX < e.maxX ? t.maxX : e.maxX,
						n = t.maxY < e.maxY ? t.maxY : e.maxY;
					if (i <= s && r <= n) {
						var a = this.minX,
							o = this.minY,
							h = this.maxX,
							u = this.maxY;
						(this.minX = i < a ? i : a),
							(this.minY = r < o ? r : o),
							(this.maxX = s > h ? s : h),
							(this.maxY = n > u ? n : u);
					}
				}),
				(t.prototype.addBoundsMatrix = function (t, e) {
					this.addFrameMatrix(e, t.minX, t.minY, t.maxX, t.maxY);
				}),
				(t.prototype.addBoundsArea = function (t, e) {
					var i = t.minX > e.x ? t.minX : e.x,
						r = t.minY > e.y ? t.minY : e.y,
						s = t.maxX < e.x + e.width ? t.maxX : e.x + e.width,
						n = t.maxY < e.y + e.height ? t.maxY : e.y + e.height;
					if (i <= s && r <= n) {
						var a = this.minX,
							o = this.minY,
							h = this.maxX,
							u = this.maxY;
						(this.minX = i < a ? i : a),
							(this.minY = r < o ? r : o),
							(this.maxX = s > h ? s : h),
							(this.maxY = n > u ? n : u);
					}
				}),
				(t.prototype.pad = function (t, e) {
					void 0 === t && (t = 0),
						void 0 === e && (e = t),
						this.isEmpty() ||
							((this.minX -= t),
							(this.maxX += t),
							(this.minY -= e),
							(this.maxY += e));
				}),
				(t.prototype.addFramePad = function (t, e, i, r, s, n) {
					(t -= s),
						(e -= n),
						(i += s),
						(r += n),
						(this.minX = this.minX < t ? this.minX : t),
						(this.maxX = this.maxX > i ? this.maxX : i),
						(this.minY = this.minY < e ? this.minY : e),
						(this.maxY = this.maxY > r ? this.maxY : r);
				}),
				t
			);
		})(),
		extendStatics$c = function (t, e) {
			return (extendStatics$c =
				Object.setPrototypeOf ||
				({ __proto__: [] } instanceof Array &&
					function (t, e) {
						t.__proto__ = e;
					}) ||
				function (t, e) {
					for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
				})(t, e);
		};
	/*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */ function __extends$c(
		t,
		e
	) {
		function i() {
			this.constructor = t;
		}
		extendStatics$c(t, e),
			(t.prototype =
				null === e ? Object.create(e) : ((i.prototype = e.prototype), new i()));
	}
	var DisplayObject = (function (t) {
			function e() {
				var e = t.call(this) || this;
				return (
					(e.tempDisplayObjectParent = null),
					(e.transform = new Transform()),
					(e.alpha = 1),
					(e.visible = !0),
					(e.renderable = !0),
					(e.parent = null),
					(e.worldAlpha = 1),
					(e._lastSortedIndex = 0),
					(e._zIndex = 0),
					(e.filterArea = null),
					(e.filters = null),
					(e._enabledFilters = null),
					(e._bounds = new Bounds()),
					(e._localBounds = null),
					(e._boundsID = 0),
					(e._boundsRect = null),
					(e._localBoundsRect = null),
					(e._mask = null),
					(e._maskRefCount = 0),
					(e._destroyed = !1),
					(e.isSprite = !1),
					(e.isMask = !1),
					e
				);
			}
			return (
				__extends$c(e, t),
				(e.mixin = function (t) {
					for (var i = Object.keys(t), r = 0; r < i.length; ++r) {
						var s = i[r];
						Object.defineProperty(
							e.prototype,
							s,
							Object.getOwnPropertyDescriptor(t, s)
						);
					}
				}),
				Object.defineProperty(e.prototype, 'destroyed', {
					get: function () {
						return this._destroyed;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype._recursivePostUpdateTransform = function () {
					this.parent
						? (this.parent._recursivePostUpdateTransform(),
						  this.transform.updateTransform(this.parent.transform))
						: this.transform.updateTransform(
								this._tempDisplayObjectParent.transform
						  );
				}),
				(e.prototype.updateTransform = function () {
					this._boundsID++,
						this.transform.updateTransform(this.parent.transform),
						(this.worldAlpha = this.alpha * this.parent.worldAlpha);
				}),
				(e.prototype.getBounds = function (t, e) {
					return (
						t ||
							(this.parent
								? (this._recursivePostUpdateTransform(), this.updateTransform())
								: ((this.parent = this._tempDisplayObjectParent),
								  this.updateTransform(),
								  (this.parent = null))),
						this._bounds.updateID !== this._boundsID &&
							(this.calculateBounds(),
							(this._bounds.updateID = this._boundsID)),
						e ||
							(this._boundsRect || (this._boundsRect = new Rectangle$2()),
							(e = this._boundsRect)),
						this._bounds.getRectangle(e)
					);
				}),
				(e.prototype.getLocalBounds = function (t) {
					t ||
						(this._localBoundsRect ||
							(this._localBoundsRect = new Rectangle$2()),
						(t = this._localBoundsRect)),
						this._localBounds || (this._localBounds = new Bounds());
					var e = this.transform,
						i = this.parent;
					(this.parent = null),
						(this.transform = this._tempDisplayObjectParent.transform);
					var r = this._bounds,
						s = this._boundsID;
					this._bounds = this._localBounds;
					var n = this.getBounds(!1, t);
					return (
						(this.parent = i),
						(this.transform = e),
						(this._bounds = r),
						(this._bounds.updateID += this._boundsID - s),
						n
					);
				}),
				(e.prototype.toGlobal = function (t, e, i) {
					return (
						void 0 === i && (i = !1),
						i ||
							(this._recursivePostUpdateTransform(),
							this.parent
								? this.displayObjectUpdateTransform()
								: ((this.parent = this._tempDisplayObjectParent),
								  this.displayObjectUpdateTransform(),
								  (this.parent = null))),
						this.worldTransform.apply(t, e)
					);
				}),
				(e.prototype.toLocal = function (t, e, i, r) {
					return (
						e && (t = e.toGlobal(t, i, r)),
						r ||
							(this._recursivePostUpdateTransform(),
							this.parent
								? this.displayObjectUpdateTransform()
								: ((this.parent = this._tempDisplayObjectParent),
								  this.displayObjectUpdateTransform(),
								  (this.parent = null))),
						this.worldTransform.applyInverse(t, i)
					);
				}),
				(e.prototype.setParent = function (t) {
					if (!t || !t.addChild)
						throw new Error('setParent: Argument must be a Container');
					return t.addChild(this), t;
				}),
				(e.prototype.setTransform = function (t, e, i, r, s, n, a, o, h) {
					return (
						void 0 === t && (t = 0),
						void 0 === e && (e = 0),
						void 0 === i && (i = 1),
						void 0 === r && (r = 1),
						void 0 === s && (s = 0),
						void 0 === n && (n = 0),
						void 0 === a && (a = 0),
						void 0 === o && (o = 0),
						void 0 === h && (h = 0),
						(this.position.x = t),
						(this.position.y = e),
						(this.scale.x = i || 1),
						(this.scale.y = r || 1),
						(this.rotation = s),
						(this.skew.x = n),
						(this.skew.y = a),
						(this.pivot.x = o),
						(this.pivot.y = h),
						this
					);
				}),
				(e.prototype.destroy = function (t) {
					this.parent && this.parent.removeChild(this),
						this.emit('destroyed'),
						this.removeAllListeners(),
						(this.transform = null),
						(this.parent = null),
						(this._bounds = null),
						(this.mask = null),
						(this.filters = null),
						(this.filterArea = null),
						(this.hitArea = null),
						(this.interactive = !1),
						(this.interactiveChildren = !1),
						(this._destroyed = !0);
				}),
				Object.defineProperty(e.prototype, '_tempDisplayObjectParent', {
					get: function () {
						return (
							null === this.tempDisplayObjectParent &&
								(this.tempDisplayObjectParent = new TemporaryDisplayObject()),
							this.tempDisplayObjectParent
						);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.enableTempParent = function () {
					var t = this.parent;
					return (this.parent = this._tempDisplayObjectParent), t;
				}),
				(e.prototype.disableTempParent = function (t) {
					this.parent = t;
				}),
				Object.defineProperty(e.prototype, 'x', {
					get: function () {
						return this.position.x;
					},
					set: function (t) {
						this.transform.position.x = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'y', {
					get: function () {
						return this.position.y;
					},
					set: function (t) {
						this.transform.position.y = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'worldTransform', {
					get: function () {
						return this.transform.worldTransform;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'localTransform', {
					get: function () {
						return this.transform.localTransform;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'position', {
					get: function () {
						return this.transform.position;
					},
					set: function (t) {
						this.transform.position.copyFrom(t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'scale', {
					get: function () {
						return this.transform.scale;
					},
					set: function (t) {
						this.transform.scale.copyFrom(t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'pivot', {
					get: function () {
						return this.transform.pivot;
					},
					set: function (t) {
						this.transform.pivot.copyFrom(t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'skew', {
					get: function () {
						return this.transform.skew;
					},
					set: function (t) {
						this.transform.skew.copyFrom(t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'rotation', {
					get: function () {
						return this.transform.rotation;
					},
					set: function (t) {
						this.transform.rotation = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'angle', {
					get: function () {
						return this.transform.rotation * RAD_TO_DEG;
					},
					set: function (t) {
						this.transform.rotation = t * DEG_TO_RAD;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'zIndex', {
					get: function () {
						return this._zIndex;
					},
					set: function (t) {
						(this._zIndex = t), this.parent && (this.parent.sortDirty = !0);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'worldVisible', {
					get: function () {
						var t = this;
						do {
							if (!t.visible) return !1;
							t = t.parent;
						} while (t);
						return !0;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'mask', {
					get: function () {
						return this._mask;
					},
					set: function (t) {
						var e;
						this._mask !== t &&
							(this._mask &&
								((e = this._mask.maskObject || this._mask)._maskRefCount--,
								0 === e._maskRefCount &&
									((e.renderable = !0), (e.isMask = !1))),
							(this._mask = t),
							this._mask &&
								(0 ===
									(e = this._mask.maskObject || this._mask)._maskRefCount &&
									((e.renderable = !1), (e.isMask = !0)),
								e._maskRefCount++));
					},
					enumerable: !1,
					configurable: !0,
				}),
				e
			);
		})(eventemitter3$1),
		TemporaryDisplayObject = (function (t) {
			function e() {
				var e = (null !== t && t.apply(this, arguments)) || this;
				return (e.sortDirty = null), e;
			}
			return __extends$c(e, t), e;
		})(DisplayObject),
		ENV$2,
		RENDERER_TYPE$2,
		BUFFER_BITS$2,
		BLEND_MODES$2,
		DRAW_MODES$2,
		FORMATS$2,
		TARGETS$2,
		TYPES$2,
		SAMPLER_TYPES$2,
		SCALE_MODES$2,
		WRAP_MODES$2,
		MIPMAP_MODES$2,
		ALPHA_MODES$2,
		CLEAR_MODES$2,
		GC_MODES$2,
		PRECISION$2,
		MASK_TYPES$2,
		MSAA_QUALITY$2,
		BUFFER_TYPE$2;
	function sortChildren(t, e) {
		return t.zIndex === e.zIndex
			? t._lastSortedIndex - e._lastSortedIndex
			: t.zIndex - e.zIndex;
	}
	(DisplayObject.prototype.displayObjectUpdateTransform =
		DisplayObject.prototype.updateTransform),
		(function (t) {
			(t[(t.WEBGL_LEGACY = 0)] = 'WEBGL_LEGACY'),
				(t[(t.WEBGL = 1)] = 'WEBGL'),
				(t[(t.WEBGL2 = 2)] = 'WEBGL2');
		})(ENV$2 || (ENV$2 = {})),
		(function (t) {
			(t[(t.UNKNOWN = 0)] = 'UNKNOWN'),
				(t[(t.WEBGL = 1)] = 'WEBGL'),
				(t[(t.CANVAS = 2)] = 'CANVAS');
		})(RENDERER_TYPE$2 || (RENDERER_TYPE$2 = {})),
		(function (t) {
			(t[(t.COLOR = 16384)] = 'COLOR'),
				(t[(t.DEPTH = 256)] = 'DEPTH'),
				(t[(t.STENCIL = 1024)] = 'STENCIL');
		})(BUFFER_BITS$2 || (BUFFER_BITS$2 = {})),
		(function (t) {
			(t[(t.NORMAL = 0)] = 'NORMAL'),
				(t[(t.ADD = 1)] = 'ADD'),
				(t[(t.MULTIPLY = 2)] = 'MULTIPLY'),
				(t[(t.SCREEN = 3)] = 'SCREEN'),
				(t[(t.OVERLAY = 4)] = 'OVERLAY'),
				(t[(t.DARKEN = 5)] = 'DARKEN'),
				(t[(t.LIGHTEN = 6)] = 'LIGHTEN'),
				(t[(t.COLOR_DODGE = 7)] = 'COLOR_DODGE'),
				(t[(t.COLOR_BURN = 8)] = 'COLOR_BURN'),
				(t[(t.HARD_LIGHT = 9)] = 'HARD_LIGHT'),
				(t[(t.SOFT_LIGHT = 10)] = 'SOFT_LIGHT'),
				(t[(t.DIFFERENCE = 11)] = 'DIFFERENCE'),
				(t[(t.EXCLUSION = 12)] = 'EXCLUSION'),
				(t[(t.HUE = 13)] = 'HUE'),
				(t[(t.SATURATION = 14)] = 'SATURATION'),
				(t[(t.COLOR = 15)] = 'COLOR'),
				(t[(t.LUMINOSITY = 16)] = 'LUMINOSITY'),
				(t[(t.NORMAL_NPM = 17)] = 'NORMAL_NPM'),
				(t[(t.ADD_NPM = 18)] = 'ADD_NPM'),
				(t[(t.SCREEN_NPM = 19)] = 'SCREEN_NPM'),
				(t[(t.NONE = 20)] = 'NONE'),
				(t[(t.SRC_OVER = 0)] = 'SRC_OVER'),
				(t[(t.SRC_IN = 21)] = 'SRC_IN'),
				(t[(t.SRC_OUT = 22)] = 'SRC_OUT'),
				(t[(t.SRC_ATOP = 23)] = 'SRC_ATOP'),
				(t[(t.DST_OVER = 24)] = 'DST_OVER'),
				(t[(t.DST_IN = 25)] = 'DST_IN'),
				(t[(t.DST_OUT = 26)] = 'DST_OUT'),
				(t[(t.DST_ATOP = 27)] = 'DST_ATOP'),
				(t[(t.ERASE = 26)] = 'ERASE'),
				(t[(t.SUBTRACT = 28)] = 'SUBTRACT'),
				(t[(t.XOR = 29)] = 'XOR');
		})(BLEND_MODES$2 || (BLEND_MODES$2 = {})),
		(function (t) {
			(t[(t.POINTS = 0)] = 'POINTS'),
				(t[(t.LINES = 1)] = 'LINES'),
				(t[(t.LINE_LOOP = 2)] = 'LINE_LOOP'),
				(t[(t.LINE_STRIP = 3)] = 'LINE_STRIP'),
				(t[(t.TRIANGLES = 4)] = 'TRIANGLES'),
				(t[(t.TRIANGLE_STRIP = 5)] = 'TRIANGLE_STRIP'),
				(t[(t.TRIANGLE_FAN = 6)] = 'TRIANGLE_FAN');
		})(DRAW_MODES$2 || (DRAW_MODES$2 = {})),
		(function (t) {
			(t[(t.RGBA = 6408)] = 'RGBA'),
				(t[(t.RGB = 6407)] = 'RGB'),
				(t[(t.RG = 33319)] = 'RG'),
				(t[(t.RED = 6403)] = 'RED'),
				(t[(t.RGBA_INTEGER = 36249)] = 'RGBA_INTEGER'),
				(t[(t.RGB_INTEGER = 36248)] = 'RGB_INTEGER'),
				(t[(t.RG_INTEGER = 33320)] = 'RG_INTEGER'),
				(t[(t.RED_INTEGER = 36244)] = 'RED_INTEGER'),
				(t[(t.ALPHA = 6406)] = 'ALPHA'),
				(t[(t.LUMINANCE = 6409)] = 'LUMINANCE'),
				(t[(t.LUMINANCE_ALPHA = 6410)] = 'LUMINANCE_ALPHA'),
				(t[(t.DEPTH_COMPONENT = 6402)] = 'DEPTH_COMPONENT'),
				(t[(t.DEPTH_STENCIL = 34041)] = 'DEPTH_STENCIL');
		})(FORMATS$2 || (FORMATS$2 = {})),
		(function (t) {
			(t[(t.TEXTURE_2D = 3553)] = 'TEXTURE_2D'),
				(t[(t.TEXTURE_CUBE_MAP = 34067)] = 'TEXTURE_CUBE_MAP'),
				(t[(t.TEXTURE_2D_ARRAY = 35866)] = 'TEXTURE_2D_ARRAY'),
				(t[(t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069)] =
					'TEXTURE_CUBE_MAP_POSITIVE_X'),
				(t[(t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070)] =
					'TEXTURE_CUBE_MAP_NEGATIVE_X'),
				(t[(t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071)] =
					'TEXTURE_CUBE_MAP_POSITIVE_Y'),
				(t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072)] =
					'TEXTURE_CUBE_MAP_NEGATIVE_Y'),
				(t[(t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073)] =
					'TEXTURE_CUBE_MAP_POSITIVE_Z'),
				(t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074)] =
					'TEXTURE_CUBE_MAP_NEGATIVE_Z');
		})(TARGETS$2 || (TARGETS$2 = {})),
		(function (t) {
			(t[(t.UNSIGNED_BYTE = 5121)] = 'UNSIGNED_BYTE'),
				(t[(t.UNSIGNED_SHORT = 5123)] = 'UNSIGNED_SHORT'),
				(t[(t.UNSIGNED_SHORT_5_6_5 = 33635)] = 'UNSIGNED_SHORT_5_6_5'),
				(t[(t.UNSIGNED_SHORT_4_4_4_4 = 32819)] = 'UNSIGNED_SHORT_4_4_4_4'),
				(t[(t.UNSIGNED_SHORT_5_5_5_1 = 32820)] = 'UNSIGNED_SHORT_5_5_5_1'),
				(t[(t.UNSIGNED_INT = 5125)] = 'UNSIGNED_INT'),
				(t[(t.UNSIGNED_INT_10F_11F_11F_REV = 35899)] =
					'UNSIGNED_INT_10F_11F_11F_REV'),
				(t[(t.UNSIGNED_INT_2_10_10_10_REV = 33640)] =
					'UNSIGNED_INT_2_10_10_10_REV'),
				(t[(t.UNSIGNED_INT_24_8 = 34042)] = 'UNSIGNED_INT_24_8'),
				(t[(t.UNSIGNED_INT_5_9_9_9_REV = 35902)] = 'UNSIGNED_INT_5_9_9_9_REV'),
				(t[(t.BYTE = 5120)] = 'BYTE'),
				(t[(t.SHORT = 5122)] = 'SHORT'),
				(t[(t.INT = 5124)] = 'INT'),
				(t[(t.FLOAT = 5126)] = 'FLOAT'),
				(t[(t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269)] =
					'FLOAT_32_UNSIGNED_INT_24_8_REV'),
				(t[(t.HALF_FLOAT = 36193)] = 'HALF_FLOAT');
		})(TYPES$2 || (TYPES$2 = {})),
		(function (t) {
			(t[(t.FLOAT = 0)] = 'FLOAT'),
				(t[(t.INT = 1)] = 'INT'),
				(t[(t.UINT = 2)] = 'UINT');
		})(SAMPLER_TYPES$2 || (SAMPLER_TYPES$2 = {})),
		(function (t) {
			(t[(t.NEAREST = 0)] = 'NEAREST'), (t[(t.LINEAR = 1)] = 'LINEAR');
		})(SCALE_MODES$2 || (SCALE_MODES$2 = {})),
		(function (t) {
			(t[(t.CLAMP = 33071)] = 'CLAMP'),
				(t[(t.REPEAT = 10497)] = 'REPEAT'),
				(t[(t.MIRRORED_REPEAT = 33648)] = 'MIRRORED_REPEAT');
		})(WRAP_MODES$2 || (WRAP_MODES$2 = {})),
		(function (t) {
			(t[(t.OFF = 0)] = 'OFF'),
				(t[(t.POW2 = 1)] = 'POW2'),
				(t[(t.ON = 2)] = 'ON'),
				(t[(t.ON_MANUAL = 3)] = 'ON_MANUAL');
		})(MIPMAP_MODES$2 || (MIPMAP_MODES$2 = {})),
		(function (t) {
			(t[(t.NPM = 0)] = 'NPM'),
				(t[(t.UNPACK = 1)] = 'UNPACK'),
				(t[(t.PMA = 2)] = 'PMA'),
				(t[(t.NO_PREMULTIPLIED_ALPHA = 0)] = 'NO_PREMULTIPLIED_ALPHA'),
				(t[(t.PREMULTIPLY_ON_UPLOAD = 1)] = 'PREMULTIPLY_ON_UPLOAD'),
				(t[(t.PREMULTIPLY_ALPHA = 2)] = 'PREMULTIPLY_ALPHA'),
				(t[(t.PREMULTIPLIED_ALPHA = 2)] = 'PREMULTIPLIED_ALPHA');
		})(ALPHA_MODES$2 || (ALPHA_MODES$2 = {})),
		(function (t) {
			(t[(t.NO = 0)] = 'NO'),
				(t[(t.YES = 1)] = 'YES'),
				(t[(t.AUTO = 2)] = 'AUTO'),
				(t[(t.BLEND = 0)] = 'BLEND'),
				(t[(t.CLEAR = 1)] = 'CLEAR'),
				(t[(t.BLIT = 2)] = 'BLIT');
		})(CLEAR_MODES$2 || (CLEAR_MODES$2 = {})),
		(function (t) {
			(t[(t.AUTO = 0)] = 'AUTO'), (t[(t.MANUAL = 1)] = 'MANUAL');
		})(GC_MODES$2 || (GC_MODES$2 = {})),
		(function (t) {
			(t.LOW = 'lowp'), (t.MEDIUM = 'mediump'), (t.HIGH = 'highp');
		})(PRECISION$2 || (PRECISION$2 = {})),
		(function (t) {
			(t[(t.NONE = 0)] = 'NONE'),
				(t[(t.SCISSOR = 1)] = 'SCISSOR'),
				(t[(t.STENCIL = 2)] = 'STENCIL'),
				(t[(t.SPRITE = 3)] = 'SPRITE');
		})(MASK_TYPES$2 || (MASK_TYPES$2 = {})),
		(function (t) {
			(t[(t.NONE = 0)] = 'NONE'),
				(t[(t.LOW = 2)] = 'LOW'),
				(t[(t.MEDIUM = 4)] = 'MEDIUM'),
				(t[(t.HIGH = 8)] = 'HIGH');
		})(MSAA_QUALITY$2 || (MSAA_QUALITY$2 = {})),
		(function (t) {
			(t[(t.ELEMENT_ARRAY_BUFFER = 34963)] = 'ELEMENT_ARRAY_BUFFER'),
				(t[(t.ARRAY_BUFFER = 34962)] = 'ARRAY_BUFFER'),
				(t[(t.UNIFORM_BUFFER = 35345)] = 'UNIFORM_BUFFER');
		})(BUFFER_TYPE$2 || (BUFFER_TYPE$2 = {}));
	var Container = (function (t) {
		function e() {
			var e = t.call(this) || this;
			return (
				(e.children = []),
				(e.sortableChildren = settings$2.SORTABLE_CHILDREN),
				(e.sortDirty = !1),
				e
			);
		}
		return (
			__extends$c(e, t),
			(e.prototype.onChildrenChange = function (t) {}),
			(e.prototype.addChild = function () {
				for (var t = arguments, e = [], i = 0; i < arguments.length; i++)
					e[i] = t[i];
				if (e.length > 1)
					for (var r = 0; r < e.length; r++) this.addChild(e[r]);
				else {
					var s = e[0];
					s.parent && s.parent.removeChild(s),
						(s.parent = this),
						(this.sortDirty = !0),
						(s.transform._parentID = -1),
						this.children.push(s),
						this._boundsID++,
						this.onChildrenChange(this.children.length - 1),
						this.emit('childAdded', s, this, this.children.length - 1),
						s.emit('added', this);
				}
				return e[0];
			}),
			(e.prototype.addChildAt = function (t, e) {
				if (e < 0 || e > this.children.length)
					throw new Error(
						t +
							'addChildAt: The index ' +
							e +
							' supplied is out of bounds ' +
							this.children.length
					);
				return (
					t.parent && t.parent.removeChild(t),
					(t.parent = this),
					(this.sortDirty = !0),
					(t.transform._parentID = -1),
					this.children.splice(e, 0, t),
					this._boundsID++,
					this.onChildrenChange(e),
					t.emit('added', this),
					this.emit('childAdded', t, this, e),
					t
				);
			}),
			(e.prototype.swapChildren = function (t, e) {
				if (t !== e) {
					var i = this.getChildIndex(t),
						r = this.getChildIndex(e);
					(this.children[i] = e),
						(this.children[r] = t),
						this.onChildrenChange(i < r ? i : r);
				}
			}),
			(e.prototype.getChildIndex = function (t) {
				var e = this.children.indexOf(t);
				if (-1 === e)
					throw new Error(
						'The supplied DisplayObject must be a child of the caller'
					);
				return e;
			}),
			(e.prototype.setChildIndex = function (t, e) {
				if (e < 0 || e >= this.children.length)
					throw new Error(
						'The index ' +
							e +
							' supplied is out of bounds ' +
							this.children.length
					);
				var i = this.getChildIndex(t);
				removeItems$1(this.children, i, 1),
					this.children.splice(e, 0, t),
					this.onChildrenChange(e);
			}),
			(e.prototype.getChildAt = function (t) {
				if (t < 0 || t >= this.children.length)
					throw new Error('getChildAt: Index (' + t + ') does not exist.');
				return this.children[t];
			}),
			(e.prototype.removeChild = function () {
				for (var t = arguments, e = [], i = 0; i < arguments.length; i++)
					e[i] = t[i];
				if (e.length > 1)
					for (var r = 0; r < e.length; r++) this.removeChild(e[r]);
				else {
					var s = e[0],
						n = this.children.indexOf(s);
					if (-1 === n) return null;
					(s.parent = null),
						(s.transform._parentID = -1),
						removeItems$1(this.children, n, 1),
						this._boundsID++,
						this.onChildrenChange(n),
						s.emit('removed', this),
						this.emit('childRemoved', s, this, n);
				}
				return e[0];
			}),
			(e.prototype.removeChildAt = function (t) {
				var e = this.getChildAt(t);
				return (
					(e.parent = null),
					(e.transform._parentID = -1),
					removeItems$1(this.children, t, 1),
					this._boundsID++,
					this.onChildrenChange(t),
					e.emit('removed', this),
					this.emit('childRemoved', e, this, t),
					e
				);
			}),
			(e.prototype.removeChildren = function (t, e) {
				void 0 === t && (t = 0), void 0 === e && (e = this.children.length);
				var i,
					r = t,
					s = e - r;
				if (s > 0 && s <= e) {
					i = this.children.splice(r, s);
					for (var n = 0; n < i.length; ++n)
						(i[n].parent = null),
							i[n].transform && (i[n].transform._parentID = -1);
					for (
						this._boundsID++, this.onChildrenChange(t), n = 0;
						n < i.length;
						++n
					)
						i[n].emit('removed', this),
							this.emit('childRemoved', i[n], this, n);
					return i;
				}
				if (0 === s && 0 === this.children.length) return [];
				throw new RangeError(
					'removeChildren: numeric values are outside the acceptable range.'
				);
			}),
			(e.prototype.sortChildren = function () {
				for (var t = !1, e = 0, i = this.children.length; e < i; ++e) {
					var r = this.children[e];
					(r._lastSortedIndex = e), t || 0 === r.zIndex || (t = !0);
				}
				t && this.children.length > 1 && this.children.sort(sortChildren),
					(this.sortDirty = !1);
			}),
			(e.prototype.updateTransform = function () {
				this.sortableChildren && this.sortDirty && this.sortChildren(),
					this._boundsID++,
					this.transform.updateTransform(this.parent.transform),
					(this.worldAlpha = this.alpha * this.parent.worldAlpha);
				for (var t = 0, e = this.children.length; t < e; ++t) {
					var i = this.children[t];
					i.visible && i.updateTransform();
				}
			}),
			(e.prototype.calculateBounds = function () {
				this._bounds.clear(), this._calculateBounds();
				for (var t = 0; t < this.children.length; t++) {
					var e = this.children[t];
					if (e.visible && e.renderable)
						if ((e.calculateBounds(), e._mask)) {
							var i = e._mask.maskObject || e._mask;
							i.calculateBounds(),
								this._bounds.addBoundsMask(e._bounds, i._bounds);
						} else
							e.filterArea
								? this._bounds.addBoundsArea(e._bounds, e.filterArea)
								: this._bounds.addBounds(e._bounds);
				}
				this._bounds.updateID = this._boundsID;
			}),
			(e.prototype.getLocalBounds = function (e, i) {
				void 0 === i && (i = !1);
				var r = t.prototype.getLocalBounds.call(this, e);
				if (!i)
					for (var s = 0, n = this.children.length; s < n; ++s) {
						var a = this.children[s];
						a.visible && a.updateTransform();
					}
				return r;
			}),
			(e.prototype._calculateBounds = function () {}),
			(e.prototype.render = function (t) {
				if (this.visible && !(this.worldAlpha <= 0) && this.renderable)
					if (this._mask || (this.filters && this.filters.length))
						this.renderAdvanced(t);
					else {
						this._render(t);
						for (var e = 0, i = this.children.length; e < i; ++e)
							this.children[e].render(t);
					}
			}),
			(e.prototype.renderAdvanced = function (t) {
				var e = this.filters,
					i = this._mask;
				if (e) {
					this._enabledFilters || (this._enabledFilters = []),
						(this._enabledFilters.length = 0);
					for (var r = 0; r < e.length; r++)
						e[r].enabled && this._enabledFilters.push(e[r]);
				}
				var s =
					(e && this._enabledFilters && this._enabledFilters.length) ||
					(i &&
						(!i.isMaskData ||
							(i.enabled && (i.autoDetect || i.type !== MASK_TYPES$2.NONE))));
				s && t.batch.flush(),
					e &&
						this._enabledFilters &&
						this._enabledFilters.length &&
						t.filter.push(this, this._enabledFilters),
					i && t.mask.push(this, this._mask),
					this._render(t),
					(r = 0);
				for (var n = this.children.length; r < n; r++)
					this.children[r].render(t);
				s && t.batch.flush(),
					i && t.mask.pop(this),
					e &&
						this._enabledFilters &&
						this._enabledFilters.length &&
						t.filter.pop();
			}),
			(e.prototype._render = function (t) {}),
			(e.prototype.destroy = function (e) {
				t.prototype.destroy.call(this), (this.sortDirty = !1);
				var i = 'boolean' == typeof e ? e : e && e.children,
					r = this.removeChildren(0, this.children.length);
				if (i) for (var s = 0; s < r.length; ++s) r[s].destroy(e);
			}),
			Object.defineProperty(e.prototype, 'width', {
				get: function () {
					return this.scale.x * this.getLocalBounds().width;
				},
				set: function (t) {
					var e = this.getLocalBounds().width;
					(this.scale.x = 0 !== e ? t / e : 1), (this._width = t);
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(e.prototype, 'height', {
				get: function () {
					return this.scale.y * this.getLocalBounds().height;
				},
				set: function (t) {
					var e = this.getLocalBounds().height;
					(this.scale.y = 0 !== e ? t / e : 1), (this._height = t);
				},
				enumerable: !1,
				configurable: !0,
			}),
			e
		);
	})(DisplayObject);
	Container.prototype.containerUpdateTransform =
		Container.prototype.updateTransform;
	/*!
	 * @pixi/runner - v6.2.1
	 * Compiled Tue, 21 Dec 2021 19:56:15 UTC
	 *
	 * @pixi/runner is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 */
	var Runner$1 = (function () {
			function t(t) {
				(this.items = []), (this._name = t), (this._aliasCount = 0);
			}
			return (
				(t.prototype.emit = function (t, e, i, r, s, n, a, o) {
					if (arguments.length > 8) throw new Error('max arguments reached');
					var h = this,
						u = h.name,
						l = h.items;
					this._aliasCount++;
					for (var c = 0, d = l.length; c < d; c++)
						l[c][u](t, e, i, r, s, n, a, o);
					return l === this.items && this._aliasCount--, this;
				}),
				(t.prototype.ensureNonAliasedItems = function () {
					this._aliasCount > 0 &&
						this.items.length > 1 &&
						((this._aliasCount = 0), (this.items = this.items.slice(0)));
				}),
				(t.prototype.add = function (t) {
					return (
						t[this._name] &&
							(this.ensureNonAliasedItems(),
							this.remove(t),
							this.items.push(t)),
						this
					);
				}),
				(t.prototype.remove = function (t) {
					var e = this.items.indexOf(t);
					return (
						-1 !== e && (this.ensureNonAliasedItems(), this.items.splice(e, 1)),
						this
					);
				}),
				(t.prototype.contains = function (t) {
					return -1 !== this.items.indexOf(t);
				}),
				(t.prototype.removeAll = function () {
					return this.ensureNonAliasedItems(), (this.items.length = 0), this;
				}),
				(t.prototype.destroy = function () {
					this.removeAll(), (this.items = null), (this._name = null);
				}),
				Object.defineProperty(t.prototype, 'empty', {
					get: function () {
						return 0 === this.items.length;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'name', {
					get: function () {
						return this._name;
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			);
		})(),
		UPDATE_PRIORITY$1;
	Object.defineProperties(Runner$1.prototype, {
		dispatch: { value: Runner$1.prototype.emit },
		run: { value: Runner$1.prototype.emit },
	}),
		/*!
		 * @pixi/ticker - v6.2.1
		 * Compiled Tue, 21 Dec 2021 19:56:15 UTC
		 *
		 * @pixi/ticker is licensed under the MIT License.
		 * http://www.opensource.org/licenses/mit-license
		 */
		(settings$2.TARGET_FPMS = 0.06),
		(function (t) {
			(t[(t.INTERACTION = 50)] = 'INTERACTION'),
				(t[(t.HIGH = 25)] = 'HIGH'),
				(t[(t.NORMAL = 0)] = 'NORMAL'),
				(t[(t.LOW = -25)] = 'LOW'),
				(t[(t.UTILITY = -50)] = 'UTILITY');
		})(UPDATE_PRIORITY$1 || (UPDATE_PRIORITY$1 = {}));
	var TickerListener$1 = (function () {
			function t(t, e, i, r) {
				void 0 === e && (e = null),
					void 0 === i && (i = 0),
					void 0 === r && (r = !1),
					(this.next = null),
					(this.previous = null),
					(this._destroyed = !1),
					(this.fn = t),
					(this.context = e),
					(this.priority = i),
					(this.once = r);
			}
			return (
				(t.prototype.match = function (t, e) {
					return (
						void 0 === e && (e = null), this.fn === t && this.context === e
					);
				}),
				(t.prototype.emit = function (t) {
					this.fn &&
						(this.context ? this.fn.call(this.context, t) : this.fn(t));
					var e = this.next;
					return (
						this.once && this.destroy(!0),
						this._destroyed && (this.next = null),
						e
					);
				}),
				(t.prototype.connect = function (t) {
					(this.previous = t),
						t.next && (t.next.previous = this),
						(this.next = t.next),
						(t.next = this);
				}),
				(t.prototype.destroy = function (t) {
					void 0 === t && (t = !1),
						(this._destroyed = !0),
						(this.fn = null),
						(this.context = null),
						this.previous && (this.previous.next = this.next),
						this.next && (this.next.previous = this.previous);
					var e = this.next;
					return (this.next = t ? null : e), (this.previous = null), e;
				}),
				t
			);
		})(),
		Ticker$1 = (function () {
			function t() {
				var t = this;
				(this.autoStart = !1),
					(this.deltaTime = 1),
					(this.lastTime = -1),
					(this.speed = 1),
					(this.started = !1),
					(this._requestId = null),
					(this._maxElapsedMS = 100),
					(this._minElapsedMS = 0),
					(this._protected = !1),
					(this._lastFrame = -1),
					(this._head = new TickerListener$1(null, null, 1 / 0)),
					(this.deltaMS = 1 / settings$2.TARGET_FPMS),
					(this.elapsedMS = 1 / settings$2.TARGET_FPMS),
					(this._tick = function (e) {
						(t._requestId = null),
							t.started &&
								(t.update(e),
								t.started &&
									null === t._requestId &&
									t._head.next &&
									(t._requestId = requestAnimationFrame(t._tick)));
					});
			}
			return (
				(t.prototype._requestIfNeeded = function () {
					null === this._requestId &&
						this._head.next &&
						((this.lastTime = performance.now()),
						(this._lastFrame = this.lastTime),
						(this._requestId = requestAnimationFrame(this._tick)));
				}),
				(t.prototype._cancelIfNeeded = function () {
					null !== this._requestId &&
						(cancelAnimationFrame(this._requestId), (this._requestId = null));
				}),
				(t.prototype._startIfPossible = function () {
					this.started
						? this._requestIfNeeded()
						: this.autoStart && this.start();
				}),
				(t.prototype.add = function (t, e, i) {
					return (
						void 0 === i && (i = UPDATE_PRIORITY$1.NORMAL),
						this._addListener(new TickerListener$1(t, e, i))
					);
				}),
				(t.prototype.addOnce = function (t, e, i) {
					return (
						void 0 === i && (i = UPDATE_PRIORITY$1.NORMAL),
						this._addListener(new TickerListener$1(t, e, i, !0))
					);
				}),
				(t.prototype._addListener = function (t) {
					var e = this._head.next,
						i = this._head;
					if (e) {
						for (; e; ) {
							if (t.priority > e.priority) {
								t.connect(i);
								break;
							}
							(i = e), (e = e.next);
						}
						t.previous || t.connect(i);
					} else t.connect(i);
					return this._startIfPossible(), this;
				}),
				(t.prototype.remove = function (t, e) {
					for (var i = this._head.next; i; )
						i = i.match(t, e) ? i.destroy() : i.next;
					return this._head.next || this._cancelIfNeeded(), this;
				}),
				Object.defineProperty(t.prototype, 'count', {
					get: function () {
						if (!this._head) return 0;
						for (var t = 0, e = this._head; (e = e.next); ) t++;
						return t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.start = function () {
					this.started || ((this.started = !0), this._requestIfNeeded());
				}),
				(t.prototype.stop = function () {
					this.started && ((this.started = !1), this._cancelIfNeeded());
				}),
				(t.prototype.destroy = function () {
					if (!this._protected) {
						this.stop();
						for (var t = this._head.next; t; ) t = t.destroy(!0);
						this._head.destroy(), (this._head = null);
					}
				}),
				(t.prototype.update = function (t) {
					var e;
					if ((void 0 === t && (t = performance.now()), t > this.lastTime)) {
						if (
							((e = this.elapsedMS = t - this.lastTime) > this._maxElapsedMS &&
								(e = this._maxElapsedMS),
							(e *= this.speed),
							this._minElapsedMS)
						) {
							var i = (t - this._lastFrame) | 0;
							if (i < this._minElapsedMS) return;
							this._lastFrame = t - (i % this._minElapsedMS);
						}
						(this.deltaMS = e),
							(this.deltaTime = this.deltaMS * settings$2.TARGET_FPMS);
						for (var r = this._head, s = r.next; s; )
							s = s.emit(this.deltaTime);
						r.next || this._cancelIfNeeded();
					} else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
					this.lastTime = t;
				}),
				Object.defineProperty(t.prototype, 'FPS', {
					get: function () {
						return 1e3 / this.elapsedMS;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'minFPS', {
					get: function () {
						return 1e3 / this._maxElapsedMS;
					},
					set: function (t) {
						var e = Math.min(this.maxFPS, t),
							i = Math.min(Math.max(0, e) / 1e3, settings$2.TARGET_FPMS);
						this._maxElapsedMS = 1 / i;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'maxFPS', {
					get: function () {
						return this._minElapsedMS
							? Math.round(1e3 / this._minElapsedMS)
							: 0;
					},
					set: function (t) {
						if (0 === t) this._minElapsedMS = 0;
						else {
							var e = Math.max(this.minFPS, t);
							this._minElapsedMS = 1 / (e / 1e3);
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t, 'shared', {
					get: function () {
						if (!t._shared) {
							var e = (t._shared = new t());
							(e.autoStart = !0), (e._protected = !0);
						}
						return t._shared;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t, 'system', {
					get: function () {
						if (!t._system) {
							var e = (t._system = new t());
							(e.autoStart = !0), (e._protected = !0);
						}
						return t._system;
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			);
		})();
	/*!
	 * @pixi/core - v6.2.1
	 * Compiled Tue, 21 Dec 2021 19:56:15 UTC
	 *
	 * @pixi/core is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 */
	(settings$2.PREFER_ENV = isMobile$1.any ? ENV$3.WEBGL : ENV$3.WEBGL2),
		(settings$2.STRICT_TEXTURE_CACHE = !1);
	var INSTALLED$1 = [];
	function autoDetectResource$1(t, e) {
		if (!t) return null;
		var i = '';
		if ('string' == typeof t) {
			var r = /\.(\w{3,4})(?:$|\?|#)/i.exec(t);
			r && (i = r[1].toLowerCase());
		}
		for (var s = INSTALLED$1.length - 1; s >= 0; --s) {
			var n = INSTALLED$1[s];
			if (n.test && n.test(t, i)) return new n(t, e);
		}
		throw new Error('Unrecognized source type to auto-detect Resource');
	}
	/*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */ var extendStatics$b =
		function (t, e) {
			return (extendStatics$b =
				Object.setPrototypeOf ||
				({ __proto__: [] } instanceof Array &&
					function (t, e) {
						t.__proto__ = e;
					}) ||
				function (t, e) {
					for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
				})(t, e);
		};
	function __extends$b(t, e) {
		function i() {
			this.constructor = t;
		}
		extendStatics$b(t, e),
			(t.prototype =
				null === e ? Object.create(e) : ((i.prototype = e.prototype), new i()));
	}
	var __assign$1 = function () {
		return (
			(__assign$1 =
				Object.assign ||
				function (t) {
					for (var e, i = arguments, r = 1, s = arguments.length; r < s; r++)
						for (var n in (e = i[r]))
							Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
					return t;
				}),
			__assign$1.apply(this, arguments)
		);
	};
	function __rest$1(t, e) {
		var i = {};
		for (var r in t)
			Object.prototype.hasOwnProperty.call(t, r) &&
				e.indexOf(r) < 0 &&
				(i[r] = t[r]);
		if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
			var s = 0;
			for (r = Object.getOwnPropertySymbols(t); s < r.length; s++)
				e.indexOf(r[s]) < 0 && (i[r[s]] = t[r[s]]);
		}
		return i;
	}
	var Resource$1 = (function () {
			function t(t, e) {
				void 0 === t && (t = 0),
					void 0 === e && (e = 0),
					(this._width = t),
					(this._height = e),
					(this.destroyed = !1),
					(this.internal = !1),
					(this.onResize = new Runner$1('setRealSize')),
					(this.onUpdate = new Runner$1('update')),
					(this.onError = new Runner$1('onError'));
			}
			return (
				(t.prototype.bind = function (t) {
					this.onResize.add(t),
						this.onUpdate.add(t),
						this.onError.add(t),
						(this._width || this._height) &&
							this.onResize.emit(this._width, this._height);
				}),
				(t.prototype.unbind = function (t) {
					this.onResize.remove(t),
						this.onUpdate.remove(t),
						this.onError.remove(t);
				}),
				(t.prototype.resize = function (t, e) {
					(t === this._width && e === this._height) ||
						((this._width = t), (this._height = e), this.onResize.emit(t, e));
				}),
				Object.defineProperty(t.prototype, 'valid', {
					get: function () {
						return !!this._width && !!this._height;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.update = function () {
					this.destroyed || this.onUpdate.emit();
				}),
				(t.prototype.load = function () {
					return Promise.resolve(this);
				}),
				Object.defineProperty(t.prototype, 'width', {
					get: function () {
						return this._width;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'height', {
					get: function () {
						return this._height;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.style = function (t, e, i) {
					return !1;
				}),
				(t.prototype.dispose = function () {}),
				(t.prototype.destroy = function () {
					this.destroyed ||
						((this.destroyed = !0),
						this.dispose(),
						this.onError.removeAll(),
						(this.onError = null),
						this.onResize.removeAll(),
						(this.onResize = null),
						this.onUpdate.removeAll(),
						(this.onUpdate = null));
				}),
				(t.test = function (t, e) {
					return !1;
				}),
				t
			);
		})(),
		BufferResource$1 = (function (t) {
			function e(e, i) {
				var r = this,
					s = i || {},
					n = s.width,
					a = s.height;
				if (!n || !a) throw new Error('BufferResource width or height invalid');
				return ((r = t.call(this, n, a) || this).data = e), r;
			}
			return (
				__extends$b(e, t),
				(e.prototype.upload = function (t, e, i) {
					var r = t.gl;
					r.pixelStorei(
						r.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
						e.alphaMode === ALPHA_MODES$3.UNPACK
					);
					var s = e.realWidth,
						n = e.realHeight;
					return (
						i.width === s && i.height === n
							? r.texSubImage2D(
									e.target,
									0,
									0,
									0,
									s,
									n,
									e.format,
									i.type,
									this.data
							  )
							: ((i.width = s),
							  (i.height = n),
							  r.texImage2D(
									e.target,
									0,
									i.internalFormat,
									s,
									n,
									0,
									e.format,
									i.type,
									this.data
							  )),
						!0
					);
				}),
				(e.prototype.dispose = function () {
					this.data = null;
				}),
				(e.test = function (t) {
					return (
						t instanceof Float32Array ||
						t instanceof Uint8Array ||
						t instanceof Uint32Array
					);
				}),
				e
			);
		})(Resource$1),
		defaultBufferOptions$1 = {
			scaleMode: SCALE_MODES$3.NEAREST,
			format: FORMATS$3.RGBA,
			alphaMode: ALPHA_MODES$3.NPM,
		},
		BaseTexture$1 = (function (t) {
			function e(e, i) {
				void 0 === e && (e = null), void 0 === i && (i = null);
				var r = t.call(this) || this,
					s = (i = i || {}).alphaMode,
					n = i.mipmap,
					a = i.anisotropicLevel,
					o = i.scaleMode,
					h = i.width,
					u = i.height,
					l = i.wrapMode,
					c = i.format,
					d = i.type,
					p = i.target,
					f = i.resolution,
					m = i.resourceOptions;
				return (
					!e ||
						e instanceof Resource$1 ||
						((e = autoDetectResource$1(e, m)).internal = !0),
					(r.resolution = f || settings$2.RESOLUTION),
					(r.width = Math.round((h || 0) * r.resolution) / r.resolution),
					(r.height = Math.round((u || 0) * r.resolution) / r.resolution),
					(r._mipmap = void 0 !== n ? n : settings$2.MIPMAP_TEXTURES),
					(r.anisotropicLevel =
						void 0 !== a ? a : settings$2.ANISOTROPIC_LEVEL),
					(r._wrapMode = l || settings$2.WRAP_MODE),
					(r._scaleMode = void 0 !== o ? o : settings$2.SCALE_MODE),
					(r.format = c || FORMATS$3.RGBA),
					(r.type = d || TYPES$3.UNSIGNED_BYTE),
					(r.target = p || TARGETS$3.TEXTURE_2D),
					(r.alphaMode = void 0 !== s ? s : ALPHA_MODES$3.UNPACK),
					(r.uid = uid$1()),
					(r.touched = 0),
					(r.isPowerOfTwo = !1),
					r._refreshPOT(),
					(r._glTextures = {}),
					(r.dirtyId = 0),
					(r.dirtyStyleId = 0),
					(r.cacheId = null),
					(r.valid = h > 0 && u > 0),
					(r.textureCacheIds = []),
					(r.destroyed = !1),
					(r.resource = null),
					(r._batchEnabled = 0),
					(r._batchLocation = 0),
					(r.parentTextureArray = null),
					r.setResource(e),
					r
				);
			}
			return (
				__extends$b(e, t),
				Object.defineProperty(e.prototype, 'realWidth', {
					get: function () {
						return Math.round(this.width * this.resolution);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'realHeight', {
					get: function () {
						return Math.round(this.height * this.resolution);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'mipmap', {
					get: function () {
						return this._mipmap;
					},
					set: function (t) {
						this._mipmap !== t && ((this._mipmap = t), this.dirtyStyleId++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'scaleMode', {
					get: function () {
						return this._scaleMode;
					},
					set: function (t) {
						this._scaleMode !== t &&
							((this._scaleMode = t), this.dirtyStyleId++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'wrapMode', {
					get: function () {
						return this._wrapMode;
					},
					set: function (t) {
						this._wrapMode !== t && ((this._wrapMode = t), this.dirtyStyleId++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.setStyle = function (t, e) {
					var i;
					return (
						void 0 !== t &&
							t !== this.scaleMode &&
							((this.scaleMode = t), (i = !0)),
						void 0 !== e && e !== this.mipmap && ((this.mipmap = e), (i = !0)),
						i && this.dirtyStyleId++,
						this
					);
				}),
				(e.prototype.setSize = function (t, e, i) {
					return (i = i || this.resolution), this.setRealSize(t * i, e * i, i);
				}),
				(e.prototype.setRealSize = function (t, e, i) {
					return (
						(this.resolution = i || this.resolution),
						(this.width = Math.round(t) / this.resolution),
						(this.height = Math.round(e) / this.resolution),
						this._refreshPOT(),
						this.update(),
						this
					);
				}),
				(e.prototype._refreshPOT = function () {
					this.isPowerOfTwo =
						isPow2$1(this.realWidth) && isPow2$1(this.realHeight);
				}),
				(e.prototype.setResolution = function (t) {
					var e = this.resolution;
					return (
						e === t ||
							((this.resolution = t),
							this.valid &&
								((this.width = Math.round(this.width * e) / t),
								(this.height = Math.round(this.height * e) / t),
								this.emit('update', this)),
							this._refreshPOT()),
						this
					);
				}),
				(e.prototype.setResource = function (t) {
					if (this.resource === t) return this;
					if (this.resource) throw new Error('Resource can be set only once');
					return t.bind(this), (this.resource = t), this;
				}),
				(e.prototype.update = function () {
					this.valid
						? (this.dirtyId++, this.dirtyStyleId++, this.emit('update', this))
						: this.width > 0 &&
						  this.height > 0 &&
						  ((this.valid = !0),
						  this.emit('loaded', this),
						  this.emit('update', this));
				}),
				(e.prototype.onError = function (t) {
					this.emit('error', this, t);
				}),
				(e.prototype.destroy = function () {
					this.resource &&
						(this.resource.unbind(this),
						this.resource.internal && this.resource.destroy(),
						(this.resource = null)),
						this.cacheId &&
							(delete BaseTextureCache$1[this.cacheId],
							delete TextureCache$1[this.cacheId],
							(this.cacheId = null)),
						this.dispose(),
						e.removeFromCache(this),
						(this.textureCacheIds = null),
						(this.destroyed = !0);
				}),
				(e.prototype.dispose = function () {
					this.emit('dispose', this);
				}),
				(e.prototype.castToBaseTexture = function () {
					return this;
				}),
				(e.from = function (t, i, r) {
					void 0 === r && (r = settings$2.STRICT_TEXTURE_CACHE);
					var s = 'string' == typeof t,
						n = null;
					if (s) n = t;
					else {
						if (!t._pixiId) {
							var a = (i && i.pixiIdPrefix) || 'pixiid';
							t._pixiId = a + '_' + uid$1();
						}
						n = t._pixiId;
					}
					var o = BaseTextureCache$1[n];
					if (s && r && !o)
						throw new Error(
							'The cacheId "' + n + '" does not exist in BaseTextureCache.'
						);
					return o || (((o = new e(t, i)).cacheId = n), e.addToCache(o, n)), o;
				}),
				(e.fromBuffer = function (t, i, r, s) {
					t = t || new Float32Array(i * r * 4);
					var n = new BufferResource$1(t, { width: i, height: r }),
						a =
							t instanceof Float32Array ? TYPES$3.FLOAT : TYPES$3.UNSIGNED_BYTE;
					return new e(
						n,
						Object.assign(
							defaultBufferOptions$1,
							s || { width: i, height: r, type: a }
						)
					);
				}),
				(e.addToCache = function (t, e) {
					e &&
						(-1 === t.textureCacheIds.indexOf(e) && t.textureCacheIds.push(e),
						BaseTextureCache$1[e],
						(BaseTextureCache$1[e] = t));
				}),
				(e.removeFromCache = function (t) {
					if ('string' == typeof t) {
						var e = BaseTextureCache$1[t];
						if (e) {
							var i = e.textureCacheIds.indexOf(t);
							return (
								i > -1 && e.textureCacheIds.splice(i, 1),
								delete BaseTextureCache$1[t],
								e
							);
						}
					} else if (t && t.textureCacheIds) {
						for (var r = 0; r < t.textureCacheIds.length; ++r)
							delete BaseTextureCache$1[t.textureCacheIds[r]];
						return (t.textureCacheIds.length = 0), t;
					}
					return null;
				}),
				(e._globalBatch = 0),
				e
			);
		})(eventemitter3$1),
		AbstractMultiResource$1 = (function (t) {
			function e(e, i) {
				var r = this,
					s = i || {},
					n = s.width,
					a = s.height;
				((r = t.call(this, n, a) || this).items = []), (r.itemDirtyIds = []);
				for (var o = 0; o < e; o++) {
					var h = new BaseTexture$1();
					r.items.push(h), r.itemDirtyIds.push(-2);
				}
				return (r.length = e), (r._load = null), (r.baseTexture = null), r;
			}
			return (
				__extends$b(e, t),
				(e.prototype.initFromArray = function (t, e) {
					for (var i = 0; i < this.length; i++)
						t[i] &&
							(t[i].castToBaseTexture
								? this.addBaseTextureAt(t[i].castToBaseTexture(), i)
								: t[i] instanceof Resource$1
								? this.addResourceAt(t[i], i)
								: this.addResourceAt(autoDetectResource$1(t[i], e), i));
				}),
				(e.prototype.dispose = function () {
					for (var t = 0, e = this.length; t < e; t++) this.items[t].destroy();
					(this.items = null), (this.itemDirtyIds = null), (this._load = null);
				}),
				(e.prototype.addResourceAt = function (t, e) {
					if (!this.items[e])
						throw new Error('Index ' + e + ' is out of bounds');
					return (
						t.valid && !this.valid && this.resize(t.width, t.height),
						this.items[e].setResource(t),
						this
					);
				}),
				(e.prototype.bind = function (e) {
					if (null !== this.baseTexture)
						throw new Error(
							'Only one base texture per TextureArray is allowed'
						);
					t.prototype.bind.call(this, e);
					for (var i = 0; i < this.length; i++)
						(this.items[i].parentTextureArray = e),
							this.items[i].on('update', e.update, e);
				}),
				(e.prototype.unbind = function (e) {
					t.prototype.unbind.call(this, e);
					for (var i = 0; i < this.length; i++)
						(this.items[i].parentTextureArray = null),
							this.items[i].off('update', e.update, e);
				}),
				(e.prototype.load = function () {
					var t = this;
					if (this._load) return this._load;
					var e = this.items
						.map(function (t) {
							return t.resource;
						})
						.filter(function (t) {
							return t;
						})
						.map(function (t) {
							return t.load();
						});
					return (
						(this._load = Promise.all(e).then(function () {
							var e = t.items[0],
								i = e.realWidth,
								r = e.realHeight;
							return t.resize(i, r), Promise.resolve(t);
						})),
						this._load
					);
				}),
				e
			);
		})(Resource$1),
		ArrayResource$1 = (function (t) {
			function e(e, i) {
				var r,
					s,
					n = this,
					a = i || {},
					o = a.width,
					h = a.height;
				return (
					Array.isArray(e) ? ((r = e), (s = e.length)) : (s = e),
					(n = t.call(this, s, { width: o, height: h }) || this),
					r && n.initFromArray(r, i),
					n
				);
			}
			return (
				__extends$b(e, t),
				(e.prototype.addBaseTextureAt = function (t, e) {
					if (!t.resource)
						throw new Error('ArrayResource does not support RenderTexture');
					return this.addResourceAt(t.resource, e), this;
				}),
				(e.prototype.bind = function (e) {
					t.prototype.bind.call(this, e),
						(e.target = TARGETS$3.TEXTURE_2D_ARRAY);
				}),
				(e.prototype.upload = function (t, e, i) {
					var r = this,
						s = r.length,
						n = r.itemDirtyIds,
						a = r.items,
						o = t.gl;
					i.dirtyId < 0 &&
						o.texImage3D(
							o.TEXTURE_2D_ARRAY,
							0,
							i.internalFormat,
							this._width,
							this._height,
							s,
							0,
							e.format,
							i.type,
							null
						);
					for (var h = 0; h < s; h++) {
						var u = a[h];
						n[h] < u.dirtyId &&
							((n[h] = u.dirtyId),
							u.valid &&
								o.texSubImage3D(
									o.TEXTURE_2D_ARRAY,
									0,
									0,
									0,
									h,
									u.resource.width,
									u.resource.height,
									1,
									e.format,
									i.type,
									u.resource.source
								));
					}
					return !0;
				}),
				e
			);
		})(AbstractMultiResource$1),
		BaseImageResource$1 = (function (t) {
			function e(e) {
				var i = this,
					r = e,
					s = r.naturalWidth || r.videoWidth || r.width,
					n = r.naturalHeight || r.videoHeight || r.height;
				return (
					((i = t.call(this, s, n) || this).source = e), (i.noSubImage = !1), i
				);
			}
			return (
				__extends$b(e, t),
				(e.crossOrigin = function (t, e, i) {
					void 0 === i && 0 !== e.indexOf('data:')
						? (t.crossOrigin = determineCrossOrigin$1(e))
						: !1 !== i &&
						  (t.crossOrigin = 'string' == typeof i ? i : 'anonymous');
				}),
				(e.prototype.upload = function (t, e, i, r) {
					var s = t.gl,
						n = e.realWidth,
						a = e.realHeight;
					return (
						(r = r || this.source),
						s.pixelStorei(
							s.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
							e.alphaMode === ALPHA_MODES$3.UNPACK
						),
						this.noSubImage ||
						e.target !== s.TEXTURE_2D ||
						i.width !== n ||
						i.height !== a
							? ((i.width = n),
							  (i.height = a),
							  s.texImage2D(
									e.target,
									0,
									i.internalFormat,
									e.format,
									i.type,
									r
							  ))
							: s.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, e.format, i.type, r),
						!0
					);
				}),
				(e.prototype.update = function () {
					if (!this.destroyed) {
						var e = this.source,
							i = e.naturalWidth || e.videoWidth || e.width,
							r = e.naturalHeight || e.videoHeight || e.height;
						this.resize(i, r), t.prototype.update.call(this);
					}
				}),
				(e.prototype.dispose = function () {
					this.source = null;
				}),
				e
			);
		})(Resource$1),
		CanvasResource$1 = (function (t) {
			function e(e) {
				return t.call(this, e) || this;
			}
			return (
				__extends$b(e, t),
				(e.test = function (t) {
					var e = self.OffscreenCanvas;
					return (
						!!(e && t instanceof e) ||
						(self.HTMLCanvasElement && t instanceof HTMLCanvasElement)
					);
				}),
				e
			);
		})(BaseImageResource$1),
		CubeResource$1 = (function (t) {
			function e(i, r) {
				var s = this,
					n = r || {},
					a = n.width,
					o = n.height,
					h = n.autoLoad,
					u = n.linkBaseTexture;
				if (i && i.length !== e.SIDES)
					throw new Error('Invalid length. Got ' + i.length + ', expected 6');
				s = t.call(this, 6, { width: a, height: o }) || this;
				for (var l = 0; l < e.SIDES; l++)
					s.items[l].target = TARGETS$3.TEXTURE_CUBE_MAP_POSITIVE_X + l;
				return (
					(s.linkBaseTexture = !1 !== u),
					i && s.initFromArray(i, r),
					!1 !== h && s.load(),
					s
				);
			}
			return (
				__extends$b(e, t),
				(e.prototype.bind = function (e) {
					t.prototype.bind.call(this, e),
						(e.target = TARGETS$3.TEXTURE_CUBE_MAP);
				}),
				(e.prototype.addBaseTextureAt = function (t, e, i) {
					if ((void 0 === i && (i = this.linkBaseTexture), !this.items[e]))
						throw new Error('Index ' + e + ' is out of bounds');
					if (
						!this.linkBaseTexture ||
						t.parentTextureArray ||
						Object.keys(t._glTextures).length > 0
					) {
						if (!t.resource)
							throw new Error(
								'CubeResource does not support copying of renderTexture.'
							);
						this.addResourceAt(t.resource, e);
					} else
						(t.target = TARGETS$3.TEXTURE_CUBE_MAP_POSITIVE_X + e),
							(t.parentTextureArray = this.baseTexture),
							(this.items[e] = t);
					return (
						t.valid && !this.valid && this.resize(t.realWidth, t.realHeight),
						(this.items[e] = t),
						this
					);
				}),
				(e.prototype.upload = function (t, i, r) {
					for (var s = this.itemDirtyIds, n = 0; n < e.SIDES; n++) {
						var a = this.items[n];
						s[n] < a.dirtyId &&
							(a.valid && a.resource
								? (a.resource.upload(t, a, r), (s[n] = a.dirtyId))
								: s[n] < -1 &&
								  (t.gl.texImage2D(
										a.target,
										0,
										r.internalFormat,
										i.realWidth,
										i.realHeight,
										0,
										i.format,
										r.type,
										null
								  ),
								  (s[n] = -1)));
					}
					return !0;
				}),
				(e.test = function (t) {
					return Array.isArray(t) && t.length === e.SIDES;
				}),
				(e.SIDES = 6),
				e
			);
		})(AbstractMultiResource$1),
		ImageResource$1 = (function (t) {
			function e(e, i) {
				var r = this;
				if (((i = i || {}), !(e instanceof HTMLImageElement))) {
					var s = new Image();
					BaseImageResource$1.crossOrigin(s, e, i.crossorigin),
						(s.src = e),
						(e = s);
				}
				return (
					(r = t.call(this, e) || this),
					!e.complete &&
						r._width &&
						r._height &&
						((r._width = 0), (r._height = 0)),
					(r.url = e.src),
					(r._process = null),
					(r.preserveBitmap = !1),
					(r.createBitmap =
						(void 0 !== i.createBitmap
							? i.createBitmap
							: settings$2.CREATE_IMAGE_BITMAP) && !!self.createImageBitmap),
					(r.alphaMode = 'number' == typeof i.alphaMode ? i.alphaMode : null),
					(r.bitmap = null),
					(r._load = null),
					!1 !== i.autoLoad && r.load(),
					r
				);
			}
			return (
				__extends$b(e, t),
				(e.prototype.load = function (t) {
					var e = this;
					return (
						this._load ||
							(void 0 !== t && (this.createBitmap = t),
							(this._load = new Promise(function (t, i) {
								var r = e.source;
								e.url = r.src;
								var s = function () {
									e.destroyed ||
										((r.onload = null),
										(r.onerror = null),
										e.resize(r.width, r.height),
										(e._load = null),
										e.createBitmap ? t(e.process()) : t(e));
								};
								r.complete && r.src
									? s()
									: ((r.onload = s),
									  (r.onerror = function (t) {
											i(t), e.onError.emit(t);
									  }));
							}))),
						this._load
					);
				}),
				(e.prototype.process = function () {
					var t = this,
						e = this.source;
					if (null !== this._process) return this._process;
					if (null !== this.bitmap || !self.createImageBitmap)
						return Promise.resolve(this);
					var i = self.createImageBitmap,
						r = !e.crossOrigin || 'anonymous' === e.crossOrigin;
					return (
						(this._process = fetch(e.src, { mode: r ? 'cors' : 'no-cors' })
							.then(function (t) {
								return t.blob();
							})
							.then(function (r) {
								return i(r, 0, 0, e.width, e.height, {
									premultiplyAlpha:
										t.alphaMode === ALPHA_MODES$3.UNPACK
											? 'premultiply'
											: 'none',
								});
							})
							.then(function (e) {
								return t.destroyed
									? Promise.reject()
									: ((t.bitmap = e),
									  t.update(),
									  (t._process = null),
									  Promise.resolve(t));
							})),
						this._process
					);
				}),
				(e.prototype.upload = function (e, i, r) {
					if (
						('number' == typeof this.alphaMode &&
							(i.alphaMode = this.alphaMode),
						!this.createBitmap)
					)
						return t.prototype.upload.call(this, e, i, r);
					if (!this.bitmap && (this.process(), !this.bitmap)) return !1;
					if (
						(t.prototype.upload.call(this, e, i, r, this.bitmap),
						!this.preserveBitmap)
					) {
						var s = !0,
							n = i._glTextures;
						for (var a in n) {
							var o = n[a];
							if (o !== r && o.dirtyId !== i.dirtyId) {
								s = !1;
								break;
							}
						}
						s &&
							(this.bitmap.close && this.bitmap.close(), (this.bitmap = null));
					}
					return !0;
				}),
				(e.prototype.dispose = function () {
					(this.source.onload = null),
						(this.source.onerror = null),
						t.prototype.dispose.call(this),
						this.bitmap && (this.bitmap.close(), (this.bitmap = null)),
						(this._process = null),
						(this._load = null);
				}),
				(e.test = function (t) {
					return 'string' == typeof t || t instanceof HTMLImageElement;
				}),
				e
			);
		})(BaseImageResource$1),
		SVGResource$1 = (function (t) {
			function e(e, i) {
				var r = this;
				return (
					(i = i || {}),
					((r =
						t.call(this, document.createElement('canvas')) || this)._width = 0),
					(r._height = 0),
					(r.svg = e),
					(r.scale = i.scale || 1),
					(r._overrideWidth = i.width),
					(r._overrideHeight = i.height),
					(r._resolve = null),
					(r._crossorigin = i.crossorigin),
					(r._load = null),
					!1 !== i.autoLoad && r.load(),
					r
				);
			}
			return (
				__extends$b(e, t),
				(e.prototype.load = function () {
					var t = this;
					return (
						this._load ||
							(this._load = new Promise(function (i) {
								if (
									((t._resolve = function () {
										t.resize(t.source.width, t.source.height), i(t);
									}),
									e.SVG_XML.test(t.svg.trim()))
								) {
									if (!btoa)
										throw new Error(
											"Your browser doesn't support base64 conversions."
										);
									t.svg =
										'data:image/svg+xml;base64,' +
										btoa(unescape(encodeURIComponent(t.svg)));
								}
								t._loadSvg();
							})),
						this._load
					);
				}),
				(e.prototype._loadSvg = function () {
					var t = this,
						e = new Image();
					BaseImageResource$1.crossOrigin(e, this.svg, this._crossorigin),
						(e.src = this.svg),
						(e.onerror = function (i) {
							t._resolve && ((e.onerror = null), t.onError.emit(i));
						}),
						(e.onload = function () {
							if (t._resolve) {
								var i = e.width,
									r = e.height;
								if (!i || !r)
									throw new Error(
										'The SVG image must have width and height defined (in pixels), canvas API needs them.'
									);
								var s = i * t.scale,
									n = r * t.scale;
								(t._overrideWidth || t._overrideHeight) &&
									((s = t._overrideWidth || (t._overrideHeight / r) * i),
									(n = t._overrideHeight || (t._overrideWidth / i) * r)),
									(s = Math.round(s)),
									(n = Math.round(n));
								var a = t.source;
								(a.width = s),
									(a.height = n),
									(a._pixiId = 'canvas_' + uid$1()),
									a.getContext('2d').drawImage(e, 0, 0, i, r, 0, 0, s, n),
									t._resolve(),
									(t._resolve = null);
							}
						});
				}),
				(e.getSize = function (t) {
					var i = e.SVG_SIZE.exec(t),
						r = {};
					return (
						i &&
							((r[i[1]] = Math.round(parseFloat(i[3]))),
							(r[i[5]] = Math.round(parseFloat(i[7])))),
						r
					);
				}),
				(e.prototype.dispose = function () {
					t.prototype.dispose.call(this),
						(this._resolve = null),
						(this._crossorigin = null);
				}),
				(e.test = function (t, i) {
					return (
						'svg' === i ||
						('string' == typeof t &&
							/^data:image\/svg\+xml(;(charset=utf8|utf8))?;base64/.test(t)) ||
						('string' == typeof t && e.SVG_XML.test(t))
					);
				}),
				(e.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m),
				(e.SVG_SIZE =
					/<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i),
				e
			);
		})(BaseImageResource$1),
		VideoResource$1 = (function (t) {
			function e(i, r) {
				var s = this;
				if (((r = r || {}), !(i instanceof HTMLVideoElement))) {
					var n = document.createElement('video');
					n.setAttribute('preload', 'auto'),
						n.setAttribute('webkit-playsinline', ''),
						n.setAttribute('playsinline', ''),
						'string' == typeof i && (i = [i]);
					var a = i[0].src || i[0];
					BaseImageResource$1.crossOrigin(n, a, r.crossorigin);
					for (var o = 0; o < i.length; ++o) {
						var h = document.createElement('source'),
							u = i[o],
							l = u.src,
							c = u.mime,
							d = (l = l || i[o]).split('?').shift().toLowerCase(),
							p = d.substr(d.lastIndexOf('.') + 1);
						(c = c || e.MIME_TYPES[p] || 'video/' + p),
							(h.src = l),
							(h.type = c),
							n.appendChild(h);
					}
					i = n;
				}
				return (
					((s = t.call(this, i) || this).noSubImage = !0),
					(s._autoUpdate = !0),
					(s._isConnectedToTicker = !1),
					(s._updateFPS = r.updateFPS || 0),
					(s._msToNextUpdate = 0),
					(s.autoPlay = !1 !== r.autoPlay),
					(s._load = null),
					(s._resolve = null),
					(s._onCanPlay = s._onCanPlay.bind(s)),
					(s._onError = s._onError.bind(s)),
					!1 !== r.autoLoad && s.load(),
					s
				);
			}
			return (
				__extends$b(e, t),
				(e.prototype.update = function (e) {
					if (!this.destroyed) {
						var i = Ticker$1.shared.elapsedMS * this.source.playbackRate;
						(this._msToNextUpdate = Math.floor(this._msToNextUpdate - i)),
							(!this._updateFPS || this._msToNextUpdate <= 0) &&
								(t.prototype.update.call(this),
								(this._msToNextUpdate = this._updateFPS
									? Math.floor(1e3 / this._updateFPS)
									: 0));
					}
				}),
				(e.prototype.load = function () {
					var t = this;
					if (this._load) return this._load;
					var e = this.source;
					return (
						(e.readyState === e.HAVE_ENOUGH_DATA ||
							e.readyState === e.HAVE_FUTURE_DATA) &&
							e.width &&
							e.height &&
							(e.complete = !0),
						e.addEventListener('play', this._onPlayStart.bind(this)),
						e.addEventListener('pause', this._onPlayStop.bind(this)),
						this._isSourceReady()
							? this._onCanPlay()
							: (e.addEventListener('canplay', this._onCanPlay),
							  e.addEventListener('canplaythrough', this._onCanPlay),
							  e.addEventListener('error', this._onError, !0)),
						(this._load = new Promise(function (i) {
							t.valid ? i(t) : ((t._resolve = i), e.load());
						})),
						this._load
					);
				}),
				(e.prototype._onError = function (t) {
					this.source.removeEventListener('error', this._onError, !0),
						this.onError.emit(t);
				}),
				(e.prototype._isSourcePlaying = function () {
					var t = this.source;
					return (
						t.currentTime > 0 &&
						!1 === t.paused &&
						!1 === t.ended &&
						t.readyState > 2
					);
				}),
				(e.prototype._isSourceReady = function () {
					var t = this.source;
					return 3 === t.readyState || 4 === t.readyState;
				}),
				(e.prototype._onPlayStart = function () {
					this.valid || this._onCanPlay(),
						this.autoUpdate &&
							!this._isConnectedToTicker &&
							(Ticker$1.shared.add(this.update, this),
							(this._isConnectedToTicker = !0));
				}),
				(e.prototype._onPlayStop = function () {
					this._isConnectedToTicker &&
						(Ticker$1.shared.remove(this.update, this),
						(this._isConnectedToTicker = !1));
				}),
				(e.prototype._onCanPlay = function () {
					var t = this.source;
					t.removeEventListener('canplay', this._onCanPlay),
						t.removeEventListener('canplaythrough', this._onCanPlay);
					var e = this.valid;
					this.resize(t.videoWidth, t.videoHeight),
						!e &&
							this._resolve &&
							(this._resolve(this), (this._resolve = null)),
						this._isSourcePlaying()
							? this._onPlayStart()
							: this.autoPlay && t.play();
				}),
				(e.prototype.dispose = function () {
					this._isConnectedToTicker &&
						(Ticker$1.shared.remove(this.update, this),
						(this._isConnectedToTicker = !1));
					var e = this.source;
					e &&
						(e.removeEventListener('error', this._onError, !0),
						e.pause(),
						(e.src = ''),
						e.load()),
						t.prototype.dispose.call(this);
				}),
				Object.defineProperty(e.prototype, 'autoUpdate', {
					get: function () {
						return this._autoUpdate;
					},
					set: function (t) {
						t !== this._autoUpdate &&
							((this._autoUpdate = t),
							!this._autoUpdate && this._isConnectedToTicker
								? (Ticker$1.shared.remove(this.update, this),
								  (this._isConnectedToTicker = !1))
								: this._autoUpdate &&
								  !this._isConnectedToTicker &&
								  this._isSourcePlaying() &&
								  (Ticker$1.shared.add(this.update, this),
								  (this._isConnectedToTicker = !0)));
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'updateFPS', {
					get: function () {
						return this._updateFPS;
					},
					set: function (t) {
						t !== this._updateFPS && (this._updateFPS = t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.test = function (t, i) {
					return (
						(self.HTMLVideoElement && t instanceof HTMLVideoElement) ||
						e.TYPES.indexOf(i) > -1
					);
				}),
				(e.TYPES = ['mp4', 'm4v', 'webm', 'ogg', 'ogv', 'h264', 'avi', 'mov']),
				(e.MIME_TYPES = {
					ogv: 'video/ogg',
					mov: 'video/quicktime',
					m4v: 'video/mp4',
				}),
				e
			);
		})(BaseImageResource$1),
		ImageBitmapResource$1 = (function (t) {
			function e(e) {
				return t.call(this, e) || this;
			}
			return (
				__extends$b(e, t),
				(e.test = function (t) {
					return !!self.createImageBitmap && t instanceof ImageBitmap;
				}),
				e
			);
		})(BaseImageResource$1);
	INSTALLED$1.push(
		ImageResource$1,
		ImageBitmapResource$1,
		CanvasResource$1,
		VideoResource$1,
		SVGResource$1,
		BufferResource$1,
		CubeResource$1,
		ArrayResource$1
	);
	var DepthResource$1 = (function (t) {
			function e() {
				return (null !== t && t.apply(this, arguments)) || this;
			}
			return (
				__extends$b(e, t),
				(e.prototype.upload = function (t, e, i) {
					var r = t.gl;
					r.pixelStorei(
						r.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
						e.alphaMode === ALPHA_MODES$3.UNPACK
					);
					var s = e.realWidth,
						n = e.realHeight;
					return (
						i.width === s && i.height === n
							? r.texSubImage2D(
									e.target,
									0,
									0,
									0,
									s,
									n,
									e.format,
									i.type,
									this.data
							  )
							: ((i.width = s),
							  (i.height = n),
							  r.texImage2D(
									e.target,
									0,
									i.internalFormat,
									s,
									n,
									0,
									e.format,
									i.type,
									this.data
							  )),
						!0
					);
				}),
				e
			);
		})(BufferResource$1),
		Framebuffer$1 = (function () {
			function t(t, e) {
				(this.width = Math.round(t || 100)),
					(this.height = Math.round(e || 100)),
					(this.stencil = !1),
					(this.depth = !1),
					(this.dirtyId = 0),
					(this.dirtyFormat = 0),
					(this.dirtySize = 0),
					(this.depthTexture = null),
					(this.colorTextures = []),
					(this.glFramebuffers = {}),
					(this.disposeRunner = new Runner$1('disposeFramebuffer')),
					(this.multisample = MSAA_QUALITY$3.NONE);
			}
			return (
				Object.defineProperty(t.prototype, 'colorTexture', {
					get: function () {
						return this.colorTextures[0];
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.addColorTexture = function (t, e) {
					return (
						void 0 === t && (t = 0),
						(this.colorTextures[t] =
							e ||
							new BaseTexture$1(null, {
								scaleMode: SCALE_MODES$3.NEAREST,
								resolution: 1,
								mipmap: MIPMAP_MODES$3.OFF,
								width: this.width,
								height: this.height,
							})),
						this.dirtyId++,
						this.dirtyFormat++,
						this
					);
				}),
				(t.prototype.addDepthTexture = function (t) {
					return (
						(this.depthTexture =
							t ||
							new BaseTexture$1(
								new DepthResource$1(null, {
									width: this.width,
									height: this.height,
								}),
								{
									scaleMode: SCALE_MODES$3.NEAREST,
									resolution: 1,
									width: this.width,
									height: this.height,
									mipmap: MIPMAP_MODES$3.OFF,
									format: FORMATS$3.DEPTH_COMPONENT,
									type: TYPES$3.UNSIGNED_SHORT,
								}
							)),
						this.dirtyId++,
						this.dirtyFormat++,
						this
					);
				}),
				(t.prototype.enableDepth = function () {
					return (this.depth = !0), this.dirtyId++, this.dirtyFormat++, this;
				}),
				(t.prototype.enableStencil = function () {
					return (this.stencil = !0), this.dirtyId++, this.dirtyFormat++, this;
				}),
				(t.prototype.resize = function (t, e) {
					if (
						((t = Math.round(t)),
						(e = Math.round(e)),
						t !== this.width || e !== this.height)
					) {
						(this.width = t),
							(this.height = e),
							this.dirtyId++,
							this.dirtySize++;
						for (var i = 0; i < this.colorTextures.length; i++) {
							var r = this.colorTextures[i],
								s = r.resolution;
							r.setSize(t / s, e / s);
						}
						this.depthTexture &&
							((s = this.depthTexture.resolution),
							this.depthTexture.setSize(t / s, e / s));
					}
				}),
				(t.prototype.dispose = function () {
					this.disposeRunner.emit(this, !1);
				}),
				(t.prototype.destroyDepthTexture = function () {
					this.depthTexture &&
						(this.depthTexture.destroy(),
						(this.depthTexture = null),
						++this.dirtyId,
						++this.dirtyFormat);
				}),
				t
			);
		})(),
		BaseRenderTexture$1 = (function (t) {
			function e(e) {
				var i = this;
				if ('number' == typeof e) {
					var r = arguments[0],
						s = arguments[1],
						n = arguments[2],
						a = arguments[3];
					e = { width: r, height: s, scaleMode: n, resolution: a };
				}
				return (
					(e.width = e.width || 100),
					(e.height = e.height || 100),
					(e.multisample =
						void 0 !== e.multisample ? e.multisample : MSAA_QUALITY$3.NONE),
					((i = t.call(this, null, e) || this).mipmap = MIPMAP_MODES$3.OFF),
					(i.valid = !0),
					(i.clearColor = [0, 0, 0, 0]),
					(i.framebuffer = new Framebuffer$1(
						i.realWidth,
						i.realHeight
					).addColorTexture(0, i)),
					(i.framebuffer.multisample = e.multisample),
					(i.maskStack = []),
					(i.filterStack = [{}]),
					i
				);
			}
			return (
				__extends$b(e, t),
				(e.prototype.resize = function (t, e) {
					this.framebuffer.resize(t * this.resolution, e * this.resolution),
						this.setRealSize(this.framebuffer.width, this.framebuffer.height);
				}),
				(e.prototype.dispose = function () {
					this.framebuffer.dispose(), t.prototype.dispose.call(this);
				}),
				(e.prototype.destroy = function () {
					t.prototype.destroy.call(this),
						this.framebuffer.destroyDepthTexture(),
						(this.framebuffer = null);
				}),
				e
			);
		})(BaseTexture$1),
		TextureUvs$1 = (function () {
			function t() {
				(this.x0 = 0),
					(this.y0 = 0),
					(this.x1 = 1),
					(this.y1 = 0),
					(this.x2 = 1),
					(this.y2 = 1),
					(this.x3 = 0),
					(this.y3 = 1),
					(this.uvsFloat32 = new Float32Array(8));
			}
			return (
				(t.prototype.set = function (t, e, i) {
					var r = e.width,
						s = e.height;
					if (i) {
						var n = t.width / 2 / r,
							a = t.height / 2 / s,
							o = t.x / r + n,
							h = t.y / s + a;
						(i = groupD8$1.add(i, groupD8$1.NW)),
							(this.x0 = o + n * groupD8$1.uX(i)),
							(this.y0 = h + a * groupD8$1.uY(i)),
							(i = groupD8$1.add(i, 2)),
							(this.x1 = o + n * groupD8$1.uX(i)),
							(this.y1 = h + a * groupD8$1.uY(i)),
							(i = groupD8$1.add(i, 2)),
							(this.x2 = o + n * groupD8$1.uX(i)),
							(this.y2 = h + a * groupD8$1.uY(i)),
							(i = groupD8$1.add(i, 2)),
							(this.x3 = o + n * groupD8$1.uX(i)),
							(this.y3 = h + a * groupD8$1.uY(i));
					} else
						(this.x0 = t.x / r),
							(this.y0 = t.y / s),
							(this.x1 = (t.x + t.width) / r),
							(this.y1 = t.y / s),
							(this.x2 = (t.x + t.width) / r),
							(this.y2 = (t.y + t.height) / s),
							(this.x3 = t.x / r),
							(this.y3 = (t.y + t.height) / s);
					(this.uvsFloat32[0] = this.x0),
						(this.uvsFloat32[1] = this.y0),
						(this.uvsFloat32[2] = this.x1),
						(this.uvsFloat32[3] = this.y1),
						(this.uvsFloat32[4] = this.x2),
						(this.uvsFloat32[5] = this.y2),
						(this.uvsFloat32[6] = this.x3),
						(this.uvsFloat32[7] = this.y3);
				}),
				(t.prototype.toString = function () {
					return (
						'[@pixi/core:TextureUvs x0=' +
						this.x0 +
						' y0=' +
						this.y0 +
						' x1=' +
						this.x1 +
						' y1=' +
						this.y1 +
						' x2=' +
						this.x2 +
						' y2=' +
						this.y2 +
						' x3=' +
						this.x3 +
						' y3=' +
						this.y3 +
						']'
					);
				}),
				t
			);
		})(),
		DEFAULT_UVS$1 = new TextureUvs$1(),
		Texture$1 = (function (t) {
			function e(i, r, s, n, a, o) {
				var h = t.call(this) || this;
				if (
					((h.noFrame = !1),
					r || ((h.noFrame = !0), (r = new Rectangle$2(0, 0, 1, 1))),
					i instanceof e && (i = i.baseTexture),
					(h.baseTexture = i),
					(h._frame = r),
					(h.trim = n),
					(h.valid = !1),
					(h._uvs = DEFAULT_UVS$1),
					(h.uvMatrix = null),
					(h.orig = s || r),
					(h._rotate = Number(a || 0)),
					!0 === a)
				)
					h._rotate = 2;
				else if (h._rotate % 2 != 0)
					throw new Error(
						'attempt to use diamond-shaped UVs. If you are sure, set rotation manually'
					);
				return (
					(h.defaultAnchor = o ? new Point$2(o.x, o.y) : new Point$2(0, 0)),
					(h._updateID = 0),
					(h.textureCacheIds = []),
					i.valid
						? h.noFrame
							? i.valid && h.onBaseTextureUpdated(i)
							: (h.frame = r)
						: i.once('loaded', h.onBaseTextureUpdated, h),
					h.noFrame && i.on('update', h.onBaseTextureUpdated, h),
					h
				);
			}
			return (
				__extends$b(e, t),
				(e.prototype.update = function () {
					this.baseTexture.resource && this.baseTexture.resource.update();
				}),
				(e.prototype.onBaseTextureUpdated = function (t) {
					if (this.noFrame) {
						if (!this.baseTexture.valid) return;
						(this._frame.width = t.width),
							(this._frame.height = t.height),
							(this.valid = !0),
							this.updateUvs();
					} else this.frame = this._frame;
					this.emit('update', this);
				}),
				(e.prototype.destroy = function (t) {
					if (this.baseTexture) {
						if (t) {
							var i = this.baseTexture.resource;
							i && i.url && TextureCache$1[i.url] && e.removeFromCache(i.url),
								this.baseTexture.destroy();
						}
						this.baseTexture.off('loaded', this.onBaseTextureUpdated, this),
							this.baseTexture.off('update', this.onBaseTextureUpdated, this),
							(this.baseTexture = null);
					}
					(this._frame = null),
						(this._uvs = null),
						(this.trim = null),
						(this.orig = null),
						(this.valid = !1),
						e.removeFromCache(this),
						(this.textureCacheIds = null);
				}),
				(e.prototype.clone = function () {
					var t = this._frame.clone(),
						i = this._frame === this.orig ? t : this.orig.clone(),
						r = new e(
							this.baseTexture,
							!this.noFrame && t,
							i,
							this.trim && this.trim.clone(),
							this.rotate,
							this.defaultAnchor
						);
					return this.noFrame && (r._frame = t), r;
				}),
				(e.prototype.updateUvs = function () {
					this._uvs === DEFAULT_UVS$1 && (this._uvs = new TextureUvs$1()),
						this._uvs.set(this._frame, this.baseTexture, this.rotate),
						this._updateID++;
				}),
				(e.from = function (t, i, r) {
					void 0 === i && (i = {}),
						void 0 === r && (r = settings$2.STRICT_TEXTURE_CACHE);
					var s = 'string' == typeof t,
						n = null;
					if (s) n = t;
					else if (t instanceof BaseTexture$1) {
						if (!t.cacheId) {
							var a = (i && i.pixiIdPrefix) || 'pixiid';
							(t.cacheId = a + '-' + uid$1()),
								BaseTexture$1.addToCache(t, t.cacheId);
						}
						n = t.cacheId;
					} else
						t._pixiId ||
							((a = (i && i.pixiIdPrefix) || 'pixiid'),
							(t._pixiId = a + '_' + uid$1())),
							(n = t._pixiId);
					var o = TextureCache$1[n];
					if (s && r && !o)
						throw new Error(
							'The cacheId "' + n + '" does not exist in TextureCache.'
						);
					return (
						o || t instanceof BaseTexture$1
							? !o &&
							  t instanceof BaseTexture$1 &&
							  ((o = new e(t)), e.addToCache(o, n))
							: (i.resolution || (i.resolution = getResolutionOfUrl$1(t)),
							  ((o = new e(new BaseTexture$1(t, i))).baseTexture.cacheId = n),
							  BaseTexture$1.addToCache(o.baseTexture, n),
							  e.addToCache(o, n)),
						o
					);
				}),
				(e.fromURL = function (t, i) {
					var r = Object.assign(
							{ autoLoad: !1 },
							null == i ? void 0 : i.resourceOptions
						),
						s = e.from(t, Object.assign({ resourceOptions: r }, i), !1),
						n = s.baseTexture.resource;
					return s.baseTexture.valid
						? Promise.resolve(s)
						: n.load().then(function () {
								return Promise.resolve(s);
						  });
				}),
				(e.fromBuffer = function (t, i, r, s) {
					return new e(BaseTexture$1.fromBuffer(t, i, r, s));
				}),
				(e.fromLoader = function (t, i, r, s) {
					var n = new BaseTexture$1(
							t,
							Object.assign(
								{
									scaleMode: settings$2.SCALE_MODE,
									resolution: getResolutionOfUrl$1(i),
								},
								s
							)
						),
						a = n.resource;
					a instanceof ImageResource$1 && (a.url = i);
					var o = new e(n);
					return (
						r || (r = i),
						BaseTexture$1.addToCache(o.baseTexture, r),
						e.addToCache(o, r),
						r !== i &&
							(BaseTexture$1.addToCache(o.baseTexture, i), e.addToCache(o, i)),
						o.baseTexture.valid
							? Promise.resolve(o)
							: new Promise(function (t) {
									o.baseTexture.once('loaded', function () {
										return t(o);
									});
							  })
					);
				}),
				(e.addToCache = function (t, e) {
					e &&
						(-1 === t.textureCacheIds.indexOf(e) && t.textureCacheIds.push(e),
						TextureCache$1[e],
						(TextureCache$1[e] = t));
				}),
				(e.removeFromCache = function (t) {
					if ('string' == typeof t) {
						var e = TextureCache$1[t];
						if (e) {
							var i = e.textureCacheIds.indexOf(t);
							return (
								i > -1 && e.textureCacheIds.splice(i, 1),
								delete TextureCache$1[t],
								e
							);
						}
					} else if (t && t.textureCacheIds) {
						for (var r = 0; r < t.textureCacheIds.length; ++r)
							TextureCache$1[t.textureCacheIds[r]] === t &&
								delete TextureCache$1[t.textureCacheIds[r]];
						return (t.textureCacheIds.length = 0), t;
					}
					return null;
				}),
				Object.defineProperty(e.prototype, 'resolution', {
					get: function () {
						return this.baseTexture.resolution;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'frame', {
					get: function () {
						return this._frame;
					},
					set: function (t) {
						(this._frame = t), (this.noFrame = !1);
						var e = t.x,
							i = t.y,
							r = t.width,
							s = t.height,
							n = e + r > this.baseTexture.width,
							a = i + s > this.baseTexture.height;
						if (n || a) {
							var o = n && a ? 'and' : 'or',
								h =
									'X: ' +
									e +
									' + ' +
									r +
									' = ' +
									(e + r) +
									' > ' +
									this.baseTexture.width,
								u =
									'Y: ' +
									i +
									' + ' +
									s +
									' = ' +
									(i + s) +
									' > ' +
									this.baseTexture.height;
							throw new Error(
								'Texture Error: frame does not fit inside the base Texture dimensions: ' +
									h +
									' ' +
									o +
									' ' +
									u
							);
						}
						(this.valid = r && s && this.baseTexture.valid),
							this.trim || this.rotate || (this.orig = t),
							this.valid && this.updateUvs();
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'rotate', {
					get: function () {
						return this._rotate;
					},
					set: function (t) {
						(this._rotate = t), this.valid && this.updateUvs();
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'width', {
					get: function () {
						return this.orig.width;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'height', {
					get: function () {
						return this.orig.height;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.castToBaseTexture = function () {
					return this.baseTexture;
				}),
				e
			);
		})(eventemitter3$1);
	function createWhiteTexture$1() {
		var t = document.createElement('canvas');
		(t.width = 16), (t.height = 16);
		var e = t.getContext('2d');
		return (
			(e.fillStyle = 'white'),
			e.fillRect(0, 0, 16, 16),
			new Texture$1(new BaseTexture$1(new CanvasResource$1(t)))
		);
	}
	function removeAllHandlers$1(t) {
		(t.destroy = function () {}),
			(t.on = function () {}),
			(t.once = function () {}),
			(t.emit = function () {});
	}
	(Texture$1.EMPTY = new Texture$1(new BaseTexture$1())),
		removeAllHandlers$1(Texture$1.EMPTY),
		removeAllHandlers$1(Texture$1.EMPTY.baseTexture),
		(Texture$1.WHITE = createWhiteTexture$1()),
		removeAllHandlers$1(Texture$1.WHITE),
		removeAllHandlers$1(Texture$1.WHITE.baseTexture);
	var RenderTexture$1 = (function (t) {
			function e(e, i) {
				var r = t.call(this, e, i) || this;
				return (
					(r.valid = !0),
					(r.filterFrame = null),
					(r.filterPoolKey = null),
					r.updateUvs(),
					r
				);
			}
			return (
				__extends$b(e, t),
				Object.defineProperty(e.prototype, 'framebuffer', {
					get: function () {
						return this.baseTexture.framebuffer;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'multisample', {
					get: function () {
						return this.framebuffer.multisample;
					},
					set: function (t) {
						this.framebuffer.multisample = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.resize = function (t, e, i) {
					void 0 === i && (i = !0);
					var r = this.baseTexture.resolution,
						s = Math.round(t * r) / r,
						n = Math.round(e * r) / r;
					(this.valid = s > 0 && n > 0),
						(this._frame.width = this.orig.width = s),
						(this._frame.height = this.orig.height = n),
						i && this.baseTexture.resize(s, n),
						this.updateUvs();
				}),
				(e.prototype.setResolution = function (t) {
					var e = this.baseTexture;
					e.resolution !== t &&
						(e.setResolution(t), this.resize(e.width, e.height, !1));
				}),
				(e.create = function (t) {
					for (var i = arguments, r = [], s = 1; s < arguments.length; s++)
						r[s - 1] = i[s];
					return (
						'number' == typeof t &&
							(deprecation$1(
								'6.0.0',
								'Arguments (width, height, scaleMode, resolution) have been deprecated.'
							),
							(t = {
								width: t,
								height: r[0],
								scaleMode: r[1],
								resolution: r[2],
							})),
						new e(new BaseRenderTexture$1(t))
					);
				}),
				e
			);
		})(Texture$1),
		RenderTexturePool$1 = (function () {
			function t(t) {
				(this.texturePool = {}),
					(this.textureOptions = t || {}),
					(this.enableFullScreen = !1),
					(this._pixelsWidth = 0),
					(this._pixelsHeight = 0);
			}
			return (
				(t.prototype.createTexture = function (t, e, i) {
					void 0 === i && (i = MSAA_QUALITY$3.NONE);
					var r = new BaseRenderTexture$1(
						Object.assign(
							{ width: t, height: e, resolution: 1, multisample: i },
							this.textureOptions
						)
					);
					return new RenderTexture$1(r);
				}),
				(t.prototype.getOptimalTexture = function (t, e, i, r) {
					var s;
					void 0 === i && (i = 1),
						void 0 === r && (r = MSAA_QUALITY$3.NONE),
						(t = Math.ceil(t * i)),
						(e = Math.ceil(e * i)),
						this.enableFullScreen &&
						t === this._pixelsWidth &&
						e === this._pixelsHeight
							? (s = r > 1 ? -r : -1)
							: ((s =
									(((65535 & (t = nextPow2$1(t))) << 16) |
										(65535 & (e = nextPow2$1(e)))) >>>
									0),
							  r > 1 && (s += 4294967296 * r)),
						this.texturePool[s] || (this.texturePool[s] = []);
					var n = this.texturePool[s].pop();
					return (
						n || (n = this.createTexture(t, e, r)),
						(n.filterPoolKey = s),
						n.setResolution(i),
						n
					);
				}),
				(t.prototype.getFilterTexture = function (t, e, i) {
					var r = this.getOptimalTexture(
						t.width,
						t.height,
						e || t.resolution,
						i || MSAA_QUALITY$3.NONE
					);
					return (r.filterFrame = t.filterFrame), r;
				}),
				(t.prototype.returnTexture = function (t) {
					var e = t.filterPoolKey;
					(t.filterFrame = null), this.texturePool[e].push(t);
				}),
				(t.prototype.returnFilterTexture = function (t) {
					this.returnTexture(t);
				}),
				(t.prototype.clear = function (t) {
					if ((t = !1 !== t))
						for (var e in this.texturePool) {
							var i = this.texturePool[e];
							if (i) for (var r = 0; r < i.length; r++) i[r].destroy(!0);
						}
					this.texturePool = {};
				}),
				(t.prototype.setScreenSize = function (t) {
					if (
						t.width !== this._pixelsWidth ||
						t.height !== this._pixelsHeight
					) {
						for (var e in ((this.enableFullScreen =
							t.width > 0 && t.height > 0),
						this.texturePool))
							if (Number(e) < 0) {
								var i = this.texturePool[e];
								if (i) for (var r = 0; r < i.length; r++) i[r].destroy(!0);
								this.texturePool[e] = [];
							}
						(this._pixelsWidth = t.width), (this._pixelsHeight = t.height);
					}
				}),
				(t.SCREEN_KEY = -1),
				t
			);
		})(),
		Attribute$1 = (function () {
			function t(t, e, i, r, s, n, a) {
				void 0 === e && (e = 0),
					void 0 === i && (i = !1),
					void 0 === r && (r = TYPES$3.FLOAT),
					(this.buffer = t),
					(this.size = e),
					(this.normalized = i),
					(this.type = r),
					(this.stride = s),
					(this.start = n),
					(this.instance = a);
			}
			return (
				(t.prototype.destroy = function () {
					this.buffer = null;
				}),
				(t.from = function (e, i, r, s, n) {
					return new t(e, i, r, s, n);
				}),
				t
			);
		})(),
		UID$5 = 0,
		Buffer$1 = (function () {
			function t(t, e, i) {
				void 0 === e && (e = !0),
					void 0 === i && (i = !1),
					(this.data = t || new Float32Array(1)),
					(this._glBuffers = {}),
					(this._updateID = 0),
					(this.index = i),
					(this.static = e),
					(this.id = UID$5++),
					(this.disposeRunner = new Runner$1('disposeBuffer'));
			}
			return (
				(t.prototype.update = function (t) {
					t instanceof Array && (t = new Float32Array(t)),
						(this.data = t || this.data),
						this._updateID++;
				}),
				(t.prototype.dispose = function () {
					this.disposeRunner.emit(this, !1);
				}),
				(t.prototype.destroy = function () {
					this.dispose(), (this.data = null);
				}),
				Object.defineProperty(t.prototype, 'index', {
					get: function () {
						return this.type === BUFFER_TYPE$3.ELEMENT_ARRAY_BUFFER;
					},
					set: function (t) {
						this.type = t
							? BUFFER_TYPE$3.ELEMENT_ARRAY_BUFFER
							: BUFFER_TYPE$3.ARRAY_BUFFER;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.from = function (e) {
					return e instanceof Array && (e = new Float32Array(e)), new t(e);
				}),
				t
			);
		})(),
		map$2 = { Float32Array, Uint32Array, Int32Array, Uint8Array };
	function interleaveTypedArrays$1(t, e) {
		for (var i = 0, r = 0, s = {}, n = 0; n < t.length; n++)
			(r += e[n]), (i += t[n].length);
		var a = new ArrayBuffer(4 * i),
			o = null,
			h = 0;
		for (n = 0; n < t.length; n++) {
			var u = e[n],
				l = t[n],
				c = getBufferType$1(l);
			s[c] || (s[c] = new map$2[c](a)), (o = s[c]);
			for (var d = 0; d < l.length; d++)
				o[((d / u) | 0) * r + h + (d % u)] = l[d];
			h += u;
		}
		return new Float32Array(a);
	}
	var byteSizeMap$2 = { 5126: 4, 5123: 2, 5121: 1 },
		UID$1$1 = 0,
		map$1$1 = {
			Float32Array,
			Uint32Array,
			Int32Array,
			Uint8Array,
			Uint16Array,
		},
		Geometry$1 = (function () {
			function t(t, e) {
				void 0 === t && (t = []),
					void 0 === e && (e = {}),
					(this.buffers = t),
					(this.indexBuffer = null),
					(this.attributes = e),
					(this.glVertexArrayObjects = {}),
					(this.id = UID$1$1++),
					(this.instanced = !1),
					(this.instanceCount = 1),
					(this.disposeRunner = new Runner$1('disposeGeometry')),
					(this.refCount = 0);
			}
			return (
				(t.prototype.addAttribute = function (t, e, i, r, s, n, a, o) {
					if (
						(void 0 === i && (i = 0),
						void 0 === r && (r = !1),
						void 0 === o && (o = !1),
						!e)
					)
						throw new Error(
							'You must pass a buffer when creating an attribute'
						);
					e instanceof Buffer$1 ||
						(e instanceof Array && (e = new Float32Array(e)),
						(e = new Buffer$1(e)));
					var h = t.split('|');
					if (h.length > 1) {
						for (var u = 0; u < h.length; u++)
							this.addAttribute(h[u], e, i, r, s);
						return this;
					}
					var l = this.buffers.indexOf(e);
					return (
						-1 === l && (this.buffers.push(e), (l = this.buffers.length - 1)),
						(this.attributes[t] = new Attribute$1(l, i, r, s, n, a, o)),
						(this.instanced = this.instanced || o),
						this
					);
				}),
				(t.prototype.getAttribute = function (t) {
					return this.attributes[t];
				}),
				(t.prototype.getBuffer = function (t) {
					return this.buffers[this.getAttribute(t).buffer];
				}),
				(t.prototype.addIndex = function (t) {
					return (
						t instanceof Buffer$1 ||
							(t instanceof Array && (t = new Uint16Array(t)),
							(t = new Buffer$1(t))),
						(t.type = BUFFER_TYPE$3.ELEMENT_ARRAY_BUFFER),
						(this.indexBuffer = t),
						-1 === this.buffers.indexOf(t) && this.buffers.push(t),
						this
					);
				}),
				(t.prototype.getIndex = function () {
					return this.indexBuffer;
				}),
				(t.prototype.interleave = function () {
					if (
						1 === this.buffers.length ||
						(2 === this.buffers.length && this.indexBuffer)
					)
						return this;
					var t,
						e = [],
						i = [],
						r = new Buffer$1();
					for (t in this.attributes) {
						var s = this.attributes[t],
							n = this.buffers[s.buffer];
						e.push(n.data),
							i.push((s.size * byteSizeMap$2[s.type]) / 4),
							(s.buffer = 0);
					}
					for (
						r.data = interleaveTypedArrays$1(e, i), t = 0;
						t < this.buffers.length;
						t++
					)
						this.buffers[t] !== this.indexBuffer && this.buffers[t].destroy();
					return (
						(this.buffers = [r]),
						this.indexBuffer && this.buffers.push(this.indexBuffer),
						this
					);
				}),
				(t.prototype.getSize = function () {
					for (var t in this.attributes) {
						var e = this.attributes[t];
						return (
							this.buffers[e.buffer].data.length / (e.stride / 4 || e.size)
						);
					}
					return 0;
				}),
				(t.prototype.dispose = function () {
					this.disposeRunner.emit(this, !1);
				}),
				(t.prototype.destroy = function () {
					this.dispose(),
						(this.buffers = null),
						(this.indexBuffer = null),
						(this.attributes = null);
				}),
				(t.prototype.clone = function () {
					for (var e = new t(), i = 0; i < this.buffers.length; i++)
						e.buffers[i] = new Buffer$1(this.buffers[i].data.slice(0));
					for (var i in this.attributes) {
						var r = this.attributes[i];
						e.attributes[i] = new Attribute$1(
							r.buffer,
							r.size,
							r.normalized,
							r.type,
							r.stride,
							r.start,
							r.instance
						);
					}
					return (
						this.indexBuffer &&
							((e.indexBuffer =
								e.buffers[this.buffers.indexOf(this.indexBuffer)]),
							(e.indexBuffer.type = BUFFER_TYPE$3.ELEMENT_ARRAY_BUFFER)),
						e
					);
				}),
				(t.merge = function (e) {
					for (
						var i, r = new t(), s = [], n = [], a = [], o = 0;
						o < e.length;
						o++
					) {
						i = e[o];
						for (var h = 0; h < i.buffers.length; h++)
							(n[h] = n[h] || 0),
								(n[h] += i.buffers[h].data.length),
								(a[h] = 0);
					}
					for (o = 0; o < i.buffers.length; o++)
						(s[o] = new map$1$1[getBufferType$1(i.buffers[o].data)](n[o])),
							(r.buffers[o] = new Buffer$1(s[o]));
					for (o = 0; o < e.length; o++)
						for (i = e[o], h = 0; h < i.buffers.length; h++)
							s[h].set(i.buffers[h].data, a[h]),
								(a[h] += i.buffers[h].data.length);
					if (((r.attributes = i.attributes), i.indexBuffer)) {
						(r.indexBuffer = r.buffers[i.buffers.indexOf(i.indexBuffer)]),
							(r.indexBuffer.type = BUFFER_TYPE$3.ELEMENT_ARRAY_BUFFER);
						var u = 0,
							l = 0,
							c = 0,
							d = 0;
						for (o = 0; o < i.buffers.length; o++)
							if (i.buffers[o] !== i.indexBuffer) {
								d = o;
								break;
							}
						for (var o in i.attributes) {
							var p = i.attributes[o];
							(0 | p.buffer) === d &&
								(l += (p.size * byteSizeMap$2[p.type]) / 4);
						}
						for (o = 0; o < e.length; o++) {
							var f = e[o].indexBuffer.data;
							for (h = 0; h < f.length; h++) r.indexBuffer.data[h + c] += u;
							(u += e[o].buffers[d].data.length / l), (c += f.length);
						}
					}
					return r;
				}),
				t
			);
		})(),
		Quad$1 = (function (t) {
			function e() {
				var e = t.call(this) || this;
				return (
					e
						.addAttribute(
							'aVertexPosition',
							new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])
						)
						.addIndex([0, 1, 3, 2]),
					e
				);
			}
			return __extends$b(e, t), e;
		})(Geometry$1),
		QuadUv$1 = (function (t) {
			function e() {
				var e = t.call(this) || this;
				return (
					(e.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1])),
					(e.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])),
					(e.vertexBuffer = new Buffer$1(e.vertices)),
					(e.uvBuffer = new Buffer$1(e.uvs)),
					e
						.addAttribute('aVertexPosition', e.vertexBuffer)
						.addAttribute('aTextureCoord', e.uvBuffer)
						.addIndex([0, 1, 2, 0, 2, 3]),
					e
				);
			}
			return (
				__extends$b(e, t),
				(e.prototype.map = function (t, e) {
					var i = 0,
						r = 0;
					return (
						(this.uvs[0] = i),
						(this.uvs[1] = r),
						(this.uvs[2] = i + e.width / t.width),
						(this.uvs[3] = r),
						(this.uvs[4] = i + e.width / t.width),
						(this.uvs[5] = r + e.height / t.height),
						(this.uvs[6] = i),
						(this.uvs[7] = r + e.height / t.height),
						(i = e.x),
						(r = e.y),
						(this.vertices[0] = i),
						(this.vertices[1] = r),
						(this.vertices[2] = i + e.width),
						(this.vertices[3] = r),
						(this.vertices[4] = i + e.width),
						(this.vertices[5] = r + e.height),
						(this.vertices[6] = i),
						(this.vertices[7] = r + e.height),
						this.invalidate(),
						this
					);
				}),
				(e.prototype.invalidate = function () {
					return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;
				}),
				e
			);
		})(Geometry$1),
		UID$2$1 = 0,
		UniformGroup$1 = (function () {
			function t(t, e, i) {
				(this.group = !0),
					(this.syncUniforms = {}),
					(this.dirtyId = 0),
					(this.id = UID$2$1++),
					(this.static = !!e),
					(this.ubo = !!i),
					t instanceof Buffer$1
						? ((this.buffer = t),
						  (this.buffer.type = BUFFER_TYPE$3.UNIFORM_BUFFER),
						  (this.autoManage = !1),
						  (this.ubo = !0))
						: ((this.uniforms = t),
						  this.ubo &&
								((this.buffer = new Buffer$1(new Float32Array(1))),
								(this.buffer.type = BUFFER_TYPE$3.UNIFORM_BUFFER),
								(this.autoManage = !0)));
			}
			return (
				(t.prototype.update = function () {
					this.dirtyId++,
						!this.autoManage && this.buffer && this.buffer.update();
				}),
				(t.prototype.add = function (e, i, r) {
					if (this.ubo)
						throw new Error(
							'[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them'
						);
					this.uniforms[e] = new t(i, r);
				}),
				(t.from = function (e, i, r) {
					return new t(e, i, r);
				}),
				(t.uboFrom = function (e, i) {
					return new t(e, null == i || i, !0);
				}),
				t
			);
		})(),
		FilterState$1 = (function () {
			function t() {
				(this.renderTexture = null),
					(this.target = null),
					(this.legacy = !1),
					(this.resolution = 1),
					(this.multisample = MSAA_QUALITY$3.NONE),
					(this.sourceFrame = new Rectangle$2()),
					(this.destinationFrame = new Rectangle$2()),
					(this.bindingSourceFrame = new Rectangle$2()),
					(this.bindingDestinationFrame = new Rectangle$2()),
					(this.filters = []),
					(this.transform = null);
			}
			return (
				(t.prototype.clear = function () {
					(this.target = null),
						(this.filters = null),
						(this.renderTexture = null);
				}),
				t
			);
		})(),
		tempPoints$1 = [new Point$2(), new Point$2(), new Point$2(), new Point$2()],
		tempMatrix$3 = new Matrix$1(),
		FilterSystem$1 = (function () {
			function t(t) {
				(this.renderer = t),
					(this.defaultFilterStack = [{}]),
					(this.texturePool = new RenderTexturePool$1()),
					this.texturePool.setScreenSize(t.view),
					(this.statePool = []),
					(this.quad = new Quad$1()),
					(this.quadUv = new QuadUv$1()),
					(this.tempRect = new Rectangle$2()),
					(this.activeState = {}),
					(this.globalUniforms = new UniformGroup$1(
						{
							outputFrame: new Rectangle$2(),
							inputSize: new Float32Array(4),
							inputPixel: new Float32Array(4),
							inputClamp: new Float32Array(4),
							resolution: 1,
							filterArea: new Float32Array(4),
							filterClamp: new Float32Array(4),
						},
						!0
					)),
					(this.forceClear = !1),
					(this.useMaxPadding = !1);
			}
			return (
				(t.prototype.push = function (t, e) {
					for (
						var i,
							r,
							s = this.renderer,
							n = this.defaultFilterStack,
							a = this.statePool.pop() || new FilterState$1(),
							o = this.renderer.renderTexture,
							h = e[0].resolution,
							u = e[0].multisample,
							l = e[0].padding,
							c = e[0].autoFit,
							d = null === (i = e[0].legacy) || void 0 === i || i,
							p = 1;
						p < e.length;
						p++
					) {
						var f = e[p];
						(h = Math.min(h, f.resolution)),
							(u = Math.min(u, f.multisample)),
							(l = this.useMaxPadding ? Math.max(l, f.padding) : l + f.padding),
							(c = c && f.autoFit),
							(d = d || null === (r = f.legacy) || void 0 === r || r);
					}
					if (
						(1 === n.length &&
							(this.defaultFilterStack[0].renderTexture = o.current),
						n.push(a),
						(a.resolution = h),
						(a.multisample = u),
						(a.legacy = d),
						(a.target = t),
						a.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)),
						a.sourceFrame.pad(l),
						c)
					) {
						var m = this.tempRect.copyFrom(o.sourceFrame);
						s.projection.transform &&
							this.transformAABB(
								tempMatrix$3.copyFrom(s.projection.transform).invert(),
								m
							),
							a.sourceFrame.fit(m);
					}
					this.roundFrame(
						a.sourceFrame,
						o.current ? o.current.resolution : s.resolution,
						o.sourceFrame,
						o.destinationFrame,
						s.projection.transform
					),
						(a.renderTexture = this.getOptimalFilterTexture(
							a.sourceFrame.width,
							a.sourceFrame.height,
							h,
							u
						)),
						(a.filters = e),
						(a.destinationFrame.width = a.renderTexture.width),
						(a.destinationFrame.height = a.renderTexture.height);
					var _ = this.tempRect;
					(_.x = 0),
						(_.y = 0),
						(_.width = a.sourceFrame.width),
						(_.height = a.sourceFrame.height),
						(a.renderTexture.filterFrame = a.sourceFrame),
						a.bindingSourceFrame.copyFrom(o.sourceFrame),
						a.bindingDestinationFrame.copyFrom(o.destinationFrame),
						(a.transform = s.projection.transform),
						(s.projection.transform = null),
						o.bind(a.renderTexture, a.sourceFrame, _),
						s.framebuffer.clear(0, 0, 0, 0);
				}),
				(t.prototype.pop = function () {
					var t = this.defaultFilterStack,
						e = t.pop(),
						i = e.filters;
					this.activeState = e;
					var r = this.globalUniforms.uniforms;
					(r.outputFrame = e.sourceFrame), (r.resolution = e.resolution);
					var s = r.inputSize,
						n = r.inputPixel,
						a = r.inputClamp;
					if (
						((s[0] = e.destinationFrame.width),
						(s[1] = e.destinationFrame.height),
						(s[2] = 1 / s[0]),
						(s[3] = 1 / s[1]),
						(n[0] = Math.round(s[0] * e.resolution)),
						(n[1] = Math.round(s[1] * e.resolution)),
						(n[2] = 1 / n[0]),
						(n[3] = 1 / n[1]),
						(a[0] = 0.5 * n[2]),
						(a[1] = 0.5 * n[3]),
						(a[2] = e.sourceFrame.width * s[2] - 0.5 * n[2]),
						(a[3] = e.sourceFrame.height * s[3] - 0.5 * n[3]),
						e.legacy)
					) {
						var o = r.filterArea;
						(o[0] = e.destinationFrame.width),
							(o[1] = e.destinationFrame.height),
							(o[2] = e.sourceFrame.x),
							(o[3] = e.sourceFrame.y),
							(r.filterClamp = r.inputClamp);
					}
					this.globalUniforms.update();
					var h = t[t.length - 1];
					if ((this.renderer.framebuffer.blit(), 1 === i.length))
						i[0].apply(
							this,
							e.renderTexture,
							h.renderTexture,
							CLEAR_MODES$3.BLEND,
							e
						),
							this.returnFilterTexture(e.renderTexture);
					else {
						var u = e.renderTexture,
							l = this.getOptimalFilterTexture(u.width, u.height, e.resolution);
						l.filterFrame = u.filterFrame;
						var c = 0;
						for (c = 0; c < i.length - 1; ++c) {
							1 === c &&
								e.multisample > 1 &&
								((l = this.getOptimalFilterTexture(
									u.width,
									u.height,
									e.resolution
								)).filterFrame = u.filterFrame),
								i[c].apply(this, u, l, CLEAR_MODES$3.CLEAR, e);
							var d = u;
							(u = l), (l = d);
						}
						i[c].apply(this, u, h.renderTexture, CLEAR_MODES$3.BLEND, e),
							c > 1 &&
								e.multisample > 1 &&
								this.returnFilterTexture(e.renderTexture),
							this.returnFilterTexture(u),
							this.returnFilterTexture(l);
					}
					e.clear(), this.statePool.push(e);
				}),
				(t.prototype.bindAndClear = function (t, e) {
					void 0 === e && (e = CLEAR_MODES$3.CLEAR);
					var i = this.renderer,
						r = i.renderTexture,
						s = i.state;
					if (
						(t ===
						this.defaultFilterStack[this.defaultFilterStack.length - 1]
							.renderTexture
							? (this.renderer.projection.transform =
									this.activeState.transform)
							: (this.renderer.projection.transform = null),
						t && t.filterFrame)
					) {
						var n = this.tempRect;
						(n.x = 0),
							(n.y = 0),
							(n.width = t.filterFrame.width),
							(n.height = t.filterFrame.height),
							r.bind(t, t.filterFrame, n);
					} else
						t !==
						this.defaultFilterStack[this.defaultFilterStack.length - 1]
							.renderTexture
							? r.bind(t)
							: this.renderer.renderTexture.bind(
									t,
									this.activeState.bindingSourceFrame,
									this.activeState.bindingDestinationFrame
							  );
					var a = 1 & s.stateId || this.forceClear;
					(e === CLEAR_MODES$3.CLEAR || (e === CLEAR_MODES$3.BLIT && a)) &&
						this.renderer.framebuffer.clear(0, 0, 0, 0);
				}),
				(t.prototype.applyFilter = function (t, e, i, r) {
					var s = this.renderer;
					s.state.set(t.state),
						this.bindAndClear(i, r),
						(t.uniforms.uSampler = e),
						(t.uniforms.filterGlobals = this.globalUniforms),
						s.shader.bind(t),
						(t.legacy = !!t.program.attributeData.aTextureCoord),
						t.legacy
							? (this.quadUv.map(e._frame, e.filterFrame),
							  s.geometry.bind(this.quadUv),
							  s.geometry.draw(DRAW_MODES$3.TRIANGLES))
							: (s.geometry.bind(this.quad),
							  s.geometry.draw(DRAW_MODES$3.TRIANGLE_STRIP));
				}),
				(t.prototype.calculateSpriteMatrix = function (t, e) {
					var i = this.activeState,
						r = i.sourceFrame,
						s = i.destinationFrame,
						n = e._texture.orig,
						a = t.set(s.width, 0, 0, s.height, r.x, r.y),
						o = e.worldTransform.copyTo(Matrix$1.TEMP_MATRIX);
					return (
						o.invert(),
						a.prepend(o),
						a.scale(1 / n.width, 1 / n.height),
						a.translate(e.anchor.x, e.anchor.y),
						a
					);
				}),
				(t.prototype.destroy = function () {
					(this.renderer = null), this.texturePool.clear(!1);
				}),
				(t.prototype.getOptimalFilterTexture = function (t, e, i, r) {
					return (
						void 0 === i && (i = 1),
						void 0 === r && (r = MSAA_QUALITY$3.NONE),
						this.texturePool.getOptimalTexture(t, e, i, r)
					);
				}),
				(t.prototype.getFilterTexture = function (t, e, i) {
					if ('number' == typeof t) {
						var r = t;
						(t = e), (e = r);
					}
					t = t || this.activeState.renderTexture;
					var s = this.texturePool.getOptimalTexture(
						t.width,
						t.height,
						e || t.resolution,
						i || MSAA_QUALITY$3.NONE
					);
					return (s.filterFrame = t.filterFrame), s;
				}),
				(t.prototype.returnFilterTexture = function (t) {
					this.texturePool.returnTexture(t);
				}),
				(t.prototype.emptyPool = function () {
					this.texturePool.clear(!0);
				}),
				(t.prototype.resize = function () {
					this.texturePool.setScreenSize(this.renderer.view);
				}),
				(t.prototype.transformAABB = function (t, e) {
					var i = tempPoints$1[0],
						r = tempPoints$1[1],
						s = tempPoints$1[2],
						n = tempPoints$1[3];
					i.set(e.left, e.top),
						r.set(e.left, e.bottom),
						s.set(e.right, e.top),
						n.set(e.right, e.bottom),
						t.apply(i, i),
						t.apply(r, r),
						t.apply(s, s),
						t.apply(n, n);
					var a = Math.min(i.x, r.x, s.x, n.x),
						o = Math.min(i.y, r.y, s.y, n.y),
						h = Math.max(i.x, r.x, s.x, n.x),
						u = Math.max(i.y, r.y, s.y, n.y);
					(e.x = a), (e.y = o), (e.width = h - a), (e.height = u - o);
				}),
				(t.prototype.roundFrame = function (t, e, i, r, s) {
					if (s) {
						var n = s.a,
							a = s.b,
							o = s.c,
							h = s.d;
						if (
							(Math.abs(a) > 1e-4 || Math.abs(o) > 1e-4) &&
							(Math.abs(n) > 1e-4 || Math.abs(h) > 1e-4)
						)
							return;
					}
					(s = s ? tempMatrix$3.copyFrom(s) : tempMatrix$3.identity())
						.translate(-i.x, -i.y)
						.scale(r.width / i.width, r.height / i.height)
						.translate(r.x, r.y),
						this.transformAABB(s, t),
						t.ceil(e),
						this.transformAABB(s.invert(), t);
				}),
				t
			);
		})(),
		ObjectRenderer$1 = (function () {
			function t(t) {
				this.renderer = t;
			}
			return (
				(t.prototype.flush = function () {}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				(t.prototype.start = function () {}),
				(t.prototype.stop = function () {
					this.flush();
				}),
				(t.prototype.render = function (t) {}),
				t
			);
		})(),
		BatchSystem$1 = (function () {
			function t(t) {
				(this.renderer = t),
					(this.emptyRenderer = new ObjectRenderer$1(t)),
					(this.currentRenderer = this.emptyRenderer);
			}
			return (
				(t.prototype.setObjectRenderer = function (t) {
					this.currentRenderer !== t &&
						(this.currentRenderer.stop(),
						(this.currentRenderer = t),
						this.currentRenderer.start());
				}),
				(t.prototype.flush = function () {
					this.setObjectRenderer(this.emptyRenderer);
				}),
				(t.prototype.reset = function () {
					this.setObjectRenderer(this.emptyRenderer);
				}),
				(t.prototype.copyBoundTextures = function (t, e) {
					for (
						var i = this.renderer.texture.boundTextures, r = e - 1;
						r >= 0;
						--r
					)
						(t[r] = i[r] || null), t[r] && (t[r]._batchLocation = r);
				}),
				(t.prototype.boundArray = function (t, e, i, r) {
					for (
						var s = t.elements, n = t.ids, a = t.count, o = 0, h = 0;
						h < a;
						h++
					) {
						var u = s[h],
							l = u._batchLocation;
						if (l >= 0 && l < r && e[l] === u) n[h] = l;
						else
							for (; o < r; ) {
								var c = e[o];
								if (!c || c._batchEnabled !== i || c._batchLocation !== o) {
									(n[h] = o), (u._batchLocation = o), (e[o] = u);
									break;
								}
								o++;
							}
					}
				}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})(),
		CONTEXT_UID_COUNTER$1 = 0,
		ContextSystem$1 = (function () {
			function t(t) {
				(this.renderer = t),
					(this.webGLVersion = 1),
					(this.extensions = {}),
					(this.supports = { uint32Indices: !1 }),
					(this.handleContextLost = this.handleContextLost.bind(this)),
					(this.handleContextRestored = this.handleContextRestored.bind(this)),
					t.view.addEventListener(
						'webglcontextlost',
						this.handleContextLost,
						!1
					),
					t.view.addEventListener(
						'webglcontextrestored',
						this.handleContextRestored,
						!1
					);
			}
			return (
				Object.defineProperty(t.prototype, 'isLost', {
					get: function () {
						return !this.gl || this.gl.isContextLost();
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.contextChange = function (t) {
					(this.gl = t),
						(this.renderer.gl = t),
						(this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER$1++),
						t.isContextLost() &&
							t.getExtension('WEBGL_lose_context') &&
							t.getExtension('WEBGL_lose_context').restoreContext();
				}),
				(t.prototype.initFromContext = function (t) {
					(this.gl = t),
						this.validateContext(t),
						(this.renderer.gl = t),
						(this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER$1++),
						this.renderer.runners.contextChange.emit(t);
				}),
				(t.prototype.initFromOptions = function (t) {
					var e = this.createContext(this.renderer.view, t);
					this.initFromContext(e);
				}),
				(t.prototype.createContext = function (t, e) {
					var i;
					if (
						(settings$2.PREFER_ENV >= ENV$3.WEBGL2 &&
							(i = t.getContext('webgl2', e)),
						i)
					)
						this.webGLVersion = 2;
					else if (
						((this.webGLVersion = 1),
						!(i =
							t.getContext('webgl', e) ||
							t.getContext('experimental-webgl', e)))
					)
						throw new Error(
							'This browser does not support WebGL. Try using the canvas renderer'
						);
					return (this.gl = i), this.getExtensions(), this.gl;
				}),
				(t.prototype.getExtensions = function () {
					var t = this.gl,
						e = {
							anisotropicFiltering: t.getExtension(
								'EXT_texture_filter_anisotropic'
							),
							floatTextureLinear: t.getExtension('OES_texture_float_linear'),
							s3tc: t.getExtension('WEBGL_compressed_texture_s3tc'),
							s3tc_sRGB: t.getExtension('WEBGL_compressed_texture_s3tc_srgb'),
							etc: t.getExtension('WEBGL_compressed_texture_etc'),
							etc1: t.getExtension('WEBGL_compressed_texture_etc1'),
							pvrtc:
								t.getExtension('WEBGL_compressed_texture_pvrtc') ||
								t.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),
							atc: t.getExtension('WEBGL_compressed_texture_atc'),
							astc: t.getExtension('WEBGL_compressed_texture_astc'),
						};
					1 === this.webGLVersion
						? Object.assign(this.extensions, e, {
								drawBuffers: t.getExtension('WEBGL_draw_buffers'),
								depthTexture: t.getExtension('WEBGL_depth_texture'),
								loseContext: t.getExtension('WEBGL_lose_context'),
								vertexArrayObject:
									t.getExtension('OES_vertex_array_object') ||
									t.getExtension('MOZ_OES_vertex_array_object') ||
									t.getExtension('WEBKIT_OES_vertex_array_object'),
								uint32ElementIndex: t.getExtension('OES_element_index_uint'),
								floatTexture: t.getExtension('OES_texture_float'),
								floatTextureLinear: t.getExtension('OES_texture_float_linear'),
								textureHalfFloat: t.getExtension('OES_texture_half_float'),
								textureHalfFloatLinear: t.getExtension(
									'OES_texture_half_float_linear'
								),
						  })
						: 2 === this.webGLVersion &&
						  Object.assign(this.extensions, e, {
								colorBufferFloat: t.getExtension('EXT_color_buffer_float'),
						  });
				}),
				(t.prototype.handleContextLost = function (t) {
					t.preventDefault();
				}),
				(t.prototype.handleContextRestored = function () {
					this.renderer.runners.contextChange.emit(this.gl);
				}),
				(t.prototype.destroy = function () {
					var t = this.renderer.view;
					(this.renderer = null),
						t.removeEventListener('webglcontextlost', this.handleContextLost),
						t.removeEventListener(
							'webglcontextrestored',
							this.handleContextRestored
						),
						this.gl.useProgram(null),
						this.extensions.loseContext &&
							this.extensions.loseContext.loseContext();
				}),
				(t.prototype.postrender = function () {
					this.renderer.renderingToScreen && this.gl.flush();
				}),
				(t.prototype.validateContext = function (t) {
					var e = t.getContextAttributes(),
						i =
							'WebGL2RenderingContext' in self &&
							t instanceof self.WebGL2RenderingContext;
					i && (this.webGLVersion = 2), e.stencil;
					var r = i || !!t.getExtension('OES_element_index_uint');
					this.supports.uint32Indices = r;
				}),
				t
			);
		})(),
		GLFramebuffer$1 = function (t) {
			(this.framebuffer = t),
				(this.stencil = null),
				(this.dirtyId = -1),
				(this.dirtyFormat = -1),
				(this.dirtySize = -1),
				(this.multisample = MSAA_QUALITY$3.NONE),
				(this.msaaBuffer = null),
				(this.blitFramebuffer = null),
				(this.mipLevel = 0);
		},
		tempRectangle$1 = new Rectangle$2(),
		FramebufferSystem$1 = (function () {
			function t(t) {
				(this.renderer = t),
					(this.managedFramebuffers = []),
					(this.unknownFramebuffer = new Framebuffer$1(10, 10)),
					(this.msaaSamples = null);
			}
			return (
				(t.prototype.contextChange = function () {
					var t = (this.gl = this.renderer.gl);
					if (
						((this.CONTEXT_UID = this.renderer.CONTEXT_UID),
						(this.current = this.unknownFramebuffer),
						(this.viewport = new Rectangle$2()),
						(this.hasMRT = !0),
						(this.writeDepthTexture = !0),
						this.disposeAll(!0),
						1 === this.renderer.context.webGLVersion)
					) {
						var e = this.renderer.context.extensions.drawBuffers,
							i = this.renderer.context.extensions.depthTexture;
						settings$2.PREFER_ENV === ENV$3.WEBGL_LEGACY &&
							((e = null), (i = null)),
							e
								? (t.drawBuffers = function (t) {
										return e.drawBuffersWEBGL(t);
								  })
								: ((this.hasMRT = !1), (t.drawBuffers = function () {})),
							i || (this.writeDepthTexture = !1);
					} else
						this.msaaSamples = t.getInternalformatParameter(
							t.RENDERBUFFER,
							t.RGBA8,
							t.SAMPLES
						);
				}),
				(t.prototype.bind = function (t, e, i) {
					void 0 === i && (i = 0);
					var r = this.gl;
					if (t) {
						var s =
							t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t);
						this.current !== t &&
							((this.current = t),
							r.bindFramebuffer(r.FRAMEBUFFER, s.framebuffer)),
							s.mipLevel !== i &&
								(t.dirtyId++, t.dirtyFormat++, (s.mipLevel = i)),
							s.dirtyId !== t.dirtyId &&
								((s.dirtyId = t.dirtyId),
								s.dirtyFormat !== t.dirtyFormat
									? ((s.dirtyFormat = t.dirtyFormat),
									  (s.dirtySize = t.dirtySize),
									  this.updateFramebuffer(t, i))
									: s.dirtySize !== t.dirtySize &&
									  ((s.dirtySize = t.dirtySize), this.resizeFramebuffer(t)));
						for (var n = 0; n < t.colorTextures.length; n++) {
							var a = t.colorTextures[n];
							this.renderer.texture.unbind(a.parentTextureArray || a);
						}
						if (
							(t.depthTexture && this.renderer.texture.unbind(t.depthTexture),
							e)
						) {
							var o = e.width >> i,
								h = e.height >> i,
								u = o / e.width;
							this.setViewport(e.x * u, e.y * u, o, h);
						} else
							(o = t.width >> i),
								(h = t.height >> i),
								this.setViewport(0, 0, o, h);
					} else
						this.current &&
							((this.current = null), r.bindFramebuffer(r.FRAMEBUFFER, null)),
							e
								? this.setViewport(e.x, e.y, e.width, e.height)
								: this.setViewport(
										0,
										0,
										this.renderer.width,
										this.renderer.height
								  );
				}),
				(t.prototype.setViewport = function (t, e, i, r) {
					var s = this.viewport;
					(t = Math.round(t)),
						(e = Math.round(e)),
						(i = Math.round(i)),
						(r = Math.round(r)),
						(s.width === i && s.height === r && s.x === t && s.y === e) ||
							((s.x = t),
							(s.y = e),
							(s.width = i),
							(s.height = r),
							this.gl.viewport(t, e, i, r));
				}),
				Object.defineProperty(t.prototype, 'size', {
					get: function () {
						return this.current
							? {
									x: 0,
									y: 0,
									width: this.current.width,
									height: this.current.height,
							  }
							: {
									x: 0,
									y: 0,
									width: this.renderer.width,
									height: this.renderer.height,
							  };
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.clear = function (t, e, i, r, s) {
					void 0 === s && (s = BUFFER_BITS$3.COLOR | BUFFER_BITS$3.DEPTH);
					var n = this.gl;
					n.clearColor(t, e, i, r), n.clear(s);
				}),
				(t.prototype.initFramebuffer = function (t) {
					var e = this.gl,
						i = new GLFramebuffer$1(e.createFramebuffer());
					return (
						(i.multisample = this.detectSamples(t.multisample)),
						(t.glFramebuffers[this.CONTEXT_UID] = i),
						this.managedFramebuffers.push(t),
						t.disposeRunner.add(this),
						i
					);
				}),
				(t.prototype.resizeFramebuffer = function (t) {
					var e = this.gl,
						i = t.glFramebuffers[this.CONTEXT_UID];
					i.msaaBuffer &&
						(e.bindRenderbuffer(e.RENDERBUFFER, i.msaaBuffer),
						e.renderbufferStorageMultisample(
							e.RENDERBUFFER,
							i.multisample,
							e.RGBA8,
							t.width,
							t.height
						)),
						i.stencil &&
							(e.bindRenderbuffer(e.RENDERBUFFER, i.stencil),
							i.msaaBuffer
								? e.renderbufferStorageMultisample(
										e.RENDERBUFFER,
										i.multisample,
										e.DEPTH24_STENCIL8,
										t.width,
										t.height
								  )
								: e.renderbufferStorage(
										e.RENDERBUFFER,
										e.DEPTH_STENCIL,
										t.width,
										t.height
								  ));
					var r = t.colorTextures,
						s = r.length;
					e.drawBuffers || (s = Math.min(s, 1));
					for (var n = 0; n < s; n++) {
						var a = r[n],
							o = a.parentTextureArray || a;
						this.renderer.texture.bind(o, 0);
					}
					t.depthTexture &&
						this.writeDepthTexture &&
						this.renderer.texture.bind(t.depthTexture, 0);
				}),
				(t.prototype.updateFramebuffer = function (t, e) {
					var i = this.gl,
						r = t.glFramebuffers[this.CONTEXT_UID],
						s = t.colorTextures,
						n = s.length;
					i.drawBuffers || (n = Math.min(n, 1)),
						r.multisample > 1 && this.canMultisampleFramebuffer(t)
							? ((r.msaaBuffer = r.msaaBuffer || i.createRenderbuffer()),
							  i.bindRenderbuffer(i.RENDERBUFFER, r.msaaBuffer),
							  i.renderbufferStorageMultisample(
									i.RENDERBUFFER,
									r.multisample,
									i.RGBA8,
									t.width,
									t.height
							  ),
							  i.framebufferRenderbuffer(
									i.FRAMEBUFFER,
									i.COLOR_ATTACHMENT0,
									i.RENDERBUFFER,
									r.msaaBuffer
							  ))
							: r.msaaBuffer &&
							  (i.deleteRenderbuffer(r.msaaBuffer),
							  (r.msaaBuffer = null),
							  r.blitFramebuffer &&
									(r.blitFramebuffer.dispose(), (r.blitFramebuffer = null)));
					for (var a = [], o = 0; o < n; o++) {
						var h = s[o],
							u = h.parentTextureArray || h;
						this.renderer.texture.bind(u, 0),
							(0 === o && r.msaaBuffer) ||
								(i.framebufferTexture2D(
									i.FRAMEBUFFER,
									i.COLOR_ATTACHMENT0 + o,
									h.target,
									u._glTextures[this.CONTEXT_UID].texture,
									e
								),
								a.push(i.COLOR_ATTACHMENT0 + o));
					}
					if (
						(a.length > 1 && i.drawBuffers(a),
						t.depthTexture && this.writeDepthTexture)
					) {
						var l = t.depthTexture;
						this.renderer.texture.bind(l, 0),
							i.framebufferTexture2D(
								i.FRAMEBUFFER,
								i.DEPTH_ATTACHMENT,
								i.TEXTURE_2D,
								l._glTextures[this.CONTEXT_UID].texture,
								e
							);
					}
					(!t.stencil && !t.depth) || (t.depthTexture && this.writeDepthTexture)
						? r.stencil && (i.deleteRenderbuffer(r.stencil), (r.stencil = null))
						: ((r.stencil = r.stencil || i.createRenderbuffer()),
						  i.bindRenderbuffer(i.RENDERBUFFER, r.stencil),
						  r.msaaBuffer
								? i.renderbufferStorageMultisample(
										i.RENDERBUFFER,
										r.multisample,
										i.DEPTH24_STENCIL8,
										t.width,
										t.height
								  )
								: i.renderbufferStorage(
										i.RENDERBUFFER,
										i.DEPTH_STENCIL,
										t.width,
										t.height
								  ),
						  i.framebufferRenderbuffer(
								i.FRAMEBUFFER,
								i.DEPTH_STENCIL_ATTACHMENT,
								i.RENDERBUFFER,
								r.stencil
						  ));
				}),
				(t.prototype.canMultisampleFramebuffer = function (t) {
					return (
						1 !== this.renderer.context.webGLVersion &&
						t.colorTextures.length <= 1 &&
						!t.depthTexture
					);
				}),
				(t.prototype.detectSamples = function (t) {
					var e = this.msaaSamples,
						i = MSAA_QUALITY$3.NONE;
					if (t <= 1 || null === e) return i;
					for (var r = 0; r < e.length; r++)
						if (e[r] <= t) {
							i = e[r];
							break;
						}
					return 1 === i && (i = MSAA_QUALITY$3.NONE), i;
				}),
				(t.prototype.blit = function (t, e, i) {
					var r = this,
						s = r.current,
						n = r.renderer,
						a = r.gl,
						o = r.CONTEXT_UID;
					if (2 === n.context.webGLVersion && s) {
						var h = s.glFramebuffers[o];
						if (h) {
							if (!t) {
								if (!h.msaaBuffer) return;
								var u = s.colorTextures[0];
								if (!u) return;
								h.blitFramebuffer ||
									((h.blitFramebuffer = new Framebuffer$1(s.width, s.height)),
									h.blitFramebuffer.addColorTexture(0, u)),
									(t = h.blitFramebuffer).colorTextures[0] !== u &&
										((t.colorTextures[0] = u), t.dirtyId++, t.dirtyFormat++),
									(t.width === s.width && t.height === s.height) ||
										((t.width = s.width),
										(t.height = s.height),
										t.dirtyId++,
										t.dirtySize++);
							}
							e ||
								(((e = tempRectangle$1).width = s.width),
								(e.height = s.height)),
								i || (i = e);
							var l = e.width === i.width && e.height === i.height;
							this.bind(t),
								a.bindFramebuffer(a.READ_FRAMEBUFFER, h.framebuffer),
								a.blitFramebuffer(
									e.x,
									e.y,
									e.width,
									e.height,
									i.x,
									i.y,
									i.width,
									i.height,
									a.COLOR_BUFFER_BIT,
									l ? a.NEAREST : a.LINEAR
								);
						}
					}
				}),
				(t.prototype.disposeFramebuffer = function (t, e) {
					var i = t.glFramebuffers[this.CONTEXT_UID],
						r = this.gl;
					if (i) {
						delete t.glFramebuffers[this.CONTEXT_UID];
						var s = this.managedFramebuffers.indexOf(t);
						s >= 0 && this.managedFramebuffers.splice(s, 1),
							t.disposeRunner.remove(this),
							e ||
								(r.deleteFramebuffer(i.framebuffer),
								i.msaaBuffer && r.deleteRenderbuffer(i.msaaBuffer),
								i.stencil && r.deleteRenderbuffer(i.stencil)),
							i.blitFramebuffer && i.blitFramebuffer.dispose();
					}
				}),
				(t.prototype.disposeAll = function (t) {
					var e = this.managedFramebuffers;
					this.managedFramebuffers = [];
					for (var i = 0; i < e.length; i++) this.disposeFramebuffer(e[i], t);
				}),
				(t.prototype.forceStencil = function () {
					var t = this.current;
					if (t) {
						var e = t.glFramebuffers[this.CONTEXT_UID];
						if (e && !e.stencil) {
							t.stencil = !0;
							var i = t.width,
								r = t.height,
								s = this.gl,
								n = s.createRenderbuffer();
							s.bindRenderbuffer(s.RENDERBUFFER, n),
								e.msaaBuffer
									? s.renderbufferStorageMultisample(
											s.RENDERBUFFER,
											e.multisample,
											s.DEPTH24_STENCIL8,
											i,
											r
									  )
									: s.renderbufferStorage(
											s.RENDERBUFFER,
											s.DEPTH_STENCIL,
											i,
											r
									  ),
								(e.stencil = n),
								s.framebufferRenderbuffer(
									s.FRAMEBUFFER,
									s.DEPTH_STENCIL_ATTACHMENT,
									s.RENDERBUFFER,
									n
								);
						}
					}
				}),
				(t.prototype.reset = function () {
					(this.current = this.unknownFramebuffer),
						(this.viewport = new Rectangle$2());
				}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})(),
		byteSizeMap$1$1 = { 5126: 4, 5123: 2, 5121: 1 },
		GeometrySystem$1 = (function () {
			function t(t) {
				(this.renderer = t),
					(this._activeGeometry = null),
					(this._activeVao = null),
					(this.hasVao = !0),
					(this.hasInstance = !0),
					(this.canUseUInt32ElementIndex = !1),
					(this.managedGeometries = {});
			}
			return (
				(t.prototype.contextChange = function () {
					this.disposeAll(!0);
					var t = (this.gl = this.renderer.gl),
						e = this.renderer.context;
					if (
						((this.CONTEXT_UID = this.renderer.CONTEXT_UID),
						2 !== e.webGLVersion)
					) {
						var i = this.renderer.context.extensions.vertexArrayObject;
						settings$2.PREFER_ENV === ENV$3.WEBGL_LEGACY && (i = null),
							i
								? ((t.createVertexArray = function () {
										return i.createVertexArrayOES();
								  }),
								  (t.bindVertexArray = function (t) {
										return i.bindVertexArrayOES(t);
								  }),
								  (t.deleteVertexArray = function (t) {
										return i.deleteVertexArrayOES(t);
								  }))
								: ((this.hasVao = !1),
								  (t.createVertexArray = function () {
										return null;
								  }),
								  (t.bindVertexArray = function () {
										return null;
								  }),
								  (t.deleteVertexArray = function () {
										return null;
								  }));
					}
					if (2 !== e.webGLVersion) {
						var r = t.getExtension('ANGLE_instanced_arrays');
						r
							? ((t.vertexAttribDivisor = function (t, e) {
									return r.vertexAttribDivisorANGLE(t, e);
							  }),
							  (t.drawElementsInstanced = function (t, e, i, s, n) {
									return r.drawElementsInstancedANGLE(t, e, i, s, n);
							  }),
							  (t.drawArraysInstanced = function (t, e, i, s) {
									return r.drawArraysInstancedANGLE(t, e, i, s);
							  }))
							: (this.hasInstance = !1);
					}
					this.canUseUInt32ElementIndex =
						2 === e.webGLVersion || !!e.extensions.uint32ElementIndex;
				}),
				(t.prototype.bind = function (t, e) {
					e = e || this.renderer.shader.shader;
					var i = this.gl,
						r = t.glVertexArrayObjects[this.CONTEXT_UID],
						s = !1;
					r ||
						((this.managedGeometries[t.id] = t),
						t.disposeRunner.add(this),
						(t.glVertexArrayObjects[this.CONTEXT_UID] = r = {}),
						(s = !0));
					var n = r[e.program.id] || this.initGeometryVao(t, e, s);
					(this._activeGeometry = t),
						this._activeVao !== n &&
							((this._activeVao = n),
							this.hasVao
								? i.bindVertexArray(n)
								: this.activateVao(t, e.program)),
						this.updateBuffers();
				}),
				(t.prototype.reset = function () {
					this.unbind();
				}),
				(t.prototype.updateBuffers = function () {
					for (
						var t = this._activeGeometry, e = this.renderer.buffer, i = 0;
						i < t.buffers.length;
						i++
					) {
						var r = t.buffers[i];
						e.update(r);
					}
				}),
				(t.prototype.checkCompatibility = function (t, e) {
					var i = t.attributes,
						r = e.attributeData;
					for (var s in r)
						if (!i[s])
							throw new Error(
								'shader and geometry incompatible, geometry missing the "' +
									s +
									'" attribute'
							);
				}),
				(t.prototype.getSignature = function (t, e) {
					var i = t.attributes,
						r = e.attributeData,
						s = ['g', t.id];
					for (var n in i) r[n] && s.push(n, r[n].location);
					return s.join('-');
				}),
				(t.prototype.initGeometryVao = function (t, e, i) {
					void 0 === i && (i = !0);
					var r = this.gl,
						s = this.CONTEXT_UID,
						n = this.renderer.buffer,
						a = e.program;
					a.glPrograms[s] || this.renderer.shader.generateProgram(e),
						this.checkCompatibility(t, a);
					var o = this.getSignature(t, a),
						h = t.glVertexArrayObjects[this.CONTEXT_UID],
						u = h[o];
					if (u) return (h[a.id] = u), u;
					var l = t.buffers,
						c = t.attributes,
						d = {},
						p = {};
					for (var f in l) (d[f] = 0), (p[f] = 0);
					for (var f in c)
						!c[f].size && a.attributeData[f]
							? (c[f].size = a.attributeData[f].size)
							: c[f].size,
							(d[c[f].buffer] += c[f].size * byteSizeMap$1$1[c[f].type]);
					for (var f in c) {
						var m = c[f],
							_ = m.size;
						void 0 === m.stride &&
							(d[m.buffer] === _ * byteSizeMap$1$1[m.type]
								? (m.stride = 0)
								: (m.stride = d[m.buffer])),
							void 0 === m.start &&
								((m.start = p[m.buffer]),
								(p[m.buffer] += _ * byteSizeMap$1$1[m.type]));
					}
					(u = r.createVertexArray()), r.bindVertexArray(u);
					for (var g = 0; g < l.length; g++) {
						var E = l[g];
						n.bind(E), i && E._glBuffers[s].refCount++;
					}
					return (
						this.activateVao(t, a),
						(this._activeVao = u),
						(h[a.id] = u),
						(h[o] = u),
						u
					);
				}),
				(t.prototype.disposeGeometry = function (t, e) {
					var i;
					if (this.managedGeometries[t.id]) {
						delete this.managedGeometries[t.id];
						var r = t.glVertexArrayObjects[this.CONTEXT_UID],
							s = this.gl,
							n = t.buffers,
							a =
								null === (i = this.renderer) || void 0 === i
									? void 0
									: i.buffer;
						if ((t.disposeRunner.remove(this), r)) {
							if (a)
								for (var o = 0; o < n.length; o++) {
									var h = n[o]._glBuffers[this.CONTEXT_UID];
									h &&
										(h.refCount--, 0 !== h.refCount || e || a.dispose(n[o], e));
								}
							if (!e)
								for (var u in r)
									if ('g' === u[0]) {
										var l = r[u];
										this._activeVao === l && this.unbind(),
											s.deleteVertexArray(l);
									}
							delete t.glVertexArrayObjects[this.CONTEXT_UID];
						}
					}
				}),
				(t.prototype.disposeAll = function (t) {
					for (
						var e = Object.keys(this.managedGeometries), i = 0;
						i < e.length;
						i++
					)
						this.disposeGeometry(this.managedGeometries[e[i]], t);
				}),
				(t.prototype.activateVao = function (t, e) {
					var i = this.gl,
						r = this.CONTEXT_UID,
						s = this.renderer.buffer,
						n = t.buffers,
						a = t.attributes;
					t.indexBuffer && s.bind(t.indexBuffer);
					var o = null;
					for (var h in a) {
						var u = a[h],
							l = n[u.buffer],
							c = l._glBuffers[r];
						if (e.attributeData[h]) {
							o !== c && (s.bind(l), (o = c));
							var d = e.attributeData[h].location;
							if (
								(i.enableVertexAttribArray(d),
								i.vertexAttribPointer(
									d,
									u.size,
									u.type || i.FLOAT,
									u.normalized,
									u.stride,
									u.start
								),
								u.instance)
							) {
								if (!this.hasInstance)
									throw new Error(
										'geometry error, GPU Instancing is not supported on this device'
									);
								i.vertexAttribDivisor(d, 1);
							}
						}
					}
				}),
				(t.prototype.draw = function (t, e, i, r) {
					var s = this.gl,
						n = this._activeGeometry;
					if (n.indexBuffer) {
						var a = n.indexBuffer.data.BYTES_PER_ELEMENT,
							o = 2 === a ? s.UNSIGNED_SHORT : s.UNSIGNED_INT;
						(2 === a || (4 === a && this.canUseUInt32ElementIndex)) &&
							(n.instanced
								? s.drawElementsInstanced(
										t,
										e || n.indexBuffer.data.length,
										o,
										(i || 0) * a,
										r || 1
								  )
								: s.drawElements(
										t,
										e || n.indexBuffer.data.length,
										o,
										(i || 0) * a
								  ));
					} else
						n.instanced
							? s.drawArraysInstanced(t, i, e || n.getSize(), r || 1)
							: s.drawArrays(t, i, e || n.getSize());
					return this;
				}),
				(t.prototype.unbind = function () {
					this.gl.bindVertexArray(null),
						(this._activeVao = null),
						(this._activeGeometry = null);
				}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})(),
		MaskData$1 = (function () {
			function t(t) {
				void 0 === t && (t = null),
					(this.type = MASK_TYPES$3.NONE),
					(this.autoDetect = !0),
					(this.maskObject = t || null),
					(this.pooled = !1),
					(this.isMaskData = !0),
					(this.resolution = null),
					(this.multisample = settings$2.FILTER_MULTISAMPLE),
					(this.enabled = !0),
					(this._filters = null),
					(this._stencilCounter = 0),
					(this._scissorCounter = 0),
					(this._scissorRect = null),
					(this._scissorRectLocal = null),
					(this._target = null);
			}
			return (
				Object.defineProperty(t.prototype, 'filter', {
					get: function () {
						return this._filters ? this._filters[0] : null;
					},
					set: function (t) {
						t
							? this._filters
								? (this._filters[0] = t)
								: (this._filters = [t])
							: (this._filters = null);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.reset = function () {
					this.pooled &&
						((this.maskObject = null),
						(this.type = MASK_TYPES$3.NONE),
						(this.autoDetect = !0)),
						(this._target = null),
						(this._scissorRectLocal = null);
				}),
				(t.prototype.copyCountersOrReset = function (t) {
					t
						? ((this._stencilCounter = t._stencilCounter),
						  (this._scissorCounter = t._scissorCounter),
						  (this._scissorRect = t._scissorRect))
						: ((this._stencilCounter = 0),
						  (this._scissorCounter = 0),
						  (this._scissorRect = null));
				}),
				t
			);
		})();
	function compileShader$1(t, e, i) {
		var r = t.createShader(e);
		return t.shaderSource(r, i), t.compileShader(r), r;
	}
	function logPrettyShaderError$1(t, e) {
		var i = t
				.getShaderSource(e)
				.split('\n')
				.map(function (t, e) {
					return e + ': ' + t;
				}),
			r = t.getShaderInfoLog(e).split('\n'),
			s = {},
			n = r
				.map(function (t) {
					return parseFloat(t.replace(/^ERROR\: 0\:([\d]+)\:.*$/, '$1'));
				})
				.filter(function (t) {
					return !(!t || s[t] || ((s[t] = !0), 0));
				}),
			a = [''];
		n.forEach(function (t) {
			(i[t - 1] = '%c' + i[t - 1] + '%c'),
				a.push(
					'background: #FF0000; color:#FFFFFF; font-size: 10px',
					'font-size: 10px'
				);
		});
		var o = i.join('\n');
		a[0] = o;
	}
	function logProgramError$1(t, e, i, r) {
		t.getProgramParameter(e, t.LINK_STATUS) ||
			(t.getShaderParameter(i, t.COMPILE_STATUS) ||
				logPrettyShaderError$1(t, i),
			t.getShaderParameter(r, t.COMPILE_STATUS) || logPrettyShaderError$1(t, r),
			t.getProgramInfoLog(e));
	}
	function booleanArray$1(t) {
		for (var e = new Array(t), i = 0; i < e.length; i++) e[i] = !1;
		return e;
	}
	function defaultValue$1(t, e) {
		switch (t) {
			case 'float':
			case 'int':
			case 'uint':
			case 'sampler2D':
			case 'sampler2DArray':
				return 0;
			case 'vec2':
				return new Float32Array(2 * e);
			case 'vec3':
				return new Float32Array(3 * e);
			case 'vec4':
				return new Float32Array(4 * e);
			case 'ivec2':
				return new Int32Array(2 * e);
			case 'ivec3':
				return new Int32Array(3 * e);
			case 'ivec4':
				return new Int32Array(4 * e);
			case 'uvec2':
				return new Uint32Array(2 * e);
			case 'uvec3':
				return new Uint32Array(3 * e);
			case 'uvec4':
				return new Uint32Array(4 * e);
			case 'bool':
				return !1;
			case 'bvec2':
				return booleanArray$1(2 * e);
			case 'bvec3':
				return booleanArray$1(3 * e);
			case 'bvec4':
				return booleanArray$1(4 * e);
			case 'mat2':
				return new Float32Array([1, 0, 0, 1]);
			case 'mat3':
				return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
			case 'mat4':
				return new Float32Array([
					1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
				]);
		}
		return null;
	}
	var unknownContext$1 = {},
		context$1 = unknownContext$1,
		maxFragmentPrecision$1;
	function getTestContext$1() {
		if (
			context$1 === unknownContext$1 ||
			(context$1 && context$1.isContextLost())
		) {
			var t = document.createElement('canvas'),
				e = void 0;
			settings$2.PREFER_ENV >= ENV$3.WEBGL2 && (e = t.getContext('webgl2', {})),
				e ||
					((e =
						t.getContext('webgl', {}) || t.getContext('experimental-webgl', {}))
						? e.getExtension('WEBGL_draw_buffers')
						: (e = null)),
				(context$1 = e);
		}
		return context$1;
	}
	function getMaxFragmentPrecision$1() {
		if (!maxFragmentPrecision$1) {
			maxFragmentPrecision$1 = PRECISION$3.MEDIUM;
			var t = getTestContext$1();
			if (t && t.getShaderPrecisionFormat) {
				var e = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT);
				maxFragmentPrecision$1 = e.precision
					? PRECISION$3.HIGH
					: PRECISION$3.MEDIUM;
			}
		}
		return maxFragmentPrecision$1;
	}
	function setPrecision$1(t, e, i) {
		if ('precision' !== t.substring(0, 9)) {
			var r = e;
			return (
				e === PRECISION$3.HIGH &&
					i !== PRECISION$3.HIGH &&
					(r = PRECISION$3.MEDIUM),
				'precision ' + r + ' float;\n' + t
			);
		}
		return i !== PRECISION$3.HIGH && 'precision highp' === t.substring(0, 15)
			? t.replace('precision highp', 'precision mediump')
			: t;
	}
	var GLSL_TO_SIZE$1 = {
		float: 1,
		vec2: 2,
		vec3: 3,
		vec4: 4,
		int: 1,
		ivec2: 2,
		ivec3: 3,
		ivec4: 4,
		uint: 1,
		uvec2: 2,
		uvec3: 3,
		uvec4: 4,
		bool: 1,
		bvec2: 2,
		bvec3: 3,
		bvec4: 4,
		mat2: 4,
		mat3: 9,
		mat4: 16,
		sampler2D: 1,
	};
	function mapSize$1(t) {
		return GLSL_TO_SIZE$1[t];
	}
	var GL_TABLE$1 = null,
		GL_TO_GLSL_TYPES$1 = {
			FLOAT: 'float',
			FLOAT_VEC2: 'vec2',
			FLOAT_VEC3: 'vec3',
			FLOAT_VEC4: 'vec4',
			INT: 'int',
			INT_VEC2: 'ivec2',
			INT_VEC3: 'ivec3',
			INT_VEC4: 'ivec4',
			UNSIGNED_INT: 'uint',
			UNSIGNED_INT_VEC2: 'uvec2',
			UNSIGNED_INT_VEC3: 'uvec3',
			UNSIGNED_INT_VEC4: 'uvec4',
			BOOL: 'bool',
			BOOL_VEC2: 'bvec2',
			BOOL_VEC3: 'bvec3',
			BOOL_VEC4: 'bvec4',
			FLOAT_MAT2: 'mat2',
			FLOAT_MAT3: 'mat3',
			FLOAT_MAT4: 'mat4',
			SAMPLER_2D: 'sampler2D',
			INT_SAMPLER_2D: 'sampler2D',
			UNSIGNED_INT_SAMPLER_2D: 'sampler2D',
			SAMPLER_CUBE: 'samplerCube',
			INT_SAMPLER_CUBE: 'samplerCube',
			UNSIGNED_INT_SAMPLER_CUBE: 'samplerCube',
			SAMPLER_2D_ARRAY: 'sampler2DArray',
			INT_SAMPLER_2D_ARRAY: 'sampler2DArray',
			UNSIGNED_INT_SAMPLER_2D_ARRAY: 'sampler2DArray',
		};
	function mapType$1(t, e) {
		if (!GL_TABLE$1) {
			var i = Object.keys(GL_TO_GLSL_TYPES$1);
			GL_TABLE$1 = {};
			for (var r = 0; r < i.length; ++r) {
				var s = i[r];
				GL_TABLE$1[t[s]] = GL_TO_GLSL_TYPES$1[s];
			}
		}
		return GL_TABLE$1[e];
	}
	var uniformParsers$1 = [
			{
				test: function (t) {
					return 'float' === t.type && 1 === t.size;
				},
				code: function (t) {
					return (
						'\n            if(uv["' +
						t +
						'"] !== ud["' +
						t +
						'"].value)\n            {\n                ud["' +
						t +
						'"].value = uv["' +
						t +
						'"]\n                gl.uniform1f(ud["' +
						t +
						'"].location, uv["' +
						t +
						'"])\n            }\n            '
					);
				},
			},
			{
				test: function (t) {
					return (
						('sampler2D' === t.type ||
							'samplerCube' === t.type ||
							'sampler2DArray' === t.type) &&
						1 === t.size &&
						!t.isArray
					);
				},
				code: function (t) {
					return (
						't = syncData.textureCount++;\n\n            renderer.texture.bind(uv["' +
						t +
						'"], t);\n\n            if(ud["' +
						t +
						'"].value !== t)\n            {\n                ud["' +
						t +
						'"].value = t;\n                gl.uniform1i(ud["' +
						t +
						'"].location, t);\n; // eslint-disable-line max-len\n            }'
					);
				},
			},
			{
				test: function (t, e) {
					return 'mat3' === t.type && 1 === t.size && void 0 !== e.a;
				},
				code: function (t) {
					return (
						'\n            gl.uniformMatrix3fv(ud["' +
						t +
						'"].location, false, uv["' +
						t +
						'"].toArray(true));\n            '
					);
				},
				codeUbo: function (t) {
					return (
						'\n                var ' +
						t +
						'_matrix = uv.' +
						t +
						'.toArray(true);\n\n                data[offset] = ' +
						t +
						'_matrix[0];\n                data[offset+1] = ' +
						t +
						'_matrix[1];\n                data[offset+2] = ' +
						t +
						'_matrix[2];\n        \n                data[offset + 4] = ' +
						t +
						'_matrix[3];\n                data[offset + 5] = ' +
						t +
						'_matrix[4];\n                data[offset + 6] = ' +
						t +
						'_matrix[5];\n        \n                data[offset + 8] = ' +
						t +
						'_matrix[6];\n                data[offset + 9] = ' +
						t +
						'_matrix[7];\n                data[offset + 10] = ' +
						t +
						'_matrix[8];\n            '
					);
				},
			},
			{
				test: function (t, e) {
					return 'vec2' === t.type && 1 === t.size && void 0 !== e.x;
				},
				code: function (t) {
					return (
						'\n                cv = ud["' +
						t +
						'"].value;\n                v = uv["' +
						t +
						'"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["' +
						t +
						'"].location, v.x, v.y);\n                }'
					);
				},
				codeUbo: function (t) {
					return (
						'\n                v = uv.' +
						t +
						';\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            '
					);
				},
			},
			{
				test: function (t) {
					return 'vec2' === t.type && 1 === t.size;
				},
				code: function (t) {
					return (
						'\n                cv = ud["' +
						t +
						'"].value;\n                v = uv["' +
						t +
						'"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["' +
						t +
						'"].location, v[0], v[1]);\n                }\n            '
					);
				},
			},
			{
				test: function (t, e) {
					return 'vec4' === t.type && 1 === t.size && void 0 !== e.width;
				},
				code: function (t) {
					return (
						'\n                cv = ud["' +
						t +
						'"].value;\n                v = uv["' +
						t +
						'"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["' +
						t +
						'"].location, v.x, v.y, v.width, v.height)\n                }'
					);
				},
				codeUbo: function (t) {
					return (
						'\n                    v = uv.' +
						t +
						';\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                '
					);
				},
			},
			{
				test: function (t) {
					return 'vec4' === t.type && 1 === t.size;
				},
				code: function (t) {
					return (
						'\n                cv = ud["' +
						t +
						'"].value;\n                v = uv["' +
						t +
						'"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["' +
						t +
						'"].location, v[0], v[1], v[2], v[3])\n                }'
					);
				},
			},
		],
		GLSL_TO_SINGLE_SETTERS_CACHED$1 = {
			float:
				'\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }',
			vec2: '\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }',
			vec3: '\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }',
			vec4: '\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }',
			int: '\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }',
			ivec2:
				'\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }',
			ivec3:
				'\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }',
			ivec4:
				'\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }',
			uint: '\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }',
			uvec2:
				'\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }',
			uvec3:
				'\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }',
			uvec4:
				'\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }',
			bool: '\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }',
			bvec2:
				'\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }',
			bvec3:
				'\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }',
			bvec4:
				'\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }',
			mat2: 'gl.uniformMatrix2fv(location, false, v)',
			mat3: 'gl.uniformMatrix3fv(location, false, v)',
			mat4: 'gl.uniformMatrix4fv(location, false, v)',
			sampler2D: 'gl.uniform1i(location, v)',
			samplerCube: 'gl.uniform1i(location, v)',
			sampler2DArray: 'gl.uniform1i(location, v)',
		},
		GLSL_TO_ARRAY_SETTERS$1 = {
			float: 'gl.uniform1fv(location, v)',
			vec2: 'gl.uniform2fv(location, v)',
			vec3: 'gl.uniform3fv(location, v)',
			vec4: 'gl.uniform4fv(location, v)',
			mat4: 'gl.uniformMatrix4fv(location, false, v)',
			mat3: 'gl.uniformMatrix3fv(location, false, v)',
			mat2: 'gl.uniformMatrix2fv(location, false, v)',
			int: 'gl.uniform1iv(location, v)',
			ivec2: 'gl.uniform2iv(location, v)',
			ivec3: 'gl.uniform3iv(location, v)',
			ivec4: 'gl.uniform4iv(location, v)',
			uint: 'gl.uniform1uiv(location, v)',
			uvec2: 'gl.uniform2uiv(location, v)',
			uvec3: 'gl.uniform3uiv(location, v)',
			uvec4: 'gl.uniform4uiv(location, v)',
			bool: 'gl.uniform1iv(location, v)',
			bvec2: 'gl.uniform2iv(location, v)',
			bvec3: 'gl.uniform3iv(location, v)',
			bvec4: 'gl.uniform4iv(location, v)',
			sampler2D: 'gl.uniform1iv(location, v)',
			samplerCube: 'gl.uniform1iv(location, v)',
			sampler2DArray: 'gl.uniform1iv(location, v)',
		};
	function generateUniformsSync$1(t, e) {
		var i,
			r = [
				'\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    ',
			];
		for (var s in t.uniforms) {
			var n = e[s];
			if (n) {
				for (
					var a = t.uniforms[s], o = !1, h = 0;
					h < uniformParsers$1.length;
					h++
				)
					if (uniformParsers$1[h].test(n, a)) {
						r.push(uniformParsers$1[h].code(s, a)), (o = !0);
						break;
					}
				if (!o) {
					var u = (
						1 === n.size
							? GLSL_TO_SINGLE_SETTERS_CACHED$1
							: GLSL_TO_ARRAY_SETTERS$1
					)[n.type].replace('location', 'ud["' + s + '"].location');
					r.push(
						'\n            cu = ud["' +
							s +
							'"];\n            cv = cu.value;\n            v = uv["' +
							s +
							'"];\n            ' +
							u +
							';'
					);
				}
			} else
				(null === (i = t.uniforms[s]) || void 0 === i ? void 0 : i.group) &&
					(t.uniforms[s].ubo
						? r.push(
								'\n                        renderer.shader.syncUniformBufferGroup(uv.' +
									s +
									", '" +
									s +
									"');\n                    "
						  )
						: r.push(
								'\n                        renderer.shader.syncUniformGroup(uv.' +
									s +
									', syncData);\n                    '
						  ));
		}
		return new Function('ud', 'uv', 'renderer', 'syncData', r.join('\n'));
	}
	var fragTemplate$1 = [
			'precision mediump float;',
			'void main(void){',
			'float test = 0.1;',
			'%forloop%',
			'gl_FragColor = vec4(0.0);',
			'}',
		].join('\n'),
		unsafeEval$1;
	function generateIfTestSrc$1(t) {
		for (var e = '', i = 0; i < t; ++i)
			i > 0 && (e += '\nelse '),
				i < t - 1 && (e += 'if(test == ' + i + '.0){}');
		return e;
	}
	function checkMaxIfStatementsInShader$1(t, e) {
		if (0 === t)
			throw new Error(
				'Invalid value of `0` passed to `checkMaxIfStatementsInShader`'
			);
		for (var i = e.createShader(e.FRAGMENT_SHADER); ; ) {
			var r = fragTemplate$1.replace(/%forloop%/gi, generateIfTestSrc$1(t));
			if (
				(e.shaderSource(i, r),
				e.compileShader(i),
				e.getShaderParameter(i, e.COMPILE_STATUS))
			)
				break;
			t = (t / 2) | 0;
		}
		return t;
	}
	function unsafeEvalSupported$1() {
		if ('boolean' == typeof unsafeEval$1) return unsafeEval$1;
		try {
			var t = new Function(
				'param1',
				'param2',
				'param3',
				'return param1[param2] === param3;'
			);
			unsafeEval$1 = !0 === t({ a: 'b' }, 'a', 'b');
		} catch (t) {
			unsafeEval$1 = !1;
		}
		return unsafeEval$1;
	}
	var defaultFragment$3 =
			'varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}',
		defaultVertex$2 =
			'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n',
		UID$3$1 = 0,
		nameCache$1 = {},
		Program$1 = (function () {
			function t(e, i, r) {
				void 0 === r && (r = 'pixi-shader'),
					(this.id = UID$3$1++),
					(this.vertexSrc = e || t.defaultVertexSrc),
					(this.fragmentSrc = i || t.defaultFragmentSrc),
					(this.vertexSrc = this.vertexSrc.trim()),
					(this.fragmentSrc = this.fragmentSrc.trim()),
					'#version' !== this.vertexSrc.substring(0, 8) &&
						((r = r.replace(/\s+/g, '-')),
						nameCache$1[r]
							? (nameCache$1[r]++, (r += '-' + nameCache$1[r]))
							: (nameCache$1[r] = 1),
						(this.vertexSrc =
							'#define SHADER_NAME ' + r + '\n' + this.vertexSrc),
						(this.fragmentSrc =
							'#define SHADER_NAME ' + r + '\n' + this.fragmentSrc),
						(this.vertexSrc = setPrecision$1(
							this.vertexSrc,
							settings$2.PRECISION_VERTEX,
							PRECISION$3.HIGH
						)),
						(this.fragmentSrc = setPrecision$1(
							this.fragmentSrc,
							settings$2.PRECISION_FRAGMENT,
							getMaxFragmentPrecision$1()
						))),
					(this.glPrograms = {}),
					(this.syncUniforms = null);
			}
			return (
				Object.defineProperty(t, 'defaultVertexSrc', {
					get: function () {
						return defaultVertex$2;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t, 'defaultFragmentSrc', {
					get: function () {
						return defaultFragment$3;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.from = function (e, i, r) {
					var s = e + i,
						n = ProgramCache$1[s];
					return n || (ProgramCache$1[s] = n = new t(e, i, r)), n;
				}),
				t
			);
		})(),
		Shader$1 = (function () {
			function t(t, e) {
				(this.uniformBindCount = 0),
					(this.program = t),
					(this.uniformGroup = e
						? e instanceof UniformGroup$1
							? e
							: new UniformGroup$1(e)
						: new UniformGroup$1({}));
			}
			return (
				(t.prototype.checkUniformExists = function (t, e) {
					if (e.uniforms[t]) return !0;
					for (var i in e.uniforms) {
						var r = e.uniforms[i];
						if (r.group && this.checkUniformExists(t, r)) return !0;
					}
					return !1;
				}),
				(t.prototype.destroy = function () {
					this.uniformGroup = null;
				}),
				Object.defineProperty(t.prototype, 'uniforms', {
					get: function () {
						return this.uniformGroup.uniforms;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.from = function (e, i, r) {
					return new t(Program$1.from(e, i), r);
				}),
				t
			);
		})(),
		BLEND$2 = 0,
		OFFSET$2 = 1,
		CULLING$2 = 2,
		DEPTH_TEST$2 = 3,
		WINDING$2 = 4,
		DEPTH_MASK$2 = 5,
		State$1 = (function () {
			function t() {
				(this.data = 0),
					(this.blendMode = BLEND_MODES$3.NORMAL),
					(this.polygonOffset = 0),
					(this.blend = !0),
					(this.depthMask = !0);
			}
			return (
				Object.defineProperty(t.prototype, 'blend', {
					get: function () {
						return !!(this.data & (1 << BLEND$2));
					},
					set: function (t) {
						!!(this.data & (1 << BLEND$2)) !== t && (this.data ^= 1 << BLEND$2);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'offsets', {
					get: function () {
						return !!(this.data & (1 << OFFSET$2));
					},
					set: function (t) {
						!!(this.data & (1 << OFFSET$2)) !== t &&
							(this.data ^= 1 << OFFSET$2);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'culling', {
					get: function () {
						return !!(this.data & (1 << CULLING$2));
					},
					set: function (t) {
						!!(this.data & (1 << CULLING$2)) !== t &&
							(this.data ^= 1 << CULLING$2);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'depthTest', {
					get: function () {
						return !!(this.data & (1 << DEPTH_TEST$2));
					},
					set: function (t) {
						!!(this.data & (1 << DEPTH_TEST$2)) !== t &&
							(this.data ^= 1 << DEPTH_TEST$2);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'depthMask', {
					get: function () {
						return !!(this.data & (1 << DEPTH_MASK$2));
					},
					set: function (t) {
						!!(this.data & (1 << DEPTH_MASK$2)) !== t &&
							(this.data ^= 1 << DEPTH_MASK$2);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'clockwiseFrontFace', {
					get: function () {
						return !!(this.data & (1 << WINDING$2));
					},
					set: function (t) {
						!!(this.data & (1 << WINDING$2)) !== t &&
							(this.data ^= 1 << WINDING$2);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'blendMode', {
					get: function () {
						return this._blendMode;
					},
					set: function (t) {
						(this.blend = t !== BLEND_MODES$3.NONE), (this._blendMode = t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'polygonOffset', {
					get: function () {
						return this._polygonOffset;
					},
					set: function (t) {
						(this.offsets = !!t), (this._polygonOffset = t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.toString = function () {
					return (
						'[@pixi/core:State blendMode=' +
						this.blendMode +
						' clockwiseFrontFace=' +
						this.clockwiseFrontFace +
						' culling=' +
						this.culling +
						' depthMask=' +
						this.depthMask +
						' polygonOffset=' +
						this.polygonOffset +
						']'
					);
				}),
				(t.for2d = function () {
					var e = new t();
					return (e.depthTest = !1), (e.blend = !0), e;
				}),
				t
			);
		})(),
		defaultVertex$1$1 =
			'attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n',
		defaultFragment$1$1 =
			'varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n',
		Filter$1 = (function (t) {
			function e(i, r, s) {
				var n = this,
					a = Program$1.from(
						i || e.defaultVertexSrc,
						r || e.defaultFragmentSrc
					);
				return (
					((n = t.call(this, a, s) || this).padding = 0),
					(n.resolution = settings$2.FILTER_RESOLUTION),
					(n.multisample = settings$2.FILTER_MULTISAMPLE),
					(n.enabled = !0),
					(n.autoFit = !0),
					(n.state = new State$1()),
					n
				);
			}
			return (
				__extends$b(e, t),
				(e.prototype.apply = function (t, e, i, r, s) {
					t.applyFilter(this, e, i, r);
				}),
				Object.defineProperty(e.prototype, 'blendMode', {
					get: function () {
						return this.state.blendMode;
					},
					set: function (t) {
						this.state.blendMode = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'resolution', {
					get: function () {
						return this._resolution;
					},
					set: function (t) {
						this._resolution = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e, 'defaultVertexSrc', {
					get: function () {
						return defaultVertex$1$1;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e, 'defaultFragmentSrc', {
					get: function () {
						return defaultFragment$1$1;
					},
					enumerable: !1,
					configurable: !0,
				}),
				e
			);
		})(Shader$1),
		vertex$9 =
			'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n',
		fragment$b =
			'varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n',
		tempMat$1 = new Matrix$1(),
		TextureMatrix$1 = (function () {
			function t(t, e) {
				(this._texture = t),
					(this.mapCoord = new Matrix$1()),
					(this.uClampFrame = new Float32Array(4)),
					(this.uClampOffset = new Float32Array(2)),
					(this._textureID = -1),
					(this._updateID = 0),
					(this.clampOffset = 0),
					(this.clampMargin = void 0 === e ? 0.5 : e),
					(this.isSimple = !1);
			}
			return (
				Object.defineProperty(t.prototype, 'texture', {
					get: function () {
						return this._texture;
					},
					set: function (t) {
						(this._texture = t), (this._textureID = -1);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.multiplyUvs = function (t, e) {
					void 0 === e && (e = t);
					for (var i = this.mapCoord, r = 0; r < t.length; r += 2) {
						var s = t[r],
							n = t[r + 1];
						(e[r] = s * i.a + n * i.c + i.tx),
							(e[r + 1] = s * i.b + n * i.d + i.ty);
					}
					return e;
				}),
				(t.prototype.update = function (t) {
					var e = this._texture;
					if (!e || !e.valid) return !1;
					if (!t && this._textureID === e._updateID) return !1;
					(this._textureID = e._updateID), this._updateID++;
					var i = e._uvs;
					this.mapCoord.set(
						i.x1 - i.x0,
						i.y1 - i.y0,
						i.x3 - i.x0,
						i.y3 - i.y0,
						i.x0,
						i.y0
					);
					var r = e.orig,
						s = e.trim;
					s &&
						(tempMat$1.set(
							r.width / s.width,
							0,
							0,
							r.height / s.height,
							-s.x / s.width,
							-s.y / s.height
						),
						this.mapCoord.append(tempMat$1));
					var n = e.baseTexture,
						a = this.uClampFrame,
						o = this.clampMargin / n.resolution,
						h = this.clampOffset;
					return (
						(a[0] = (e._frame.x + o + h) / n.width),
						(a[1] = (e._frame.y + o + h) / n.height),
						(a[2] = (e._frame.x + e._frame.width - o + h) / n.width),
						(a[3] = (e._frame.y + e._frame.height - o + h) / n.height),
						(this.uClampOffset[0] = h / n.realWidth),
						(this.uClampOffset[1] = h / n.realHeight),
						(this.isSimple =
							e._frame.width === n.width &&
							e._frame.height === n.height &&
							0 === e.rotate),
						!0
					);
				}),
				t
			);
		})(),
		SpriteMaskFilter$1 = (function (t) {
			function e(e, i, r) {
				var s = this,
					n = null;
				return (
					'string' != typeof e &&
						void 0 === i &&
						void 0 === r &&
						((n = e), (e = void 0), (i = void 0), (r = void 0)),
					((s =
						t.call(this, e || vertex$9, i || fragment$b, r) ||
						this).maskSprite = n),
					(s.maskMatrix = new Matrix$1()),
					s
				);
			}
			return (
				__extends$b(e, t),
				Object.defineProperty(e.prototype, 'maskSprite', {
					get: function () {
						return this._maskSprite;
					},
					set: function (t) {
						(this._maskSprite = t),
							this._maskSprite && (this._maskSprite.renderable = !1);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.apply = function (t, e, i, r) {
					var s = this._maskSprite,
						n = s._texture;
					n.valid &&
						(n.uvMatrix || (n.uvMatrix = new TextureMatrix$1(n, 0)),
						n.uvMatrix.update(),
						(this.uniforms.npmAlpha = n.baseTexture.alphaMode ? 0 : 1),
						(this.uniforms.mask = n),
						(this.uniforms.otherMatrix = t
							.calculateSpriteMatrix(this.maskMatrix, s)
							.prepend(n.uvMatrix.mapCoord)),
						(this.uniforms.alpha = s.worldAlpha),
						(this.uniforms.maskClamp = n.uvMatrix.uClampFrame),
						t.applyFilter(this, e, i, r));
				}),
				e
			);
		})(Filter$1),
		MaskSystem$1 = (function () {
			function t(t) {
				(this.renderer = t),
					(this.enableScissor = !0),
					(this.alphaMaskPool = []),
					(this.maskDataPool = []),
					(this.maskStack = []),
					(this.alphaMaskIndex = 0);
			}
			return (
				(t.prototype.setMaskStack = function (t) {
					(this.maskStack = t),
						this.renderer.scissor.setMaskStack(t),
						this.renderer.stencil.setMaskStack(t);
				}),
				(t.prototype.push = function (t, e) {
					var i = e;
					if (!i.isMaskData) {
						var r = this.maskDataPool.pop() || new MaskData$1();
						(r.pooled = !0), (r.maskObject = e), (i = r);
					}
					var s =
						0 !== this.maskStack.length
							? this.maskStack[this.maskStack.length - 1]
							: null;
					if (
						(i.copyCountersOrReset(s),
						i.autoDetect && this.detect(i),
						(i._target = t),
						i.type !== MASK_TYPES$3.SPRITE && this.maskStack.push(i),
						i.enabled)
					)
						switch (i.type) {
							case MASK_TYPES$3.SCISSOR:
								this.renderer.scissor.push(i);
								break;
							case MASK_TYPES$3.STENCIL:
								this.renderer.stencil.push(i);
								break;
							case MASK_TYPES$3.SPRITE:
								i.copyCountersOrReset(null), this.pushSpriteMask(i);
						}
					i.type === MASK_TYPES$3.SPRITE && this.maskStack.push(i);
				}),
				(t.prototype.pop = function (t) {
					var e = this.maskStack.pop();
					if (e && e._target === t) {
						if (e.enabled)
							switch (e.type) {
								case MASK_TYPES$3.SCISSOR:
									this.renderer.scissor.pop();
									break;
								case MASK_TYPES$3.STENCIL:
									this.renderer.stencil.pop(e.maskObject);
									break;
								case MASK_TYPES$3.SPRITE:
									this.popSpriteMask(e);
							}
						if (
							(e.reset(),
							e.pooled && this.maskDataPool.push(e),
							0 !== this.maskStack.length)
						) {
							var i = this.maskStack[this.maskStack.length - 1];
							i.type === MASK_TYPES$3.SPRITE &&
								i._filters &&
								(i._filters[0].maskSprite = i.maskObject);
						}
					}
				}),
				(t.prototype.detect = function (t) {
					t.maskObject.isSprite
						? (t.type = MASK_TYPES$3.SPRITE)
						: this.enableScissor && this.renderer.scissor.testScissor(t)
						? (t.type = MASK_TYPES$3.SCISSOR)
						: (t.type = MASK_TYPES$3.STENCIL);
				}),
				(t.prototype.pushSpriteMask = function (t) {
					var e,
						i,
						r = t.maskObject,
						s = t._target,
						n = t._filters;
					n ||
						(n = this.alphaMaskPool[this.alphaMaskIndex]) ||
						(n = this.alphaMaskPool[this.alphaMaskIndex] =
							[new SpriteMaskFilter$1()]);
					var a,
						o,
						h = this.renderer,
						u = h.renderTexture;
					if (u.current) {
						var l = u.current;
						(a = t.resolution || l.resolution),
							(o =
								null !== (e = t.multisample) && void 0 !== e
									? e
									: l.multisample);
					} else
						(a = t.resolution || h.resolution),
							(o =
								null !== (i = t.multisample) && void 0 !== i
									? i
									: h.multisample);
					(n[0].resolution = a), (n[0].multisample = o), (n[0].maskSprite = r);
					var c = s.filterArea;
					(s.filterArea = r.getBounds(!0)),
						h.filter.push(s, n),
						(s.filterArea = c),
						t._filters || this.alphaMaskIndex++;
				}),
				(t.prototype.popSpriteMask = function (t) {
					this.renderer.filter.pop(),
						t._filters
							? (t._filters[0].maskSprite = null)
							: (this.alphaMaskIndex--,
							  (this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null));
				}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})(),
		AbstractMaskSystem$1 = (function () {
			function t(t) {
				(this.renderer = t), (this.maskStack = []), (this.glConst = 0);
			}
			return (
				(t.prototype.getStackLength = function () {
					return this.maskStack.length;
				}),
				(t.prototype.setMaskStack = function (t) {
					var e = this.renderer.gl,
						i = this.getStackLength();
					this.maskStack = t;
					var r = this.getStackLength();
					r !== i &&
						(0 === r
							? e.disable(this.glConst)
							: (e.enable(this.glConst), this._useCurrent()));
				}),
				(t.prototype._useCurrent = function () {}),
				(t.prototype.destroy = function () {
					(this.renderer = null), (this.maskStack = null);
				}),
				t
			);
		})(),
		tempMatrix$1$1 = new Matrix$1(),
		ScissorSystem$1 = (function (t) {
			function e(e) {
				var i = t.call(this, e) || this;
				return (i.glConst = WebGLRenderingContext.SCISSOR_TEST), i;
			}
			return (
				__extends$b(e, t),
				(e.prototype.getStackLength = function () {
					var t = this.maskStack[this.maskStack.length - 1];
					return t ? t._scissorCounter : 0;
				}),
				(e.prototype.calcScissorRect = function (t) {
					if (!t._scissorRectLocal) {
						var e = t._scissorRect,
							i = t.maskObject,
							r = this.renderer,
							s = r.renderTexture;
						i.renderable = !0;
						var n = i.getBounds();
						this.roundFrameToPixels(
							n,
							s.current ? s.current.resolution : r.resolution,
							s.sourceFrame,
							s.destinationFrame,
							r.projection.transform
						),
							(i.renderable = !1),
							e && n.fit(e),
							(t._scissorRectLocal = n);
					}
				}),
				(e.isMatrixRotated = function (t) {
					if (!t) return !1;
					var e = t.a,
						i = t.b,
						r = t.c,
						s = t.d;
					return (
						(Math.abs(i) > 1e-4 || Math.abs(r) > 1e-4) &&
						(Math.abs(e) > 1e-4 || Math.abs(s) > 1e-4)
					);
				}),
				(e.prototype.testScissor = function (t) {
					var i = t.maskObject;
					if (!i.isFastRect || !i.isFastRect()) return !1;
					if (e.isMatrixRotated(i.worldTransform)) return !1;
					if (e.isMatrixRotated(this.renderer.projection.transform)) return !1;
					this.calcScissorRect(t);
					var r = t._scissorRectLocal;
					return r.width > 0 && r.height > 0;
				}),
				(e.prototype.roundFrameToPixels = function (t, i, r, s, n) {
					e.isMatrixRotated(n) ||
						((n = n ? tempMatrix$1$1.copyFrom(n) : tempMatrix$1$1.identity())
							.translate(-r.x, -r.y)
							.scale(s.width / r.width, s.height / r.height)
							.translate(s.x, s.y),
						this.renderer.filter.transformAABB(n, t),
						t.fit(s),
						(t.x = Math.round(t.x * i)),
						(t.y = Math.round(t.y * i)),
						(t.width = Math.round(t.width * i)),
						(t.height = Math.round(t.height * i)));
				}),
				(e.prototype.push = function (t) {
					t._scissorRectLocal || this.calcScissorRect(t);
					var e = this.renderer.gl;
					t._scissorRect || e.enable(e.SCISSOR_TEST),
						t._scissorCounter++,
						(t._scissorRect = t._scissorRectLocal),
						this._useCurrent();
				}),
				(e.prototype.pop = function () {
					var t = this.renderer.gl;
					this.getStackLength() > 0
						? this._useCurrent()
						: t.disable(t.SCISSOR_TEST);
				}),
				(e.prototype._useCurrent = function () {
					var t,
						e = this.maskStack[this.maskStack.length - 1]._scissorRect;
					(t = this.renderer.renderTexture.current
						? e.y
						: this.renderer.height - e.height - e.y),
						this.renderer.gl.scissor(e.x, t, e.width, e.height);
				}),
				e
			);
		})(AbstractMaskSystem$1),
		StencilSystem$1 = (function (t) {
			function e(e) {
				var i = t.call(this, e) || this;
				return (i.glConst = WebGLRenderingContext.STENCIL_TEST), i;
			}
			return (
				__extends$b(e, t),
				(e.prototype.getStackLength = function () {
					var t = this.maskStack[this.maskStack.length - 1];
					return t ? t._stencilCounter : 0;
				}),
				(e.prototype.push = function (t) {
					var e = t.maskObject,
						i = this.renderer.gl,
						r = t._stencilCounter;
					0 === r &&
						(this.renderer.framebuffer.forceStencil(),
						i.clearStencil(0),
						i.clear(i.STENCIL_BUFFER_BIT),
						i.enable(i.STENCIL_TEST)),
						t._stencilCounter++,
						i.colorMask(!1, !1, !1, !1),
						i.stencilFunc(i.EQUAL, r, 4294967295),
						i.stencilOp(i.KEEP, i.KEEP, i.INCR),
						(e.renderable = !0),
						e.render(this.renderer),
						this.renderer.batch.flush(),
						(e.renderable = !1),
						this._useCurrent();
				}),
				(e.prototype.pop = function (t) {
					var e = this.renderer.gl;
					0 === this.getStackLength()
						? e.disable(e.STENCIL_TEST)
						: (e.colorMask(!1, !1, !1, !1),
						  e.stencilOp(e.KEEP, e.KEEP, e.DECR),
						  (t.renderable = !0),
						  t.render(this.renderer),
						  this.renderer.batch.flush(),
						  (t.renderable = !1),
						  this._useCurrent());
				}),
				(e.prototype._useCurrent = function () {
					var t = this.renderer.gl;
					t.colorMask(!0, !0, !0, !0),
						t.stencilFunc(t.EQUAL, this.getStackLength(), 4294967295),
						t.stencilOp(t.KEEP, t.KEEP, t.KEEP);
				}),
				e
			);
		})(AbstractMaskSystem$1),
		ProjectionSystem$1 = (function () {
			function t(t) {
				(this.renderer = t),
					(this.destinationFrame = null),
					(this.sourceFrame = null),
					(this.defaultFrame = null),
					(this.projectionMatrix = new Matrix$1()),
					(this.transform = null);
			}
			return (
				(t.prototype.update = function (t, e, i, r) {
					(this.destinationFrame =
						t || this.destinationFrame || this.defaultFrame),
						(this.sourceFrame = e || this.sourceFrame || t),
						this.calculateProjection(
							this.destinationFrame,
							this.sourceFrame,
							i,
							r
						),
						this.transform && this.projectionMatrix.append(this.transform);
					var s = this.renderer;
					(s.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix),
						s.globalUniforms.update(),
						s.shader.shader &&
							s.shader.syncUniformGroup(s.shader.shader.uniforms.globals);
				}),
				(t.prototype.calculateProjection = function (t, e, i, r) {
					var s = this.projectionMatrix,
						n = r ? -1 : 1;
					s.identity(),
						(s.a = (1 / e.width) * 2),
						(s.d = n * ((1 / e.height) * 2)),
						(s.tx = -1 - e.x * s.a),
						(s.ty = -n - e.y * s.d);
				}),
				(t.prototype.setTransform = function (t) {}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})(),
		tempRect$1 = new Rectangle$2(),
		tempRect2$1 = new Rectangle$2(),
		RenderTextureSystem$1 = (function () {
			function t(t) {
				(this.renderer = t),
					(this.clearColor = t._backgroundColorRgba),
					(this.defaultMaskStack = []),
					(this.current = null),
					(this.sourceFrame = new Rectangle$2()),
					(this.destinationFrame = new Rectangle$2()),
					(this.viewportFrame = new Rectangle$2());
			}
			return (
				(t.prototype.bind = function (t, e, i) {
					void 0 === t && (t = null);
					var r,
						s,
						n,
						a = this.renderer;
					(this.current = t),
						t
							? ((n = (r = t.baseTexture).resolution),
							  e ||
									((tempRect$1.width = t.frame.width),
									(tempRect$1.height = t.frame.height),
									(e = tempRect$1)),
							  i ||
									((tempRect2$1.x = t.frame.x),
									(tempRect2$1.y = t.frame.y),
									(tempRect2$1.width = e.width),
									(tempRect2$1.height = e.height),
									(i = tempRect2$1)),
							  (s = r.framebuffer))
							: ((n = a.resolution),
							  e ||
									((tempRect$1.width = a.screen.width),
									(tempRect$1.height = a.screen.height),
									(e = tempRect$1)),
							  i ||
									(((i = tempRect$1).width = e.width), (i.height = e.height)));
					var o = this.viewportFrame;
					(o.x = i.x * n),
						(o.y = i.y * n),
						(o.width = i.width * n),
						(o.height = i.height * n),
						t || (o.y = a.view.height - (o.y + o.height)),
						o.ceil(),
						this.renderer.framebuffer.bind(s, o),
						this.renderer.projection.update(i, e, n, !s),
						t
							? this.renderer.mask.setMaskStack(r.maskStack)
							: this.renderer.mask.setMaskStack(this.defaultMaskStack),
						this.sourceFrame.copyFrom(e),
						this.destinationFrame.copyFrom(i);
				}),
				(t.prototype.clear = function (t, e) {
					t = this.current
						? t || this.current.baseTexture.clearColor
						: t || this.clearColor;
					var i = this.destinationFrame,
						r = this.current ? this.current.baseTexture : this.renderer.screen,
						s = i.width !== r.width || i.height !== r.height;
					if (s) {
						var n = this.viewportFrame,
							a = n.x,
							o = n.y,
							h = n.width,
							u = n.height;
						(a = Math.round(a)),
							(o = Math.round(o)),
							(h = Math.round(h)),
							(u = Math.round(u)),
							this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST),
							this.renderer.gl.scissor(a, o, h, u);
					}
					this.renderer.framebuffer.clear(t[0], t[1], t[2], t[3], e),
						s && this.renderer.scissor.pop();
				}),
				(t.prototype.resize = function () {
					this.bind(null);
				}),
				(t.prototype.reset = function () {
					this.bind(null);
				}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})();
	function uboUpdate$1(t, e, i, r, s) {
		i.buffer.update(s);
	}
	var UBO_TO_SINGLE_SETTERS$1 = {
			float: '\n        data[offset] = v;\n    ',
			vec2: '\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    ',
			vec3: '\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    ',
			vec4: '\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    ',
			mat2: '\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    ',
			mat3: '\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    ',
			mat4: '\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    ',
		},
		GLSL_TO_STD40_SIZE$1 = {
			float: 4,
			vec2: 8,
			vec3: 12,
			vec4: 16,
			int: 4,
			ivec2: 8,
			ivec3: 12,
			ivec4: 16,
			uint: 4,
			uvec2: 8,
			uvec3: 12,
			uvec4: 16,
			bool: 4,
			bvec2: 8,
			bvec3: 12,
			bvec4: 16,
			mat2: 32,
			mat3: 48,
			mat4: 64,
		};
	function createUBOElements$1(t) {
		for (
			var e = t.map(function (t) {
					return { data: t, offset: 0, dataLen: 0, dirty: 0 };
				}),
				i = 0,
				r = 0,
				s = 0,
				n = 0;
			n < e.length;
			n++
		) {
			var a = e[n];
			if (
				((i = GLSL_TO_STD40_SIZE$1[a.data.type]),
				a.data.size > 1 && (i = Math.max(i, 16) * a.data.size),
				(a.dataLen = i),
				r % i != 0 && r < 16)
			) {
				var o = (r % i) % 16;
				(r += o), (s += o);
			}
			r + i > 16
				? ((s = 16 * Math.ceil(s / 16)), (a.offset = s), (s += i), (r = i))
				: ((a.offset = s), (r += i), (s += i));
		}
		return { uboElements: e, size: (s = 16 * Math.ceil(s / 16)) };
	}
	function getUBOData$1(t, e) {
		var i = [];
		for (var r in t) e[r] && i.push(e[r]);
		return (
			i.sort(function (t, e) {
				return t.index - e.index;
			}),
			i
		);
	}
	function generateUniformBufferSync$1(t, e) {
		if (!t.autoManage) return { size: 0, syncFunc: uboUpdate$1 };
		for (
			var i = createUBOElements$1(getUBOData$1(t.uniforms, e)),
				r = i.uboElements,
				s = i.size,
				n = [
					'\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    ',
				],
				a = 0;
			a < r.length;
			a++
		) {
			for (
				var o = r[a],
					h = t.uniforms[o.data.name],
					u = o.data.name,
					l = !1,
					c = 0;
				c < uniformParsers$1.length;
				c++
			) {
				var d = uniformParsers$1[c];
				if (d.codeUbo && d.test(o.data, h)) {
					n.push(
						'offset = ' + o.offset / 4 + ';',
						uniformParsers$1[c].codeUbo(o.data.name, h)
					),
						(l = !0);
					break;
				}
			}
			if (!l)
				if (o.data.size > 1) {
					var p = mapSize$1(o.data.type),
						f = Math.max(GLSL_TO_STD40_SIZE$1[o.data.type] / 16, 1),
						m = p / f,
						_ = (4 - (m % 4)) % 4;
					n.push(
						'\n                cv = ud.' +
							u +
							'.value;\n                v = uv.' +
							u +
							';\n                offset = ' +
							o.offset / 4 +
							';\n\n                t = 0;\n\n                for(var i=0; i < ' +
							o.data.size * f +
							'; i++)\n                {\n                    for(var j = 0; j < ' +
							m +
							'; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += ' +
							_ +
							';\n                }\n\n                '
					);
				} else {
					var g = UBO_TO_SINGLE_SETTERS$1[o.data.type];
					n.push(
						'\n                cv = ud.' +
							u +
							'.value;\n                v = uv.' +
							u +
							';\n                offset = ' +
							o.offset / 4 +
							';\n                ' +
							g +
							';\n                '
					);
				}
		}
		return (
			n.push('\n       renderer.buffer.update(buffer);\n    '),
			{
				size: s,
				syncFunc: new Function(
					'ud',
					'uv',
					'renderer',
					'syncData',
					'buffer',
					n.join('\n')
				),
			}
		);
	}
	var GLProgram$1 = (function () {
		function t(t, e) {
			(this.program = t),
				(this.uniformData = e),
				(this.uniformGroups = {}),
				(this.uniformDirtyGroups = {}),
				(this.uniformBufferBindings = {});
		}
		return (
			(t.prototype.destroy = function () {
				(this.uniformData = null),
					(this.uniformGroups = null),
					(this.uniformDirtyGroups = null),
					(this.uniformBufferBindings = null),
					(this.program = null);
			}),
			t
		);
	})();
	function getAttributeData$1(t, e) {
		for (
			var i = {}, r = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES), s = 0;
			s < r;
			s++
		) {
			var n = e.getActiveAttrib(t, s);
			if (0 !== n.name.indexOf('gl_')) {
				var a = mapType$1(e, n.type),
					o = {
						type: a,
						name: n.name,
						size: mapSize$1(a),
						location: e.getAttribLocation(t, n.name),
					};
				i[n.name] = o;
			}
		}
		return i;
	}
	function getUniformData$1(t, e) {
		for (
			var i = {}, r = e.getProgramParameter(t, e.ACTIVE_UNIFORMS), s = 0;
			s < r;
			s++
		) {
			var n = e.getActiveUniform(t, s),
				a = n.name.replace(/\[.*?\]$/, ''),
				o = !!n.name.match(/\[.*?\]$/),
				h = mapType$1(e, n.type);
			i[a] = {
				name: a,
				index: s,
				type: h,
				size: n.size,
				isArray: o,
				value: defaultValue$1(h, n.size),
			};
		}
		return i;
	}
	function generateProgram$1(t, e) {
		var i = compileShader$1(t, t.VERTEX_SHADER, e.vertexSrc),
			r = compileShader$1(t, t.FRAGMENT_SHADER, e.fragmentSrc),
			s = t.createProgram();
		if (
			(t.attachShader(s, i),
			t.attachShader(s, r),
			t.linkProgram(s),
			t.getProgramParameter(s, t.LINK_STATUS) || logProgramError$1(t, s, i, r),
			(e.attributeData = getAttributeData$1(s, t)),
			(e.uniformData = getUniformData$1(s, t)),
			!/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e.vertexSrc))
		) {
			var n = Object.keys(e.attributeData);
			n.sort(function (t, e) {
				return t > e ? 1 : -1;
			});
			for (var a = 0; a < n.length; a++)
				(e.attributeData[n[a]].location = a), t.bindAttribLocation(s, a, n[a]);
			t.linkProgram(s);
		}
		t.deleteShader(i), t.deleteShader(r);
		var o = {};
		for (var a in e.uniformData) {
			var h = e.uniformData[a];
			o[a] = {
				location: t.getUniformLocation(s, a),
				value: defaultValue$1(h.type, h.size),
			};
		}
		return new GLProgram$1(s, o);
	}
	var UID$4$1 = 0,
		defaultSyncData$1 = { textureCount: 0, uboCount: 0 },
		ShaderSystem$1 = (function () {
			function t(t) {
				(this.destroyed = !1),
					(this.renderer = t),
					this.systemCheck(),
					(this.gl = null),
					(this.shader = null),
					(this.program = null),
					(this.cache = {}),
					(this._uboCache = {}),
					(this.id = UID$4$1++);
			}
			return (
				(t.prototype.systemCheck = function () {
					if (!unsafeEvalSupported$1())
						throw new Error(
							'Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.'
						);
				}),
				(t.prototype.contextChange = function (t) {
					(this.gl = t), this.reset();
				}),
				(t.prototype.bind = function (t, e) {
					t.uniforms.globals = this.renderer.globalUniforms;
					var i = t.program,
						r =
							i.glPrograms[this.renderer.CONTEXT_UID] ||
							this.generateProgram(t);
					return (
						(this.shader = t),
						this.program !== i &&
							((this.program = i), this.gl.useProgram(r.program)),
						e ||
							((defaultSyncData$1.textureCount = 0),
							(defaultSyncData$1.uboCount = 0),
							this.syncUniformGroup(t.uniformGroup, defaultSyncData$1)),
						r
					);
				}),
				(t.prototype.setUniforms = function (t) {
					var e = this.shader.program,
						i = e.glPrograms[this.renderer.CONTEXT_UID];
					e.syncUniforms(i.uniformData, t, this.renderer);
				}),
				(t.prototype.syncUniformGroup = function (t, e) {
					var i = this.getGlProgram();
					(t.static && t.dirtyId === i.uniformDirtyGroups[t.id]) ||
						((i.uniformDirtyGroups[t.id] = t.dirtyId),
						this.syncUniforms(t, i, e));
				}),
				(t.prototype.syncUniforms = function (t, e, i) {
					(t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t))(
						e.uniformData,
						t.uniforms,
						this.renderer,
						i
					);
				}),
				(t.prototype.createSyncGroups = function (t) {
					var e = this.getSignature(t, this.shader.program.uniformData, 'u');
					return (
						this.cache[e] ||
							(this.cache[e] = generateUniformsSync$1(
								t,
								this.shader.program.uniformData
							)),
						(t.syncUniforms[this.shader.program.id] = this.cache[e]),
						t.syncUniforms[this.shader.program.id]
					);
				}),
				(t.prototype.syncUniformBufferGroup = function (t, e) {
					var i = this.getGlProgram();
					if (!t.static || 0 !== t.dirtyId || !i.uniformGroups[t.id]) {
						t.dirtyId = 0;
						var r =
							i.uniformGroups[t.id] || this.createSyncBufferGroup(t, i, e);
						t.buffer.update(),
							r(
								i.uniformData,
								t.uniforms,
								this.renderer,
								defaultSyncData$1,
								t.buffer
							);
					}
					this.renderer.buffer.bindBufferBase(
						t.buffer,
						i.uniformBufferBindings[e]
					);
				}),
				(t.prototype.createSyncBufferGroup = function (t, e, i) {
					var r = this.renderer.gl;
					this.renderer.buffer.bind(t.buffer);
					var s = this.gl.getUniformBlockIndex(e.program, i);
					(e.uniformBufferBindings[i] = this.shader.uniformBindCount),
						r.uniformBlockBinding(e.program, s, this.shader.uniformBindCount),
						this.shader.uniformBindCount++;
					var n = this.getSignature(t, this.shader.program.uniformData, 'ubo'),
						a = this._uboCache[n];
					if (
						(a ||
							(a = this._uboCache[n] =
								generateUniformBufferSync$1(
									t,
									this.shader.program.uniformData
								)),
						t.autoManage)
					) {
						var o = new Float32Array(a.size / 4);
						t.buffer.update(o);
					}
					return (e.uniformGroups[t.id] = a.syncFunc), e.uniformGroups[t.id];
				}),
				(t.prototype.getSignature = function (t, e, i) {
					var r = t.uniforms,
						s = [i + '-'];
					for (var n in r) s.push(n), e[n] && s.push(e[n].type);
					return s.join('-');
				}),
				(t.prototype.getGlProgram = function () {
					return this.shader
						? this.shader.program.glPrograms[this.renderer.CONTEXT_UID]
						: null;
				}),
				(t.prototype.generateProgram = function (t) {
					var e = this.gl,
						i = t.program,
						r = generateProgram$1(e, i);
					return (i.glPrograms[this.renderer.CONTEXT_UID] = r), r;
				}),
				(t.prototype.reset = function () {
					(this.program = null), (this.shader = null);
				}),
				(t.prototype.destroy = function () {
					(this.renderer = null), (this.destroyed = !0);
				}),
				t
			);
		})();
	function mapWebGLBlendModesToPixi$1(t, e) {
		return (
			void 0 === e && (e = []),
			(e[BLEND_MODES$3.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$3.ADD] = [t.ONE, t.ONE]),
			(e[BLEND_MODES$3.MULTIPLY] = [
				t.DST_COLOR,
				t.ONE_MINUS_SRC_ALPHA,
				t.ONE,
				t.ONE_MINUS_SRC_ALPHA,
			]),
			(e[BLEND_MODES$3.SCREEN] = [
				t.ONE,
				t.ONE_MINUS_SRC_COLOR,
				t.ONE,
				t.ONE_MINUS_SRC_ALPHA,
			]),
			(e[BLEND_MODES$3.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$3.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$3.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$3.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$3.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$3.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$3.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$3.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$3.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$3.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$3.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$3.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$3.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$3.NONE] = [0, 0]),
			(e[BLEND_MODES$3.NORMAL_NPM] = [
				t.SRC_ALPHA,
				t.ONE_MINUS_SRC_ALPHA,
				t.ONE,
				t.ONE_MINUS_SRC_ALPHA,
			]),
			(e[BLEND_MODES$3.ADD_NPM] = [t.SRC_ALPHA, t.ONE, t.ONE, t.ONE]),
			(e[BLEND_MODES$3.SCREEN_NPM] = [
				t.SRC_ALPHA,
				t.ONE_MINUS_SRC_COLOR,
				t.ONE,
				t.ONE_MINUS_SRC_ALPHA,
			]),
			(e[BLEND_MODES$3.SRC_IN] = [t.DST_ALPHA, t.ZERO]),
			(e[BLEND_MODES$3.SRC_OUT] = [t.ONE_MINUS_DST_ALPHA, t.ZERO]),
			(e[BLEND_MODES$3.SRC_ATOP] = [t.DST_ALPHA, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$3.DST_OVER] = [t.ONE_MINUS_DST_ALPHA, t.ONE]),
			(e[BLEND_MODES$3.DST_IN] = [t.ZERO, t.SRC_ALPHA]),
			(e[BLEND_MODES$3.DST_OUT] = [t.ZERO, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$3.DST_ATOP] = [t.ONE_MINUS_DST_ALPHA, t.SRC_ALPHA]),
			(e[BLEND_MODES$3.XOR] = [t.ONE_MINUS_DST_ALPHA, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES$3.SUBTRACT] = [
				t.ONE,
				t.ONE,
				t.ONE,
				t.ONE,
				t.FUNC_REVERSE_SUBTRACT,
				t.FUNC_ADD,
			]),
			e
		);
	}
	var BLEND$1$1 = 0,
		OFFSET$1$1 = 1,
		CULLING$1$1 = 2,
		DEPTH_TEST$1$1 = 3,
		WINDING$1$1 = 4,
		DEPTH_MASK$1$1 = 5,
		StateSystem$1 = (function () {
			function t() {
				(this.gl = null),
					(this.stateId = 0),
					(this.polygonOffset = 0),
					(this.blendMode = BLEND_MODES$3.NONE),
					(this._blendEq = !1),
					(this.map = []),
					(this.map[BLEND$1$1] = this.setBlend),
					(this.map[OFFSET$1$1] = this.setOffset),
					(this.map[CULLING$1$1] = this.setCullFace),
					(this.map[DEPTH_TEST$1$1] = this.setDepthTest),
					(this.map[WINDING$1$1] = this.setFrontFace),
					(this.map[DEPTH_MASK$1$1] = this.setDepthMask),
					(this.checks = []),
					(this.defaultState = new State$1()),
					(this.defaultState.blend = !0);
			}
			return (
				(t.prototype.contextChange = function (t) {
					(this.gl = t),
						(this.blendModes = mapWebGLBlendModesToPixi$1(t)),
						this.set(this.defaultState),
						this.reset();
				}),
				(t.prototype.set = function (t) {
					if (((t = t || this.defaultState), this.stateId !== t.data)) {
						for (var e = this.stateId ^ t.data, i = 0; e; )
							1 & e && this.map[i].call(this, !!(t.data & (1 << i))),
								(e >>= 1),
								i++;
						this.stateId = t.data;
					}
					for (i = 0; i < this.checks.length; i++) this.checks[i](this, t);
				}),
				(t.prototype.forceState = function (t) {
					t = t || this.defaultState;
					for (var e = 0; e < this.map.length; e++)
						this.map[e].call(this, !!(t.data & (1 << e)));
					for (e = 0; e < this.checks.length; e++) this.checks[e](this, t);
					this.stateId = t.data;
				}),
				(t.prototype.setBlend = function (e) {
					this.updateCheck(t.checkBlendMode, e),
						this.gl[e ? 'enable' : 'disable'](this.gl.BLEND);
				}),
				(t.prototype.setOffset = function (e) {
					this.updateCheck(t.checkPolygonOffset, e),
						this.gl[e ? 'enable' : 'disable'](this.gl.POLYGON_OFFSET_FILL);
				}),
				(t.prototype.setDepthTest = function (t) {
					this.gl[t ? 'enable' : 'disable'](this.gl.DEPTH_TEST);
				}),
				(t.prototype.setDepthMask = function (t) {
					this.gl.depthMask(t);
				}),
				(t.prototype.setCullFace = function (t) {
					this.gl[t ? 'enable' : 'disable'](this.gl.CULL_FACE);
				}),
				(t.prototype.setFrontFace = function (t) {
					this.gl.frontFace(this.gl[t ? 'CW' : 'CCW']);
				}),
				(t.prototype.setBlendMode = function (t) {
					if (t !== this.blendMode) {
						this.blendMode = t;
						var e = this.blendModes[t],
							i = this.gl;
						2 === e.length
							? i.blendFunc(e[0], e[1])
							: i.blendFuncSeparate(e[0], e[1], e[2], e[3]),
							6 === e.length
								? ((this._blendEq = !0), i.blendEquationSeparate(e[4], e[5]))
								: this._blendEq &&
								  ((this._blendEq = !1),
								  i.blendEquationSeparate(i.FUNC_ADD, i.FUNC_ADD));
					}
				}),
				(t.prototype.setPolygonOffset = function (t, e) {
					this.gl.polygonOffset(t, e);
				}),
				(t.prototype.reset = function () {
					this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1),
						this.forceState(this.defaultState),
						(this._blendEq = !0),
						(this.blendMode = -1),
						this.setBlendMode(0);
				}),
				(t.prototype.updateCheck = function (t, e) {
					var i = this.checks.indexOf(t);
					e && -1 === i
						? this.checks.push(t)
						: e || -1 === i || this.checks.splice(i, 1);
				}),
				(t.checkBlendMode = function (t, e) {
					t.setBlendMode(e.blendMode);
				}),
				(t.checkPolygonOffset = function (t, e) {
					t.setPolygonOffset(1, e.polygonOffset);
				}),
				(t.prototype.destroy = function () {
					this.gl = null;
				}),
				t
			);
		})(),
		TextureGCSystem$1 = (function () {
			function t(t) {
				(this.renderer = t),
					(this.count = 0),
					(this.checkCount = 0),
					(this.maxIdle = settings$2.GC_MAX_IDLE),
					(this.checkCountMax = settings$2.GC_MAX_CHECK_COUNT),
					(this.mode = settings$2.GC_MODE);
			}
			return (
				(t.prototype.postrender = function () {
					this.renderer.renderingToScreen &&
						(this.count++,
						this.mode !== GC_MODES$3.MANUAL &&
							(this.checkCount++,
							this.checkCount > this.checkCountMax &&
								((this.checkCount = 0), this.run())));
				}),
				(t.prototype.run = function () {
					for (
						var t = this.renderer.texture, e = t.managedTextures, i = !1, r = 0;
						r < e.length;
						r++
					) {
						var s = e[r];
						!s.framebuffer &&
							this.count - s.touched > this.maxIdle &&
							(t.destroyTexture(s, !0), (e[r] = null), (i = !0));
					}
					if (i) {
						var n = 0;
						for (r = 0; r < e.length; r++) null !== e[r] && (e[n++] = e[r]);
						e.length = n;
					}
				}),
				(t.prototype.unload = function (t) {
					var e = this.renderer.texture,
						i = t._texture;
					i && !i.framebuffer && e.destroyTexture(i);
					for (var r = t.children.length - 1; r >= 0; r--)
						this.unload(t.children[r]);
				}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})();
	function mapTypeAndFormatToInternalFormat$1(t) {
		var e, i, r, s, n, a, o, h, u, l, c, d, p, f, m, _, g, E, y, T, v, S, x;
		return (
			'WebGL2RenderingContext' in self &&
			t instanceof self.WebGL2RenderingContext
				? (((e = {})[TYPES$3.UNSIGNED_BYTE] =
						(((i = {})[FORMATS$3.RGBA] = t.RGBA8),
						(i[FORMATS$3.RGB] = t.RGB8),
						(i[FORMATS$3.RG] = t.RG8),
						(i[FORMATS$3.RED] = t.R8),
						(i[FORMATS$3.RGBA_INTEGER] = t.RGBA8UI),
						(i[FORMATS$3.RGB_INTEGER] = t.RGB8UI),
						(i[FORMATS$3.RG_INTEGER] = t.RG8UI),
						(i[FORMATS$3.RED_INTEGER] = t.R8UI),
						(i[FORMATS$3.ALPHA] = t.ALPHA),
						(i[FORMATS$3.LUMINANCE] = t.LUMINANCE),
						(i[FORMATS$3.LUMINANCE_ALPHA] = t.LUMINANCE_ALPHA),
						i)),
				  (e[TYPES$3.BYTE] =
						(((r = {})[FORMATS$3.RGBA] = t.RGBA8_SNORM),
						(r[FORMATS$3.RGB] = t.RGB8_SNORM),
						(r[FORMATS$3.RG] = t.RG8_SNORM),
						(r[FORMATS$3.RED] = t.R8_SNORM),
						(r[FORMATS$3.RGBA_INTEGER] = t.RGBA8I),
						(r[FORMATS$3.RGB_INTEGER] = t.RGB8I),
						(r[FORMATS$3.RG_INTEGER] = t.RG8I),
						(r[FORMATS$3.RED_INTEGER] = t.R8I),
						r)),
				  (e[TYPES$3.UNSIGNED_SHORT] =
						(((s = {})[FORMATS$3.RGBA_INTEGER] = t.RGBA16UI),
						(s[FORMATS$3.RGB_INTEGER] = t.RGB16UI),
						(s[FORMATS$3.RG_INTEGER] = t.RG16UI),
						(s[FORMATS$3.RED_INTEGER] = t.R16UI),
						(s[FORMATS$3.DEPTH_COMPONENT] = t.DEPTH_COMPONENT16),
						s)),
				  (e[TYPES$3.SHORT] =
						(((n = {})[FORMATS$3.RGBA_INTEGER] = t.RGBA16I),
						(n[FORMATS$3.RGB_INTEGER] = t.RGB16I),
						(n[FORMATS$3.RG_INTEGER] = t.RG16I),
						(n[FORMATS$3.RED_INTEGER] = t.R16I),
						n)),
				  (e[TYPES$3.UNSIGNED_INT] =
						(((a = {})[FORMATS$3.RGBA_INTEGER] = t.RGBA32UI),
						(a[FORMATS$3.RGB_INTEGER] = t.RGB32UI),
						(a[FORMATS$3.RG_INTEGER] = t.RG32UI),
						(a[FORMATS$3.RED_INTEGER] = t.R32UI),
						(a[FORMATS$3.DEPTH_COMPONENT] = t.DEPTH_COMPONENT24),
						a)),
				  (e[TYPES$3.INT] =
						(((o = {})[FORMATS$3.RGBA_INTEGER] = t.RGBA32I),
						(o[FORMATS$3.RGB_INTEGER] = t.RGB32I),
						(o[FORMATS$3.RG_INTEGER] = t.RG32I),
						(o[FORMATS$3.RED_INTEGER] = t.R32I),
						o)),
				  (e[TYPES$3.FLOAT] =
						(((h = {})[FORMATS$3.RGBA] = t.RGBA32F),
						(h[FORMATS$3.RGB] = t.RGB32F),
						(h[FORMATS$3.RG] = t.RG32F),
						(h[FORMATS$3.RED] = t.R32F),
						(h[FORMATS$3.DEPTH_COMPONENT] = t.DEPTH_COMPONENT32F),
						h)),
				  (e[TYPES$3.HALF_FLOAT] =
						(((u = {})[FORMATS$3.RGBA] = t.RGBA16F),
						(u[FORMATS$3.RGB] = t.RGB16F),
						(u[FORMATS$3.RG] = t.RG16F),
						(u[FORMATS$3.RED] = t.R16F),
						u)),
				  (e[TYPES$3.UNSIGNED_SHORT_5_6_5] =
						(((l = {})[FORMATS$3.RGB] = t.RGB565), l)),
				  (e[TYPES$3.UNSIGNED_SHORT_4_4_4_4] =
						(((c = {})[FORMATS$3.RGBA] = t.RGBA4), c)),
				  (e[TYPES$3.UNSIGNED_SHORT_5_5_5_1] =
						(((d = {})[FORMATS$3.RGBA] = t.RGB5_A1), d)),
				  (e[TYPES$3.UNSIGNED_INT_2_10_10_10_REV] =
						(((p = {})[FORMATS$3.RGBA] = t.RGB10_A2),
						(p[FORMATS$3.RGBA_INTEGER] = t.RGB10_A2UI),
						p)),
				  (e[TYPES$3.UNSIGNED_INT_10F_11F_11F_REV] =
						(((f = {})[FORMATS$3.RGB] = t.R11F_G11F_B10F), f)),
				  (e[TYPES$3.UNSIGNED_INT_5_9_9_9_REV] =
						(((m = {})[FORMATS$3.RGB] = t.RGB9_E5), m)),
				  (e[TYPES$3.UNSIGNED_INT_24_8] =
						(((_ = {})[FORMATS$3.DEPTH_STENCIL] = t.DEPTH24_STENCIL8), _)),
				  (e[TYPES$3.FLOAT_32_UNSIGNED_INT_24_8_REV] =
						(((g = {})[FORMATS$3.DEPTH_STENCIL] = t.DEPTH32F_STENCIL8), g)),
				  (x = e))
				: (((E = {})[TYPES$3.UNSIGNED_BYTE] =
						(((y = {})[FORMATS$3.RGBA] = t.RGBA),
						(y[FORMATS$3.RGB] = t.RGB),
						(y[FORMATS$3.ALPHA] = t.ALPHA),
						(y[FORMATS$3.LUMINANCE] = t.LUMINANCE),
						(y[FORMATS$3.LUMINANCE_ALPHA] = t.LUMINANCE_ALPHA),
						y)),
				  (E[TYPES$3.UNSIGNED_SHORT_5_6_5] =
						(((T = {})[FORMATS$3.RGB] = t.RGB), T)),
				  (E[TYPES$3.UNSIGNED_SHORT_4_4_4_4] =
						(((v = {})[FORMATS$3.RGBA] = t.RGBA), v)),
				  (E[TYPES$3.UNSIGNED_SHORT_5_5_5_1] =
						(((S = {})[FORMATS$3.RGBA] = t.RGBA), S)),
				  (x = E)),
			x
		);
	}
	var GLTexture$1 = function (t) {
			(this.texture = t),
				(this.width = -1),
				(this.height = -1),
				(this.dirtyId = -1),
				(this.dirtyStyleId = -1),
				(this.mipmap = !1),
				(this.wrapMode = 33071),
				(this.type = TYPES$3.UNSIGNED_BYTE),
				(this.internalFormat = FORMATS$3.RGBA),
				(this.samplerType = 0);
		},
		TextureSystem$1 = (function () {
			function t(t) {
				(this.renderer = t),
					(this.boundTextures = []),
					(this.currentLocation = -1),
					(this.managedTextures = []),
					(this._unknownBoundTextures = !1),
					(this.unknownTexture = new BaseTexture$1()),
					(this.hasIntegerTextures = !1);
			}
			return (
				(t.prototype.contextChange = function () {
					var t = (this.gl = this.renderer.gl);
					(this.CONTEXT_UID = this.renderer.CONTEXT_UID),
						(this.webGLVersion = this.renderer.context.webGLVersion),
						(this.internalFormats = mapTypeAndFormatToInternalFormat$1(t));
					var e = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
					this.boundTextures.length = e;
					for (var i = 0; i < e; i++) this.boundTextures[i] = null;
					this.emptyTextures = {};
					var r = new GLTexture$1(t.createTexture());
					for (
						t.bindTexture(t.TEXTURE_2D, r.texture),
							t.texImage2D(
								t.TEXTURE_2D,
								0,
								t.RGBA,
								1,
								1,
								0,
								t.RGBA,
								t.UNSIGNED_BYTE,
								new Uint8Array(4)
							),
							this.emptyTextures[t.TEXTURE_2D] = r,
							this.emptyTextures[t.TEXTURE_CUBE_MAP] = new GLTexture$1(
								t.createTexture()
							),
							t.bindTexture(
								t.TEXTURE_CUBE_MAP,
								this.emptyTextures[t.TEXTURE_CUBE_MAP].texture
							),
							i = 0;
						i < 6;
						i++
					)
						t.texImage2D(
							t.TEXTURE_CUBE_MAP_POSITIVE_X + i,
							0,
							t.RGBA,
							1,
							1,
							0,
							t.RGBA,
							t.UNSIGNED_BYTE,
							null
						);
					for (
						t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR),
							t.texParameteri(
								t.TEXTURE_CUBE_MAP,
								t.TEXTURE_MIN_FILTER,
								t.LINEAR
							),
							i = 0;
						i < this.boundTextures.length;
						i++
					)
						this.bind(null, i);
				}),
				(t.prototype.bind = function (t, e) {
					void 0 === e && (e = 0);
					var i = this.gl;
					if (
						(t = null == t ? void 0 : t.castToBaseTexture()) &&
						t.valid &&
						!t.parentTextureArray
					) {
						t.touched = this.renderer.textureGC.count;
						var r = t._glTextures[this.CONTEXT_UID] || this.initTexture(t);
						this.boundTextures[e] !== t &&
							(this.currentLocation !== e &&
								((this.currentLocation = e), i.activeTexture(i.TEXTURE0 + e)),
							i.bindTexture(t.target, r.texture)),
							r.dirtyId !== t.dirtyId &&
								(this.currentLocation !== e &&
									((this.currentLocation = e), i.activeTexture(i.TEXTURE0 + e)),
								this.updateTexture(t)),
							(this.boundTextures[e] = t);
					} else
						this.currentLocation !== e &&
							((this.currentLocation = e), i.activeTexture(i.TEXTURE0 + e)),
							i.bindTexture(
								i.TEXTURE_2D,
								this.emptyTextures[i.TEXTURE_2D].texture
							),
							(this.boundTextures[e] = null);
				}),
				(t.prototype.reset = function () {
					(this._unknownBoundTextures = !0),
						(this.hasIntegerTextures = !1),
						(this.currentLocation = -1);
					for (var t = 0; t < this.boundTextures.length; t++)
						this.boundTextures[t] = this.unknownTexture;
				}),
				(t.prototype.unbind = function (t) {
					var e = this.gl,
						i = this.boundTextures;
					if (this._unknownBoundTextures) {
						this._unknownBoundTextures = !1;
						for (var r = 0; r < i.length; r++)
							i[r] === this.unknownTexture && this.bind(null, r);
					}
					for (r = 0; r < i.length; r++)
						i[r] === t &&
							(this.currentLocation !== r &&
								(e.activeTexture(e.TEXTURE0 + r), (this.currentLocation = r)),
							e.bindTexture(t.target, this.emptyTextures[t.target].texture),
							(i[r] = null));
				}),
				(t.prototype.ensureSamplerType = function (t) {
					var e = this,
						i = e.boundTextures,
						r = e.hasIntegerTextures,
						s = e.CONTEXT_UID;
					if (r)
						for (var n = t - 1; n >= 0; --n) {
							var a = i[n];
							a &&
								a._glTextures[s].samplerType !== SAMPLER_TYPES$3.FLOAT &&
								this.renderer.texture.unbind(a);
						}
				}),
				(t.prototype.initTexture = function (t) {
					var e = new GLTexture$1(this.gl.createTexture());
					return (
						(e.dirtyId = -1),
						(t._glTextures[this.CONTEXT_UID] = e),
						this.managedTextures.push(t),
						t.on('dispose', this.destroyTexture, this),
						e
					);
				}),
				(t.prototype.initTextureType = function (t, e) {
					var i, r;
					(e.internalFormat =
						null !==
							(r =
								null === (i = this.internalFormats[t.type]) || void 0 === i
									? void 0
									: i[t.format]) && void 0 !== r
							? r
							: t.format),
						2 === this.webGLVersion && t.type === TYPES$3.HALF_FLOAT
							? (e.type = this.gl.HALF_FLOAT)
							: (e.type = t.type);
				}),
				(t.prototype.updateTexture = function (t) {
					var e = t._glTextures[this.CONTEXT_UID];
					if (e) {
						var i = this.renderer;
						if (
							(this.initTextureType(t, e),
							t.resource && t.resource.upload(i, t, e))
						)
							e.samplerType !== SAMPLER_TYPES$3.FLOAT &&
								(this.hasIntegerTextures = !0);
						else {
							var r = t.realWidth,
								s = t.realHeight,
								n = i.gl;
							(e.width !== r || e.height !== s || e.dirtyId < 0) &&
								((e.width = r),
								(e.height = s),
								n.texImage2D(
									t.target,
									0,
									e.internalFormat,
									r,
									s,
									0,
									t.format,
									e.type,
									null
								));
						}
						t.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(t),
							(e.dirtyId = t.dirtyId);
					}
				}),
				(t.prototype.destroyTexture = function (t, e) {
					var i = this.gl;
					if (
						(t = t.castToBaseTexture())._glTextures[this.CONTEXT_UID] &&
						(this.unbind(t),
						i.deleteTexture(t._glTextures[this.CONTEXT_UID].texture),
						t.off('dispose', this.destroyTexture, this),
						delete t._glTextures[this.CONTEXT_UID],
						!e)
					) {
						var r = this.managedTextures.indexOf(t);
						-1 !== r && removeItems$1(this.managedTextures, r, 1);
					}
				}),
				(t.prototype.updateTextureStyle = function (t) {
					var e = t._glTextures[this.CONTEXT_UID];
					e &&
						((t.mipmap !== MIPMAP_MODES$3.POW2 && 2 === this.webGLVersion) ||
						t.isPowerOfTwo
							? (e.mipmap = t.mipmap >= 1)
							: (e.mipmap = !1),
						2 === this.webGLVersion || t.isPowerOfTwo
							? (e.wrapMode = t.wrapMode)
							: (e.wrapMode = WRAP_MODES$3.CLAMP),
						(t.resource && t.resource.style(this.renderer, t, e)) ||
							this.setStyle(t, e),
						(e.dirtyStyleId = t.dirtyStyleId));
				}),
				(t.prototype.setStyle = function (t, e) {
					var i = this.gl;
					if (
						(e.mipmap &&
							t.mipmap !== MIPMAP_MODES$3.ON_MANUAL &&
							i.generateMipmap(t.target),
						i.texParameteri(t.target, i.TEXTURE_WRAP_S, e.wrapMode),
						i.texParameteri(t.target, i.TEXTURE_WRAP_T, e.wrapMode),
						e.mipmap)
					) {
						i.texParameteri(
							t.target,
							i.TEXTURE_MIN_FILTER,
							t.scaleMode === SCALE_MODES$3.LINEAR
								? i.LINEAR_MIPMAP_LINEAR
								: i.NEAREST_MIPMAP_NEAREST
						);
						var r = this.renderer.context.extensions.anisotropicFiltering;
						if (
							r &&
							t.anisotropicLevel > 0 &&
							t.scaleMode === SCALE_MODES$3.LINEAR
						) {
							var s = Math.min(
								t.anisotropicLevel,
								i.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
							);
							i.texParameterf(t.target, r.TEXTURE_MAX_ANISOTROPY_EXT, s);
						}
					} else
						i.texParameteri(
							t.target,
							i.TEXTURE_MIN_FILTER,
							t.scaleMode === SCALE_MODES$3.LINEAR ? i.LINEAR : i.NEAREST
						);
					i.texParameteri(
						t.target,
						i.TEXTURE_MAG_FILTER,
						t.scaleMode === SCALE_MODES$3.LINEAR ? i.LINEAR : i.NEAREST
					);
				}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})(),
		tempMatrix$2$1 = new Matrix$1(),
		AbstractRenderer$1 = (function (t) {
			function e(e, i) {
				void 0 === e && (e = RENDERER_TYPE$3.UNKNOWN);
				var r = t.call(this) || this;
				return (
					(i = Object.assign({}, settings$2.RENDER_OPTIONS, i)),
					(r.options = i),
					(r.type = e),
					(r.screen = new Rectangle$2(0, 0, i.width, i.height)),
					(r.view = i.view || document.createElement('canvas')),
					(r.resolution = i.resolution || settings$2.RESOLUTION),
					(r.useContextAlpha = i.useContextAlpha),
					(r.autoDensity = !!i.autoDensity),
					(r.preserveDrawingBuffer = i.preserveDrawingBuffer),
					(r.clearBeforeRender = i.clearBeforeRender),
					(r._backgroundColor = 0),
					(r._backgroundColorRgba = [0, 0, 0, 1]),
					(r._backgroundColorString = '#000000'),
					(r.backgroundColor = i.backgroundColor || r._backgroundColor),
					(r.backgroundAlpha = i.backgroundAlpha),
					void 0 !== i.transparent &&
						(deprecation$1(
							'6.0.0',
							'Option transparent is deprecated, please use backgroundAlpha instead.'
						),
						(r.useContextAlpha = i.transparent),
						(r.backgroundAlpha = i.transparent ? 0 : 1)),
					(r._lastObjectRendered = null),
					(r.plugins = {}),
					r
				);
			}
			return (
				__extends$b(e, t),
				(e.prototype.initPlugins = function (t) {
					for (var e in t) this.plugins[e] = new t[e](this);
				}),
				Object.defineProperty(e.prototype, 'width', {
					get: function () {
						return this.view.width;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'height', {
					get: function () {
						return this.view.height;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.resize = function (t, e) {
					(this.view.width = Math.round(t * this.resolution)),
						(this.view.height = Math.round(e * this.resolution));
					var i = this.view.width / this.resolution,
						r = this.view.height / this.resolution;
					(this.screen.width = i),
						(this.screen.height = r),
						this.autoDensity &&
							((this.view.style.width = i + 'px'),
							(this.view.style.height = r + 'px')),
						this.emit('resize', i, r);
				}),
				(e.prototype.generateTexture = function (t, e, i, r) {
					void 0 === e && (e = {}),
						'number' == typeof e &&
							(deprecation$1(
								'6.1.0',
								'generateTexture options (scaleMode, resolution, region) are now object options.'
							),
							(e = { scaleMode: e, resolution: i, region: r }));
					var s = e.region,
						n = __rest$1(e, ['region']);
					0 === (r = s || t.getLocalBounds(null, !0)).width && (r.width = 1),
						0 === r.height && (r.height = 1);
					var a = RenderTexture$1.create(
						__assign$1({ width: r.width, height: r.height }, n)
					);
					return (
						(tempMatrix$2$1.tx = -r.x),
						(tempMatrix$2$1.ty = -r.y),
						this.render(t, {
							renderTexture: a,
							clear: !1,
							transform: tempMatrix$2$1,
							skipUpdateTransform: !!t.parent,
						}),
						a
					);
				}),
				(e.prototype.destroy = function (t) {
					for (var e in this.plugins)
						this.plugins[e].destroy(), (this.plugins[e] = null);
					t &&
						this.view.parentNode &&
						this.view.parentNode.removeChild(this.view);
					var i = this;
					(i.plugins = null),
						(i.type = RENDERER_TYPE$3.UNKNOWN),
						(i.view = null),
						(i.screen = null),
						(i._tempDisplayObjectParent = null),
						(i.options = null),
						(this._backgroundColorRgba = null),
						(this._backgroundColorString = null),
						(this._lastObjectRendered = null);
				}),
				Object.defineProperty(e.prototype, 'backgroundColor', {
					get: function () {
						return this._backgroundColor;
					},
					set: function (t) {
						(this._backgroundColor = t),
							(this._backgroundColorString = hex2string$1(t)),
							hex2rgb$1(t, this._backgroundColorRgba);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'backgroundAlpha', {
					get: function () {
						return this._backgroundColorRgba[3];
					},
					set: function (t) {
						this._backgroundColorRgba[3] = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				e
			);
		})(eventemitter3$1),
		GLBuffer$1 = function (t) {
			(this.buffer = t || null),
				(this.updateID = -1),
				(this.byteLength = -1),
				(this.refCount = 0);
		},
		BufferSystem$1 = (function () {
			function t(t) {
				(this.renderer = t),
					(this.managedBuffers = {}),
					(this.boundBufferBases = {});
			}
			return (
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				(t.prototype.contextChange = function () {
					this.disposeAll(!0),
						(this.gl = this.renderer.gl),
						(this.CONTEXT_UID = this.renderer.CONTEXT_UID);
				}),
				(t.prototype.bind = function (t) {
					var e = this.gl,
						i = this.CONTEXT_UID,
						r = t._glBuffers[i] || this.createGLBuffer(t);
					e.bindBuffer(t.type, r.buffer);
				}),
				(t.prototype.bindBufferBase = function (t, e) {
					var i = this.gl,
						r = this.CONTEXT_UID;
					if (this.boundBufferBases[e] !== t) {
						var s = t._glBuffers[r] || this.createGLBuffer(t);
						(this.boundBufferBases[e] = t),
							i.bindBufferBase(i.UNIFORM_BUFFER, e, s.buffer);
					}
				}),
				(t.prototype.bindBufferRange = function (t, e, i) {
					var r = this.gl,
						s = this.CONTEXT_UID;
					i = i || 0;
					var n = t._glBuffers[s] || this.createGLBuffer(t);
					r.bindBufferRange(r.UNIFORM_BUFFER, e || 0, n.buffer, 256 * i, 256);
				}),
				(t.prototype.update = function (t) {
					var e = this.gl,
						i = this.CONTEXT_UID,
						r = t._glBuffers[i];
					if (t._updateID !== r.updateID)
						if (
							((r.updateID = t._updateID),
							e.bindBuffer(t.type, r.buffer),
							r.byteLength >= t.data.byteLength)
						)
							e.bufferSubData(t.type, 0, t.data);
						else {
							var s = t.static ? e.STATIC_DRAW : e.DYNAMIC_DRAW;
							(r.byteLength = t.data.byteLength),
								e.bufferData(t.type, t.data, s);
						}
				}),
				(t.prototype.dispose = function (t, e) {
					if (this.managedBuffers[t.id]) {
						delete this.managedBuffers[t.id];
						var i = t._glBuffers[this.CONTEXT_UID],
							r = this.gl;
						t.disposeRunner.remove(this),
							i &&
								(e || r.deleteBuffer(i.buffer),
								delete t._glBuffers[this.CONTEXT_UID]);
					}
				}),
				(t.prototype.disposeAll = function (t) {
					for (
						var e = Object.keys(this.managedBuffers), i = 0;
						i < e.length;
						i++
					)
						this.dispose(this.managedBuffers[e[i]], t);
				}),
				(t.prototype.createGLBuffer = function (t) {
					var e = this.CONTEXT_UID,
						i = this.gl;
					return (
						(t._glBuffers[e] = new GLBuffer$1(i.createBuffer())),
						(this.managedBuffers[t.id] = t),
						t.disposeRunner.add(this),
						t._glBuffers[e]
					);
				}),
				t
			);
		})(),
		Renderer = (function (t) {
			function e(i) {
				var r = t.call(this, RENDERER_TYPE$3.WEBGL, i) || this;
				return (
					(i = r.options),
					(r.gl = null),
					(r.CONTEXT_UID = 0),
					(r.runners = {
						destroy: new Runner$1('destroy'),
						contextChange: new Runner$1('contextChange'),
						reset: new Runner$1('reset'),
						update: new Runner$1('update'),
						postrender: new Runner$1('postrender'),
						prerender: new Runner$1('prerender'),
						resize: new Runner$1('resize'),
					}),
					r.runners.contextChange.add(r),
					(r.globalUniforms = new UniformGroup$1(
						{ projectionMatrix: new Matrix$1() },
						!0
					)),
					r
						.addSystem(MaskSystem$1, 'mask')
						.addSystem(ContextSystem$1, 'context')
						.addSystem(StateSystem$1, 'state')
						.addSystem(ShaderSystem$1, 'shader')
						.addSystem(TextureSystem$1, 'texture')
						.addSystem(BufferSystem$1, 'buffer')
						.addSystem(GeometrySystem$1, 'geometry')
						.addSystem(FramebufferSystem$1, 'framebuffer')
						.addSystem(ScissorSystem$1, 'scissor')
						.addSystem(StencilSystem$1, 'stencil')
						.addSystem(ProjectionSystem$1, 'projection')
						.addSystem(TextureGCSystem$1, 'textureGC')
						.addSystem(FilterSystem$1, 'filter')
						.addSystem(RenderTextureSystem$1, 'renderTexture')
						.addSystem(BatchSystem$1, 'batch'),
					r.initPlugins(e.__plugins),
					(r.multisample = void 0),
					i.context
						? r.context.initFromContext(i.context)
						: r.context.initFromOptions({
								alpha: !!r.useContextAlpha,
								antialias: i.antialias,
								premultipliedAlpha:
									r.useContextAlpha && 'notMultiplied' !== r.useContextAlpha,
								stencil: !0,
								preserveDrawingBuffer: i.preserveDrawingBuffer,
								powerPreference: r.options.powerPreference,
						  }),
					(r.renderingToScreen = !0),
					sayHello$1(2 === r.context.webGLVersion ? 'WebGL 2' : 'WebGL 1'),
					r.resize(r.options.width, r.options.height),
					r
				);
			}
			return (
				__extends$b(e, t),
				(e.create = function (t) {
					if (isWebGLSupported$1()) return new e(t);
					throw new Error(
						'WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.'
					);
				}),
				(e.prototype.contextChange = function () {
					var t,
						e = this.gl;
					if (1 === this.context.webGLVersion) {
						var i = e.getParameter(e.FRAMEBUFFER_BINDING);
						e.bindFramebuffer(e.FRAMEBUFFER, null),
							(t = e.getParameter(e.SAMPLES)),
							e.bindFramebuffer(e.FRAMEBUFFER, i);
					} else
						(i = e.getParameter(e.DRAW_FRAMEBUFFER_BINDING)),
							e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
							(t = e.getParameter(e.SAMPLES)),
							e.bindFramebuffer(e.DRAW_FRAMEBUFFER, i);
					t >= MSAA_QUALITY$3.HIGH
						? (this.multisample = MSAA_QUALITY$3.HIGH)
						: t >= MSAA_QUALITY$3.MEDIUM
						? (this.multisample = MSAA_QUALITY$3.MEDIUM)
						: t >= MSAA_QUALITY$3.LOW
						? (this.multisample = MSAA_QUALITY$3.LOW)
						: (this.multisample = MSAA_QUALITY$3.NONE);
				}),
				(e.prototype.addSystem = function (t, e) {
					var i = new t(this);
					if (this[e])
						throw new Error('Whoops! The name "' + e + '" is already in use');
					for (var r in ((this[e] = i), this.runners)) this.runners[r].add(i);
					return this;
				}),
				(e.prototype.render = function (t, e) {
					var i, r, s, n;
					if (
						(e &&
							(e instanceof RenderTexture$1
								? (deprecation$1(
										'6.0.0',
										'Renderer#render arguments changed, use options instead.'
								  ),
								  (i = e),
								  (r = arguments[2]),
								  (s = arguments[3]),
								  (n = arguments[4]))
								: ((i = e.renderTexture),
								  (r = e.clear),
								  (s = e.transform),
								  (n = e.skipUpdateTransform))),
						(this.renderingToScreen = !i),
						this.runners.prerender.emit(),
						this.emit('prerender'),
						(this.projection.transform = s),
						!this.context.isLost)
					) {
						if ((i || (this._lastObjectRendered = t), !n)) {
							var a = t.enableTempParent();
							t.updateTransform(), t.disableTempParent(a);
						}
						this.renderTexture.bind(i),
							this.batch.currentRenderer.start(),
							(void 0 !== r ? r : this.clearBeforeRender) &&
								this.renderTexture.clear(),
							t.render(this),
							this.batch.currentRenderer.flush(),
							i && i.baseTexture.update(),
							this.runners.postrender.emit(),
							(this.projection.transform = null),
							this.emit('postrender');
					}
				}),
				(e.prototype.generateTexture = function (e, i, r, s) {
					void 0 === i && (i = {});
					var n = t.prototype.generateTexture.call(this, e, i, r, s);
					return this.framebuffer.blit(), n;
				}),
				(e.prototype.resize = function (e, i) {
					t.prototype.resize.call(this, e, i),
						this.runners.resize.emit(this.screen.height, this.screen.width);
				}),
				(e.prototype.reset = function () {
					return this.runners.reset.emit(), this;
				}),
				(e.prototype.clear = function () {
					this.renderTexture.bind(), this.renderTexture.clear();
				}),
				(e.prototype.destroy = function (e) {
					for (var i in (this.runners.destroy.emit(), this.runners))
						this.runners[i].destroy();
					t.prototype.destroy.call(this, e), (this.gl = null);
				}),
				Object.defineProperty(e.prototype, 'extract', {
					get: function () {
						return (
							deprecation$1(
								'6.0.0',
								'Renderer#extract has been deprecated, please use Renderer#plugins.extract instead.'
							),
							this.plugins.extract
						);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.registerPlugin = function (t, i) {
					(e.__plugins = e.__plugins || {}), (e.__plugins[t] = i);
				}),
				e
			);
		})(AbstractRenderer$1),
		BatchDrawCall$1 = function () {
			(this.texArray = null),
				(this.blend = 0),
				(this.type = DRAW_MODES$3.TRIANGLES),
				(this.start = 0),
				(this.size = 0),
				(this.data = null);
		},
		BatchTextureArray$1 = (function () {
			function t() {
				(this.elements = []), (this.ids = []), (this.count = 0);
			}
			return (
				(t.prototype.clear = function () {
					for (var t = 0; t < this.count; t++) this.elements[t] = null;
					this.count = 0;
				}),
				t
			);
		})(),
		ViewableBuffer$1 = (function () {
			function t(t) {
				'number' == typeof t
					? (this.rawBinaryData = new ArrayBuffer(t))
					: t instanceof Uint8Array
					? (this.rawBinaryData = t.buffer)
					: (this.rawBinaryData = t),
					(this.uint32View = new Uint32Array(this.rawBinaryData)),
					(this.float32View = new Float32Array(this.rawBinaryData));
			}
			return (
				Object.defineProperty(t.prototype, 'int8View', {
					get: function () {
						return (
							this._int8View ||
								(this._int8View = new Int8Array(this.rawBinaryData)),
							this._int8View
						);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'uint8View', {
					get: function () {
						return (
							this._uint8View ||
								(this._uint8View = new Uint8Array(this.rawBinaryData)),
							this._uint8View
						);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'int16View', {
					get: function () {
						return (
							this._int16View ||
								(this._int16View = new Int16Array(this.rawBinaryData)),
							this._int16View
						);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'uint16View', {
					get: function () {
						return (
							this._uint16View ||
								(this._uint16View = new Uint16Array(this.rawBinaryData)),
							this._uint16View
						);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'int32View', {
					get: function () {
						return (
							this._int32View ||
								(this._int32View = new Int32Array(this.rawBinaryData)),
							this._int32View
						);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.view = function (t) {
					return this[t + 'View'];
				}),
				(t.prototype.destroy = function () {
					(this.rawBinaryData = null),
						(this._int8View = null),
						(this._uint8View = null),
						(this._int16View = null),
						(this._uint16View = null),
						(this._int32View = null),
						(this.uint32View = null),
						(this.float32View = null);
				}),
				(t.sizeOf = function (t) {
					switch (t) {
						case 'int8':
						case 'uint8':
							return 1;
						case 'int16':
						case 'uint16':
							return 2;
						case 'int32':
						case 'uint32':
						case 'float32':
							return 4;
						default:
							throw new Error(t + " isn't a valid view type");
					}
				}),
				t
			);
		})(),
		AbstractBatchRenderer$1 = (function (t) {
			function e(e) {
				var i = t.call(this, e) || this;
				return (
					(i.shaderGenerator = null),
					(i.geometryClass = null),
					(i.vertexSize = null),
					(i.state = State$1.for2d()),
					(i.size = 4 * settings$2.SPRITE_BATCH_SIZE),
					(i._vertexCount = 0),
					(i._indexCount = 0),
					(i._bufferedElements = []),
					(i._bufferedTextures = []),
					(i._bufferSize = 0),
					(i._shader = null),
					(i._packedGeometries = []),
					(i._packedGeometryPoolSize = 2),
					(i._flushId = 0),
					(i._aBuffers = {}),
					(i._iBuffers = {}),
					(i.MAX_TEXTURES = 1),
					i.renderer.on('prerender', i.onPrerender, i),
					e.runners.contextChange.add(i),
					(i._dcIndex = 0),
					(i._aIndex = 0),
					(i._iIndex = 0),
					(i._attributeBuffer = null),
					(i._indexBuffer = null),
					(i._tempBoundTextures = []),
					i
				);
			}
			return (
				__extends$b(e, t),
				(e.prototype.contextChange = function () {
					var t = this.renderer.gl;
					settings$2.PREFER_ENV === ENV$3.WEBGL_LEGACY
						? (this.MAX_TEXTURES = 1)
						: ((this.MAX_TEXTURES = Math.min(
								t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
								settings$2.SPRITE_MAX_TEXTURES
						  )),
						  (this.MAX_TEXTURES = checkMaxIfStatementsInShader$1(
								this.MAX_TEXTURES,
								t
						  ))),
						(this._shader = this.shaderGenerator.generateShader(
							this.MAX_TEXTURES
						));
					for (var e = 0; e < this._packedGeometryPoolSize; e++)
						this._packedGeometries[e] = new this.geometryClass();
					this.initFlushBuffers();
				}),
				(e.prototype.initFlushBuffers = function () {
					for (
						var t = e._drawCallPool,
							i = e._textureArrayPool,
							r = this.size / 4,
							s = Math.floor(r / this.MAX_TEXTURES) + 1;
						t.length < r;

					)
						t.push(new BatchDrawCall$1());
					for (; i.length < s; ) i.push(new BatchTextureArray$1());
					for (var n = 0; n < this.MAX_TEXTURES; n++)
						this._tempBoundTextures[n] = null;
				}),
				(e.prototype.onPrerender = function () {
					this._flushId = 0;
				}),
				(e.prototype.render = function (t) {
					t._texture.valid &&
						(this._vertexCount + t.vertexData.length / 2 > this.size &&
							this.flush(),
						(this._vertexCount += t.vertexData.length / 2),
						(this._indexCount += t.indices.length),
						(this._bufferedTextures[this._bufferSize] = t._texture.baseTexture),
						(this._bufferedElements[this._bufferSize++] = t));
				}),
				(e.prototype.buildTexturesAndDrawCalls = function () {
					var t = this._bufferedTextures,
						i = this.MAX_TEXTURES,
						r = e._textureArrayPool,
						s = this.renderer.batch,
						n = this._tempBoundTextures,
						a = this.renderer.textureGC.count,
						o = ++BaseTexture$1._globalBatch,
						h = 0,
						u = r[0],
						l = 0;
					s.copyBoundTextures(n, i);
					for (var c = 0; c < this._bufferSize; ++c) {
						var d = t[c];
						(t[c] = null),
							d._batchEnabled !== o &&
								(u.count >= i &&
									(s.boundArray(u, n, o, i),
									this.buildDrawCalls(u, l, c),
									(l = c),
									(u = r[++h]),
									++o),
								(d._batchEnabled = o),
								(d.touched = a),
								(u.elements[u.count++] = d));
					}
					for (
						u.count > 0 &&
							(s.boundArray(u, n, o, i),
							this.buildDrawCalls(u, l, this._bufferSize),
							++h,
							++o),
							c = 0;
						c < n.length;
						c++
					)
						n[c] = null;
					BaseTexture$1._globalBatch = o;
				}),
				(e.prototype.buildDrawCalls = function (t, i, r) {
					var s = this,
						n = s._bufferedElements,
						a = s._attributeBuffer,
						o = s._indexBuffer,
						h = s.vertexSize,
						u = e._drawCallPool,
						l = this._dcIndex,
						c = this._aIndex,
						d = this._iIndex,
						p = u[l];
					(p.start = this._iIndex), (p.texArray = t);
					for (var f = i; f < r; ++f) {
						var m = n[f],
							_ = m._texture.baseTexture,
							g = premultiplyBlendMode$1[_.alphaMode ? 1 : 0][m.blendMode];
						(n[f] = null),
							i < f &&
								p.blend !== g &&
								((p.size = d - p.start),
								(i = f),
								((p = u[++l]).texArray = t),
								(p.start = d)),
							this.packInterleavedGeometry(m, a, o, c, d),
							(c += (m.vertexData.length / 2) * h),
							(d += m.indices.length),
							(p.blend = g);
					}
					i < r && ((p.size = d - p.start), ++l),
						(this._dcIndex = l),
						(this._aIndex = c),
						(this._iIndex = d);
				}),
				(e.prototype.bindAndClearTexArray = function (t) {
					for (var e = this.renderer.texture, i = 0; i < t.count; i++)
						e.bind(t.elements[i], t.ids[i]), (t.elements[i] = null);
					t.count = 0;
				}),
				(e.prototype.updateGeometry = function () {
					var t = this,
						e = t._packedGeometries,
						i = t._attributeBuffer,
						r = t._indexBuffer;
					settings$2.CAN_UPLOAD_SAME_BUFFER
						? (e[this._flushId]._buffer.update(i.rawBinaryData),
						  e[this._flushId]._indexBuffer.update(r),
						  this.renderer.geometry.updateBuffers())
						: (this._packedGeometryPoolSize <= this._flushId &&
								(this._packedGeometryPoolSize++,
								(e[this._flushId] = new this.geometryClass())),
						  e[this._flushId]._buffer.update(i.rawBinaryData),
						  e[this._flushId]._indexBuffer.update(r),
						  this.renderer.geometry.bind(e[this._flushId]),
						  this.renderer.geometry.updateBuffers(),
						  this._flushId++);
				}),
				(e.prototype.drawBatches = function () {
					for (
						var t = this._dcIndex,
							i = this.renderer,
							r = i.gl,
							s = i.state,
							n = e._drawCallPool,
							a = null,
							o = 0;
						o < t;
						o++
					) {
						var h = n[o],
							u = h.texArray,
							l = h.type,
							c = h.size,
							d = h.start,
							p = h.blend;
						a !== u && ((a = u), this.bindAndClearTexArray(u)),
							(this.state.blendMode = p),
							s.set(this.state),
							r.drawElements(l, c, r.UNSIGNED_SHORT, 2 * d);
					}
				}),
				(e.prototype.flush = function () {
					0 !== this._vertexCount &&
						((this._attributeBuffer = this.getAttributeBuffer(
							this._vertexCount
						)),
						(this._indexBuffer = this.getIndexBuffer(this._indexCount)),
						(this._aIndex = 0),
						(this._iIndex = 0),
						(this._dcIndex = 0),
						this.buildTexturesAndDrawCalls(),
						this.updateGeometry(),
						this.drawBatches(),
						(this._bufferSize = 0),
						(this._vertexCount = 0),
						(this._indexCount = 0));
				}),
				(e.prototype.start = function () {
					this.renderer.state.set(this.state),
						this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES),
						this.renderer.shader.bind(this._shader),
						settings$2.CAN_UPLOAD_SAME_BUFFER &&
							this.renderer.geometry.bind(
								this._packedGeometries[this._flushId]
							);
				}),
				(e.prototype.stop = function () {
					this.flush();
				}),
				(e.prototype.destroy = function () {
					for (var e = 0; e < this._packedGeometryPoolSize; e++)
						this._packedGeometries[e] && this._packedGeometries[e].destroy();
					this.renderer.off('prerender', this.onPrerender, this),
						(this._aBuffers = null),
						(this._iBuffers = null),
						(this._packedGeometries = null),
						(this._attributeBuffer = null),
						(this._indexBuffer = null),
						this._shader && (this._shader.destroy(), (this._shader = null)),
						t.prototype.destroy.call(this);
				}),
				(e.prototype.getAttributeBuffer = function (t) {
					var e = nextPow2$1(Math.ceil(t / 8)),
						i = log2$1(e),
						r = 8 * e;
					this._aBuffers.length <= i && (this._iBuffers.length = i + 1);
					var s = this._aBuffers[r];
					return (
						s ||
							(this._aBuffers[r] = s =
								new ViewableBuffer$1(r * this.vertexSize * 4)),
						s
					);
				}),
				(e.prototype.getIndexBuffer = function (t) {
					var e = nextPow2$1(Math.ceil(t / 12)),
						i = log2$1(e),
						r = 12 * e;
					this._iBuffers.length <= i && (this._iBuffers.length = i + 1);
					var s = this._iBuffers[i];
					return s || (this._iBuffers[i] = s = new Uint16Array(r)), s;
				}),
				(e.prototype.packInterleavedGeometry = function (t, e, i, r, s) {
					for (
						var n = e.uint32View,
							a = e.float32View,
							o = r / this.vertexSize,
							h = t.uvs,
							u = t.indices,
							l = t.vertexData,
							c = t._texture.baseTexture._batchLocation,
							d = Math.min(t.worldAlpha, 1),
							p =
								d < 1 && t._texture.baseTexture.alphaMode
									? premultiplyTint$1(t._tintRGB, d)
									: t._tintRGB + ((255 * d) << 24),
							f = 0;
						f < l.length;
						f += 2
					)
						(a[r++] = l[f]),
							(a[r++] = l[f + 1]),
							(a[r++] = h[f]),
							(a[r++] = h[f + 1]),
							(n[r++] = p),
							(a[r++] = c);
					for (f = 0; f < u.length; f++) i[s++] = o + u[f];
				}),
				(e._drawCallPool = []),
				(e._textureArrayPool = []),
				e
			);
		})(ObjectRenderer$1),
		BatchShaderGenerator$1 = (function () {
			function t(t, e) {
				if (
					((this.vertexSrc = t),
					(this.fragTemplate = e),
					(this.programCache = {}),
					(this.defaultGroupCache = {}),
					e.indexOf('%count%') < 0)
				)
					throw new Error('Fragment template must contain "%count%".');
				if (e.indexOf('%forloop%') < 0)
					throw new Error('Fragment template must contain "%forloop%".');
			}
			return (
				(t.prototype.generateShader = function (t) {
					if (!this.programCache[t]) {
						for (var e = new Int32Array(t), i = 0; i < t; i++) e[i] = i;
						this.defaultGroupCache[t] = UniformGroup$1.from(
							{ uSamplers: e },
							!0
						);
						var r = this.fragTemplate;
						(r = (r = r.replace(/%count%/gi, '' + t)).replace(
							/%forloop%/gi,
							this.generateSampleSrc(t)
						)),
							(this.programCache[t] = new Program$1(this.vertexSrc, r));
					}
					var s = {
						tint: new Float32Array([1, 1, 1, 1]),
						translationMatrix: new Matrix$1(),
						default: this.defaultGroupCache[t],
					};
					return new Shader$1(this.programCache[t], s);
				}),
				(t.prototype.generateSampleSrc = function (t) {
					var e = '';
					(e += '\n'), (e += '\n');
					for (var i = 0; i < t; i++)
						i > 0 && (e += '\nelse '),
							i < t - 1 && (e += 'if(vTextureId < ' + i + '.5)'),
							(e += '\n{'),
							(e +=
								'\n\tcolor = texture2D(uSamplers[' + i + '], vTextureCoord);'),
							(e += '\n}');
					return (e += '\n') + '\n';
				}),
				t
			);
		})(),
		BatchGeometry$1 = (function (t) {
			function e(e) {
				void 0 === e && (e = !1);
				var i = t.call(this) || this;
				return (
					(i._buffer = new Buffer$1(null, e, !1)),
					(i._indexBuffer = new Buffer$1(null, e, !0)),
					i
						.addAttribute('aVertexPosition', i._buffer, 2, !1, TYPES$3.FLOAT)
						.addAttribute('aTextureCoord', i._buffer, 2, !1, TYPES$3.FLOAT)
						.addAttribute('aColor', i._buffer, 4, !0, TYPES$3.UNSIGNED_BYTE)
						.addAttribute('aTextureId', i._buffer, 1, !0, TYPES$3.FLOAT)
						.addIndex(i._indexBuffer),
					i
				);
			}
			return __extends$b(e, t), e;
		})(Geometry$1),
		defaultVertex$3$1 =
			'precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n',
		defaultFragment$2$1 =
			'varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n',
		BatchPluginFactory$1 = (function () {
			function t() {}
			return (
				(t.create = function (t) {
					var e = Object.assign(
							{
								vertex: defaultVertex$3$1,
								fragment: defaultFragment$2$1,
								geometryClass: BatchGeometry$1,
								vertexSize: 6,
							},
							t
						),
						i = e.vertex,
						r = e.fragment,
						s = e.vertexSize,
						n = e.geometryClass;
					return (function (t) {
						function e(e) {
							var a = t.call(this, e) || this;
							return (
								(a.shaderGenerator = new BatchShaderGenerator$1(i, r)),
								(a.geometryClass = n),
								(a.vertexSize = s),
								a
							);
						}
						return __extends$b(e, t), e;
					})(AbstractBatchRenderer$1);
				}),
				Object.defineProperty(t, 'defaultVertexSrc', {
					get: function () {
						return defaultVertex$3$1;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t, 'defaultFragmentTemplate', {
					get: function () {
						return defaultFragment$2$1;
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			);
		})();
	BatchPluginFactory$1.create();
	class CanvasTileRenderer {
		__init() {
			this.tileAnim = [0, 0];
		}
		__init2() {
			this.dontUseTransform = !1;
		}
		constructor(t) {
			CanvasTileRenderer.prototype.__init.call(this),
				CanvasTileRenderer.prototype.__init2.call(this),
				(this.renderer = t),
				(this.tileAnim = [0, 0]);
		}
		static getInstance(t) {
			return (
				t.plugins.tilemap || (t.plugins.tilemap = new CanvasTileRenderer(t)),
				t.plugins.tilemap
			);
		}
	}
	const settings$1 = {
		TEXTURES_PER_TILEMAP: 16,
		TEXTILE_DIMEN: 1024,
		TEXTILE_UNITS: 1,
		TEXTILE_SCALE_MODE: SCALE_MODES$3.LINEAR,
		use32bitIndex: !1,
		DO_CLEAR: !0,
		get maxTextures() {
			return this.MAX_TEXTURES;
		},
		set maxTextures(t) {
			this.MAX_TEXTURES = t;
		},
		get boundSize() {
			return this.TEXTURE_TILE_DIMEN;
		},
		set boundSize(t) {
			this.TILE_TEXTURE_DIMEN = t;
		},
		get boundCountPerBuffer() {
			return this.TEXTILE_UNITS;
		},
		set boundCountPerBuffer(t) {
			this.TEXTILE_UNITS = t;
		},
	};
	function _nullishCoalesce(t, e) {
		return null != t ? t : e();
	}
	var POINT_STRUCT, POINT_STRUCT2;
	(POINT_STRUCT2 = POINT_STRUCT || (POINT_STRUCT = {})),
		(POINT_STRUCT2[(POINT_STRUCT2.U = 0)] = 'U'),
		(POINT_STRUCT2[(POINT_STRUCT2.V = 1)] = 'V'),
		(POINT_STRUCT2[(POINT_STRUCT2.X = 2)] = 'X'),
		(POINT_STRUCT2[(POINT_STRUCT2.Y = 3)] = 'Y'),
		(POINT_STRUCT2[(POINT_STRUCT2.TILE_WIDTH = 4)] = 'TILE_WIDTH'),
		(POINT_STRUCT2[(POINT_STRUCT2.TILE_HEIGHT = 5)] = 'TILE_HEIGHT'),
		(POINT_STRUCT2[(POINT_STRUCT2.ROTATE = 6)] = 'ROTATE'),
		(POINT_STRUCT2[(POINT_STRUCT2.ANIM_X = 7)] = 'ANIM_X'),
		(POINT_STRUCT2[(POINT_STRUCT2.ANIM_Y = 8)] = 'ANIM_Y'),
		(POINT_STRUCT2[(POINT_STRUCT2.TEXTURE_INDEX = 9)] = 'TEXTURE_INDEX'),
		(POINT_STRUCT2[(POINT_STRUCT2.ANIM_COUNT_X = 10)] = 'ANIM_COUNT_X'),
		(POINT_STRUCT2[(POINT_STRUCT2.ANIM_COUNT_Y = 11)] = 'ANIM_COUNT_Y'),
		(POINT_STRUCT2[(POINT_STRUCT2.ANIM_DIVISOR = 12)] = 'ANIM_DIVISOR'),
		(POINT_STRUCT2[(POINT_STRUCT2.ALPHA = 13)] = 'ALPHA');
	const POINT_STRUCT_SIZE = Object.keys(POINT_STRUCT).length / 2;
	class Tilemap$1 extends Container {
		__init() {
			this.shadowColor = new Float32Array([0, 0, 0, 0.5]);
		}
		__init2() {
			this._globalMat = null;
		}
		__init3() {
			this.tileAnim = null;
		}
		__init4() {
			this.modificationMarker = 0;
		}
		__init5() {
			this.offsetX = 0;
		}
		__init6() {
			this.offsetY = 0;
		}
		__init7() {
			this.compositeParent = !1;
		}
		__init8() {
			this.tilemapBounds = new Bounds();
		}
		__init9() {
			this.hasAnimatedTile = !1;
		}
		__init10() {
			this.pointsBuf = [];
		}
		constructor(t) {
			super(),
				Tilemap$1.prototype.__init.call(this),
				Tilemap$1.prototype.__init2.call(this),
				Tilemap$1.prototype.__init3.call(this),
				Tilemap$1.prototype.__init4.call(this),
				Tilemap$1.prototype.__init5.call(this),
				Tilemap$1.prototype.__init6.call(this),
				Tilemap$1.prototype.__init7.call(this),
				Tilemap$1.prototype.__init8.call(this),
				Tilemap$1.prototype.__init9.call(this),
				Tilemap$1.prototype.__init10.call(this),
				Tilemap$1.prototype.__init11.call(this),
				Tilemap$1.prototype.__init12.call(this),
				Tilemap$1.prototype.__init13.call(this),
				Tilemap$1.prototype.__init14.call(this),
				Tilemap$1.prototype.__init15.call(this),
				Tilemap$1.prototype.__init16.call(this),
				this.setTileset(t);
		}
		getTileset() {
			return this.tileset;
		}
		setTileset(t = []) {
			Array.isArray(t) || (t = [t]);
			for (let e = 0; e < t.length; e++)
				t[e].baseTexture && (t[e] = t[e].baseTexture);
			return (this.tileset = t), this;
		}
		clear() {
			return (
				(this.pointsBuf.length = 0),
				(this.modificationMarker = 0),
				this.tilemapBounds.clear(),
				(this.hasAnimatedTile = !1),
				this
			);
		}
		tile(t, e, i, r = {}) {
			let s,
				n = -1;
			if ('number' == typeof t) (n = t), (s = this.tileset[n]);
			else {
				let e;
				e = 'string' == typeof t ? Texture$1.from(t) : t;
				const i = this.tileset;
				for (let t = 0; t < i.length; t++)
					if (i[t] === e.castToBaseTexture()) {
						n = t;
						break;
					}
				'baseTexture' in e &&
					((r.u = _nullishCoalesce(r.u, () => e.frame.x)),
					(r.v = _nullishCoalesce(r.v, () => e.frame.y)),
					(r.tileWidth = _nullishCoalesce(r.tileWidth, () => e.orig.width)),
					(r.tileHeight = _nullishCoalesce(r.tileHeight, () => e.orig.height))),
					(s = e.castToBaseTexture());
			}
			if (!s || n < 0) return this;
			const {
					u: a = 0,
					v: o = 0,
					tileWidth: h = s.realWidth,
					tileHeight: u = s.realHeight,
					animX: l = 0,
					animY: c = 0,
					rotate: d = 0,
					animCountX: p = 1024,
					animCountY: f = 1024,
					animDivisor: m = 1,
					alpha: _ = 1,
				} = r,
				g = this.pointsBuf;
			return (
				(this.hasAnimatedTile = this.hasAnimatedTile || l > 0 || c > 0),
				g.push(a),
				g.push(o),
				g.push(e),
				g.push(i),
				g.push(h),
				g.push(u),
				g.push(d),
				g.push(0 | l),
				g.push(0 | c),
				g.push(n),
				g.push(p),
				g.push(f),
				g.push(m),
				g.push(_),
				this.tilemapBounds.addFramePad(e, i, e + h, i + u, 0, 0),
				this
			);
		}
		tileRotate(t) {
			const e = this.pointsBuf;
			e[e.length - (POINT_STRUCT_SIZE - POINT_STRUCT.TEXTURE_INDEX)] = t;
		}
		tileAnimX(t, e) {
			const i = this.pointsBuf;
			(i[i.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_X)] = t),
				(i[i.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_COUNT_X)] = e);
		}
		tileAnimY(t, e) {
			const i = this.pointsBuf;
			(i[i.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_Y)] = t),
				(i[i.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_COUNT_Y)] = e);
		}
		tileAnimDivisor(t) {
			const e = this.pointsBuf;
			e[e.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_DIVISOR)] = t;
		}
		tileAlpha(t) {
			const e = this.pointsBuf;
			e[e.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ALPHA)] = t;
		}
		__init11() {
			this.renderCanvas = (t) => {
				const e = CanvasTileRenderer.getInstance(t);
				if (e && !e.dontUseTransform) {
					const e = this.worldTransform;
					t.context.setTransform(
						e.a,
						e.b,
						e.c,
						e.d,
						e.tx * t.resolution,
						e.ty * t.resolution
					);
				}
				this.renderCanvasCore(t);
			};
		}
		renderCanvasCore(t) {
			if (0 === this.tileset.length) return;
			const e = this.pointsBuf,
				i = this.tileAnim || (t.plugins.tilemap && t.plugins.tilemap.tileAnim);
			t.context.fillStyle = '#000000';
			for (let r = 0, s = e.length; r < s; r += POINT_STRUCT_SIZE) {
				let s = e[r + POINT_STRUCT.U],
					n = e[r + POINT_STRUCT.V];
				const a = e[r + POINT_STRUCT.X],
					o = e[r + POINT_STRUCT.Y],
					h = e[r + POINT_STRUCT.TILE_WIDTH],
					u = e[r + POINT_STRUCT.TILE_HEIGHT];
				(s += e[r + POINT_STRUCT.ANIM_X] * i[0]),
					(n += e[r + POINT_STRUCT.ANIM_Y] * i[1]);
				const l = e[r + POINT_STRUCT.TEXTURE_INDEX],
					c = e[r + POINT_STRUCT.ALPHA];
				l >= 0 && this.tileset[l]
					? ((t.context.globalAlpha = c),
					  t.context.drawImage(
							this.tileset[l].getDrawableSource(),
							s,
							n,
							h,
							u,
							a,
							o,
							h,
							u
					  ))
					: ((t.context.globalAlpha = 0.5), t.context.fillRect(a, o, h, u)),
					(t.context.globalAlpha = 1);
			}
		}
		__init12() {
			this.vbId = 0;
		}
		__init13() {
			this.vb = null;
		}
		__init14() {
			this.vbBuffer = null;
		}
		__init15() {
			this.vbArray = null;
		}
		__init16() {
			this.vbInts = null;
		}
		destroyVb() {
			this.vb && (this.vb.destroy(), (this.vb = null));
		}
		render(t) {
			const e = t.plugins.tilemap,
				i = e.getShader();
			t.batch.setObjectRenderer(e),
				(this._globalMat = i.uniforms.projTransMatrix),
				t.globalUniforms.uniforms.projectionMatrix
					.copyTo(this._globalMat)
					.append(this.worldTransform),
				(i.uniforms.shadowColor = this.shadowColor),
				(i.uniforms.animationFrame = this.tileAnim || e.tileAnim),
				this.renderWebGLCore(t, e);
		}
		renderWebGLCore(t, e) {
			const i = this.pointsBuf;
			if (0 === i.length) return;
			const r = i.length / POINT_STRUCT_SIZE,
				s = e.getShader(),
				n = this.tileset;
			if (0 === n.length) return;
			e.bindTileTextures(t, n), t.shader.bind(s, !1);
			let a = this.vb;
			a ||
				((a = e.createVb()),
				(this.vb = a),
				(this.vbId = a.id),
				(this.vbBuffer = null),
				(this.modificationMarker = 0)),
				e.checkIndexBuffer(r, a);
			const o = settings$1.TEXTILE_UNITS,
				h = a.getBuffer('aVertexPosition'),
				u = r * a.vertPerQuad;
			if (0 !== u) {
				if (this.modificationMarker !== u) {
					this.modificationMarker = u;
					const t = a.stride * u;
					if (!this.vbBuffer || this.vbBuffer.byteLength < t) {
						let e = a.stride;
						for (; e < t; ) e *= 2;
						(this.vbBuffer = new ArrayBuffer(e)),
							(this.vbArray = new Float32Array(this.vbBuffer)),
							(this.vbInts = new Uint32Array(this.vbBuffer)),
							h.update(this.vbBuffer);
					}
					const e = this.vbArray;
					let r = 0,
						s = 0,
						n = this.offsetX,
						l = this.offsetY;
					for (let t = 0; t < i.length; t += POINT_STRUCT_SIZE) {
						const a = 0.5;
						if (this.compositeParent) {
							const e = i[t + POINT_STRUCT.TEXTURE_INDEX];
							o > 1
								? ((s = e >> 2),
								  (n = this.offsetX * (1 & e)),
								  (l = this.offsetY * ((e >> 1) & 1)))
								: ((s = e), (n = 0), (l = 0));
						}
						const h = i[t + POINT_STRUCT.X],
							u = i[t + POINT_STRUCT.Y],
							c = i[t + POINT_STRUCT.TILE_WIDTH],
							d = i[t + POINT_STRUCT.TILE_HEIGHT],
							p = i[t + POINT_STRUCT.U] + n,
							f = i[t + POINT_STRUCT.V] + l;
						let m = i[t + POINT_STRUCT.ROTATE];
						const _ = i[t + POINT_STRUCT.ANIM_X],
							g = i[t + POINT_STRUCT.ANIM_Y],
							E = _ + 2048 * (i[t + POINT_STRUCT.ANIM_COUNT_X] || 1024),
							y = g + 2048 * (i[t + POINT_STRUCT.ANIM_COUNT_Y] || 1024),
							T = i[t + POINT_STRUCT.ANIM_DIVISOR],
							v = i[t + POINT_STRUCT.ALPHA];
						let S, x, b, A, R, I, M, w;
						if (0 === m)
							(S = p),
								(x = f),
								(b = p + c),
								(A = f),
								(R = p + c),
								(I = f + d),
								(M = p),
								(w = f + d);
						else {
							let t = c / 2,
								e = d / 2;
							m % 4 != 0 && ((t = d / 2), (e = c / 2));
							const i = p + t,
								r = f + e;
							(m = groupD8$1.add(m, groupD8$1.NW)),
								(S = i + t * groupD8$1.uX(m)),
								(x = r + e * groupD8$1.uY(m)),
								(m = groupD8$1.add(m, 2)),
								(b = i + t * groupD8$1.uX(m)),
								(A = r + e * groupD8$1.uY(m)),
								(m = groupD8$1.add(m, 2)),
								(R = i + t * groupD8$1.uX(m)),
								(I = r + e * groupD8$1.uY(m)),
								(m = groupD8$1.add(m, 2)),
								(M = i + t * groupD8$1.uX(m)),
								(w = r + e * groupD8$1.uY(m));
						}
						(e[r++] = h),
							(e[r++] = u),
							(e[r++] = S),
							(e[r++] = x),
							(e[r++] = p + a),
							(e[r++] = f + a),
							(e[r++] = p + c - a),
							(e[r++] = f + d - a),
							(e[r++] = E),
							(e[r++] = y),
							(e[r++] = s),
							(e[r++] = T),
							(e[r++] = v),
							(e[r++] = h + c),
							(e[r++] = u),
							(e[r++] = b),
							(e[r++] = A),
							(e[r++] = p + a),
							(e[r++] = f + a),
							(e[r++] = p + c - a),
							(e[r++] = f + d - a),
							(e[r++] = E),
							(e[r++] = y),
							(e[r++] = s),
							(e[r++] = T),
							(e[r++] = v),
							(e[r++] = h + c),
							(e[r++] = u + d),
							(e[r++] = R),
							(e[r++] = I),
							(e[r++] = p + a),
							(e[r++] = f + a),
							(e[r++] = p + c - a),
							(e[r++] = f + d - a),
							(e[r++] = E),
							(e[r++] = y),
							(e[r++] = s),
							(e[r++] = T),
							(e[r++] = v),
							(e[r++] = h),
							(e[r++] = u + d),
							(e[r++] = M),
							(e[r++] = w),
							(e[r++] = p + a),
							(e[r++] = f + a),
							(e[r++] = p + c - a),
							(e[r++] = f + d - a),
							(e[r++] = E),
							(e[r++] = y),
							(e[r++] = s),
							(e[r++] = T),
							(e[r++] = v);
					}
					h.update(e);
				}
				t.geometry.bind(a, s),
					t.geometry.draw(DRAW_MODES$3.TRIANGLES, 6 * r, 0);
			}
		}
		isModified(t) {
			return !!(
				this.modificationMarker !== this.pointsBuf.length ||
				(t && this.hasAnimatedTile)
			);
		}
		clearModify() {
			this.modificationMarker = this.pointsBuf.length;
		}
		_calculateBounds() {
			const { minX: t, minY: e, maxX: i, maxY: r } = this.tilemapBounds;
			this._bounds.addFrame(this.transform, t, e, i, r);
		}
		getLocalBounds(t) {
			return 0 === this.children.length
				? this.tilemapBounds.getRectangle(t)
				: super.getLocalBounds.call(this, t);
		}
		destroy(t) {
			super.destroy(t), this.destroyVb();
		}
		addFrame(t, e, i, r, s) {
			return this.tile(t, e, i, { animX: r, animY: s }), !0;
		}
		addRect(
			t,
			e,
			i,
			r,
			s,
			n,
			a,
			o = 0,
			h = 0,
			u = 0,
			l = 1024,
			c = 1024,
			d = 1,
			p = 1
		) {
			return this.tile(t, r, s, {
				u: e,
				v: i,
				tileWidth: n,
				tileHeight: a,
				animX: o,
				animY: h,
				rotate: u,
				animCountX: l,
				animCountY: c,
				animDivisor: d,
				alpha: p,
			});
		}
	}
	class CompositeTilemap extends Container {
		__init() {
			this.tileAnim = null;
		}
		__init2() {
			this.lastModifiedTilemap = null;
		}
		__init3() {
			this.modificationMarker = 0;
		}
		__init4() {
			this.shadowColor = new Float32Array([0, 0, 0, 0.5]);
		}
		__init5() {
			this._globalMat = null;
		}
		constructor(t) {
			super(),
				CompositeTilemap.prototype.__init.call(this),
				CompositeTilemap.prototype.__init2.call(this),
				CompositeTilemap.prototype.__init3.call(this),
				CompositeTilemap.prototype.__init4.call(this),
				CompositeTilemap.prototype.__init5.call(this),
				CompositeTilemap.prototype.__init6.call(this),
				this.tileset(t),
				(this.texturesPerTilemap = settings$1.TEXTURES_PER_TILEMAP);
		}
		tileset(t) {
			t || (t = []);
			const e = this.texturesPerTilemap,
				i = this.children.length,
				r = Math.ceil(t.length / e);
			for (let s = 0; s < Math.min(i, r); s++)
				this.children[s].setTileset(t.slice(s * e, (s + 1) * e));
			for (let s = i; s < r; s++) {
				const i = new Tilemap$1(t.slice(s * e, (s + 1) * e));
				(i.compositeParent = !0),
					(i.offsetX = settings$1.TEXTILE_DIMEN),
					(i.offsetY = settings$1.TEXTILE_DIMEN),
					this.addChild(i);
			}
			return this;
		}
		clear() {
			for (let t = 0; t < this.children.length; t++) this.children[t].clear();
			return (this.modificationMarker = 0), this;
		}
		tileRotate(t) {
			return (
				this.lastModifiedTilemap && this.lastModifiedTilemap.tileRotate(t), this
			);
		}
		tileAnimX(t, e) {
			return (
				this.lastModifiedTilemap && this.lastModifiedTilemap.tileAnimX(t, e),
				this
			);
		}
		tileAnimY(t, e) {
			return (
				this.lastModifiedTilemap && this.lastModifiedTilemap.tileAnimY(t, e),
				this
			);
		}
		tileAnimDivisor(t) {
			return (
				this.lastModifiedTilemap && this.lastModifiedTilemap.tileAnimDivisor(t),
				this
			);
		}
		tile(t, e, i, r = {}) {
			let s = null;
			const n = this.children;
			if (((this.lastModifiedTilemap = null), 'number' == typeof t)) {
				let a = 0;
				if (((s = n[(t / this.texturesPerTilemap) >> 0]), s))
					a = t % this.texturesPerTilemap;
				else {
					if (((s = n[0]), !s)) return this;
					a = 0;
				}
				s.tile(a, e, i, r);
			} else {
				'string' == typeof t && (t = Texture$1.from(t));
				for (let e = 0; e < n.length; e++) {
					const i = n[e],
						r = i.getTileset();
					for (let e = 0; e < r.length; e++)
						if (r[e] === t.baseTexture) {
							s = i;
							break;
						}
					if (s) break;
				}
				if (!s) {
					for (let e = n.length - 1; e >= 0; e--) {
						const i = n[e];
						if (i.getTileset().length < this.texturesPerTilemap) {
							(s = i), i.getTileset().push(t.baseTexture);
							break;
						}
					}
					s ||
						((s = new Tilemap$1(t.baseTexture)),
						(s.compositeParent = !0),
						(s.offsetX = settings$1.TEXTILE_DIMEN),
						(s.offsetY = settings$1.TEXTILE_DIMEN),
						this.addChild(s));
				}
				s.tile(t, e, i, r);
			}
			return (this.lastModifiedTilemap = s), this;
		}
		renderCanvas(t) {
			if (!this.visible || this.worldAlpha <= 0 || !this.renderable) return;
			const e = CanvasTileRenderer.getInstance(t);
			if (e && !e.dontUseTransform) {
				const e = this.worldTransform;
				t.context.setTransform(
					e.a,
					e.b,
					e.c,
					e.d,
					e.tx * t.resolution,
					e.ty * t.resolution
				);
			}
			const i = this.children;
			for (let e = 0; e < i.length; e++) {
				const r = i[e];
				(r.tileAnim = this.tileAnim), r.renderCanvasCore(t);
			}
		}
		render(t) {
			if (!this.visible || this.worldAlpha <= 0 || !this.renderable) return;
			const e = t.plugins.tilemap,
				i = e.getShader();
			t.batch.setObjectRenderer(e),
				(this._globalMat = i.uniforms.projTransMatrix),
				t.globalUniforms.uniforms.projectionMatrix
					.copyTo(this._globalMat)
					.append(this.worldTransform),
				(i.uniforms.shadowColor = this.shadowColor),
				(i.uniforms.animationFrame = this.tileAnim || e.tileAnim),
				t.shader.bind(i, !1);
			const r = this.children;
			for (let i = 0; i < r.length; i++) r[i].renderWebGLCore(t, e);
		}
		isModified(t) {
			const e = this.children;
			if (this.modificationMarker !== e.length) return !0;
			for (let i = 0; i < e.length; i++) if (e[i].isModified(t)) return !0;
			return !1;
		}
		clearModify() {
			const t = this.children;
			this.modificationMarker = t.length;
			for (let e = 0; e < t.length; e++) t[e].clearModify();
		}
		addFrame(t, e, i, r, s, n, a, o, h) {
			return this.tile(t, e, i, {
				animX: r,
				animY: s,
				animCountX: n,
				animCountY: a,
				animDivisor: o,
				alpha: h,
			});
		}
		addRect(t, e, i, r, s, n, a, o, h, u, l, c) {
			const d = (t / this.texturesPerTilemap) >> 0,
				p = t % this.texturesPerTilemap;
			return (
				this.children[d] && this.children[d].getTileset()
					? ((this.lastModifiedTilemap = this.children[d]),
					  this.lastModifiedTilemap.addRect(
							p,
							e,
							i,
							r,
							s,
							n,
							a,
							o,
							h,
							u,
							l,
							c
					  ))
					: (this.lastModifiedTilemap = null),
				this
			);
		}
		__init6() {
			this.setBitmaps = this.tileset;
		}
		get texPerChild() {
			return this.texturesPerTilemap;
		}
	}
	class TextileResource extends Resource$1 {
		__init() {
			this.baseTexture = null;
		}
		__init2() {
			this._clearBuffer = null;
		}
		constructor(t = settings$1) {
			super(
				2 * t.TEXTILE_DIMEN,
				t.TEXTILE_DIMEN * Math.ceil(t.TEXTILE_UNITS / 2)
			),
				TextileResource.prototype.__init.call(this),
				TextileResource.prototype.__init2.call(this);
			const e = (this.tiles = new Array(t.TEXTILE_UNITS));
			(this.doClear = !!t.DO_CLEAR), (this.tileDimen = t.TEXTILE_DIMEN);
			for (let i = 0; i < t.TEXTILE_UNITS; i++)
				e[i] = {
					dirtyId: 0,
					x: t.TEXTILE_DIMEN * (1 & i),
					y: t.TEXTILE_DIMEN * (i >> 1),
					baseTexture: Texture$1.WHITE.baseTexture,
				};
		}
		tile(t, e) {
			const i = this.tiles[t];
			i.baseTexture !== e &&
				((i.baseTexture = e),
				this.baseTexture.update(),
				(this.tiles[t].dirtyId = this.baseTexture.dirtyId));
		}
		bind(t) {
			if (this.baseTexture)
				throw new Error('Only one baseTexture is allowed for this resource!');
			(this.baseTexture = t), super.bind(t);
		}
		upload(t, e, i) {
			const { gl: r } = t,
				{ width: s, height: n } = this;
			r.pixelStorei(
				r.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
				void 0 === e.alphaMode || e.alphaMode === ALPHA_MODES$3.UNPACK
			),
				i.dirtyId < 0 &&
					((i.width = s),
					(i.height = n),
					r.texImage2D(e.target, 0, e.format, s, n, 0, e.format, e.type, null));
			const a = this.doClear,
				o = this.tiles;
			a &&
				!this._clearBuffer &&
				(this._clearBuffer = new Uint8Array(
					settings$1.TEXTILE_DIMEN * settings$1.TEXTILE_DIMEN * 4
				));
			for (let t = 0; t < o.length; t++) {
				const s = o[t],
					n = s.baseTexture;
				if (i.dirtyId >= this.tiles[t].dirtyId) continue;
				const h = n.resource;
				n.valid &&
					h &&
					h.source &&
					(a &&
						(n.width < this.tileDimen || n.height < this.tileDimen) &&
						r.texSubImage2D(
							e.target,
							0,
							s.x,
							s.y,
							this.tileDimen,
							this.tileDimen,
							e.format,
							e.type,
							this._clearBuffer
						),
					r.texSubImage2D(e.target, 0, s.x, s.y, e.format, e.type, h.source));
			}
			return !0;
		}
	}
	function generateSampleSrc(t) {
		let e = '';
		(e += '\n'),
			(e += '\n'),
			(e += 'if(vTextureId <= -1.0) {'),
			(e += '\n\tcolor = shadowColor;'),
			(e += '\n}');
		for (let i = 0; i < t; i++)
			(e += '\nelse '),
				i < t - 1 && (e += `if(textureId == ${i}.0)`),
				(e += '\n{'),
				(e += `\n\tcolor = texture2D(uSamplers[${i}], textureCoord * uSamplerSize[${i}]);`),
				(e += '\n}');
		return (e += '\n'), (e += '\n'), e;
	}
	function fillSamplers(t, e) {
		const i = [];
		for (let t = 0; t < e; t++) i[t] = t;
		t.uniforms.uSamplers = i;
		const r = [];
		for (let t = 0; t < e; t++) r.push(1 / 2048), r.push(1 / 2048);
		t.uniforms.uSamplerSize = r;
	}
	function generateFragmentSrc(t, e) {
		return e
			.replace(/%count%/gi, `${t}`)
			.replace(/%forloop%/gi, generateSampleSrc(t));
	}
	const tilemapVertexTemplateSrc =
			'#version 100\nprecision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aFrame;\nattribute vec2 aAnim;\nattribute float aAnimDivisor;\nattribute float aTextureId;\nattribute float aAlpha;\n\nuniform mat3 projTransMatrix;\nuniform vec2 animationFrame;\n\nvarying vec2 vTextureCoord;\nvarying float vTextureId;\nvarying vec4 vFrame;\nvarying float vAlpha;\n\nvoid main(void)\n{\n   gl_Position = vec4((projTransMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vec2 animCount = floor((aAnim + 0.5) / 2048.0);\n   vec2 animFrameOffset = aAnim - animCount * 2048.0;\n   vec2 currentFrame = floor(animationFrame / aAnimDivisor);\n   vec2 animOffset = animFrameOffset * floor(mod(currentFrame + 0.5, animCount));\n\n   vTextureCoord = aTextureCoord + animOffset;\n   vFrame = aFrame + vec4(animOffset, animOffset);\n   vTextureId = aTextureId;\n   vAlpha = aAlpha;\n}\n',
		tilemapFragmentTemplateSrc =
			'#version 100\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\nvarying vec2 vTextureCoord;\nvarying vec4 vFrame;\nvarying float vTextureId;\nvarying float vAlpha;\nuniform vec4 shadowColor;\nuniform sampler2D uSamplers[%count%];\nuniform vec2 uSamplerSize[%count%];\n\nvoid main(void)\n{\n   vec2 textureCoord = clamp(vTextureCoord, vFrame.xy, vFrame.zw);\n   float textureId = floor(vTextureId + 0.5);\n\n   vec4 color;\n   %forloop%\n   gl_FragColor = color * vAlpha;\n}\n';
	class TilemapShader extends Shader$1 {
		__init() {
			this.maxTextures = 0;
		}
		constructor(t) {
			super(
				new Program$1(
					tilemapVertexTemplateSrc,
					generateFragmentSrc(t, tilemapFragmentTemplateSrc)
				),
				{
					animationFrame: new Float32Array(2),
					uSamplers: [],
					uSamplerSize: [],
					projTransMatrix: new Matrix$1(),
				}
			),
				TilemapShader.prototype.__init.call(this),
				(this.maxTextures = t),
				fillSamplers(this, this.maxTextures);
		}
	}
	class TilemapGeometry extends Geometry$1 {
		__init2() {
			this.vertSize = 13;
		}
		__init3() {
			this.vertPerQuad = 4;
		}
		__init4() {
			this.stride = 4 * this.vertSize;
		}
		__init5() {
			this.lastTimeAccess = 0;
		}
		constructor() {
			super(),
				TilemapGeometry.prototype.__init2.call(this),
				TilemapGeometry.prototype.__init3.call(this),
				TilemapGeometry.prototype.__init4.call(this),
				TilemapGeometry.prototype.__init5.call(this);
			const t = (this.buf = new Buffer$1(new Float32Array(2), !0, !1));
			this.addAttribute('aVertexPosition', t, 0, !1, 0, this.stride, 0)
				.addAttribute('aTextureCoord', t, 0, !1, 0, this.stride, 8)
				.addAttribute('aFrame', t, 0, !1, 0, this.stride, 16)
				.addAttribute('aAnim', t, 0, !1, 0, this.stride, 32)
				.addAttribute('aTextureId', t, 0, !1, 0, this.stride, 40)
				.addAttribute('aAnimDivisor', t, 0, !1, 0, this.stride, 44)
				.addAttribute('aAlpha', t, 0, !1, 0, this.stride, 48);
		}
	}
	class TileRenderer extends ObjectRenderer$1 {
		__init() {
			this.tileAnim = [0, 0];
		}
		__init2() {
			this.ibLen = 0;
		}
		__init3() {
			this.indexBuffer = null;
		}
		__init4() {
			this.textiles = [];
		}
		constructor(t) {
			super(t),
				TileRenderer.prototype.__init.call(this),
				TileRenderer.prototype.__init2.call(this),
				TileRenderer.prototype.__init3.call(this),
				TileRenderer.prototype.__init4.call(this),
				(this.shader = new TilemapShader(settings$1.TEXTURES_PER_TILEMAP)),
				(this.indexBuffer = new Buffer$1(void 0, !0, !0)),
				this.checkIndexBuffer(2e3),
				this.makeTextiles();
		}
		bindTileTextures(t, e) {
			const i = e.length,
				r = this.shader,
				s = settings$1.TEXTURES_PER_TILEMAP,
				n = r.uniforms.uSamplerSize;
			if (!(i > settings$1.TEXTILE_UNITS * s)) {
				if (settings$1.TEXTILE_UNITS <= 1)
					for (let i = 0; i < e.length; i++) {
						const r = e[i];
						if (!r || !r.valid) return;
						t.texture.bind(e[i], i),
							(n[2 * i] = 1 / e[i].realWidth),
							(n[2 * i + 1] = 1 / e[i].realHeight);
					}
				else {
					this.makeTextiles();
					const r = Math.ceil(i / settings$1.TEXTILE_UNITS);
					for (let t = 0; t < i; t++) {
						const i = e[t];
						if (i && i.valid) {
							const e = Math.floor(t / settings$1.TEXTILE_UNITS),
								r = t % settings$1.TEXTILE_UNITS;
							this.textiles[e].tile(r, i);
						}
					}
					for (let e = 0; e < r; e++)
						t.texture.bind(this.textiles[e].baseTexture, e),
							(n[2 * e] = 1 / this.textiles[e].width),
							(n[2 * e + 1] = 1 / this.textiles[e].baseTexture.height);
				}
				r.uniforms.uSamplerSize = n;
			}
		}
		start() {}
		createVb() {
			const t = new TilemapGeometry();
			return t.addIndex(this.indexBuffer), (t.lastTimeAccess = Date.now()), t;
		}
		getShader() {
			return this.shader;
		}
		destroy() {
			super.destroy(), (this.shader = null);
		}
		checkIndexBuffer(t, e = null) {
			const i = 6 * t;
			i <= this.ibLen ||
				((this.ibLen = i),
				this.indexBuffer.update(
					createIndicesForQuads(
						t,
						settings$1.use32bitIndex ? new Uint32Array(6 * t) : void 0
					)
				));
		}
		makeTextiles() {
			if (!(settings$1.TEXTILE_UNITS <= 1))
				for (let t = 0; t < settings$1.TEXTILE_UNITS; t++) {
					if (this.textiles[t]) continue;
					const e = new TextileResource(),
						i = new BaseTexture$1(e);
					(i.scaleMode = settings$1.TEXTILE_SCALE_MODE),
						(i.wrapMode = WRAP_MODES$3.CLAMP),
						(this.textiles[t] = e);
				}
		}
	}
	Renderer.registerPlugin('tilemap', TileRenderer);
	/*!
	 * @pixi/filter-alpha - v6.4.2
	 * Compiled Thu, 02 Jun 2022 15:39:26 UTC
	 *
	 * @pixi/filter-alpha is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 */
	/*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
	var extendStatics$a = function (t, e) {
		return (extendStatics$a =
			Object.setPrototypeOf ||
			({ __proto__: [] } instanceof Array &&
				function (t, e) {
					t.__proto__ = e;
				}) ||
			function (t, e) {
				for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
			})(t, e);
	};
	function __extends$a(t, e) {
		function i() {
			this.constructor = t;
		}
		extendStatics$a(t, e),
			(t.prototype =
				null === e ? Object.create(e) : ((i.prototype = e.prototype), new i()));
	}
	var fragment$a =
			'varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n',
		AlphaFilter = (function (t) {
			function e(e) {
				void 0 === e && (e = 1);
				var i =
					t.call(this, defaultVertex$1$2, fragment$a, { uAlpha: 1 }) || this;
				return (i.alpha = e), i;
			}
			return (
				__extends$a(e, t),
				Object.defineProperty(e.prototype, 'alpha', {
					get: function () {
						return this.uniforms.uAlpha;
					},
					set: function (t) {
						this.uniforms.uAlpha = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				e
			);
		})(Filter$3),
		extendStatics$9 = function (t, e) {
			return (extendStatics$9 =
				Object.setPrototypeOf ||
				({ __proto__: [] } instanceof Array &&
					function (t, e) {
						t.__proto__ = e;
					}) ||
				function (t, e) {
					for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
				})(t, e);
		};
	function __extends$9(t, e) {
		function i() {
			this.constructor = t;
		}
		extendStatics$9(t, e),
			(t.prototype =
				null === e ? Object.create(e) : ((i.prototype = e.prototype), new i()));
	}
	var fragment$9 =
			'varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n',
		ColorMatrixFilter = (function (t) {
			function e() {
				var e = this,
					i = {
						m: new Float32Array([
							1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0,
						]),
						uAlpha: 1,
					};
				return (
					((e =
						t.call(this, defaultFilterVertex, fragment$9, i) ||
						this).alpha = 1),
					e
				);
			}
			return (
				__extends$9(e, t),
				(e.prototype._loadMatrix = function (t, e) {
					void 0 === e && (e = !1);
					var i = t;
					e &&
						(this._multiply(i, this.uniforms.m, t), (i = this._colorMatrix(i))),
						(this.uniforms.m = i);
				}),
				(e.prototype._multiply = function (t, e, i) {
					return (
						(t[0] = e[0] * i[0] + e[1] * i[5] + e[2] * i[10] + e[3] * i[15]),
						(t[1] = e[0] * i[1] + e[1] * i[6] + e[2] * i[11] + e[3] * i[16]),
						(t[2] = e[0] * i[2] + e[1] * i[7] + e[2] * i[12] + e[3] * i[17]),
						(t[3] = e[0] * i[3] + e[1] * i[8] + e[2] * i[13] + e[3] * i[18]),
						(t[4] =
							e[0] * i[4] + e[1] * i[9] + e[2] * i[14] + e[3] * i[19] + e[4]),
						(t[5] = e[5] * i[0] + e[6] * i[5] + e[7] * i[10] + e[8] * i[15]),
						(t[6] = e[5] * i[1] + e[6] * i[6] + e[7] * i[11] + e[8] * i[16]),
						(t[7] = e[5] * i[2] + e[6] * i[7] + e[7] * i[12] + e[8] * i[17]),
						(t[8] = e[5] * i[3] + e[6] * i[8] + e[7] * i[13] + e[8] * i[18]),
						(t[9] =
							e[5] * i[4] + e[6] * i[9] + e[7] * i[14] + e[8] * i[19] + e[9]),
						(t[10] =
							e[10] * i[0] + e[11] * i[5] + e[12] * i[10] + e[13] * i[15]),
						(t[11] =
							e[10] * i[1] + e[11] * i[6] + e[12] * i[11] + e[13] * i[16]),
						(t[12] =
							e[10] * i[2] + e[11] * i[7] + e[12] * i[12] + e[13] * i[17]),
						(t[13] =
							e[10] * i[3] + e[11] * i[8] + e[12] * i[13] + e[13] * i[18]),
						(t[14] =
							e[10] * i[4] +
							e[11] * i[9] +
							e[12] * i[14] +
							e[13] * i[19] +
							e[14]),
						(t[15] =
							e[15] * i[0] + e[16] * i[5] + e[17] * i[10] + e[18] * i[15]),
						(t[16] =
							e[15] * i[1] + e[16] * i[6] + e[17] * i[11] + e[18] * i[16]),
						(t[17] =
							e[15] * i[2] + e[16] * i[7] + e[17] * i[12] + e[18] * i[17]),
						(t[18] =
							e[15] * i[3] + e[16] * i[8] + e[17] * i[13] + e[18] * i[18]),
						(t[19] =
							e[15] * i[4] +
							e[16] * i[9] +
							e[17] * i[14] +
							e[18] * i[19] +
							e[19]),
						t
					);
				}),
				(e.prototype._colorMatrix = function (t) {
					var e = new Float32Array(t);
					return (
						(e[4] /= 255), (e[9] /= 255), (e[14] /= 255), (e[19] /= 255), e
					);
				}),
				(e.prototype.brightness = function (t, e) {
					var i = [t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 1, 0];
					this._loadMatrix(i, e);
				}),
				(e.prototype.tint = function (t, e) {
					var i = [
						((t >> 16) & 255) / 255,
						0,
						0,
						0,
						0,
						0,
						((t >> 8) & 255) / 255,
						0,
						0,
						0,
						0,
						0,
						(255 & t) / 255,
						0,
						0,
						0,
						0,
						0,
						1,
						0,
					];
					this._loadMatrix(i, e);
				}),
				(e.prototype.greyscale = function (t, e) {
					var i = [t, t, t, 0, 0, t, t, t, 0, 0, t, t, t, 0, 0, 0, 0, 0, 1, 0];
					this._loadMatrix(i, e);
				}),
				(e.prototype.blackAndWhite = function (t) {
					this._loadMatrix(
						[
							0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0,
							0, 0, 1, 0,
						],
						t
					);
				}),
				(e.prototype.hue = function (t, e) {
					t = ((t || 0) / 180) * Math.PI;
					var i = Math.cos(t),
						r = Math.sin(t),
						s = 1 / 3,
						n = (0, Math.sqrt)(s),
						a = [
							i + (1 - i) * s,
							s * (1 - i) - n * r,
							s * (1 - i) + n * r,
							0,
							0,
							s * (1 - i) + n * r,
							i + s * (1 - i),
							s * (1 - i) - n * r,
							0,
							0,
							s * (1 - i) - n * r,
							s * (1 - i) + n * r,
							i + s * (1 - i),
							0,
							0,
							0,
							0,
							0,
							1,
							0,
						];
					this._loadMatrix(a, e);
				}),
				(e.prototype.contrast = function (t, e) {
					var i = (t || 0) + 1,
						r = -0.5 * (i - 1),
						s = [i, 0, 0, 0, r, 0, i, 0, 0, r, 0, 0, i, 0, r, 0, 0, 0, 1, 0];
					this._loadMatrix(s, e);
				}),
				(e.prototype.saturate = function (t, e) {
					void 0 === t && (t = 0);
					var i = (2 * t) / 3 + 1,
						r = -0.5 * (i - 1),
						s = [i, r, r, 0, 0, r, i, r, 0, 0, r, r, i, 0, 0, 0, 0, 0, 1, 0];
					this._loadMatrix(s, e);
				}),
				(e.prototype.desaturate = function () {
					this.saturate(-1);
				}),
				(e.prototype.negative = function (t) {
					this._loadMatrix(
						[-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0],
						t
					);
				}),
				(e.prototype.sepia = function (t) {
					this._loadMatrix(
						[
							0.393, 0.7689999, 0.18899999, 0, 0, 0.349, 0.6859999, 0.16799999,
							0, 0, 0.272, 0.5339999, 0.13099999, 0, 0, 0, 0, 0, 1, 0,
						],
						t
					);
				}),
				(e.prototype.technicolor = function (t) {
					this._loadMatrix(
						[
							1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0,
							11.793603434377337, -0.3087833385928097, 1.7658908555458428,
							-0.10601743074722245, 0, -70.35205161461398, -0.231103377548616,
							-0.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0,
							0, 0, 1, 0,
						],
						t
					);
				}),
				(e.prototype.polaroid = function (t) {
					this._loadMatrix(
						[
							1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016,
							-0.016, 1.483, 0, 0, 0, 0, 0, 1, 0,
						],
						t
					);
				}),
				(e.prototype.toBGR = function (t) {
					this._loadMatrix(
						[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0],
						t
					);
				}),
				(e.prototype.kodachrome = function (t) {
					this._loadMatrix(
						[
							1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0,
							63.72958762196502, -0.16404339962244616, 1.0835251566291304,
							-0.05498805115633132, 0, 24.732407896706203, -0.16786010706155763,
							-0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0,
							0, 0, 1, 0,
						],
						t
					);
				}),
				(e.prototype.browni = function (t) {
					this._loadMatrix(
						[
							0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0,
							47.43192855600873, -0.037703249837783157, 0.8609577587992641,
							0.15059552388459913, 0, -36.96841498319127, 0.24113635128153335,
							-0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283,
							0, 0, 0, 1, 0,
						],
						t
					);
				}),
				(e.prototype.vintage = function (t) {
					this._loadMatrix(
						[
							0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0,
							9.651285835294123, 0.02578397704808868, 0.6441188644374771,
							0.03259127616149294, 0, 7.462829176470591, 0.0466055556782719,
							-0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296, 0,
							0, 0, 1, 0,
						],
						t
					);
				}),
				(e.prototype.colorTone = function (t, e, i, r, s) {
					var n = (((i = i || 16770432) >> 16) & 255) / 255,
						a = ((i >> 8) & 255) / 255,
						o = (255 & i) / 255,
						h = (((r = r || 3375104) >> 16) & 255) / 255,
						u = ((r >> 8) & 255) / 255,
						l = (255 & r) / 255,
						c = [
							0.3,
							0.59,
							0.11,
							0,
							0,
							n,
							a,
							o,
							(t = t || 0.2),
							0,
							h,
							u,
							l,
							(e = e || 0.15),
							0,
							n - h,
							a - u,
							o - l,
							0,
							0,
						];
					this._loadMatrix(c, s);
				}),
				(e.prototype.night = function (t, e) {
					var i = [
						-2 * (t = t || 0.1),
						-t,
						0,
						0,
						0,
						-t,
						0,
						t,
						0,
						0,
						0,
						t,
						2 * t,
						0,
						0,
						0,
						0,
						0,
						1,
						0,
					];
					this._loadMatrix(i, e);
				}),
				(e.prototype.predator = function (t, e) {
					var i = [
						11.224130630493164 * t,
						-4.794486999511719 * t,
						-2.8746118545532227 * t,
						0 * t,
						0.40342438220977783 * t,
						-3.6330697536468506 * t,
						9.193157196044922 * t,
						-2.951810836791992 * t,
						0 * t,
						-1.316135048866272 * t,
						-3.2184197902679443 * t,
						-4.2375030517578125 * t,
						7.476448059082031 * t,
						0 * t,
						0.8044459223747253 * t,
						0,
						0,
						0,
						1,
						0,
					];
					this._loadMatrix(i, e);
				}),
				(e.prototype.lsd = function (t) {
					this._loadMatrix(
						[
							2, -0.4, 0.5, 0, 0, -0.5, 2, -0.4, 0, 0, -0.4, -0.5, 3, 0, 0, 0,
							0, 0, 1, 0,
						],
						t
					);
				}),
				(e.prototype.reset = function () {
					this._loadMatrix(
						[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
						!1
					);
				}),
				Object.defineProperty(e.prototype, 'matrix', {
					get: function () {
						return this.uniforms.m;
					},
					set: function (t) {
						this.uniforms.m = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'alpha', {
					get: function () {
						return this.uniforms.uAlpha;
					},
					set: function (t) {
						this.uniforms.uAlpha = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				e
			);
		})(Filter$3);
	ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;
	/*!
	 * @pixi/filter-pixelate - v4.1.3
	 * Compiled Thu, 17 Jun 2021 19:33:56 UTC
	 *
	 * @pixi/filter-pixelate is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 */
	/*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
	var extendStatics$8 = function (t, e) {
		return (extendStatics$8 =
			Object.setPrototypeOf ||
			({ __proto__: [] } instanceof Array &&
				function (t, e) {
					t.__proto__ = e;
				}) ||
			function (t, e) {
				for (var i in e)
					Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
			})(t, e);
	};
	function __extends$8(t, e) {
		function i() {
			this.constructor = t;
		}
		extendStatics$8(t, e),
			(t.prototype =
				null === e ? Object.create(e) : ((i.prototype = e.prototype), new i()));
	}
	var vertex$8 =
			'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}',
		fragment$8 =
			'precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform vec2 size;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvec2 pixelate(vec2 coord, vec2 size)\n{\n\treturn floor( coord / size ) * size;\n}\n\nvoid main(void)\n{\n    vec2 coord = mapCoord(vTextureCoord);\n\n    coord = pixelate(coord, size);\n\n    coord = unmapCoord(coord);\n\n    gl_FragColor = texture2D(uSampler, coord);\n}\n',
		PixelateFilter = (function (t) {
			function e(e) {
				void 0 === e && (e = 10);
				var i = t.call(this, vertex$8, fragment$8) || this;
				return (i.size = e), i;
			}
			return (
				__extends$8(e, t),
				Object.defineProperty(e.prototype, 'size', {
					get: function () {
						return this.uniforms.size;
					},
					set: function (t) {
						'number' == typeof t && (t = [t, t]), (this.uniforms.size = t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				e
			);
		})(Filter$1),
		isMobile = isMobile$4(self.navigator),
		ENV$1,
		RENDERER_TYPE$1,
		BUFFER_BITS$1,
		BLEND_MODES$1,
		DRAW_MODES$1,
		FORMATS$1,
		TARGETS$1,
		TYPES$1,
		SAMPLER_TYPES$1,
		SCALE_MODES$1,
		WRAP_MODES$1,
		MIPMAP_MODES$1,
		ALPHA_MODES$1,
		CLEAR_MODES$1,
		GC_MODES$1,
		PRECISION$1,
		MASK_TYPES$1,
		MSAA_QUALITY$1,
		BUFFER_TYPE$1;
	function maxRecommendedTextures(t) {
		var e,
			i = !0;
		(isMobile.tablet || isMobile.phone) &&
			(isMobile.apple.device &&
				(e = navigator.userAgent.match(/OS (\d+)_(\d+)?/)) &&
				parseInt(e[1], 10) < 11 &&
				(i = !1),
			isMobile.android.device &&
				(e = navigator.userAgent.match(/Android\s([0-9.]*)/)) &&
				parseInt(e[1], 10) < 7 &&
				(i = !1));
		return i ? t : 4;
	}
	function canUploadSameBuffer() {
		return !isMobile.apple.device;
	}
	/*!
	 * @pixi/constants - v6.2.2
	 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
	 *
	 * @pixi/constants is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 */ !(function (t) {
		(t[(t.WEBGL_LEGACY = 0)] = 'WEBGL_LEGACY'),
			(t[(t.WEBGL = 1)] = 'WEBGL'),
			(t[(t.WEBGL2 = 2)] = 'WEBGL2');
	})(ENV$1 || (ENV$1 = {})),
		(function (t) {
			(t[(t.UNKNOWN = 0)] = 'UNKNOWN'),
				(t[(t.WEBGL = 1)] = 'WEBGL'),
				(t[(t.CANVAS = 2)] = 'CANVAS');
		})(RENDERER_TYPE$1 || (RENDERER_TYPE$1 = {})),
		(function (t) {
			(t[(t.COLOR = 16384)] = 'COLOR'),
				(t[(t.DEPTH = 256)] = 'DEPTH'),
				(t[(t.STENCIL = 1024)] = 'STENCIL');
		})(BUFFER_BITS$1 || (BUFFER_BITS$1 = {})),
		(function (t) {
			(t[(t.NORMAL = 0)] = 'NORMAL'),
				(t[(t.ADD = 1)] = 'ADD'),
				(t[(t.MULTIPLY = 2)] = 'MULTIPLY'),
				(t[(t.SCREEN = 3)] = 'SCREEN'),
				(t[(t.OVERLAY = 4)] = 'OVERLAY'),
				(t[(t.DARKEN = 5)] = 'DARKEN'),
				(t[(t.LIGHTEN = 6)] = 'LIGHTEN'),
				(t[(t.COLOR_DODGE = 7)] = 'COLOR_DODGE'),
				(t[(t.COLOR_BURN = 8)] = 'COLOR_BURN'),
				(t[(t.HARD_LIGHT = 9)] = 'HARD_LIGHT'),
				(t[(t.SOFT_LIGHT = 10)] = 'SOFT_LIGHT'),
				(t[(t.DIFFERENCE = 11)] = 'DIFFERENCE'),
				(t[(t.EXCLUSION = 12)] = 'EXCLUSION'),
				(t[(t.HUE = 13)] = 'HUE'),
				(t[(t.SATURATION = 14)] = 'SATURATION'),
				(t[(t.COLOR = 15)] = 'COLOR'),
				(t[(t.LUMINOSITY = 16)] = 'LUMINOSITY'),
				(t[(t.NORMAL_NPM = 17)] = 'NORMAL_NPM'),
				(t[(t.ADD_NPM = 18)] = 'ADD_NPM'),
				(t[(t.SCREEN_NPM = 19)] = 'SCREEN_NPM'),
				(t[(t.NONE = 20)] = 'NONE'),
				(t[(t.SRC_OVER = 0)] = 'SRC_OVER'),
				(t[(t.SRC_IN = 21)] = 'SRC_IN'),
				(t[(t.SRC_OUT = 22)] = 'SRC_OUT'),
				(t[(t.SRC_ATOP = 23)] = 'SRC_ATOP'),
				(t[(t.DST_OVER = 24)] = 'DST_OVER'),
				(t[(t.DST_IN = 25)] = 'DST_IN'),
				(t[(t.DST_OUT = 26)] = 'DST_OUT'),
				(t[(t.DST_ATOP = 27)] = 'DST_ATOP'),
				(t[(t.ERASE = 26)] = 'ERASE'),
				(t[(t.SUBTRACT = 28)] = 'SUBTRACT'),
				(t[(t.XOR = 29)] = 'XOR');
		})(BLEND_MODES$1 || (BLEND_MODES$1 = {})),
		(function (t) {
			(t[(t.POINTS = 0)] = 'POINTS'),
				(t[(t.LINES = 1)] = 'LINES'),
				(t[(t.LINE_LOOP = 2)] = 'LINE_LOOP'),
				(t[(t.LINE_STRIP = 3)] = 'LINE_STRIP'),
				(t[(t.TRIANGLES = 4)] = 'TRIANGLES'),
				(t[(t.TRIANGLE_STRIP = 5)] = 'TRIANGLE_STRIP'),
				(t[(t.TRIANGLE_FAN = 6)] = 'TRIANGLE_FAN');
		})(DRAW_MODES$1 || (DRAW_MODES$1 = {})),
		(function (t) {
			(t[(t.RGBA = 6408)] = 'RGBA'),
				(t[(t.RGB = 6407)] = 'RGB'),
				(t[(t.RG = 33319)] = 'RG'),
				(t[(t.RED = 6403)] = 'RED'),
				(t[(t.RGBA_INTEGER = 36249)] = 'RGBA_INTEGER'),
				(t[(t.RGB_INTEGER = 36248)] = 'RGB_INTEGER'),
				(t[(t.RG_INTEGER = 33320)] = 'RG_INTEGER'),
				(t[(t.RED_INTEGER = 36244)] = 'RED_INTEGER'),
				(t[(t.ALPHA = 6406)] = 'ALPHA'),
				(t[(t.LUMINANCE = 6409)] = 'LUMINANCE'),
				(t[(t.LUMINANCE_ALPHA = 6410)] = 'LUMINANCE_ALPHA'),
				(t[(t.DEPTH_COMPONENT = 6402)] = 'DEPTH_COMPONENT'),
				(t[(t.DEPTH_STENCIL = 34041)] = 'DEPTH_STENCIL');
		})(FORMATS$1 || (FORMATS$1 = {})),
		(function (t) {
			(t[(t.TEXTURE_2D = 3553)] = 'TEXTURE_2D'),
				(t[(t.TEXTURE_CUBE_MAP = 34067)] = 'TEXTURE_CUBE_MAP'),
				(t[(t.TEXTURE_2D_ARRAY = 35866)] = 'TEXTURE_2D_ARRAY'),
				(t[(t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069)] =
					'TEXTURE_CUBE_MAP_POSITIVE_X'),
				(t[(t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070)] =
					'TEXTURE_CUBE_MAP_NEGATIVE_X'),
				(t[(t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071)] =
					'TEXTURE_CUBE_MAP_POSITIVE_Y'),
				(t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072)] =
					'TEXTURE_CUBE_MAP_NEGATIVE_Y'),
				(t[(t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073)] =
					'TEXTURE_CUBE_MAP_POSITIVE_Z'),
				(t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074)] =
					'TEXTURE_CUBE_MAP_NEGATIVE_Z');
		})(TARGETS$1 || (TARGETS$1 = {})),
		(function (t) {
			(t[(t.UNSIGNED_BYTE = 5121)] = 'UNSIGNED_BYTE'),
				(t[(t.UNSIGNED_SHORT = 5123)] = 'UNSIGNED_SHORT'),
				(t[(t.UNSIGNED_SHORT_5_6_5 = 33635)] = 'UNSIGNED_SHORT_5_6_5'),
				(t[(t.UNSIGNED_SHORT_4_4_4_4 = 32819)] = 'UNSIGNED_SHORT_4_4_4_4'),
				(t[(t.UNSIGNED_SHORT_5_5_5_1 = 32820)] = 'UNSIGNED_SHORT_5_5_5_1'),
				(t[(t.UNSIGNED_INT = 5125)] = 'UNSIGNED_INT'),
				(t[(t.UNSIGNED_INT_10F_11F_11F_REV = 35899)] =
					'UNSIGNED_INT_10F_11F_11F_REV'),
				(t[(t.UNSIGNED_INT_2_10_10_10_REV = 33640)] =
					'UNSIGNED_INT_2_10_10_10_REV'),
				(t[(t.UNSIGNED_INT_24_8 = 34042)] = 'UNSIGNED_INT_24_8'),
				(t[(t.UNSIGNED_INT_5_9_9_9_REV = 35902)] = 'UNSIGNED_INT_5_9_9_9_REV'),
				(t[(t.BYTE = 5120)] = 'BYTE'),
				(t[(t.SHORT = 5122)] = 'SHORT'),
				(t[(t.INT = 5124)] = 'INT'),
				(t[(t.FLOAT = 5126)] = 'FLOAT'),
				(t[(t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269)] =
					'FLOAT_32_UNSIGNED_INT_24_8_REV'),
				(t[(t.HALF_FLOAT = 36193)] = 'HALF_FLOAT');
		})(TYPES$1 || (TYPES$1 = {})),
		(function (t) {
			(t[(t.FLOAT = 0)] = 'FLOAT'),
				(t[(t.INT = 1)] = 'INT'),
				(t[(t.UINT = 2)] = 'UINT');
		})(SAMPLER_TYPES$1 || (SAMPLER_TYPES$1 = {})),
		(function (t) {
			(t[(t.NEAREST = 0)] = 'NEAREST'), (t[(t.LINEAR = 1)] = 'LINEAR');
		})(SCALE_MODES$1 || (SCALE_MODES$1 = {})),
		(function (t) {
			(t[(t.CLAMP = 33071)] = 'CLAMP'),
				(t[(t.REPEAT = 10497)] = 'REPEAT'),
				(t[(t.MIRRORED_REPEAT = 33648)] = 'MIRRORED_REPEAT');
		})(WRAP_MODES$1 || (WRAP_MODES$1 = {})),
		(function (t) {
			(t[(t.OFF = 0)] = 'OFF'),
				(t[(t.POW2 = 1)] = 'POW2'),
				(t[(t.ON = 2)] = 'ON'),
				(t[(t.ON_MANUAL = 3)] = 'ON_MANUAL');
		})(MIPMAP_MODES$1 || (MIPMAP_MODES$1 = {})),
		(function (t) {
			(t[(t.NPM = 0)] = 'NPM'),
				(t[(t.UNPACK = 1)] = 'UNPACK'),
				(t[(t.PMA = 2)] = 'PMA'),
				(t[(t.NO_PREMULTIPLIED_ALPHA = 0)] = 'NO_PREMULTIPLIED_ALPHA'),
				(t[(t.PREMULTIPLY_ON_UPLOAD = 1)] = 'PREMULTIPLY_ON_UPLOAD'),
				(t[(t.PREMULTIPLY_ALPHA = 2)] = 'PREMULTIPLY_ALPHA'),
				(t[(t.PREMULTIPLIED_ALPHA = 2)] = 'PREMULTIPLIED_ALPHA');
		})(ALPHA_MODES$1 || (ALPHA_MODES$1 = {})),
		(function (t) {
			(t[(t.NO = 0)] = 'NO'),
				(t[(t.YES = 1)] = 'YES'),
				(t[(t.AUTO = 2)] = 'AUTO'),
				(t[(t.BLEND = 0)] = 'BLEND'),
				(t[(t.CLEAR = 1)] = 'CLEAR'),
				(t[(t.BLIT = 2)] = 'BLIT');
		})(CLEAR_MODES$1 || (CLEAR_MODES$1 = {})),
		(function (t) {
			(t[(t.AUTO = 0)] = 'AUTO'), (t[(t.MANUAL = 1)] = 'MANUAL');
		})(GC_MODES$1 || (GC_MODES$1 = {})),
		(function (t) {
			(t.LOW = 'lowp'), (t.MEDIUM = 'mediump'), (t.HIGH = 'highp');
		})(PRECISION$1 || (PRECISION$1 = {})),
		(function (t) {
			(t[(t.NONE = 0)] = 'NONE'),
				(t[(t.SCISSOR = 1)] = 'SCISSOR'),
				(t[(t.STENCIL = 2)] = 'STENCIL'),
				(t[(t.SPRITE = 3)] = 'SPRITE');
		})(MASK_TYPES$1 || (MASK_TYPES$1 = {})),
		(function (t) {
			(t[(t.NONE = 0)] = 'NONE'),
				(t[(t.LOW = 2)] = 'LOW'),
				(t[(t.MEDIUM = 4)] = 'MEDIUM'),
				(t[(t.HIGH = 8)] = 'HIGH');
		})(MSAA_QUALITY$1 || (MSAA_QUALITY$1 = {})),
		(function (t) {
			(t[(t.ELEMENT_ARRAY_BUFFER = 34963)] = 'ELEMENT_ARRAY_BUFFER'),
				(t[(t.ARRAY_BUFFER = 34962)] = 'ARRAY_BUFFER'),
				(t[(t.UNIFORM_BUFFER = 35345)] = 'UNIFORM_BUFFER');
		})(BUFFER_TYPE$1 || (BUFFER_TYPE$1 = {}));
	var settings = {
			MIPMAP_TEXTURES: MIPMAP_MODES$1.POW2,
			ANISOTROPIC_LEVEL: 0,
			RESOLUTION: 1,
			FILTER_RESOLUTION: 1,
			FILTER_MULTISAMPLE: MSAA_QUALITY$1.NONE,
			SPRITE_MAX_TEXTURES: maxRecommendedTextures(32),
			SPRITE_BATCH_SIZE: 4096,
			RENDER_OPTIONS: {
				view: null,
				antialias: !1,
				autoDensity: !1,
				backgroundColor: 0,
				backgroundAlpha: 1,
				useContextAlpha: !0,
				clearBeforeRender: !0,
				preserveDrawingBuffer: !1,
				width: 800,
				height: 600,
				legacy: !1,
			},
			GC_MODE: GC_MODES$1.AUTO,
			GC_MAX_IDLE: 3600,
			GC_MAX_CHECK_COUNT: 600,
			WRAP_MODE: WRAP_MODES$1.CLAMP,
			SCALE_MODE: SCALE_MODES$1.LINEAR,
			PRECISION_VERTEX: PRECISION$1.HIGH,
			PRECISION_FRAGMENT: isMobile.apple.device
				? PRECISION$1.HIGH
				: PRECISION$1.MEDIUM,
			CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer(),
			CREATE_IMAGE_BITMAP: !1,
			ROUND_PIXELS: !1,
		},
		ENV,
		RENDERER_TYPE,
		BUFFER_BITS,
		BLEND_MODES,
		DRAW_MODES,
		FORMATS,
		TARGETS,
		TYPES,
		SAMPLER_TYPES,
		SCALE_MODES,
		WRAP_MODES,
		MIPMAP_MODES,
		ALPHA_MODES,
		CLEAR_MODES,
		GC_MODES,
		PRECISION,
		MASK_TYPES,
		MSAA_QUALITY,
		BUFFER_TYPE;
	/*!
	 * @pixi/constants - v6.2.2
	 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
	 *
	 * @pixi/constants is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 */ !(function (t) {
		(t[(t.WEBGL_LEGACY = 0)] = 'WEBGL_LEGACY'),
			(t[(t.WEBGL = 1)] = 'WEBGL'),
			(t[(t.WEBGL2 = 2)] = 'WEBGL2');
	})(ENV || (ENV = {})),
		(function (t) {
			(t[(t.UNKNOWN = 0)] = 'UNKNOWN'),
				(t[(t.WEBGL = 1)] = 'WEBGL'),
				(t[(t.CANVAS = 2)] = 'CANVAS');
		})(RENDERER_TYPE || (RENDERER_TYPE = {})),
		(function (t) {
			(t[(t.COLOR = 16384)] = 'COLOR'),
				(t[(t.DEPTH = 256)] = 'DEPTH'),
				(t[(t.STENCIL = 1024)] = 'STENCIL');
		})(BUFFER_BITS || (BUFFER_BITS = {})),
		(function (t) {
			(t[(t.NORMAL = 0)] = 'NORMAL'),
				(t[(t.ADD = 1)] = 'ADD'),
				(t[(t.MULTIPLY = 2)] = 'MULTIPLY'),
				(t[(t.SCREEN = 3)] = 'SCREEN'),
				(t[(t.OVERLAY = 4)] = 'OVERLAY'),
				(t[(t.DARKEN = 5)] = 'DARKEN'),
				(t[(t.LIGHTEN = 6)] = 'LIGHTEN'),
				(t[(t.COLOR_DODGE = 7)] = 'COLOR_DODGE'),
				(t[(t.COLOR_BURN = 8)] = 'COLOR_BURN'),
				(t[(t.HARD_LIGHT = 9)] = 'HARD_LIGHT'),
				(t[(t.SOFT_LIGHT = 10)] = 'SOFT_LIGHT'),
				(t[(t.DIFFERENCE = 11)] = 'DIFFERENCE'),
				(t[(t.EXCLUSION = 12)] = 'EXCLUSION'),
				(t[(t.HUE = 13)] = 'HUE'),
				(t[(t.SATURATION = 14)] = 'SATURATION'),
				(t[(t.COLOR = 15)] = 'COLOR'),
				(t[(t.LUMINOSITY = 16)] = 'LUMINOSITY'),
				(t[(t.NORMAL_NPM = 17)] = 'NORMAL_NPM'),
				(t[(t.ADD_NPM = 18)] = 'ADD_NPM'),
				(t[(t.SCREEN_NPM = 19)] = 'SCREEN_NPM'),
				(t[(t.NONE = 20)] = 'NONE'),
				(t[(t.SRC_OVER = 0)] = 'SRC_OVER'),
				(t[(t.SRC_IN = 21)] = 'SRC_IN'),
				(t[(t.SRC_OUT = 22)] = 'SRC_OUT'),
				(t[(t.SRC_ATOP = 23)] = 'SRC_ATOP'),
				(t[(t.DST_OVER = 24)] = 'DST_OVER'),
				(t[(t.DST_IN = 25)] = 'DST_IN'),
				(t[(t.DST_OUT = 26)] = 'DST_OUT'),
				(t[(t.DST_ATOP = 27)] = 'DST_ATOP'),
				(t[(t.ERASE = 26)] = 'ERASE'),
				(t[(t.SUBTRACT = 28)] = 'SUBTRACT'),
				(t[(t.XOR = 29)] = 'XOR');
		})(BLEND_MODES || (BLEND_MODES = {})),
		(function (t) {
			(t[(t.POINTS = 0)] = 'POINTS'),
				(t[(t.LINES = 1)] = 'LINES'),
				(t[(t.LINE_LOOP = 2)] = 'LINE_LOOP'),
				(t[(t.LINE_STRIP = 3)] = 'LINE_STRIP'),
				(t[(t.TRIANGLES = 4)] = 'TRIANGLES'),
				(t[(t.TRIANGLE_STRIP = 5)] = 'TRIANGLE_STRIP'),
				(t[(t.TRIANGLE_FAN = 6)] = 'TRIANGLE_FAN');
		})(DRAW_MODES || (DRAW_MODES = {})),
		(function (t) {
			(t[(t.RGBA = 6408)] = 'RGBA'),
				(t[(t.RGB = 6407)] = 'RGB'),
				(t[(t.RG = 33319)] = 'RG'),
				(t[(t.RED = 6403)] = 'RED'),
				(t[(t.RGBA_INTEGER = 36249)] = 'RGBA_INTEGER'),
				(t[(t.RGB_INTEGER = 36248)] = 'RGB_INTEGER'),
				(t[(t.RG_INTEGER = 33320)] = 'RG_INTEGER'),
				(t[(t.RED_INTEGER = 36244)] = 'RED_INTEGER'),
				(t[(t.ALPHA = 6406)] = 'ALPHA'),
				(t[(t.LUMINANCE = 6409)] = 'LUMINANCE'),
				(t[(t.LUMINANCE_ALPHA = 6410)] = 'LUMINANCE_ALPHA'),
				(t[(t.DEPTH_COMPONENT = 6402)] = 'DEPTH_COMPONENT'),
				(t[(t.DEPTH_STENCIL = 34041)] = 'DEPTH_STENCIL');
		})(FORMATS || (FORMATS = {})),
		(function (t) {
			(t[(t.TEXTURE_2D = 3553)] = 'TEXTURE_2D'),
				(t[(t.TEXTURE_CUBE_MAP = 34067)] = 'TEXTURE_CUBE_MAP'),
				(t[(t.TEXTURE_2D_ARRAY = 35866)] = 'TEXTURE_2D_ARRAY'),
				(t[(t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069)] =
					'TEXTURE_CUBE_MAP_POSITIVE_X'),
				(t[(t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070)] =
					'TEXTURE_CUBE_MAP_NEGATIVE_X'),
				(t[(t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071)] =
					'TEXTURE_CUBE_MAP_POSITIVE_Y'),
				(t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072)] =
					'TEXTURE_CUBE_MAP_NEGATIVE_Y'),
				(t[(t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073)] =
					'TEXTURE_CUBE_MAP_POSITIVE_Z'),
				(t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074)] =
					'TEXTURE_CUBE_MAP_NEGATIVE_Z');
		})(TARGETS || (TARGETS = {})),
		(function (t) {
			(t[(t.UNSIGNED_BYTE = 5121)] = 'UNSIGNED_BYTE'),
				(t[(t.UNSIGNED_SHORT = 5123)] = 'UNSIGNED_SHORT'),
				(t[(t.UNSIGNED_SHORT_5_6_5 = 33635)] = 'UNSIGNED_SHORT_5_6_5'),
				(t[(t.UNSIGNED_SHORT_4_4_4_4 = 32819)] = 'UNSIGNED_SHORT_4_4_4_4'),
				(t[(t.UNSIGNED_SHORT_5_5_5_1 = 32820)] = 'UNSIGNED_SHORT_5_5_5_1'),
				(t[(t.UNSIGNED_INT = 5125)] = 'UNSIGNED_INT'),
				(t[(t.UNSIGNED_INT_10F_11F_11F_REV = 35899)] =
					'UNSIGNED_INT_10F_11F_11F_REV'),
				(t[(t.UNSIGNED_INT_2_10_10_10_REV = 33640)] =
					'UNSIGNED_INT_2_10_10_10_REV'),
				(t[(t.UNSIGNED_INT_24_8 = 34042)] = 'UNSIGNED_INT_24_8'),
				(t[(t.UNSIGNED_INT_5_9_9_9_REV = 35902)] = 'UNSIGNED_INT_5_9_9_9_REV'),
				(t[(t.BYTE = 5120)] = 'BYTE'),
				(t[(t.SHORT = 5122)] = 'SHORT'),
				(t[(t.INT = 5124)] = 'INT'),
				(t[(t.FLOAT = 5126)] = 'FLOAT'),
				(t[(t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269)] =
					'FLOAT_32_UNSIGNED_INT_24_8_REV'),
				(t[(t.HALF_FLOAT = 36193)] = 'HALF_FLOAT');
		})(TYPES || (TYPES = {})),
		(function (t) {
			(t[(t.FLOAT = 0)] = 'FLOAT'),
				(t[(t.INT = 1)] = 'INT'),
				(t[(t.UINT = 2)] = 'UINT');
		})(SAMPLER_TYPES || (SAMPLER_TYPES = {})),
		(function (t) {
			(t[(t.NEAREST = 0)] = 'NEAREST'), (t[(t.LINEAR = 1)] = 'LINEAR');
		})(SCALE_MODES || (SCALE_MODES = {})),
		(function (t) {
			(t[(t.CLAMP = 33071)] = 'CLAMP'),
				(t[(t.REPEAT = 10497)] = 'REPEAT'),
				(t[(t.MIRRORED_REPEAT = 33648)] = 'MIRRORED_REPEAT');
		})(WRAP_MODES || (WRAP_MODES = {})),
		(function (t) {
			(t[(t.OFF = 0)] = 'OFF'),
				(t[(t.POW2 = 1)] = 'POW2'),
				(t[(t.ON = 2)] = 'ON'),
				(t[(t.ON_MANUAL = 3)] = 'ON_MANUAL');
		})(MIPMAP_MODES || (MIPMAP_MODES = {})),
		(function (t) {
			(t[(t.NPM = 0)] = 'NPM'),
				(t[(t.UNPACK = 1)] = 'UNPACK'),
				(t[(t.PMA = 2)] = 'PMA'),
				(t[(t.NO_PREMULTIPLIED_ALPHA = 0)] = 'NO_PREMULTIPLIED_ALPHA'),
				(t[(t.PREMULTIPLY_ON_UPLOAD = 1)] = 'PREMULTIPLY_ON_UPLOAD'),
				(t[(t.PREMULTIPLY_ALPHA = 2)] = 'PREMULTIPLY_ALPHA'),
				(t[(t.PREMULTIPLIED_ALPHA = 2)] = 'PREMULTIPLIED_ALPHA');
		})(ALPHA_MODES || (ALPHA_MODES = {})),
		(function (t) {
			(t[(t.NO = 0)] = 'NO'),
				(t[(t.YES = 1)] = 'YES'),
				(t[(t.AUTO = 2)] = 'AUTO'),
				(t[(t.BLEND = 0)] = 'BLEND'),
				(t[(t.CLEAR = 1)] = 'CLEAR'),
				(t[(t.BLIT = 2)] = 'BLIT');
		})(CLEAR_MODES || (CLEAR_MODES = {})),
		(function (t) {
			(t[(t.AUTO = 0)] = 'AUTO'), (t[(t.MANUAL = 1)] = 'MANUAL');
		})(GC_MODES || (GC_MODES = {})),
		(function (t) {
			(t.LOW = 'lowp'), (t.MEDIUM = 'mediump'), (t.HIGH = 'highp');
		})(PRECISION || (PRECISION = {})),
		(function (t) {
			(t[(t.NONE = 0)] = 'NONE'),
				(t[(t.SCISSOR = 1)] = 'SCISSOR'),
				(t[(t.STENCIL = 2)] = 'STENCIL'),
				(t[(t.SPRITE = 3)] = 'SPRITE');
		})(MASK_TYPES || (MASK_TYPES = {})),
		(function (t) {
			(t[(t.NONE = 0)] = 'NONE'),
				(t[(t.LOW = 2)] = 'LOW'),
				(t[(t.MEDIUM = 4)] = 'MEDIUM'),
				(t[(t.HIGH = 8)] = 'HIGH');
		})(MSAA_QUALITY || (MSAA_QUALITY = {})),
		(function (t) {
			(t[(t.ELEMENT_ARRAY_BUFFER = 34963)] = 'ELEMENT_ARRAY_BUFFER'),
				(t[(t.ARRAY_BUFFER = 34962)] = 'ARRAY_BUFFER'),
				(t[(t.UNIFORM_BUFFER = 35345)] = 'UNIFORM_BUFFER');
		})(BUFFER_TYPE || (BUFFER_TYPE = {}));
	const { parse } = url$1,
		{ format } = url$1,
		{ resolve } = url$1;
	/*!
	 * @pixi/utils - v6.2.2
	 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
	 *
	 * @pixi/utils is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 */
	var url2 = { parse, format, resolve };
	(settings.RETINA_PREFIX = /@([0-9\.]+)x/),
		(settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1);
	var saidHello = !1,
		VERSION = '6.2.2',
		supported;
	function sayHello(t) {
		var e;
		if (!saidHello) {
			if (navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
				var i = [
					'\n %c %c %c PixiJS ' +
						VERSION +
						' - ✰ ' +
						t +
						' ✰  %c  %c  http://www.pixijs.com/  %c %c ♥%c♥%c♥ \n\n',
					'background: #ff66a5; padding:5px 0;',
					'background: #ff66a5; padding:5px 0;',
					'color: #ff66a5; background: #030307; padding:5px 0;',
					'background: #ff66a5; padding:5px 0;',
					'background: #ffc3dc; padding:5px 0;',
					'background: #ff66a5; padding:5px 0;',
					'color: #ff2424; background: #fff; padding:5px 0;',
					'color: #ff2424; background: #fff; padding:5px 0;',
					'color: #ff2424; background: #fff; padding:5px 0;',
				];
				(e = self.console).log.apply(e, i);
			} else
				self.console &&
					self.console.log(
						'PixiJS ' + VERSION + ' - ' + t + ' - http://www.pixijs.com/'
					);
			saidHello = !0;
		}
	}
	function isWebGLSupported() {
		return (
			void 0 === supported &&
				(supported = (function () {
					var t = {
						stencil: !0,
						failIfMajorPerformanceCaveat:
							settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT,
					};
					try {
						if (!self.WebGLRenderingContext) return !1;
						var e = document.createElement('canvas'),
							i =
								e.getContext('webgl', t) ||
								e.getContext('experimental-webgl', t),
							r = !(!i || !i.getContextAttributes().stencil);
						if (i) {
							var s = i.getExtension('WEBGL_lose_context');
							s && s.loseContext();
						}
						return (i = null), r;
					} catch (t) {
						return !1;
					}
				})()),
			supported
		);
	}
	function hex2rgb(t, e) {
		return (
			void 0 === e && (e = []),
			(e[0] = ((t >> 16) & 255) / 255),
			(e[1] = ((t >> 8) & 255) / 255),
			(e[2] = (255 & t) / 255),
			e
		);
	}
	function hex2string(t) {
		var e = t.toString(16);
		return '#' + ('000000'.substr(0, 6 - e.length) + e);
	}
	function mapPremultipliedBlendModes() {
		for (var t = [], e = [], i = 0; i < 32; i++) (t[i] = i), (e[i] = i);
		(t[BLEND_MODES.NORMAL_NPM] = BLEND_MODES.NORMAL),
			(t[BLEND_MODES.ADD_NPM] = BLEND_MODES.ADD),
			(t[BLEND_MODES.SCREEN_NPM] = BLEND_MODES.SCREEN),
			(e[BLEND_MODES.NORMAL] = BLEND_MODES.NORMAL_NPM),
			(e[BLEND_MODES.ADD] = BLEND_MODES.ADD_NPM),
			(e[BLEND_MODES.SCREEN] = BLEND_MODES.SCREEN_NPM);
		var r = [];
		return r.push(e), r.push(t), r;
	}
	var premultiplyBlendMode = mapPremultipliedBlendModes();
	function premultiplyTint(t, e) {
		if (1 === e) return ((255 * e) << 24) + t;
		if (0 === e) return 0;
		var i = (t >> 16) & 255,
			r = (t >> 8) & 255,
			s = 255 & t;
		return (
			((255 * e) << 24) +
			((i = (i * e + 0.5) | 0) << 16) +
			((r = (r * e + 0.5) | 0) << 8) +
			((s * e + 0.5) | 0)
		);
	}
	function getBufferType(t) {
		if (4 === t.BYTES_PER_ELEMENT)
			return t instanceof Float32Array
				? 'Float32Array'
				: t instanceof Uint32Array
				? 'Uint32Array'
				: 'Int32Array';
		if (2 === t.BYTES_PER_ELEMENT) {
			if (t instanceof Uint16Array) return 'Uint16Array';
		} else if (1 === t.BYTES_PER_ELEMENT && t instanceof Uint8Array)
			return 'Uint8Array';
		return null;
	}
	function nextPow2(t) {
		return (
			(t += 0 === t ? 1 : 0),
			--t,
			(t |= t >>> 1),
			(t |= t >>> 2),
			(t |= t >>> 4),
			(t |= t >>> 8),
			1 + (t |= t >>> 16)
		);
	}
	function isPow2(t) {
		return !(t & (t - 1) || !t);
	}
	function log2(t) {
		var e = (t > 65535 ? 1 : 0) << 4,
			i = ((t >>>= e) > 255 ? 1 : 0) << 3;
		return (
			(e |= i),
			(e |= i = ((t >>>= i) > 15 ? 1 : 0) << 2),
			(e |= i = ((t >>>= i) > 3 ? 1 : 0) << 1) | ((t >>>= i) >> 1)
		);
	}
	function removeItems(t, e, i) {
		var r,
			s = t.length;
		if (!(e >= s || 0 === i)) {
			var n = s - (i = e + i > s ? s - e : i);
			for (r = e; r < n; ++r) t[r] = t[r + i];
			t.length = n;
		}
	}
	var nextUid = 0;
	function uid() {
		return ++nextUid;
	}
	var warnings = {};
	function deprecation(t, e, i) {
		if ((void 0 === i && (i = 3), !warnings[e])) {
			var r = new Error().stack;
			void 0 === r ||
				((r = r.split('\n').splice(i).join('\n')), console.groupCollapsed),
				(warnings[e] = !0);
		}
	}
	var ProgramCache = {},
		TextureCache = Object.create(null),
		BaseTextureCache = Object.create(null),
		tempAnchor;
	function determineCrossOrigin(t, e) {
		if ((void 0 === e && (e = self.location), 0 === t.indexOf('data:')))
			return '';
		(e = e || self.location),
			tempAnchor || (tempAnchor = document.createElement('a')),
			(tempAnchor.href = t);
		var i = url2.parse(tempAnchor.href),
			r = (!i.port && '' === e.port) || i.port === e.port;
		return i.hostname === e.hostname && r && i.protocol === e.protocol
			? ''
			: 'anonymous';
	}
	function getResolutionOfUrl(t, e) {
		var i = settings.RETINA_PREFIX.exec(t);
		return i ? parseFloat(i[1]) : void 0 !== e ? e : 1;
	}
	/*!
	 * @pixi/runner - v6.2.2
	 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
	 *
	 * @pixi/runner is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 */ !(function () {
		function t(t, e, i) {
			(this.canvas = document.createElement('canvas')),
				(this.context = this.canvas.getContext('2d')),
				(this.resolution = i || settings.RESOLUTION),
				this.resize(t, e);
		}
		(t.prototype.clear = function () {
			this.context.setTransform(1, 0, 0, 1, 0, 0),
				this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
		}),
			(t.prototype.resize = function (t, e) {
				(this.canvas.width = Math.round(t * this.resolution)),
					(this.canvas.height = Math.round(e * this.resolution));
			}),
			(t.prototype.destroy = function () {
				(this.context = null), (this.canvas = null);
			}),
			Object.defineProperty(t.prototype, 'width', {
				get: function () {
					return this.canvas.width;
				},
				set: function (t) {
					this.canvas.width = Math.round(t);
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(t.prototype, 'height', {
				get: function () {
					return this.canvas.height;
				},
				set: function (t) {
					this.canvas.height = Math.round(t);
				},
				enumerable: !1,
				configurable: !0,
			});
	})();
	var Runner = (function () {
			function t(t) {
				(this.items = []), (this._name = t), (this._aliasCount = 0);
			}
			return (
				(t.prototype.emit = function (t, e, i, r, s, n, a, o) {
					if (arguments.length > 8) throw new Error('max arguments reached');
					var h = this,
						u = h.name,
						l = h.items;
					this._aliasCount++;
					for (var c = 0, d = l.length; c < d; c++)
						l[c][u](t, e, i, r, s, n, a, o);
					return l === this.items && this._aliasCount--, this;
				}),
				(t.prototype.ensureNonAliasedItems = function () {
					this._aliasCount > 0 &&
						this.items.length > 1 &&
						((this._aliasCount = 0), (this.items = this.items.slice(0)));
				}),
				(t.prototype.add = function (t) {
					return (
						t[this._name] &&
							(this.ensureNonAliasedItems(),
							this.remove(t),
							this.items.push(t)),
						this
					);
				}),
				(t.prototype.remove = function (t) {
					var e = this.items.indexOf(t);
					return (
						-1 !== e && (this.ensureNonAliasedItems(), this.items.splice(e, 1)),
						this
					);
				}),
				(t.prototype.contains = function (t) {
					return -1 !== this.items.indexOf(t);
				}),
				(t.prototype.removeAll = function () {
					return this.ensureNonAliasedItems(), (this.items.length = 0), this;
				}),
				(t.prototype.destroy = function () {
					this.removeAll(), (this.items = null), (this._name = null);
				}),
				Object.defineProperty(t.prototype, 'empty', {
					get: function () {
						return 0 === this.items.length;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'name', {
					get: function () {
						return this._name;
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			);
		})(),
		UPDATE_PRIORITY;
	Object.defineProperties(Runner.prototype, {
		dispatch: { value: Runner.prototype.emit },
		run: { value: Runner.prototype.emit },
	}),
		/*!
		 * @pixi/ticker - v6.2.2
		 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
		 *
		 * @pixi/ticker is licensed under the MIT License.
		 * http://www.opensource.org/licenses/mit-license
		 */
		(settings.TARGET_FPMS = 0.06),
		(function (t) {
			(t[(t.INTERACTION = 50)] = 'INTERACTION'),
				(t[(t.HIGH = 25)] = 'HIGH'),
				(t[(t.NORMAL = 0)] = 'NORMAL'),
				(t[(t.LOW = -25)] = 'LOW'),
				(t[(t.UTILITY = -50)] = 'UTILITY');
		})(UPDATE_PRIORITY || (UPDATE_PRIORITY = {}));
	var TickerListener = (function () {
			function t(t, e, i, r) {
				void 0 === e && (e = null),
					void 0 === i && (i = 0),
					void 0 === r && (r = !1),
					(this.next = null),
					(this.previous = null),
					(this._destroyed = !1),
					(this.fn = t),
					(this.context = e),
					(this.priority = i),
					(this.once = r);
			}
			return (
				(t.prototype.match = function (t, e) {
					return (
						void 0 === e && (e = null), this.fn === t && this.context === e
					);
				}),
				(t.prototype.emit = function (t) {
					this.fn &&
						(this.context ? this.fn.call(this.context, t) : this.fn(t));
					var e = this.next;
					return (
						this.once && this.destroy(!0),
						this._destroyed && (this.next = null),
						e
					);
				}),
				(t.prototype.connect = function (t) {
					(this.previous = t),
						t.next && (t.next.previous = this),
						(this.next = t.next),
						(t.next = this);
				}),
				(t.prototype.destroy = function (t) {
					void 0 === t && (t = !1),
						(this._destroyed = !0),
						(this.fn = null),
						(this.context = null),
						this.previous && (this.previous.next = this.next),
						this.next && (this.next.previous = this.previous);
					var e = this.next;
					return (this.next = t ? null : e), (this.previous = null), e;
				}),
				t
			);
		})(),
		Ticker = (function () {
			function t() {
				var t = this;
				(this.autoStart = !1),
					(this.deltaTime = 1),
					(this.lastTime = -1),
					(this.speed = 1),
					(this.started = !1),
					(this._requestId = null),
					(this._maxElapsedMS = 100),
					(this._minElapsedMS = 0),
					(this._protected = !1),
					(this._lastFrame = -1),
					(this._head = new TickerListener(null, null, 1 / 0)),
					(this.deltaMS = 1 / settings.TARGET_FPMS),
					(this.elapsedMS = 1 / settings.TARGET_FPMS),
					(this._tick = function (e) {
						(t._requestId = null),
							t.started &&
								(t.update(e),
								t.started &&
									null === t._requestId &&
									t._head.next &&
									(t._requestId = requestAnimationFrame(t._tick)));
					});
			}
			return (
				(t.prototype._requestIfNeeded = function () {
					null === this._requestId &&
						this._head.next &&
						((this.lastTime = performance.now()),
						(this._lastFrame = this.lastTime),
						(this._requestId = requestAnimationFrame(this._tick)));
				}),
				(t.prototype._cancelIfNeeded = function () {
					null !== this._requestId &&
						(cancelAnimationFrame(this._requestId), (this._requestId = null));
				}),
				(t.prototype._startIfPossible = function () {
					this.started
						? this._requestIfNeeded()
						: this.autoStart && this.start();
				}),
				(t.prototype.add = function (t, e, i) {
					return (
						void 0 === i && (i = UPDATE_PRIORITY.NORMAL),
						this._addListener(new TickerListener(t, e, i))
					);
				}),
				(t.prototype.addOnce = function (t, e, i) {
					return (
						void 0 === i && (i = UPDATE_PRIORITY.NORMAL),
						this._addListener(new TickerListener(t, e, i, !0))
					);
				}),
				(t.prototype._addListener = function (t) {
					var e = this._head.next,
						i = this._head;
					if (e) {
						for (; e; ) {
							if (t.priority > e.priority) {
								t.connect(i);
								break;
							}
							(i = e), (e = e.next);
						}
						t.previous || t.connect(i);
					} else t.connect(i);
					return this._startIfPossible(), this;
				}),
				(t.prototype.remove = function (t, e) {
					for (var i = this._head.next; i; )
						i = i.match(t, e) ? i.destroy() : i.next;
					return this._head.next || this._cancelIfNeeded(), this;
				}),
				Object.defineProperty(t.prototype, 'count', {
					get: function () {
						if (!this._head) return 0;
						for (var t = 0, e = this._head; (e = e.next); ) t++;
						return t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.start = function () {
					this.started || ((this.started = !0), this._requestIfNeeded());
				}),
				(t.prototype.stop = function () {
					this.started && ((this.started = !1), this._cancelIfNeeded());
				}),
				(t.prototype.destroy = function () {
					if (!this._protected) {
						this.stop();
						for (var t = this._head.next; t; ) t = t.destroy(!0);
						this._head.destroy(), (this._head = null);
					}
				}),
				(t.prototype.update = function (t) {
					var e;
					if ((void 0 === t && (t = performance.now()), t > this.lastTime)) {
						if (
							((e = this.elapsedMS = t - this.lastTime) > this._maxElapsedMS &&
								(e = this._maxElapsedMS),
							(e *= this.speed),
							this._minElapsedMS)
						) {
							var i = (t - this._lastFrame) | 0;
							if (i < this._minElapsedMS) return;
							this._lastFrame = t - (i % this._minElapsedMS);
						}
						(this.deltaMS = e),
							(this.deltaTime = this.deltaMS * settings.TARGET_FPMS);
						for (var r = this._head, s = r.next; s; )
							s = s.emit(this.deltaTime);
						r.next || this._cancelIfNeeded();
					} else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
					this.lastTime = t;
				}),
				Object.defineProperty(t.prototype, 'FPS', {
					get: function () {
						return 1e3 / this.elapsedMS;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'minFPS', {
					get: function () {
						return 1e3 / this._maxElapsedMS;
					},
					set: function (t) {
						var e = Math.min(this.maxFPS, t),
							i = Math.min(Math.max(0, e) / 1e3, settings.TARGET_FPMS);
						this._maxElapsedMS = 1 / i;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'maxFPS', {
					get: function () {
						return this._minElapsedMS
							? Math.round(1e3 / this._minElapsedMS)
							: 0;
					},
					set: function (t) {
						if (0 === t) this._minElapsedMS = 0;
						else {
							var e = Math.max(this.minFPS, t);
							this._minElapsedMS = 1 / (e / 1e3);
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t, 'shared', {
					get: function () {
						if (!t._shared) {
							var e = (t._shared = new t());
							(e.autoStart = !0), (e._protected = !0);
						}
						return t._shared;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t, 'system', {
					get: function () {
						if (!t._system) {
							var e = (t._system = new t());
							(e.autoStart = !0), (e._protected = !0);
						}
						return t._system;
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			);
		})(),
		PI_2 = 2 * Math.PI,
		SHAPES;
	!(function (t) {
		(t[(t.POLY = 0)] = 'POLY'),
			(t[(t.RECT = 1)] = 'RECT'),
			(t[(t.CIRC = 2)] = 'CIRC'),
			(t[(t.ELIP = 3)] = 'ELIP'),
			(t[(t.RREC = 4)] = 'RREC');
	})(SHAPES || (SHAPES = {}));
	var Rectangle$1 = (function () {
			function t(t, e, i, r) {
				void 0 === t && (t = 0),
					void 0 === e && (e = 0),
					void 0 === i && (i = 0),
					void 0 === r && (r = 0),
					(this.x = Number(t)),
					(this.y = Number(e)),
					(this.width = Number(i)),
					(this.height = Number(r)),
					(this.type = SHAPES.RECT);
			}
			return (
				Object.defineProperty(t.prototype, 'left', {
					get: function () {
						return this.x;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'right', {
					get: function () {
						return this.x + this.width;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'top', {
					get: function () {
						return this.y;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'bottom', {
					get: function () {
						return this.y + this.height;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t, 'EMPTY', {
					get: function () {
						return new t(0, 0, 0, 0);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.clone = function () {
					return new t(this.x, this.y, this.width, this.height);
				}),
				(t.prototype.copyFrom = function (t) {
					return (
						(this.x = t.x),
						(this.y = t.y),
						(this.width = t.width),
						(this.height = t.height),
						this
					);
				}),
				(t.prototype.copyTo = function (t) {
					return (
						(t.x = this.x),
						(t.y = this.y),
						(t.width = this.width),
						(t.height = this.height),
						t
					);
				}),
				(t.prototype.contains = function (t, e) {
					return (
						!(this.width <= 0 || this.height <= 0) &&
						t >= this.x &&
						t < this.x + this.width &&
						e >= this.y &&
						e < this.y + this.height
					);
				}),
				(t.prototype.pad = function (t, e) {
					return (
						void 0 === t && (t = 0),
						void 0 === e && (e = t),
						(this.x -= t),
						(this.y -= e),
						(this.width += 2 * t),
						(this.height += 2 * e),
						this
					);
				}),
				(t.prototype.fit = function (t) {
					var e = Math.max(this.x, t.x),
						i = Math.min(this.x + this.width, t.x + t.width),
						r = Math.max(this.y, t.y),
						s = Math.min(this.y + this.height, t.y + t.height);
					return (
						(this.x = e),
						(this.width = Math.max(i - e, 0)),
						(this.y = r),
						(this.height = Math.max(s - r, 0)),
						this
					);
				}),
				(t.prototype.ceil = function (t, e) {
					void 0 === t && (t = 1), void 0 === e && (e = 0.001);
					var i = Math.ceil((this.x + this.width - e) * t) / t,
						r = Math.ceil((this.y + this.height - e) * t) / t;
					return (
						(this.x = Math.floor((this.x + e) * t) / t),
						(this.y = Math.floor((this.y + e) * t) / t),
						(this.width = i - this.x),
						(this.height = r - this.y),
						this
					);
				}),
				(t.prototype.enlarge = function (t) {
					var e = Math.min(this.x, t.x),
						i = Math.max(this.x + this.width, t.x + t.width),
						r = Math.min(this.y, t.y),
						s = Math.max(this.y + this.height, t.y + t.height);
					return (
						(this.x = e),
						(this.width = i - e),
						(this.y = r),
						(this.height = s - r),
						this
					);
				}),
				(t.prototype.toString = function () {
					return (
						'[@pixi/math:Rectangle x=' +
						this.x +
						' y=' +
						this.y +
						' width=' +
						this.width +
						' height=' +
						this.height +
						']'
					);
				}),
				t
			);
		})(),
		Point$1 = (function () {
			function t(t, e) {
				void 0 === t && (t = 0),
					void 0 === e && (e = 0),
					(this.x = 0),
					(this.y = 0),
					(this.x = t),
					(this.y = e);
			}
			return (
				(t.prototype.clone = function () {
					return new t(this.x, this.y);
				}),
				(t.prototype.copyFrom = function (t) {
					return this.set(t.x, t.y), this;
				}),
				(t.prototype.copyTo = function (t) {
					return t.set(this.x, this.y), t;
				}),
				(t.prototype.equals = function (t) {
					return t.x === this.x && t.y === this.y;
				}),
				(t.prototype.set = function (t, e) {
					return (
						void 0 === t && (t = 0),
						void 0 === e && (e = t),
						(this.x = t),
						(this.y = e),
						this
					);
				}),
				(t.prototype.toString = function () {
					return '[@pixi/math:Point x=' + this.x + ' y=' + this.y + ']';
				}),
				t
			);
		})(),
		ObservablePoint = (function () {
			function t(t, e, i, r) {
				void 0 === i && (i = 0),
					void 0 === r && (r = 0),
					(this._x = i),
					(this._y = r),
					(this.cb = t),
					(this.scope = e);
			}
			return (
				(t.prototype.clone = function (e, i) {
					return (
						void 0 === e && (e = this.cb),
						void 0 === i && (i = this.scope),
						new t(e, i, this._x, this._y)
					);
				}),
				(t.prototype.set = function (t, e) {
					return (
						void 0 === t && (t = 0),
						void 0 === e && (e = t),
						(this._x === t && this._y === e) ||
							((this._x = t), (this._y = e), this.cb.call(this.scope)),
						this
					);
				}),
				(t.prototype.copyFrom = function (t) {
					return (
						(this._x === t.x && this._y === t.y) ||
							((this._x = t.x), (this._y = t.y), this.cb.call(this.scope)),
						this
					);
				}),
				(t.prototype.copyTo = function (t) {
					return t.set(this._x, this._y), t;
				}),
				(t.prototype.equals = function (t) {
					return t.x === this._x && t.y === this._y;
				}),
				(t.prototype.toString = function () {
					return (
						'[@pixi/math:ObservablePoint x=0 y=0 scope=' + this.scope + ']'
					);
				}),
				Object.defineProperty(t.prototype, 'x', {
					get: function () {
						return this._x;
					},
					set: function (t) {
						this._x !== t && ((this._x = t), this.cb.call(this.scope));
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'y', {
					get: function () {
						return this._y;
					},
					set: function (t) {
						this._y !== t && ((this._y = t), this.cb.call(this.scope));
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			);
		})(),
		Matrix = (function () {
			function t(t, e, i, r, s, n) {
				void 0 === t && (t = 1),
					void 0 === e && (e = 0),
					void 0 === i && (i = 0),
					void 0 === r && (r = 1),
					void 0 === s && (s = 0),
					void 0 === n && (n = 0),
					(this.array = null),
					(this.a = t),
					(this.b = e),
					(this.c = i),
					(this.d = r),
					(this.tx = s),
					(this.ty = n);
			}
			return (
				(t.prototype.fromArray = function (t) {
					(this.a = t[0]),
						(this.b = t[1]),
						(this.c = t[3]),
						(this.d = t[4]),
						(this.tx = t[2]),
						(this.ty = t[5]);
				}),
				(t.prototype.set = function (t, e, i, r, s, n) {
					return (
						(this.a = t),
						(this.b = e),
						(this.c = i),
						(this.d = r),
						(this.tx = s),
						(this.ty = n),
						this
					);
				}),
				(t.prototype.toArray = function (t, e) {
					this.array || (this.array = new Float32Array(9));
					var i = e || this.array;
					return (
						t
							? ((i[0] = this.a),
							  (i[1] = this.b),
							  (i[2] = 0),
							  (i[3] = this.c),
							  (i[4] = this.d),
							  (i[5] = 0),
							  (i[6] = this.tx),
							  (i[7] = this.ty),
							  (i[8] = 1))
							: ((i[0] = this.a),
							  (i[1] = this.c),
							  (i[2] = this.tx),
							  (i[3] = this.b),
							  (i[4] = this.d),
							  (i[5] = this.ty),
							  (i[6] = 0),
							  (i[7] = 0),
							  (i[8] = 1)),
						i
					);
				}),
				(t.prototype.apply = function (t, e) {
					e = e || new Point$1();
					var i = t.x,
						r = t.y;
					return (
						(e.x = this.a * i + this.c * r + this.tx),
						(e.y = this.b * i + this.d * r + this.ty),
						e
					);
				}),
				(t.prototype.applyInverse = function (t, e) {
					e = e || new Point$1();
					var i = 1 / (this.a * this.d + this.c * -this.b),
						r = t.x,
						s = t.y;
					return (
						(e.x =
							this.d * i * r +
							-this.c * i * s +
							(this.ty * this.c - this.tx * this.d) * i),
						(e.y =
							this.a * i * s +
							-this.b * i * r +
							(-this.ty * this.a + this.tx * this.b) * i),
						e
					);
				}),
				(t.prototype.translate = function (t, e) {
					return (this.tx += t), (this.ty += e), this;
				}),
				(t.prototype.scale = function (t, e) {
					return (
						(this.a *= t),
						(this.d *= e),
						(this.c *= t),
						(this.b *= e),
						(this.tx *= t),
						(this.ty *= e),
						this
					);
				}),
				(t.prototype.rotate = function (t) {
					var e = Math.cos(t),
						i = Math.sin(t),
						r = this.a,
						s = this.c,
						n = this.tx;
					return (
						(this.a = r * e - this.b * i),
						(this.b = r * i + this.b * e),
						(this.c = s * e - this.d * i),
						(this.d = s * i + this.d * e),
						(this.tx = n * e - this.ty * i),
						(this.ty = n * i + this.ty * e),
						this
					);
				}),
				(t.prototype.append = function (t) {
					var e = this.a,
						i = this.b,
						r = this.c,
						s = this.d;
					return (
						(this.a = t.a * e + t.b * r),
						(this.b = t.a * i + t.b * s),
						(this.c = t.c * e + t.d * r),
						(this.d = t.c * i + t.d * s),
						(this.tx = t.tx * e + t.ty * r + this.tx),
						(this.ty = t.tx * i + t.ty * s + this.ty),
						this
					);
				}),
				(t.prototype.setTransform = function (t, e, i, r, s, n, a, o, h) {
					return (
						(this.a = Math.cos(a + h) * s),
						(this.b = Math.sin(a + h) * s),
						(this.c = -Math.sin(a - o) * n),
						(this.d = Math.cos(a - o) * n),
						(this.tx = t - (i * this.a + r * this.c)),
						(this.ty = e - (i * this.b + r * this.d)),
						this
					);
				}),
				(t.prototype.prepend = function (t) {
					var e = this.tx;
					if (1 !== t.a || 0 !== t.b || 0 !== t.c || 1 !== t.d) {
						var i = this.a,
							r = this.c;
						(this.a = i * t.a + this.b * t.c),
							(this.b = i * t.b + this.b * t.d),
							(this.c = r * t.a + this.d * t.c),
							(this.d = r * t.b + this.d * t.d);
					}
					return (
						(this.tx = e * t.a + this.ty * t.c + t.tx),
						(this.ty = e * t.b + this.ty * t.d + t.ty),
						this
					);
				}),
				(t.prototype.decompose = function (t) {
					var e = this.a,
						i = this.b,
						r = this.c,
						s = this.d,
						n = t.pivot,
						a = -Math.atan2(-r, s),
						o = Math.atan2(i, e),
						h = Math.abs(a + o);
					return (
						h < 1e-5 || Math.abs(PI_2 - h) < 1e-5
							? ((t.rotation = o), (t.skew.x = t.skew.y = 0))
							: ((t.rotation = 0), (t.skew.x = a), (t.skew.y = o)),
						(t.scale.x = Math.sqrt(e * e + i * i)),
						(t.scale.y = Math.sqrt(r * r + s * s)),
						(t.position.x = this.tx + (n.x * e + n.y * r)),
						(t.position.y = this.ty + (n.x * i + n.y * s)),
						t
					);
				}),
				(t.prototype.invert = function () {
					var t = this.a,
						e = this.b,
						i = this.c,
						r = this.d,
						s = this.tx,
						n = t * r - e * i;
					return (
						(this.a = r / n),
						(this.b = -e / n),
						(this.c = -i / n),
						(this.d = t / n),
						(this.tx = (i * this.ty - r * s) / n),
						(this.ty = -(t * this.ty - e * s) / n),
						this
					);
				}),
				(t.prototype.identity = function () {
					return (
						(this.a = 1),
						(this.b = 0),
						(this.c = 0),
						(this.d = 1),
						(this.tx = 0),
						(this.ty = 0),
						this
					);
				}),
				(t.prototype.clone = function () {
					var e = new t();
					return (
						(e.a = this.a),
						(e.b = this.b),
						(e.c = this.c),
						(e.d = this.d),
						(e.tx = this.tx),
						(e.ty = this.ty),
						e
					);
				}),
				(t.prototype.copyTo = function (t) {
					return (
						(t.a = this.a),
						(t.b = this.b),
						(t.c = this.c),
						(t.d = this.d),
						(t.tx = this.tx),
						(t.ty = this.ty),
						t
					);
				}),
				(t.prototype.copyFrom = function (t) {
					return (
						(this.a = t.a),
						(this.b = t.b),
						(this.c = t.c),
						(this.d = t.d),
						(this.tx = t.tx),
						(this.ty = t.ty),
						this
					);
				}),
				(t.prototype.toString = function () {
					return (
						'[@pixi/math:Matrix a=' +
						this.a +
						' b=' +
						this.b +
						' c=' +
						this.c +
						' d=' +
						this.d +
						' tx=' +
						this.tx +
						' ty=' +
						this.ty +
						']'
					);
				}),
				Object.defineProperty(t, 'IDENTITY', {
					get: function () {
						return new t();
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t, 'TEMP_MATRIX', {
					get: function () {
						return new t();
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			);
		})(),
		ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1],
		uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1],
		vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1],
		vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1],
		rotationCayley = [],
		rotationMatrices = [],
		signum = Math.sign;
	function init() {
		for (var t = 0; t < 16; t++) {
			var e = [];
			rotationCayley.push(e);
			for (var i = 0; i < 16; i++)
				for (
					var r = signum(ux[t] * ux[i] + vx[t] * uy[i]),
						s = signum(uy[t] * ux[i] + vy[t] * uy[i]),
						n = signum(ux[t] * vx[i] + vx[t] * vy[i]),
						a = signum(uy[t] * vx[i] + vy[t] * vy[i]),
						o = 0;
					o < 16;
					o++
				)
					if (ux[o] === r && uy[o] === s && vx[o] === n && vy[o] === a) {
						e.push(o);
						break;
					}
		}
		for (t = 0; t < 16; t++) {
			var h = new Matrix();
			h.set(ux[t], uy[t], vx[t], vy[t], 0, 0), rotationMatrices.push(h);
		}
	}
	init();
	var groupD8 = {
		E: 0,
		SE: 1,
		S: 2,
		SW: 3,
		W: 4,
		NW: 5,
		N: 6,
		NE: 7,
		MIRROR_VERTICAL: 8,
		MAIN_DIAGONAL: 10,
		MIRROR_HORIZONTAL: 12,
		REVERSE_DIAGONAL: 14,
		uX: function (t) {
			return ux[t];
		},
		uY: function (t) {
			return uy[t];
		},
		vX: function (t) {
			return vx[t];
		},
		vY: function (t) {
			return vy[t];
		},
		inv: function (t) {
			return 8 & t ? 15 & t : 7 & -t;
		},
		add: function (t, e) {
			return rotationCayley[t][e];
		},
		sub: function (t, e) {
			return rotationCayley[t][groupD8.inv(e)];
		},
		rotate180: function (t) {
			return 4 ^ t;
		},
		isVertical: function (t) {
			return 2 == (3 & t);
		},
		byDirection: function (t, e) {
			return 2 * Math.abs(t) <= Math.abs(e)
				? e >= 0
					? groupD8.S
					: groupD8.N
				: 2 * Math.abs(e) <= Math.abs(t)
				? t > 0
					? groupD8.E
					: groupD8.W
				: e > 0
				? t > 0
					? groupD8.SE
					: groupD8.SW
				: t > 0
				? groupD8.NE
				: groupD8.NW;
		},
		matrixAppendRotationInv: function (t, e, i, r) {
			void 0 === i && (i = 0), void 0 === r && (r = 0);
			var s = rotationMatrices[groupD8.inv(e)];
			(s.tx = i), (s.ty = r), t.append(s);
		},
	};
	!(function () {
		function t() {
			(this.worldTransform = new Matrix()),
				(this.localTransform = new Matrix()),
				(this.position = new ObservablePoint(this.onChange, this, 0, 0)),
				(this.scale = new ObservablePoint(this.onChange, this, 1, 1)),
				(this.pivot = new ObservablePoint(this.onChange, this, 0, 0)),
				(this.skew = new ObservablePoint(this.updateSkew, this, 0, 0)),
				(this._rotation = 0),
				(this._cx = 1),
				(this._sx = 0),
				(this._cy = 0),
				(this._sy = 1),
				(this._localID = 0),
				(this._currentLocalID = 0),
				(this._worldID = 0),
				(this._parentID = 0);
		}
		(t.prototype.onChange = function () {
			this._localID++;
		}),
			(t.prototype.updateSkew = function () {
				(this._cx = Math.cos(this._rotation + this.skew.y)),
					(this._sx = Math.sin(this._rotation + this.skew.y)),
					(this._cy = -Math.sin(this._rotation - this.skew.x)),
					(this._sy = Math.cos(this._rotation - this.skew.x)),
					this._localID++;
			}),
			(t.prototype.toString = function () {
				return (
					'[@pixi/math:Transform position=(' +
					this.position.x +
					', ' +
					this.position.y +
					') rotation=' +
					this.rotation +
					' scale=(' +
					this.scale.x +
					', ' +
					this.scale.y +
					') skew=(' +
					this.skew.x +
					', ' +
					this.skew.y +
					') ]'
				);
			}),
			(t.prototype.updateLocalTransform = function () {
				var t = this.localTransform;
				this._localID !== this._currentLocalID &&
					((t.a = this._cx * this.scale.x),
					(t.b = this._sx * this.scale.x),
					(t.c = this._cy * this.scale.y),
					(t.d = this._sy * this.scale.y),
					(t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c)),
					(t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d)),
					(this._currentLocalID = this._localID),
					(this._parentID = -1));
			}),
			(t.prototype.updateTransform = function (t) {
				var e = this.localTransform;
				if (
					(this._localID !== this._currentLocalID &&
						((e.a = this._cx * this.scale.x),
						(e.b = this._sx * this.scale.x),
						(e.c = this._cy * this.scale.y),
						(e.d = this._sy * this.scale.y),
						(e.tx =
							this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c)),
						(e.ty =
							this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d)),
						(this._currentLocalID = this._localID),
						(this._parentID = -1)),
					this._parentID !== t._worldID)
				) {
					var i = t.worldTransform,
						r = this.worldTransform;
					(r.a = e.a * i.a + e.b * i.c),
						(r.b = e.a * i.b + e.b * i.d),
						(r.c = e.c * i.a + e.d * i.c),
						(r.d = e.c * i.b + e.d * i.d),
						(r.tx = e.tx * i.a + e.ty * i.c + i.tx),
						(r.ty = e.tx * i.b + e.ty * i.d + i.ty),
						(this._parentID = t._worldID),
						this._worldID++;
				}
			}),
			(t.prototype.setFromMatrix = function (t) {
				t.decompose(this), this._localID++;
			}),
			Object.defineProperty(t.prototype, 'rotation', {
				get: function () {
					return this._rotation;
				},
				set: function (t) {
					this._rotation !== t && ((this._rotation = t), this.updateSkew());
				},
				enumerable: !1,
				configurable: !0,
			}),
			(t.IDENTITY = new t());
	})(),
		/*!
		 * @pixi/core - v6.2.2
		 * Compiled Wed, 26 Jan 2022 16:23:27 UTC
		 *
		 * @pixi/core is licensed under the MIT License.
		 * http://www.opensource.org/licenses/mit-license
		 */
		(settings.PREFER_ENV = isMobile.any ? ENV.WEBGL : ENV.WEBGL2),
		(settings.STRICT_TEXTURE_CACHE = !1);
	var INSTALLED = [];
	function autoDetectResource(t, e) {
		if (!t) return null;
		var i = '';
		if ('string' == typeof t) {
			var r = /\.(\w{3,4})(?:$|\?|#)/i.exec(t);
			r && (i = r[1].toLowerCase());
		}
		for (var s = INSTALLED.length - 1; s >= 0; --s) {
			var n = INSTALLED[s];
			if (n.test && n.test(t, i)) return new n(t, e);
		}
		throw new Error('Unrecognized source type to auto-detect Resource');
	}
	/*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */ var extendStatics$7 =
		function (t, e) {
			return (extendStatics$7 =
				Object.setPrototypeOf ||
				({ __proto__: [] } instanceof Array &&
					function (t, e) {
						t.__proto__ = e;
					}) ||
				function (t, e) {
					for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
				})(t, e);
		};
	function __extends$7(t, e) {
		function i() {
			this.constructor = t;
		}
		extendStatics$7(t, e),
			(t.prototype =
				null === e ? Object.create(e) : ((i.prototype = e.prototype), new i()));
	}
	var __assign = function () {
		return (
			(__assign =
				Object.assign ||
				function (t) {
					for (var e, i = arguments, r = 1, s = arguments.length; r < s; r++)
						for (var n in (e = i[r]))
							Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
					return t;
				}),
			__assign.apply(this, arguments)
		);
	};
	function __rest(t, e) {
		var i = {};
		for (var r in t)
			Object.prototype.hasOwnProperty.call(t, r) &&
				e.indexOf(r) < 0 &&
				(i[r] = t[r]);
		if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
			var s = 0;
			for (r = Object.getOwnPropertySymbols(t); s < r.length; s++)
				e.indexOf(r[s]) < 0 && (i[r[s]] = t[r[s]]);
		}
		return i;
	}
	var Resource = (function () {
			function t(t, e) {
				void 0 === t && (t = 0),
					void 0 === e && (e = 0),
					(this._width = t),
					(this._height = e),
					(this.destroyed = !1),
					(this.internal = !1),
					(this.onResize = new Runner('setRealSize')),
					(this.onUpdate = new Runner('update')),
					(this.onError = new Runner('onError'));
			}
			return (
				(t.prototype.bind = function (t) {
					this.onResize.add(t),
						this.onUpdate.add(t),
						this.onError.add(t),
						(this._width || this._height) &&
							this.onResize.emit(this._width, this._height);
				}),
				(t.prototype.unbind = function (t) {
					this.onResize.remove(t),
						this.onUpdate.remove(t),
						this.onError.remove(t);
				}),
				(t.prototype.resize = function (t, e) {
					(t === this._width && e === this._height) ||
						((this._width = t), (this._height = e), this.onResize.emit(t, e));
				}),
				Object.defineProperty(t.prototype, 'valid', {
					get: function () {
						return !!this._width && !!this._height;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.update = function () {
					this.destroyed || this.onUpdate.emit();
				}),
				(t.prototype.load = function () {
					return Promise.resolve(this);
				}),
				Object.defineProperty(t.prototype, 'width', {
					get: function () {
						return this._width;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'height', {
					get: function () {
						return this._height;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.style = function (t, e, i) {
					return !1;
				}),
				(t.prototype.dispose = function () {}),
				(t.prototype.destroy = function () {
					this.destroyed ||
						((this.destroyed = !0),
						this.dispose(),
						this.onError.removeAll(),
						(this.onError = null),
						this.onResize.removeAll(),
						(this.onResize = null),
						this.onUpdate.removeAll(),
						(this.onUpdate = null));
				}),
				(t.test = function (t, e) {
					return !1;
				}),
				t
			);
		})(),
		BufferResource = (function (t) {
			function e(e, i) {
				var r = this,
					s = i || {},
					n = s.width,
					a = s.height;
				if (!n || !a) throw new Error('BufferResource width or height invalid');
				return ((r = t.call(this, n, a) || this).data = e), r;
			}
			return (
				__extends$7(e, t),
				(e.prototype.upload = function (t, e, i) {
					var r = t.gl;
					r.pixelStorei(
						r.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
						e.alphaMode === ALPHA_MODES.UNPACK
					);
					var s = e.realWidth,
						n = e.realHeight;
					return (
						i.width === s && i.height === n
							? r.texSubImage2D(
									e.target,
									0,
									0,
									0,
									s,
									n,
									e.format,
									i.type,
									this.data
							  )
							: ((i.width = s),
							  (i.height = n),
							  r.texImage2D(
									e.target,
									0,
									i.internalFormat,
									s,
									n,
									0,
									e.format,
									i.type,
									this.data
							  )),
						!0
					);
				}),
				(e.prototype.dispose = function () {
					this.data = null;
				}),
				(e.test = function (t) {
					return (
						t instanceof Float32Array ||
						t instanceof Uint8Array ||
						t instanceof Uint32Array
					);
				}),
				e
			);
		})(Resource),
		defaultBufferOptions = {
			scaleMode: SCALE_MODES.NEAREST,
			format: FORMATS.RGBA,
			alphaMode: ALPHA_MODES.NPM,
		},
		BaseTexture = (function (t) {
			function e(e, i) {
				void 0 === e && (e = null), void 0 === i && (i = null);
				var r = t.call(this) || this,
					s = (i = i || {}).alphaMode,
					n = i.mipmap,
					a = i.anisotropicLevel,
					o = i.scaleMode,
					h = i.width,
					u = i.height,
					l = i.wrapMode,
					c = i.format,
					d = i.type,
					p = i.target,
					f = i.resolution,
					m = i.resourceOptions;
				return (
					!e ||
						e instanceof Resource ||
						((e = autoDetectResource(e, m)).internal = !0),
					(r.resolution = f || settings.RESOLUTION),
					(r.width = Math.round((h || 0) * r.resolution) / r.resolution),
					(r.height = Math.round((u || 0) * r.resolution) / r.resolution),
					(r._mipmap = void 0 !== n ? n : settings.MIPMAP_TEXTURES),
					(r.anisotropicLevel = void 0 !== a ? a : settings.ANISOTROPIC_LEVEL),
					(r._wrapMode = l || settings.WRAP_MODE),
					(r._scaleMode = void 0 !== o ? o : settings.SCALE_MODE),
					(r.format = c || FORMATS.RGBA),
					(r.type = d || TYPES.UNSIGNED_BYTE),
					(r.target = p || TARGETS.TEXTURE_2D),
					(r.alphaMode = void 0 !== s ? s : ALPHA_MODES.UNPACK),
					(r.uid = uid()),
					(r.touched = 0),
					(r.isPowerOfTwo = !1),
					r._refreshPOT(),
					(r._glTextures = {}),
					(r.dirtyId = 0),
					(r.dirtyStyleId = 0),
					(r.cacheId = null),
					(r.valid = h > 0 && u > 0),
					(r.textureCacheIds = []),
					(r.destroyed = !1),
					(r.resource = null),
					(r._batchEnabled = 0),
					(r._batchLocation = 0),
					(r.parentTextureArray = null),
					r.setResource(e),
					r
				);
			}
			return (
				__extends$7(e, t),
				Object.defineProperty(e.prototype, 'realWidth', {
					get: function () {
						return Math.round(this.width * this.resolution);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'realHeight', {
					get: function () {
						return Math.round(this.height * this.resolution);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'mipmap', {
					get: function () {
						return this._mipmap;
					},
					set: function (t) {
						this._mipmap !== t && ((this._mipmap = t), this.dirtyStyleId++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'scaleMode', {
					get: function () {
						return this._scaleMode;
					},
					set: function (t) {
						this._scaleMode !== t &&
							((this._scaleMode = t), this.dirtyStyleId++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'wrapMode', {
					get: function () {
						return this._wrapMode;
					},
					set: function (t) {
						this._wrapMode !== t && ((this._wrapMode = t), this.dirtyStyleId++);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.setStyle = function (t, e) {
					var i;
					return (
						void 0 !== t &&
							t !== this.scaleMode &&
							((this.scaleMode = t), (i = !0)),
						void 0 !== e && e !== this.mipmap && ((this.mipmap = e), (i = !0)),
						i && this.dirtyStyleId++,
						this
					);
				}),
				(e.prototype.setSize = function (t, e, i) {
					return (i = i || this.resolution), this.setRealSize(t * i, e * i, i);
				}),
				(e.prototype.setRealSize = function (t, e, i) {
					return (
						(this.resolution = i || this.resolution),
						(this.width = Math.round(t) / this.resolution),
						(this.height = Math.round(e) / this.resolution),
						this._refreshPOT(),
						this.update(),
						this
					);
				}),
				(e.prototype._refreshPOT = function () {
					this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);
				}),
				(e.prototype.setResolution = function (t) {
					var e = this.resolution;
					return (
						e === t ||
							((this.resolution = t),
							this.valid &&
								((this.width = Math.round(this.width * e) / t),
								(this.height = Math.round(this.height * e) / t),
								this.emit('update', this)),
							this._refreshPOT()),
						this
					);
				}),
				(e.prototype.setResource = function (t) {
					if (this.resource === t) return this;
					if (this.resource) throw new Error('Resource can be set only once');
					return t.bind(this), (this.resource = t), this;
				}),
				(e.prototype.update = function () {
					this.valid
						? (this.dirtyId++, this.dirtyStyleId++, this.emit('update', this))
						: this.width > 0 &&
						  this.height > 0 &&
						  ((this.valid = !0),
						  this.emit('loaded', this),
						  this.emit('update', this));
				}),
				(e.prototype.onError = function (t) {
					this.emit('error', this, t);
				}),
				(e.prototype.destroy = function () {
					this.resource &&
						(this.resource.unbind(this),
						this.resource.internal && this.resource.destroy(),
						(this.resource = null)),
						this.cacheId &&
							(delete BaseTextureCache[this.cacheId],
							delete TextureCache[this.cacheId],
							(this.cacheId = null)),
						this.dispose(),
						e.removeFromCache(this),
						(this.textureCacheIds = null),
						(this.destroyed = !0);
				}),
				(e.prototype.dispose = function () {
					this.emit('dispose', this);
				}),
				(e.prototype.castToBaseTexture = function () {
					return this;
				}),
				(e.from = function (t, i, r) {
					void 0 === r && (r = settings.STRICT_TEXTURE_CACHE);
					var s = 'string' == typeof t,
						n = null;
					if (s) n = t;
					else {
						if (!t._pixiId) {
							var a = (i && i.pixiIdPrefix) || 'pixiid';
							t._pixiId = a + '_' + uid();
						}
						n = t._pixiId;
					}
					var o = BaseTextureCache[n];
					if (s && r && !o)
						throw new Error(
							'The cacheId "' + n + '" does not exist in BaseTextureCache.'
						);
					return o || (((o = new e(t, i)).cacheId = n), e.addToCache(o, n)), o;
				}),
				(e.fromBuffer = function (t, i, r, s) {
					t = t || new Float32Array(i * r * 4);
					var n = new BufferResource(t, { width: i, height: r }),
						a = t instanceof Float32Array ? TYPES.FLOAT : TYPES.UNSIGNED_BYTE;
					return new e(
						n,
						Object.assign(
							defaultBufferOptions,
							s || { width: i, height: r, type: a }
						)
					);
				}),
				(e.addToCache = function (t, e) {
					e &&
						(-1 === t.textureCacheIds.indexOf(e) && t.textureCacheIds.push(e),
						BaseTextureCache[e],
						(BaseTextureCache[e] = t));
				}),
				(e.removeFromCache = function (t) {
					if ('string' == typeof t) {
						var e = BaseTextureCache[t];
						if (e) {
							var i = e.textureCacheIds.indexOf(t);
							return (
								i > -1 && e.textureCacheIds.splice(i, 1),
								delete BaseTextureCache[t],
								e
							);
						}
					} else if (t && t.textureCacheIds) {
						for (var r = 0; r < t.textureCacheIds.length; ++r)
							delete BaseTextureCache[t.textureCacheIds[r]];
						return (t.textureCacheIds.length = 0), t;
					}
					return null;
				}),
				(e._globalBatch = 0),
				e
			);
		})(eventemitter3$1),
		AbstractMultiResource = (function (t) {
			function e(e, i) {
				var r = this,
					s = i || {},
					n = s.width,
					a = s.height;
				((r = t.call(this, n, a) || this).items = []), (r.itemDirtyIds = []);
				for (var o = 0; o < e; o++) {
					var h = new BaseTexture();
					r.items.push(h), r.itemDirtyIds.push(-2);
				}
				return (r.length = e), (r._load = null), (r.baseTexture = null), r;
			}
			return (
				__extends$7(e, t),
				(e.prototype.initFromArray = function (t, e) {
					for (var i = 0; i < this.length; i++)
						t[i] &&
							(t[i].castToBaseTexture
								? this.addBaseTextureAt(t[i].castToBaseTexture(), i)
								: t[i] instanceof Resource
								? this.addResourceAt(t[i], i)
								: this.addResourceAt(autoDetectResource(t[i], e), i));
				}),
				(e.prototype.dispose = function () {
					for (var t = 0, e = this.length; t < e; t++) this.items[t].destroy();
					(this.items = null), (this.itemDirtyIds = null), (this._load = null);
				}),
				(e.prototype.addResourceAt = function (t, e) {
					if (!this.items[e])
						throw new Error('Index ' + e + ' is out of bounds');
					return (
						t.valid && !this.valid && this.resize(t.width, t.height),
						this.items[e].setResource(t),
						this
					);
				}),
				(e.prototype.bind = function (e) {
					if (null !== this.baseTexture)
						throw new Error(
							'Only one base texture per TextureArray is allowed'
						);
					t.prototype.bind.call(this, e);
					for (var i = 0; i < this.length; i++)
						(this.items[i].parentTextureArray = e),
							this.items[i].on('update', e.update, e);
				}),
				(e.prototype.unbind = function (e) {
					t.prototype.unbind.call(this, e);
					for (var i = 0; i < this.length; i++)
						(this.items[i].parentTextureArray = null),
							this.items[i].off('update', e.update, e);
				}),
				(e.prototype.load = function () {
					var t = this;
					if (this._load) return this._load;
					var e = this.items
						.map(function (t) {
							return t.resource;
						})
						.filter(function (t) {
							return t;
						})
						.map(function (t) {
							return t.load();
						});
					return (
						(this._load = Promise.all(e).then(function () {
							var e = t.items[0],
								i = e.realWidth,
								r = e.realHeight;
							return t.resize(i, r), Promise.resolve(t);
						})),
						this._load
					);
				}),
				e
			);
		})(Resource),
		ArrayResource = (function (t) {
			function e(e, i) {
				var r,
					s,
					n = this,
					a = i || {},
					o = a.width,
					h = a.height;
				return (
					Array.isArray(e) ? ((r = e), (s = e.length)) : (s = e),
					(n = t.call(this, s, { width: o, height: h }) || this),
					r && n.initFromArray(r, i),
					n
				);
			}
			return (
				__extends$7(e, t),
				(e.prototype.addBaseTextureAt = function (t, e) {
					if (!t.resource)
						throw new Error('ArrayResource does not support RenderTexture');
					return this.addResourceAt(t.resource, e), this;
				}),
				(e.prototype.bind = function (e) {
					t.prototype.bind.call(this, e), (e.target = TARGETS.TEXTURE_2D_ARRAY);
				}),
				(e.prototype.upload = function (t, e, i) {
					var r = this,
						s = r.length,
						n = r.itemDirtyIds,
						a = r.items,
						o = t.gl;
					i.dirtyId < 0 &&
						o.texImage3D(
							o.TEXTURE_2D_ARRAY,
							0,
							i.internalFormat,
							this._width,
							this._height,
							s,
							0,
							e.format,
							i.type,
							null
						);
					for (var h = 0; h < s; h++) {
						var u = a[h];
						n[h] < u.dirtyId &&
							((n[h] = u.dirtyId),
							u.valid &&
								o.texSubImage3D(
									o.TEXTURE_2D_ARRAY,
									0,
									0,
									0,
									h,
									u.resource.width,
									u.resource.height,
									1,
									e.format,
									i.type,
									u.resource.source
								));
					}
					return !0;
				}),
				e
			);
		})(AbstractMultiResource),
		BaseImageResource = (function (t) {
			function e(e) {
				var i = this,
					r = e,
					s = r.naturalWidth || r.videoWidth || r.width,
					n = r.naturalHeight || r.videoHeight || r.height;
				return (
					((i = t.call(this, s, n) || this).source = e), (i.noSubImage = !1), i
				);
			}
			return (
				__extends$7(e, t),
				(e.crossOrigin = function (t, e, i) {
					void 0 === i && 0 !== e.indexOf('data:')
						? (t.crossOrigin = determineCrossOrigin(e))
						: !1 !== i &&
						  (t.crossOrigin = 'string' == typeof i ? i : 'anonymous');
				}),
				(e.prototype.upload = function (t, e, i, r) {
					var s = t.gl,
						n = e.realWidth,
						a = e.realHeight;
					return (
						(r = r || this.source),
						s.pixelStorei(
							s.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
							e.alphaMode === ALPHA_MODES.UNPACK
						),
						this.noSubImage ||
						e.target !== s.TEXTURE_2D ||
						i.width !== n ||
						i.height !== a
							? ((i.width = n),
							  (i.height = a),
							  s.texImage2D(
									e.target,
									0,
									i.internalFormat,
									e.format,
									i.type,
									r
							  ))
							: s.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, e.format, i.type, r),
						!0
					);
				}),
				(e.prototype.update = function () {
					if (!this.destroyed) {
						var e = this.source,
							i = e.naturalWidth || e.videoWidth || e.width,
							r = e.naturalHeight || e.videoHeight || e.height;
						this.resize(i, r), t.prototype.update.call(this);
					}
				}),
				(e.prototype.dispose = function () {
					this.source = null;
				}),
				e
			);
		})(Resource),
		CanvasResource = (function (t) {
			function e(e) {
				return t.call(this, e) || this;
			}
			return (
				__extends$7(e, t),
				(e.test = function (t) {
					var e = self.OffscreenCanvas;
					return (
						!!(e && t instanceof e) ||
						(self.HTMLCanvasElement && t instanceof HTMLCanvasElement)
					);
				}),
				e
			);
		})(BaseImageResource),
		CubeResource = (function (t) {
			function e(i, r) {
				var s = this,
					n = r || {},
					a = n.width,
					o = n.height,
					h = n.autoLoad,
					u = n.linkBaseTexture;
				if (i && i.length !== e.SIDES)
					throw new Error('Invalid length. Got ' + i.length + ', expected 6');
				s = t.call(this, 6, { width: a, height: o }) || this;
				for (var l = 0; l < e.SIDES; l++)
					s.items[l].target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + l;
				return (
					(s.linkBaseTexture = !1 !== u),
					i && s.initFromArray(i, r),
					!1 !== h && s.load(),
					s
				);
			}
			return (
				__extends$7(e, t),
				(e.prototype.bind = function (e) {
					t.prototype.bind.call(this, e), (e.target = TARGETS.TEXTURE_CUBE_MAP);
				}),
				(e.prototype.addBaseTextureAt = function (t, e, i) {
					if ((void 0 === i && (i = this.linkBaseTexture), !this.items[e]))
						throw new Error('Index ' + e + ' is out of bounds');
					if (
						!this.linkBaseTexture ||
						t.parentTextureArray ||
						Object.keys(t._glTextures).length > 0
					) {
						if (!t.resource)
							throw new Error(
								'CubeResource does not support copying of renderTexture.'
							);
						this.addResourceAt(t.resource, e);
					} else
						(t.target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + e),
							(t.parentTextureArray = this.baseTexture),
							(this.items[e] = t);
					return (
						t.valid && !this.valid && this.resize(t.realWidth, t.realHeight),
						(this.items[e] = t),
						this
					);
				}),
				(e.prototype.upload = function (t, i, r) {
					for (var s = this.itemDirtyIds, n = 0; n < e.SIDES; n++) {
						var a = this.items[n];
						s[n] < a.dirtyId &&
							(a.valid && a.resource
								? (a.resource.upload(t, a, r), (s[n] = a.dirtyId))
								: s[n] < -1 &&
								  (t.gl.texImage2D(
										a.target,
										0,
										r.internalFormat,
										i.realWidth,
										i.realHeight,
										0,
										i.format,
										r.type,
										null
								  ),
								  (s[n] = -1)));
					}
					return !0;
				}),
				(e.test = function (t) {
					return Array.isArray(t) && t.length === e.SIDES;
				}),
				(e.SIDES = 6),
				e
			);
		})(AbstractMultiResource),
		ImageResource = (function (t) {
			function e(e, i) {
				var r = this;
				if (((i = i || {}), !(e instanceof HTMLImageElement))) {
					var s = new Image();
					BaseImageResource.crossOrigin(s, e, i.crossorigin),
						(s.src = e),
						(e = s);
				}
				return (
					(r = t.call(this, e) || this),
					!e.complete &&
						r._width &&
						r._height &&
						((r._width = 0), (r._height = 0)),
					(r.url = e.src),
					(r._process = null),
					(r.preserveBitmap = !1),
					(r.createBitmap =
						(void 0 !== i.createBitmap
							? i.createBitmap
							: settings.CREATE_IMAGE_BITMAP) && !!self.createImageBitmap),
					(r.alphaMode = 'number' == typeof i.alphaMode ? i.alphaMode : null),
					(r.bitmap = null),
					(r._load = null),
					!1 !== i.autoLoad && r.load(),
					r
				);
			}
			return (
				__extends$7(e, t),
				(e.prototype.load = function (t) {
					var e = this;
					return (
						this._load ||
							(void 0 !== t && (this.createBitmap = t),
							(this._load = new Promise(function (t, i) {
								var r = e.source;
								e.url = r.src;
								var s = function () {
									e.destroyed ||
										((r.onload = null),
										(r.onerror = null),
										e.resize(r.width, r.height),
										(e._load = null),
										e.createBitmap ? t(e.process()) : t(e));
								};
								r.complete && r.src
									? s()
									: ((r.onload = s),
									  (r.onerror = function (t) {
											i(t), e.onError.emit(t);
									  }));
							}))),
						this._load
					);
				}),
				(e.prototype.process = function () {
					var t = this,
						e = this.source;
					if (null !== this._process) return this._process;
					if (null !== this.bitmap || !self.createImageBitmap)
						return Promise.resolve(this);
					var i = self.createImageBitmap,
						r = !e.crossOrigin || 'anonymous' === e.crossOrigin;
					return (
						(this._process = fetch(e.src, { mode: r ? 'cors' : 'no-cors' })
							.then(function (t) {
								return t.blob();
							})
							.then(function (r) {
								return i(r, 0, 0, e.width, e.height, {
									premultiplyAlpha:
										t.alphaMode === ALPHA_MODES.UNPACK ? 'premultiply' : 'none',
								});
							})
							.then(function (e) {
								return t.destroyed
									? Promise.reject()
									: ((t.bitmap = e),
									  t.update(),
									  (t._process = null),
									  Promise.resolve(t));
							})),
						this._process
					);
				}),
				(e.prototype.upload = function (e, i, r) {
					if (
						('number' == typeof this.alphaMode &&
							(i.alphaMode = this.alphaMode),
						!this.createBitmap)
					)
						return t.prototype.upload.call(this, e, i, r);
					if (!this.bitmap && (this.process(), !this.bitmap)) return !1;
					if (
						(t.prototype.upload.call(this, e, i, r, this.bitmap),
						!this.preserveBitmap)
					) {
						var s = !0,
							n = i._glTextures;
						for (var a in n) {
							var o = n[a];
							if (o !== r && o.dirtyId !== i.dirtyId) {
								s = !1;
								break;
							}
						}
						s &&
							(this.bitmap.close && this.bitmap.close(), (this.bitmap = null));
					}
					return !0;
				}),
				(e.prototype.dispose = function () {
					(this.source.onload = null),
						(this.source.onerror = null),
						t.prototype.dispose.call(this),
						this.bitmap && (this.bitmap.close(), (this.bitmap = null)),
						(this._process = null),
						(this._load = null);
				}),
				(e.test = function (t) {
					return 'string' == typeof t || t instanceof HTMLImageElement;
				}),
				e
			);
		})(BaseImageResource),
		SVGResource = (function (t) {
			function e(e, i) {
				var r = this;
				return (
					(i = i || {}),
					((r =
						t.call(this, document.createElement('canvas')) || this)._width = 0),
					(r._height = 0),
					(r.svg = e),
					(r.scale = i.scale || 1),
					(r._overrideWidth = i.width),
					(r._overrideHeight = i.height),
					(r._resolve = null),
					(r._crossorigin = i.crossorigin),
					(r._load = null),
					!1 !== i.autoLoad && r.load(),
					r
				);
			}
			return (
				__extends$7(e, t),
				(e.prototype.load = function () {
					var t = this;
					return (
						this._load ||
							(this._load = new Promise(function (i) {
								if (
									((t._resolve = function () {
										t.resize(t.source.width, t.source.height), i(t);
									}),
									e.SVG_XML.test(t.svg.trim()))
								) {
									if (!btoa)
										throw new Error(
											"Your browser doesn't support base64 conversions."
										);
									t.svg =
										'data:image/svg+xml;base64,' +
										btoa(unescape(encodeURIComponent(t.svg)));
								}
								t._loadSvg();
							})),
						this._load
					);
				}),
				(e.prototype._loadSvg = function () {
					var t = this,
						e = new Image();
					BaseImageResource.crossOrigin(e, this.svg, this._crossorigin),
						(e.src = this.svg),
						(e.onerror = function (i) {
							t._resolve && ((e.onerror = null), t.onError.emit(i));
						}),
						(e.onload = function () {
							if (t._resolve) {
								var i = e.width,
									r = e.height;
								if (!i || !r)
									throw new Error(
										'The SVG image must have width and height defined (in pixels), canvas API needs them.'
									);
								var s = i * t.scale,
									n = r * t.scale;
								(t._overrideWidth || t._overrideHeight) &&
									((s = t._overrideWidth || (t._overrideHeight / r) * i),
									(n = t._overrideHeight || (t._overrideWidth / i) * r)),
									(s = Math.round(s)),
									(n = Math.round(n));
								var a = t.source;
								(a.width = s),
									(a.height = n),
									(a._pixiId = 'canvas_' + uid()),
									a.getContext('2d').drawImage(e, 0, 0, i, r, 0, 0, s, n),
									t._resolve(),
									(t._resolve = null);
							}
						});
				}),
				(e.getSize = function (t) {
					var i = e.SVG_SIZE.exec(t),
						r = {};
					return (
						i &&
							((r[i[1]] = Math.round(parseFloat(i[3]))),
							(r[i[5]] = Math.round(parseFloat(i[7])))),
						r
					);
				}),
				(e.prototype.dispose = function () {
					t.prototype.dispose.call(this),
						(this._resolve = null),
						(this._crossorigin = null);
				}),
				(e.test = function (t, i) {
					return (
						'svg' === i ||
						('string' == typeof t &&
							/^data:image\/svg\+xml(;(charset=utf8|utf8))?;base64/.test(t)) ||
						('string' == typeof t && e.SVG_XML.test(t))
					);
				}),
				(e.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m),
				(e.SVG_SIZE =
					/<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i),
				e
			);
		})(BaseImageResource),
		VideoResource = (function (t) {
			function e(i, r) {
				var s = this;
				if (((r = r || {}), !(i instanceof HTMLVideoElement))) {
					var n = document.createElement('video');
					n.setAttribute('preload', 'auto'),
						n.setAttribute('webkit-playsinline', ''),
						n.setAttribute('playsinline', ''),
						'string' == typeof i && (i = [i]);
					var a = i[0].src || i[0];
					BaseImageResource.crossOrigin(n, a, r.crossorigin);
					for (var o = 0; o < i.length; ++o) {
						var h = document.createElement('source'),
							u = i[o],
							l = u.src,
							c = u.mime,
							d = (l = l || i[o]).split('?').shift().toLowerCase(),
							p = d.substr(d.lastIndexOf('.') + 1);
						(c = c || e.MIME_TYPES[p] || 'video/' + p),
							(h.src = l),
							(h.type = c),
							n.appendChild(h);
					}
					i = n;
				}
				return (
					((s = t.call(this, i) || this).noSubImage = !0),
					(s._autoUpdate = !0),
					(s._isConnectedToTicker = !1),
					(s._updateFPS = r.updateFPS || 0),
					(s._msToNextUpdate = 0),
					(s.autoPlay = !1 !== r.autoPlay),
					(s._load = null),
					(s._resolve = null),
					(s._onCanPlay = s._onCanPlay.bind(s)),
					(s._onError = s._onError.bind(s)),
					!1 !== r.autoLoad && s.load(),
					s
				);
			}
			return (
				__extends$7(e, t),
				(e.prototype.update = function (e) {
					if (!this.destroyed) {
						var i = Ticker.shared.elapsedMS * this.source.playbackRate;
						(this._msToNextUpdate = Math.floor(this._msToNextUpdate - i)),
							(!this._updateFPS || this._msToNextUpdate <= 0) &&
								(t.prototype.update.call(this),
								(this._msToNextUpdate = this._updateFPS
									? Math.floor(1e3 / this._updateFPS)
									: 0));
					}
				}),
				(e.prototype.load = function () {
					var t = this;
					if (this._load) return this._load;
					var e = this.source;
					return (
						(e.readyState === e.HAVE_ENOUGH_DATA ||
							e.readyState === e.HAVE_FUTURE_DATA) &&
							e.width &&
							e.height &&
							(e.complete = !0),
						e.addEventListener('play', this._onPlayStart.bind(this)),
						e.addEventListener('pause', this._onPlayStop.bind(this)),
						this._isSourceReady()
							? this._onCanPlay()
							: (e.addEventListener('canplay', this._onCanPlay),
							  e.addEventListener('canplaythrough', this._onCanPlay),
							  e.addEventListener('error', this._onError, !0)),
						(this._load = new Promise(function (i) {
							t.valid ? i(t) : ((t._resolve = i), e.load());
						})),
						this._load
					);
				}),
				(e.prototype._onError = function (t) {
					this.source.removeEventListener('error', this._onError, !0),
						this.onError.emit(t);
				}),
				(e.prototype._isSourcePlaying = function () {
					var t = this.source;
					return (
						t.currentTime > 0 &&
						!1 === t.paused &&
						!1 === t.ended &&
						t.readyState > 2
					);
				}),
				(e.prototype._isSourceReady = function () {
					var t = this.source;
					return 3 === t.readyState || 4 === t.readyState;
				}),
				(e.prototype._onPlayStart = function () {
					this.valid || this._onCanPlay(),
						this.autoUpdate &&
							!this._isConnectedToTicker &&
							(Ticker.shared.add(this.update, this),
							(this._isConnectedToTicker = !0));
				}),
				(e.prototype._onPlayStop = function () {
					this._isConnectedToTicker &&
						(Ticker.shared.remove(this.update, this),
						(this._isConnectedToTicker = !1));
				}),
				(e.prototype._onCanPlay = function () {
					var t = this.source;
					t.removeEventListener('canplay', this._onCanPlay),
						t.removeEventListener('canplaythrough', this._onCanPlay);
					var e = this.valid;
					this.resize(t.videoWidth, t.videoHeight),
						!e &&
							this._resolve &&
							(this._resolve(this), (this._resolve = null)),
						this._isSourcePlaying()
							? this._onPlayStart()
							: this.autoPlay && t.play();
				}),
				(e.prototype.dispose = function () {
					this._isConnectedToTicker &&
						(Ticker.shared.remove(this.update, this),
						(this._isConnectedToTicker = !1));
					var e = this.source;
					e &&
						(e.removeEventListener('error', this._onError, !0),
						e.pause(),
						(e.src = ''),
						e.load()),
						t.prototype.dispose.call(this);
				}),
				Object.defineProperty(e.prototype, 'autoUpdate', {
					get: function () {
						return this._autoUpdate;
					},
					set: function (t) {
						t !== this._autoUpdate &&
							((this._autoUpdate = t),
							!this._autoUpdate && this._isConnectedToTicker
								? (Ticker.shared.remove(this.update, this),
								  (this._isConnectedToTicker = !1))
								: this._autoUpdate &&
								  !this._isConnectedToTicker &&
								  this._isSourcePlaying() &&
								  (Ticker.shared.add(this.update, this),
								  (this._isConnectedToTicker = !0)));
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'updateFPS', {
					get: function () {
						return this._updateFPS;
					},
					set: function (t) {
						t !== this._updateFPS && (this._updateFPS = t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.test = function (t, i) {
					return (
						(self.HTMLVideoElement && t instanceof HTMLVideoElement) ||
						e.TYPES.indexOf(i) > -1
					);
				}),
				(e.TYPES = ['mp4', 'm4v', 'webm', 'ogg', 'ogv', 'h264', 'avi', 'mov']),
				(e.MIME_TYPES = {
					ogv: 'video/ogg',
					mov: 'video/quicktime',
					m4v: 'video/mp4',
				}),
				e
			);
		})(BaseImageResource),
		ImageBitmapResource = (function (t) {
			function e(e) {
				return t.call(this, e) || this;
			}
			return (
				__extends$7(e, t),
				(e.test = function (t) {
					return !!self.createImageBitmap && t instanceof ImageBitmap;
				}),
				e
			);
		})(BaseImageResource);
	INSTALLED.push(
		ImageResource,
		ImageBitmapResource,
		CanvasResource,
		VideoResource,
		SVGResource,
		BufferResource,
		CubeResource,
		ArrayResource
	);
	var DepthResource = (function (t) {
			function e() {
				return (null !== t && t.apply(this, arguments)) || this;
			}
			return (
				__extends$7(e, t),
				(e.prototype.upload = function (t, e, i) {
					var r = t.gl;
					r.pixelStorei(
						r.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
						e.alphaMode === ALPHA_MODES.UNPACK
					);
					var s = e.realWidth,
						n = e.realHeight;
					return (
						i.width === s && i.height === n
							? r.texSubImage2D(
									e.target,
									0,
									0,
									0,
									s,
									n,
									e.format,
									i.type,
									this.data
							  )
							: ((i.width = s),
							  (i.height = n),
							  r.texImage2D(
									e.target,
									0,
									i.internalFormat,
									s,
									n,
									0,
									e.format,
									i.type,
									this.data
							  )),
						!0
					);
				}),
				e
			);
		})(BufferResource),
		Framebuffer = (function () {
			function t(t, e) {
				(this.width = Math.round(t || 100)),
					(this.height = Math.round(e || 100)),
					(this.stencil = !1),
					(this.depth = !1),
					(this.dirtyId = 0),
					(this.dirtyFormat = 0),
					(this.dirtySize = 0),
					(this.depthTexture = null),
					(this.colorTextures = []),
					(this.glFramebuffers = {}),
					(this.disposeRunner = new Runner('disposeFramebuffer')),
					(this.multisample = MSAA_QUALITY.NONE);
			}
			return (
				Object.defineProperty(t.prototype, 'colorTexture', {
					get: function () {
						return this.colorTextures[0];
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.addColorTexture = function (t, e) {
					return (
						void 0 === t && (t = 0),
						(this.colorTextures[t] =
							e ||
							new BaseTexture(null, {
								scaleMode: SCALE_MODES.NEAREST,
								resolution: 1,
								mipmap: MIPMAP_MODES.OFF,
								width: this.width,
								height: this.height,
							})),
						this.dirtyId++,
						this.dirtyFormat++,
						this
					);
				}),
				(t.prototype.addDepthTexture = function (t) {
					return (
						(this.depthTexture =
							t ||
							new BaseTexture(
								new DepthResource(null, {
									width: this.width,
									height: this.height,
								}),
								{
									scaleMode: SCALE_MODES.NEAREST,
									resolution: 1,
									width: this.width,
									height: this.height,
									mipmap: MIPMAP_MODES.OFF,
									format: FORMATS.DEPTH_COMPONENT,
									type: TYPES.UNSIGNED_SHORT,
								}
							)),
						this.dirtyId++,
						this.dirtyFormat++,
						this
					);
				}),
				(t.prototype.enableDepth = function () {
					return (this.depth = !0), this.dirtyId++, this.dirtyFormat++, this;
				}),
				(t.prototype.enableStencil = function () {
					return (this.stencil = !0), this.dirtyId++, this.dirtyFormat++, this;
				}),
				(t.prototype.resize = function (t, e) {
					if (
						((t = Math.round(t)),
						(e = Math.round(e)),
						t !== this.width || e !== this.height)
					) {
						(this.width = t),
							(this.height = e),
							this.dirtyId++,
							this.dirtySize++;
						for (var i = 0; i < this.colorTextures.length; i++) {
							var r = this.colorTextures[i],
								s = r.resolution;
							r.setSize(t / s, e / s);
						}
						this.depthTexture &&
							((s = this.depthTexture.resolution),
							this.depthTexture.setSize(t / s, e / s));
					}
				}),
				(t.prototype.dispose = function () {
					this.disposeRunner.emit(this, !1);
				}),
				(t.prototype.destroyDepthTexture = function () {
					this.depthTexture &&
						(this.depthTexture.destroy(),
						(this.depthTexture = null),
						++this.dirtyId,
						++this.dirtyFormat);
				}),
				t
			);
		})(),
		BaseRenderTexture = (function (t) {
			function e(e) {
				var i = this;
				if ('number' == typeof e) {
					var r = arguments[0],
						s = arguments[1],
						n = arguments[2],
						a = arguments[3];
					e = { width: r, height: s, scaleMode: n, resolution: a };
				}
				return (
					(e.width = e.width || 100),
					(e.height = e.height || 100),
					(e.multisample =
						void 0 !== e.multisample ? e.multisample : MSAA_QUALITY.NONE),
					((i = t.call(this, null, e) || this).mipmap = MIPMAP_MODES.OFF),
					(i.valid = !0),
					(i.clearColor = [0, 0, 0, 0]),
					(i.framebuffer = new Framebuffer(
						i.realWidth,
						i.realHeight
					).addColorTexture(0, i)),
					(i.framebuffer.multisample = e.multisample),
					(i.maskStack = []),
					(i.filterStack = [{}]),
					i
				);
			}
			return (
				__extends$7(e, t),
				(e.prototype.resize = function (t, e) {
					this.framebuffer.resize(t * this.resolution, e * this.resolution),
						this.setRealSize(this.framebuffer.width, this.framebuffer.height);
				}),
				(e.prototype.dispose = function () {
					this.framebuffer.dispose(), t.prototype.dispose.call(this);
				}),
				(e.prototype.destroy = function () {
					t.prototype.destroy.call(this),
						this.framebuffer.destroyDepthTexture(),
						(this.framebuffer = null);
				}),
				e
			);
		})(BaseTexture),
		TextureUvs = (function () {
			function t() {
				(this.x0 = 0),
					(this.y0 = 0),
					(this.x1 = 1),
					(this.y1 = 0),
					(this.x2 = 1),
					(this.y2 = 1),
					(this.x3 = 0),
					(this.y3 = 1),
					(this.uvsFloat32 = new Float32Array(8));
			}
			return (
				(t.prototype.set = function (t, e, i) {
					var r = e.width,
						s = e.height;
					if (i) {
						var n = t.width / 2 / r,
							a = t.height / 2 / s,
							o = t.x / r + n,
							h = t.y / s + a;
						(i = groupD8.add(i, groupD8.NW)),
							(this.x0 = o + n * groupD8.uX(i)),
							(this.y0 = h + a * groupD8.uY(i)),
							(i = groupD8.add(i, 2)),
							(this.x1 = o + n * groupD8.uX(i)),
							(this.y1 = h + a * groupD8.uY(i)),
							(i = groupD8.add(i, 2)),
							(this.x2 = o + n * groupD8.uX(i)),
							(this.y2 = h + a * groupD8.uY(i)),
							(i = groupD8.add(i, 2)),
							(this.x3 = o + n * groupD8.uX(i)),
							(this.y3 = h + a * groupD8.uY(i));
					} else
						(this.x0 = t.x / r),
							(this.y0 = t.y / s),
							(this.x1 = (t.x + t.width) / r),
							(this.y1 = t.y / s),
							(this.x2 = (t.x + t.width) / r),
							(this.y2 = (t.y + t.height) / s),
							(this.x3 = t.x / r),
							(this.y3 = (t.y + t.height) / s);
					(this.uvsFloat32[0] = this.x0),
						(this.uvsFloat32[1] = this.y0),
						(this.uvsFloat32[2] = this.x1),
						(this.uvsFloat32[3] = this.y1),
						(this.uvsFloat32[4] = this.x2),
						(this.uvsFloat32[5] = this.y2),
						(this.uvsFloat32[6] = this.x3),
						(this.uvsFloat32[7] = this.y3);
				}),
				(t.prototype.toString = function () {
					return (
						'[@pixi/core:TextureUvs x0=' +
						this.x0 +
						' y0=' +
						this.y0 +
						' x1=' +
						this.x1 +
						' y1=' +
						this.y1 +
						' x2=' +
						this.x2 +
						' y2=' +
						this.y2 +
						' x3=' +
						this.x3 +
						' y3=' +
						this.y3 +
						']'
					);
				}),
				t
			);
		})(),
		DEFAULT_UVS = new TextureUvs(),
		Texture = (function (t) {
			function e(i, r, s, n, a, o) {
				var h = t.call(this) || this;
				if (
					((h.noFrame = !1),
					r || ((h.noFrame = !0), (r = new Rectangle$1(0, 0, 1, 1))),
					i instanceof e && (i = i.baseTexture),
					(h.baseTexture = i),
					(h._frame = r),
					(h.trim = n),
					(h.valid = !1),
					(h._uvs = DEFAULT_UVS),
					(h.uvMatrix = null),
					(h.orig = s || r),
					(h._rotate = Number(a || 0)),
					!0 === a)
				)
					h._rotate = 2;
				else if (h._rotate % 2 != 0)
					throw new Error(
						'attempt to use diamond-shaped UVs. If you are sure, set rotation manually'
					);
				return (
					(h.defaultAnchor = o ? new Point$1(o.x, o.y) : new Point$1(0, 0)),
					(h._updateID = 0),
					(h.textureCacheIds = []),
					i.valid
						? h.noFrame
							? i.valid && h.onBaseTextureUpdated(i)
							: (h.frame = r)
						: i.once('loaded', h.onBaseTextureUpdated, h),
					h.noFrame && i.on('update', h.onBaseTextureUpdated, h),
					h
				);
			}
			return (
				__extends$7(e, t),
				(e.prototype.update = function () {
					this.baseTexture.resource && this.baseTexture.resource.update();
				}),
				(e.prototype.onBaseTextureUpdated = function (t) {
					if (this.noFrame) {
						if (!this.baseTexture.valid) return;
						(this._frame.width = t.width),
							(this._frame.height = t.height),
							(this.valid = !0),
							this.updateUvs();
					} else this.frame = this._frame;
					this.emit('update', this);
				}),
				(e.prototype.destroy = function (t) {
					if (this.baseTexture) {
						if (t) {
							var i = this.baseTexture.resource;
							i && i.url && TextureCache[i.url] && e.removeFromCache(i.url),
								this.baseTexture.destroy();
						}
						this.baseTexture.off('loaded', this.onBaseTextureUpdated, this),
							this.baseTexture.off('update', this.onBaseTextureUpdated, this),
							(this.baseTexture = null);
					}
					(this._frame = null),
						(this._uvs = null),
						(this.trim = null),
						(this.orig = null),
						(this.valid = !1),
						e.removeFromCache(this),
						(this.textureCacheIds = null);
				}),
				(e.prototype.clone = function () {
					var t = this._frame.clone(),
						i = this._frame === this.orig ? t : this.orig.clone(),
						r = new e(
							this.baseTexture,
							!this.noFrame && t,
							i,
							this.trim && this.trim.clone(),
							this.rotate,
							this.defaultAnchor
						);
					return this.noFrame && (r._frame = t), r;
				}),
				(e.prototype.updateUvs = function () {
					this._uvs === DEFAULT_UVS && (this._uvs = new TextureUvs()),
						this._uvs.set(this._frame, this.baseTexture, this.rotate),
						this._updateID++;
				}),
				(e.from = function (t, i, r) {
					void 0 === i && (i = {}),
						void 0 === r && (r = settings.STRICT_TEXTURE_CACHE);
					var s = 'string' == typeof t,
						n = null;
					if (s) n = t;
					else if (t instanceof BaseTexture) {
						if (!t.cacheId) {
							var a = (i && i.pixiIdPrefix) || 'pixiid';
							(t.cacheId = a + '-' + uid()),
								BaseTexture.addToCache(t, t.cacheId);
						}
						n = t.cacheId;
					} else
						t._pixiId ||
							((a = (i && i.pixiIdPrefix) || 'pixiid'),
							(t._pixiId = a + '_' + uid())),
							(n = t._pixiId);
					var o = TextureCache[n];
					if (s && r && !o)
						throw new Error(
							'The cacheId "' + n + '" does not exist in TextureCache.'
						);
					return (
						o || t instanceof BaseTexture
							? !o &&
							  t instanceof BaseTexture &&
							  ((o = new e(t)), e.addToCache(o, n))
							: (i.resolution || (i.resolution = getResolutionOfUrl(t)),
							  ((o = new e(new BaseTexture(t, i))).baseTexture.cacheId = n),
							  BaseTexture.addToCache(o.baseTexture, n),
							  e.addToCache(o, n)),
						o
					);
				}),
				(e.fromURL = function (t, i) {
					var r = Object.assign(
							{ autoLoad: !1 },
							null == i ? void 0 : i.resourceOptions
						),
						s = e.from(t, Object.assign({ resourceOptions: r }, i), !1),
						n = s.baseTexture.resource;
					return s.baseTexture.valid
						? Promise.resolve(s)
						: n.load().then(function () {
								return Promise.resolve(s);
						  });
				}),
				(e.fromBuffer = function (t, i, r, s) {
					return new e(BaseTexture.fromBuffer(t, i, r, s));
				}),
				(e.fromLoader = function (t, i, r, s) {
					var n = new BaseTexture(
							t,
							Object.assign(
								{
									scaleMode: settings.SCALE_MODE,
									resolution: getResolutionOfUrl(i),
								},
								s
							)
						),
						a = n.resource;
					a instanceof ImageResource && (a.url = i);
					var o = new e(n);
					return (
						r || (r = i),
						BaseTexture.addToCache(o.baseTexture, r),
						e.addToCache(o, r),
						r !== i &&
							(BaseTexture.addToCache(o.baseTexture, i), e.addToCache(o, i)),
						o.baseTexture.valid
							? Promise.resolve(o)
							: new Promise(function (t) {
									o.baseTexture.once('loaded', function () {
										return t(o);
									});
							  })
					);
				}),
				(e.addToCache = function (t, e) {
					e &&
						(-1 === t.textureCacheIds.indexOf(e) && t.textureCacheIds.push(e),
						TextureCache[e],
						(TextureCache[e] = t));
				}),
				(e.removeFromCache = function (t) {
					if ('string' == typeof t) {
						var e = TextureCache[t];
						if (e) {
							var i = e.textureCacheIds.indexOf(t);
							return (
								i > -1 && e.textureCacheIds.splice(i, 1),
								delete TextureCache[t],
								e
							);
						}
					} else if (t && t.textureCacheIds) {
						for (var r = 0; r < t.textureCacheIds.length; ++r)
							TextureCache[t.textureCacheIds[r]] === t &&
								delete TextureCache[t.textureCacheIds[r]];
						return (t.textureCacheIds.length = 0), t;
					}
					return null;
				}),
				Object.defineProperty(e.prototype, 'resolution', {
					get: function () {
						return this.baseTexture.resolution;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'frame', {
					get: function () {
						return this._frame;
					},
					set: function (t) {
						(this._frame = t), (this.noFrame = !1);
						var e = t.x,
							i = t.y,
							r = t.width,
							s = t.height,
							n = e + r > this.baseTexture.width,
							a = i + s > this.baseTexture.height;
						if (n || a) {
							var o = n && a ? 'and' : 'or',
								h =
									'X: ' +
									e +
									' + ' +
									r +
									' = ' +
									(e + r) +
									' > ' +
									this.baseTexture.width,
								u =
									'Y: ' +
									i +
									' + ' +
									s +
									' = ' +
									(i + s) +
									' > ' +
									this.baseTexture.height;
							throw new Error(
								'Texture Error: frame does not fit inside the base Texture dimensions: ' +
									h +
									' ' +
									o +
									' ' +
									u
							);
						}
						(this.valid = r && s && this.baseTexture.valid),
							this.trim || this.rotate || (this.orig = t),
							this.valid && this.updateUvs();
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'rotate', {
					get: function () {
						return this._rotate;
					},
					set: function (t) {
						(this._rotate = t), this.valid && this.updateUvs();
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'width', {
					get: function () {
						return this.orig.width;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'height', {
					get: function () {
						return this.orig.height;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.castToBaseTexture = function () {
					return this.baseTexture;
				}),
				e
			);
		})(eventemitter3$1);
	function createWhiteTexture() {
		var t = document.createElement('canvas');
		(t.width = 16), (t.height = 16);
		var e = t.getContext('2d');
		return (
			(e.fillStyle = 'white'),
			e.fillRect(0, 0, 16, 16),
			new Texture(new BaseTexture(new CanvasResource(t)))
		);
	}
	function removeAllHandlers(t) {
		(t.destroy = function () {}),
			(t.on = function () {}),
			(t.once = function () {}),
			(t.emit = function () {});
	}
	(Texture.EMPTY = new Texture(new BaseTexture())),
		removeAllHandlers(Texture.EMPTY),
		removeAllHandlers(Texture.EMPTY.baseTexture),
		(Texture.WHITE = createWhiteTexture()),
		removeAllHandlers(Texture.WHITE),
		removeAllHandlers(Texture.WHITE.baseTexture);
	var RenderTexture = (function (t) {
			function e(e, i) {
				var r = t.call(this, e, i) || this;
				return (
					(r.valid = !0),
					(r.filterFrame = null),
					(r.filterPoolKey = null),
					r.updateUvs(),
					r
				);
			}
			return (
				__extends$7(e, t),
				Object.defineProperty(e.prototype, 'framebuffer', {
					get: function () {
						return this.baseTexture.framebuffer;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'multisample', {
					get: function () {
						return this.framebuffer.multisample;
					},
					set: function (t) {
						this.framebuffer.multisample = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.resize = function (t, e, i) {
					void 0 === i && (i = !0);
					var r = this.baseTexture.resolution,
						s = Math.round(t * r) / r,
						n = Math.round(e * r) / r;
					(this.valid = s > 0 && n > 0),
						(this._frame.width = this.orig.width = s),
						(this._frame.height = this.orig.height = n),
						i && this.baseTexture.resize(s, n),
						this.updateUvs();
				}),
				(e.prototype.setResolution = function (t) {
					var e = this.baseTexture;
					e.resolution !== t &&
						(e.setResolution(t), this.resize(e.width, e.height, !1));
				}),
				(e.create = function (t) {
					for (var i = arguments, r = [], s = 1; s < arguments.length; s++)
						r[s - 1] = i[s];
					return (
						'number' == typeof t &&
							(deprecation(
								'6.0.0',
								'Arguments (width, height, scaleMode, resolution) have been deprecated.'
							),
							(t = {
								width: t,
								height: r[0],
								scaleMode: r[1],
								resolution: r[2],
							})),
						new e(new BaseRenderTexture(t))
					);
				}),
				e
			);
		})(Texture),
		RenderTexturePool = (function () {
			function t(t) {
				(this.texturePool = {}),
					(this.textureOptions = t || {}),
					(this.enableFullScreen = !1),
					(this._pixelsWidth = 0),
					(this._pixelsHeight = 0);
			}
			return (
				(t.prototype.createTexture = function (t, e, i) {
					void 0 === i && (i = MSAA_QUALITY.NONE);
					var r = new BaseRenderTexture(
						Object.assign(
							{ width: t, height: e, resolution: 1, multisample: i },
							this.textureOptions
						)
					);
					return new RenderTexture(r);
				}),
				(t.prototype.getOptimalTexture = function (t, e, i, r) {
					var s;
					void 0 === i && (i = 1),
						void 0 === r && (r = MSAA_QUALITY.NONE),
						(t = Math.ceil(t * i)),
						(e = Math.ceil(e * i)),
						this.enableFullScreen &&
						t === this._pixelsWidth &&
						e === this._pixelsHeight
							? (s = r > 1 ? -r : -1)
							: ((s =
									(((65535 & (t = nextPow2(t))) << 16) |
										(65535 & (e = nextPow2(e)))) >>>
									0),
							  r > 1 && (s += 4294967296 * r)),
						this.texturePool[s] || (this.texturePool[s] = []);
					var n = this.texturePool[s].pop();
					return (
						n || (n = this.createTexture(t, e, r)),
						(n.filterPoolKey = s),
						n.setResolution(i),
						n
					);
				}),
				(t.prototype.getFilterTexture = function (t, e, i) {
					var r = this.getOptimalTexture(
						t.width,
						t.height,
						e || t.resolution,
						i || MSAA_QUALITY.NONE
					);
					return (r.filterFrame = t.filterFrame), r;
				}),
				(t.prototype.returnTexture = function (t) {
					var e = t.filterPoolKey;
					(t.filterFrame = null), this.texturePool[e].push(t);
				}),
				(t.prototype.returnFilterTexture = function (t) {
					this.returnTexture(t);
				}),
				(t.prototype.clear = function (t) {
					if ((t = !1 !== t))
						for (var e in this.texturePool) {
							var i = this.texturePool[e];
							if (i) for (var r = 0; r < i.length; r++) i[r].destroy(!0);
						}
					this.texturePool = {};
				}),
				(t.prototype.setScreenSize = function (t) {
					if (
						t.width !== this._pixelsWidth ||
						t.height !== this._pixelsHeight
					) {
						for (var e in ((this.enableFullScreen =
							t.width > 0 && t.height > 0),
						this.texturePool))
							if (Number(e) < 0) {
								var i = this.texturePool[e];
								if (i) for (var r = 0; r < i.length; r++) i[r].destroy(!0);
								this.texturePool[e] = [];
							}
						(this._pixelsWidth = t.width), (this._pixelsHeight = t.height);
					}
				}),
				(t.SCREEN_KEY = -1),
				t
			);
		})(),
		Attribute = (function () {
			function t(t, e, i, r, s, n, a) {
				void 0 === e && (e = 0),
					void 0 === i && (i = !1),
					void 0 === r && (r = TYPES.FLOAT),
					(this.buffer = t),
					(this.size = e),
					(this.normalized = i),
					(this.type = r),
					(this.stride = s),
					(this.start = n),
					(this.instance = a);
			}
			return (
				(t.prototype.destroy = function () {
					this.buffer = null;
				}),
				(t.from = function (e, i, r, s, n) {
					return new t(e, i, r, s, n);
				}),
				t
			);
		})(),
		UID = 0,
		Buffer = (function () {
			function t(t, e, i) {
				void 0 === e && (e = !0),
					void 0 === i && (i = !1),
					(this.data = t || new Float32Array(1)),
					(this._glBuffers = {}),
					(this._updateID = 0),
					(this.index = i),
					(this.static = e),
					(this.id = UID++),
					(this.disposeRunner = new Runner('disposeBuffer'));
			}
			return (
				(t.prototype.update = function (t) {
					t instanceof Array && (t = new Float32Array(t)),
						(this.data = t || this.data),
						this._updateID++;
				}),
				(t.prototype.dispose = function () {
					this.disposeRunner.emit(this, !1);
				}),
				(t.prototype.destroy = function () {
					this.dispose(), (this.data = null);
				}),
				Object.defineProperty(t.prototype, 'index', {
					get: function () {
						return this.type === BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
					},
					set: function (t) {
						this.type = t
							? BUFFER_TYPE.ELEMENT_ARRAY_BUFFER
							: BUFFER_TYPE.ARRAY_BUFFER;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.from = function (e) {
					return e instanceof Array && (e = new Float32Array(e)), new t(e);
				}),
				t
			);
		})(),
		map = { Float32Array, Uint32Array, Int32Array, Uint8Array };
	function interleaveTypedArrays(t, e) {
		for (var i = 0, r = 0, s = {}, n = 0; n < t.length; n++)
			(r += e[n]), (i += t[n].length);
		var a = new ArrayBuffer(4 * i),
			o = null,
			h = 0;
		for (n = 0; n < t.length; n++) {
			var u = e[n],
				l = t[n],
				c = getBufferType(l);
			s[c] || (s[c] = new map[c](a)), (o = s[c]);
			for (var d = 0; d < l.length; d++)
				o[((d / u) | 0) * r + h + (d % u)] = l[d];
			h += u;
		}
		return new Float32Array(a);
	}
	var byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 },
		UID$1 = 0,
		map$1 = { Float32Array, Uint32Array, Int32Array, Uint8Array, Uint16Array },
		Geometry = (function () {
			function t(t, e) {
				void 0 === t && (t = []),
					void 0 === e && (e = {}),
					(this.buffers = t),
					(this.indexBuffer = null),
					(this.attributes = e),
					(this.glVertexArrayObjects = {}),
					(this.id = UID$1++),
					(this.instanced = !1),
					(this.instanceCount = 1),
					(this.disposeRunner = new Runner('disposeGeometry')),
					(this.refCount = 0);
			}
			return (
				(t.prototype.addAttribute = function (t, e, i, r, s, n, a, o) {
					if (
						(void 0 === i && (i = 0),
						void 0 === r && (r = !1),
						void 0 === o && (o = !1),
						!e)
					)
						throw new Error(
							'You must pass a buffer when creating an attribute'
						);
					e instanceof Buffer ||
						(e instanceof Array && (e = new Float32Array(e)),
						(e = new Buffer(e)));
					var h = t.split('|');
					if (h.length > 1) {
						for (var u = 0; u < h.length; u++)
							this.addAttribute(h[u], e, i, r, s);
						return this;
					}
					var l = this.buffers.indexOf(e);
					return (
						-1 === l && (this.buffers.push(e), (l = this.buffers.length - 1)),
						(this.attributes[t] = new Attribute(l, i, r, s, n, a, o)),
						(this.instanced = this.instanced || o),
						this
					);
				}),
				(t.prototype.getAttribute = function (t) {
					return this.attributes[t];
				}),
				(t.prototype.getBuffer = function (t) {
					return this.buffers[this.getAttribute(t).buffer];
				}),
				(t.prototype.addIndex = function (t) {
					return (
						t instanceof Buffer ||
							(t instanceof Array && (t = new Uint16Array(t)),
							(t = new Buffer(t))),
						(t.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER),
						(this.indexBuffer = t),
						-1 === this.buffers.indexOf(t) && this.buffers.push(t),
						this
					);
				}),
				(t.prototype.getIndex = function () {
					return this.indexBuffer;
				}),
				(t.prototype.interleave = function () {
					if (
						1 === this.buffers.length ||
						(2 === this.buffers.length && this.indexBuffer)
					)
						return this;
					var t,
						e = [],
						i = [],
						r = new Buffer();
					for (t in this.attributes) {
						var s = this.attributes[t],
							n = this.buffers[s.buffer];
						e.push(n.data),
							i.push((s.size * byteSizeMap[s.type]) / 4),
							(s.buffer = 0);
					}
					for (
						r.data = interleaveTypedArrays(e, i), t = 0;
						t < this.buffers.length;
						t++
					)
						this.buffers[t] !== this.indexBuffer && this.buffers[t].destroy();
					return (
						(this.buffers = [r]),
						this.indexBuffer && this.buffers.push(this.indexBuffer),
						this
					);
				}),
				(t.prototype.getSize = function () {
					for (var t in this.attributes) {
						var e = this.attributes[t];
						return (
							this.buffers[e.buffer].data.length / (e.stride / 4 || e.size)
						);
					}
					return 0;
				}),
				(t.prototype.dispose = function () {
					this.disposeRunner.emit(this, !1);
				}),
				(t.prototype.destroy = function () {
					this.dispose(),
						(this.buffers = null),
						(this.indexBuffer = null),
						(this.attributes = null);
				}),
				(t.prototype.clone = function () {
					for (var e = new t(), i = 0; i < this.buffers.length; i++)
						e.buffers[i] = new Buffer(this.buffers[i].data.slice(0));
					for (var i in this.attributes) {
						var r = this.attributes[i];
						e.attributes[i] = new Attribute(
							r.buffer,
							r.size,
							r.normalized,
							r.type,
							r.stride,
							r.start,
							r.instance
						);
					}
					return (
						this.indexBuffer &&
							((e.indexBuffer =
								e.buffers[this.buffers.indexOf(this.indexBuffer)]),
							(e.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER)),
						e
					);
				}),
				(t.merge = function (e) {
					for (
						var i, r = new t(), s = [], n = [], a = [], o = 0;
						o < e.length;
						o++
					) {
						i = e[o];
						for (var h = 0; h < i.buffers.length; h++)
							(n[h] = n[h] || 0),
								(n[h] += i.buffers[h].data.length),
								(a[h] = 0);
					}
					for (o = 0; o < i.buffers.length; o++)
						(s[o] = new map$1[getBufferType(i.buffers[o].data)](n[o])),
							(r.buffers[o] = new Buffer(s[o]));
					for (o = 0; o < e.length; o++)
						for (i = e[o], h = 0; h < i.buffers.length; h++)
							s[h].set(i.buffers[h].data, a[h]),
								(a[h] += i.buffers[h].data.length);
					if (((r.attributes = i.attributes), i.indexBuffer)) {
						(r.indexBuffer = r.buffers[i.buffers.indexOf(i.indexBuffer)]),
							(r.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER);
						var u = 0,
							l = 0,
							c = 0,
							d = 0;
						for (o = 0; o < i.buffers.length; o++)
							if (i.buffers[o] !== i.indexBuffer) {
								d = o;
								break;
							}
						for (var o in i.attributes) {
							var p = i.attributes[o];
							(0 | p.buffer) === d && (l += (p.size * byteSizeMap[p.type]) / 4);
						}
						for (o = 0; o < e.length; o++) {
							var f = e[o].indexBuffer.data;
							for (h = 0; h < f.length; h++) r.indexBuffer.data[h + c] += u;
							(u += e[o].buffers[d].data.length / l), (c += f.length);
						}
					}
					return r;
				}),
				t
			);
		})(),
		Quad = (function (t) {
			function e() {
				var e = t.call(this) || this;
				return (
					e
						.addAttribute(
							'aVertexPosition',
							new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])
						)
						.addIndex([0, 1, 3, 2]),
					e
				);
			}
			return __extends$7(e, t), e;
		})(Geometry),
		QuadUv = (function (t) {
			function e() {
				var e = t.call(this) || this;
				return (
					(e.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1])),
					(e.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])),
					(e.vertexBuffer = new Buffer(e.vertices)),
					(e.uvBuffer = new Buffer(e.uvs)),
					e
						.addAttribute('aVertexPosition', e.vertexBuffer)
						.addAttribute('aTextureCoord', e.uvBuffer)
						.addIndex([0, 1, 2, 0, 2, 3]),
					e
				);
			}
			return (
				__extends$7(e, t),
				(e.prototype.map = function (t, e) {
					var i = 0,
						r = 0;
					return (
						(this.uvs[0] = i),
						(this.uvs[1] = r),
						(this.uvs[2] = i + e.width / t.width),
						(this.uvs[3] = r),
						(this.uvs[4] = i + e.width / t.width),
						(this.uvs[5] = r + e.height / t.height),
						(this.uvs[6] = i),
						(this.uvs[7] = r + e.height / t.height),
						(i = e.x),
						(r = e.y),
						(this.vertices[0] = i),
						(this.vertices[1] = r),
						(this.vertices[2] = i + e.width),
						(this.vertices[3] = r),
						(this.vertices[4] = i + e.width),
						(this.vertices[5] = r + e.height),
						(this.vertices[6] = i),
						(this.vertices[7] = r + e.height),
						this.invalidate(),
						this
					);
				}),
				(e.prototype.invalidate = function () {
					return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;
				}),
				e
			);
		})(Geometry),
		UID$2 = 0,
		UniformGroup = (function () {
			function t(t, e, i) {
				(this.group = !0),
					(this.syncUniforms = {}),
					(this.dirtyId = 0),
					(this.id = UID$2++),
					(this.static = !!e),
					(this.ubo = !!i),
					t instanceof Buffer
						? ((this.buffer = t),
						  (this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER),
						  (this.autoManage = !1),
						  (this.ubo = !0))
						: ((this.uniforms = t),
						  this.ubo &&
								((this.buffer = new Buffer(new Float32Array(1))),
								(this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER),
								(this.autoManage = !0)));
			}
			return (
				(t.prototype.update = function () {
					this.dirtyId++,
						!this.autoManage && this.buffer && this.buffer.update();
				}),
				(t.prototype.add = function (e, i, r) {
					if (this.ubo)
						throw new Error(
							'[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them'
						);
					this.uniforms[e] = new t(i, r);
				}),
				(t.from = function (e, i, r) {
					return new t(e, i, r);
				}),
				(t.uboFrom = function (e, i) {
					return new t(e, null == i || i, !0);
				}),
				t
			);
		})(),
		FilterState = (function () {
			function t() {
				(this.renderTexture = null),
					(this.target = null),
					(this.legacy = !1),
					(this.resolution = 1),
					(this.multisample = MSAA_QUALITY.NONE),
					(this.sourceFrame = new Rectangle$1()),
					(this.destinationFrame = new Rectangle$1()),
					(this.bindingSourceFrame = new Rectangle$1()),
					(this.bindingDestinationFrame = new Rectangle$1()),
					(this.filters = []),
					(this.transform = null);
			}
			return (
				(t.prototype.clear = function () {
					(this.target = null),
						(this.filters = null),
						(this.renderTexture = null);
				}),
				t
			);
		})(),
		tempPoints = [new Point$1(), new Point$1(), new Point$1(), new Point$1()],
		tempMatrix = new Matrix(),
		FilterSystem = (function () {
			function t(t) {
				(this.renderer = t),
					(this.defaultFilterStack = [{}]),
					(this.texturePool = new RenderTexturePool()),
					this.texturePool.setScreenSize(t.view),
					(this.statePool = []),
					(this.quad = new Quad()),
					(this.quadUv = new QuadUv()),
					(this.tempRect = new Rectangle$1()),
					(this.activeState = {}),
					(this.globalUniforms = new UniformGroup(
						{
							outputFrame: new Rectangle$1(),
							inputSize: new Float32Array(4),
							inputPixel: new Float32Array(4),
							inputClamp: new Float32Array(4),
							resolution: 1,
							filterArea: new Float32Array(4),
							filterClamp: new Float32Array(4),
						},
						!0
					)),
					(this.forceClear = !1),
					(this.useMaxPadding = !1);
			}
			return (
				(t.prototype.push = function (t, e) {
					for (
						var i,
							r,
							s = this.renderer,
							n = this.defaultFilterStack,
							a = this.statePool.pop() || new FilterState(),
							o = this.renderer.renderTexture,
							h = e[0].resolution,
							u = e[0].multisample,
							l = e[0].padding,
							c = e[0].autoFit,
							d = null === (i = e[0].legacy) || void 0 === i || i,
							p = 1;
						p < e.length;
						p++
					) {
						var f = e[p];
						(h = Math.min(h, f.resolution)),
							(u = Math.min(u, f.multisample)),
							(l = this.useMaxPadding ? Math.max(l, f.padding) : l + f.padding),
							(c = c && f.autoFit),
							(d = d || null === (r = f.legacy) || void 0 === r || r);
					}
					if (
						(1 === n.length &&
							(this.defaultFilterStack[0].renderTexture = o.current),
						n.push(a),
						(a.resolution = h),
						(a.multisample = u),
						(a.legacy = d),
						(a.target = t),
						a.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)),
						a.sourceFrame.pad(l),
						c)
					) {
						var m = this.tempRect.copyFrom(o.sourceFrame);
						s.projection.transform &&
							this.transformAABB(
								tempMatrix.copyFrom(s.projection.transform).invert(),
								m
							),
							a.sourceFrame.fit(m);
					}
					this.roundFrame(
						a.sourceFrame,
						o.current ? o.current.resolution : s.resolution,
						o.sourceFrame,
						o.destinationFrame,
						s.projection.transform
					),
						(a.renderTexture = this.getOptimalFilterTexture(
							a.sourceFrame.width,
							a.sourceFrame.height,
							h,
							u
						)),
						(a.filters = e),
						(a.destinationFrame.width = a.renderTexture.width),
						(a.destinationFrame.height = a.renderTexture.height);
					var _ = this.tempRect;
					(_.x = 0),
						(_.y = 0),
						(_.width = a.sourceFrame.width),
						(_.height = a.sourceFrame.height),
						(a.renderTexture.filterFrame = a.sourceFrame),
						a.bindingSourceFrame.copyFrom(o.sourceFrame),
						a.bindingDestinationFrame.copyFrom(o.destinationFrame),
						(a.transform = s.projection.transform),
						(s.projection.transform = null),
						o.bind(a.renderTexture, a.sourceFrame, _),
						s.framebuffer.clear(0, 0, 0, 0);
				}),
				(t.prototype.pop = function () {
					var t = this.defaultFilterStack,
						e = t.pop(),
						i = e.filters;
					this.activeState = e;
					var r = this.globalUniforms.uniforms;
					(r.outputFrame = e.sourceFrame), (r.resolution = e.resolution);
					var s = r.inputSize,
						n = r.inputPixel,
						a = r.inputClamp;
					if (
						((s[0] = e.destinationFrame.width),
						(s[1] = e.destinationFrame.height),
						(s[2] = 1 / s[0]),
						(s[3] = 1 / s[1]),
						(n[0] = Math.round(s[0] * e.resolution)),
						(n[1] = Math.round(s[1] * e.resolution)),
						(n[2] = 1 / n[0]),
						(n[3] = 1 / n[1]),
						(a[0] = 0.5 * n[2]),
						(a[1] = 0.5 * n[3]),
						(a[2] = e.sourceFrame.width * s[2] - 0.5 * n[2]),
						(a[3] = e.sourceFrame.height * s[3] - 0.5 * n[3]),
						e.legacy)
					) {
						var o = r.filterArea;
						(o[0] = e.destinationFrame.width),
							(o[1] = e.destinationFrame.height),
							(o[2] = e.sourceFrame.x),
							(o[3] = e.sourceFrame.y),
							(r.filterClamp = r.inputClamp);
					}
					this.globalUniforms.update();
					var h = t[t.length - 1];
					if ((this.renderer.framebuffer.blit(), 1 === i.length))
						i[0].apply(
							this,
							e.renderTexture,
							h.renderTexture,
							CLEAR_MODES.BLEND,
							e
						),
							this.returnFilterTexture(e.renderTexture);
					else {
						var u = e.renderTexture,
							l = this.getOptimalFilterTexture(u.width, u.height, e.resolution);
						l.filterFrame = u.filterFrame;
						var c = 0;
						for (c = 0; c < i.length - 1; ++c) {
							1 === c &&
								e.multisample > 1 &&
								((l = this.getOptimalFilterTexture(
									u.width,
									u.height,
									e.resolution
								)).filterFrame = u.filterFrame),
								i[c].apply(this, u, l, CLEAR_MODES.CLEAR, e);
							var d = u;
							(u = l), (l = d);
						}
						i[c].apply(this, u, h.renderTexture, CLEAR_MODES.BLEND, e),
							c > 1 &&
								e.multisample > 1 &&
								this.returnFilterTexture(e.renderTexture),
							this.returnFilterTexture(u),
							this.returnFilterTexture(l);
					}
					e.clear(), this.statePool.push(e);
				}),
				(t.prototype.bindAndClear = function (t, e) {
					void 0 === e && (e = CLEAR_MODES.CLEAR);
					var i = this.renderer,
						r = i.renderTexture,
						s = i.state;
					if (
						(t ===
						this.defaultFilterStack[this.defaultFilterStack.length - 1]
							.renderTexture
							? (this.renderer.projection.transform =
									this.activeState.transform)
							: (this.renderer.projection.transform = null),
						t && t.filterFrame)
					) {
						var n = this.tempRect;
						(n.x = 0),
							(n.y = 0),
							(n.width = t.filterFrame.width),
							(n.height = t.filterFrame.height),
							r.bind(t, t.filterFrame, n);
					} else
						t !==
						this.defaultFilterStack[this.defaultFilterStack.length - 1]
							.renderTexture
							? r.bind(t)
							: this.renderer.renderTexture.bind(
									t,
									this.activeState.bindingSourceFrame,
									this.activeState.bindingDestinationFrame
							  );
					var a = 1 & s.stateId || this.forceClear;
					(e === CLEAR_MODES.CLEAR || (e === CLEAR_MODES.BLIT && a)) &&
						this.renderer.framebuffer.clear(0, 0, 0, 0);
				}),
				(t.prototype.applyFilter = function (t, e, i, r) {
					var s = this.renderer;
					s.state.set(t.state),
						this.bindAndClear(i, r),
						(t.uniforms.uSampler = e),
						(t.uniforms.filterGlobals = this.globalUniforms),
						s.shader.bind(t),
						(t.legacy = !!t.program.attributeData.aTextureCoord),
						t.legacy
							? (this.quadUv.map(e._frame, e.filterFrame),
							  s.geometry.bind(this.quadUv),
							  s.geometry.draw(DRAW_MODES.TRIANGLES))
							: (s.geometry.bind(this.quad),
							  s.geometry.draw(DRAW_MODES.TRIANGLE_STRIP));
				}),
				(t.prototype.calculateSpriteMatrix = function (t, e) {
					var i = this.activeState,
						r = i.sourceFrame,
						s = i.destinationFrame,
						n = e._texture.orig,
						a = t.set(s.width, 0, 0, s.height, r.x, r.y),
						o = e.worldTransform.copyTo(Matrix.TEMP_MATRIX);
					return (
						o.invert(),
						a.prepend(o),
						a.scale(1 / n.width, 1 / n.height),
						a.translate(e.anchor.x, e.anchor.y),
						a
					);
				}),
				(t.prototype.destroy = function () {
					(this.renderer = null), this.texturePool.clear(!1);
				}),
				(t.prototype.getOptimalFilterTexture = function (t, e, i, r) {
					return (
						void 0 === i && (i = 1),
						void 0 === r && (r = MSAA_QUALITY.NONE),
						this.texturePool.getOptimalTexture(t, e, i, r)
					);
				}),
				(t.prototype.getFilterTexture = function (t, e, i) {
					if ('number' == typeof t) {
						var r = t;
						(t = e), (e = r);
					}
					t = t || this.activeState.renderTexture;
					var s = this.texturePool.getOptimalTexture(
						t.width,
						t.height,
						e || t.resolution,
						i || MSAA_QUALITY.NONE
					);
					return (s.filterFrame = t.filterFrame), s;
				}),
				(t.prototype.returnFilterTexture = function (t) {
					this.texturePool.returnTexture(t);
				}),
				(t.prototype.emptyPool = function () {
					this.texturePool.clear(!0);
				}),
				(t.prototype.resize = function () {
					this.texturePool.setScreenSize(this.renderer.view);
				}),
				(t.prototype.transformAABB = function (t, e) {
					var i = tempPoints[0],
						r = tempPoints[1],
						s = tempPoints[2],
						n = tempPoints[3];
					i.set(e.left, e.top),
						r.set(e.left, e.bottom),
						s.set(e.right, e.top),
						n.set(e.right, e.bottom),
						t.apply(i, i),
						t.apply(r, r),
						t.apply(s, s),
						t.apply(n, n);
					var a = Math.min(i.x, r.x, s.x, n.x),
						o = Math.min(i.y, r.y, s.y, n.y),
						h = Math.max(i.x, r.x, s.x, n.x),
						u = Math.max(i.y, r.y, s.y, n.y);
					(e.x = a), (e.y = o), (e.width = h - a), (e.height = u - o);
				}),
				(t.prototype.roundFrame = function (t, e, i, r, s) {
					if (
						!(t.width <= 0 || t.height <= 0 || i.width <= 0 || i.height <= 0)
					) {
						if (s) {
							var n = s.a,
								a = s.b,
								o = s.c,
								h = s.d;
							if (
								(Math.abs(a) > 1e-4 || Math.abs(o) > 1e-4) &&
								(Math.abs(n) > 1e-4 || Math.abs(h) > 1e-4)
							)
								return;
						}
						(s = s ? tempMatrix.copyFrom(s) : tempMatrix.identity())
							.translate(-i.x, -i.y)
							.scale(r.width / i.width, r.height / i.height)
							.translate(r.x, r.y),
							this.transformAABB(s, t),
							t.ceil(e),
							this.transformAABB(s.invert(), t);
					}
				}),
				t
			);
		})(),
		ObjectRenderer = (function () {
			function t(t) {
				this.renderer = t;
			}
			return (
				(t.prototype.flush = function () {}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				(t.prototype.start = function () {}),
				(t.prototype.stop = function () {
					this.flush();
				}),
				(t.prototype.render = function (t) {}),
				t
			);
		})(),
		BatchSystem = (function () {
			function t(t) {
				(this.renderer = t),
					(this.emptyRenderer = new ObjectRenderer(t)),
					(this.currentRenderer = this.emptyRenderer);
			}
			return (
				(t.prototype.setObjectRenderer = function (t) {
					this.currentRenderer !== t &&
						(this.currentRenderer.stop(),
						(this.currentRenderer = t),
						this.currentRenderer.start());
				}),
				(t.prototype.flush = function () {
					this.setObjectRenderer(this.emptyRenderer);
				}),
				(t.prototype.reset = function () {
					this.setObjectRenderer(this.emptyRenderer);
				}),
				(t.prototype.copyBoundTextures = function (t, e) {
					for (
						var i = this.renderer.texture.boundTextures, r = e - 1;
						r >= 0;
						--r
					)
						(t[r] = i[r] || null), t[r] && (t[r]._batchLocation = r);
				}),
				(t.prototype.boundArray = function (t, e, i, r) {
					for (
						var s = t.elements, n = t.ids, a = t.count, o = 0, h = 0;
						h < a;
						h++
					) {
						var u = s[h],
							l = u._batchLocation;
						if (l >= 0 && l < r && e[l] === u) n[h] = l;
						else
							for (; o < r; ) {
								var c = e[o];
								if (!c || c._batchEnabled !== i || c._batchLocation !== o) {
									(n[h] = o), (u._batchLocation = o), (e[o] = u);
									break;
								}
								o++;
							}
					}
				}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})(),
		CONTEXT_UID_COUNTER = 0,
		ContextSystem = (function () {
			function t(t) {
				(this.renderer = t),
					(this.webGLVersion = 1),
					(this.extensions = {}),
					(this.supports = { uint32Indices: !1 }),
					(this.handleContextLost = this.handleContextLost.bind(this)),
					(this.handleContextRestored = this.handleContextRestored.bind(this)),
					t.view.addEventListener(
						'webglcontextlost',
						this.handleContextLost,
						!1
					),
					t.view.addEventListener(
						'webglcontextrestored',
						this.handleContextRestored,
						!1
					);
			}
			return (
				Object.defineProperty(t.prototype, 'isLost', {
					get: function () {
						return !this.gl || this.gl.isContextLost();
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.contextChange = function (t) {
					(this.gl = t),
						(this.renderer.gl = t),
						(this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++),
						t.isContextLost() &&
							t.getExtension('WEBGL_lose_context') &&
							t.getExtension('WEBGL_lose_context').restoreContext();
				}),
				(t.prototype.initFromContext = function (t) {
					(this.gl = t),
						this.validateContext(t),
						(this.renderer.gl = t),
						(this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++),
						this.renderer.runners.contextChange.emit(t);
				}),
				(t.prototype.initFromOptions = function (t) {
					var e = this.createContext(this.renderer.view, t);
					this.initFromContext(e);
				}),
				(t.prototype.createContext = function (t, e) {
					var i;
					if (
						(settings.PREFER_ENV >= ENV.WEBGL2 &&
							(i = t.getContext('webgl2', e)),
						i)
					)
						this.webGLVersion = 2;
					else if (
						((this.webGLVersion = 1),
						!(i =
							t.getContext('webgl', e) ||
							t.getContext('experimental-webgl', e)))
					)
						throw new Error(
							'This browser does not support WebGL. Try using the canvas renderer'
						);
					return (this.gl = i), this.getExtensions(), this.gl;
				}),
				(t.prototype.getExtensions = function () {
					var t = this.gl,
						e = {
							anisotropicFiltering: t.getExtension(
								'EXT_texture_filter_anisotropic'
							),
							floatTextureLinear: t.getExtension('OES_texture_float_linear'),
							s3tc: t.getExtension('WEBGL_compressed_texture_s3tc'),
							s3tc_sRGB: t.getExtension('WEBGL_compressed_texture_s3tc_srgb'),
							etc: t.getExtension('WEBGL_compressed_texture_etc'),
							etc1: t.getExtension('WEBGL_compressed_texture_etc1'),
							pvrtc:
								t.getExtension('WEBGL_compressed_texture_pvrtc') ||
								t.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),
							atc: t.getExtension('WEBGL_compressed_texture_atc'),
							astc: t.getExtension('WEBGL_compressed_texture_astc'),
						};
					1 === this.webGLVersion
						? Object.assign(this.extensions, e, {
								drawBuffers: t.getExtension('WEBGL_draw_buffers'),
								depthTexture: t.getExtension('WEBGL_depth_texture'),
								loseContext: t.getExtension('WEBGL_lose_context'),
								vertexArrayObject:
									t.getExtension('OES_vertex_array_object') ||
									t.getExtension('MOZ_OES_vertex_array_object') ||
									t.getExtension('WEBKIT_OES_vertex_array_object'),
								uint32ElementIndex: t.getExtension('OES_element_index_uint'),
								floatTexture: t.getExtension('OES_texture_float'),
								floatTextureLinear: t.getExtension('OES_texture_float_linear'),
								textureHalfFloat: t.getExtension('OES_texture_half_float'),
								textureHalfFloatLinear: t.getExtension(
									'OES_texture_half_float_linear'
								),
						  })
						: 2 === this.webGLVersion &&
						  Object.assign(this.extensions, e, {
								colorBufferFloat: t.getExtension('EXT_color_buffer_float'),
						  });
				}),
				(t.prototype.handleContextLost = function (t) {
					t.preventDefault();
				}),
				(t.prototype.handleContextRestored = function () {
					this.renderer.runners.contextChange.emit(this.gl);
				}),
				(t.prototype.destroy = function () {
					var t = this.renderer.view;
					(this.renderer = null),
						t.removeEventListener('webglcontextlost', this.handleContextLost),
						t.removeEventListener(
							'webglcontextrestored',
							this.handleContextRestored
						),
						this.gl.useProgram(null),
						this.extensions.loseContext &&
							this.extensions.loseContext.loseContext();
				}),
				(t.prototype.postrender = function () {
					this.renderer.renderingToScreen && this.gl.flush();
				}),
				(t.prototype.validateContext = function (t) {
					var e = t.getContextAttributes(),
						i =
							'WebGL2RenderingContext' in self &&
							t instanceof self.WebGL2RenderingContext;
					i && (this.webGLVersion = 2), e.stencil;
					var r = i || !!t.getExtension('OES_element_index_uint');
					this.supports.uint32Indices = r;
				}),
				t
			);
		})(),
		GLFramebuffer = function (t) {
			(this.framebuffer = t),
				(this.stencil = null),
				(this.dirtyId = -1),
				(this.dirtyFormat = -1),
				(this.dirtySize = -1),
				(this.multisample = MSAA_QUALITY.NONE),
				(this.msaaBuffer = null),
				(this.blitFramebuffer = null),
				(this.mipLevel = 0);
		},
		tempRectangle = new Rectangle$1(),
		FramebufferSystem = (function () {
			function t(t) {
				(this.renderer = t),
					(this.managedFramebuffers = []),
					(this.unknownFramebuffer = new Framebuffer(10, 10)),
					(this.msaaSamples = null);
			}
			return (
				(t.prototype.contextChange = function () {
					var t = (this.gl = this.renderer.gl);
					if (
						((this.CONTEXT_UID = this.renderer.CONTEXT_UID),
						(this.current = this.unknownFramebuffer),
						(this.viewport = new Rectangle$1()),
						(this.hasMRT = !0),
						(this.writeDepthTexture = !0),
						this.disposeAll(!0),
						1 === this.renderer.context.webGLVersion)
					) {
						var e = this.renderer.context.extensions.drawBuffers,
							i = this.renderer.context.extensions.depthTexture;
						settings.PREFER_ENV === ENV.WEBGL_LEGACY &&
							((e = null), (i = null)),
							e
								? (t.drawBuffers = function (t) {
										return e.drawBuffersWEBGL(t);
								  })
								: ((this.hasMRT = !1), (t.drawBuffers = function () {})),
							i || (this.writeDepthTexture = !1);
					} else
						this.msaaSamples = t.getInternalformatParameter(
							t.RENDERBUFFER,
							t.RGBA8,
							t.SAMPLES
						);
				}),
				(t.prototype.bind = function (t, e, i) {
					void 0 === i && (i = 0);
					var r = this.gl;
					if (t) {
						var s =
							t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t);
						this.current !== t &&
							((this.current = t),
							r.bindFramebuffer(r.FRAMEBUFFER, s.framebuffer)),
							s.mipLevel !== i &&
								(t.dirtyId++, t.dirtyFormat++, (s.mipLevel = i)),
							s.dirtyId !== t.dirtyId &&
								((s.dirtyId = t.dirtyId),
								s.dirtyFormat !== t.dirtyFormat
									? ((s.dirtyFormat = t.dirtyFormat),
									  (s.dirtySize = t.dirtySize),
									  this.updateFramebuffer(t, i))
									: s.dirtySize !== t.dirtySize &&
									  ((s.dirtySize = t.dirtySize), this.resizeFramebuffer(t)));
						for (var n = 0; n < t.colorTextures.length; n++) {
							var a = t.colorTextures[n];
							this.renderer.texture.unbind(a.parentTextureArray || a);
						}
						if (
							(t.depthTexture && this.renderer.texture.unbind(t.depthTexture),
							e)
						) {
							var o = e.width >> i,
								h = e.height >> i,
								u = o / e.width;
							this.setViewport(e.x * u, e.y * u, o, h);
						} else
							(o = t.width >> i),
								(h = t.height >> i),
								this.setViewport(0, 0, o, h);
					} else
						this.current &&
							((this.current = null), r.bindFramebuffer(r.FRAMEBUFFER, null)),
							e
								? this.setViewport(e.x, e.y, e.width, e.height)
								: this.setViewport(
										0,
										0,
										this.renderer.width,
										this.renderer.height
								  );
				}),
				(t.prototype.setViewport = function (t, e, i, r) {
					var s = this.viewport;
					(t = Math.round(t)),
						(e = Math.round(e)),
						(i = Math.round(i)),
						(r = Math.round(r)),
						(s.width === i && s.height === r && s.x === t && s.y === e) ||
							((s.x = t),
							(s.y = e),
							(s.width = i),
							(s.height = r),
							this.gl.viewport(t, e, i, r));
				}),
				Object.defineProperty(t.prototype, 'size', {
					get: function () {
						return this.current
							? {
									x: 0,
									y: 0,
									width: this.current.width,
									height: this.current.height,
							  }
							: {
									x: 0,
									y: 0,
									width: this.renderer.width,
									height: this.renderer.height,
							  };
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.clear = function (t, e, i, r, s) {
					void 0 === s && (s = BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH);
					var n = this.gl;
					n.clearColor(t, e, i, r), n.clear(s);
				}),
				(t.prototype.initFramebuffer = function (t) {
					var e = this.gl,
						i = new GLFramebuffer(e.createFramebuffer());
					return (
						(i.multisample = this.detectSamples(t.multisample)),
						(t.glFramebuffers[this.CONTEXT_UID] = i),
						this.managedFramebuffers.push(t),
						t.disposeRunner.add(this),
						i
					);
				}),
				(t.prototype.resizeFramebuffer = function (t) {
					var e = this.gl,
						i = t.glFramebuffers[this.CONTEXT_UID];
					i.msaaBuffer &&
						(e.bindRenderbuffer(e.RENDERBUFFER, i.msaaBuffer),
						e.renderbufferStorageMultisample(
							e.RENDERBUFFER,
							i.multisample,
							e.RGBA8,
							t.width,
							t.height
						)),
						i.stencil &&
							(e.bindRenderbuffer(e.RENDERBUFFER, i.stencil),
							i.msaaBuffer
								? e.renderbufferStorageMultisample(
										e.RENDERBUFFER,
										i.multisample,
										e.DEPTH24_STENCIL8,
										t.width,
										t.height
								  )
								: e.renderbufferStorage(
										e.RENDERBUFFER,
										e.DEPTH_STENCIL,
										t.width,
										t.height
								  ));
					var r = t.colorTextures,
						s = r.length;
					e.drawBuffers || (s = Math.min(s, 1));
					for (var n = 0; n < s; n++) {
						var a = r[n],
							o = a.parentTextureArray || a;
						this.renderer.texture.bind(o, 0);
					}
					t.depthTexture &&
						this.writeDepthTexture &&
						this.renderer.texture.bind(t.depthTexture, 0);
				}),
				(t.prototype.updateFramebuffer = function (t, e) {
					var i = this.gl,
						r = t.glFramebuffers[this.CONTEXT_UID],
						s = t.colorTextures,
						n = s.length;
					i.drawBuffers || (n = Math.min(n, 1)),
						r.multisample > 1 && this.canMultisampleFramebuffer(t)
							? ((r.msaaBuffer = r.msaaBuffer || i.createRenderbuffer()),
							  i.bindRenderbuffer(i.RENDERBUFFER, r.msaaBuffer),
							  i.renderbufferStorageMultisample(
									i.RENDERBUFFER,
									r.multisample,
									i.RGBA8,
									t.width,
									t.height
							  ),
							  i.framebufferRenderbuffer(
									i.FRAMEBUFFER,
									i.COLOR_ATTACHMENT0,
									i.RENDERBUFFER,
									r.msaaBuffer
							  ))
							: r.msaaBuffer &&
							  (i.deleteRenderbuffer(r.msaaBuffer),
							  (r.msaaBuffer = null),
							  r.blitFramebuffer &&
									(r.blitFramebuffer.dispose(), (r.blitFramebuffer = null)));
					for (var a = [], o = 0; o < n; o++) {
						var h = s[o],
							u = h.parentTextureArray || h;
						this.renderer.texture.bind(u, 0),
							(0 === o && r.msaaBuffer) ||
								(i.framebufferTexture2D(
									i.FRAMEBUFFER,
									i.COLOR_ATTACHMENT0 + o,
									h.target,
									u._glTextures[this.CONTEXT_UID].texture,
									e
								),
								a.push(i.COLOR_ATTACHMENT0 + o));
					}
					if (
						(a.length > 1 && i.drawBuffers(a),
						t.depthTexture && this.writeDepthTexture)
					) {
						var l = t.depthTexture;
						this.renderer.texture.bind(l, 0),
							i.framebufferTexture2D(
								i.FRAMEBUFFER,
								i.DEPTH_ATTACHMENT,
								i.TEXTURE_2D,
								l._glTextures[this.CONTEXT_UID].texture,
								e
							);
					}
					(!t.stencil && !t.depth) || (t.depthTexture && this.writeDepthTexture)
						? r.stencil && (i.deleteRenderbuffer(r.stencil), (r.stencil = null))
						: ((r.stencil = r.stencil || i.createRenderbuffer()),
						  i.bindRenderbuffer(i.RENDERBUFFER, r.stencil),
						  r.msaaBuffer
								? i.renderbufferStorageMultisample(
										i.RENDERBUFFER,
										r.multisample,
										i.DEPTH24_STENCIL8,
										t.width,
										t.height
								  )
								: i.renderbufferStorage(
										i.RENDERBUFFER,
										i.DEPTH_STENCIL,
										t.width,
										t.height
								  ),
						  i.framebufferRenderbuffer(
								i.FRAMEBUFFER,
								i.DEPTH_STENCIL_ATTACHMENT,
								i.RENDERBUFFER,
								r.stencil
						  ));
				}),
				(t.prototype.canMultisampleFramebuffer = function (t) {
					return (
						1 !== this.renderer.context.webGLVersion &&
						t.colorTextures.length <= 1 &&
						!t.depthTexture
					);
				}),
				(t.prototype.detectSamples = function (t) {
					var e = this.msaaSamples,
						i = MSAA_QUALITY.NONE;
					if (t <= 1 || null === e) return i;
					for (var r = 0; r < e.length; r++)
						if (e[r] <= t) {
							i = e[r];
							break;
						}
					return 1 === i && (i = MSAA_QUALITY.NONE), i;
				}),
				(t.prototype.blit = function (t, e, i) {
					var r = this,
						s = r.current,
						n = r.renderer,
						a = r.gl,
						o = r.CONTEXT_UID;
					if (2 === n.context.webGLVersion && s) {
						var h = s.glFramebuffers[o];
						if (h) {
							if (!t) {
								if (!h.msaaBuffer) return;
								var u = s.colorTextures[0];
								if (!u) return;
								h.blitFramebuffer ||
									((h.blitFramebuffer = new Framebuffer(s.width, s.height)),
									h.blitFramebuffer.addColorTexture(0, u)),
									(t = h.blitFramebuffer).colorTextures[0] !== u &&
										((t.colorTextures[0] = u), t.dirtyId++, t.dirtyFormat++),
									(t.width === s.width && t.height === s.height) ||
										((t.width = s.width),
										(t.height = s.height),
										t.dirtyId++,
										t.dirtySize++);
							}
							e ||
								(((e = tempRectangle).width = s.width), (e.height = s.height)),
								i || (i = e);
							var l = e.width === i.width && e.height === i.height;
							this.bind(t),
								a.bindFramebuffer(a.READ_FRAMEBUFFER, h.framebuffer),
								a.blitFramebuffer(
									e.x,
									e.y,
									e.width,
									e.height,
									i.x,
									i.y,
									i.width,
									i.height,
									a.COLOR_BUFFER_BIT,
									l ? a.NEAREST : a.LINEAR
								);
						}
					}
				}),
				(t.prototype.disposeFramebuffer = function (t, e) {
					var i = t.glFramebuffers[this.CONTEXT_UID],
						r = this.gl;
					if (i) {
						delete t.glFramebuffers[this.CONTEXT_UID];
						var s = this.managedFramebuffers.indexOf(t);
						s >= 0 && this.managedFramebuffers.splice(s, 1),
							t.disposeRunner.remove(this),
							e ||
								(r.deleteFramebuffer(i.framebuffer),
								i.msaaBuffer && r.deleteRenderbuffer(i.msaaBuffer),
								i.stencil && r.deleteRenderbuffer(i.stencil)),
							i.blitFramebuffer && i.blitFramebuffer.dispose();
					}
				}),
				(t.prototype.disposeAll = function (t) {
					var e = this.managedFramebuffers;
					this.managedFramebuffers = [];
					for (var i = 0; i < e.length; i++) this.disposeFramebuffer(e[i], t);
				}),
				(t.prototype.forceStencil = function () {
					var t = this.current;
					if (t) {
						var e = t.glFramebuffers[this.CONTEXT_UID];
						if (e && !e.stencil) {
							t.stencil = !0;
							var i = t.width,
								r = t.height,
								s = this.gl,
								n = s.createRenderbuffer();
							s.bindRenderbuffer(s.RENDERBUFFER, n),
								e.msaaBuffer
									? s.renderbufferStorageMultisample(
											s.RENDERBUFFER,
											e.multisample,
											s.DEPTH24_STENCIL8,
											i,
											r
									  )
									: s.renderbufferStorage(
											s.RENDERBUFFER,
											s.DEPTH_STENCIL,
											i,
											r
									  ),
								(e.stencil = n),
								s.framebufferRenderbuffer(
									s.FRAMEBUFFER,
									s.DEPTH_STENCIL_ATTACHMENT,
									s.RENDERBUFFER,
									n
								);
						}
					}
				}),
				(t.prototype.reset = function () {
					(this.current = this.unknownFramebuffer),
						(this.viewport = new Rectangle$1());
				}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})(),
		byteSizeMap$1 = { 5126: 4, 5123: 2, 5121: 1 },
		GeometrySystem = (function () {
			function t(t) {
				(this.renderer = t),
					(this._activeGeometry = null),
					(this._activeVao = null),
					(this.hasVao = !0),
					(this.hasInstance = !0),
					(this.canUseUInt32ElementIndex = !1),
					(this.managedGeometries = {});
			}
			return (
				(t.prototype.contextChange = function () {
					this.disposeAll(!0);
					var t = (this.gl = this.renderer.gl),
						e = this.renderer.context;
					if (
						((this.CONTEXT_UID = this.renderer.CONTEXT_UID),
						2 !== e.webGLVersion)
					) {
						var i = this.renderer.context.extensions.vertexArrayObject;
						settings.PREFER_ENV === ENV.WEBGL_LEGACY && (i = null),
							i
								? ((t.createVertexArray = function () {
										return i.createVertexArrayOES();
								  }),
								  (t.bindVertexArray = function (t) {
										return i.bindVertexArrayOES(t);
								  }),
								  (t.deleteVertexArray = function (t) {
										return i.deleteVertexArrayOES(t);
								  }))
								: ((this.hasVao = !1),
								  (t.createVertexArray = function () {
										return null;
								  }),
								  (t.bindVertexArray = function () {
										return null;
								  }),
								  (t.deleteVertexArray = function () {
										return null;
								  }));
					}
					if (2 !== e.webGLVersion) {
						var r = t.getExtension('ANGLE_instanced_arrays');
						r
							? ((t.vertexAttribDivisor = function (t, e) {
									return r.vertexAttribDivisorANGLE(t, e);
							  }),
							  (t.drawElementsInstanced = function (t, e, i, s, n) {
									return r.drawElementsInstancedANGLE(t, e, i, s, n);
							  }),
							  (t.drawArraysInstanced = function (t, e, i, s) {
									return r.drawArraysInstancedANGLE(t, e, i, s);
							  }))
							: (this.hasInstance = !1);
					}
					this.canUseUInt32ElementIndex =
						2 === e.webGLVersion || !!e.extensions.uint32ElementIndex;
				}),
				(t.prototype.bind = function (t, e) {
					e = e || this.renderer.shader.shader;
					var i = this.gl,
						r = t.glVertexArrayObjects[this.CONTEXT_UID],
						s = !1;
					r ||
						((this.managedGeometries[t.id] = t),
						t.disposeRunner.add(this),
						(t.glVertexArrayObjects[this.CONTEXT_UID] = r = {}),
						(s = !0));
					var n = r[e.program.id] || this.initGeometryVao(t, e, s);
					(this._activeGeometry = t),
						this._activeVao !== n &&
							((this._activeVao = n),
							this.hasVao
								? i.bindVertexArray(n)
								: this.activateVao(t, e.program)),
						this.updateBuffers();
				}),
				(t.prototype.reset = function () {
					this.unbind();
				}),
				(t.prototype.updateBuffers = function () {
					for (
						var t = this._activeGeometry, e = this.renderer.buffer, i = 0;
						i < t.buffers.length;
						i++
					) {
						var r = t.buffers[i];
						e.update(r);
					}
				}),
				(t.prototype.checkCompatibility = function (t, e) {
					var i = t.attributes,
						r = e.attributeData;
					for (var s in r)
						if (!i[s])
							throw new Error(
								'shader and geometry incompatible, geometry missing the "' +
									s +
									'" attribute'
							);
				}),
				(t.prototype.getSignature = function (t, e) {
					var i = t.attributes,
						r = e.attributeData,
						s = ['g', t.id];
					for (var n in i) r[n] && s.push(n, r[n].location);
					return s.join('-');
				}),
				(t.prototype.initGeometryVao = function (t, e, i) {
					void 0 === i && (i = !0);
					var r = this.gl,
						s = this.CONTEXT_UID,
						n = this.renderer.buffer,
						a = e.program;
					a.glPrograms[s] || this.renderer.shader.generateProgram(e),
						this.checkCompatibility(t, a);
					var o = this.getSignature(t, a),
						h = t.glVertexArrayObjects[this.CONTEXT_UID],
						u = h[o];
					if (u) return (h[a.id] = u), u;
					var l = t.buffers,
						c = t.attributes,
						d = {},
						p = {};
					for (var f in l) (d[f] = 0), (p[f] = 0);
					for (var f in c)
						!c[f].size && a.attributeData[f]
							? (c[f].size = a.attributeData[f].size)
							: c[f].size,
							(d[c[f].buffer] += c[f].size * byteSizeMap$1[c[f].type]);
					for (var f in c) {
						var m = c[f],
							_ = m.size;
						void 0 === m.stride &&
							(d[m.buffer] === _ * byteSizeMap$1[m.type]
								? (m.stride = 0)
								: (m.stride = d[m.buffer])),
							void 0 === m.start &&
								((m.start = p[m.buffer]),
								(p[m.buffer] += _ * byteSizeMap$1[m.type]));
					}
					(u = r.createVertexArray()), r.bindVertexArray(u);
					for (var g = 0; g < l.length; g++) {
						var E = l[g];
						n.bind(E), i && E._glBuffers[s].refCount++;
					}
					return (
						this.activateVao(t, a),
						(this._activeVao = u),
						(h[a.id] = u),
						(h[o] = u),
						u
					);
				}),
				(t.prototype.disposeGeometry = function (t, e) {
					var i;
					if (this.managedGeometries[t.id]) {
						delete this.managedGeometries[t.id];
						var r = t.glVertexArrayObjects[this.CONTEXT_UID],
							s = this.gl,
							n = t.buffers,
							a =
								null === (i = this.renderer) || void 0 === i
									? void 0
									: i.buffer;
						if ((t.disposeRunner.remove(this), r)) {
							if (a)
								for (var o = 0; o < n.length; o++) {
									var h = n[o]._glBuffers[this.CONTEXT_UID];
									h &&
										(h.refCount--, 0 !== h.refCount || e || a.dispose(n[o], e));
								}
							if (!e)
								for (var u in r)
									if ('g' === u[0]) {
										var l = r[u];
										this._activeVao === l && this.unbind(),
											s.deleteVertexArray(l);
									}
							delete t.glVertexArrayObjects[this.CONTEXT_UID];
						}
					}
				}),
				(t.prototype.disposeAll = function (t) {
					for (
						var e = Object.keys(this.managedGeometries), i = 0;
						i < e.length;
						i++
					)
						this.disposeGeometry(this.managedGeometries[e[i]], t);
				}),
				(t.prototype.activateVao = function (t, e) {
					var i = this.gl,
						r = this.CONTEXT_UID,
						s = this.renderer.buffer,
						n = t.buffers,
						a = t.attributes;
					t.indexBuffer && s.bind(t.indexBuffer);
					var o = null;
					for (var h in a) {
						var u = a[h],
							l = n[u.buffer],
							c = l._glBuffers[r];
						if (e.attributeData[h]) {
							o !== c && (s.bind(l), (o = c));
							var d = e.attributeData[h].location;
							if (
								(i.enableVertexAttribArray(d),
								i.vertexAttribPointer(
									d,
									u.size,
									u.type || i.FLOAT,
									u.normalized,
									u.stride,
									u.start
								),
								u.instance)
							) {
								if (!this.hasInstance)
									throw new Error(
										'geometry error, GPU Instancing is not supported on this device'
									);
								i.vertexAttribDivisor(d, 1);
							}
						}
					}
				}),
				(t.prototype.draw = function (t, e, i, r) {
					var s = this.gl,
						n = this._activeGeometry;
					if (n.indexBuffer) {
						var a = n.indexBuffer.data.BYTES_PER_ELEMENT,
							o = 2 === a ? s.UNSIGNED_SHORT : s.UNSIGNED_INT;
						(2 === a || (4 === a && this.canUseUInt32ElementIndex)) &&
							(n.instanced
								? s.drawElementsInstanced(
										t,
										e || n.indexBuffer.data.length,
										o,
										(i || 0) * a,
										r || 1
								  )
								: s.drawElements(
										t,
										e || n.indexBuffer.data.length,
										o,
										(i || 0) * a
								  ));
					} else
						n.instanced
							? s.drawArraysInstanced(t, i, e || n.getSize(), r || 1)
							: s.drawArrays(t, i, e || n.getSize());
					return this;
				}),
				(t.prototype.unbind = function () {
					this.gl.bindVertexArray(null),
						(this._activeVao = null),
						(this._activeGeometry = null);
				}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})(),
		MaskData = (function () {
			function t(t) {
				void 0 === t && (t = null),
					(this.type = MASK_TYPES.NONE),
					(this.autoDetect = !0),
					(this.maskObject = t || null),
					(this.pooled = !1),
					(this.isMaskData = !0),
					(this.resolution = null),
					(this.multisample = settings.FILTER_MULTISAMPLE),
					(this.enabled = !0),
					(this._filters = null),
					(this._stencilCounter = 0),
					(this._scissorCounter = 0),
					(this._scissorRect = null),
					(this._scissorRectLocal = null),
					(this._target = null);
			}
			return (
				Object.defineProperty(t.prototype, 'filter', {
					get: function () {
						return this._filters ? this._filters[0] : null;
					},
					set: function (t) {
						t
							? this._filters
								? (this._filters[0] = t)
								: (this._filters = [t])
							: (this._filters = null);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.reset = function () {
					this.pooled &&
						((this.maskObject = null),
						(this.type = MASK_TYPES.NONE),
						(this.autoDetect = !0)),
						(this._target = null),
						(this._scissorRectLocal = null);
				}),
				(t.prototype.copyCountersOrReset = function (t) {
					t
						? ((this._stencilCounter = t._stencilCounter),
						  (this._scissorCounter = t._scissorCounter),
						  (this._scissorRect = t._scissorRect))
						: ((this._stencilCounter = 0),
						  (this._scissorCounter = 0),
						  (this._scissorRect = null));
				}),
				t
			);
		})();
	function compileShader(t, e, i) {
		var r = t.createShader(e);
		return t.shaderSource(r, i), t.compileShader(r), r;
	}
	function logPrettyShaderError(t, e) {
		var i = t
				.getShaderSource(e)
				.split('\n')
				.map(function (t, e) {
					return e + ': ' + t;
				}),
			r = t.getShaderInfoLog(e).split('\n'),
			s = {},
			n = r
				.map(function (t) {
					return parseFloat(t.replace(/^ERROR\: 0\:([\d]+)\:.*$/, '$1'));
				})
				.filter(function (t) {
					return !(!t || s[t] || ((s[t] = !0), 0));
				}),
			a = [''];
		n.forEach(function (t) {
			(i[t - 1] = '%c' + i[t - 1] + '%c'),
				a.push(
					'background: #FF0000; color:#FFFFFF; font-size: 10px',
					'font-size: 10px'
				);
		});
		var o = i.join('\n');
		a[0] = o;
	}
	function logProgramError(t, e, i, r) {
		t.getProgramParameter(e, t.LINK_STATUS) ||
			(t.getShaderParameter(i, t.COMPILE_STATUS) || logPrettyShaderError(t, i),
			t.getShaderParameter(r, t.COMPILE_STATUS) || logPrettyShaderError(t, r),
			t.getProgramInfoLog(e));
	}
	function booleanArray(t) {
		for (var e = new Array(t), i = 0; i < e.length; i++) e[i] = !1;
		return e;
	}
	function defaultValue(t, e) {
		switch (t) {
			case 'float':
			case 'int':
			case 'uint':
			case 'sampler2D':
			case 'sampler2DArray':
				return 0;
			case 'vec2':
				return new Float32Array(2 * e);
			case 'vec3':
				return new Float32Array(3 * e);
			case 'vec4':
				return new Float32Array(4 * e);
			case 'ivec2':
				return new Int32Array(2 * e);
			case 'ivec3':
				return new Int32Array(3 * e);
			case 'ivec4':
				return new Int32Array(4 * e);
			case 'uvec2':
				return new Uint32Array(2 * e);
			case 'uvec3':
				return new Uint32Array(3 * e);
			case 'uvec4':
				return new Uint32Array(4 * e);
			case 'bool':
				return !1;
			case 'bvec2':
				return booleanArray(2 * e);
			case 'bvec3':
				return booleanArray(3 * e);
			case 'bvec4':
				return booleanArray(4 * e);
			case 'mat2':
				return new Float32Array([1, 0, 0, 1]);
			case 'mat3':
				return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
			case 'mat4':
				return new Float32Array([
					1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
				]);
		}
		return null;
	}
	var unknownContext = {},
		context = unknownContext,
		maxFragmentPrecision;
	function getTestContext() {
		if (context === unknownContext || (context && context.isContextLost())) {
			var t = document.createElement('canvas'),
				e = void 0;
			settings.PREFER_ENV >= ENV.WEBGL2 && (e = t.getContext('webgl2', {})),
				e ||
					((e =
						t.getContext('webgl', {}) || t.getContext('experimental-webgl', {}))
						? e.getExtension('WEBGL_draw_buffers')
						: (e = null)),
				(context = e);
		}
		return context;
	}
	function getMaxFragmentPrecision() {
		if (!maxFragmentPrecision) {
			maxFragmentPrecision = PRECISION.MEDIUM;
			var t = getTestContext();
			if (t && t.getShaderPrecisionFormat) {
				var e = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT);
				maxFragmentPrecision = e.precision ? PRECISION.HIGH : PRECISION.MEDIUM;
			}
		}
		return maxFragmentPrecision;
	}
	function setPrecision(t, e, i) {
		if ('precision' !== t.substring(0, 9)) {
			var r = e;
			return (
				e === PRECISION.HIGH && i !== PRECISION.HIGH && (r = PRECISION.MEDIUM),
				'precision ' + r + ' float;\n' + t
			);
		}
		return i !== PRECISION.HIGH && 'precision highp' === t.substring(0, 15)
			? t.replace('precision highp', 'precision mediump')
			: t;
	}
	var GLSL_TO_SIZE = {
		float: 1,
		vec2: 2,
		vec3: 3,
		vec4: 4,
		int: 1,
		ivec2: 2,
		ivec3: 3,
		ivec4: 4,
		uint: 1,
		uvec2: 2,
		uvec3: 3,
		uvec4: 4,
		bool: 1,
		bvec2: 2,
		bvec3: 3,
		bvec4: 4,
		mat2: 4,
		mat3: 9,
		mat4: 16,
		sampler2D: 1,
	};
	function mapSize(t) {
		return GLSL_TO_SIZE[t];
	}
	var GL_TABLE = null,
		GL_TO_GLSL_TYPES = {
			FLOAT: 'float',
			FLOAT_VEC2: 'vec2',
			FLOAT_VEC3: 'vec3',
			FLOAT_VEC4: 'vec4',
			INT: 'int',
			INT_VEC2: 'ivec2',
			INT_VEC3: 'ivec3',
			INT_VEC4: 'ivec4',
			UNSIGNED_INT: 'uint',
			UNSIGNED_INT_VEC2: 'uvec2',
			UNSIGNED_INT_VEC3: 'uvec3',
			UNSIGNED_INT_VEC4: 'uvec4',
			BOOL: 'bool',
			BOOL_VEC2: 'bvec2',
			BOOL_VEC3: 'bvec3',
			BOOL_VEC4: 'bvec4',
			FLOAT_MAT2: 'mat2',
			FLOAT_MAT3: 'mat3',
			FLOAT_MAT4: 'mat4',
			SAMPLER_2D: 'sampler2D',
			INT_SAMPLER_2D: 'sampler2D',
			UNSIGNED_INT_SAMPLER_2D: 'sampler2D',
			SAMPLER_CUBE: 'samplerCube',
			INT_SAMPLER_CUBE: 'samplerCube',
			UNSIGNED_INT_SAMPLER_CUBE: 'samplerCube',
			SAMPLER_2D_ARRAY: 'sampler2DArray',
			INT_SAMPLER_2D_ARRAY: 'sampler2DArray',
			UNSIGNED_INT_SAMPLER_2D_ARRAY: 'sampler2DArray',
		};
	function mapType(t, e) {
		if (!GL_TABLE) {
			var i = Object.keys(GL_TO_GLSL_TYPES);
			GL_TABLE = {};
			for (var r = 0; r < i.length; ++r) {
				var s = i[r];
				GL_TABLE[t[s]] = GL_TO_GLSL_TYPES[s];
			}
		}
		return GL_TABLE[e];
	}
	var uniformParsers = [
			{
				test: function (t) {
					return 'float' === t.type && 1 === t.size;
				},
				code: function (t) {
					return (
						'\n            if(uv["' +
						t +
						'"] !== ud["' +
						t +
						'"].value)\n            {\n                ud["' +
						t +
						'"].value = uv["' +
						t +
						'"]\n                gl.uniform1f(ud["' +
						t +
						'"].location, uv["' +
						t +
						'"])\n            }\n            '
					);
				},
			},
			{
				test: function (t) {
					return (
						('sampler2D' === t.type ||
							'samplerCube' === t.type ||
							'sampler2DArray' === t.type) &&
						1 === t.size &&
						!t.isArray
					);
				},
				code: function (t) {
					return (
						't = syncData.textureCount++;\n\n            renderer.texture.bind(uv["' +
						t +
						'"], t);\n\n            if(ud["' +
						t +
						'"].value !== t)\n            {\n                ud["' +
						t +
						'"].value = t;\n                gl.uniform1i(ud["' +
						t +
						'"].location, t);\n; // eslint-disable-line max-len\n            }'
					);
				},
			},
			{
				test: function (t, e) {
					return 'mat3' === t.type && 1 === t.size && void 0 !== e.a;
				},
				code: function (t) {
					return (
						'\n            gl.uniformMatrix3fv(ud["' +
						t +
						'"].location, false, uv["' +
						t +
						'"].toArray(true));\n            '
					);
				},
				codeUbo: function (t) {
					return (
						'\n                var ' +
						t +
						'_matrix = uv.' +
						t +
						'.toArray(true);\n\n                data[offset] = ' +
						t +
						'_matrix[0];\n                data[offset+1] = ' +
						t +
						'_matrix[1];\n                data[offset+2] = ' +
						t +
						'_matrix[2];\n        \n                data[offset + 4] = ' +
						t +
						'_matrix[3];\n                data[offset + 5] = ' +
						t +
						'_matrix[4];\n                data[offset + 6] = ' +
						t +
						'_matrix[5];\n        \n                data[offset + 8] = ' +
						t +
						'_matrix[6];\n                data[offset + 9] = ' +
						t +
						'_matrix[7];\n                data[offset + 10] = ' +
						t +
						'_matrix[8];\n            '
					);
				},
			},
			{
				test: function (t, e) {
					return 'vec2' === t.type && 1 === t.size && void 0 !== e.x;
				},
				code: function (t) {
					return (
						'\n                cv = ud["' +
						t +
						'"].value;\n                v = uv["' +
						t +
						'"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["' +
						t +
						'"].location, v.x, v.y);\n                }'
					);
				},
				codeUbo: function (t) {
					return (
						'\n                v = uv.' +
						t +
						';\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            '
					);
				},
			},
			{
				test: function (t) {
					return 'vec2' === t.type && 1 === t.size;
				},
				code: function (t) {
					return (
						'\n                cv = ud["' +
						t +
						'"].value;\n                v = uv["' +
						t +
						'"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["' +
						t +
						'"].location, v[0], v[1]);\n                }\n            '
					);
				},
			},
			{
				test: function (t, e) {
					return 'vec4' === t.type && 1 === t.size && void 0 !== e.width;
				},
				code: function (t) {
					return (
						'\n                cv = ud["' +
						t +
						'"].value;\n                v = uv["' +
						t +
						'"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["' +
						t +
						'"].location, v.x, v.y, v.width, v.height)\n                }'
					);
				},
				codeUbo: function (t) {
					return (
						'\n                    v = uv.' +
						t +
						';\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                '
					);
				},
			},
			{
				test: function (t) {
					return 'vec4' === t.type && 1 === t.size;
				},
				code: function (t) {
					return (
						'\n                cv = ud["' +
						t +
						'"].value;\n                v = uv["' +
						t +
						'"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["' +
						t +
						'"].location, v[0], v[1], v[2], v[3])\n                }'
					);
				},
			},
		],
		GLSL_TO_SINGLE_SETTERS_CACHED = {
			float:
				'\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }',
			vec2: '\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }',
			vec3: '\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }',
			vec4: '\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }',
			int: '\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }',
			ivec2:
				'\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }',
			ivec3:
				'\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }',
			ivec4:
				'\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }',
			uint: '\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }',
			uvec2:
				'\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }',
			uvec3:
				'\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }',
			uvec4:
				'\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }',
			bool: '\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }',
			bvec2:
				'\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }',
			bvec3:
				'\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }',
			bvec4:
				'\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }',
			mat2: 'gl.uniformMatrix2fv(location, false, v)',
			mat3: 'gl.uniformMatrix3fv(location, false, v)',
			mat4: 'gl.uniformMatrix4fv(location, false, v)',
			sampler2D: 'gl.uniform1i(location, v)',
			samplerCube: 'gl.uniform1i(location, v)',
			sampler2DArray: 'gl.uniform1i(location, v)',
		},
		GLSL_TO_ARRAY_SETTERS = {
			float: 'gl.uniform1fv(location, v)',
			vec2: 'gl.uniform2fv(location, v)',
			vec3: 'gl.uniform3fv(location, v)',
			vec4: 'gl.uniform4fv(location, v)',
			mat4: 'gl.uniformMatrix4fv(location, false, v)',
			mat3: 'gl.uniformMatrix3fv(location, false, v)',
			mat2: 'gl.uniformMatrix2fv(location, false, v)',
			int: 'gl.uniform1iv(location, v)',
			ivec2: 'gl.uniform2iv(location, v)',
			ivec3: 'gl.uniform3iv(location, v)',
			ivec4: 'gl.uniform4iv(location, v)',
			uint: 'gl.uniform1uiv(location, v)',
			uvec2: 'gl.uniform2uiv(location, v)',
			uvec3: 'gl.uniform3uiv(location, v)',
			uvec4: 'gl.uniform4uiv(location, v)',
			bool: 'gl.uniform1iv(location, v)',
			bvec2: 'gl.uniform2iv(location, v)',
			bvec3: 'gl.uniform3iv(location, v)',
			bvec4: 'gl.uniform4iv(location, v)',
			sampler2D: 'gl.uniform1iv(location, v)',
			samplerCube: 'gl.uniform1iv(location, v)',
			sampler2DArray: 'gl.uniform1iv(location, v)',
		};
	function generateUniformsSync(t, e) {
		var i,
			r = [
				'\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    ',
			];
		for (var s in t.uniforms) {
			var n = e[s];
			if (n) {
				for (
					var a = t.uniforms[s], o = !1, h = 0;
					h < uniformParsers.length;
					h++
				)
					if (uniformParsers[h].test(n, a)) {
						r.push(uniformParsers[h].code(s, a)), (o = !0);
						break;
					}
				if (!o) {
					var u = (
						1 === n.size ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS
					)[n.type].replace('location', 'ud["' + s + '"].location');
					r.push(
						'\n            cu = ud["' +
							s +
							'"];\n            cv = cu.value;\n            v = uv["' +
							s +
							'"];\n            ' +
							u +
							';'
					);
				}
			} else
				(null === (i = t.uniforms[s]) || void 0 === i ? void 0 : i.group) &&
					(t.uniforms[s].ubo
						? r.push(
								'\n                        renderer.shader.syncUniformBufferGroup(uv.' +
									s +
									", '" +
									s +
									"');\n                    "
						  )
						: r.push(
								'\n                        renderer.shader.syncUniformGroup(uv.' +
									s +
									', syncData);\n                    '
						  ));
		}
		return new Function('ud', 'uv', 'renderer', 'syncData', r.join('\n'));
	}
	var fragTemplate = [
			'precision mediump float;',
			'void main(void){',
			'float test = 0.1;',
			'%forloop%',
			'gl_FragColor = vec4(0.0);',
			'}',
		].join('\n'),
		unsafeEval;
	function generateIfTestSrc(t) {
		for (var e = '', i = 0; i < t; ++i)
			i > 0 && (e += '\nelse '),
				i < t - 1 && (e += 'if(test == ' + i + '.0){}');
		return e;
	}
	function checkMaxIfStatementsInShader(t, e) {
		if (0 === t)
			throw new Error(
				'Invalid value of `0` passed to `checkMaxIfStatementsInShader`'
			);
		for (var i = e.createShader(e.FRAGMENT_SHADER); ; ) {
			var r = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(t));
			if (
				(e.shaderSource(i, r),
				e.compileShader(i),
				e.getShaderParameter(i, e.COMPILE_STATUS))
			)
				break;
			t = (t / 2) | 0;
		}
		return t;
	}
	function unsafeEvalSupported() {
		if ('boolean' == typeof unsafeEval) return unsafeEval;
		try {
			var t = new Function(
				'param1',
				'param2',
				'param3',
				'return param1[param2] === param3;'
			);
			unsafeEval = !0 === t({ a: 'b' }, 'a', 'b');
		} catch (t) {
			unsafeEval = !1;
		}
		return unsafeEval;
	}
	var defaultFragment =
			'varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}',
		defaultVertex =
			'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n',
		UID$3 = 0,
		nameCache = {},
		Program = (function () {
			function t(e, i, r) {
				void 0 === r && (r = 'pixi-shader'),
					(this.id = UID$3++),
					(this.vertexSrc = e || t.defaultVertexSrc),
					(this.fragmentSrc = i || t.defaultFragmentSrc),
					(this.vertexSrc = this.vertexSrc.trim()),
					(this.fragmentSrc = this.fragmentSrc.trim()),
					'#version' !== this.vertexSrc.substring(0, 8) &&
						((r = r.replace(/\s+/g, '-')),
						nameCache[r]
							? (nameCache[r]++, (r += '-' + nameCache[r]))
							: (nameCache[r] = 1),
						(this.vertexSrc =
							'#define SHADER_NAME ' + r + '\n' + this.vertexSrc),
						(this.fragmentSrc =
							'#define SHADER_NAME ' + r + '\n' + this.fragmentSrc),
						(this.vertexSrc = setPrecision(
							this.vertexSrc,
							settings.PRECISION_VERTEX,
							PRECISION.HIGH
						)),
						(this.fragmentSrc = setPrecision(
							this.fragmentSrc,
							settings.PRECISION_FRAGMENT,
							getMaxFragmentPrecision()
						))),
					(this.glPrograms = {}),
					(this.syncUniforms = null);
			}
			return (
				Object.defineProperty(t, 'defaultVertexSrc', {
					get: function () {
						return defaultVertex;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t, 'defaultFragmentSrc', {
					get: function () {
						return defaultFragment;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.from = function (e, i, r) {
					var s = e + i,
						n = ProgramCache[s];
					return n || (ProgramCache[s] = n = new t(e, i, r)), n;
				}),
				t
			);
		})(),
		Shader = (function () {
			function t(t, e) {
				(this.uniformBindCount = 0),
					(this.program = t),
					(this.uniformGroup = e
						? e instanceof UniformGroup
							? e
							: new UniformGroup(e)
						: new UniformGroup({}));
			}
			return (
				(t.prototype.checkUniformExists = function (t, e) {
					if (e.uniforms[t]) return !0;
					for (var i in e.uniforms) {
						var r = e.uniforms[i];
						if (r.group && this.checkUniformExists(t, r)) return !0;
					}
					return !1;
				}),
				(t.prototype.destroy = function () {
					this.uniformGroup = null;
				}),
				Object.defineProperty(t.prototype, 'uniforms', {
					get: function () {
						return this.uniformGroup.uniforms;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.from = function (e, i, r) {
					return new t(Program.from(e, i), r);
				}),
				t
			);
		})(),
		BLEND = 0,
		OFFSET = 1,
		CULLING = 2,
		DEPTH_TEST = 3,
		WINDING = 4,
		DEPTH_MASK = 5,
		State = (function () {
			function t() {
				(this.data = 0),
					(this.blendMode = BLEND_MODES.NORMAL),
					(this.polygonOffset = 0),
					(this.blend = !0),
					(this.depthMask = !0);
			}
			return (
				Object.defineProperty(t.prototype, 'blend', {
					get: function () {
						return !!(this.data & (1 << BLEND));
					},
					set: function (t) {
						!!(this.data & (1 << BLEND)) !== t && (this.data ^= 1 << BLEND);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'offsets', {
					get: function () {
						return !!(this.data & (1 << OFFSET));
					},
					set: function (t) {
						!!(this.data & (1 << OFFSET)) !== t && (this.data ^= 1 << OFFSET);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'culling', {
					get: function () {
						return !!(this.data & (1 << CULLING));
					},
					set: function (t) {
						!!(this.data & (1 << CULLING)) !== t && (this.data ^= 1 << CULLING);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'depthTest', {
					get: function () {
						return !!(this.data & (1 << DEPTH_TEST));
					},
					set: function (t) {
						!!(this.data & (1 << DEPTH_TEST)) !== t &&
							(this.data ^= 1 << DEPTH_TEST);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'depthMask', {
					get: function () {
						return !!(this.data & (1 << DEPTH_MASK));
					},
					set: function (t) {
						!!(this.data & (1 << DEPTH_MASK)) !== t &&
							(this.data ^= 1 << DEPTH_MASK);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'clockwiseFrontFace', {
					get: function () {
						return !!(this.data & (1 << WINDING));
					},
					set: function (t) {
						!!(this.data & (1 << WINDING)) !== t && (this.data ^= 1 << WINDING);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'blendMode', {
					get: function () {
						return this._blendMode;
					},
					set: function (t) {
						(this.blend = t !== BLEND_MODES.NONE), (this._blendMode = t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'polygonOffset', {
					get: function () {
						return this._polygonOffset;
					},
					set: function (t) {
						(this.offsets = !!t), (this._polygonOffset = t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.toString = function () {
					return (
						'[@pixi/core:State blendMode=' +
						this.blendMode +
						' clockwiseFrontFace=' +
						this.clockwiseFrontFace +
						' culling=' +
						this.culling +
						' depthMask=' +
						this.depthMask +
						' polygonOffset=' +
						this.polygonOffset +
						']'
					);
				}),
				(t.for2d = function () {
					var e = new t();
					return (e.depthTest = !1), (e.blend = !0), e;
				}),
				t
			);
		})(),
		defaultVertex$1 =
			'attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n',
		defaultFragment$1 =
			'varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n',
		Filter = (function (t) {
			function e(i, r, s) {
				var n = this,
					a = Program.from(i || e.defaultVertexSrc, r || e.defaultFragmentSrc);
				return (
					((n = t.call(this, a, s) || this).padding = 0),
					(n.resolution = settings.FILTER_RESOLUTION),
					(n.multisample = settings.FILTER_MULTISAMPLE),
					(n.enabled = !0),
					(n.autoFit = !0),
					(n.state = new State()),
					n
				);
			}
			return (
				__extends$7(e, t),
				(e.prototype.apply = function (t, e, i, r, s) {
					t.applyFilter(this, e, i, r);
				}),
				Object.defineProperty(e.prototype, 'blendMode', {
					get: function () {
						return this.state.blendMode;
					},
					set: function (t) {
						this.state.blendMode = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'resolution', {
					get: function () {
						return this._resolution;
					},
					set: function (t) {
						this._resolution = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e, 'defaultVertexSrc', {
					get: function () {
						return defaultVertex$1;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e, 'defaultFragmentSrc', {
					get: function () {
						return defaultFragment$1;
					},
					enumerable: !1,
					configurable: !0,
				}),
				e
			);
		})(Shader),
		vertex$7 =
			'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n',
		fragment$7 =
			'varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n',
		tempMat = new Matrix(),
		TextureMatrix = (function () {
			function t(t, e) {
				(this._texture = t),
					(this.mapCoord = new Matrix()),
					(this.uClampFrame = new Float32Array(4)),
					(this.uClampOffset = new Float32Array(2)),
					(this._textureID = -1),
					(this._updateID = 0),
					(this.clampOffset = 0),
					(this.clampMargin = void 0 === e ? 0.5 : e),
					(this.isSimple = !1);
			}
			return (
				Object.defineProperty(t.prototype, 'texture', {
					get: function () {
						return this._texture;
					},
					set: function (t) {
						(this._texture = t), (this._textureID = -1);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.multiplyUvs = function (t, e) {
					void 0 === e && (e = t);
					for (var i = this.mapCoord, r = 0; r < t.length; r += 2) {
						var s = t[r],
							n = t[r + 1];
						(e[r] = s * i.a + n * i.c + i.tx),
							(e[r + 1] = s * i.b + n * i.d + i.ty);
					}
					return e;
				}),
				(t.prototype.update = function (t) {
					var e = this._texture;
					if (!e || !e.valid) return !1;
					if (!t && this._textureID === e._updateID) return !1;
					(this._textureID = e._updateID), this._updateID++;
					var i = e._uvs;
					this.mapCoord.set(
						i.x1 - i.x0,
						i.y1 - i.y0,
						i.x3 - i.x0,
						i.y3 - i.y0,
						i.x0,
						i.y0
					);
					var r = e.orig,
						s = e.trim;
					s &&
						(tempMat.set(
							r.width / s.width,
							0,
							0,
							r.height / s.height,
							-s.x / s.width,
							-s.y / s.height
						),
						this.mapCoord.append(tempMat));
					var n = e.baseTexture,
						a = this.uClampFrame,
						o = this.clampMargin / n.resolution,
						h = this.clampOffset;
					return (
						(a[0] = (e._frame.x + o + h) / n.width),
						(a[1] = (e._frame.y + o + h) / n.height),
						(a[2] = (e._frame.x + e._frame.width - o + h) / n.width),
						(a[3] = (e._frame.y + e._frame.height - o + h) / n.height),
						(this.uClampOffset[0] = h / n.realWidth),
						(this.uClampOffset[1] = h / n.realHeight),
						(this.isSimple =
							e._frame.width === n.width &&
							e._frame.height === n.height &&
							0 === e.rotate),
						!0
					);
				}),
				t
			);
		})(),
		SpriteMaskFilter = (function (t) {
			function e(e, i, r) {
				var s = this,
					n = null;
				return (
					'string' != typeof e &&
						void 0 === i &&
						void 0 === r &&
						((n = e), (e = void 0), (i = void 0), (r = void 0)),
					((s =
						t.call(this, e || vertex$7, i || fragment$7, r) ||
						this).maskSprite = n),
					(s.maskMatrix = new Matrix()),
					s
				);
			}
			return (
				__extends$7(e, t),
				Object.defineProperty(e.prototype, 'maskSprite', {
					get: function () {
						return this._maskSprite;
					},
					set: function (t) {
						(this._maskSprite = t),
							this._maskSprite && (this._maskSprite.renderable = !1);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.apply = function (t, e, i, r) {
					var s = this._maskSprite,
						n = s._texture;
					n.valid &&
						(n.uvMatrix || (n.uvMatrix = new TextureMatrix(n, 0)),
						n.uvMatrix.update(),
						(this.uniforms.npmAlpha = n.baseTexture.alphaMode ? 0 : 1),
						(this.uniforms.mask = n),
						(this.uniforms.otherMatrix = t
							.calculateSpriteMatrix(this.maskMatrix, s)
							.prepend(n.uvMatrix.mapCoord)),
						(this.uniforms.alpha = s.worldAlpha),
						(this.uniforms.maskClamp = n.uvMatrix.uClampFrame),
						t.applyFilter(this, e, i, r));
				}),
				e
			);
		})(Filter),
		MaskSystem = (function () {
			function t(t) {
				(this.renderer = t),
					(this.enableScissor = !0),
					(this.alphaMaskPool = []),
					(this.maskDataPool = []),
					(this.maskStack = []),
					(this.alphaMaskIndex = 0);
			}
			return (
				(t.prototype.setMaskStack = function (t) {
					(this.maskStack = t),
						this.renderer.scissor.setMaskStack(t),
						this.renderer.stencil.setMaskStack(t);
				}),
				(t.prototype.push = function (t, e) {
					var i = e;
					if (!i.isMaskData) {
						var r = this.maskDataPool.pop() || new MaskData();
						(r.pooled = !0), (r.maskObject = e), (i = r);
					}
					var s =
						0 !== this.maskStack.length
							? this.maskStack[this.maskStack.length - 1]
							: null;
					if (
						(i.copyCountersOrReset(s),
						i.autoDetect && this.detect(i),
						(i._target = t),
						i.type !== MASK_TYPES.SPRITE && this.maskStack.push(i),
						i.enabled)
					)
						switch (i.type) {
							case MASK_TYPES.SCISSOR:
								this.renderer.scissor.push(i);
								break;
							case MASK_TYPES.STENCIL:
								this.renderer.stencil.push(i);
								break;
							case MASK_TYPES.SPRITE:
								i.copyCountersOrReset(null), this.pushSpriteMask(i);
						}
					i.type === MASK_TYPES.SPRITE && this.maskStack.push(i);
				}),
				(t.prototype.pop = function (t) {
					var e = this.maskStack.pop();
					if (e && e._target === t) {
						if (e.enabled)
							switch (e.type) {
								case MASK_TYPES.SCISSOR:
									this.renderer.scissor.pop();
									break;
								case MASK_TYPES.STENCIL:
									this.renderer.stencil.pop(e.maskObject);
									break;
								case MASK_TYPES.SPRITE:
									this.popSpriteMask(e);
							}
						if (
							(e.reset(),
							e.pooled && this.maskDataPool.push(e),
							0 !== this.maskStack.length)
						) {
							var i = this.maskStack[this.maskStack.length - 1];
							i.type === MASK_TYPES.SPRITE &&
								i._filters &&
								(i._filters[0].maskSprite = i.maskObject);
						}
					}
				}),
				(t.prototype.detect = function (t) {
					t.maskObject.isSprite
						? (t.type = MASK_TYPES.SPRITE)
						: this.enableScissor && this.renderer.scissor.testScissor(t)
						? (t.type = MASK_TYPES.SCISSOR)
						: (t.type = MASK_TYPES.STENCIL);
				}),
				(t.prototype.pushSpriteMask = function (t) {
					var e,
						i,
						r = t.maskObject,
						s = t._target,
						n = t._filters;
					n ||
						(n = this.alphaMaskPool[this.alphaMaskIndex]) ||
						(n = this.alphaMaskPool[this.alphaMaskIndex] =
							[new SpriteMaskFilter()]);
					var a,
						o,
						h = this.renderer,
						u = h.renderTexture;
					if (u.current) {
						var l = u.current;
						(a = t.resolution || l.resolution),
							(o =
								null !== (e = t.multisample) && void 0 !== e
									? e
									: l.multisample);
					} else
						(a = t.resolution || h.resolution),
							(o =
								null !== (i = t.multisample) && void 0 !== i
									? i
									: h.multisample);
					(n[0].resolution = a), (n[0].multisample = o), (n[0].maskSprite = r);
					var c = s.filterArea;
					(s.filterArea = r.getBounds(!0)),
						h.filter.push(s, n),
						(s.filterArea = c),
						t._filters || this.alphaMaskIndex++;
				}),
				(t.prototype.popSpriteMask = function (t) {
					this.renderer.filter.pop(),
						t._filters
							? (t._filters[0].maskSprite = null)
							: (this.alphaMaskIndex--,
							  (this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null));
				}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})(),
		AbstractMaskSystem = (function () {
			function t(t) {
				(this.renderer = t), (this.maskStack = []), (this.glConst = 0);
			}
			return (
				(t.prototype.getStackLength = function () {
					return this.maskStack.length;
				}),
				(t.prototype.setMaskStack = function (t) {
					var e = this.renderer.gl,
						i = this.getStackLength();
					this.maskStack = t;
					var r = this.getStackLength();
					r !== i &&
						(0 === r
							? e.disable(this.glConst)
							: (e.enable(this.glConst), this._useCurrent()));
				}),
				(t.prototype._useCurrent = function () {}),
				(t.prototype.destroy = function () {
					(this.renderer = null), (this.maskStack = null);
				}),
				t
			);
		})(),
		tempMatrix$1 = new Matrix(),
		ScissorSystem = (function (t) {
			function e(e) {
				var i = t.call(this, e) || this;
				return (i.glConst = WebGLRenderingContext.SCISSOR_TEST), i;
			}
			return (
				__extends$7(e, t),
				(e.prototype.getStackLength = function () {
					var t = this.maskStack[this.maskStack.length - 1];
					return t ? t._scissorCounter : 0;
				}),
				(e.prototype.calcScissorRect = function (t) {
					if (!t._scissorRectLocal) {
						var e = t._scissorRect,
							i = t.maskObject,
							r = this.renderer,
							s = r.renderTexture;
						i.renderable = !0;
						var n = i.getBounds();
						this.roundFrameToPixels(
							n,
							s.current ? s.current.resolution : r.resolution,
							s.sourceFrame,
							s.destinationFrame,
							r.projection.transform
						),
							(i.renderable = !1),
							e && n.fit(e),
							(t._scissorRectLocal = n);
					}
				}),
				(e.isMatrixRotated = function (t) {
					if (!t) return !1;
					var e = t.a,
						i = t.b,
						r = t.c,
						s = t.d;
					return (
						(Math.abs(i) > 1e-4 || Math.abs(r) > 1e-4) &&
						(Math.abs(e) > 1e-4 || Math.abs(s) > 1e-4)
					);
				}),
				(e.prototype.testScissor = function (t) {
					var i = t.maskObject;
					if (!i.isFastRect || !i.isFastRect()) return !1;
					if (e.isMatrixRotated(i.worldTransform)) return !1;
					if (e.isMatrixRotated(this.renderer.projection.transform)) return !1;
					this.calcScissorRect(t);
					var r = t._scissorRectLocal;
					return r.width > 0 && r.height > 0;
				}),
				(e.prototype.roundFrameToPixels = function (t, i, r, s, n) {
					e.isMatrixRotated(n) ||
						((n = n ? tempMatrix$1.copyFrom(n) : tempMatrix$1.identity())
							.translate(-r.x, -r.y)
							.scale(s.width / r.width, s.height / r.height)
							.translate(s.x, s.y),
						this.renderer.filter.transformAABB(n, t),
						t.fit(s),
						(t.x = Math.round(t.x * i)),
						(t.y = Math.round(t.y * i)),
						(t.width = Math.round(t.width * i)),
						(t.height = Math.round(t.height * i)));
				}),
				(e.prototype.push = function (t) {
					t._scissorRectLocal || this.calcScissorRect(t);
					var e = this.renderer.gl;
					t._scissorRect || e.enable(e.SCISSOR_TEST),
						t._scissorCounter++,
						(t._scissorRect = t._scissorRectLocal),
						this._useCurrent();
				}),
				(e.prototype.pop = function () {
					var t = this.renderer.gl;
					this.getStackLength() > 0
						? this._useCurrent()
						: t.disable(t.SCISSOR_TEST);
				}),
				(e.prototype._useCurrent = function () {
					var t,
						e = this.maskStack[this.maskStack.length - 1]._scissorRect;
					(t = this.renderer.renderTexture.current
						? e.y
						: this.renderer.height - e.height - e.y),
						this.renderer.gl.scissor(e.x, t, e.width, e.height);
				}),
				e
			);
		})(AbstractMaskSystem),
		StencilSystem = (function (t) {
			function e(e) {
				var i = t.call(this, e) || this;
				return (i.glConst = WebGLRenderingContext.STENCIL_TEST), i;
			}
			return (
				__extends$7(e, t),
				(e.prototype.getStackLength = function () {
					var t = this.maskStack[this.maskStack.length - 1];
					return t ? t._stencilCounter : 0;
				}),
				(e.prototype.push = function (t) {
					var e = t.maskObject,
						i = this.renderer.gl,
						r = t._stencilCounter;
					0 === r &&
						(this.renderer.framebuffer.forceStencil(),
						i.clearStencil(0),
						i.clear(i.STENCIL_BUFFER_BIT),
						i.enable(i.STENCIL_TEST)),
						t._stencilCounter++,
						i.colorMask(!1, !1, !1, !1),
						i.stencilFunc(i.EQUAL, r, 4294967295),
						i.stencilOp(i.KEEP, i.KEEP, i.INCR),
						(e.renderable = !0),
						e.render(this.renderer),
						this.renderer.batch.flush(),
						(e.renderable = !1),
						this._useCurrent();
				}),
				(e.prototype.pop = function (t) {
					var e = this.renderer.gl;
					0 === this.getStackLength()
						? e.disable(e.STENCIL_TEST)
						: (e.colorMask(!1, !1, !1, !1),
						  e.stencilOp(e.KEEP, e.KEEP, e.DECR),
						  (t.renderable = !0),
						  t.render(this.renderer),
						  this.renderer.batch.flush(),
						  (t.renderable = !1),
						  this._useCurrent());
				}),
				(e.prototype._useCurrent = function () {
					var t = this.renderer.gl;
					t.colorMask(!0, !0, !0, !0),
						t.stencilFunc(t.EQUAL, this.getStackLength(), 4294967295),
						t.stencilOp(t.KEEP, t.KEEP, t.KEEP);
				}),
				e
			);
		})(AbstractMaskSystem),
		ProjectionSystem = (function () {
			function t(t) {
				(this.renderer = t),
					(this.destinationFrame = null),
					(this.sourceFrame = null),
					(this.defaultFrame = null),
					(this.projectionMatrix = new Matrix()),
					(this.transform = null);
			}
			return (
				(t.prototype.update = function (t, e, i, r) {
					(this.destinationFrame =
						t || this.destinationFrame || this.defaultFrame),
						(this.sourceFrame = e || this.sourceFrame || t),
						this.calculateProjection(
							this.destinationFrame,
							this.sourceFrame,
							i,
							r
						),
						this.transform && this.projectionMatrix.append(this.transform);
					var s = this.renderer;
					(s.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix),
						s.globalUniforms.update(),
						s.shader.shader &&
							s.shader.syncUniformGroup(s.shader.shader.uniforms.globals);
				}),
				(t.prototype.calculateProjection = function (t, e, i, r) {
					var s = this.projectionMatrix,
						n = r ? -1 : 1;
					s.identity(),
						(s.a = (1 / e.width) * 2),
						(s.d = n * ((1 / e.height) * 2)),
						(s.tx = -1 - e.x * s.a),
						(s.ty = -n - e.y * s.d);
				}),
				(t.prototype.setTransform = function (t) {}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})(),
		tempRect = new Rectangle$1(),
		tempRect2 = new Rectangle$1(),
		RenderTextureSystem = (function () {
			function t(t) {
				(this.renderer = t),
					(this.clearColor = t._backgroundColorRgba),
					(this.defaultMaskStack = []),
					(this.current = null),
					(this.sourceFrame = new Rectangle$1()),
					(this.destinationFrame = new Rectangle$1()),
					(this.viewportFrame = new Rectangle$1());
			}
			return (
				(t.prototype.bind = function (t, e, i) {
					void 0 === t && (t = null);
					var r,
						s,
						n,
						a = this.renderer;
					(this.current = t),
						t
							? ((n = (r = t.baseTexture).resolution),
							  e ||
									((tempRect.width = t.frame.width),
									(tempRect.height = t.frame.height),
									(e = tempRect)),
							  i ||
									((tempRect2.x = t.frame.x),
									(tempRect2.y = t.frame.y),
									(tempRect2.width = e.width),
									(tempRect2.height = e.height),
									(i = tempRect2)),
							  (s = r.framebuffer))
							: ((n = a.resolution),
							  e ||
									((tempRect.width = a.screen.width),
									(tempRect.height = a.screen.height),
									(e = tempRect)),
							  i || (((i = tempRect).width = e.width), (i.height = e.height)));
					var o = this.viewportFrame;
					(o.x = i.x * n),
						(o.y = i.y * n),
						(o.width = i.width * n),
						(o.height = i.height * n),
						t || (o.y = a.view.height - (o.y + o.height)),
						o.ceil(),
						this.renderer.framebuffer.bind(s, o),
						this.renderer.projection.update(i, e, n, !s),
						t
							? this.renderer.mask.setMaskStack(r.maskStack)
							: this.renderer.mask.setMaskStack(this.defaultMaskStack),
						this.sourceFrame.copyFrom(e),
						this.destinationFrame.copyFrom(i);
				}),
				(t.prototype.clear = function (t, e) {
					t = this.current
						? t || this.current.baseTexture.clearColor
						: t || this.clearColor;
					var i = this.destinationFrame,
						r = this.current ? this.current.baseTexture : this.renderer.screen,
						s = i.width !== r.width || i.height !== r.height;
					if (s) {
						var n = this.viewportFrame,
							a = n.x,
							o = n.y,
							h = n.width,
							u = n.height;
						(a = Math.round(a)),
							(o = Math.round(o)),
							(h = Math.round(h)),
							(u = Math.round(u)),
							this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST),
							this.renderer.gl.scissor(a, o, h, u);
					}
					this.renderer.framebuffer.clear(t[0], t[1], t[2], t[3], e),
						s && this.renderer.scissor.pop();
				}),
				(t.prototype.resize = function () {
					this.bind(null);
				}),
				(t.prototype.reset = function () {
					this.bind(null);
				}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})();
	function uboUpdate(t, e, i, r, s) {
		i.buffer.update(s);
	}
	var UBO_TO_SINGLE_SETTERS = {
			float: '\n        data[offset] = v;\n    ',
			vec2: '\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    ',
			vec3: '\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    ',
			vec4: '\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    ',
			mat2: '\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    ',
			mat3: '\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    ',
			mat4: '\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    ',
		},
		GLSL_TO_STD40_SIZE = {
			float: 4,
			vec2: 8,
			vec3: 12,
			vec4: 16,
			int: 4,
			ivec2: 8,
			ivec3: 12,
			ivec4: 16,
			uint: 4,
			uvec2: 8,
			uvec3: 12,
			uvec4: 16,
			bool: 4,
			bvec2: 8,
			bvec3: 12,
			bvec4: 16,
			mat2: 32,
			mat3: 48,
			mat4: 64,
		};
	function createUBOElements(t) {
		for (
			var e = t.map(function (t) {
					return { data: t, offset: 0, dataLen: 0, dirty: 0 };
				}),
				i = 0,
				r = 0,
				s = 0,
				n = 0;
			n < e.length;
			n++
		) {
			var a = e[n];
			if (
				((i = GLSL_TO_STD40_SIZE[a.data.type]),
				a.data.size > 1 && (i = Math.max(i, 16) * a.data.size),
				(a.dataLen = i),
				r % i != 0 && r < 16)
			) {
				var o = (r % i) % 16;
				(r += o), (s += o);
			}
			r + i > 16
				? ((s = 16 * Math.ceil(s / 16)), (a.offset = s), (s += i), (r = i))
				: ((a.offset = s), (r += i), (s += i));
		}
		return { uboElements: e, size: (s = 16 * Math.ceil(s / 16)) };
	}
	function getUBOData(t, e) {
		var i = [];
		for (var r in t) e[r] && i.push(e[r]);
		return (
			i.sort(function (t, e) {
				return t.index - e.index;
			}),
			i
		);
	}
	function generateUniformBufferSync(t, e) {
		if (!t.autoManage) return { size: 0, syncFunc: uboUpdate };
		for (
			var i = createUBOElements(getUBOData(t.uniforms, e)),
				r = i.uboElements,
				s = i.size,
				n = [
					'\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    ',
				],
				a = 0;
			a < r.length;
			a++
		) {
			for (
				var o = r[a],
					h = t.uniforms[o.data.name],
					u = o.data.name,
					l = !1,
					c = 0;
				c < uniformParsers.length;
				c++
			) {
				var d = uniformParsers[c];
				if (d.codeUbo && d.test(o.data, h)) {
					n.push(
						'offset = ' + o.offset / 4 + ';',
						uniformParsers[c].codeUbo(o.data.name, h)
					),
						(l = !0);
					break;
				}
			}
			if (!l)
				if (o.data.size > 1) {
					var p = mapSize(o.data.type),
						f = Math.max(GLSL_TO_STD40_SIZE[o.data.type] / 16, 1),
						m = p / f,
						_ = (4 - (m % 4)) % 4;
					n.push(
						'\n                cv = ud.' +
							u +
							'.value;\n                v = uv.' +
							u +
							';\n                offset = ' +
							o.offset / 4 +
							';\n\n                t = 0;\n\n                for(var i=0; i < ' +
							o.data.size * f +
							'; i++)\n                {\n                    for(var j = 0; j < ' +
							m +
							'; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += ' +
							_ +
							';\n                }\n\n                '
					);
				} else {
					var g = UBO_TO_SINGLE_SETTERS[o.data.type];
					n.push(
						'\n                cv = ud.' +
							u +
							'.value;\n                v = uv.' +
							u +
							';\n                offset = ' +
							o.offset / 4 +
							';\n                ' +
							g +
							';\n                '
					);
				}
		}
		return (
			n.push('\n       renderer.buffer.update(buffer);\n    '),
			{
				size: s,
				syncFunc: new Function(
					'ud',
					'uv',
					'renderer',
					'syncData',
					'buffer',
					n.join('\n')
				),
			}
		);
	}
	var GLProgram = (function () {
		function t(t, e) {
			(this.program = t),
				(this.uniformData = e),
				(this.uniformGroups = {}),
				(this.uniformDirtyGroups = {}),
				(this.uniformBufferBindings = {});
		}
		return (
			(t.prototype.destroy = function () {
				(this.uniformData = null),
					(this.uniformGroups = null),
					(this.uniformDirtyGroups = null),
					(this.uniformBufferBindings = null),
					(this.program = null);
			}),
			t
		);
	})();
	function getAttributeData(t, e) {
		for (
			var i = {}, r = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES), s = 0;
			s < r;
			s++
		) {
			var n = e.getActiveAttrib(t, s);
			if (0 !== n.name.indexOf('gl_')) {
				var a = mapType(e, n.type),
					o = {
						type: a,
						name: n.name,
						size: mapSize(a),
						location: e.getAttribLocation(t, n.name),
					};
				i[n.name] = o;
			}
		}
		return i;
	}
	function getUniformData(t, e) {
		for (
			var i = {}, r = e.getProgramParameter(t, e.ACTIVE_UNIFORMS), s = 0;
			s < r;
			s++
		) {
			var n = e.getActiveUniform(t, s),
				a = n.name.replace(/\[.*?\]$/, ''),
				o = !!n.name.match(/\[.*?\]$/),
				h = mapType(e, n.type);
			i[a] = {
				name: a,
				index: s,
				type: h,
				size: n.size,
				isArray: o,
				value: defaultValue(h, n.size),
			};
		}
		return i;
	}
	function generateProgram(t, e) {
		var i = compileShader(t, t.VERTEX_SHADER, e.vertexSrc),
			r = compileShader(t, t.FRAGMENT_SHADER, e.fragmentSrc),
			s = t.createProgram();
		if (
			(t.attachShader(s, i),
			t.attachShader(s, r),
			t.linkProgram(s),
			t.getProgramParameter(s, t.LINK_STATUS) || logProgramError(t, s, i, r),
			(e.attributeData = getAttributeData(s, t)),
			(e.uniformData = getUniformData(s, t)),
			!/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e.vertexSrc))
		) {
			var n = Object.keys(e.attributeData);
			n.sort(function (t, e) {
				return t > e ? 1 : -1;
			});
			for (var a = 0; a < n.length; a++)
				(e.attributeData[n[a]].location = a), t.bindAttribLocation(s, a, n[a]);
			t.linkProgram(s);
		}
		t.deleteShader(i), t.deleteShader(r);
		var o = {};
		for (var a in e.uniformData) {
			var h = e.uniformData[a];
			o[a] = {
				location: t.getUniformLocation(s, a),
				value: defaultValue(h.type, h.size),
			};
		}
		return new GLProgram(s, o);
	}
	var UID$4 = 0,
		defaultSyncData = { textureCount: 0, uboCount: 0 },
		ShaderSystem = (function () {
			function t(t) {
				(this.destroyed = !1),
					(this.renderer = t),
					this.systemCheck(),
					(this.gl = null),
					(this.shader = null),
					(this.program = null),
					(this.cache = {}),
					(this._uboCache = {}),
					(this.id = UID$4++);
			}
			return (
				(t.prototype.systemCheck = function () {
					if (!unsafeEvalSupported())
						throw new Error(
							'Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.'
						);
				}),
				(t.prototype.contextChange = function (t) {
					(this.gl = t), this.reset();
				}),
				(t.prototype.bind = function (t, e) {
					t.uniforms.globals = this.renderer.globalUniforms;
					var i = t.program,
						r =
							i.glPrograms[this.renderer.CONTEXT_UID] ||
							this.generateProgram(t);
					return (
						(this.shader = t),
						this.program !== i &&
							((this.program = i), this.gl.useProgram(r.program)),
						e ||
							((defaultSyncData.textureCount = 0),
							(defaultSyncData.uboCount = 0),
							this.syncUniformGroup(t.uniformGroup, defaultSyncData)),
						r
					);
				}),
				(t.prototype.setUniforms = function (t) {
					var e = this.shader.program,
						i = e.glPrograms[this.renderer.CONTEXT_UID];
					e.syncUniforms(i.uniformData, t, this.renderer);
				}),
				(t.prototype.syncUniformGroup = function (t, e) {
					var i = this.getGlProgram();
					(t.static && t.dirtyId === i.uniformDirtyGroups[t.id]) ||
						((i.uniformDirtyGroups[t.id] = t.dirtyId),
						this.syncUniforms(t, i, e));
				}),
				(t.prototype.syncUniforms = function (t, e, i) {
					(t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t))(
						e.uniformData,
						t.uniforms,
						this.renderer,
						i
					);
				}),
				(t.prototype.createSyncGroups = function (t) {
					var e = this.getSignature(t, this.shader.program.uniformData, 'u');
					return (
						this.cache[e] ||
							(this.cache[e] = generateUniformsSync(
								t,
								this.shader.program.uniformData
							)),
						(t.syncUniforms[this.shader.program.id] = this.cache[e]),
						t.syncUniforms[this.shader.program.id]
					);
				}),
				(t.prototype.syncUniformBufferGroup = function (t, e) {
					var i = this.getGlProgram();
					if (!t.static || 0 !== t.dirtyId || !i.uniformGroups[t.id]) {
						t.dirtyId = 0;
						var r =
							i.uniformGroups[t.id] || this.createSyncBufferGroup(t, i, e);
						t.buffer.update(),
							r(
								i.uniformData,
								t.uniforms,
								this.renderer,
								defaultSyncData,
								t.buffer
							);
					}
					this.renderer.buffer.bindBufferBase(
						t.buffer,
						i.uniformBufferBindings[e]
					);
				}),
				(t.prototype.createSyncBufferGroup = function (t, e, i) {
					var r = this.renderer.gl;
					this.renderer.buffer.bind(t.buffer);
					var s = this.gl.getUniformBlockIndex(e.program, i);
					(e.uniformBufferBindings[i] = this.shader.uniformBindCount),
						r.uniformBlockBinding(e.program, s, this.shader.uniformBindCount),
						this.shader.uniformBindCount++;
					var n = this.getSignature(t, this.shader.program.uniformData, 'ubo'),
						a = this._uboCache[n];
					if (
						(a ||
							(a = this._uboCache[n] =
								generateUniformBufferSync(t, this.shader.program.uniformData)),
						t.autoManage)
					) {
						var o = new Float32Array(a.size / 4);
						t.buffer.update(o);
					}
					return (e.uniformGroups[t.id] = a.syncFunc), e.uniformGroups[t.id];
				}),
				(t.prototype.getSignature = function (t, e, i) {
					var r = t.uniforms,
						s = [i + '-'];
					for (var n in r) s.push(n), e[n] && s.push(e[n].type);
					return s.join('-');
				}),
				(t.prototype.getGlProgram = function () {
					return this.shader
						? this.shader.program.glPrograms[this.renderer.CONTEXT_UID]
						: null;
				}),
				(t.prototype.generateProgram = function (t) {
					var e = this.gl,
						i = t.program,
						r = generateProgram(e, i);
					return (i.glPrograms[this.renderer.CONTEXT_UID] = r), r;
				}),
				(t.prototype.reset = function () {
					(this.program = null), (this.shader = null);
				}),
				(t.prototype.destroy = function () {
					(this.renderer = null), (this.destroyed = !0);
				}),
				t
			);
		})();
	function mapWebGLBlendModesToPixi(t, e) {
		return (
			void 0 === e && (e = []),
			(e[BLEND_MODES.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES.ADD] = [t.ONE, t.ONE]),
			(e[BLEND_MODES.MULTIPLY] = [
				t.DST_COLOR,
				t.ONE_MINUS_SRC_ALPHA,
				t.ONE,
				t.ONE_MINUS_SRC_ALPHA,
			]),
			(e[BLEND_MODES.SCREEN] = [
				t.ONE,
				t.ONE_MINUS_SRC_COLOR,
				t.ONE,
				t.ONE_MINUS_SRC_ALPHA,
			]),
			(e[BLEND_MODES.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES.NONE] = [0, 0]),
			(e[BLEND_MODES.NORMAL_NPM] = [
				t.SRC_ALPHA,
				t.ONE_MINUS_SRC_ALPHA,
				t.ONE,
				t.ONE_MINUS_SRC_ALPHA,
			]),
			(e[BLEND_MODES.ADD_NPM] = [t.SRC_ALPHA, t.ONE, t.ONE, t.ONE]),
			(e[BLEND_MODES.SCREEN_NPM] = [
				t.SRC_ALPHA,
				t.ONE_MINUS_SRC_COLOR,
				t.ONE,
				t.ONE_MINUS_SRC_ALPHA,
			]),
			(e[BLEND_MODES.SRC_IN] = [t.DST_ALPHA, t.ZERO]),
			(e[BLEND_MODES.SRC_OUT] = [t.ONE_MINUS_DST_ALPHA, t.ZERO]),
			(e[BLEND_MODES.SRC_ATOP] = [t.DST_ALPHA, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES.DST_OVER] = [t.ONE_MINUS_DST_ALPHA, t.ONE]),
			(e[BLEND_MODES.DST_IN] = [t.ZERO, t.SRC_ALPHA]),
			(e[BLEND_MODES.DST_OUT] = [t.ZERO, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES.DST_ATOP] = [t.ONE_MINUS_DST_ALPHA, t.SRC_ALPHA]),
			(e[BLEND_MODES.XOR] = [t.ONE_MINUS_DST_ALPHA, t.ONE_MINUS_SRC_ALPHA]),
			(e[BLEND_MODES.SUBTRACT] = [
				t.ONE,
				t.ONE,
				t.ONE,
				t.ONE,
				t.FUNC_REVERSE_SUBTRACT,
				t.FUNC_ADD,
			]),
			e
		);
	}
	var BLEND$1 = 0,
		OFFSET$1 = 1,
		CULLING$1 = 2,
		DEPTH_TEST$1 = 3,
		WINDING$1 = 4,
		DEPTH_MASK$1 = 5,
		StateSystem = (function () {
			function t() {
				(this.gl = null),
					(this.stateId = 0),
					(this.polygonOffset = 0),
					(this.blendMode = BLEND_MODES.NONE),
					(this._blendEq = !1),
					(this.map = []),
					(this.map[BLEND$1] = this.setBlend),
					(this.map[OFFSET$1] = this.setOffset),
					(this.map[CULLING$1] = this.setCullFace),
					(this.map[DEPTH_TEST$1] = this.setDepthTest),
					(this.map[WINDING$1] = this.setFrontFace),
					(this.map[DEPTH_MASK$1] = this.setDepthMask),
					(this.checks = []),
					(this.defaultState = new State()),
					(this.defaultState.blend = !0);
			}
			return (
				(t.prototype.contextChange = function (t) {
					(this.gl = t),
						(this.blendModes = mapWebGLBlendModesToPixi(t)),
						this.set(this.defaultState),
						this.reset();
				}),
				(t.prototype.set = function (t) {
					if (((t = t || this.defaultState), this.stateId !== t.data)) {
						for (var e = this.stateId ^ t.data, i = 0; e; )
							1 & e && this.map[i].call(this, !!(t.data & (1 << i))),
								(e >>= 1),
								i++;
						this.stateId = t.data;
					}
					for (i = 0; i < this.checks.length; i++) this.checks[i](this, t);
				}),
				(t.prototype.forceState = function (t) {
					t = t || this.defaultState;
					for (var e = 0; e < this.map.length; e++)
						this.map[e].call(this, !!(t.data & (1 << e)));
					for (e = 0; e < this.checks.length; e++) this.checks[e](this, t);
					this.stateId = t.data;
				}),
				(t.prototype.setBlend = function (e) {
					this.updateCheck(t.checkBlendMode, e),
						this.gl[e ? 'enable' : 'disable'](this.gl.BLEND);
				}),
				(t.prototype.setOffset = function (e) {
					this.updateCheck(t.checkPolygonOffset, e),
						this.gl[e ? 'enable' : 'disable'](this.gl.POLYGON_OFFSET_FILL);
				}),
				(t.prototype.setDepthTest = function (t) {
					this.gl[t ? 'enable' : 'disable'](this.gl.DEPTH_TEST);
				}),
				(t.prototype.setDepthMask = function (t) {
					this.gl.depthMask(t);
				}),
				(t.prototype.setCullFace = function (t) {
					this.gl[t ? 'enable' : 'disable'](this.gl.CULL_FACE);
				}),
				(t.prototype.setFrontFace = function (t) {
					this.gl.frontFace(this.gl[t ? 'CW' : 'CCW']);
				}),
				(t.prototype.setBlendMode = function (t) {
					if (t !== this.blendMode) {
						this.blendMode = t;
						var e = this.blendModes[t],
							i = this.gl;
						2 === e.length
							? i.blendFunc(e[0], e[1])
							: i.blendFuncSeparate(e[0], e[1], e[2], e[3]),
							6 === e.length
								? ((this._blendEq = !0), i.blendEquationSeparate(e[4], e[5]))
								: this._blendEq &&
								  ((this._blendEq = !1),
								  i.blendEquationSeparate(i.FUNC_ADD, i.FUNC_ADD));
					}
				}),
				(t.prototype.setPolygonOffset = function (t, e) {
					this.gl.polygonOffset(t, e);
				}),
				(t.prototype.reset = function () {
					this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1),
						this.forceState(this.defaultState),
						(this._blendEq = !0),
						(this.blendMode = -1),
						this.setBlendMode(0);
				}),
				(t.prototype.updateCheck = function (t, e) {
					var i = this.checks.indexOf(t);
					e && -1 === i
						? this.checks.push(t)
						: e || -1 === i || this.checks.splice(i, 1);
				}),
				(t.checkBlendMode = function (t, e) {
					t.setBlendMode(e.blendMode);
				}),
				(t.checkPolygonOffset = function (t, e) {
					t.setPolygonOffset(1, e.polygonOffset);
				}),
				(t.prototype.destroy = function () {
					this.gl = null;
				}),
				t
			);
		})(),
		TextureGCSystem = (function () {
			function t(t) {
				(this.renderer = t),
					(this.count = 0),
					(this.checkCount = 0),
					(this.maxIdle = settings.GC_MAX_IDLE),
					(this.checkCountMax = settings.GC_MAX_CHECK_COUNT),
					(this.mode = settings.GC_MODE);
			}
			return (
				(t.prototype.postrender = function () {
					this.renderer.renderingToScreen &&
						(this.count++,
						this.mode !== GC_MODES.MANUAL &&
							(this.checkCount++,
							this.checkCount > this.checkCountMax &&
								((this.checkCount = 0), this.run())));
				}),
				(t.prototype.run = function () {
					for (
						var t = this.renderer.texture, e = t.managedTextures, i = !1, r = 0;
						r < e.length;
						r++
					) {
						var s = e[r];
						!s.framebuffer &&
							this.count - s.touched > this.maxIdle &&
							(t.destroyTexture(s, !0), (e[r] = null), (i = !0));
					}
					if (i) {
						var n = 0;
						for (r = 0; r < e.length; r++) null !== e[r] && (e[n++] = e[r]);
						e.length = n;
					}
				}),
				(t.prototype.unload = function (t) {
					var e = this.renderer.texture,
						i = t._texture;
					i && !i.framebuffer && e.destroyTexture(i);
					for (var r = t.children.length - 1; r >= 0; r--)
						this.unload(t.children[r]);
				}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})();
	function mapTypeAndFormatToInternalFormat(t) {
		var e, i, r, s, n, a, o, h, u, l, c, d, p, f, m, _, g, E, y, T, v, S, x;
		return (
			'WebGL2RenderingContext' in self &&
			t instanceof self.WebGL2RenderingContext
				? (((e = {})[TYPES.UNSIGNED_BYTE] =
						(((i = {})[FORMATS.RGBA] = t.RGBA8),
						(i[FORMATS.RGB] = t.RGB8),
						(i[FORMATS.RG] = t.RG8),
						(i[FORMATS.RED] = t.R8),
						(i[FORMATS.RGBA_INTEGER] = t.RGBA8UI),
						(i[FORMATS.RGB_INTEGER] = t.RGB8UI),
						(i[FORMATS.RG_INTEGER] = t.RG8UI),
						(i[FORMATS.RED_INTEGER] = t.R8UI),
						(i[FORMATS.ALPHA] = t.ALPHA),
						(i[FORMATS.LUMINANCE] = t.LUMINANCE),
						(i[FORMATS.LUMINANCE_ALPHA] = t.LUMINANCE_ALPHA),
						i)),
				  (e[TYPES.BYTE] =
						(((r = {})[FORMATS.RGBA] = t.RGBA8_SNORM),
						(r[FORMATS.RGB] = t.RGB8_SNORM),
						(r[FORMATS.RG] = t.RG8_SNORM),
						(r[FORMATS.RED] = t.R8_SNORM),
						(r[FORMATS.RGBA_INTEGER] = t.RGBA8I),
						(r[FORMATS.RGB_INTEGER] = t.RGB8I),
						(r[FORMATS.RG_INTEGER] = t.RG8I),
						(r[FORMATS.RED_INTEGER] = t.R8I),
						r)),
				  (e[TYPES.UNSIGNED_SHORT] =
						(((s = {})[FORMATS.RGBA_INTEGER] = t.RGBA16UI),
						(s[FORMATS.RGB_INTEGER] = t.RGB16UI),
						(s[FORMATS.RG_INTEGER] = t.RG16UI),
						(s[FORMATS.RED_INTEGER] = t.R16UI),
						(s[FORMATS.DEPTH_COMPONENT] = t.DEPTH_COMPONENT16),
						s)),
				  (e[TYPES.SHORT] =
						(((n = {})[FORMATS.RGBA_INTEGER] = t.RGBA16I),
						(n[FORMATS.RGB_INTEGER] = t.RGB16I),
						(n[FORMATS.RG_INTEGER] = t.RG16I),
						(n[FORMATS.RED_INTEGER] = t.R16I),
						n)),
				  (e[TYPES.UNSIGNED_INT] =
						(((a = {})[FORMATS.RGBA_INTEGER] = t.RGBA32UI),
						(a[FORMATS.RGB_INTEGER] = t.RGB32UI),
						(a[FORMATS.RG_INTEGER] = t.RG32UI),
						(a[FORMATS.RED_INTEGER] = t.R32UI),
						(a[FORMATS.DEPTH_COMPONENT] = t.DEPTH_COMPONENT24),
						a)),
				  (e[TYPES.INT] =
						(((o = {})[FORMATS.RGBA_INTEGER] = t.RGBA32I),
						(o[FORMATS.RGB_INTEGER] = t.RGB32I),
						(o[FORMATS.RG_INTEGER] = t.RG32I),
						(o[FORMATS.RED_INTEGER] = t.R32I),
						o)),
				  (e[TYPES.FLOAT] =
						(((h = {})[FORMATS.RGBA] = t.RGBA32F),
						(h[FORMATS.RGB] = t.RGB32F),
						(h[FORMATS.RG] = t.RG32F),
						(h[FORMATS.RED] = t.R32F),
						(h[FORMATS.DEPTH_COMPONENT] = t.DEPTH_COMPONENT32F),
						h)),
				  (e[TYPES.HALF_FLOAT] =
						(((u = {})[FORMATS.RGBA] = t.RGBA16F),
						(u[FORMATS.RGB] = t.RGB16F),
						(u[FORMATS.RG] = t.RG16F),
						(u[FORMATS.RED] = t.R16F),
						u)),
				  (e[TYPES.UNSIGNED_SHORT_5_6_5] =
						(((l = {})[FORMATS.RGB] = t.RGB565), l)),
				  (e[TYPES.UNSIGNED_SHORT_4_4_4_4] =
						(((c = {})[FORMATS.RGBA] = t.RGBA4), c)),
				  (e[TYPES.UNSIGNED_SHORT_5_5_5_1] =
						(((d = {})[FORMATS.RGBA] = t.RGB5_A1), d)),
				  (e[TYPES.UNSIGNED_INT_2_10_10_10_REV] =
						(((p = {})[FORMATS.RGBA] = t.RGB10_A2),
						(p[FORMATS.RGBA_INTEGER] = t.RGB10_A2UI),
						p)),
				  (e[TYPES.UNSIGNED_INT_10F_11F_11F_REV] =
						(((f = {})[FORMATS.RGB] = t.R11F_G11F_B10F), f)),
				  (e[TYPES.UNSIGNED_INT_5_9_9_9_REV] =
						(((m = {})[FORMATS.RGB] = t.RGB9_E5), m)),
				  (e[TYPES.UNSIGNED_INT_24_8] =
						(((_ = {})[FORMATS.DEPTH_STENCIL] = t.DEPTH24_STENCIL8), _)),
				  (e[TYPES.FLOAT_32_UNSIGNED_INT_24_8_REV] =
						(((g = {})[FORMATS.DEPTH_STENCIL] = t.DEPTH32F_STENCIL8), g)),
				  (x = e))
				: (((E = {})[TYPES.UNSIGNED_BYTE] =
						(((y = {})[FORMATS.RGBA] = t.RGBA),
						(y[FORMATS.RGB] = t.RGB),
						(y[FORMATS.ALPHA] = t.ALPHA),
						(y[FORMATS.LUMINANCE] = t.LUMINANCE),
						(y[FORMATS.LUMINANCE_ALPHA] = t.LUMINANCE_ALPHA),
						y)),
				  (E[TYPES.UNSIGNED_SHORT_5_6_5] =
						(((T = {})[FORMATS.RGB] = t.RGB), T)),
				  (E[TYPES.UNSIGNED_SHORT_4_4_4_4] =
						(((v = {})[FORMATS.RGBA] = t.RGBA), v)),
				  (E[TYPES.UNSIGNED_SHORT_5_5_5_1] =
						(((S = {})[FORMATS.RGBA] = t.RGBA), S)),
				  (x = E)),
			x
		);
	}
	var GLTexture = function (t) {
			(this.texture = t),
				(this.width = -1),
				(this.height = -1),
				(this.dirtyId = -1),
				(this.dirtyStyleId = -1),
				(this.mipmap = !1),
				(this.wrapMode = 33071),
				(this.type = TYPES.UNSIGNED_BYTE),
				(this.internalFormat = FORMATS.RGBA),
				(this.samplerType = 0);
		},
		TextureSystem = (function () {
			function t(t) {
				(this.renderer = t),
					(this.boundTextures = []),
					(this.currentLocation = -1),
					(this.managedTextures = []),
					(this._unknownBoundTextures = !1),
					(this.unknownTexture = new BaseTexture()),
					(this.hasIntegerTextures = !1);
			}
			return (
				(t.prototype.contextChange = function () {
					var t = (this.gl = this.renderer.gl);
					(this.CONTEXT_UID = this.renderer.CONTEXT_UID),
						(this.webGLVersion = this.renderer.context.webGLVersion),
						(this.internalFormats = mapTypeAndFormatToInternalFormat(t));
					var e = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
					this.boundTextures.length = e;
					for (var i = 0; i < e; i++) this.boundTextures[i] = null;
					this.emptyTextures = {};
					var r = new GLTexture(t.createTexture());
					for (
						t.bindTexture(t.TEXTURE_2D, r.texture),
							t.texImage2D(
								t.TEXTURE_2D,
								0,
								t.RGBA,
								1,
								1,
								0,
								t.RGBA,
								t.UNSIGNED_BYTE,
								new Uint8Array(4)
							),
							this.emptyTextures[t.TEXTURE_2D] = r,
							this.emptyTextures[t.TEXTURE_CUBE_MAP] = new GLTexture(
								t.createTexture()
							),
							t.bindTexture(
								t.TEXTURE_CUBE_MAP,
								this.emptyTextures[t.TEXTURE_CUBE_MAP].texture
							),
							i = 0;
						i < 6;
						i++
					)
						t.texImage2D(
							t.TEXTURE_CUBE_MAP_POSITIVE_X + i,
							0,
							t.RGBA,
							1,
							1,
							0,
							t.RGBA,
							t.UNSIGNED_BYTE,
							null
						);
					for (
						t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR),
							t.texParameteri(
								t.TEXTURE_CUBE_MAP,
								t.TEXTURE_MIN_FILTER,
								t.LINEAR
							),
							i = 0;
						i < this.boundTextures.length;
						i++
					)
						this.bind(null, i);
				}),
				(t.prototype.bind = function (t, e) {
					void 0 === e && (e = 0);
					var i = this.gl;
					if (
						(t = null == t ? void 0 : t.castToBaseTexture()) &&
						t.valid &&
						!t.parentTextureArray
					) {
						t.touched = this.renderer.textureGC.count;
						var r = t._glTextures[this.CONTEXT_UID] || this.initTexture(t);
						this.boundTextures[e] !== t &&
							(this.currentLocation !== e &&
								((this.currentLocation = e), i.activeTexture(i.TEXTURE0 + e)),
							i.bindTexture(t.target, r.texture)),
							r.dirtyId !== t.dirtyId &&
								(this.currentLocation !== e &&
									((this.currentLocation = e), i.activeTexture(i.TEXTURE0 + e)),
								this.updateTexture(t)),
							(this.boundTextures[e] = t);
					} else
						this.currentLocation !== e &&
							((this.currentLocation = e), i.activeTexture(i.TEXTURE0 + e)),
							i.bindTexture(
								i.TEXTURE_2D,
								this.emptyTextures[i.TEXTURE_2D].texture
							),
							(this.boundTextures[e] = null);
				}),
				(t.prototype.reset = function () {
					(this._unknownBoundTextures = !0),
						(this.hasIntegerTextures = !1),
						(this.currentLocation = -1);
					for (var t = 0; t < this.boundTextures.length; t++)
						this.boundTextures[t] = this.unknownTexture;
				}),
				(t.prototype.unbind = function (t) {
					var e = this.gl,
						i = this.boundTextures;
					if (this._unknownBoundTextures) {
						this._unknownBoundTextures = !1;
						for (var r = 0; r < i.length; r++)
							i[r] === this.unknownTexture && this.bind(null, r);
					}
					for (r = 0; r < i.length; r++)
						i[r] === t &&
							(this.currentLocation !== r &&
								(e.activeTexture(e.TEXTURE0 + r), (this.currentLocation = r)),
							e.bindTexture(t.target, this.emptyTextures[t.target].texture),
							(i[r] = null));
				}),
				(t.prototype.ensureSamplerType = function (t) {
					var e = this,
						i = e.boundTextures,
						r = e.hasIntegerTextures,
						s = e.CONTEXT_UID;
					if (r)
						for (var n = t - 1; n >= 0; --n) {
							var a = i[n];
							a &&
								a._glTextures[s].samplerType !== SAMPLER_TYPES.FLOAT &&
								this.renderer.texture.unbind(a);
						}
				}),
				(t.prototype.initTexture = function (t) {
					var e = new GLTexture(this.gl.createTexture());
					return (
						(e.dirtyId = -1),
						(t._glTextures[this.CONTEXT_UID] = e),
						this.managedTextures.push(t),
						t.on('dispose', this.destroyTexture, this),
						e
					);
				}),
				(t.prototype.initTextureType = function (t, e) {
					var i, r;
					(e.internalFormat =
						null !==
							(r =
								null === (i = this.internalFormats[t.type]) || void 0 === i
									? void 0
									: i[t.format]) && void 0 !== r
							? r
							: t.format),
						2 === this.webGLVersion && t.type === TYPES.HALF_FLOAT
							? (e.type = this.gl.HALF_FLOAT)
							: (e.type = t.type);
				}),
				(t.prototype.updateTexture = function (t) {
					var e = t._glTextures[this.CONTEXT_UID];
					if (e) {
						var i = this.renderer;
						if (
							(this.initTextureType(t, e),
							t.resource && t.resource.upload(i, t, e))
						)
							e.samplerType !== SAMPLER_TYPES.FLOAT &&
								(this.hasIntegerTextures = !0);
						else {
							var r = t.realWidth,
								s = t.realHeight,
								n = i.gl;
							(e.width !== r || e.height !== s || e.dirtyId < 0) &&
								((e.width = r),
								(e.height = s),
								n.texImage2D(
									t.target,
									0,
									e.internalFormat,
									r,
									s,
									0,
									t.format,
									e.type,
									null
								));
						}
						t.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(t),
							(e.dirtyId = t.dirtyId);
					}
				}),
				(t.prototype.destroyTexture = function (t, e) {
					var i = this.gl;
					if (
						(t = t.castToBaseTexture())._glTextures[this.CONTEXT_UID] &&
						(this.unbind(t),
						i.deleteTexture(t._glTextures[this.CONTEXT_UID].texture),
						t.off('dispose', this.destroyTexture, this),
						delete t._glTextures[this.CONTEXT_UID],
						!e)
					) {
						var r = this.managedTextures.indexOf(t);
						-1 !== r && removeItems(this.managedTextures, r, 1);
					}
				}),
				(t.prototype.updateTextureStyle = function (t) {
					var e = t._glTextures[this.CONTEXT_UID];
					e &&
						((t.mipmap !== MIPMAP_MODES.POW2 && 2 === this.webGLVersion) ||
						t.isPowerOfTwo
							? (e.mipmap = t.mipmap >= 1)
							: (e.mipmap = !1),
						2 === this.webGLVersion || t.isPowerOfTwo
							? (e.wrapMode = t.wrapMode)
							: (e.wrapMode = WRAP_MODES.CLAMP),
						(t.resource && t.resource.style(this.renderer, t, e)) ||
							this.setStyle(t, e),
						(e.dirtyStyleId = t.dirtyStyleId));
				}),
				(t.prototype.setStyle = function (t, e) {
					var i = this.gl;
					if (
						(e.mipmap &&
							t.mipmap !== MIPMAP_MODES.ON_MANUAL &&
							i.generateMipmap(t.target),
						i.texParameteri(t.target, i.TEXTURE_WRAP_S, e.wrapMode),
						i.texParameteri(t.target, i.TEXTURE_WRAP_T, e.wrapMode),
						e.mipmap)
					) {
						i.texParameteri(
							t.target,
							i.TEXTURE_MIN_FILTER,
							t.scaleMode === SCALE_MODES.LINEAR
								? i.LINEAR_MIPMAP_LINEAR
								: i.NEAREST_MIPMAP_NEAREST
						);
						var r = this.renderer.context.extensions.anisotropicFiltering;
						if (
							r &&
							t.anisotropicLevel > 0 &&
							t.scaleMode === SCALE_MODES.LINEAR
						) {
							var s = Math.min(
								t.anisotropicLevel,
								i.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
							);
							i.texParameterf(t.target, r.TEXTURE_MAX_ANISOTROPY_EXT, s);
						}
					} else
						i.texParameteri(
							t.target,
							i.TEXTURE_MIN_FILTER,
							t.scaleMode === SCALE_MODES.LINEAR ? i.LINEAR : i.NEAREST
						);
					i.texParameteri(
						t.target,
						i.TEXTURE_MAG_FILTER,
						t.scaleMode === SCALE_MODES.LINEAR ? i.LINEAR : i.NEAREST
					);
				}),
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				t
			);
		})(),
		tempMatrix$2 = new Matrix(),
		AbstractRenderer = (function (t) {
			function e(e, i) {
				void 0 === e && (e = RENDERER_TYPE.UNKNOWN);
				var r = t.call(this) || this;
				return (
					(i = Object.assign({}, settings.RENDER_OPTIONS, i)),
					(r.options = i),
					(r.type = e),
					(r.screen = new Rectangle$1(0, 0, i.width, i.height)),
					(r.view = i.view || document.createElement('canvas')),
					(r.resolution = i.resolution || settings.RESOLUTION),
					(r.useContextAlpha = i.useContextAlpha),
					(r.autoDensity = !!i.autoDensity),
					(r.preserveDrawingBuffer = i.preserveDrawingBuffer),
					(r.clearBeforeRender = i.clearBeforeRender),
					(r._backgroundColor = 0),
					(r._backgroundColorRgba = [0, 0, 0, 1]),
					(r._backgroundColorString = '#000000'),
					(r.backgroundColor = i.backgroundColor || r._backgroundColor),
					(r.backgroundAlpha = i.backgroundAlpha),
					void 0 !== i.transparent &&
						(deprecation(
							'6.0.0',
							'Option transparent is deprecated, please use backgroundAlpha instead.'
						),
						(r.useContextAlpha = i.transparent),
						(r.backgroundAlpha = i.transparent ? 0 : 1)),
					(r._lastObjectRendered = null),
					(r.plugins = {}),
					r
				);
			}
			return (
				__extends$7(e, t),
				(e.prototype.initPlugins = function (t) {
					for (var e in t) this.plugins[e] = new t[e](this);
				}),
				Object.defineProperty(e.prototype, 'width', {
					get: function () {
						return this.view.width;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'height', {
					get: function () {
						return this.view.height;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.resize = function (t, e) {
					(this.view.width = Math.round(t * this.resolution)),
						(this.view.height = Math.round(e * this.resolution));
					var i = this.view.width / this.resolution,
						r = this.view.height / this.resolution;
					(this.screen.width = i),
						(this.screen.height = r),
						this.autoDensity &&
							((this.view.style.width = i + 'px'),
							(this.view.style.height = r + 'px')),
						this.emit('resize', i, r);
				}),
				(e.prototype.generateTexture = function (t, e, i, r) {
					void 0 === e && (e = {}),
						'number' == typeof e &&
							(deprecation(
								'6.1.0',
								'generateTexture options (scaleMode, resolution, region) are now object options.'
							),
							(e = { scaleMode: e, resolution: i, region: r }));
					var s = e.region,
						n = __rest(e, ['region']);
					0 === (r = s || t.getLocalBounds(null, !0)).width && (r.width = 1),
						0 === r.height && (r.height = 1);
					var a = RenderTexture.create(
						__assign({ width: r.width, height: r.height }, n)
					);
					return (
						(tempMatrix$2.tx = -r.x),
						(tempMatrix$2.ty = -r.y),
						this.render(t, {
							renderTexture: a,
							clear: !1,
							transform: tempMatrix$2,
							skipUpdateTransform: !!t.parent,
						}),
						a
					);
				}),
				(e.prototype.destroy = function (t) {
					for (var e in this.plugins)
						this.plugins[e].destroy(), (this.plugins[e] = null);
					t &&
						this.view.parentNode &&
						this.view.parentNode.removeChild(this.view);
					var i = this;
					(i.plugins = null),
						(i.type = RENDERER_TYPE.UNKNOWN),
						(i.view = null),
						(i.screen = null),
						(i._tempDisplayObjectParent = null),
						(i.options = null),
						(this._backgroundColorRgba = null),
						(this._backgroundColorString = null),
						(this._lastObjectRendered = null);
				}),
				Object.defineProperty(e.prototype, 'backgroundColor', {
					get: function () {
						return this._backgroundColor;
					},
					set: function (t) {
						(this._backgroundColor = t),
							(this._backgroundColorString = hex2string(t)),
							hex2rgb(t, this._backgroundColorRgba);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'backgroundAlpha', {
					get: function () {
						return this._backgroundColorRgba[3];
					},
					set: function (t) {
						this._backgroundColorRgba[3] = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				e
			);
		})(eventemitter3$1),
		GLBuffer = function (t) {
			(this.buffer = t || null),
				(this.updateID = -1),
				(this.byteLength = -1),
				(this.refCount = 0);
		},
		BufferSystem = (function () {
			function t(t) {
				(this.renderer = t),
					(this.managedBuffers = {}),
					(this.boundBufferBases = {});
			}
			return (
				(t.prototype.destroy = function () {
					this.renderer = null;
				}),
				(t.prototype.contextChange = function () {
					this.disposeAll(!0),
						(this.gl = this.renderer.gl),
						(this.CONTEXT_UID = this.renderer.CONTEXT_UID);
				}),
				(t.prototype.bind = function (t) {
					var e = this.gl,
						i = this.CONTEXT_UID,
						r = t._glBuffers[i] || this.createGLBuffer(t);
					e.bindBuffer(t.type, r.buffer);
				}),
				(t.prototype.bindBufferBase = function (t, e) {
					var i = this.gl,
						r = this.CONTEXT_UID;
					if (this.boundBufferBases[e] !== t) {
						var s = t._glBuffers[r] || this.createGLBuffer(t);
						(this.boundBufferBases[e] = t),
							i.bindBufferBase(i.UNIFORM_BUFFER, e, s.buffer);
					}
				}),
				(t.prototype.bindBufferRange = function (t, e, i) {
					var r = this.gl,
						s = this.CONTEXT_UID;
					i = i || 0;
					var n = t._glBuffers[s] || this.createGLBuffer(t);
					r.bindBufferRange(r.UNIFORM_BUFFER, e || 0, n.buffer, 256 * i, 256);
				}),
				(t.prototype.update = function (t) {
					var e = this.gl,
						i = this.CONTEXT_UID,
						r = t._glBuffers[i];
					if (t._updateID !== r.updateID)
						if (
							((r.updateID = t._updateID),
							e.bindBuffer(t.type, r.buffer),
							r.byteLength >= t.data.byteLength)
						)
							e.bufferSubData(t.type, 0, t.data);
						else {
							var s = t.static ? e.STATIC_DRAW : e.DYNAMIC_DRAW;
							(r.byteLength = t.data.byteLength),
								e.bufferData(t.type, t.data, s);
						}
				}),
				(t.prototype.dispose = function (t, e) {
					if (this.managedBuffers[t.id]) {
						delete this.managedBuffers[t.id];
						var i = t._glBuffers[this.CONTEXT_UID],
							r = this.gl;
						t.disposeRunner.remove(this),
							i &&
								(e || r.deleteBuffer(i.buffer),
								delete t._glBuffers[this.CONTEXT_UID]);
					}
				}),
				(t.prototype.disposeAll = function (t) {
					for (
						var e = Object.keys(this.managedBuffers), i = 0;
						i < e.length;
						i++
					)
						this.dispose(this.managedBuffers[e[i]], t);
				}),
				(t.prototype.createGLBuffer = function (t) {
					var e = this.CONTEXT_UID,
						i = this.gl;
					return (
						(t._glBuffers[e] = new GLBuffer(i.createBuffer())),
						(this.managedBuffers[t.id] = t),
						t.disposeRunner.add(this),
						t._glBuffers[e]
					);
				}),
				t
			);
		})();
	!(function (t) {
		function e(i) {
			var r = t.call(this, RENDERER_TYPE.WEBGL, i) || this;
			return (
				(i = r.options),
				(r.gl = null),
				(r.CONTEXT_UID = 0),
				(r.runners = {
					destroy: new Runner('destroy'),
					contextChange: new Runner('contextChange'),
					reset: new Runner('reset'),
					update: new Runner('update'),
					postrender: new Runner('postrender'),
					prerender: new Runner('prerender'),
					resize: new Runner('resize'),
				}),
				r.runners.contextChange.add(r),
				(r.globalUniforms = new UniformGroup(
					{ projectionMatrix: new Matrix() },
					!0
				)),
				r
					.addSystem(MaskSystem, 'mask')
					.addSystem(ContextSystem, 'context')
					.addSystem(StateSystem, 'state')
					.addSystem(ShaderSystem, 'shader')
					.addSystem(TextureSystem, 'texture')
					.addSystem(BufferSystem, 'buffer')
					.addSystem(GeometrySystem, 'geometry')
					.addSystem(FramebufferSystem, 'framebuffer')
					.addSystem(ScissorSystem, 'scissor')
					.addSystem(StencilSystem, 'stencil')
					.addSystem(ProjectionSystem, 'projection')
					.addSystem(TextureGCSystem, 'textureGC')
					.addSystem(FilterSystem, 'filter')
					.addSystem(RenderTextureSystem, 'renderTexture')
					.addSystem(BatchSystem, 'batch'),
				r.initPlugins(e.__plugins),
				(r.multisample = void 0),
				i.context
					? r.context.initFromContext(i.context)
					: r.context.initFromOptions({
							alpha: !!r.useContextAlpha,
							antialias: i.antialias,
							premultipliedAlpha:
								r.useContextAlpha && 'notMultiplied' !== r.useContextAlpha,
							stencil: !0,
							preserveDrawingBuffer: i.preserveDrawingBuffer,
							powerPreference: r.options.powerPreference,
					  }),
				(r.renderingToScreen = !0),
				sayHello(2 === r.context.webGLVersion ? 'WebGL 2' : 'WebGL 1'),
				r.resize(r.options.width, r.options.height),
				r
			);
		}
		__extends$7(e, t),
			(e.create = function (t) {
				if (isWebGLSupported()) return new e(t);
				throw new Error(
					'WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.'
				);
			}),
			(e.prototype.contextChange = function () {
				var t,
					e = this.gl;
				if (1 === this.context.webGLVersion) {
					var i = e.getParameter(e.FRAMEBUFFER_BINDING);
					e.bindFramebuffer(e.FRAMEBUFFER, null),
						(t = e.getParameter(e.SAMPLES)),
						e.bindFramebuffer(e.FRAMEBUFFER, i);
				} else
					(i = e.getParameter(e.DRAW_FRAMEBUFFER_BINDING)),
						e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
						(t = e.getParameter(e.SAMPLES)),
						e.bindFramebuffer(e.DRAW_FRAMEBUFFER, i);
				t >= MSAA_QUALITY.HIGH
					? (this.multisample = MSAA_QUALITY.HIGH)
					: t >= MSAA_QUALITY.MEDIUM
					? (this.multisample = MSAA_QUALITY.MEDIUM)
					: t >= MSAA_QUALITY.LOW
					? (this.multisample = MSAA_QUALITY.LOW)
					: (this.multisample = MSAA_QUALITY.NONE);
			}),
			(e.prototype.addSystem = function (t, e) {
				var i = new t(this);
				if (this[e])
					throw new Error('Whoops! The name "' + e + '" is already in use');
				for (var r in ((this[e] = i), this.runners)) this.runners[r].add(i);
				return this;
			}),
			(e.prototype.render = function (t, e) {
				var i, r, s, n;
				if (
					(e &&
						(e instanceof RenderTexture
							? (deprecation(
									'6.0.0',
									'Renderer#render arguments changed, use options instead.'
							  ),
							  (i = e),
							  (r = arguments[2]),
							  (s = arguments[3]),
							  (n = arguments[4]))
							: ((i = e.renderTexture),
							  (r = e.clear),
							  (s = e.transform),
							  (n = e.skipUpdateTransform))),
					(this.renderingToScreen = !i),
					this.runners.prerender.emit(),
					this.emit('prerender'),
					(this.projection.transform = s),
					!this.context.isLost)
				) {
					if ((i || (this._lastObjectRendered = t), !n)) {
						var a = t.enableTempParent();
						t.updateTransform(), t.disableTempParent(a);
					}
					this.renderTexture.bind(i),
						this.batch.currentRenderer.start(),
						(void 0 !== r ? r : this.clearBeforeRender) &&
							this.renderTexture.clear(),
						t.render(this),
						this.batch.currentRenderer.flush(),
						i && i.baseTexture.update(),
						this.runners.postrender.emit(),
						(this.projection.transform = null),
						this.emit('postrender');
				}
			}),
			(e.prototype.generateTexture = function (e, i, r, s) {
				void 0 === i && (i = {});
				var n = t.prototype.generateTexture.call(this, e, i, r, s);
				return this.framebuffer.blit(), n;
			}),
			(e.prototype.resize = function (e, i) {
				t.prototype.resize.call(this, e, i),
					this.runners.resize.emit(this.screen.height, this.screen.width);
			}),
			(e.prototype.reset = function () {
				return this.runners.reset.emit(), this;
			}),
			(e.prototype.clear = function () {
				this.renderTexture.bind(), this.renderTexture.clear();
			}),
			(e.prototype.destroy = function (e) {
				for (var i in (this.runners.destroy.emit(), this.runners))
					this.runners[i].destroy();
				t.prototype.destroy.call(this, e), (this.gl = null);
			}),
			Object.defineProperty(e.prototype, 'extract', {
				get: function () {
					return (
						deprecation(
							'6.0.0',
							'Renderer#extract has been deprecated, please use Renderer#plugins.extract instead.'
						),
						this.plugins.extract
					);
				},
				enumerable: !1,
				configurable: !0,
			}),
			(e.registerPlugin = function (t, i) {
				(e.__plugins = e.__plugins || {}), (e.__plugins[t] = i);
			});
	})(AbstractRenderer);
	var BatchDrawCall = function () {
			(this.texArray = null),
				(this.blend = 0),
				(this.type = DRAW_MODES.TRIANGLES),
				(this.start = 0),
				(this.size = 0),
				(this.data = null);
		},
		BatchTextureArray = (function () {
			function t() {
				(this.elements = []), (this.ids = []), (this.count = 0);
			}
			return (
				(t.prototype.clear = function () {
					for (var t = 0; t < this.count; t++) this.elements[t] = null;
					this.count = 0;
				}),
				t
			);
		})(),
		ViewableBuffer = (function () {
			function t(t) {
				'number' == typeof t
					? (this.rawBinaryData = new ArrayBuffer(t))
					: t instanceof Uint8Array
					? (this.rawBinaryData = t.buffer)
					: (this.rawBinaryData = t),
					(this.uint32View = new Uint32Array(this.rawBinaryData)),
					(this.float32View = new Float32Array(this.rawBinaryData));
			}
			return (
				Object.defineProperty(t.prototype, 'int8View', {
					get: function () {
						return (
							this._int8View ||
								(this._int8View = new Int8Array(this.rawBinaryData)),
							this._int8View
						);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'uint8View', {
					get: function () {
						return (
							this._uint8View ||
								(this._uint8View = new Uint8Array(this.rawBinaryData)),
							this._uint8View
						);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'int16View', {
					get: function () {
						return (
							this._int16View ||
								(this._int16View = new Int16Array(this.rawBinaryData)),
							this._int16View
						);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'uint16View', {
					get: function () {
						return (
							this._uint16View ||
								(this._uint16View = new Uint16Array(this.rawBinaryData)),
							this._uint16View
						);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, 'int32View', {
					get: function () {
						return (
							this._int32View ||
								(this._int32View = new Int32Array(this.rawBinaryData)),
							this._int32View
						);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(t.prototype.view = function (t) {
					return this[t + 'View'];
				}),
				(t.prototype.destroy = function () {
					(this.rawBinaryData = null),
						(this._int8View = null),
						(this._uint8View = null),
						(this._int16View = null),
						(this._uint16View = null),
						(this._int32View = null),
						(this.uint32View = null),
						(this.float32View = null);
				}),
				(t.sizeOf = function (t) {
					switch (t) {
						case 'int8':
						case 'uint8':
							return 1;
						case 'int16':
						case 'uint16':
							return 2;
						case 'int32':
						case 'uint32':
						case 'float32':
							return 4;
						default:
							throw new Error(t + " isn't a valid view type");
					}
				}),
				t
			);
		})(),
		AbstractBatchRenderer = (function (t) {
			function e(e) {
				var i = t.call(this, e) || this;
				return (
					(i.shaderGenerator = null),
					(i.geometryClass = null),
					(i.vertexSize = null),
					(i.state = State.for2d()),
					(i.size = 4 * settings.SPRITE_BATCH_SIZE),
					(i._vertexCount = 0),
					(i._indexCount = 0),
					(i._bufferedElements = []),
					(i._bufferedTextures = []),
					(i._bufferSize = 0),
					(i._shader = null),
					(i._packedGeometries = []),
					(i._packedGeometryPoolSize = 2),
					(i._flushId = 0),
					(i._aBuffers = {}),
					(i._iBuffers = {}),
					(i.MAX_TEXTURES = 1),
					i.renderer.on('prerender', i.onPrerender, i),
					e.runners.contextChange.add(i),
					(i._dcIndex = 0),
					(i._aIndex = 0),
					(i._iIndex = 0),
					(i._attributeBuffer = null),
					(i._indexBuffer = null),
					(i._tempBoundTextures = []),
					i
				);
			}
			return (
				__extends$7(e, t),
				(e.prototype.contextChange = function () {
					var t = this.renderer.gl;
					settings.PREFER_ENV === ENV.WEBGL_LEGACY
						? (this.MAX_TEXTURES = 1)
						: ((this.MAX_TEXTURES = Math.min(
								t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
								settings.SPRITE_MAX_TEXTURES
						  )),
						  (this.MAX_TEXTURES = checkMaxIfStatementsInShader(
								this.MAX_TEXTURES,
								t
						  ))),
						(this._shader = this.shaderGenerator.generateShader(
							this.MAX_TEXTURES
						));
					for (var e = 0; e < this._packedGeometryPoolSize; e++)
						this._packedGeometries[e] = new this.geometryClass();
					this.initFlushBuffers();
				}),
				(e.prototype.initFlushBuffers = function () {
					for (
						var t = e._drawCallPool,
							i = e._textureArrayPool,
							r = this.size / 4,
							s = Math.floor(r / this.MAX_TEXTURES) + 1;
						t.length < r;

					)
						t.push(new BatchDrawCall());
					for (; i.length < s; ) i.push(new BatchTextureArray());
					for (var n = 0; n < this.MAX_TEXTURES; n++)
						this._tempBoundTextures[n] = null;
				}),
				(e.prototype.onPrerender = function () {
					this._flushId = 0;
				}),
				(e.prototype.render = function (t) {
					t._texture.valid &&
						(this._vertexCount + t.vertexData.length / 2 > this.size &&
							this.flush(),
						(this._vertexCount += t.vertexData.length / 2),
						(this._indexCount += t.indices.length),
						(this._bufferedTextures[this._bufferSize] = t._texture.baseTexture),
						(this._bufferedElements[this._bufferSize++] = t));
				}),
				(e.prototype.buildTexturesAndDrawCalls = function () {
					var t = this._bufferedTextures,
						i = this.MAX_TEXTURES,
						r = e._textureArrayPool,
						s = this.renderer.batch,
						n = this._tempBoundTextures,
						a = this.renderer.textureGC.count,
						o = ++BaseTexture._globalBatch,
						h = 0,
						u = r[0],
						l = 0;
					s.copyBoundTextures(n, i);
					for (var c = 0; c < this._bufferSize; ++c) {
						var d = t[c];
						(t[c] = null),
							d._batchEnabled !== o &&
								(u.count >= i &&
									(s.boundArray(u, n, o, i),
									this.buildDrawCalls(u, l, c),
									(l = c),
									(u = r[++h]),
									++o),
								(d._batchEnabled = o),
								(d.touched = a),
								(u.elements[u.count++] = d));
					}
					for (
						u.count > 0 &&
							(s.boundArray(u, n, o, i),
							this.buildDrawCalls(u, l, this._bufferSize),
							++h,
							++o),
							c = 0;
						c < n.length;
						c++
					)
						n[c] = null;
					BaseTexture._globalBatch = o;
				}),
				(e.prototype.buildDrawCalls = function (t, i, r) {
					var s = this,
						n = s._bufferedElements,
						a = s._attributeBuffer,
						o = s._indexBuffer,
						h = s.vertexSize,
						u = e._drawCallPool,
						l = this._dcIndex,
						c = this._aIndex,
						d = this._iIndex,
						p = u[l];
					(p.start = this._iIndex), (p.texArray = t);
					for (var f = i; f < r; ++f) {
						var m = n[f],
							_ = m._texture.baseTexture,
							g = premultiplyBlendMode[_.alphaMode ? 1 : 0][m.blendMode];
						(n[f] = null),
							i < f &&
								p.blend !== g &&
								((p.size = d - p.start),
								(i = f),
								((p = u[++l]).texArray = t),
								(p.start = d)),
							this.packInterleavedGeometry(m, a, o, c, d),
							(c += (m.vertexData.length / 2) * h),
							(d += m.indices.length),
							(p.blend = g);
					}
					i < r && ((p.size = d - p.start), ++l),
						(this._dcIndex = l),
						(this._aIndex = c),
						(this._iIndex = d);
				}),
				(e.prototype.bindAndClearTexArray = function (t) {
					for (var e = this.renderer.texture, i = 0; i < t.count; i++)
						e.bind(t.elements[i], t.ids[i]), (t.elements[i] = null);
					t.count = 0;
				}),
				(e.prototype.updateGeometry = function () {
					var t = this,
						e = t._packedGeometries,
						i = t._attributeBuffer,
						r = t._indexBuffer;
					settings.CAN_UPLOAD_SAME_BUFFER
						? (e[this._flushId]._buffer.update(i.rawBinaryData),
						  e[this._flushId]._indexBuffer.update(r),
						  this.renderer.geometry.updateBuffers())
						: (this._packedGeometryPoolSize <= this._flushId &&
								(this._packedGeometryPoolSize++,
								(e[this._flushId] = new this.geometryClass())),
						  e[this._flushId]._buffer.update(i.rawBinaryData),
						  e[this._flushId]._indexBuffer.update(r),
						  this.renderer.geometry.bind(e[this._flushId]),
						  this.renderer.geometry.updateBuffers(),
						  this._flushId++);
				}),
				(e.prototype.drawBatches = function () {
					for (
						var t = this._dcIndex,
							i = this.renderer,
							r = i.gl,
							s = i.state,
							n = e._drawCallPool,
							a = null,
							o = 0;
						o < t;
						o++
					) {
						var h = n[o],
							u = h.texArray,
							l = h.type,
							c = h.size,
							d = h.start,
							p = h.blend;
						a !== u && ((a = u), this.bindAndClearTexArray(u)),
							(this.state.blendMode = p),
							s.set(this.state),
							r.drawElements(l, c, r.UNSIGNED_SHORT, 2 * d);
					}
				}),
				(e.prototype.flush = function () {
					0 !== this._vertexCount &&
						((this._attributeBuffer = this.getAttributeBuffer(
							this._vertexCount
						)),
						(this._indexBuffer = this.getIndexBuffer(this._indexCount)),
						(this._aIndex = 0),
						(this._iIndex = 0),
						(this._dcIndex = 0),
						this.buildTexturesAndDrawCalls(),
						this.updateGeometry(),
						this.drawBatches(),
						(this._bufferSize = 0),
						(this._vertexCount = 0),
						(this._indexCount = 0));
				}),
				(e.prototype.start = function () {
					this.renderer.state.set(this.state),
						this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES),
						this.renderer.shader.bind(this._shader),
						settings.CAN_UPLOAD_SAME_BUFFER &&
							this.renderer.geometry.bind(
								this._packedGeometries[this._flushId]
							);
				}),
				(e.prototype.stop = function () {
					this.flush();
				}),
				(e.prototype.destroy = function () {
					for (var e = 0; e < this._packedGeometryPoolSize; e++)
						this._packedGeometries[e] && this._packedGeometries[e].destroy();
					this.renderer.off('prerender', this.onPrerender, this),
						(this._aBuffers = null),
						(this._iBuffers = null),
						(this._packedGeometries = null),
						(this._attributeBuffer = null),
						(this._indexBuffer = null),
						this._shader && (this._shader.destroy(), (this._shader = null)),
						t.prototype.destroy.call(this);
				}),
				(e.prototype.getAttributeBuffer = function (t) {
					var e = nextPow2(Math.ceil(t / 8)),
						i = log2(e),
						r = 8 * e;
					this._aBuffers.length <= i && (this._iBuffers.length = i + 1);
					var s = this._aBuffers[r];
					return (
						s ||
							(this._aBuffers[r] = s =
								new ViewableBuffer(r * this.vertexSize * 4)),
						s
					);
				}),
				(e.prototype.getIndexBuffer = function (t) {
					var e = nextPow2(Math.ceil(t / 12)),
						i = log2(e),
						r = 12 * e;
					this._iBuffers.length <= i && (this._iBuffers.length = i + 1);
					var s = this._iBuffers[i];
					return s || (this._iBuffers[i] = s = new Uint16Array(r)), s;
				}),
				(e.prototype.packInterleavedGeometry = function (t, e, i, r, s) {
					for (
						var n = e.uint32View,
							a = e.float32View,
							o = r / this.vertexSize,
							h = t.uvs,
							u = t.indices,
							l = t.vertexData,
							c = t._texture.baseTexture._batchLocation,
							d = Math.min(t.worldAlpha, 1),
							p =
								d < 1 && t._texture.baseTexture.alphaMode
									? premultiplyTint(t._tintRGB, d)
									: t._tintRGB + ((255 * d) << 24),
							f = 0;
						f < l.length;
						f += 2
					)
						(a[r++] = l[f]),
							(a[r++] = l[f + 1]),
							(a[r++] = h[f]),
							(a[r++] = h[f + 1]),
							(n[r++] = p),
							(a[r++] = c);
					for (f = 0; f < u.length; f++) i[s++] = o + u[f];
				}),
				(e._drawCallPool = []),
				(e._textureArrayPool = []),
				e
			);
		})(ObjectRenderer),
		BatchShaderGenerator = (function () {
			function t(t, e) {
				if (
					((this.vertexSrc = t),
					(this.fragTemplate = e),
					(this.programCache = {}),
					(this.defaultGroupCache = {}),
					e.indexOf('%count%') < 0)
				)
					throw new Error('Fragment template must contain "%count%".');
				if (e.indexOf('%forloop%') < 0)
					throw new Error('Fragment template must contain "%forloop%".');
			}
			return (
				(t.prototype.generateShader = function (t) {
					if (!this.programCache[t]) {
						for (var e = new Int32Array(t), i = 0; i < t; i++) e[i] = i;
						this.defaultGroupCache[t] = UniformGroup.from({ uSamplers: e }, !0);
						var r = this.fragTemplate;
						(r = (r = r.replace(/%count%/gi, '' + t)).replace(
							/%forloop%/gi,
							this.generateSampleSrc(t)
						)),
							(this.programCache[t] = new Program(this.vertexSrc, r));
					}
					var s = {
						tint: new Float32Array([1, 1, 1, 1]),
						translationMatrix: new Matrix(),
						default: this.defaultGroupCache[t],
					};
					return new Shader(this.programCache[t], s);
				}),
				(t.prototype.generateSampleSrc = function (t) {
					var e = '';
					(e += '\n'), (e += '\n');
					for (var i = 0; i < t; i++)
						i > 0 && (e += '\nelse '),
							i < t - 1 && (e += 'if(vTextureId < ' + i + '.5)'),
							(e += '\n{'),
							(e +=
								'\n\tcolor = texture2D(uSamplers[' + i + '], vTextureCoord);'),
							(e += '\n}');
					return (e += '\n') + '\n';
				}),
				t
			);
		})(),
		BatchGeometry = (function (t) {
			function e(e) {
				void 0 === e && (e = !1);
				var i = t.call(this) || this;
				return (
					(i._buffer = new Buffer(null, e, !1)),
					(i._indexBuffer = new Buffer(null, e, !0)),
					i
						.addAttribute('aVertexPosition', i._buffer, 2, !1, TYPES.FLOAT)
						.addAttribute('aTextureCoord', i._buffer, 2, !1, TYPES.FLOAT)
						.addAttribute('aColor', i._buffer, 4, !0, TYPES.UNSIGNED_BYTE)
						.addAttribute('aTextureId', i._buffer, 1, !0, TYPES.FLOAT)
						.addIndex(i._indexBuffer),
					i
				);
			}
			return __extends$7(e, t), e;
		})(Geometry),
		defaultVertex$3 =
			'precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n',
		defaultFragment$2 =
			'varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n',
		BatchPluginFactory = (function () {
			function t() {}
			return (
				(t.create = function (t) {
					var e = Object.assign(
							{
								vertex: defaultVertex$3,
								fragment: defaultFragment$2,
								geometryClass: BatchGeometry,
								vertexSize: 6,
							},
							t
						),
						i = e.vertex,
						r = e.fragment,
						s = e.vertexSize,
						n = e.geometryClass;
					return (function (t) {
						function e(e) {
							var a = t.call(this, e) || this;
							return (
								(a.shaderGenerator = new BatchShaderGenerator(i, r)),
								(a.geometryClass = n),
								(a.vertexSize = s),
								a
							);
						}
						return __extends$7(e, t), e;
					})(AbstractBatchRenderer);
				}),
				Object.defineProperty(t, 'defaultVertexSrc', {
					get: function () {
						return defaultVertex$3;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(t, 'defaultFragmentTemplate', {
					get: function () {
						return defaultFragment$2;
					},
					enumerable: !1,
					configurable: !0,
				}),
				t
			);
		})();
	BatchPluginFactory.create();
	/*!
	 * @pixi/filter-crt - v4.1.6
	 * Compiled Thu, 03 Feb 2022 14:30:04 UTC
	 *
	 * @pixi/filter-crt is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 */
	/*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
	var extendStatics$6 = function (t, e) {
		return (extendStatics$6 =
			Object.setPrototypeOf ||
			({ __proto__: [] } instanceof Array &&
				function (t, e) {
					t.__proto__ = e;
				}) ||
			function (t, e) {
				for (var i in e)
					Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
			})(t, e);
	};
	function __extends$6(t, e) {
		function i() {
			this.constructor = t;
		}
		extendStatics$6(t, e),
			(t.prototype =
				null === e ? Object.create(e) : ((i.prototype = e.prototype), new i()));
	}
	var vertex$6 =
			'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}',
		fragment$6 =
			'varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nconst float SQRT_2 = 1.414213;\n\nconst float light = 1.0;\n\nuniform float curvature;\nuniform float lineWidth;\nuniform float lineContrast;\nuniform bool verticalLine;\nuniform float noise;\nuniform float noiseSize;\n\nuniform float vignetting;\nuniform float vignettingAlpha;\nuniform float vignettingBlur;\n\nuniform float seed;\nuniform float time;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main(void)\n{\n    vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n    vec2 dir = vec2(vTextureCoord.xy * filterArea.xy / dimensions - vec2(0.5, 0.5));\n    \n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n    vec3 rgb = gl_FragColor.rgb;\n\n    if (noise > 0.0 && noiseSize > 0.0)\n    {\n        pixelCoord.x = floor(pixelCoord.x / noiseSize);\n        pixelCoord.y = floor(pixelCoord.y / noiseSize);\n        float _noise = rand(pixelCoord * noiseSize * seed) - 0.5;\n        rgb += _noise * noise;\n    }\n\n    if (lineWidth > 0.0)\n    {\n        float _c = curvature > 0. ? curvature : 1.;\n        float k = curvature > 0. ?(length(dir * dir) * 0.25 * _c * _c + 0.935 * _c) : 1.;\n        vec2 uv = dir * k;\n\n        float v = (verticalLine ? uv.x * dimensions.x : uv.y * dimensions.y) * min(1.0, 2.0 / lineWidth ) / _c;\n        float j = 1. + cos(v * 1.2 - time) * 0.5 * lineContrast;\n        rgb *= j;\n        float segment = verticalLine ? mod((dir.x + .5) * dimensions.x, 4.) : mod((dir.y + .5) * dimensions.y, 4.);\n        rgb *= 0.99 + ceil(segment) * 0.015;\n    }\n\n    if (vignetting > 0.0)\n    {\n        float outter = SQRT_2 - vignetting * SQRT_2;\n        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignettingBlur * SQRT_2), 0.0, 1.0);\n        rgb *= darker + (1.0 - darker) * (1.0 - vignettingAlpha);\n    }\n\n    gl_FragColor.rgb = rgb;\n}\n',
		CRTFilter = (function (t) {
			function e(i) {
				var r = t.call(this, vertex$6, fragment$6) || this;
				return (
					(r.time = 0),
					(r.seed = 0),
					(r.uniforms.dimensions = new Float32Array(2)),
					Object.assign(r, e.defaults, i),
					r
				);
			}
			return (
				__extends$6(e, t),
				(e.prototype.apply = function (t, e, i, r) {
					var s = e.filterFrame,
						n = s.width,
						a = s.height;
					(this.uniforms.dimensions[0] = n),
						(this.uniforms.dimensions[1] = a),
						(this.uniforms.seed = this.seed),
						(this.uniforms.time = this.time),
						t.applyFilter(this, e, i, r);
				}),
				Object.defineProperty(e.prototype, 'curvature', {
					get: function () {
						return this.uniforms.curvature;
					},
					set: function (t) {
						this.uniforms.curvature = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'lineWidth', {
					get: function () {
						return this.uniforms.lineWidth;
					},
					set: function (t) {
						this.uniforms.lineWidth = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'lineContrast', {
					get: function () {
						return this.uniforms.lineContrast;
					},
					set: function (t) {
						this.uniforms.lineContrast = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'verticalLine', {
					get: function () {
						return this.uniforms.verticalLine;
					},
					set: function (t) {
						this.uniforms.verticalLine = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'noise', {
					get: function () {
						return this.uniforms.noise;
					},
					set: function (t) {
						this.uniforms.noise = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'noiseSize', {
					get: function () {
						return this.uniforms.noiseSize;
					},
					set: function (t) {
						this.uniforms.noiseSize = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'vignetting', {
					get: function () {
						return this.uniforms.vignetting;
					},
					set: function (t) {
						this.uniforms.vignetting = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'vignettingAlpha', {
					get: function () {
						return this.uniforms.vignettingAlpha;
					},
					set: function (t) {
						this.uniforms.vignettingAlpha = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'vignettingBlur', {
					get: function () {
						return this.uniforms.vignettingBlur;
					},
					set: function (t) {
						this.uniforms.vignettingBlur = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.defaults = {
					curvature: 1,
					lineWidth: 1,
					lineContrast: 0.25,
					verticalLine: !1,
					noise: 0,
					noiseSize: 1,
					seed: 0,
					vignetting: 0.3,
					vignettingAlpha: 1,
					vignettingBlur: 0.3,
					time: 0,
				}),
				e
			);
		})(Filter),
		extendStatics$5 = function (t, e) {
			return (extendStatics$5 =
				Object.setPrototypeOf ||
				({ __proto__: [] } instanceof Array &&
					function (t, e) {
						t.__proto__ = e;
					}) ||
				function (t, e) {
					for (var i in e)
						Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
				})(t, e);
		};
	function __extends$5(t, e) {
		function i() {
			this.constructor = t;
		}
		extendStatics$5(t, e),
			(t.prototype =
				null === e ? Object.create(e) : ((i.prototype = e.prototype), new i()));
	}
	var vertex$5 =
			'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}',
		fragment$5 =
			'varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\n\nuniform vec2 center;\n\nuniform float amplitude;\nuniform float wavelength;\n// uniform float power;\nuniform float brightness;\nuniform float speed;\nuniform float radius;\n\nuniform float time;\n\nconst float PI = 3.14159;\n\nvoid main()\n{\n    float halfWavelength = wavelength * 0.5 / filterArea.x;\n    float maxRadius = radius / filterArea.x;\n    float currentRadius = time * speed / filterArea.x;\n\n    float fade = 1.0;\n\n    if (maxRadius > 0.0) {\n        if (currentRadius > maxRadius) {\n            gl_FragColor = texture2D(uSampler, vTextureCoord);\n            return;\n        }\n        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);\n    }\n\n    vec2 dir = vec2(vTextureCoord - center / filterArea.xy);\n    dir.y *= filterArea.y / filterArea.x;\n    float dist = length(dir);\n\n    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {\n        gl_FragColor = texture2D(uSampler, vTextureCoord);\n        return;\n    }\n\n    vec2 diffUV = normalize(dir);\n\n    float diff = (dist - currentRadius) / halfWavelength;\n\n    float p = 1.0 - pow(abs(diff), 2.0);\n\n    // float powDiff = diff * pow(p, 2.0) * ( amplitude * fade );\n    float powDiff = 1.25 * sin(diff * PI) * p * ( amplitude * fade );\n\n    vec2 offset = diffUV * powDiff / filterArea.xy;\n\n    // Do clamp :\n    vec2 coord = vTextureCoord + offset;\n    vec2 clampedCoord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    vec4 color = texture2D(uSampler, clampedCoord);\n    if (coord != clampedCoord) {\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n\n    // No clamp :\n    // gl_FragColor = texture2D(uSampler, vTextureCoord + offset);\n\n    color.rgb *= 1.0 + (brightness - 1.0) * p * fade;\n\n    gl_FragColor = color;\n}\n',
		ShockwaveFilter = (function (t) {
			function e(i, r, s) {
				void 0 === i && (i = [0, 0]), void 0 === s && (s = 0);
				var n = t.call(this, vertex$5, fragment$5) || this;
				return (n.center = i), Object.assign(n, e.defaults, r), (n.time = s), n;
			}
			return (
				__extends$5(e, t),
				(e.prototype.apply = function (t, e, i, r) {
					(this.uniforms.time = this.time), t.applyFilter(this, e, i, r);
				}),
				Object.defineProperty(e.prototype, 'center', {
					get: function () {
						return this.uniforms.center;
					},
					set: function (t) {
						this.uniforms.center = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'amplitude', {
					get: function () {
						return this.uniforms.amplitude;
					},
					set: function (t) {
						this.uniforms.amplitude = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'wavelength', {
					get: function () {
						return this.uniforms.wavelength;
					},
					set: function (t) {
						this.uniforms.wavelength = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'brightness', {
					get: function () {
						return this.uniforms.brightness;
					},
					set: function (t) {
						this.uniforms.brightness = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'speed', {
					get: function () {
						return this.uniforms.speed;
					},
					set: function (t) {
						this.uniforms.speed = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'radius', {
					get: function () {
						return this.uniforms.radius;
					},
					set: function (t) {
						this.uniforms.radius = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.defaults = {
					amplitude: 30,
					wavelength: 160,
					brightness: 1,
					speed: 500,
					radius: -1,
				}),
				e
			);
		})(Filter$1),
		extendStatics$4 = function (t, e) {
			return (extendStatics$4 =
				Object.setPrototypeOf ||
				({ __proto__: [] } instanceof Array &&
					function (t, e) {
						t.__proto__ = e;
					}) ||
				function (t, e) {
					for (var i in e)
						Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
				})(t, e);
		};
	function __extends$4(t, e) {
		function i() {
			this.constructor = t;
		}
		extendStatics$4(t, e),
			(t.prototype =
				null === e ? Object.create(e) : ((i.prototype = e.prototype), new i()));
	}
	var vertex$4 =
			'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}',
		fragment$4 =
			'precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec2 red;\nuniform vec2 green;\nuniform vec2 blue;\n\nvoid main(void)\n{\n   gl_FragColor.r = texture2D(uSampler, vTextureCoord + red/filterArea.xy).r;\n   gl_FragColor.g = texture2D(uSampler, vTextureCoord + green/filterArea.xy).g;\n   gl_FragColor.b = texture2D(uSampler, vTextureCoord + blue/filterArea.xy).b;\n   gl_FragColor.a = texture2D(uSampler, vTextureCoord).a;\n}\n',
		RGBSplitFilter = (function (t) {
			function e(e, i, r) {
				void 0 === e && (e = [-10, 0]),
					void 0 === i && (i = [0, 10]),
					void 0 === r && (r = [0, 0]);
				var s = t.call(this, vertex$4, fragment$4) || this;
				return (s.red = e), (s.green = i), (s.blue = r), s;
			}
			return (
				__extends$4(e, t),
				Object.defineProperty(e.prototype, 'red', {
					get: function () {
						return this.uniforms.red;
					},
					set: function (t) {
						this.uniforms.red = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'green', {
					get: function () {
						return this.uniforms.green;
					},
					set: function (t) {
						this.uniforms.green = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'blue', {
					get: function () {
						return this.uniforms.blue;
					},
					set: function (t) {
						this.uniforms.blue = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				e
			);
		})(Filter$1),
		extendStatics$3 = function (t, e) {
			return (extendStatics$3 =
				Object.setPrototypeOf ||
				({ __proto__: [] } instanceof Array &&
					function (t, e) {
						t.__proto__ = e;
					}) ||
				function (t, e) {
					for (var i in e)
						Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
				})(t, e);
		};
	function __extends$3(t, e) {
		function i() {
			this.constructor = t;
		}
		extendStatics$3(t, e),
			(t.prototype =
				null === e ? Object.create(e) : ((i.prototype = e.prototype), new i()));
	}
	var vertex$3 =
			'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}',
		fragment$3 =
			'\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 uOffset;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample top right pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample bottom right pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Sample bottom left pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Average\n    color *= 0.25;\n\n    gl_FragColor = color;\n}',
		fragmentClamp =
			'\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 uOffset;\nuniform vec4 filterClamp;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample top right pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample bottom right pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample bottom left pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Average\n    color *= 0.25;\n\n    gl_FragColor = color;\n}\n',
		KawaseBlurFilter = (function (t) {
			function e(e, i, r) {
				void 0 === e && (e = 4),
					void 0 === i && (i = 3),
					void 0 === r && (r = !1);
				var s = t.call(this, vertex$3, r ? fragmentClamp : fragment$3) || this;
				return (
					(s._kernels = []),
					(s._blur = 4),
					(s._quality = 3),
					(s.uniforms.uOffset = new Float32Array(2)),
					(s._pixelSize = new Point$2()),
					(s.pixelSize = 1),
					(s._clamp = r),
					Array.isArray(e) ? (s.kernels = e) : ((s._blur = e), (s.quality = i)),
					s
				);
			}
			return (
				__extends$3(e, t),
				(e.prototype.apply = function (t, e, i, r) {
					var s,
						n = this._pixelSize.x / e._frame.width,
						a = this._pixelSize.y / e._frame.height;
					if (1 === this._quality || 0 === this._blur)
						(s = this._kernels[0] + 0.5),
							(this.uniforms.uOffset[0] = s * n),
							(this.uniforms.uOffset[1] = s * a),
							t.applyFilter(this, e, i, r);
					else {
						for (
							var o = t.getFilterTexture(),
								h = e,
								u = o,
								l = void 0,
								c = this._quality - 1,
								d = 0;
							d < c;
							d++
						)
							(s = this._kernels[d] + 0.5),
								(this.uniforms.uOffset[0] = s * n),
								(this.uniforms.uOffset[1] = s * a),
								t.applyFilter(this, h, u, 1),
								(l = h),
								(h = u),
								(u = l);
						(s = this._kernels[c] + 0.5),
							(this.uniforms.uOffset[0] = s * n),
							(this.uniforms.uOffset[1] = s * a),
							t.applyFilter(this, h, i, r),
							t.returnFilterTexture(o);
					}
				}),
				(e.prototype._updatePadding = function () {
					this.padding = Math.ceil(
						this._kernels.reduce(function (t, e) {
							return t + e + 0.5;
						}, 0)
					);
				}),
				(e.prototype._generateKernels = function () {
					var t = this._blur,
						e = this._quality,
						i = [t];
					if (t > 0)
						for (var r = t, s = t / e, n = 1; n < e; n++) (r -= s), i.push(r);
					(this._kernels = i), this._updatePadding();
				}),
				Object.defineProperty(e.prototype, 'kernels', {
					get: function () {
						return this._kernels;
					},
					set: function (t) {
						Array.isArray(t) && t.length > 0
							? ((this._kernels = t),
							  (this._quality = t.length),
							  (this._blur = Math.max.apply(Math, t)))
							: ((this._kernels = [0]), (this._quality = 1));
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'clamp', {
					get: function () {
						return this._clamp;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'pixelSize', {
					get: function () {
						return this._pixelSize;
					},
					set: function (t) {
						'number' == typeof t
							? ((this._pixelSize.x = t), (this._pixelSize.y = t))
							: Array.isArray(t)
							? ((this._pixelSize.x = t[0]), (this._pixelSize.y = t[1]))
							: t instanceof Point$2
							? ((this._pixelSize.x = t.x), (this._pixelSize.y = t.y))
							: ((this._pixelSize.x = 1), (this._pixelSize.y = 1));
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'quality', {
					get: function () {
						return this._quality;
					},
					set: function (t) {
						(this._quality = Math.max(1, Math.round(t))),
							this._generateKernels();
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'blur', {
					get: function () {
						return this._blur;
					},
					set: function (t) {
						(this._blur = t), this._generateKernels();
					},
					enumerable: !1,
					configurable: !0,
				}),
				e
			);
		})(Filter$1),
		extendStatics$2 = function (t, e) {
			return (extendStatics$2 =
				Object.setPrototypeOf ||
				({ __proto__: [] } instanceof Array &&
					function (t, e) {
						t.__proto__ = e;
					}) ||
				function (t, e) {
					for (var i in e)
						Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
				})(t, e);
		};
	function __extends$2(t, e) {
		function i() {
			this.constructor = t;
		}
		extendStatics$2(t, e),
			(t.prototype =
				null === e ? Object.create(e) : ((i.prototype = e.prototype), new i()));
	}
	var vertex$2 =
			'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}',
		fragment$2 =
			"\nuniform sampler2D uSampler;\nvarying vec2 vTextureCoord;\n\nuniform float threshold;\n\nvoid main() {\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    // A simple & fast algorithm for getting brightness.\n    // It's inaccuracy , but good enought for this feature.\n    float _max = max(max(color.r, color.g), color.b);\n    float _min = min(min(color.r, color.g), color.b);\n    float brightness = (_max + _min) * 0.5;\n\n    if(brightness > threshold) {\n        gl_FragColor = color;\n    } else {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}\n",
		ExtractBrightnessFilter = (function (t) {
			function e(e) {
				void 0 === e && (e = 0.5);
				var i = t.call(this, vertex$2, fragment$2) || this;
				return (i.threshold = e), i;
			}
			return (
				__extends$2(e, t),
				Object.defineProperty(e.prototype, 'threshold', {
					get: function () {
						return this.uniforms.threshold;
					},
					set: function (t) {
						this.uniforms.threshold = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				e
			);
		})(Filter$1),
		fragment$1$1 =
			'uniform sampler2D uSampler;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D bloomTexture;\nuniform float bloomScale;\nuniform float brightness;\n\nvoid main() {\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    color.rgb *= brightness;\n    vec4 bloomColor = vec4(texture2D(bloomTexture, vTextureCoord).rgb, 0.0);\n    bloomColor.rgb *= bloomScale;\n    gl_FragColor = color + bloomColor;\n}\n',
		AdvancedBloomFilter = (function (t) {
			function e(i) {
				var r = t.call(this, vertex$2, fragment$1$1) || this;
				(r.bloomScale = 1),
					(r.brightness = 1),
					(r._resolution = settings$2.FILTER_RESOLUTION),
					'number' == typeof i && (i = { threshold: i });
				var s = Object.assign(e.defaults, i);
				(r.bloomScale = s.bloomScale), (r.brightness = s.brightness);
				var n = s.kernels,
					a = s.blur,
					o = s.quality,
					h = s.pixelSize,
					u = s.resolution;
				return (
					(r._extractFilter = new ExtractBrightnessFilter(s.threshold)),
					(r._extractFilter.resolution = u),
					(r._blurFilter = n
						? new KawaseBlurFilter(n)
						: new KawaseBlurFilter(a, o)),
					(r.pixelSize = h),
					(r.resolution = u),
					r
				);
			}
			return (
				__extends$2(e, t),
				(e.prototype.apply = function (t, e, i, r, s) {
					var n = t.getFilterTexture();
					this._extractFilter.apply(t, e, n, 1, s);
					var a = t.getFilterTexture();
					this._blurFilter.apply(t, n, a, 1),
						(this.uniforms.bloomScale = this.bloomScale),
						(this.uniforms.brightness = this.brightness),
						(this.uniforms.bloomTexture = a),
						t.applyFilter(this, e, i, r),
						t.returnFilterTexture(a),
						t.returnFilterTexture(n);
				}),
				Object.defineProperty(e.prototype, 'resolution', {
					get: function () {
						return this._resolution;
					},
					set: function (t) {
						(this._resolution = t),
							this._extractFilter && (this._extractFilter.resolution = t),
							this._blurFilter && (this._blurFilter.resolution = t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'threshold', {
					get: function () {
						return this._extractFilter.threshold;
					},
					set: function (t) {
						this._extractFilter.threshold = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'kernels', {
					get: function () {
						return this._blurFilter.kernels;
					},
					set: function (t) {
						this._blurFilter.kernels = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'blur', {
					get: function () {
						return this._blurFilter.blur;
					},
					set: function (t) {
						this._blurFilter.blur = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'quality', {
					get: function () {
						return this._blurFilter.quality;
					},
					set: function (t) {
						this._blurFilter.quality = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'pixelSize', {
					get: function () {
						return this._blurFilter.pixelSize;
					},
					set: function (t) {
						this._blurFilter.pixelSize = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.defaults = {
					threshold: 0.5,
					bloomScale: 1,
					brightness: 1,
					kernels: null,
					blur: 8,
					quality: 4,
					pixelSize: 1,
					resolution: settings$2.FILTER_RESOLUTION,
				}),
				e
			);
		})(Filter$1),
		extendStatics$1 = function (t, e) {
			return (extendStatics$1 =
				Object.setPrototypeOf ||
				({ __proto__: [] } instanceof Array &&
					function (t, e) {
						t.__proto__ = e;
					}) ||
				function (t, e) {
					for (var i in e)
						Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
				})(t, e);
		};
	function __extends$1(t, e) {
		function i() {
			this.constructor = t;
		}
		extendStatics$1(t, e),
			(t.prototype =
				null === e ? Object.create(e) : ((i.prototype = e.prototype), new i()));
	}
	var vertex$1 =
			'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}',
		fragment$1 =
			'varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform vec2 uVelocity;\nuniform int uKernelSize;\nuniform float uOffset;\n\nconst int MAX_KERNEL_SIZE = 2048;\n\n// Notice:\n// the perfect way:\n//    int kernelSize = min(uKernelSize, MAX_KERNELSIZE);\n// BUT in real use-case , uKernelSize < MAX_KERNELSIZE almost always.\n// So use uKernelSize directly.\n\nvoid main(void)\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    if (uKernelSize == 0)\n    {\n        gl_FragColor = color;\n        return;\n    }\n\n    vec2 velocity = uVelocity / filterArea.xy;\n    float offset = -uOffset / length(uVelocity) - 0.5;\n    int k = uKernelSize - 1;\n\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\n        if (i == k) {\n            break;\n        }\n        vec2 bias = velocity * (float(i) / float(k) + offset);\n        color += texture2D(uSampler, vTextureCoord + bias);\n    }\n    gl_FragColor = color / float(uKernelSize);\n}\n',
		MotionBlurFilter = (function (t) {
			function e(e, i, r) {
				void 0 === e && (e = [0, 0]),
					void 0 === i && (i = 5),
					void 0 === r && (r = 0);
				var s = t.call(this, vertex$1, fragment$1) || this;
				return (
					(s.kernelSize = 5),
					(s.uniforms.uVelocity = new Float32Array(2)),
					(s._velocity = new ObservablePoint$1(s.velocityChanged, s)),
					s.setVelocity(e),
					(s.kernelSize = i),
					(s.offset = r),
					s
				);
			}
			return (
				__extends$1(e, t),
				(e.prototype.apply = function (t, e, i, r) {
					var s = this.velocity,
						n = s.x,
						a = s.y;
					(this.uniforms.uKernelSize =
						0 !== n || 0 !== a ? this.kernelSize : 0),
						t.applyFilter(this, e, i, r);
				}),
				Object.defineProperty(e.prototype, 'velocity', {
					get: function () {
						return this._velocity;
					},
					set: function (t) {
						this.setVelocity(t);
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.setVelocity = function (t) {
					if (Array.isArray(t)) {
						var e = t[0],
							i = t[1];
						this._velocity.set(e, i);
					} else this._velocity.copyFrom(t);
				}),
				(e.prototype.velocityChanged = function () {
					(this.uniforms.uVelocity[0] = this._velocity.x),
						(this.uniforms.uVelocity[1] = this._velocity.y),
						(this.padding =
							1 +
							(Math.max(
								Math.abs(this._velocity.x),
								Math.abs(this._velocity.y)
							) >>
								0));
				}),
				Object.defineProperty(e.prototype, 'offset', {
					get: function () {
						return this.uniforms.uOffset;
					},
					set: function (t) {
						this.uniforms.uOffset = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				e
			);
		})(Filter$1),
		extendStatics = function (t, e) {
			return (extendStatics =
				Object.setPrototypeOf ||
				({ __proto__: [] } instanceof Array &&
					function (t, e) {
						t.__proto__ = e;
					}) ||
				function (t, e) {
					for (var i in e)
						Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
				})(t, e);
		};
	function __extends(t, e) {
		function i() {
			this.constructor = t;
		}
		extendStatics(t, e),
			(t.prototype =
				null === e ? Object.create(e) : ((i.prototype = e.prototype), new i()));
	}
	var vertex =
			'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}',
		fragment =
			'// precision highp float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform vec2 dimensions;\nuniform float aspect;\n\nuniform sampler2D displacementMap;\nuniform float offset;\nuniform float sinDir;\nuniform float cosDir;\nuniform int fillMode;\n\nuniform float seed;\nuniform vec2 red;\nuniform vec2 green;\nuniform vec2 blue;\n\nconst int TRANSPARENT = 0;\nconst int ORIGINAL = 1;\nconst int LOOP = 2;\nconst int CLAMP = 3;\nconst int MIRROR = 4;\n\nvoid main(void)\n{\n    vec2 coord = (vTextureCoord * filterArea.xy) / dimensions;\n\n    if (coord.x > 1.0 || coord.y > 1.0) {\n        return;\n    }\n\n    float cx = coord.x - 0.5;\n    float cy = (coord.y - 0.5) * aspect;\n    float ny = (-sinDir * cx + cosDir * cy) / aspect + 0.5;\n\n    // displacementMap: repeat\n    // ny = ny > 1.0 ? ny - 1.0 : (ny < 0.0 ? 1.0 + ny : ny);\n\n    // displacementMap: mirror\n    ny = ny > 1.0 ? 2.0 - ny : (ny < 0.0 ? -ny : ny);\n\n    vec4 dc = texture2D(displacementMap, vec2(0.5, ny));\n\n    float displacement = (dc.r - dc.g) * (offset / filterArea.x);\n\n    coord = vTextureCoord + vec2(cosDir * displacement, sinDir * displacement * aspect);\n\n    if (fillMode == CLAMP) {\n        coord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    } else {\n        if( coord.x > filterClamp.z ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.x -= filterClamp.z;\n            } else if (fillMode == MIRROR) {\n                coord.x = filterClamp.z * 2.0 - coord.x;\n            }\n        } else if( coord.x < filterClamp.x ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.x += filterClamp.z;\n            } else if (fillMode == MIRROR) {\n                coord.x *= -filterClamp.z;\n            }\n        }\n\n        if( coord.y > filterClamp.w ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.y -= filterClamp.w;\n            } else if (fillMode == MIRROR) {\n                coord.y = filterClamp.w * 2.0 - coord.y;\n            }\n        } else if( coord.y < filterClamp.y ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.y += filterClamp.w;\n            } else if (fillMode == MIRROR) {\n                coord.y *= -filterClamp.w;\n            }\n        }\n    }\n\n    gl_FragColor.r = texture2D(uSampler, coord + red * (1.0 - seed * 0.4) / filterArea.xy).r;\n    gl_FragColor.g = texture2D(uSampler, coord + green * (1.0 - seed * 0.3) / filterArea.xy).g;\n    gl_FragColor.b = texture2D(uSampler, coord + blue * (1.0 - seed * 0.2) / filterArea.xy).b;\n    gl_FragColor.a = texture2D(uSampler, coord).a;\n}\n',
		GlitchFilter = (function (t) {
			function e(i) {
				var r = t.call(this, vertex, fragment) || this;
				return (
					(r.offset = 100),
					(r.fillMode = e.TRANSPARENT),
					(r.average = !1),
					(r.seed = 0),
					(r.minSize = 8),
					(r.sampleSize = 512),
					(r._slices = 0),
					(r._offsets = new Float32Array(1)),
					(r._sizes = new Float32Array(1)),
					(r._direction = -1),
					(r.uniforms.dimensions = new Float32Array(2)),
					(r._canvas = document.createElement('canvas')),
					(r._canvas.width = 4),
					(r._canvas.height = r.sampleSize),
					(r.texture = Texture$1.from(r._canvas, {
						scaleMode: SCALE_MODES$3.NEAREST,
					})),
					Object.assign(r, e.defaults, i),
					r
				);
			}
			return (
				__extends(e, t),
				(e.prototype.apply = function (t, e, i, r) {
					var s = e.filterFrame,
						n = s.width,
						a = s.height;
					(this.uniforms.dimensions[0] = n),
						(this.uniforms.dimensions[1] = a),
						(this.uniforms.aspect = a / n),
						(this.uniforms.seed = this.seed),
						(this.uniforms.offset = this.offset),
						(this.uniforms.fillMode = this.fillMode),
						t.applyFilter(this, e, i, r);
				}),
				(e.prototype._randomizeSizes = function () {
					var t = this._sizes,
						e = this._slices - 1,
						i = this.sampleSize,
						r = Math.min(this.minSize / i, 0.9 / this._slices);
					if (this.average) {
						for (var s = this._slices, n = 1, a = 0; a < e; a++) {
							var o = n / (s - a),
								h = Math.max(o * (1 - 0.6 * Math.random()), r);
							(t[a] = h), (n -= h);
						}
						t[e] = n;
					} else {
						n = 1;
						var u = Math.sqrt(1 / this._slices);
						for (a = 0; a < e; a++)
							(h = Math.max(u * n * Math.random(), r)), (t[a] = h), (n -= h);
						t[e] = n;
					}
					this.shuffle();
				}),
				(e.prototype.shuffle = function () {
					for (var t = this._sizes, e = this._slices - 1; e > 0; e--) {
						var i = (Math.random() * e) >> 0,
							r = t[e];
						(t[e] = t[i]), (t[i] = r);
					}
				}),
				(e.prototype._randomizeOffsets = function () {
					for (var t = 0; t < this._slices; t++)
						this._offsets[t] = Math.random() * (Math.random() < 0.5 ? -1 : 1);
				}),
				(e.prototype.refresh = function () {
					this._randomizeSizes(), this._randomizeOffsets(), this.redraw();
				}),
				(e.prototype.redraw = function () {
					var t,
						e = this.sampleSize,
						i = this.texture,
						r = this._canvas.getContext('2d');
					r.clearRect(0, 0, 8, e);
					for (var s = 0, n = 0; n < this._slices; n++) {
						t = Math.floor(256 * this._offsets[n]);
						var a = this._sizes[n] * e,
							o = t > 0 ? t : 0,
							h = t < 0 ? -t : 0;
						(r.fillStyle = 'rgba(' + o + ', ' + h + ', 0, 1)'),
							r.fillRect(0, s >> 0, e, (a + 1) >> 0),
							(s += a);
					}
					i.baseTexture.update(), (this.uniforms.displacementMap = i);
				}),
				Object.defineProperty(e.prototype, 'sizes', {
					get: function () {
						return this._sizes;
					},
					set: function (t) {
						for (var e = Math.min(this._slices, t.length), i = 0; i < e; i++)
							this._sizes[i] = t[i];
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'offsets', {
					get: function () {
						return this._offsets;
					},
					set: function (t) {
						for (var e = Math.min(this._slices, t.length), i = 0; i < e; i++)
							this._offsets[i] = t[i];
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'slices', {
					get: function () {
						return this._slices;
					},
					set: function (t) {
						this._slices !== t &&
							((this._slices = t),
							(this.uniforms.slices = t),
							(this._sizes = this.uniforms.slicesWidth = new Float32Array(t)),
							(this._offsets = this.uniforms.slicesOffset =
								new Float32Array(t)),
							this.refresh());
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'direction', {
					get: function () {
						return this._direction;
					},
					set: function (t) {
						if (this._direction !== t) {
							this._direction = t;
							var e = t * DEG_TO_RAD;
							(this.uniforms.sinDir = Math.sin(e)),
								(this.uniforms.cosDir = Math.cos(e));
						}
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'red', {
					get: function () {
						return this.uniforms.red;
					},
					set: function (t) {
						this.uniforms.red = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'green', {
					get: function () {
						return this.uniforms.green;
					},
					set: function (t) {
						this.uniforms.green = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(e.prototype, 'blue', {
					get: function () {
						return this.uniforms.blue;
					},
					set: function (t) {
						this.uniforms.blue = t;
					},
					enumerable: !1,
					configurable: !0,
				}),
				(e.prototype.destroy = function () {
					var t;
					null === (t = this.texture) || void 0 === t || t.destroy(!0),
						(this.texture =
							this._canvas =
							this.red =
							this.green =
							this.blue =
							this._sizes =
							this._offsets =
								null);
				}),
				(e.defaults = {
					slices: 5,
					offset: 100,
					direction: 0,
					fillMode: 0,
					average: !1,
					seed: 0,
					red: [0, 0],
					green: [0, 0],
					blue: [0, 0],
					minSize: 8,
					sampleSize: 512,
				}),
				(e.TRANSPARENT = 0),
				(e.ORIGINAL = 1),
				(e.LOOP = 2),
				(e.CLAMP = 3),
				(e.MIRROR = 4),
				e
			);
		})(Filter$1);
	Renderer$1.registerPlugin('batch', BatchRenderer),
		Renderer$1.registerPlugin('extract', Extract),
		Renderer$1.registerPlugin('tilingSprite', TilingSpriteRenderer),
		Renderer$1.registerPlugin('tilemap', TileRenderer),
		CanvasRenderer.registerPlugin('extract', CanvasExtract),
		CanvasRenderer.registerPlugin('graphics', CanvasGraphicsRenderer),
		CanvasRenderer.registerPlugin('mesh', CanvasMeshRenderer),
		CanvasRenderer.registerPlugin('sprite', CanvasSpriteRenderer),
		CanvasRenderer.registerPlugin('tilemap', CanvasTileRenderer),
		Application.registerPlugin(TickerPlugin);
	const filters = {
		AlphaFilter,
		ColorMatrixFilter,
		PixelateFilter,
		CRTFilter,
		ShockwaveFilter,
		RGBSplitFilter,
		AdvancedBloomFilter,
		MotionBlurFilter,
		KawaseBlurFilter,
		GlitchFilter,
	};
	var PIXI = Object.freeze({
		__proto__: null,
		utils,
		filters,
		get ALPHA_MODES() {
			return ALPHA_MODES$9;
		},
		get BLEND_MODES() {
			return BLEND_MODES$9;
		},
		get BUFFER_BITS() {
			return BUFFER_BITS$9;
		},
		get BUFFER_TYPE() {
			return BUFFER_TYPE$9;
		},
		get CLEAR_MODES() {
			return CLEAR_MODES$9;
		},
		get DRAW_MODES() {
			return DRAW_MODES$9;
		},
		get ENV() {
			return ENV$9;
		},
		get FORMATS() {
			return FORMATS$9;
		},
		get GC_MODES() {
			return GC_MODES$9;
		},
		get MASK_TYPES() {
			return MASK_TYPES$9;
		},
		get MIPMAP_MODES() {
			return MIPMAP_MODES$9;
		},
		get MSAA_QUALITY() {
			return MSAA_QUALITY$9;
		},
		get PRECISION() {
			return PRECISION$9;
		},
		get RENDERER_TYPE() {
			return RENDERER_TYPE$9;
		},
		get SAMPLER_TYPES() {
			return SAMPLER_TYPES$9;
		},
		get SCALE_MODES() {
			return SCALE_MODES$9;
		},
		get TARGETS() {
			return TARGETS$9;
		},
		get TYPES() {
			return TYPES$9;
		},
		get WRAP_MODES() {
			return WRAP_MODES$9;
		},
		Circle,
		DEG_TO_RAD: DEG_TO_RAD$1,
		Ellipse,
		Matrix: Matrix$3,
		ObservablePoint: ObservablePoint$3,
		PI_2: PI_2$3,
		Point: Point$4,
		Polygon,
		RAD_TO_DEG: RAD_TO_DEG$1,
		Rectangle: Rectangle$4,
		RoundedRectangle,
		get SHAPES() {
			return SHAPES$3;
		},
		Transform: Transform$1,
		groupD8: groupD8$3,
		Runner: Runner$3,
		isMobile: isMobile$3,
		settings: settings$4,
		Ticker: Ticker$3,
		TickerPlugin,
		get UPDATE_PRIORITY() {
			return UPDATE_PRIORITY$3;
		},
		Bounds: Bounds$2,
		Container: Container$2,
		DisplayObject: DisplayObject$2,
		TemporaryDisplayObject: TemporaryDisplayObject$2,
		AbstractBatchRenderer: AbstractBatchRenderer$3,
		AbstractMultiResource: AbstractMultiResource$3,
		AbstractRenderer: AbstractRenderer$3,
		ArrayResource: ArrayResource$3,
		Attribute: Attribute$3,
		BaseImageResource: BaseImageResource$3,
		BaseRenderTexture: BaseRenderTexture$3,
		BaseTexture: BaseTexture$3,
		BatchDrawCall: BatchDrawCall$3,
		BatchGeometry: BatchGeometry$3,
		BatchPluginFactory: BatchPluginFactory$3,
		BatchRenderer,
		BatchShaderGenerator: BatchShaderGenerator$3,
		BatchSystem: BatchSystem$3,
		BatchTextureArray: BatchTextureArray$3,
		Buffer: Buffer$3,
		BufferResource: BufferResource$3,
		CanvasResource: CanvasResource$3,
		ContextSystem: ContextSystem$3,
		CubeResource: CubeResource$3,
		Filter: Filter$3,
		FilterState: FilterState$3,
		FilterSystem: FilterSystem$3,
		Framebuffer: Framebuffer$3,
		FramebufferSystem: FramebufferSystem$3,
		GLFramebuffer: GLFramebuffer$3,
		GLProgram: GLProgram$3,
		GLTexture: GLTexture$3,
		Geometry: Geometry$3,
		GeometrySystem: GeometrySystem$3,
		IGLUniformData,
		INSTALLED: INSTALLED$3,
		ImageBitmapResource: ImageBitmapResource$3,
		ImageResource: ImageResource$3,
		MaskData: MaskData$3,
		MaskSystem: MaskSystem$3,
		ObjectRenderer: ObjectRenderer$3,
		Program: Program$3,
		ProjectionSystem: ProjectionSystem$3,
		Quad: Quad$3,
		QuadUv: QuadUv$3,
		RenderTexture: RenderTexture$3,
		RenderTexturePool: RenderTexturePool$3,
		RenderTextureSystem: RenderTextureSystem$3,
		Renderer: Renderer$1,
		Resource: Resource$3,
		SVGResource: SVGResource$3,
		ScissorSystem: ScissorSystem$3,
		Shader: Shader$3,
		ShaderSystem: ShaderSystem$3,
		SpriteMaskFilter: SpriteMaskFilter$3,
		State: State$3,
		StateSystem: StateSystem$3,
		StencilSystem: StencilSystem$3,
		System,
		Texture: Texture$3,
		TextureGCSystem: TextureGCSystem$3,
		TextureMatrix: TextureMatrix$3,
		TextureSystem: TextureSystem$3,
		TextureUvs: TextureUvs$3,
		UniformGroup: UniformGroup$3,
		VideoResource: VideoResource$3,
		ViewableBuffer: ViewableBuffer$3,
		autoDetectRenderer,
		autoDetectResource: autoDetectResource$3,
		checkMaxIfStatementsInShader: checkMaxIfStatementsInShader$3,
		createUBOElements: createUBOElements$3,
		defaultFilterVertex,
		defaultVertex: defaultVertex$1$2,
		generateProgram: generateProgram$3,
		generateUniformBufferSync: generateUniformBufferSync$3,
		getTestContext: getTestContext$3,
		getUBOData: getUBOData$3,
		resources,
		systems,
		uniformParsers: uniformParsers$3,
		Extract,
		Mesh,
		MeshBatchUvs,
		MeshGeometry,
		MeshMaterial,
		Sprite: Sprite$1,
		CanvasRenderer,
		canUseNewCanvasBlendModes,
		canvasUtils,
		CanvasExtract,
		Application,
		FillStyle,
		GRAPHICS_CURVES,
		Graphics: Graphics$1,
		GraphicsData,
		GraphicsGeometry,
		get LINE_CAP() {
			return LINE_CAP;
		},
		get LINE_JOIN() {
			return LINE_JOIN;
		},
		LineStyle,
		graphicsUtils,
		NineSlicePlane,
		PlaneGeometry,
		RopeGeometry,
		SimpleMesh,
		SimplePlane,
		SimpleRope,
		TilingSprite: TilingSprite$1,
		TilingSpriteRenderer,
		CanvasSpriteRenderer,
		BitmapFont,
		BitmapFontData,
		BitmapFontLoader,
		BitmapText,
		get TEXT_GRADIENT() {
			return TEXT_GRADIENT;
		},
		Text,
		TextMetrics,
		TextStyle,
		CanvasGraphicsRenderer,
		CanvasMeshRenderer,
	});
	function createCommonjsModule(t, e) {
		return t((e = { exports: {} }), e.exports), e.exports;
	}
	createCommonjsModule(function (t) {
		var e = (function (t) {
			var e,
				i = Object.prototype,
				r = i.hasOwnProperty,
				s = 'function' == typeof Symbol ? Symbol : {},
				n = s.iterator || '@@iterator',
				a = s.asyncIterator || '@@asyncIterator',
				o = s.toStringTag || '@@toStringTag';
			function h(t, e, i) {
				return (
					Object.defineProperty(t, e, {
						value: i,
						enumerable: !0,
						configurable: !0,
						writable: !0,
					}),
					t[e]
				);
			}
			try {
				h({}, '');
			} catch (t) {
				h = function (t, e, i) {
					return (t[e] = i);
				};
			}
			function u(t, e, i, r) {
				var s = e && e.prototype instanceof _ ? e : _,
					n = Object.create(s.prototype),
					a = new M(r || []);
				return (
					(n._invoke = (function (t, e, i) {
						var r = c;
						return function (s, n) {
							if (r === p) throw new Error('Generator is already running');
							if (r === f) {
								if ('throw' === s) throw n;
								return C();
							}
							for (i.method = s, i.arg = n; ; ) {
								var a = i.delegate;
								if (a) {
									var o = A(a, i);
									if (o) {
										if (o === m) continue;
										return o;
									}
								}
								if ('next' === i.method) i.sent = i._sent = i.arg;
								else if ('throw' === i.method) {
									if (r === c) throw ((r = f), i.arg);
									i.dispatchException(i.arg);
								} else 'return' === i.method && i.abrupt('return', i.arg);
								r = p;
								var h = l(t, e, i);
								if ('normal' === h.type) {
									if (((r = i.done ? f : d), h.arg === m)) continue;
									return { value: h.arg, done: i.done };
								}
								'throw' === h.type &&
									((r = f), (i.method = 'throw'), (i.arg = h.arg));
							}
						};
					})(t, i, a)),
					n
				);
			}
			function l(t, e, i) {
				try {
					return { type: 'normal', arg: t.call(e, i) };
				} catch (t) {
					return { type: 'throw', arg: t };
				}
			}
			t.wrap = u;
			var c = 'suspendedStart',
				d = 'suspendedYield',
				p = 'executing',
				f = 'completed',
				m = {};
			function _() {}
			function g() {}
			function E() {}
			var y = {};
			y[n] = function () {
				return this;
			};
			var T = Object.getPrototypeOf,
				v = T && T(T(w([])));
			v && v !== i && r.call(v, n) && (y = v);
			var S = (E.prototype = _.prototype = Object.create(y));
			function x(t) {
				['next', 'throw', 'return'].forEach(function (e) {
					h(t, e, function (t) {
						return this._invoke(e, t);
					});
				});
			}
			function b(t, e) {
				function i(s, n, a, o) {
					var h = l(t[s], t, n);
					if ('throw' !== h.type) {
						var u = h.arg,
							c = u.value;
						return c && 'object' == typeof c && r.call(c, '__await')
							? e.resolve(c.__await).then(
									function (t) {
										i('next', t, a, o);
									},
									function (t) {
										i('throw', t, a, o);
									}
							  )
							: e.resolve(c).then(
									function (t) {
										(u.value = t), a(u);
									},
									function (t) {
										return i('throw', t, a, o);
									}
							  );
					}
					o(h.arg);
				}
				var s;
				this._invoke = function (t, r) {
					function n() {
						return new e(function (e, s) {
							i(t, r, e, s);
						});
					}
					return (s = s ? s.then(n, n) : n());
				};
			}
			function A(t, i) {
				var r = t.iterator[i.method];
				if (r === e) {
					if (((i.delegate = null), 'throw' === i.method)) {
						if (
							t.iterator.return &&
							((i.method = 'return'),
							(i.arg = e),
							A(t, i),
							'throw' === i.method)
						)
							return m;
						(i.method = 'throw'),
							(i.arg = new TypeError(
								"The iterator does not provide a 'throw' method"
							));
					}
					return m;
				}
				var s = l(r, t.iterator, i.arg);
				if ('throw' === s.type)
					return (i.method = 'throw'), (i.arg = s.arg), (i.delegate = null), m;
				var n = s.arg;
				return n
					? n.done
						? ((i[t.resultName] = n.value),
						  (i.next = t.nextLoc),
						  'return' !== i.method && ((i.method = 'next'), (i.arg = e)),
						  (i.delegate = null),
						  m)
						: n
					: ((i.method = 'throw'),
					  (i.arg = new TypeError('iterator result is not an object')),
					  (i.delegate = null),
					  m);
			}
			function R(t) {
				var e = { tryLoc: t[0] };
				1 in t && (e.catchLoc = t[1]),
					2 in t && ((e.finallyLoc = t[2]), (e.afterLoc = t[3])),
					this.tryEntries.push(e);
			}
			function I(t) {
				var e = t.completion || {};
				(e.type = 'normal'), delete e.arg, (t.completion = e);
			}
			function M(t) {
				(this.tryEntries = [{ tryLoc: 'root' }]),
					t.forEach(R, this),
					this.reset(!0);
			}
			function w(t) {
				if (t) {
					var i = t[n];
					if (i) return i.call(t);
					if ('function' == typeof t.next) return t;
					if (!isNaN(t.length)) {
						var s = -1,
							a = function i() {
								for (; ++s < t.length; )
									if (r.call(t, s)) return (i.value = t[s]), (i.done = !1), i;
								return (i.value = e), (i.done = !0), i;
							};
						return (a.next = a);
					}
				}
				return { next: C };
			}
			function C() {
				return { value: e, done: !0 };
			}
			return (
				(g.prototype = S.constructor = E),
				(E.constructor = g),
				(g.displayName = h(E, o, 'GeneratorFunction')),
				(t.isGeneratorFunction = function (t) {
					var e = 'function' == typeof t && t.constructor;
					return (
						!!e &&
						(e === g || 'GeneratorFunction' === (e.displayName || e.name))
					);
				}),
				(t.mark = function (t) {
					return (
						Object.setPrototypeOf
							? Object.setPrototypeOf(t, E)
							: ((t.__proto__ = E), h(t, o, 'GeneratorFunction')),
						(t.prototype = Object.create(S)),
						t
					);
				}),
				(t.awrap = function (t) {
					return { __await: t };
				}),
				x(b.prototype),
				(b.prototype[a] = function () {
					return this;
				}),
				(t.AsyncIterator = b),
				(t.async = function (e, i, r, s, n) {
					void 0 === n && (n = Promise);
					var a = new b(u(e, i, r, s), n);
					return t.isGeneratorFunction(i)
						? a
						: a.next().then(function (t) {
								return t.done ? t.value : a.next();
						  });
				}),
				x(S),
				h(S, o, 'Generator'),
				(S[n] = function () {
					return this;
				}),
				(S.toString = function () {
					return '[object Generator]';
				}),
				(t.keys = function (t) {
					var e = [];
					for (var i in t) e.push(i);
					return (
						e.reverse(),
						function i() {
							for (; e.length; ) {
								var r = e.pop();
								if (r in t) return (i.value = r), (i.done = !1), i;
							}
							return (i.done = !0), i;
						}
					);
				}),
				(t.values = w),
				(M.prototype = {
					constructor: M,
					reset: function (t) {
						if (
							((this.prev = 0),
							(this.next = 0),
							(this.sent = this._sent = e),
							(this.done = !1),
							(this.delegate = null),
							(this.method = 'next'),
							(this.arg = e),
							this.tryEntries.forEach(I),
							!t)
						)
							for (var i in this)
								't' === i.charAt(0) &&
									r.call(this, i) &&
									!isNaN(+i.slice(1)) &&
									(this[i] = e);
					},
					stop: function () {
						this.done = !0;
						var t = this.tryEntries[0].completion;
						if ('throw' === t.type) throw t.arg;
						return this.rval;
					},
					dispatchException: function (t) {
						if (this.done) throw t;
						var i = this;
						function s(r, s) {
							return (
								(o.type = 'throw'),
								(o.arg = t),
								(i.next = r),
								s && ((i.method = 'next'), (i.arg = e)),
								!!s
							);
						}
						for (var n = this.tryEntries.length - 1; n >= 0; --n) {
							var a = this.tryEntries[n],
								o = a.completion;
							if ('root' === a.tryLoc) return s('end');
							if (a.tryLoc <= this.prev) {
								var h = r.call(a, 'catchLoc'),
									u = r.call(a, 'finallyLoc');
								if (h && u) {
									if (this.prev < a.catchLoc) return s(a.catchLoc, !0);
									if (this.prev < a.finallyLoc) return s(a.finallyLoc);
								} else if (h) {
									if (this.prev < a.catchLoc) return s(a.catchLoc, !0);
								} else {
									if (!u)
										throw new Error('try statement without catch or finally');
									if (this.prev < a.finallyLoc) return s(a.finallyLoc);
								}
							}
						}
					},
					abrupt: function (t, e) {
						for (var i = this.tryEntries.length - 1; i >= 0; --i) {
							var s = this.tryEntries[i];
							if (
								s.tryLoc <= this.prev &&
								r.call(s, 'finallyLoc') &&
								this.prev < s.finallyLoc
							) {
								var n = s;
								break;
							}
						}
						n &&
							('break' === t || 'continue' === t) &&
							n.tryLoc <= e &&
							e <= n.finallyLoc &&
							(n = null);
						var a = n ? n.completion : {};
						return (
							(a.type = t),
							(a.arg = e),
							n
								? ((this.method = 'next'), (this.next = n.finallyLoc), m)
								: this.complete(a)
						);
					},
					complete: function (t, e) {
						if ('throw' === t.type) throw t.arg;
						return (
							'break' === t.type || 'continue' === t.type
								? (this.next = t.arg)
								: 'return' === t.type
								? ((this.rval = this.arg = t.arg),
								  (this.method = 'return'),
								  (this.next = 'end'))
								: 'normal' === t.type && e && (this.next = e),
							m
						);
					},
					finish: function (t) {
						for (var e = this.tryEntries.length - 1; e >= 0; --e) {
							var i = this.tryEntries[e];
							if (i.finallyLoc === t)
								return this.complete(i.completion, i.afterLoc), I(i), m;
						}
					},
					catch: function (t) {
						for (var e = this.tryEntries.length - 1; e >= 0; --e) {
							var i = this.tryEntries[e];
							if (i.tryLoc === t) {
								var r = i.completion;
								if ('throw' === r.type) {
									var s = r.arg;
									I(i);
								}
								return s;
							}
						}
						throw new Error('illegal catch attempt');
					},
					delegateYield: function (t, i, r) {
						return (
							(this.delegate = { iterator: w(t), resultName: i, nextLoc: r }),
							'next' === this.method && (this.arg = e),
							m
						);
					},
				}),
				t
			);
		})(t.exports);
		try {
			regeneratorRuntime = e;
		} catch (t) {
			Function('r', 'regeneratorRuntime = r')(e);
		}
	}),
		(Number.prototype.clamp = function (t, e) {
			return Math.min(Math.max(this, t), e);
		}),
		(Number.prototype.mod = function (t) {
			return ((this % t) + t) % t;
		}),
		(String.prototype.format = function () {
			const t = arguments;
			return this.replace(/%([0-9]+)/g, (e, i) => t[Number(i) - 1]);
		}),
		(String.prototype.padZero = function (t) {
			let e = this;
			for (; e.length < t; ) e = `0${e}`;
			return e;
		}),
		(Number.prototype.padZero = function (t) {
			return String(this).padZero(t);
		}),
		Object.defineProperties(Array.prototype, {
			equals: {
				enumerable: !1,
				value(t) {
					if (!t || this.length !== t.length) return !1;
					for (let e = 0; e < this.length; e++)
						if (this[e] instanceof Array && t[e] instanceof Array) {
							if (!this[e].equals(t[e])) return !1;
						} else if (this[e] !== t[e]) return !1;
					return !0;
				},
			},
			clone: {
				enumerable: !1,
				value() {
					return this.slice(0);
				},
			},
			contains: {
				enumerable: !1,
				value(t) {
					return this.includes(t);
				},
			},
		}),
		(String.prototype.contains = function (t) {
			return this.includes(t);
		}),
		(Math.randomInt = (t) => Math.floor(t * Math.random()));
	class CacheEntry {
		constructor(t, e, i) {
			(this.cache = t),
				(this.key = e),
				(this.item = i),
				(this.cached = !1),
				(this.touchTicks = 0),
				(this.touchSeconds = 0),
				(this.ttlTicks = 0),
				(this.ttlSeconds = 0),
				(this.freedByTTL = !1);
		}
		free(t) {
			(this.freedByTTL = t || !1),
				this.cached && ((this.cached = !1), delete this.cache._inner[this.key]);
		}
		allocate() {
			return (
				this.cached ||
					((this.cache._inner[this.key] = this), (this.cached = !0)),
				this.touch(),
				this
			);
		}
		setTimeToLive(t, e) {
			return (this.ttlTicks = t || 0), (this.ttlSeconds = e || 0), this;
		}
		isStillAlive() {
			const t = this.cache;
			return (
				(0 == this.ttlTicks ||
					this.touchTicks + this.ttlTicks < t.updateTicks) &&
				(0 == this.ttlSeconds ||
					this.touchSeconds + this.ttlSeconds < t.updateSeconds)
			);
		}
		touch() {
			const t = this.cache;
			this.cached
				? ((this.touchTicks = t.updateTicks),
				  (this.touchSeconds = t.updateSeconds))
				: this.freedByTTL &&
				  ((this.freedByTTL = !1),
				  t._inner[this.key] || (t._inner[this.key] = this));
		}
	}
	class CacheMap {
		constructor(t) {
			(this.manager = t),
				(this._inner = {}),
				(this._lastRemovedEntries = {}),
				(this.updateTicks = 0),
				(this.lastCheckTTL = 0),
				(this.delayCheckTTL = 100),
				(this.updateSeconds = Date.now());
		}
		checkTTL() {
			const t = this._inner;
			let e = this._lastRemovedEntries;
			e || ((e = []), (this._lastRemovedEntries = e));
			for (let i in t) {
				const r = t[i];
				r.isStillAlive() || e.push(r);
			}
			for (let t = 0; t < e.length; t++) e[t].free(!0);
			e.length = 0;
		}
		getItem(t) {
			const e = this._inner[t];
			return e ? e.item : null;
		}
		clear() {
			const t = Object.keys(this._inner);
			for (let e = 0; e < t.length; e++) this._inner[t[e]].free();
		}
		setItem(t, e) {
			return new CacheEntry(this, t, e).allocate();
		}
		update(t, e) {
			(this.updateTicks += t),
				(this.updateSeconds += e),
				this.updateSeconds >= this.delayCheckTTL + this.lastCheckTTL &&
					((this.lastCheckTTL = this.updateSeconds), this.checkTTL());
		}
	}
	class ImageCache {
		constructor(...t) {
			this.initialize(...t);
		}
		initialize() {
			this._items = {};
		}
		add(t, e) {
			(this._items[t] = { bitmap: e, touch: Date.now(), key: t }),
				this._truncateCache();
		}
		get(t) {
			if (this._items[t]) {
				const e = this._items[t];
				return (e.touch = Date.now()), e.bitmap;
			}
			return null;
		}
		reserve(t, e, i) {
			this._items[t] ||
				(this._items[t] = { bitmap: e, touch: Date.now(), key: t }),
				(this._items[t].reservationId = i);
		}
		releaseReservation(t) {
			const e = this._items;
			Object.keys(e)
				.map((t) => e[t])
				.forEach((e) => {
					e.reservationId === t && delete e.reservationId;
				});
		}
		_truncateCache() {
			const t = this._items;
			let e = ImageCache.limit;
			Object.keys(t)
				.map((e) => t[e])
				.sort((t, e) => t.touch - e.touch)
				.forEach((i) => {
					if (e > 0 || this._mustBeHeld(i)) {
						const t = i.bitmap;
						e -= t.width * t.height;
					} else delete t[i.key];
				});
		}
		_mustBeHeld({ bitmap: t, reservationId: e }) {
			return !(t.isRequestOnly() || (!e && t.isReady()));
		}
		isReady() {
			const t = this._items;
			return !Object.keys(t).some(
				(e) => !t[e].bitmap.isRequestOnly() && !t[e].bitmap.isReady()
			);
		}
		getErrorBitmap() {
			const t = this._items;
			let e = null;
			return Object.keys(t).some(
				(i) => !!t[i].bitmap.isError() && ((e = t[i].bitmap), !0)
			)
				? e
				: null;
		}
	}
	ImageCache.limit = 1e7;
	class RequestQueue {
		constructor(...t) {
			this.initialize(...t);
		}
		initialize() {
			this._queue = [];
		}
		enqueue(t, e) {
			this._queue.push({ key: t, value: e });
		}
		update() {
			if (0 === this._queue.length) return;
			const t = this._queue[0];
			t.value.isRequestReady()
				? (this._queue.shift(),
				  0 !== this._queue.length && this._queue[0].value.startRequest())
				: t.value.startRequest();
		}
		raisePriority(t) {
			for (let e = 0; e < this._queue.length; e++) {
				const i = this._queue[e];
				if (i.key === t) {
					this._queue.splice(e, 1), this._queue.unshift(i);
					break;
				}
			}
		}
		clear() {
			this._queue.splice(0);
		}
	}
	class Utils {
		constructor() {
			throw new Error('This is a static class');
		}
		static isOptionValid(t) {
			return (
				!!location.search.slice(1).split('&').contains(t) ||
				!!(
					'undefined' != typeof nw &&
					nw.App.argv.length > 0 &&
					nw.App.argv[0].split('&').contains(t)
				)
			);
		}
		static isNwjs() {
			if ('boolean' == typeof Utils._nwjs) return Utils._nwjs;
			const t = 'function' == typeof require && 'object' == typeof process;
			return (Utils._nwjs = t), t;
		}
		static isTauri() {
			return !!window.__TAURI__;
		}
		static isHighFps() {
			return Utils._fpsChecked ? Utils._highFps : Utils.getFps() >= 66;
		}
		/**
		 * Returns estimated monitor refresh rate.
		 *
		 * @static
		 * @method getFps
		 * @return {Number} Refresh rate
		 * @credit Adapted from Adam Sassano on Stack Overflow
		 * @license CC BY-SA 4.0
		 */ static getFps() {
			if (Utils._fpsChecked || Utils._fpsIsBusyCounting) return Utils._fps;
			{
				let t = 0,
					e = 0,
					i = 0;
				const r = (s) => {
					e <= 180
						? (e++, (i += 1e3 / (s - t)), (t = s), requestAnimationFrame(r))
						: (Utils._fps !== 1 / 0 &&
								((Utils._fps = i / e),
								Utils._fps >= 66 && (Utils._highFps = !0)),
						  (Utils._fpsChecked = !0),
						  (Utils._fpsIsBusyCounting = !1));
				};
				return (
					requestAnimationFrame((e) => {
						(t = e), requestAnimationFrame(r);
					}),
					(Utils._fpsIsBusyCounting = !0),
					Utils._fps
				);
			}
		}
		static isMobileDevice() {
			if ('boolean' == typeof Utils._mobileDevice) return Utils._mobileDevice;
			const t = !!navigator.userAgent.match(
				/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i
			);
			return (Utils._mobileDevice = t), t;
		}
		static isMobileSafari() {
			if ('boolean' == typeof Utils._mobileSafari) return Utils._mobileSafari;
			const t = navigator.userAgent,
				e = !(
					!t.match(/iPhone|iPad|iPod/) ||
					!t.match(/AppleWebKit/) ||
					t.match('CriOS')
				);
			return (Utils._mobileSafari = e), e;
		}
		static isAndroidChrome() {
			if ('boolean' == typeof Utils._androidChrome) return Utils._androidChrome;
			const t = navigator.userAgent,
				e = !(!t.match(/Android/) || !t.match(/Chrome/));
			return (Utils._androidChrome = e), e;
		}
		static canReadGameFiles() {
			const t = document.getElementsByTagName('script'),
				e = t[t.length - 1],
				i = new XMLHttpRequest();
			try {
				return (
					i.open('GET', e.src),
					i.overrideMimeType('text/javascript'),
					i.send(),
					!0
				);
			} catch (t) {
				return !1;
			}
		}
		static rgbToCssColor(t, e, i) {
			return `rgb(${(t = Math.round(t))},${(e = Math.round(e))},${(i =
				Math.round(i))})`;
		}
		static generateRuntimeId() {
			return Utils._id++;
		}
		static isSupportPassiveEvent() {
			if ('boolean' == typeof Utils._supportPassiveEvent)
				return Utils._supportPassiveEvent;
			let t = !1;
			const e = Object.defineProperty({}, 'passive', {
				get() {
					t = !0;
				},
			});
			return (
				window.addEventListener('test', null, e),
				(Utils._supportPassiveEvent = t),
				t
			);
		}
		static isWorker() {
			return 'function' == typeof importScripts;
		}
		static loadScript(t, e) {
			if (this.isWorker()) return importScripts(t), null;
			{
				const i = document.createElement('script');
				return (
					(i.type = e ? 'module' : 'text/javascript'),
					(i.src = t),
					(i.async = !1),
					document.body.appendChild(i),
					i
				);
			}
		}
		static getThrottledFunction(t, e, i) {
			let r, s;
			return function () {
				const n = i || this,
					a = +new Date(),
					o = arguments;
				r && a < r + e
					? (clearTimeout(s),
					  (s = setTimeout(() => {
							(r = a), t.apply(n, o);
					  }, e + r - a)))
					: ((r = a), t.apply(n, o));
			};
		}
	}
	(Utils.RPGMAKER_NAME = 'MV'),
		(Utils.RPGMAKER_VERSION = '1.6.1'),
		(Utils.RPGMAKER_ENGINE = 'community-1.4'),
		(Utils._nwjs = null),
		(Utils._highFps = !1),
		(Utils._fps = 60),
		(Utils._fpsIsBusyCounting = !1),
		(Utils._fpsChecked = !1),
		(Utils._mobileDevice = null),
		(Utils._mobileSafari = null),
		(Utils._androidChrome = null),
		(Utils._id = 1),
		(Utils._supportPassiveEvent = null);
	class Decrypter {
		constructor() {
			throw new Error('This is a static class');
		}
		static checkImgIgnore(t) {
			for (let e = 0; e < this._ignoreList.length; e++)
				if (t === this._ignoreList[e]) return !0;
			return !1;
		}
		static decryptImg(t, e) {
			t = this.extToEncryptExt(t);
			const i = new XMLHttpRequest();
			i.open('GET', t),
				(i.responseType = 'arraybuffer'),
				i.send(),
				(i.onload = function () {
					if (this.status < Decrypter._xhrOk) {
						const t = Decrypter.decryptArrayBuffer(i.response);
						(e._image.src = Decrypter.createBlobUrl(t)),
							e._image.addEventListener(
								'load',
								(e._loadListener = Bitmap.prototype._onLoad.bind(e))
							),
							e._image.addEventListener(
								'error',
								(e._errorListener =
									e._loader || Bitmap.prototype._onError.bind(e))
							);
					}
				}),
				(i.onerror = () => {
					e._loader ? e._loader() : e._onError();
				});
		}
		static decryptArrayBuffer(t) {
			if (!t) return null;
			const e = new Uint8Array(t, 0, this._headerlength);
			let i;
			const r = this.SIGNATURE + this.VER + this.REMAIN,
				s = new Uint8Array(16);
			for (i = 0; i < this._headerlength; i++)
				s[i] = parseInt(`0x${r.substr(2 * i, 2)}`, 16);
			for (i = 0; i < this._headerlength; i++)
				if (e[i] !== s[i]) throw new Error('Header is wrong');
			t = this.cutArrayHeader(t, Decrypter._headerlength);
			const n = new DataView(t);
			if ((this.readEncryptionkey(), t)) {
				const e = new Uint8Array(t);
				for (i = 0; i < this._headerlength; i++)
					(e[i] = e[i] ^ parseInt(Decrypter._encryptionKey[i], 16)),
						n.setUint8(i, e[i]);
			}
			return t;
		}
		static readEncryptionkey() {
			this._encryptionKey = self.$dataSystem.encryptionKey
				.split(/(.{2})/)
				.filter(Boolean);
		}
		static cutArrayHeader(t, e) {
			t.slice(e);
		}
		static createBlobUrl(t) {
			const e = new Blob([t]);
			return window.URL.createObjectURL(e);
		}
		static extToEncryptExt(t) {
			const e = t.split('.').pop();
			let i = e;
			return (
				(i =
					'ogg' === e
						? '.rpgmvo'
						: 'm4a' === e
						? '.rpgmvm'
						: 'png' === e
						? '.rpgmvp'
						: e),
				t.slice(0, t.lastIndexOf(e) - 1) + i
			);
		}
	}
	(Decrypter.hasEncryptedImages = !1),
		(Decrypter.hasEncryptedAudio = !1),
		(Decrypter._requestImgFile = []),
		(Decrypter._headerlength = 16),
		(Decrypter._xhrOk = 400),
		(Decrypter._encryptionKey = ''),
		(Decrypter._ignoreList = ['img/system/Window.png']),
		(Decrypter.SIGNATURE = '5250474d56000000'),
		(Decrypter.VER = '000301'),
		(Decrypter.REMAIN = '0000000000');
	class WebAudio {
		constructor(...t) {
			this.initialize(...t);
		}
		initialize(t) {
			WebAudio._initialized || WebAudio.initialize(),
				this.clear(),
				WebAudio._standAlone ||
					(this._loader = ResourceHandler.createLoader(
						t,
						this._load.bind(this, t),
						() => {
							this._hasError = !0;
						}
					)),
				this._load(t),
				(this._url = t);
		}
		static initialize(t) {
			return (
				this._initialized ||
					(t ||
						(this._createContext(),
						this._detectCodecs(),
						this._createMasterGainNode(),
						this._setupEventHandlers()),
					(this._initialized = !0)),
				!!this._context
			);
		}
		static canPlayOgg() {
			return this._initialized || this.initialize(), !!this._canPlayOgg;
		}
		static canPlayM4a() {
			return this._initialized || this.initialize(), !!this._canPlayM4a;
		}
		static setMasterVolume(t) {
			(this._masterVolume = t),
				this._masterGainNode &&
					this._masterGainNode.gain.setValueAtTime(
						this._masterVolume,
						this._context.currentTime
					);
		}
		static _createContext() {
			try {
				'undefined' != typeof AudioContext
					? (this._context = new AudioContext())
					: 'undefined' != typeof webkitAudioContext &&
					  (this._context = new webkitAudioContext());
			} catch (t) {
				this._context = null;
			}
		}
		static _detectCodecs() {
			const t = document.createElement('audio');
			t.canPlayType &&
				((this._canPlayOgg = t.canPlayType('audio/ogg; codecs="vorbis"')),
				(this._canPlayM4a = t.canPlayType('audio/mp4')));
		}
		static _createMasterGainNode() {
			const t = WebAudio._context;
			t &&
				((this._masterGainNode = t.createGain()),
				this._masterGainNode.gain.setValueAtTime(
					this._masterVolume,
					t.currentTime
				),
				this._masterGainNode.connect(t.destination));
		}
		static _setupEventHandlers() {
			const t = () => {
				const t = WebAudio._context;
				t && 'suspended' === t.state && 'function' == typeof t.resume
					? t.resume().then(() => {
							WebAudio._onTouchStart();
					  })
					: WebAudio._onTouchStart();
			};
			document.addEventListener('keydown', t),
				document.addEventListener('mousedown', t),
				document.addEventListener('touchend', t),
				document.addEventListener('touchstart', this._onTouchStart.bind(this)),
				document.addEventListener(
					'visibilitychange',
					this._onVisibilityChange.bind(this)
				);
		}
		static _onTouchStart() {
			const t = WebAudio._context;
			t &&
				!this._unlocked &&
				(t.createBufferSource().start(0), (this._unlocked = !0));
		}
		static _onVisibilityChange() {
			'hidden' === document.visibilityState ? this._onHide() : this._onShow();
		}
		static _onHide() {
			this._shouldMuteOnHide() && this._fadeOut(1);
		}
		static _onShow() {
			this._shouldMuteOnHide() && this._fadeIn(1);
		}
		static _fadeIn(t) {
			if (this._masterGainNode) {
				const e = this._masterGainNode.gain,
					i = WebAudio._context.currentTime;
				e.setValueAtTime(0, i),
					e.linearRampToValueAtTime(this._masterVolume, i + t);
			}
		}
		static _fadeOut(t) {
			if (this._masterGainNode) {
				const e = this._masterGainNode.gain,
					i = WebAudio._context.currentTime;
				e.setValueAtTime(this._masterVolume, i),
					e.linearRampToValueAtTime(0, i + t);
			}
		}
		clear() {
			this.stop(),
				(this._buffer = null),
				(this._sourceNode = null),
				(this._gainNode = null),
				(this._pannerNode = null),
				(this._totalTime = 0),
				(this._sampleRate = 0),
				(this._loopStart = 0),
				(this._loopLength = 0),
				(this._startTime = 0),
				(this._volume = 1),
				(this._pitch = 1),
				(this._pan = 0),
				(this._endTimer = null),
				(this._loadListeners = []),
				(this._stopListeners = []),
				(this._hasError = !1),
				(this._autoPlay = !1);
		}
		get url() {
			return this._url;
		}
		get volume() {
			return this._volume;
		}
		set volume(t) {
			(this._volume = t),
				this._gainNode &&
					this._gainNode.gain.setValueAtTime(
						this._volume,
						WebAudio._context.currentTime
					);
		}
		get pitch() {
			return this._pitch;
		}
		set pitch(t) {
			this._pitch !== t &&
				((this._pitch = t),
				this.isPlaying() && this.play(this._sourceNode.loop, 0));
		}
		get pan() {
			return this._pan;
		}
		set pan(t) {
			(this._pan = t), this._updatePanner();
		}
		isReady() {
			return !!this._buffer;
		}
		isError() {
			return this._hasError;
		}
		isPlaying() {
			return !!this._sourceNode;
		}
		play(t, e) {
			this.isReady()
				? ((e = e || 0), this._startPlaying(t, e))
				: WebAudio._context &&
				  ((this._autoPlay = !0),
				  this.addLoadListener(() => {
						this._autoPlay && this.play(t, e);
				  }));
		}
		stop() {
			if (
				((this._autoPlay = !1),
				this._removeEndTimer(),
				this._removeNodes(),
				this._stopListeners)
			)
				for (; this._stopListeners.length > 0; ) this._stopListeners.shift()();
		}
		fadeIn(t) {
			if (this.isReady()) {
				if (this._gainNode) {
					const e = this._gainNode.gain,
						i = WebAudio._context.currentTime;
					e.setValueAtTime(0, i),
						e.linearRampToValueAtTime(this._volume, i + t);
				}
			} else
				this._autoPlay &&
					this.addLoadListener(() => {
						this.fadeIn(t);
					});
		}
		fadeOut(t) {
			if (this._gainNode) {
				const e = this._gainNode.gain,
					i = WebAudio._context.currentTime;
				e.setValueAtTime(this._volume, i), e.linearRampToValueAtTime(0, i + t);
			}
			this._autoPlay = !1;
		}
		seek() {
			if (WebAudio._context) {
				let t = (WebAudio._context.currentTime - this._startTime) * this._pitch;
				if (this._loopLength > 0)
					for (; t >= this._loopStart + this._loopLength; )
						t -= this._loopLength;
				return t;
			}
			return 0;
		}
		addLoadListener(t) {
			this._loadListeners.push(t);
		}
		addStopListener(t) {
			this._stopListeners.push(t);
		}
		_load(t) {
			if (WebAudio._context) {
				const e = new XMLHttpRequest();
				Decrypter.hasEncryptedAudio && (t = Decrypter.extToEncryptExt(t)),
					e.open('GET', t),
					(e.responseType = 'arraybuffer'),
					(e.onload = () => {
						e.status < 400 && this._onXhrLoad(e);
					}),
					(e.onerror =
						this._loader ||
						(() => {
							this._hasError = !0;
						})),
					e.send();
			}
		}
		_onXhrLoad({ response: t }) {
			let e = t;
			Decrypter.hasEncryptedAudio && (e = Decrypter.decryptArrayBuffer(e)),
				this._readLoopComments(new Uint8Array(e)),
				WebAudio._context.decodeAudioData(e, (t) => {
					(this._buffer = t),
						(this._totalTime = t.duration),
						this._loopLength > 0 && this._sampleRate > 0
							? ((this._loopStart /= this._sampleRate),
							  (this._loopLength /= this._sampleRate))
							: ((this._loopStart = 0), (this._loopLength = this._totalTime)),
						this._onLoad();
				});
		}
		_startPlaying(t, e) {
			if (this._loopLength > 0)
				for (; e >= this._loopStart + this._loopLength; ) e -= this._loopLength;
			this._removeEndTimer(),
				this._removeNodes(),
				this._createNodes(),
				this._connectNodes(),
				(this._sourceNode.loop = t),
				this._sourceNode.start(0, e),
				(this._startTime = WebAudio._context.currentTime - e / this._pitch),
				this._createEndTimer();
		}
		_createNodes() {
			const t = WebAudio._context;
			(this._sourceNode = t.createBufferSource()),
				(this._sourceNode.buffer = this._buffer),
				(this._sourceNode.loopStart = this._loopStart),
				(this._sourceNode.loopEnd = this._loopStart + this._loopLength),
				this._sourceNode.playbackRate.setValueAtTime(
					this._pitch,
					t.currentTime
				),
				(this._gainNode = t.createGain()),
				this._gainNode.gain.setValueAtTime(this._volume, t.currentTime),
				(this._pannerNode = t.createPanner()),
				(this._pannerNode.panningModel = 'equalpower'),
				this._updatePanner();
		}
		_connectNodes() {
			this._sourceNode.connect(this._gainNode),
				this._gainNode.connect(this._pannerNode),
				this._pannerNode.connect(WebAudio._masterGainNode);
		}
		_removeNodes() {
			this._sourceNode &&
				(this._sourceNode.stop(0),
				(this._sourceNode = null),
				(this._gainNode = null),
				(this._pannerNode = null));
		}
		_createEndTimer() {
			if (this._sourceNode && !this._sourceNode.loop) {
				const t =
					this._startTime +
					this._totalTime / this._pitch -
					WebAudio._context.currentTime;
				this._endTimer = setTimeout(() => {
					this.stop();
				}, 1e3 * t);
			}
		}
		_removeEndTimer() {
			this._endTimer && (clearTimeout(this._endTimer), (this._endTimer = null));
		}
		_updatePanner() {
			if (this._pannerNode) {
				const t = this._pan,
					e = 1 - Math.abs(t);
				this._pannerNode.setPosition(t, 0, e);
			}
		}
		_onLoad() {
			for (; this._loadListeners.length > 0; ) this._loadListeners.shift()();
		}
		_readLoopComments(t) {
			this._readOgg(t), this._readMp4(t);
		}
		_readOgg(t) {
			let e = 0;
			for (; e < t.length && 'OggS' === this._readFourCharacters(t, e); ) {
				e += 26;
				let i = !1;
				const r = t[e++],
					s = [];
				for (let i = 0; i < r; i++) s.push(t[e++]);
				for (let n = 0; n < r; n++) {
					if ('vorb' === this._readFourCharacters(t, e + 1)) {
						const a = t[e];
						if (1 === a) this._sampleRate = this._readLittleEndian(t, e + 12);
						else if (3 === a) {
							let i = 0;
							for (; n < r && ((i += s[n]), !(s[n] < 255)); n++);
							this._readMetaData(t, e, i);
						}
						i = !0;
					}
					e += s[n];
				}
				if (!i) break;
			}
		}
		_readMp4(t) {
			if ('ftyp' === this._readFourCharacters(t, 4)) {
				let e = 0;
				for (; e < t.length; ) {
					const i = this._readBigEndian(t, e),
						r = this._readFourCharacters(t, e + 4);
					if ('moov' === r) e += 8;
					else if (
						('mvhd' === r &&
							(this._sampleRate = this._readBigEndian(t, e + 20)),
						('udta' !== r && 'meta' !== r) || this._readMetaData(t, e, i),
						(e += i),
						i <= 1)
					)
						break;
				}
			}
		}
		_readMetaData(t, e, i) {
			for (let r = e; r < e + i - 10; r++)
				if ('LOOP' === this._readFourCharacters(t, r)) {
					let e = '';
					for (; t[r] > 0; ) e += String.fromCharCode(t[r++]);
					if (
						(e.match(/LOOPSTART=([0-9]+)/) &&
							(this._loopStart = parseInt(RegExp.$1)),
						e.match(/LOOPLENGTH=([0-9]+)/) &&
							(this._loopLength = parseInt(RegExp.$1)),
						'LOOPSTART' == e || 'LOOPLENGTH' == e)
					) {
						let i = '';
						for (r += 16; t[r] > 0; ) i += String.fromCharCode(t[r++]);
						'LOOPSTART' == e
							? (this._loopStart = parseInt(i))
							: (this._loopLength = parseInt(i));
					}
				}
		}
		_readLittleEndian(t, e) {
			return 16777216 * t[e + 3] + 65536 * t[e + 2] + 256 * t[e + 1] + t[e + 0];
		}
		_readBigEndian(t, e) {
			return 16777216 * t[e + 0] + 65536 * t[e + 1] + 256 * t[e + 2] + t[e + 3];
		}
		_readFourCharacters(t, e) {
			let i = '';
			for (let r = 0; r < 4; r++) i += String.fromCharCode(t[e + r]);
			return i;
		}
		static _shouldMuteOnHide() {
			return Utils.isMobileDevice();
		}
	}
	(WebAudio._standAlone = !self.ResourceHandler),
		(WebAudio._masterVolume = 1),
		(WebAudio._context = null),
		(WebAudio._masterGainNode = null),
		(WebAudio._initialized = !1),
		(WebAudio._unlocked = !1);
	class AudioManager {
		constructor() {
			throw new Error('This is a static class');
		}
		static playBgm(t, e) {
			this.isCurrentBgm(t)
				? this.updateBgmParameters(t)
				: (this.stopBgm(),
				  t.name &&
						((this._bgmBuffer = this.createBuffer('bgm', t.name)),
						this.updateBgmParameters(t),
						this._meBuffer || this._bgmBuffer.play(!0, e || 0))),
				this.updateCurrentBgm(t, e);
		}
		static playEncryptedBgm({ name: t }, e) {
			const i = this.audioFileExt();
			let r = `${this._path}bgm/${encodeURIComponent(t)}${i}`;
			r = Decrypter.extToEncryptExt(r);
		}
		static createDecryptBuffer(t, e, i) {
			(this._blobUrl = t),
				(this._bgmBuffer = this.createBuffer('bgm', e.name)),
				this.updateBgmParameters(e),
				this._meBuffer || this._bgmBuffer.play(!0, i || 0),
				this.updateCurrentBgm(e, i);
		}
		static replayBgm(t) {
			this.isCurrentBgm(t)
				? this.updateBgmParameters(t)
				: (this.playBgm(t, t.pos),
				  this._bgmBuffer && this._bgmBuffer.fadeIn(this._replayFadeTime));
		}
		static isCurrentBgm({ name: t }) {
			return this._currentBgm && this._bgmBuffer && this._currentBgm.name === t;
		}
		static updateBgmParameters(t) {
			this.updateBufferParameters(this._bgmBuffer, this._bgmVolume, t);
		}
		static updateCurrentBgm({ name: t, volume: e, pitch: i, pan: r }, s) {
			this._currentBgm = { name: t, volume: e, pitch: i, pan: r, pos: s };
		}
		static stopBgm() {
			this._bgmBuffer &&
				(this._bgmBuffer.stop(),
				(this._bgmBuffer = null),
				(this._currentBgm = null));
		}
		static fadeOutBgm(t) {
			this._bgmBuffer &&
				this._currentBgm &&
				(this._bgmBuffer.fadeOut(t), (this._currentBgm = null));
		}
		static fadeInBgm(t) {
			this._bgmBuffer && this._currentBgm && this._bgmBuffer.fadeIn(t);
		}
		static playBgs(t, e) {
			this.isCurrentBgs(t)
				? this.updateBgsParameters(t)
				: (this.stopBgs(),
				  t.name &&
						((this._bgsBuffer = this.createBuffer('bgs', t.name)),
						this.updateBgsParameters(t),
						this._bgsBuffer.play(!0, e || 0))),
				this.updateCurrentBgs(t, e);
		}
		static replayBgs(t) {
			this.isCurrentBgs(t)
				? this.updateBgsParameters(t)
				: (this.playBgs(t, t.pos),
				  this._bgsBuffer && this._bgsBuffer.fadeIn(this._replayFadeTime));
		}
		static isCurrentBgs({ name: t }) {
			return this._currentBgs && this._bgsBuffer && this._currentBgs.name === t;
		}
		static updateBgsParameters(t) {
			this.updateBufferParameters(this._bgsBuffer, this._bgsVolume, t);
		}
		static updateCurrentBgs({ name: t, volume: e, pitch: i, pan: r }, s) {
			this._currentBgs = { name: t, volume: e, pitch: i, pan: r, pos: s };
		}
		static stopBgs() {
			this._bgsBuffer &&
				(this._bgsBuffer.stop(),
				(this._bgsBuffer = null),
				(this._currentBgs = null));
		}
		static fadeOutBgs(t) {
			this._bgsBuffer &&
				this._currentBgs &&
				(this._bgsBuffer.fadeOut(t), (this._currentBgs = null));
		}
		static fadeInBgs(t) {
			this._bgsBuffer && this._currentBgs && this._bgsBuffer.fadeIn(t);
		}
		static playMe(t) {
			this.stopMe(),
				t.name &&
					(this._bgmBuffer &&
						this._currentBgm &&
						((this._currentBgm.pos = this._bgmBuffer.seek()),
						this._bgmBuffer.stop()),
					(this._meBuffer = this.createBuffer('me', t.name)),
					this.updateMeParameters(t),
					this._meBuffer.play(!1),
					this._meBuffer.addStopListener(this.stopMe.bind(this)));
		}
		static updateMeParameters(t) {
			this.updateBufferParameters(this._meBuffer, this._meVolume, t);
		}
		static fadeOutMe(t) {
			this._meBuffer && this._meBuffer.fadeOut(t);
		}
		static stopMe() {
			this._meBuffer &&
				(this._meBuffer.stop(),
				(this._meBuffer = null),
				this._bgmBuffer &&
					this._currentBgm &&
					!this._bgmBuffer.isPlaying() &&
					(this._bgmBuffer.play(!0, this._currentBgm.pos),
					this._bgmBuffer.fadeIn(this._replayFadeTime)));
		}
		static playSe(t) {
			if (t.name) {
				this._seBuffers = this._seBuffers.filter((t) => t.isPlaying());
				const e = this.createBuffer('se', t.name);
				this.updateSeParameters(e, t), e.play(!1), this._seBuffers.push(e);
			}
		}
		static updateSeParameters(t, e) {
			this.updateBufferParameters(t, this._seVolume, e);
		}
		static stopSe() {
			this._seBuffers.forEach((t) => {
				t.stop();
			}),
				(this._seBuffers = []);
		}
		static playStaticSe(t) {
			if (t.name) {
				this.loadStaticSe(t);
				for (const e of this._staticBuffers)
					if (e._reservedSeName === t.name) {
						e.stop(), this.updateSeParameters(e, t), e.play(!1);
						break;
					}
			}
		}
		static loadStaticSe(t) {
			if (t.name && !this.isStaticSe(t)) {
				const e = this.createBuffer('se', t.name);
				(e._reservedSeName = t.name), this._staticBuffers.push(e);
			}
		}
		static isStaticSe({ name: t }) {
			for (const e of this._staticBuffers)
				if (e._reservedSeName === t) return !0;
			return !1;
		}
		static stopAll() {
			this.stopMe(), this.stopBgm(), this.stopBgs(), this.stopSe();
		}
		static saveBgm() {
			if (this._currentBgm) {
				const t = this._currentBgm;
				return {
					name: t.name,
					volume: t.volume,
					pitch: t.pitch,
					pan: t.pan,
					pos: this._bgmBuffer ? this._bgmBuffer.seek() : 0,
				};
			}
			return this.makeEmptyAudioObject();
		}
		static saveBgs() {
			if (this._currentBgs) {
				const t = this._currentBgs;
				return {
					name: t.name,
					volume: t.volume,
					pitch: t.pitch,
					pan: t.pan,
					pos: this._bgsBuffer ? this._bgsBuffer.seek() : 0,
				};
			}
			return this.makeEmptyAudioObject();
		}
		static createBuffer(t, e) {
			const i = this.audioFileExt(),
				r = `${this._path + t}/${encodeURIComponent(e)}${i}`,
				s = new WebAudio(r);
			return this._callCreationHook(s), s;
		}
		static checkErrors() {
			this.checkWebAudioError(this._bgmBuffer),
				this.checkWebAudioError(this._bgsBuffer),
				this.checkWebAudioError(this._meBuffer),
				this._seBuffers.forEach((t) => {
					this.checkWebAudioError(t);
				}),
				this._staticBuffers.forEach((t) => {
					this.checkWebAudioError(t);
				});
		}
		static setCreationHook(t) {
			this._creationHook = t;
		}
		static _callCreationHook(t) {
			this._creationHook && this._creationHook(t);
		}
		static audioFileExt() {
			return WebAudio.canPlayOgg() && !Utils.isMobileDevice() ? '.ogg' : '.m4a';
		}
		static shouldUseHtml5Audio() {
			return !1;
		}
		static checkWebAudioError(t) {
			if (t && t.isError()) throw new Error(`Failed to load: ${t.url}`);
		}
		static makeEmptyAudioObject() {
			return { name: '', volume: 0, pitch: 0 };
		}
		static updateBufferParameters(t, e, i) {
			t &&
				i &&
				((t.volume = (e * (i.volume || 0)) / 1e4),
				(t.pitch = (i.pitch || 0) / 100),
				(t.pan = (i.pan || 0) / 100));
		}
	}
	(AudioManager._masterVolume = 1),
		(AudioManager._bgmVolume = 100),
		(AudioManager._bgsVolume = 100),
		(AudioManager._meVolume = 100),
		(AudioManager._seVolume = 100),
		(AudioManager._currentBgm = null),
		(AudioManager._currentBgs = null),
		(AudioManager._bgmBuffer = null),
		(AudioManager._bgsBuffer = null),
		(AudioManager._meBuffer = null),
		(AudioManager._seBuffers = []),
		(AudioManager._staticBuffers = []),
		(AudioManager._replayFadeTime = 0.5),
		(AudioManager._path = 'audio/'),
		(AudioManager._blobUrl = null),
		Object.defineProperty(AudioManager, 'masterVolume', {
			get() {
				return this._masterVolume;
			},
			set(t) {
				(this._masterVolume = t),
					WebAudio.setMasterVolume(this._masterVolume),
					Graphics.setVideoVolume(this._masterVolume);
			},
			configurable: !0,
		}),
		Object.defineProperty(AudioManager, 'bgmVolume', {
			get() {
				return this._bgmVolume;
			},
			set(t) {
				(this._bgmVolume = t), this.updateBgmParameters(this._currentBgm);
			},
			configurable: !0,
		}),
		Object.defineProperty(AudioManager, 'bgsVolume', {
			get() {
				return this._bgsVolume;
			},
			set(t) {
				(this._bgsVolume = t), this.updateBgsParameters(this._currentBgs);
			},
			configurable: !0,
		}),
		Object.defineProperty(AudioManager, 'meVolume', {
			get() {
				return this._meVolume;
			},
			set(t) {
				(this._meVolume = t), this.updateMeParameters(this._currentMe);
			},
			configurable: !0,
		}),
		Object.defineProperty(AudioManager, 'seVolume', {
			get() {
				return this._seVolume;
			},
			set(t) {
				this._seVolume = t;
			},
			configurable: !0,
		});
	class Input {
		constructor() {
			throw new Error('This is a static class');
		}
		static initialize() {
			this.clear(), this._wrapNwjsAlert(), this._setupEventHandlers();
		}
		static clear() {
			(this._currentState = {}),
				(this._previousState = {}),
				(this._gamepadStates = []),
				(this._latestButton = null),
				(this._pressedTime = 0),
				(this._dir4 = 0),
				(this._dir8 = 0),
				(this._preferredAxis = ''),
				(this._date = 0);
		}
		static update() {
			this._pollGamepads(),
				this._currentState[this._latestButton]
					? this._pressedTime++
					: (this._latestButton = null);
			for (let t in this._currentState)
				this._currentState[t] &&
					!this._previousState[t] &&
					((this._latestButton = t),
					(this._pressedTime = 0),
					(this._date = Date.now())),
					(this._previousState[t] = this._currentState[t]);
			this._updateDirection();
		}
		static isPressed(t) {
			return (
				!(!this._isEscapeCompatible(t) || !this.isPressed('escape')) ||
				!!this._currentState[t]
			);
		}
		static isTriggered(t) {
			return (
				!(!this._isEscapeCompatible(t) || !this.isTriggered('escape')) ||
				(this._latestButton === t && 0 === this._pressedTime)
			);
		}
		static isRepeated(t) {
			return (
				!(!this._isEscapeCompatible(t) || !this.isRepeated('escape')) ||
				(this._latestButton === t &&
					(0 === this._pressedTime ||
						(this._pressedTime >= this.keyRepeatWait &&
							this._pressedTime % this.keyRepeatInterval == 0)))
			);
		}
		static isLongPressed(t) {
			return (
				!(!this._isEscapeCompatible(t) || !this.isLongPressed('escape')) ||
				(this._latestButton === t && this._pressedTime >= this.keyRepeatWait)
			);
		}
		static _setupEventHandlers() {
			document.addEventListener('keydown', this._onKeyDown.bind(this)),
				document.addEventListener('keyup', this._onKeyUp.bind(this)),
				window.addEventListener('blur', this._onLostFocus.bind(this));
		}
		static _onKeyDown(t) {
			this._shouldPreventDefault(t.keyCode) && t.preventDefault(),
				144 === t.keyCode && this.clear();
			const e = this.keyMapper[t.keyCode];
			ResourceHandler.exists() && 'ok' === e
				? ResourceHandler.retry()
				: e && (this._currentState[e] = !0);
		}
		static _onKeyUp({ keyCode: t }) {
			const e = this.keyMapper[t];
			e && (this._currentState[e] = !1), 0 === t && this.clear();
		}
		static _onLostFocus() {
			this.clear();
		}
		static _pollGamepads() {
			if (navigator.getGamepads) {
				const t = navigator.getGamepads();
				if (t)
					for (const e of t) e && e.connected && this._updateGamepadState(e);
			}
		}
		static _updateGamepadState(t) {
			const e = this._gamepadStates[t.index] || [],
				i = [],
				r = t.buttons,
				s = t.axes;
			(i[12] = !1), (i[13] = !1), (i[14] = !1), (i[15] = !1);
			for (let t = 0; t < r.length; t++) i[t] = r[t].pressed;
			s[1] < -0.5 ? (i[12] = !0) : s[1] > 0.5 && (i[13] = !0),
				s[0] < -0.5 ? (i[14] = !0) : s[0] > 0.5 && (i[15] = !0);
			for (let t = 0; t < i.length; t++)
				if (i[t] !== e[t]) {
					const e = this.gamepadMapper[t];
					e && (this._currentState[e] = i[t]);
				}
			this._gamepadStates[t.index] = i;
		}
		static _updateDirection() {
			let t = this._signX(),
				e = this._signY();
			(this._dir8 = this._makeNumpadDirection(t, e)),
				0 !== t && 0 !== e
					? 'x' === this._preferredAxis
						? (e = 0)
						: (t = 0)
					: 0 !== t
					? (this._preferredAxis = 'y')
					: 0 !== e && (this._preferredAxis = 'x'),
				(this._dir4 = this._makeNumpadDirection(t, e));
		}
		static _signX() {
			let t = 0;
			return this.isPressed('left') && t--, this.isPressed('right') && t++, t;
		}
		static _signY() {
			let t = 0;
			return this.isPressed('up') && t--, this.isPressed('down') && t++, t;
		}
		static _wrapNwjsAlert() {
			if (Utils.isNwjs()) {
				const t = window.alert;
				window.alert = function (...e) {
					const i = require('nw.gui').Window.get();
					t.apply(this, e), i.focus(), Input.clear();
				};
			}
		}
		static _shouldPreventDefault(t) {
			switch (t) {
				case 8:
				case 33:
				case 34:
				case 37:
				case 38:
				case 39:
				case 40:
					return !0;
			}
			return !1;
		}
		static _makeNumpadDirection(t, e) {
			return 0 !== t || 0 !== e ? 5 - 3 * e + t : 0;
		}
		static _isEscapeCompatible(t) {
			return 'cancel' === t || 'menu' === t;
		}
	}
	(Input.keyRepeatWait = 24),
		(Input.keyRepeatInterval = 6),
		(Input.keyMapper = {
			9: 'tab',
			13: 'ok',
			16: 'shift',
			17: 'control',
			18: 'control',
			27: 'escape',
			32: 'ok',
			33: 'pageup',
			34: 'pagedown',
			37: 'left',
			38: 'up',
			39: 'right',
			40: 'down',
			45: 'escape',
			81: 'pageup',
			87: 'pagedown',
			88: 'escape',
			90: 'ok',
			96: 'escape',
			98: 'down',
			100: 'left',
			102: 'right',
			104: 'up',
			120: 'debug',
		}),
		(Input.gamepadMapper = {
			0: 'ok',
			1: 'cancel',
			2: 'shift',
			3: 'menu',
			4: 'pageup',
			5: 'pagedown',
			12: 'up',
			13: 'down',
			14: 'left',
			15: 'right',
		}),
		Object.defineProperty(Input, 'dir4', {
			get() {
				return this._dir4;
			},
			configurable: !0,
		}),
		Object.defineProperty(Input, 'dir8', {
			get() {
				return this._dir8;
			},
			configurable: !0,
		}),
		Object.defineProperty(Input, 'date', {
			get() {
				return this._date;
			},
			configurable: !0,
		});
	class PluginManager {
		constructor() {
			throw new Error('This is a static class');
		}
		static setup(t) {
			t.forEach(function ({ status: t, name: e, parameters: i }) {
				t &&
					!this._scripts.contains(e) &&
					(this.setParameters(e, i),
					this.loadScript(`${e}.js`),
					this._scripts.push(e));
			}, this);
		}
		static checkErrors() {
			const t = this._errorUrls.shift();
			if (t) throw new Error(`Failed to load: ${t}`);
		}
		static parameters(t) {
			return this._parameters[t.toLowerCase()] || {};
		}
		static setParameters(t, e) {
			this._parameters[t.toLowerCase()] = e;
		}
		static loadScript(t) {
			const e = this._path + t,
				i = Utils.loadScript(e);
			i && ((i.onerror = this.onError.bind(this)), (i._url = e));
		}
		static onError({ target: t }) {
			this._errorUrls.push(t._url);
		}
	}
	(PluginManager._path = 'js/plugins/'),
		(PluginManager._scripts = []),
		(PluginManager._errorUrls = []),
		(PluginManager._parameters = {});
	class TouchInput {
		constructor() {
			throw new Error('This is a static class');
		}
		static initialize() {
			this.clear(), this._setupEventHandlers();
		}
		static clear() {
			(this._mousePressed = !1),
				(this._screenPressed = !1),
				(this._pressedTime = 0),
				(this._events = {}),
				(this._events.triggered = !1),
				(this._events.cancelled = !1),
				(this._events.moved = !1),
				(this._events.released = !1),
				(this._events.wheelX = 0),
				(this._events.wheelY = 0),
				(this._triggered = !1),
				(this._cancelled = !1),
				(this._moved = !1),
				(this._released = !1),
				(this._wheelX = 0),
				(this._wheelY = 0),
				(this._x = 0),
				(this._y = 0),
				(this._date = 0);
		}
		static update() {
			(this._triggered = this._events.triggered),
				(this._cancelled = this._events.cancelled),
				(this._moved = this._events.moved),
				(this._released = this._events.released),
				(this._wheelX = this._events.wheelX),
				(this._wheelY = this._events.wheelY),
				(this._events.triggered = !1),
				(this._events.cancelled = !1),
				(this._events.moved = !1),
				(this._events.released = !1),
				(this._events.wheelX = 0),
				(this._events.wheelY = 0),
				this.isPressed() && this._pressedTime++;
		}
		static isPressed() {
			return this._mousePressed || this._screenPressed;
		}
		static isTriggered() {
			return this._triggered;
		}
		static isRepeated() {
			return (
				this.isPressed() &&
				(this._triggered ||
					(this._pressedTime >= this.keyRepeatWait &&
						this._pressedTime % this.keyRepeatInterval == 0))
			);
		}
		static isLongPressed() {
			return this.isPressed() && this._pressedTime >= this.keyRepeatWait;
		}
		static isCancelled() {
			return this._cancelled;
		}
		static isMoved() {
			return this._moved;
		}
		static isReleased() {
			return this._released;
		}
		static _setupEventHandlers() {
			const t = Utils.isSupportPassiveEvent();
			document.addEventListener('mousedown', this._onMouseDown.bind(this)),
				document.addEventListener('mousemove', this._onMouseMove.bind(this)),
				document.addEventListener('mouseup', this._onMouseUp.bind(this)),
				document.addEventListener(
					'wheel',
					this._onWheel.bind(this),
					!!t && { passive: !1 }
				),
				document.addEventListener(
					'touchstart',
					this._onTouchStart.bind(this),
					!!t && { passive: !1 }
				),
				document.addEventListener(
					'touchmove',
					this._onTouchMove.bind(this),
					!!t && { passive: !1 }
				),
				document.addEventListener('touchend', this._onTouchEnd.bind(this)),
				document.addEventListener(
					'touchcancel',
					this._onTouchCancel.bind(this)
				),
				document.addEventListener(
					'pointerdown',
					this._onPointerDown.bind(this)
				),
				window.addEventListener('blur', this._onLostFocus.bind(this));
		}
		static _onMouseDown(t) {
			0 === t.button
				? this._onLeftButtonDown(t)
				: 1 === t.button
				? this._onMiddleButtonDown(t)
				: 2 === t.button && this._onRightButtonDown(t);
		}
		static _onLeftButtonDown({ pageX: t, pageY: e }) {
			const i = Graphics.pageToCanvasX(t),
				r = Graphics.pageToCanvasY(e);
			Graphics.isInsideCanvas(i, r) &&
				((this._mousePressed = !0),
				(this._pressedTime = 0),
				this._onTrigger(i, r));
		}
		static _onRightButtonDown({ pageX: t, pageY: e }) {
			const i = Graphics.pageToCanvasX(t),
				r = Graphics.pageToCanvasY(e);
			Graphics.isInsideCanvas(i, r) && this._onCancel(i, r);
		}
		static _onMouseMove({ pageX: t, pageY: e }) {
			if (this._mousePressed) {
				const i = Graphics.pageToCanvasX(t),
					r = Graphics.pageToCanvasY(e);
				this._onMove(i, r);
			}
		}
		static _onMouseUp({ button: t, pageX: e, pageY: i }) {
			if (0 === t) {
				const t = Graphics.pageToCanvasX(e),
					r = Graphics.pageToCanvasY(i);
				(this._mousePressed = !1), this._onRelease(t, r);
			}
		}
		static _onWheel(t) {
			(this._events.wheelX += t.deltaX),
				(this._events.wheelY += t.deltaY),
				t.preventDefault();
		}
		static _onTouchStart(t) {
			for (const e of t.changedTouches) {
				const i = Graphics.pageToCanvasX(e.pageX),
					r = Graphics.pageToCanvasY(e.pageY);
				Graphics.isInsideCanvas(i, r) &&
					((this._screenPressed = !0),
					(this._pressedTime = 0),
					t.touches.length >= 2 ? this._onCancel(i, r) : this._onTrigger(i, r),
					t.preventDefault());
			}
			(window.cordova || window.navigator.standalone) && t.preventDefault();
		}
		static _onTouchMove({ changedTouches: t }) {
			for (const e of t) {
				const t = Graphics.pageToCanvasX(e.pageX),
					i = Graphics.pageToCanvasY(e.pageY);
				this._onMove(t, i);
			}
		}
		static _onTouchEnd({ changedTouches: t }) {
			for (const e of t) {
				const t = Graphics.pageToCanvasX(e.pageX),
					i = Graphics.pageToCanvasY(e.pageY);
				(this._screenPressed = !1), this._onRelease(t, i);
			}
		}
		static _onTouchCancel(t) {
			this._screenPressed = !1;
		}
		static _onPointerDown(t) {
			if ('touch' === t.pointerType && !t.isPrimary) {
				const e = Graphics.pageToCanvasX(t.pageX),
					i = Graphics.pageToCanvasY(t.pageY);
				Graphics.isInsideCanvas(e, i) &&
					(this._onCancel(e, i), t.preventDefault());
			}
		}
		static _onLostFocus() {
			this.clear();
		}
		static _onTrigger(t, e) {
			(this._events.triggered = !0),
				(this._x = t),
				(this._y = e),
				(this._date = Date.now());
		}
		static _onCancel(t, e) {
			(this._events.cancelled = !0), (this._x = t), (this._y = e);
		}
		static _onMove(t, e) {
			(this._events.moved = !0), (this._x = t), (this._y = e);
		}
		static _onRelease(t, e) {
			(this._events.released = !0), (this._x = t), (this._y = e);
		}
	}
	(TouchInput.keyRepeatWait = 24),
		(TouchInput.keyRepeatInterval = 6),
		Object.defineProperty(TouchInput, 'wheelX', {
			get() {
				return this._wheelX;
			},
			configurable: !0,
		}),
		Object.defineProperty(TouchInput, 'wheelY', {
			get() {
				return this._wheelY;
			},
			configurable: !0,
		}),
		Object.defineProperty(TouchInput, 'x', {
			get() {
				return this._x;
			},
			configurable: !0,
		}),
		Object.defineProperty(TouchInput, 'y', {
			get() {
				return this._y;
			},
			configurable: !0,
		}),
		Object.defineProperty(TouchInput, 'date', {
			get() {
				return this._date;
			},
			configurable: !0,
		}),
		(TouchInput._onMiddleButtonDown = (t) => {});
	class SceneManager {
		constructor() {
			throw new Error('This is a static class');
		}
		static run(t) {
			try {
				this.initialize(), this.goto(t), this.requestUpdate();
			} catch (t) {
				this.catchException(t);
			}
		}
		static initialize() {
			this.initProgressWatcher(),
				this.initGraphics(),
				this.checkFileAccess(),
				this.initAudio(),
				this.initInput(),
				this.initNwjs(),
				this.checkPluginErrors(),
				this.setupErrorHandlers();
		}
		static initGraphics() {
			const t = this.preferableRendererType();
			Graphics.initialize(this._screenWidth, this._screenHeight, t),
				(Graphics.boxWidth = this._boxWidth),
				(Graphics.boxHeight = this._boxHeight),
				Graphics.setLoadingImage('img/system/Loading.png'),
				Utils.isOptionValid('showfps') && Graphics.showFps(),
				'webgl' === t && this.checkWebGL();
		}
		static setupErrorHandlers() {
			window.addEventListener('error', this.onError.bind(this)),
				document.addEventListener('keydown', this.onKeyDown.bind(this));
		}
		static frameCount() {
			return this._frameCount;
		}
		static setFrameCount(t) {
			this._frameCount = t;
		}
		static resetFrameCount() {
			this._frameCount = 0;
		}
		static requestUpdate() {
			this._stopped || requestAnimationFrame(this.update.bind(this));
		}
		static update() {
			try {
				this.tickStart(),
					Utils.isMobileSafari() && this.updateInputData(),
					this.updateManagers(),
					this.updateMain(),
					this.tickEnd();
			} catch (t) {
				this.catchException(t);
			}
		}
		static onError({ message: t, filename: e, lineno: i }) {
			if (e || i)
				try {
					this.stop(), Graphics.printError('Error', t), AudioManager.stopAll();
				} catch (t) {}
		}
		static catchException(t) {
			t instanceof Error
				? (Graphics.printError(t.name, t.message), Graphics.printErrorDetail(t))
				: Graphics.printError('UnknownError', t),
				AudioManager.stopAll(),
				this.stop();
		}
		static updateMain() {
			if (Utils.isHighFps()) {
				if (Utils.isMobileSafari()) this.changeScene(), this.updateScene();
				else {
					const t = this._getTimeInMsWithoutMobileSafari();
					void 0 === this._currentTime && (this._currentTime = t);
					let e = (t - this._currentTime) / 1e3;
					for (
						e > 0.25 && (e = 0.25),
							this._currentTime = t,
							this._accumulator += e;
						this._accumulator >= this._deltaTime;

					)
						this.updateInputData(),
							this.changeScene(),
							this.updateScene(),
							(this._accumulator -= this._deltaTime);
				}
				this.renderScene(), this.requestUpdate();
			} else
				this.updateInputData(),
					this.changeScene(),
					this.updateScene(),
					this.renderScene(),
					this.requestUpdate();
		}
		static changeScene() {
			this.isSceneChanging() &&
				!this.isCurrentSceneBusy() &&
				(this._scene &&
					(this._scene.terminate(),
					this._scene.detachReservation(),
					(this._previousClass = this._scene.constructor)),
				(this._scene = this._nextScene),
				this._scene &&
					(this._scene.attachReservation(),
					this._scene.create(),
					(this._nextScene = null),
					(this._sceneStarted = !1),
					this.onSceneCreate()),
				this._exiting && this.terminate());
		}
		static updateScene() {
			this._scene &&
				(!this._sceneStarted &&
					this._scene.isReady() &&
					(this._scene.start(), (this._sceneStarted = !0), this.onSceneStart()),
				this.isCurrentSceneStarted() &&
					(this.updateFrameCount(), this._scene.update()));
		}
		static renderScene() {
			this.isCurrentSceneStarted()
				? Graphics.render(this._scene)
				: this._scene && this.onSceneLoading();
		}
		static updateFrameCount() {
			this._frameCount++;
		}
		static isSceneChanging() {
			return this._exiting || !!this._nextScene;
		}
		static isCurrentSceneBusy() {
			return this._scene && this._scene.isBusy();
		}
		static isCurrentSceneStarted() {
			return this._scene && this._sceneStarted;
		}
		static isNextScene(t) {
			return this._nextScene && this._nextScene.constructor === t;
		}
		static isPreviousScene(t) {
			return this._previousClass === t;
		}
		static goto(t) {
			t && (this._nextScene = new t()), this._scene && this._scene.stop();
		}
		static push(t) {
			this._stack.push(this._scene.constructor), this.goto(t);
		}
		static pop() {
			this._stack.length > 0 ? this.goto(this._stack.pop()) : this.exit();
		}
		static exit() {
			this.goto(null), (this._exiting = !0);
		}
		static clearStack() {
			this._stack = [];
		}
		static stop() {
			this._stopped = !0;
		}
		static prepareNextScene(...t) {
			this._nextScene.prepare(...t);
		}
		static snap() {
			return Bitmap.snap(this._scene);
		}
		static snapForBackground() {
			(this._backgroundBitmap = this.snap()), this._backgroundBitmap.blur();
		}
		static backgroundBitmap() {
			return this._backgroundBitmap;
		}
		static resume() {
			(this._stopped = !1),
				this.requestUpdate(),
				Utils.isMobileSafari() ||
					((this._currentTime = this._getTimeInMsWithoutMobileSafari()),
					(this._accumulator = 0));
		}
		static _getTimeInMsWithoutMobileSafari() {
			return performance.now();
		}
		static initProgressWatcher() {
			ProgressWatcher.initialize();
		}
		static preferableRendererType() {
			return Utils.isOptionValid('canvas')
				? 'canvas'
				: Utils.isOptionValid('webgl')
				? 'webgl'
				: 'auto';
		}
		static shouldUseCanvasRenderer() {
			return Utils.isMobileDevice();
		}
		static checkWebGL() {
			if (!Graphics.hasWebGL())
				throw new Error('Your browser does not support WebGL.');
		}
		static checkFileAccess() {
			if (!Utils.canReadGameFiles())
				throw new Error('Your browser does not allow to read local files.');
		}
		static initAudio() {
			const t = Utils.isOptionValid('noaudio');
			if (!WebAudio.initialize(t) && !t)
				throw new Error('Your browser does not support Web Audio API.');
		}
		static initInput() {
			Input.initialize(), TouchInput.initialize();
		}
		static initNwjs() {
			if (Utils.isNwjs()) {
				const t = require('nw.gui'),
					e = t.Window.get();
				if ('darwin' === process.platform && !e.menu) {
					const i = new t.Menu({ type: 'menubar' }),
						r = { hideEdit: !0, hideWindow: !0 };
					i.createMacBuiltin('Game', r), (e.menu = i);
				}
			}
		}
		static checkPluginErrors() {
			PluginManager.checkErrors();
		}
		static terminate() {
			window.close();
		}
		static onKeyDown({ ctrlKey: t, altKey: e, keyCode: i }) {
			if (!t && !e)
				switch (i) {
					case 116:
						Utils.isNwjs() && location.reload();
						break;
					case 119:
						Utils.isNwjs() &&
							Utils.isOptionValid('test') &&
							require('nw.gui').Window.get().showDevTools();
				}
		}
		static tickStart() {
			Graphics.tickStart();
		}
		static tickEnd() {
			Graphics.tickEnd();
		}
		static updateInputData() {
			Input.update(), TouchInput.update();
		}
		static updateManagers() {
			ImageManager.update();
		}
		static onSceneCreate() {
			Graphics.startLoading();
		}
		static onSceneStart() {
			Graphics.callGC(), Graphics.endLoading();
		}
		static onSceneLoading() {
			Graphics.updateLoading();
		}
	}
	(SceneManager._scene = null),
		(SceneManager._nextScene = null),
		(SceneManager._stack = []),
		(SceneManager._stopped = !1),
		(SceneManager._sceneStarted = !1),
		(SceneManager._exiting = !1),
		(SceneManager._previousClass = null),
		(SceneManager._backgroundBitmap = null),
		(SceneManager._screenWidth = 816),
		(SceneManager._screenHeight = 624),
		(SceneManager._boxWidth = 816),
		(SceneManager._boxHeight = 624),
		(SceneManager._deltaTime = 1 / 60),
		Utils.isMobileSafari() ||
			(SceneManager._currentTime =
				SceneManager._getTimeInMsWithoutMobileSafari()),
		(SceneManager._accumulator = 0),
		(SceneManager._frameCount = 0);
	class ResourceHandler {
		constructor() {
			throw new Error('This is a static class');
		}
		static createLoader(t, e, i, r = this._defaultRetryInterval) {
			const s = this._reloaders;
			let n = 0;
			return () => {
				n < r.length
					? (setTimeout(e, r[n]), n++)
					: (i && i(),
					  t &&
							(0 === s.length &&
								(Graphics.printLoadingError(t), SceneManager.stop()),
							s.push(() => {
								(n = 0), e();
							})));
			};
		}
		static exists() {
			return this._reloaders.length > 0;
		}
		static retry() {
			this._reloaders.length > 0 &&
				(Graphics.eraseLoadingError(),
				SceneManager.resume(),
				this._reloaders.forEach((t) => {
					t();
				}),
				(this._reloaders.length = 0));
		}
	}
	(ResourceHandler._reloaders = []),
		(ResourceHandler._defaultRetryInterval = [500, 1e3, 3e3]);
	class Graphics {
		constructor() {
			throw new Error('This is a static class');
		}
		static initialize(t, e, i) {
			(this._width = t || 800),
				(this._height = e || 600),
				(this._rendererType = i || 'auto'),
				(this._boxWidth = this._width),
				(this._boxHeight = this._height),
				(this._scale = 1),
				(this._realScale = 1),
				(this._errorShowed = !1),
				(this._errorPrinter = null),
				(this._canvas = null),
				(this._video = null),
				(this._videoUnlocked = !1),
				(this._videoLoading = !1),
				(this._upperCanvas = null),
				(this._fpsMeter = null),
				(this._modeBox = null),
				(this._skipCount = 0),
				(this._maxSkip = 3),
				(this._rendered = !1),
				(this._loadingImage = null),
				(this._loadingCount = 0),
				(this._fpsMeterToggled = !1),
				(this._stretchEnabled = this._defaultStretchMode()),
				(this._canUseDifferenceBlend = !1),
				(this._canUseSaturationBlend = !1),
				(this._hiddenCanvas = null),
				(this._app = null),
				this._testCanvasBlendModes(),
				this._modifyExistingElements(),
				this._updateRealScale(),
				this._createAllElements(),
				this._disableTextSelection(),
				this._disableContextMenu(),
				this._setupEventHandlers(),
				this._setupCssFontLoading(),
				this._setupProgress();
		}
		static canUseCssFontLoading() {
			return !!this._cssFontLoading;
		}
		static render(t) {
			t && (this._app.stage = t);
		}
		static isWebGL() {
			return this._renderer && this._renderer.type === RENDERER_TYPE$9.WEBGL;
		}
		static canUseDifferenceBlend() {
			return this._canUseDifferenceBlend;
		}
		static canUseSaturationBlend() {
			return this._canUseSaturationBlend;
		}
		static setLoadingImage(t) {
			(this._loadingImage = new Image()), (this._loadingImage.src = t);
		}
		static setProgressEnabled(t) {
			this._progressEnabled = t;
		}
		static startLoading() {
			(this._loadingCount = 0),
				ProgressWatcher.truncateProgress(),
				ProgressWatcher.setProgressListener(
					this._updateProgressCount.bind(this)
				),
				(this._progressTimeout = setTimeout(() => {
					Graphics._showProgress();
				}, 1500));
		}
		static _setupProgress() {
			(this._progressElement = document.createElement('div')),
				(this._progressElement.id = 'loading-progress'),
				(this._progressElement.width = 600),
				(this._progressElement.height = 300),
				(this._progressElement.style.visibility = 'hidden'),
				(this._barElement = document.createElement('div')),
				(this._barElement.id = 'loading-bar'),
				(this._barElement.style.width = '100%'),
				(this._barElement.style.height = '10%'),
				(this._barElement.style.background =
					'linear-gradient(to top, gray, lightgray)'),
				(this._barElement.style.border = '5px solid white'),
				(this._barElement.style.borderRadius = '15px'),
				(this._barElement.style.marginTop = '40%'),
				(this._filledBarElement = document.createElement('div')),
				(this._filledBarElement.id = 'loading-filled-bar'),
				(this._filledBarElement.style.width = '0%'),
				(this._filledBarElement.style.height = '100%'),
				(this._filledBarElement.style.background =
					'linear-gradient(to top, lime, honeydew)'),
				(this._filledBarElement.style.borderRadius = '10px'),
				this._progressElement.appendChild(this._barElement),
				this._barElement.appendChild(this._filledBarElement),
				this._updateProgress(),
				document.body.appendChild(this._progressElement);
		}
		static _showProgress() {
			this._progressEnabled &&
				((this._progressElement.value = 0),
				(this._progressElement.style.visibility = 'visible'),
				(this._progressElement.style.zIndex = 98));
		}
		static _hideProgress() {
			this._progressElement &&
				(this._progressElement.style.visibility = 'hidden'),
				clearTimeout(this._progressTimeout);
		}
		static _updateProgressCount(t, e) {
			let i;
			(i = 0 !== e ? (t / e) * 100 : 100),
				(this._filledBarElement.style.width = `${i}%`);
		}
		static _updateProgress() {
			this._centerElement(this._progressElement);
		}
		static updateLoading() {
			this._loadingCount++,
				this._paintUpperCanvas(),
				(this._upperCanvas.style.opacity = 1),
				this._updateProgress();
		}
		static endLoading() {
			this._clearUpperCanvas(),
				(this._upperCanvas.style.opacity = 0),
				this._hideProgress();
		}
		static printLoadingError(t) {
			if (this._errorPrinter && !this._errorShowed) {
				this._updateErrorPrinter(),
					(this._errorPrinter.innerHTML = this._makeErrorHtml(
						'Loading Error',
						`Failed to load: ${t}`
					)),
					(this._errorPrinter.style.userSelect = 'text'),
					(this._errorPrinter.style.webkitUserSelect = 'text'),
					(this._errorPrinter.style.msUserSelect = 'text'),
					(this._errorPrinter.style.mozUserSelect = 'text'),
					(this._errorPrinter.oncontextmenu = null);
				const e = document.createElement('button');
				(e.innerHTML = 'Retry'),
					(e.style.fontSize = '24px'),
					(e.style.color = '#ffffff'),
					(e.style.backgroundColor = '#000000'),
					e.addEventListener('touchstart', (t) => {
						t.stopPropagation();
					}),
					e.addEventListener('click', (t) => {
						ResourceHandler.retry();
					}),
					this._errorPrinter.appendChild(e),
					(this._loadingCount = -1 / 0);
			}
		}
		static eraseLoadingError() {
			this._errorPrinter &&
				!this._errorShowed &&
				((this._errorPrinter.innerHTML = ''),
				(this._errorPrinter.style.userSelect = 'none'),
				(this._errorPrinter.style.webkitUserSelect = 'none'),
				(this._errorPrinter.style.msUserSelect = 'none'),
				(this._errorPrinter.style.mozUserSelect = 'none'),
				(this._errorPrinter.oncontextmenu = () => !1),
				(this._loadingCount = 0));
		}
		static printError(t, e) {
			(this._errorShowed = !0),
				this._hideProgress(),
				this.hideFps(),
				this._errorPrinter &&
					(this._updateErrorPrinter(),
					(this._errorPrinter.innerHTML = this._makeErrorHtml(t, e)),
					(this._errorPrinter.style.userSelect = 'text'),
					(this._errorPrinter.style.webkitUserSelect = 'text'),
					(this._errorPrinter.style.msUserSelect = 'text'),
					(this._errorPrinter.style.mozUserSelect = 'text'),
					(this._errorPrinter.oncontextmenu = null),
					this._errorMessage && this._makeErrorMessage()),
				this._applyCanvasFilter(),
				this._clearUpperCanvas();
		}
		static printErrorDetail(t) {
			if (this._errorPrinter && this._showErrorDetail) {
				const e = this._formatEventInfo(t),
					i = this._formatEventCommandInfo(t),
					r = i ? `${e}, ${i}` : e,
					s = this._formatStackTrace(t);
				this._makeErrorDetail(r, s);
			}
		}
		static setErrorMessage(t) {
			this._errorMessage = t;
		}
		static setShowErrorDetail(t) {
			this._showErrorDetail = t;
		}
		static showFps() {
			this._fpsMeter &&
				(this._fpsMeter.extensions.pixi ||
					this._fpsMeter.enableExtension('pixi', [PIXI, this._app]),
				document.body.appendChild(this._fpsMeter.dom),
				this._fpsMeter.show(!0));
		}
		static hideFps() {
			this._fpsMeter &&
				(document.body.contains(this._fpsMeter.dom) &&
					document.body.removeChild(this._fpsMeter.dom),
				this._fpsMeter.show(!1));
		}
		static loadFont(t, e) {
			const i = document.createElement('style'),
				r = document.getElementsByTagName('head'),
				s = `@font-face { font-family: "${t}"; src: url("${e}"); }`;
			(i.type = 'text/css'),
				r.item(0).appendChild(i),
				i.sheet.insertRule(s, 0),
				this._createFontLoader(t);
		}
		static isFontLoaded(t) {
			if (Graphics._cssFontLoading)
				return (
					!!Graphics._fontLoaded && Graphics._fontLoaded.check(`10px "${t}"`)
				);
			{
				this._hiddenCanvas ||
					(this._hiddenCanvas = document.createElement('canvas'));
				const e = this._hiddenCanvas.getContext('2d'),
					i = 'abcdefghijklmnopqrstuvwxyz';
				let r, s;
				return (
					(e.font = `40px ${t}, sans-serif`),
					(r = e.measureText(i).width),
					(e.font = '40px sans-serif'),
					(s = e.measureText(i).width),
					r !== s
				);
			}
		}
		static playVideo(t) {}
		static _playVideo(t) {}
		static isVideoPlaying() {
			return !1;
		}
		static canPlayVideoType(t) {
			return !1;
		}
		static setVideoVolume(t) {}
		static pageToCanvasX(t) {
			if (this._canvas) {
				const e = this._canvas.offsetLeft;
				return Math.round((t - e) / this._realScale);
			}
			return 0;
		}
		static pageToCanvasY(t) {
			if (this._canvas) {
				const e = this._canvas.offsetTop;
				return Math.round((t - e) / this._realScale);
			}
			return 0;
		}
		static isInsideCanvas(t, e) {
			return t >= 0 && t < this._width && e >= 0 && e < this._height;
		}
		static _createAllElements() {
			this._createErrorPrinter(),
				this._createCanvas(),
				this._createVideo(),
				this._createUpperCanvas(),
				this._createRenderer(),
				this._createPixiApp(),
				this._createFPSMeter(),
				this._createModeBox(),
				this._createGameFontLoader();
		}
		static _updateAllElements() {
			this._updateRealScale(),
				this._updateErrorPrinter(),
				this._updateCanvas(),
				this._updateVideo(),
				this._updateUpperCanvas(),
				this._updateRenderer(),
				this._paintUpperCanvas(),
				this._updateProgress();
		}
		static _updateRealScale() {
			if (this._stretchEnabled) {
				let t = window.innerWidth / this._width,
					e = window.innerHeight / this._height;
				t >= 1 && t - 0.01 <= 1 && (t = 1),
					e >= 1 && e - 0.01 <= 1 && (e = 1),
					(this._realScale = Math.min(t, e));
			} else this._realScale = this._scale;
		}
		static _testCanvasBlendModes() {
			let t, e, i, r;
			(t = document.createElement('canvas')),
				(t.width = 1),
				(t.height = 1),
				(e = t.getContext('2d')),
				(e.globalCompositeOperation = 'source-over'),
				(e.fillStyle = 'white'),
				e.fillRect(0, 0, 1, 1),
				(e.globalCompositeOperation = 'difference'),
				(e.fillStyle = 'white'),
				e.fillRect(0, 0, 1, 1),
				(i = e.getImageData(0, 0, 1, 1)),
				(e.globalCompositeOperation = 'source-over'),
				(e.fillStyle = 'black'),
				e.fillRect(0, 0, 1, 1),
				(e.globalCompositeOperation = 'saturation'),
				(e.fillStyle = 'white'),
				e.fillRect(0, 0, 1, 1),
				(r = e.getImageData(0, 0, 1, 1)),
				(this._canUseDifferenceBlend = 0 === i.data[0]),
				(this._canUseSaturationBlend = 0 === r.data[0]);
		}
		static _createErrorPrinter() {
			(this._errorPrinter = document.createElement('p')),
				(this._errorPrinter.id = 'ErrorPrinter'),
				this._updateErrorPrinter(),
				document.body.appendChild(this._errorPrinter);
		}
		static _updateErrorPrinter() {
			(this._errorPrinter.width = 0.9 * this._width),
				this._errorShowed && this._showErrorDetail
					? (this._errorPrinter.height = 0.9 * this._height)
					: this._errorShowed && this._errorMessage
					? (this._errorPrinter.height = 100)
					: (this._errorPrinter.height = 40),
				(this._errorPrinter.style.textAlign = 'center'),
				(this._errorPrinter.style.textShadow = '1px 1px 3px #000'),
				(this._errorPrinter.style.fontSize = '20px'),
				(this._errorPrinter.style.zIndex = 99),
				this._centerElement(this._errorPrinter);
		}
		static _makeErrorMessage() {
			const t = document.createElement('div'),
				e = t.style;
			(e.color = 'white'),
				(e.textAlign = 'left'),
				(e.fontSize = '18px'),
				(t.innerHTML = `<hr>${this._errorMessage}`),
				this._errorPrinter.appendChild(t);
		}
		static _makeErrorDetail(t, e) {
			const i = document.createElement('div'),
				r = i.style;
			(r.color = 'white'),
				(r.textAlign = 'left'),
				(r.fontSize = '18px'),
				(i.innerHTML = `<br><hr>${t}<br><br>${e}`),
				this._errorPrinter.appendChild(i);
		}
		static _createCanvas() {
			(this._canvas = document.createElement('canvas')),
				(this._canvas.id = 'GameCanvas'),
				this._updateCanvas(),
				document.body.appendChild(this._canvas);
		}
		static _updateCanvas() {
			(this._canvas.width = this._width),
				(this._canvas.height = this._height),
				(this._canvas.style.zIndex = 1),
				this._centerElement(this._canvas);
		}
		static _createVideo() {}
		static _updateVideo() {}
		static _createUpperCanvas() {
			(this._upperCanvas = document.createElement('canvas')),
				(this._upperCanvas.id = 'UpperCanvas'),
				this._updateUpperCanvas(),
				document.body.appendChild(this._upperCanvas);
		}
		static _updateUpperCanvas() {
			(this._upperCanvas.width = this._width),
				(this._upperCanvas.height = this._height),
				(this._upperCanvas.style.zIndex = 3),
				this._centerElement(this._upperCanvas);
		}
		static _clearUpperCanvas() {
			this._upperCanvas
				.getContext('2d')
				.clearRect(0, 0, this._width, this._height);
		}
		static _paintUpperCanvas() {
			if (
				(this._clearUpperCanvas(),
				this._loadingImage && this._loadingCount >= 20)
			) {
				const t = this._upperCanvas.getContext('2d'),
					e = (this._width - this._loadingImage.width) / 2,
					i = (this._height - this._loadingImage.height) / 2,
					r = ((this._loadingCount - 20) / 30).clamp(0, 1);
				t.save(),
					(t.globalAlpha = r),
					t.drawImage(this._loadingImage, e, i),
					t.restore();
			}
		}
		static _updateRenderer() {
			this._app && this._app.renderer.resize(this._width, this._height);
		}
		static _createFPSMeter() {
			'function' == typeof GameStats &&
				((this._fpsMeter = new GameStats({ autoPlace: !1 })),
				this._fpsMeter.show(!1),
				(this._fpsMeter.dom.style.zIndex = 1));
		}
		static _createModeBox() {
			const t = document.createElement('div');
			(t.id = 'modeTextBack'),
				(t.style.position = 'absolute'),
				(t.style.left = '5px'),
				(t.style.top = '5px'),
				(t.style.width = '119px'),
				(t.style.height = '58px'),
				(t.style.background = 'rgba(0,0,0,0.2)'),
				(t.style.zIndex = 9),
				(t.style.opacity = 0);
			const e = document.createElement('div');
			(e.id = 'modeText'),
				(e.style.position = 'absolute'),
				(e.style.left = '0px'),
				(e.style.top = '41px'),
				(e.style.width = '119px'),
				(e.style.fontSize = '12px'),
				(e.style.fontFamily = 'monospace'),
				(e.style.color = 'white'),
				(e.style.textAlign = 'center'),
				(e.style.textShadow = '1px 1px 0 rgba(0,0,0,0.5)'),
				(e.innerHTML = this.isWebGL() ? 'WebGL mode' : 'Canvas mode'),
				document.body.appendChild(t),
				t.appendChild(e),
				(this._modeBox = t);
		}
		static _createGameFontLoader() {
			this._createFontLoader('GameFont');
		}
		static _centerElement(t) {
			const e = t.width * this._realScale,
				i = t.height * this._realScale;
			(t.style.position = 'absolute'),
				(t.style.margin = 'auto'),
				(t.style.top = 0),
				(t.style.left = 0),
				(t.style.right = 0),
				(t.style.bottom = 0),
				(t.style.width = `${e}px`),
				(t.style.height = `${i}px`);
		}
		static _applyCanvasFilter() {
			this._canvas &&
				((this._canvas.style.opacity = 0.5),
				(this._canvas.style.filter = 'blur(8px)'),
				(this._canvas.style.webkitFilter = 'blur(8px)'));
		}
		static _onVideoLoad() {}
		static _onVideoError() {}
		static _onVideoEnd() {}
		static _updateVisibility(t) {}
		static _isVideoVisible() {
			return !1;
		}
		static _setupEventHandlers() {
			window.addEventListener('resize', this._onWindowResize.bind(this)),
				document.addEventListener('keydown', this._onKeyDown.bind(this)),
				document.addEventListener('keydown', this._onTouchEnd.bind(this)),
				document.addEventListener('mousedown', this._onTouchEnd.bind(this)),
				document.addEventListener('touchend', this._onTouchEnd.bind(this));
		}
		static _onWindowResize() {
			this._updateAllElements();
		}
		static _onKeyDown(t) {
			if (!t.ctrlKey && !t.altKey)
				switch (t.keyCode) {
					case 113:
						t.preventDefault(), this._switchFPSMeter();
						break;
					case 114:
						t.preventDefault(), this._switchStretchMode();
						break;
					case 115:
						t.preventDefault(), this._switchFullScreen();
				}
		}
		static _onTouchEnd(t) {}
		static _switchFPSMeter() {
			this._fpsMeter && this._fpsMeterToggled
				? (this.hideFps(), (this._fpsMeterToggled = !1))
				: this._fpsMeter &&
				  !this._fpsMeterToggled &&
				  (this.showFps(), (this._fpsMeterToggled = !0));
		}
		static _switchStretchMode() {
			(this._stretchEnabled = !this._stretchEnabled), this._updateAllElements();
		}
		static _switchFullScreen() {
			this._isFullScreen()
				? this._cancelFullScreen()
				: this._requestFullScreen();
		}
		static _onTick(t) {
			this._fpsMeter && this._fpsMeter.shown && this._fpsMeter.begin(),
				this._app.stage && this._app.render(),
				this._fpsMeter && this._fpsMeter.shown && this._fpsMeter.end();
		}
		static _createPixiApp() {
			const t = {
				view: this._canvas,
				width: this._width,
				height: this._height,
				resolution: window.devicePixelRatio,
				powerPreference: 'high-performance',
				autoStart: !0,
			};
			try {
				(this._app = new Application(t)),
					this._app.ticker.remove(this._app.render, this._app),
					this._app.ticker.add(this._onTick, this);
			} catch (t) {
				this._app = null;
			}
		}
		static _setupCssFontLoading() {
			Graphics._cssFontLoading &&
				document.fonts.ready
					.then((t) => {
						Graphics._fontLoaded = t;
					})
					.catch((t) => {
						SceneManager.onError(t);
					});
		}
		static tickStart() {}
		static tickEnd() {}
		static hasWebGL() {
			if ('boolean' == typeof Graphics._canWebGL) return Graphics._canWebGL;
			try {
				const t = document.createElement('canvas'),
					e = !(!t.getContext('webgl') && !t.getContext('experimental-webgl'));
				return (Graphics._canWebGL = e), e;
			} catch (t) {
				return (Graphics._canWebGL = !1), !1;
			}
		}
		static callGC() {
			Graphics.isWebGL() && Graphics._renderer.textureGC.run();
		}
		static _makeErrorHtml(t, e) {
			return `<font color="yellow"><b>${t}</b></font><br><font color="white">${decodeURIComponent(
				e
			)}</font><br>`;
		}
		static _defaultStretchMode() {
			return Utils.isNwjs() || Utils.isMobileDevice() || Utils.isTauri();
		}
		static _modifyExistingElements() {
			const t = document.getElementsByTagName('*');
			for (let e = 0; e < t.length; e++)
				t[e].style.zIndex > 0 && (t[e].style.zIndex = 0);
		}
		static _formatEventInfo(t) {
			switch (String(t.eventType)) {
				case 'map_event':
					return 'MapID: %1, MapEventID: %2, page: %3, line: %4'.format(
						t.mapId,
						t.mapEventId,
						t.page,
						t.line
					);
				case 'common_event':
					return 'CommonEventID: %1, line: %2'.format(t.commonEventId, t.line);
				case 'battle_event':
					return 'TroopID: %1, page: %2, line: %3'.format(
						t.troopId,
						t.page,
						t.line
					);
				case 'test_event':
					return 'TestEvent, line: %1'.format(t.line);
				default:
					return 'No information';
			}
		}
		static _formatEventCommandInfo({ eventCommand: t, content: e }) {
			switch (String(t)) {
				case 'plugin_command':
					return `◆Plugin Command: ${e}`;
				case 'script':
					return `◆Script: ${e}`;
				case 'control_variables':
					return `◆Control Variables: Script: ${e}`;
				case 'conditional_branch_script':
					return `◆If: Script: ${e}`;
				case 'set_route_script':
					return `◆Set Movement Route: ◇Script: ${e}`;
				case 'auto_route_script':
					return `Autonomous Movement Custom Route: ◇Script: ${e}`;
				default:
					return '';
			}
		}
		static _formatStackTrace({ stack: t }) {
			return decodeURIComponent(
				(t || '')
					.replace(/file:.*js\//g, '')
					.replace(/http:.*js\//g, '')
					.replace(/https:.*js\//g, '')
					.replace(/chrome-extension:.*js\//g, '')
					.replace(/\n/g, '<br>')
			);
		}
		static _createRenderer() {}
		static _createFontLoader(t) {
			const e = document.createElement('div'),
				i = document.createTextNode('.');
			(e.style.fontFamily = t),
				(e.style.fontSize = '0px'),
				(e.style.color = 'transparent'),
				(e.style.position = 'absolute'),
				(e.style.margin = 'auto'),
				(e.style.top = '0px'),
				(e.style.left = '0px'),
				(e.style.width = '1px'),
				(e.style.height = '1px'),
				e.appendChild(i),
				document.body.appendChild(e);
		}
		static _disableTextSelection() {
			const t = document.body;
			(t.style.userSelect = 'none'),
				(t.style.webkitUserSelect = 'none'),
				(t.style.msUserSelect = 'none'),
				(t.style.mozUserSelect = 'none');
		}
		static _disableContextMenu() {
			const t = document.body.getElementsByTagName('*'),
				e = () => !1;
			for (let i = 0; i < t.length; i++) t[i].oncontextmenu = e;
		}
		static _isFullScreen() {
			return (
				document.fullscreenElement ||
				document.mozFullScreen ||
				document.webkitFullscreenElement ||
				document.msFullscreenElement
			);
		}
		static _requestFullScreen() {
			const t = document.body;
			t.requestFullscreen
				? t.requestFullscreen()
				: t.mozRequestFullScreen
				? t.mozRequestFullScreen()
				: t.webkitRequestFullScreen
				? t.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT)
				: t.msRequestFullscreen && t.msRequestFullscreen();
		}
		static _cancelFullScreen() {
			document.exitFullscreen
				? document.exitFullscreen()
				: document.mozCancelFullScreen
				? document.mozCancelFullScreen()
				: document.webkitCancelFullScreen
				? document.webkitCancelFullScreen()
				: document.msExitFullscreen && document.msExitFullscreen();
		}
	}
	(Graphics._cssFontLoading =
		document.fonts && document.fonts.ready && document.fonts.ready.then),
		(Graphics._fontLoaded = null),
		(Graphics._videoVolume = 1),
		Object.defineProperty(Graphics, 'app', {
			get() {
				return this._app;
			},
			configurable: !0,
		}),
		Object.defineProperty(Graphics, '_renderer', {
			get() {
				return this._app.renderer;
			},
			configurable: !0,
		}),
		(Graphics.frameCount = 0),
		(Graphics.BLEND_NORMAL = 0),
		(Graphics.BLEND_ADD = 1),
		(Graphics.BLEND_MULTIPLY = 2),
		(Graphics.BLEND_SCREEN = 3),
		(Graphics._canWebGL = null),
		Object.defineProperty(Graphics, 'width', {
			get() {
				return this._width;
			},
			set(t) {
				this._width !== t && ((this._width = t), this._updateAllElements());
			},
			configurable: !0,
		}),
		Object.defineProperty(Graphics, 'height', {
			get() {
				return this._height;
			},
			set(t) {
				this._height !== t && ((this._height = t), this._updateAllElements());
			},
			configurable: !0,
		}),
		Object.defineProperty(Graphics, 'boxWidth', {
			get() {
				return this._boxWidth;
			},
			set(t) {
				this._boxWidth = t;
			},
			configurable: !0,
		}),
		Object.defineProperty(Graphics, 'boxHeight', {
			get() {
				return this._boxHeight;
			},
			set(t) {
				this._boxHeight = t;
			},
			configurable: !0,
		}),
		Object.defineProperty(Graphics, 'scale', {
			get() {
				return this._scale;
			},
			set(t) {
				this._scale !== t && ((this._scale = t), this._updateAllElements());
			},
			configurable: !0,
		});
	class Rectangle extends Rectangle$4 {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e, i, r) {
			Rectangle$4.call(this, t, e, i, r);
		}
	}
	Rectangle.emptyRectangle = new Rectangle(0, 0, 0, 0);
	class Bitmap {
		constructor(...t) {
			this.initialize(...t);
		}
		_createCanvas(t, e) {
			if (
				((this.__canvas = this.__canvas || document.createElement('canvas')),
				(this.__context = this.__canvas.getContext('2d')),
				(this.__canvas.width = Math.max(t || 0, 1)),
				(this.__canvas.height = Math.max(e || 0, 1)),
				this._image)
			) {
				const t = Math.max(this._image.width || 0, 1),
					e = Math.max(this._image.height || 0, 1);
				(this.__canvas.width = t),
					(this.__canvas.height = e),
					this._createBaseTexture(this._canvas),
					this.__context.drawImage(this._image, 0, 0);
			}
			this._setDirty();
		}
		_createBaseTexture(t) {
			(this.__baseTexture = new BaseTexture$3(t)),
				(this.__baseTexture.mipmap = !1),
				(this.__baseTexture.width = t.width),
				(this.__baseTexture.height = t.height),
				(this._baseTexture.scaleMode = SCALE_MODES$9.NEAREST);
		}
		_clearImgInstance() {
			(this._image.src = ''),
				(this._image.onload = null),
				(this._image.onerror = null),
				(this._errorListener = null),
				(this._loadListener = null),
				Bitmap._reuseImages.push(this._image),
				(this._image = null);
		}
		_renewCanvas() {
			const t = this._image;
			t &&
				this.__canvas &&
				(this.__canvas.width < t.width || this.__canvas.height < t.height) &&
				this._createCanvas();
		}
		initialize(t, e) {
			this._defer || this._createCanvas(t, e),
				(this._image = null),
				(this._url = ''),
				(this._paintOpacity = 255),
				(this._smooth = !1),
				(this._loadListeners = []),
				(this._loadingState = 'none'),
				(this._decodeAfterRequest = !1),
				(this.cacheEntry = null),
				(this.fontFace = 'GameFont'),
				(this.fontSize = 28),
				(this.fontItalic = !1),
				(this.textColor = '#ffffff'),
				(this.outlineColor = 'rgba(0, 0, 0, 0.5)'),
				(this.outlineWidth = 4);
		}
		isReady() {
			return 'loaded' === this._loadingState || 'none' === this._loadingState;
		}
		isError() {
			return 'error' === this._loadingState;
		}
		touch() {
			this.cacheEntry && this.cacheEntry.touch();
		}
		get url() {
			return this._url;
		}
		get baseTexture() {
			return this._baseTexture;
		}
		get canvas() {
			return this._canvas;
		}
		get context() {
			return this._context;
		}
		get width() {
			return this.isReady()
				? this._image
					? this._image.width
					: this._canvas.width
				: 0;
		}
		get height() {
			return this.isReady()
				? this._image
					? this._image.height
					: this._canvas.height
				: 0;
		}
		get rect() {
			return new Rectangle(0, 0, this.width, this.height);
		}
		get smooth() {
			return this._smooth;
		}
		set smooth(t) {
			!1 !== this._smooth && (this._smooth = !1);
		}
		get paintOpacity() {
			return this._paintOpacity;
		}
		set paintOpacity(t) {
			this._paintOpacity !== t &&
				((this._paintOpacity = t),
				(this._context.globalAlpha = this._paintOpacity / 255));
		}
		resize(t, e) {
			(t = Math.max(t || 0, 1)),
				(e = Math.max(e || 0, 1)),
				(this._canvas.width = t),
				(this._canvas.height = e),
				(this._baseTexture.width = t),
				(this._baseTexture.height = e);
		}
		blt({ width: t, height: e, _canvas: i }, r, s, n, a, o, h, u, l) {
			(u = u || n),
				(l = l || a),
				(r = Math.floor(r)),
				(s = Math.floor(s)),
				(n = Math.floor(n)),
				(a = Math.floor(a)),
				(o = Math.floor(o)),
				(h = Math.floor(h)),
				(u = Math.floor(u)),
				(l = Math.floor(l)),
				r >= 0 &&
					s >= 0 &&
					n > 0 &&
					a > 0 &&
					u > 0 &&
					l > 0 &&
					r + n <= t &&
					s + a <= e &&
					((this._context.globalCompositeOperation = 'source-over'),
					this._context.drawImage(i, r, s, n, a, o, h, u, l),
					this._setDirty());
		}
		bltImage({ width: t, height: e, _image: i }, r, s, n, a, o, h, u, l) {
			(u = u || n),
				(l = l || a),
				r >= 0 &&
					s >= 0 &&
					n > 0 &&
					a > 0 &&
					u > 0 &&
					l > 0 &&
					r + n <= t &&
					s + a <= e &&
					((this._context.globalCompositeOperation = 'source-over'),
					this._context.drawImage(i, r, s, n, a, o, h, u, l),
					this._setDirty());
		}
		getPixel(t, e) {
			const i = this._context.getImageData(t, e, 1, 1).data;
			let r = '#';
			for (let t = 0; t < 3; t++) r += i[t].toString(16).padZero(2);
			return r;
		}
		getAlphaPixel(t, e) {
			return this._context.getImageData(t, e, 1, 1).data[3];
		}
		clearRect(t, e, i, r) {
			this._context.clearRect(t, e, i, r), this._setDirty();
		}
		clear() {
			this.clearRect(0, 0, this.width, this.height);
		}
		fillRect(t, e, i, r, s) {
			(t = Math.floor(t)),
				(e = Math.floor(e)),
				(i = Math.floor(i)),
				(r = Math.floor(r));
			const n = this._context;
			n.save(),
				(n.fillStyle = s),
				n.fillRect(t, e, i, r),
				n.restore(),
				this._setDirty();
		}
		fillAll(t) {
			this.fillRect(0, 0, this.width, this.height, t);
		}
		gradientFillRect(t, e, i, r, s, n, a) {
			const o = this._context;
			let h;
			(h = a
				? o.createLinearGradient(t, e, t, e + r)
				: o.createLinearGradient(t, e, t + i, e)),
				h.addColorStop(0, s),
				h.addColorStop(1, n),
				o.save(),
				(o.fillStyle = h),
				o.fillRect(t, e, i, r),
				o.restore(),
				this._setDirty();
		}
		drawCircle(t, e, i, r) {
			(t = Math.floor(t)), (e = Math.floor(e));
			const s = this._context;
			s.save(),
				(s.fillStyle = r),
				s.beginPath(),
				s.arc(t, e, i, 0, 2 * Math.PI, !1),
				s.fill(),
				s.restore(),
				this._setDirty();
		}
		drawText(t, e, i, r, s, n) {
			if (void 0 !== t) {
				(e = Math.floor(e)),
					(i = Math.floor(i)),
					(r = Math.floor(r) || 4294967295);
				let a = e;
				const o =
						i + (s = Math.floor(s)) - Math.round((s - 0.7 * this.fontSize) / 2),
					h = this._context,
					u = h.globalAlpha;
				'center' === n && (a += r / 2),
					'right' === n && (a += r),
					h.save(),
					(h.font = this._makeFontNameText()),
					(h.textAlign = n),
					(h.textBaseline = 'alphabetic'),
					(h.globalAlpha = 1),
					this._drawTextOutline(t, a, o, r),
					(h.globalAlpha = u),
					this._drawTextBody(t, a, o, r),
					h.restore(),
					this._setDirty();
			}
		}
		drawSmallText(t, e, i, r, s, n) {}
		measureTextWidth(t) {
			const e = this._context;
			e.save(), (e.font = this._makeFontNameText());
			const i = e.measureText(t).width;
			return e.restore(), i;
		}
		adjustTone(t, e, i) {
			if ((t || e || i) && this.width > 0 && this.height > 0) {
				const r = this._context,
					s = r.getImageData(0, 0, this.width, this.height),
					n = s.data;
				for (let r = 0; r < n.length; r += 4)
					(n[r + 0] += t), (n[r + 1] += e), (n[r + 2] += i);
				r.putImageData(s, 0, 0), this._setDirty();
			}
		}
		rotateHue(t) {
			if (t && t && this.width > 0 && this.height > 0) {
				t = ((t % 360) + 360) % 360;
				const r = this._context,
					s = r.getImageData(0, 0, this.width, this.height),
					n = s.data;
				for (let r = 0; r < n.length; r += 4) {
					const s = e(n[r + 0], n[r + 1], n[r + 2]),
						a = i((s[0] + t) % 360, s[1], s[2]);
					(n[r + 0] = a[0]), (n[r + 1] = a[1]), (n[r + 2] = a[2]);
				}
				r.putImageData(s, 0, 0), this._setDirty();
			}
			function e(t, e, i) {
				const r = Math.min(t, e, i),
					s = Math.max(t, e, i);
				let n = 0,
					a = 0;
				const o = (r + s) / 2,
					h = s - r;
				return (
					h > 0 &&
						((n =
							t === s
								? (((e - i) / h + 6) % 6) * 60
								: e === s
								? 60 * ((i - t) / h + 2)
								: 60 * ((t - e) / h + 4)),
						(a = h / (255 - Math.abs(2 * o - 255)))),
					[n, a, o]
				);
			}
			function i(t, e, i) {
				const r = (255 - Math.abs(2 * i - 255)) * e,
					s = i - r / 2,
					n = r + s,
					a = r * (1 - Math.abs(((t / 60) % 2) - 1)) + s;
				return t < 60
					? [n, a, s]
					: t < 120
					? [a, n, s]
					: t < 180
					? [s, n, a]
					: t < 240
					? [s, a, n]
					: t < 300
					? [a, s, n]
					: [n, s, a];
			}
		}
		blur() {
			for (let t = 0; t < 2; t++) {
				const t = this.width,
					e = this.height,
					i = this._canvas,
					r = this._context,
					s = document.createElement('canvas'),
					n = s.getContext('2d');
				(s.width = t + 2),
					(s.height = e + 2),
					n.drawImage(i, 0, 0, t, e, 1, 1, t, e),
					n.drawImage(i, 0, 0, t, 1, 1, 0, t, 1),
					n.drawImage(i, 0, 0, 1, e, 0, 1, 1, e),
					n.drawImage(i, 0, e - 1, t, 1, 1, e + 1, t, 1),
					n.drawImage(i, t - 1, 0, 1, e, t + 1, 1, 1, e),
					r.save(),
					(r.fillStyle = 'black'),
					r.fillRect(0, 0, t, e),
					(r.globalCompositeOperation = 'lighter'),
					(r.globalAlpha = 1 / 9);
				for (let i = 0; i < 3; i++)
					for (let n = 0; n < 3; n++) r.drawImage(s, n, i, t, e, 0, 0, t, e);
				r.restore();
			}
			this._setDirty();
		}
		addLoadListener(t) {
			this.isReady() ? t(this) : this._loadListeners.push(t);
		}
		_makeFontNameText() {
			return `${(this.fontItalic ? 'Italic ' : '') + this.fontSize}px ${
				this.fontFace
			}`;
		}
		_drawTextOutline(t, e, i, r) {
			const s = this._context;
			(s.strokeStyle = this.outlineColor),
				(s.lineWidth = this.outlineWidth),
				(s.lineJoin = 'round'),
				s.strokeText(t, e, i, r);
		}
		_drawTextBody(t, e, i, r) {
			const s = this._context;
			(s.fillStyle = this.textColor), s.fillText(t, e, i, r);
		}
		_onLoad() {
			switch (
				(this._image.removeEventListener('load', this._loadListener),
				this._image.removeEventListener('error', this._errorListener),
				this._renewCanvas(),
				this._loadingState)
			) {
				case 'requesting':
					(this._loadingState = 'requestCompleted'),
						this._decodeAfterRequest
							? this.decode()
							: ((this._loadingState = 'purged'), this._clearImgInstance());
					break;
				case 'decrypting':
					window.URL.revokeObjectURL(this._image.src),
						(this._loadingState = 'decryptCompleted'),
						this._decodeAfterRequest
							? this.decode()
							: ((this._loadingState = 'purged'), this._clearImgInstance());
			}
		}
		decode() {
			switch (this._loadingState) {
				case 'requestCompleted':
				case 'decryptCompleted':
					(this._loadingState = 'loaded'),
						this.__canvas || this._createBaseTexture(this._image),
						this._setDirty(),
						this._callLoadListeners();
					break;
				case 'requesting':
				case 'decrypting':
					(this._decodeAfterRequest = !0),
						this._loader ||
							((this._loader = ResourceHandler.createLoader(
								this._url,
								this._requestImage.bind(this, this._url),
								this._onError.bind(this)
							)),
							this._image.removeEventListener('error', this._errorListener),
							this._image.addEventListener(
								'error',
								(this._errorListener = this._loader)
							));
					break;
				case 'pending':
				case 'purged':
				case 'error':
					(this._decodeAfterRequest = !0), this._requestImage(this._url);
			}
		}
		_callLoadListeners() {
			for (; this._loadListeners.length > 0; )
				this._loadListeners.shift()(this);
		}
		_onError() {
			this._image.removeEventListener('load', this._loadListener),
				this._image.removeEventListener('error', this._errorListener),
				(this._loadingState = 'error');
		}
		_setDirty() {
			this._dirty = !0;
		}
		checkDirty() {
			if (this._dirty) {
				this._baseTexture.update();
				const t = this._baseTexture;
				setTimeout(() => {
					t.update();
				}, 0),
					(this._dirty = !1);
			}
		}
		_requestImage(t) {
			0 !== Bitmap._reuseImages.length
				? (this._image = Bitmap._reuseImages.pop())
				: (this._image = new Image()),
				this._decodeAfterRequest &&
					!this._loader &&
					(this._loader = ResourceHandler.createLoader(
						t,
						this._requestImage.bind(this, t),
						this._onError.bind(this)
					)),
				(this._url = t),
				(this._loadingState = 'requesting'),
				!Decrypter.checkImgIgnore(t) && Decrypter.hasEncryptedImages
					? ((this._loadingState = 'decrypting'), Decrypter.decryptImg(t, this))
					: ((this._image.src = t),
					  this._image.addEventListener(
							'load',
							(this._loadListener = Bitmap.prototype._onLoad.bind(this))
					  ),
					  this._image.addEventListener(
							'error',
							(this._errorListener =
								this._loader || Bitmap.prototype._onError.bind(this))
					  ));
		}
		isRequestOnly() {
			return !(this._decodeAfterRequest || this.isReady());
		}
		isRequestReady() {
			return (
				'pending' !== this._loadingState &&
				'requesting' !== this._loadingState &&
				'decrypting' !== this._loadingState
			);
		}
		startRequest() {
			'pending' === this._loadingState &&
				((this._decodeAfterRequest = !1), this._requestImage(this._url));
		}
		static load(t) {
			const e = Object.create(Bitmap.prototype);
			return (
				(e._defer = !0),
				e.initialize(),
				(e._decodeAfterRequest = !0),
				e._requestImage(t),
				e
			);
		}
		static snap(t) {
			const e = Graphics.width,
				i = Graphics.height,
				r = new Bitmap(e, i),
				s = r._context,
				n = RenderTexture$3.create({ width: e, height: i });
			if (t) {
				Graphics._renderer.render(t, { renderTexture: n }),
					t.worldTransform.identity();
				let e = null;
				(e = Graphics.isWebGL()
					? Graphics._renderer.plugins.extract.canvas(n)
					: n.baseTexture._canvasRenderTarget.canvas),
					s.drawImage(e, 0, 0);
			}
			return n.destroy({ destroyBase: !0 }), r._setDirty(), r;
		}
		static request(t) {
			const e = Object.create(Bitmap.prototype);
			return (
				(e._defer = !0),
				e.initialize(),
				(e._url = t),
				(e._loadingState = 'pending'),
				e
			);
		}
	}
	(Bitmap._reuseImages = []),
		Object.defineProperties(Bitmap.prototype, {
			_canvas: {
				get() {
					return this.__canvas || this._createCanvas(), this.__canvas;
				},
			},
			_context: {
				get() {
					return this.__context || this._createCanvas(), this.__context;
				},
			},
			_baseTexture: {
				get() {
					return (
						this.__baseTexture ||
							this._createBaseTexture(this._image || this.__canvas),
						this.__baseTexture
					);
				},
			},
		});
	class ImageManager {
		constructor() {
			throw new Error('This is a static class');
		}
		static loadAnimation(t, e) {
			return this.loadBitmap('img/animations/', t, e, !0);
		}
		static loadBattleback1(t, e) {
			return this.loadBitmap('img/battlebacks1/', t, e, !0);
		}
		static loadBattleback2(t, e) {
			return this.loadBitmap('img/battlebacks2/', t, e, !0);
		}
		static loadEnemy(t, e) {
			return this.loadBitmap('img/enemies/', t, e, !0);
		}
		static loadCharacter(t, e) {
			return this.loadBitmap('img/characters/', t, e, !1);
		}
		static loadFace(t, e) {
			return this.loadBitmap('img/faces/', t, e, !0);
		}
		static loadParallax(t, e) {
			return this.loadBitmap('img/parallaxes/', t, e, !0);
		}
		static loadPicture(t, e) {
			return this.loadBitmap('img/pictures/', t, e, !0);
		}
		static loadSvActor(t, e) {
			return this.loadBitmap('img/sv_actors/', t, e, !1);
		}
		static loadSvEnemy(t, e) {
			return this.loadBitmap('img/sv_enemies/', t, e, !0);
		}
		static loadSystem(t, e) {
			return this.loadBitmap('img/system/', t, e, !1);
		}
		static loadTileset(t, e) {
			return this.loadBitmap('img/tilesets/', t, e, !1);
		}
		static loadTitle1(t, e) {
			return this.loadBitmap('img/titles1/', t, e, !0);
		}
		static loadTitle2(t, e) {
			return this.loadBitmap('img/titles2/', t, e, !0);
		}
		static loadBitmap(t, e, i, r) {
			if (e) {
				const r = `${t + encodeURIComponent(e)}.png`,
					s = this.loadNormalBitmap(r, i || 0);
				return (s.smooth = !1), s;
			}
			return this.loadEmptyBitmap();
		}
		static loadEmptyBitmap() {
			let t = this._imageCache.get('empty');
			return (
				t ||
					((t = new Bitmap()),
					this._imageCache.add('empty', t),
					this._imageCache.reserve('empty', t, this._systemReservationId)),
				t
			);
		}
		static loadNormalBitmap(t, e) {
			const i = this._generateCacheKey(t, e);
			let r = this._imageCache.get(i);
			return (
				r
					? r.isReady() || r.decode()
					: ((r = Bitmap.load(t)),
					  this._callCreationHook(r),
					  r.addLoadListener(() => {
							r.rotateHue(e);
					  }),
					  this._imageCache.add(i, r)),
				r
			);
		}
		static clear() {
			this._imageCache = new ImageCache();
		}
		static isReady() {
			return this._imageCache.isReady();
		}
		static reserveAnimation(t, e, i) {
			return this.reserveBitmap('img/animations/', t, e, !0, i);
		}
		static reserveBattleback1(t, e, i) {
			return this.reserveBitmap('img/battlebacks1/', t, e, !0, i);
		}
		static reserveBattleback2(t, e, i) {
			return this.reserveBitmap('img/battlebacks2/', t, e, !0, i);
		}
		static reserveEnemy(t, e, i) {
			return this.reserveBitmap('img/enemies/', t, e, !0, i);
		}
		static reserveCharacter(t, e, i) {
			return this.reserveBitmap('img/characters/', t, e, !1, i);
		}
		static reserveFace(t, e, i) {
			return this.reserveBitmap('img/faces/', t, e, !0, i);
		}
		static reserveParallax(t, e, i) {
			return this.reserveBitmap('img/parallaxes/', t, e, !0, i);
		}
		static reservePicture(t, e, i) {
			return this.reserveBitmap('img/pictures/', t, e, !0, i);
		}
		static reserveSvActor(t, e, i) {
			return this.reserveBitmap('img/sv_actors/', t, e, !1, i);
		}
		static reserveSvEnemy(t, e, i) {
			return this.reserveBitmap('img/sv_enemies/', t, e, !0, i);
		}
		static reserveSystem(t, e, i) {
			return this.reserveBitmap(
				'img/system/',
				t,
				e,
				!1,
				i || this._systemReservationId
			);
		}
		static reserveTileset(t, e, i) {
			return this.reserveBitmap('img/tilesets/', t, e, !1, i);
		}
		static reserveTitle1(t, e, i) {
			return this.reserveBitmap('img/titles1/', t, e, !0, i);
		}
		static reserveTitle2(t, e, i) {
			return this.reserveBitmap('img/titles2/', t, e, !0, i);
		}
		static reserveBitmap(t, e, i, r, s) {
			if (e) {
				const r = `${t + encodeURIComponent(e)}.png`,
					n = this.reserveNormalBitmap(
						r,
						i || 0,
						s || this._defaultReservationId
					);
				return (n.smooth = !1), n;
			}
			return this.loadEmptyBitmap();
		}
		static reserveNormalBitmap(t, e, i) {
			const r = this.loadNormalBitmap(t, e);
			return this._imageCache.reserve(this._generateCacheKey(t, e), r, i), r;
		}
		static releaseReservation(t) {
			this._imageCache.releaseReservation(t);
		}
		static setDefaultReservationId(t) {
			this._defaultReservationId = t;
		}
		static requestAnimation(t, e) {
			return this.requestBitmap('img/animations/', t, e, !0);
		}
		static requestBattleback1(t, e) {
			return this.requestBitmap('img/battlebacks1/', t, e, !0);
		}
		static requestBattleback2(t, e) {
			return this.requestBitmap('img/battlebacks2/', t, e, !0);
		}
		static requestEnemy(t, e) {
			return this.requestBitmap('img/enemies/', t, e, !0);
		}
		static requestCharacter(t, e) {
			return this.requestBitmap('img/characters/', t, e, !1);
		}
		static requestFace(t, e) {
			return this.requestBitmap('img/faces/', t, e, !0);
		}
		static requestParallax(t, e) {
			return this.requestBitmap('img/parallaxes/', t, e, !0);
		}
		static requestPicture(t, e) {
			return this.requestBitmap('img/pictures/', t, e, !0);
		}
		static requestSvActor(t, e) {
			return this.requestBitmap('img/sv_actors/', t, e, !1);
		}
		static requestSvEnemy(t, e) {
			return this.requestBitmap('img/sv_enemies/', t, e, !0);
		}
		static requestSystem(t, e) {
			return this.requestBitmap('img/system/', t, e, !1);
		}
		static requestTileset(t, e) {
			return this.requestBitmap('img/tilesets/', t, e, !1);
		}
		static requestTitle1(t, e) {
			return this.requestBitmap('img/titles1/', t, e, !0);
		}
		static requestTitle2(t, e) {
			return this.requestBitmap('img/titles2/', t, e, !0);
		}
		static requestBitmap(t, e, i, r) {
			if (e) {
				const r = `${t + encodeURIComponent(e)}.png`,
					s = this.requestNormalBitmap(r, i || 0);
				return (s.smooth = !1), s;
			}
			return this.loadEmptyBitmap();
		}
		static requestNormalBitmap(t, e) {
			const i = this._generateCacheKey(t, e);
			let r = this._imageCache.get(i);
			return (
				r
					? this._requestQueue.raisePriority(i)
					: ((r = Bitmap.request(t)),
					  this._callCreationHook(r),
					  r.addLoadListener(() => {
							r.rotateHue(e);
					  }),
					  this._imageCache.add(i, r),
					  this._requestQueue.enqueue(i, r)),
				r
			);
		}
		static update() {
			this._requestQueue.update();
		}
		static clearRequest() {
			this._requestQueue.clear();
		}
		static setCreationHook(t) {
			this._creationHook = t;
		}
		static _callCreationHook(t) {
			this._creationHook && this._creationHook(t);
		}
		static isObjectCharacter(t) {
			const e = t.match(/^[\!\$]+/);
			return e && e[0].contains('!');
		}
		static isBigCharacter(t) {
			const e = t.match(/^[\!\$]+/);
			return e && e[0].contains('$');
		}
		static isZeroParallax(t) {
			return '!' === t.charAt(0);
		}
		static _generateCacheKey(t, e) {
			return `${t}:${e}`;
		}
	}
	(ImageManager.cache = new CacheMap(ImageManager)),
		(ImageManager._imageCache = new ImageCache()),
		(ImageManager._requestQueue = new RequestQueue()),
		(ImageManager._systemReservationId = Utils.generateRuntimeId());
	class ProgressWatcher {
		constructor() {
			throw new Error('This is a static class');
		}
		static initialize() {
			this.clearProgress(),
				ImageManager.setCreationHook(this._bitmapListener.bind(this)),
				AudioManager.setCreationHook(this._audioListener.bind(this));
		}
		static _bitmapListener(t) {
			this._countLoading++,
				t.addLoadListener(() => {
					this._countLoaded++,
						this._progressListener &&
							this._progressListener(this._countLoaded, this._countLoading);
				});
		}
		static _audioListener(t) {
			this._countLoading++,
				t.addLoadListener(() => {
					this._countLoaded++,
						this._progressListener &&
							this._progressListener(this._countLoaded, this._countLoading);
				});
		}
		static setProgressListener(t) {
			this._progressListener = t;
		}
		static clearProgress() {
			(this._countLoading = 0), (this._countLoaded = 0);
		}
		static truncateProgress() {
			this._countLoaded &&
				((this._countLoading -= this._countLoaded), (this._countLoaded = 0));
		}
	}
	class Point extends Point$4 {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e) {
			Point$4.call(this, t, e);
		}
	}
	class BitmapPIXI extends Container$2 {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e) {
			Container$2.call(this),
				(t = Math.max(t || 0, 1)),
				(e = Math.max(e || 0, 1)),
				(this._width = t),
				(this._height = e),
				(this._paintOpacity = 255),
				(this.textPadding = 2),
				(this.wordWrap = !1),
				(this.wordWrapWidth = 0),
				(this.fontFace = 'GameFont'),
				(this.fontSize = 28),
				(this.fontItalic = !1),
				(this.textColor = '#ffffff'),
				(this.outlineColor = 'rgba(0, 0, 0, 0.5)'),
				(this.outlineWidth = 4),
				(this.textCache = []),
				this.on('removed', this.onRemoveAsAChild);
		}
		onRemoveAsAChild() {
			this.textCache = [];
			for (let t = this.children.length - 1; t >= 0; t--)
				this.children[t].destroy({ children: !0, texture: !0 }),
					this.removeChild(this.children[t]);
		}
		get paintOpacity() {
			return this._paintOpacity;
		}
		set paintOpacity(t) {
			this._paintOpacity !== t && (this._paintOpacity = t);
		}
		get width() {
			return this._width;
		}
		set width(t) {
			this._width !== t && (this._width = t);
		}
		get height() {
			return this._height;
		}
		set height(t) {
			this._height !== t && (this._height = t);
		}
		resize(t, e) {
			(t = Math.max(t || 0, 1)),
				(e = Math.max(e || 0, 1)),
				(this._width = t),
				(this._height = e);
		}
		clear() {
			for (let t = this.children.length - 1; t >= 0; t--)
				this.children[t].isBitmapText
					? (this.children[t].text = '')
					: (this.children[t].destroy({ children: !0, texture: !0 }),
					  this.removeChild(this.children[t]));
		}
		clearRect(t, e, i, r) {
			const s = this,
				n = [];
			this.children.forEach((s) => {
				s &&
					s.x >= t &&
					s.x < t + i &&
					s.y >= e &&
					s.y < e + r &&
					(s.isBitmapText ? (s.text = '') : n.push(s));
			}),
				n.forEach((t) => {
					t.destroy({ children: !0, texture: !0 }), s.removeChild(t);
				});
		}
		drawText(t, e, i, r, s, n) {
			if (void 0 === t) return;
			const a = this._paintOpacity / 255;
			(r = Math.floor(r) || 4294967295),
				(s = Math.floor(s)),
				(t = String(t)),
				'center' === n ? (e += r / 2) : 'right' === n && (e += r),
				(i = i + s - 1.25 * this.fontSize),
				(e = Math.floor(e)),
				(i = Math.floor(i)),
				this._updateExistingText(t, e, i, a) ||
					this._drawNewText(t, e, i, a, r, s, n);
		}
		_updateExistingText(t, e, i, r) {
			for (const s of this.textCache)
				if (s.x === e && s.y === i) {
					const e = string2hex(this.textColor);
					return (
						s._tint !== e && (s.tint = e),
						s.text !== t && (s.text = t),
						s.alpha !== r && (s.alpha = r),
						this.addChild(s),
						!0
					);
				}
			return !1;
		}
		_drawNewText(t, e, i, r, s, n, a) {
			const o = {
				fontFamily: this.fontFace,
				fontSize: this.fontSize,
				fill: 16777215,
				lineHeight: n,
				wordWrap: this.wordWrap,
				wordWrapWidth: this.wordWrapWidth,
				padding: this.textPadding,
				fontStyle: this.fontItalic ? 'italic' : 'normal',
				stroke: this.outlineColor,
				strokeThickness: this.outlineWidth,
			};
			BitmapFont.available[o.fontFamily] || this._makeBitmapFont(o);
			const h = new BitmapText(t, {
				fontName: o.fontFamily,
				fontSize: o.fontSize,
			});
			!o.wordWrap && h.width > s && (h.scale.x = s / h.width),
				'center' === a
					? h.anchor.set(0.5, 0)
					: 'right' === a && h.anchor.set(1, 0),
				h &&
					((h.x = e),
					(h.y = i),
					(h.tint = string2hex(this.textColor)),
					(h.alpha = r),
					(h.isBitmapText = !0),
					this.textCache.push(h),
					this.addChild(h));
		}
		_makeBitmapFont(t) {
			BitmapFont.from(t.fontFamily, t, { chars: [[' ', '~'], '→', '’'] });
		}
		measureTextWidth(t) {
			t = String(t);
			const e = new TextStyle({
				fontFamily: this.fontFace,
				fontSize: this.fontSize,
				padding: this.textPadding,
			});
			return TextMetrics.measureText(t, e).width;
		}
		create9Slice(t, e, i, r, s, n, a, o, h) {
			return new NineSlicePlane(
				new Texture$3(t, new Rectangle$4(e, i, r, s)),
				n,
				a,
				o,
				h
			);
		}
		createTilingSprite(t, e, i, r, s, n, a) {
			return new TilingSprite$1(
				new Texture$3(t, new Rectangle$4(e, i, r, s)),
				n,
				a
			);
		}
		createCroppedSprite(t, e, i, r, s) {
			return new Sprite$1(new Texture$3(t, new Rectangle$4(e, i, r, s)));
		}
		blt({ width: t, height: e, baseTexture: i }, r, s, n, a, o, h, u, l) {
			if (
				((u = u || n),
				(l = l || a),
				(r = Math.floor(r)),
				(s = Math.floor(s)),
				(n = Math.floor(n)),
				(a = Math.floor(a)),
				(o = Math.floor(o)),
				(h = Math.floor(h)),
				(u = Math.floor(u)),
				(l = Math.floor(l)),
				r >= 0 &&
					s >= 0 &&
					n > 0 &&
					a > 0 &&
					u > 0 &&
					l > 0 &&
					r + n <= t &&
					s + a <= e)
			) {
				const t = this.createCroppedSprite(i, r, s, n, a);
				if (t)
					return (
						(t.x = o),
						(t.y = h),
						(t.width = u),
						(t.height = l),
						(t.alpha = this._paintOpacity / 255),
						this.addChild(t),
						t
					);
			}
		}
		fillRect(t, e, i, r, s) {
			(t = Math.floor(t)),
				(e = Math.floor(e)),
				(i = Math.floor(i)),
				(r = Math.floor(r));
			const n = new Graphics$1();
			return (
				(s = string2hex(s)),
				n.beginFill(s),
				n.drawRect(0, 0, i, r),
				n.endFill(),
				n &&
					((n.x = t),
					(n.y = e),
					(n.alpha = this._paintOpacity / 255),
					this.addChild(n)),
				n
			);
		}
		gradientFillRect(t, e, i, r, s, n, a) {
			return this.fillRect(t, e, i, r, s);
		}
		drawCircle(t, e, i, r) {
			(t = Math.floor(t)), (e = Math.floor(e));
			const s = new Graphics$1();
			return (
				(r = string2hex(r)),
				s.beginFill(r),
				s.drawCircle(0, 0, i),
				s.endFill(),
				s &&
					((s.x = t),
					(s.y = e),
					(s.alpha = this._paintOpacity / 255),
					this.addChild(s)),
				s
			);
		}
	}
	class Sprite extends Sprite$1 {
		constructor(...t) {
			super(), this.initialize(...t);
		}
		initialize(t) {
			const e = new Texture$3(new BaseTexture$3());
			Sprite$1.call(this, e),
				(this.filters = null),
				(this._bitmap = null),
				(this._frame = new Rectangle()),
				(this._realFrame = new Rectangle()),
				(this._blendColor = [0, 0, 0, 0]),
				(this._colorTone = [0, 0, 0, 0]),
				(this._canvas = null),
				(this._context = null),
				(this._tintTexture = null),
				(this._colorMatrixFilter = null),
				(this.spriteId = Sprite._counter++),
				(this.opaque = !1),
				(this.bitmap = t);
		}
		get bitmap() {
			return this._bitmap;
		}
		set bitmap(t) {
			this._bitmap !== t &&
				((this._bitmap = t),
				t
					? ((this._refreshFrame = !0),
					  t.addLoadListener(this._onBitmapLoad.bind(this)))
					: ((this._refreshFrame = !1),
					  (this.texture.frame = Rectangle.emptyRectangle)));
		}
		get width() {
			return this._frame.width;
		}
		set width(t) {
			(this._frame.width = t), this._refresh();
		}
		get height() {
			return this._frame.height;
		}
		set height(t) {
			(this._frame.height = t), this._refresh();
		}
		get opacity() {
			return 255 * this.alpha;
		}
		set opacity(t) {
			this.alpha = t.clamp(0, 255) / 255;
		}
		update() {
			this.children.forEach((t) => {
				t.update && t.update();
			});
		}
		move(t, e) {
			(this.x = t), (this.y = e);
		}
		setFrame(t, e, i, r) {
			this._refreshFrame = !1;
			const s = this._frame;
			(t === s.x && e === s.y && i === s.width && r === s.height) ||
				((s.x = t), (s.y = e), (s.width = i), (s.height = r), this._refresh());
		}
		getBlendColor() {
			return this._blendColor.clone();
		}
		setBlendColor(t) {
			if (!(t instanceof Array)) throw new Error('Argument must be an array');
			this._blendColor.equals(t) ||
				((this._blendColor = t.clone()), this._refresh());
		}
		getColorTone() {
			return this._colorTone.clone();
		}
		setColorTone(t) {
			if (!(t instanceof Array)) throw new Error('Argument must be an array');
			this._colorTone.equals(t) ||
				((this._colorTone = t.clone()), this._refresh());
		}
		_onBitmapLoad(t) {
			t === this._bitmap &&
				this._refreshFrame &&
				this._bitmap &&
				((this._refreshFrame = !1),
				(this._frame.width = this._bitmap.width),
				(this._frame.height = this._bitmap.height)),
				this._refresh();
		}
		_refresh() {
			const t = Math.floor(this._frame.x),
				e = Math.floor(this._frame.y),
				i = Math.floor(this._frame.width),
				r = Math.floor(this._frame.height),
				s = this._bitmap ? this._bitmap.width : 0,
				n = this._bitmap ? this._bitmap.height : 0,
				a = t.clamp(0, s),
				o = e.clamp(0, n),
				h = (i - a + t).clamp(0, s - a),
				u = (r - o + e).clamp(0, n - o);
			(this._realFrame.x = a),
				(this._realFrame.y = o),
				(this._realFrame.width = h),
				(this._realFrame.height = u),
				(this.pivot.x = t - a),
				(this.pivot.y = e - o),
				h > 0 && u > 0
					? this._needsTint()
						? Graphics.isWebGL()
							? (this._createTinterWebGL(), this._executeTintWebGL())
							: (this._createTinter(h, u),
							  this._executeTint(a, o, h, u),
							  this._tintTexture.update(),
							  (this.texture.baseTexture = this._tintTexture),
							  (this.texture.frame = new Rectangle(0, 0, h, u)))
						: (this._bitmap &&
								(this.texture.baseTexture = this._bitmap.baseTexture),
						  (this.texture.frame = this._realFrame),
						  this._clearTintWebGL())
					: this._bitmap
					? (this.texture.frame = Rectangle.emptyRectangle)
					: ((this.texture.baseTexture.width = Math.max(
							this.texture.baseTexture.width,
							this._frame.x + this._frame.width
					  )),
					  (this.texture.baseTexture.height = Math.max(
							this.texture.baseTexture.height,
							this._frame.y + this._frame.height
					  )),
					  (this.texture.frame = this._frame)),
				this.texture._updateID++;
		}
		_isInBitmapRect(t, e, i, r) {
			return (
				this._bitmap &&
				t + i > 0 &&
				e + r > 0 &&
				t < this._bitmap.width &&
				e < this._bitmap.height
			);
		}
		_needsTint() {
			const t = this._colorTone;
			return t[0] || t[1] || t[2] || t[3] || this._blendColor[3] > 0;
		}
		_createTinter(t, e) {
			this._canvas ||
				((this._canvas = document.createElement('canvas')),
				(this._context = this._canvas.getContext('2d'))),
				(this._canvas.width = t),
				(this._canvas.height = e),
				this._tintTexture ||
					(this._tintTexture = new BaseTexture$3(this._canvas)),
				(this._tintTexture.width = t),
				(this._tintTexture.height = e),
				(this._tintTexture.scaleMode = this._bitmap.baseTexture.scaleMode);
		}
		_executeTint(t, e, i, r) {
			const s = this._context,
				n = this._colorTone,
				a = this._blendColor;
			if (
				((s.globalCompositeOperation = 'copy'),
				s.drawImage(this._bitmap.canvas, t, e, i, r, 0, 0, i, r),
				n[0] || n[1] || n[2] || n[3])
			) {
				if (Graphics.canUseSaturationBlend()) {
					const t = Math.max(0, n[3]);
					(s.globalCompositeOperation = 'saturation'),
						(s.fillStyle = `rgba(255,255,255,${t / 255})`),
						s.fillRect(0, 0, i, r);
				}
				const t = Math.max(0, n[0]),
					e = Math.max(0, n[1]),
					a = Math.max(0, n[2]);
				if (
					((s.globalCompositeOperation = 'lighter'),
					(s.fillStyle = Utils.rgbToCssColor(t, e, a)),
					s.fillRect(0, 0, i, r),
					Graphics.canUseDifferenceBlend())
				) {
					(s.globalCompositeOperation = 'difference'),
						(s.fillStyle = 'white'),
						s.fillRect(0, 0, i, r);
					const t = Math.max(0, -n[0]),
						e = Math.max(0, -n[1]),
						a = Math.max(0, -n[2]);
					(s.globalCompositeOperation = 'lighter'),
						(s.fillStyle = Utils.rgbToCssColor(t, e, a)),
						s.fillRect(0, 0, i, r),
						(s.globalCompositeOperation = 'difference'),
						(s.fillStyle = 'white'),
						s.fillRect(0, 0, i, r);
				}
			}
			const o = Math.max(0, a[0]),
				h = Math.max(0, a[1]),
				u = Math.max(0, a[2]),
				l = Math.max(0, a[3]);
			(s.globalCompositeOperation = 'source-atop'),
				(s.fillStyle = Utils.rgbToCssColor(o, h, u)),
				(s.globalAlpha = l / 255),
				s.fillRect(0, 0, i, r),
				(s.globalCompositeOperation = 'destination-in'),
				(s.globalAlpha = 1),
				s.drawImage(this._bitmap.canvas, t, e, i, r, 0, 0, i, r);
		}
		_createTinterWebGL() {
			this.filters || (this.filters = []),
				this._colorMatrixFilter ||
					((this._colorMatrixFilter = new filters.ColorMatrixFilter()),
					this.filters.push(this._colorMatrixFilter)),
				(this._colorMatrixFilter.enabled = !0);
		}
		_executeTintWebGL() {
			const t = this._blendColor,
				e = t[0] / 255,
				i = t[1] / 255,
				r = t[2] / 255,
				s = t[3] / 255;
			(this._colorMatrixFilter.matrix = [
				e / 64,
				0,
				0,
				0,
				e,
				0,
				i / 64,
				0,
				0,
				i,
				0,
				0,
				r / 64,
				0,
				r,
				0,
				0,
				0,
				1,
				0,
			]),
				(this._colorMatrixFilter.alpha = s);
		}
		_clearTintWebGL() {
			this._colorMatrixFilter && (this._colorMatrixFilter.enabled = !1);
		}
		_renderCanvas(t) {
			this.bitmap && this.bitmap.touch(),
				(this.bitmap && !this.bitmap.isReady()) ||
					(this.texture.frame.width > 0 &&
						this.texture.frame.height > 0 &&
						this._renderCanvas_PIXI(t));
		}
		_render(t) {
			this.bitmap && this.bitmap.touch(),
				(this.bitmap && !this.bitmap.isReady()) ||
					(this.texture.frame.width > 0 &&
						this.texture.frame.height > 0 &&
						(this._bitmap && this._bitmap.checkDirty(), this._render_PIXI(t)));
		}
	}
	(Sprite.voidFilter = new filters.AlphaFilter()),
		(Sprite._counter = 0),
		(Sprite.prototype._renderCanvas_PIXI = Sprite$1.prototype._renderCanvas),
		(Sprite.prototype._render_PIXI = Sprite$1.prototype._render);
	class Tilemap extends Container$2 {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			Container$2.call(this),
				(this._margin = 20),
				(this._width = Graphics.width + 2 * this._margin),
				(this._height = Graphics.height + 2 * this._margin),
				(this._tileWidth = 48),
				(this._tileHeight = 48),
				(this._mapWidth = 0),
				(this._mapHeight = 0),
				(this._mapData = null),
				(this._layerWidth = 0),
				(this._layerHeight = 0),
				(this._lastTiles = []),
				(this.bitmaps = []),
				(this.origin = new Point()),
				(this.flags = []),
				(this.animationCount = 0),
				(this.horizontalWrap = !1),
				(this.verticalWrap = !1),
				this._createLayers(),
				this.refresh();
		}
		get width() {
			return this._width;
		}
		set width(t) {
			this._width !== t && ((this._width = t), this._createLayers());
		}
		get height() {
			return this._height;
		}
		set height(t) {
			this._height !== t && ((this._height = t), this._createLayers());
		}
		get tileWidth() {
			return this._tileWidth;
		}
		set tileWidth(t) {
			this._tileWidth !== t && ((this._tileWidth = t), this._createLayers());
		}
		get tileHeight() {
			return this._tileHeight;
		}
		set tileHeight(t) {
			this._tileHeight !== t && ((this._tileHeight = t), this._createLayers());
		}
		setData(t, e, i) {
			(this._mapWidth = t), (this._mapHeight = e), (this._mapData = i);
		}
		isReady() {
			for (let t = 0; t < this.bitmaps.length; t++)
				if (this.bitmaps[t] && !this.bitmaps[t].isReady()) return !1;
			return !0;
		}
		update() {
			this.animationCount++,
				(this.animationFrame = Math.floor(this.animationCount / 30)),
				this.children.forEach((t) => {
					t.update && t.update();
				});
			for (let t = 0; t < this.bitmaps.length; t++)
				this.bitmaps[t] && this.bitmaps[t].touch();
		}
		refresh() {
			this._lastTiles.length = 0;
		}
		refreshTileset() {}
		updateTransform() {
			const t = Math.floor(this.origin.x),
				e = Math.floor(this.origin.y),
				i = Math.floor((t - this._margin) / this._tileWidth),
				r = Math.floor((e - this._margin) / this._tileHeight);
			this._updateLayerPositions(i, r),
				(this._needsRepaint ||
					this._lastAnimationFrame !== this.animationFrame ||
					this._lastStartX !== i ||
					this._lastStartY !== r) &&
					((this._frameUpdated =
						this._lastAnimationFrame !== this.animationFrame),
					(this._lastAnimationFrame = this.animationFrame),
					(this._lastStartX = i),
					(this._lastStartY = r),
					this._paintAllTiles(i, r),
					(this._needsRepaint = !1)),
				this._sortChildren(),
				super.updateTransform();
		}
		_createLayers() {
			const t = this._width,
				e = this._height,
				i = this._margin,
				r = Math.ceil(t / this._tileWidth) + 1,
				s = Math.ceil(e / this._tileHeight) + 1,
				n = r * this._tileWidth,
				a = s * this._tileHeight;
			(this._lowerBitmap = new Bitmap(n, a)),
				(this._upperBitmap = new Bitmap(n, a)),
				(this._layerWidth = n),
				(this._layerHeight = a),
				(this._lowerLayer = new Sprite()),
				this._lowerLayer.move(-i, -i, t, e),
				(this._lowerLayer.z = 0),
				(this._upperLayer = new Sprite()),
				this._upperLayer.move(-i, -i, t, e),
				(this._upperLayer.z = 4);
			for (let t = 0; t < 4; t++)
				this._lowerLayer.addChild(new Sprite(this._lowerBitmap)),
					this._upperLayer.addChild(new Sprite(this._upperBitmap));
			this.addChild(this._lowerLayer), this.addChild(this._upperLayer);
		}
		_updateLayerPositions(t, e) {
			const i = this._margin,
				r = Math.floor(this.origin.x),
				s = Math.floor(this.origin.y),
				n = (r - i).mod(this._layerWidth),
				a = (s - i).mod(this._layerHeight),
				o = this._layerWidth - n,
				h = this._layerHeight - a,
				u = this._width - o,
				l = this._height - h;
			for (let t = 0; t < 2; t++) {
				let e;
				(e = 0 === t ? this._lowerLayer.children : this._upperLayer.children),
					e[0].move(0, 0, o, h),
					e[0].setFrame(n, a, o, h),
					e[1].move(o, 0, u, h),
					e[1].setFrame(0, a, u, h),
					e[2].move(0, h, o, l),
					e[2].setFrame(n, 0, o, l),
					e[3].move(o, h, u, l),
					e[3].setFrame(0, 0, u, l);
			}
		}
		_paintAllTiles(t, e) {
			const i = Math.ceil(this._width / this._tileWidth) + 1,
				r = Math.ceil(this._height / this._tileHeight) + 1;
			for (let s = 0; s < r; s++)
				for (let r = 0; r < i; r++) this._paintTiles(t, e, r, s);
		}
		_paintTiles(t, e, i, r) {
			const s = t + i,
				n = e + r,
				a = (s * this._tileWidth).mod(this._layerWidth),
				o = (n * this._tileHeight).mod(this._layerHeight),
				h = a / this._tileWidth,
				u = o / this._tileHeight,
				l = this._readMapData(s, n, 0),
				c = this._readMapData(s, n, 1),
				d = this._readMapData(s, n, 2),
				p = this._readMapData(s, n, 3),
				f = this._readMapData(s, n, 4),
				m = this._readMapData(s, n - 1, 1),
				_ = [],
				g = [];
			this._isHigherTile(l) ? g.push(l) : _.push(l),
				this._isHigherTile(c) ? g.push(c) : _.push(c),
				_.push(-f),
				this._isTableTile(m) &&
					!this._isTableTile(c) &&
					(Tilemap.isShadowingTile(l) || _.push(1e4 + m)),
				this._isOverpassPosition(s, n)
					? (g.push(d), g.push(p))
					: (this._isHigherTile(d) ? g.push(d) : _.push(d),
					  this._isHigherTile(p) ? g.push(p) : _.push(p));
			const E = this._readLastTiles(0, h, u);
			if (!_.equals(E) || (Tilemap.isTileA1(l) && this._frameUpdated)) {
				this._lowerBitmap.clearRect(a, o, this._tileWidth, this._tileHeight);
				for (const t of _)
					t < 0
						? this._drawShadow(this._lowerBitmap, f, a, o)
						: t >= 1e4
						? this._drawTableEdge(this._lowerBitmap, m, a, o)
						: this._drawTile(this._lowerBitmap, t, a, o);
				this._writeLastTiles(0, h, u, _);
			}
			const y = this._readLastTiles(1, h, u);
			if (!g.equals(y)) {
				this._upperBitmap.clearRect(a, o, this._tileWidth, this._tileHeight);
				for (let t = 0; t < g.length; t++)
					this._drawTile(this._upperBitmap, g[t], a, o);
				this._writeLastTiles(1, h, u, g);
			}
		}
		_readLastTiles(t, e, i) {
			const r = this._lastTiles[t];
			if (r) {
				const t = r[i];
				if (t) {
					const i = t[e];
					if (i) return i;
				}
			}
			return [];
		}
		_writeLastTiles(t, e, i, r) {
			let s = this._lastTiles[t];
			s || (s = this._lastTiles[t] = []);
			let n = s[i];
			n || (n = s[i] = []), (n[e] = r);
		}
		_drawTile(t, e, i, r) {
			Tilemap.isVisibleTile(e) &&
				(Tilemap.isAutotile(e)
					? this._drawAutotile(t, e, i, r)
					: this._drawNormalTile(t, e, i, r));
		}
		_drawNormalTile(t, e, i, r) {
			let s = 0;
			s = Tilemap.isTileA5(e) ? 4 : 5 + Math.floor(e / 256);
			const n = this._tileWidth,
				a = this._tileHeight,
				o = ((Math.floor(e / 128) % 2) * 8 + (e % 8)) * n,
				h = (Math.floor((e % 256) / 8) % 16) * a,
				u = this.bitmaps[s];
			u && t.bltImage(u, o, h, n, a, i, r, n, a);
		}
		_drawAutotile(t, e, i, r) {
			let s = Tilemap.FLOOR_AUTOTILE_TABLE;
			const n = Tilemap.getAutotileKind(e),
				a = Tilemap.getAutotileShape(e),
				o = n % 8,
				h = Math.floor(n / 8);
			let u = 0,
				l = 0,
				c = 0,
				d = !1;
			if (Tilemap.isTileA1(e)) {
				const t = [0, 1, 2, 1][this.animationFrame % 4];
				(c = 0),
					0 === n
						? ((u = 2 * t), (l = 0))
						: 1 === n
						? ((u = 2 * t), (l = 3))
						: 2 === n
						? ((u = 6), (l = 0))
						: 3 === n
						? ((u = 6), (l = 3))
						: ((u = 8 * Math.floor(o / 4)),
						  (l = 6 * h + (Math.floor(o / 2) % 2) * 3),
						  n % 2 == 0
								? (u += 2 * t)
								: ((u += 6),
								  (s = Tilemap.WATERFALL_AUTOTILE_TABLE),
								  (l += this.animationFrame % 3)));
			} else
				Tilemap.isTileA2(e)
					? ((c = 1),
					  (u = 2 * o),
					  (l = 3 * (h - 2)),
					  (d = this._isTableTile(e)))
					: Tilemap.isTileA3(e)
					? ((c = 2),
					  (u = 2 * o),
					  (l = 2 * (h - 6)),
					  (s = Tilemap.WALL_AUTOTILE_TABLE))
					: Tilemap.isTileA4(e) &&
					  ((c = 3),
					  (u = 2 * o),
					  (l = Math.floor(2.5 * (h - 10) + (h % 2 == 1 ? 0.5 : 0))),
					  h % 2 == 1 && (s = Tilemap.WALL_AUTOTILE_TABLE));
			const p = s[a],
				f = this.bitmaps[c];
			if (p && f) {
				const e = this._tileWidth / 2,
					s = this._tileHeight / 2;
				for (let n = 0; n < 4; n++) {
					const a = p[n][0],
						o = p[n][1],
						h = (2 * u + a) * e,
						c = (2 * l + o) * s,
						m = i + (n % 2) * e;
					let _ = r + Math.floor(n / 2) * s;
					if (!d || (1 !== o && 5 !== o)) t.bltImage(f, h, c, e, s, m, _, e, s);
					else {
						let i = a;
						1 === o && (i = [0, 3, 2, 1][a]);
						const r = (2 * u + i) * e,
							n = (2 * l + 3) * s;
						t.bltImage(f, r, n, e, s, m, _, e, s),
							(_ += s / 2),
							t.bltImage(f, h, c, e, s / 2, m, _, e, s / 2);
					}
				}
			}
		}
		_drawTableEdge(t, e, i, r) {
			if (Tilemap.isTileA2(e)) {
				const s = Tilemap.FLOOR_AUTOTILE_TABLE,
					n = Tilemap.getAutotileKind(e),
					a = Tilemap.getAutotileShape(e),
					o = 1,
					h = (n % 8) * 2,
					u = 3 * (Math.floor(n / 8) - 2),
					l = s[a];
				if (l) {
					const e = this.bitmaps[o],
						s = this._tileWidth / 2,
						n = this._tileHeight / 2;
					for (let a = 0; a < 2; a++) {
						const o = (2 * h + l[2 + a][0]) * s,
							c = (2 * u + l[2 + a][1]) * n + n / 2,
							d = i + (a % 2) * s,
							p = r + Math.floor(a / 2) * n;
						t.bltImage(e, o, c, s, n / 2, d, p, s, n / 2);
					}
				}
			}
		}
		_drawShadow(t, e, i, r) {}
		_readMapData(t, e, i) {
			if (this._mapData) {
				const r = this._mapWidth,
					s = this._mapHeight;
				return (
					this.horizontalWrap && (t = t.mod(r)),
					this.verticalWrap && (e = e.mod(s)),
					(t >= 0 &&
						t < r &&
						e >= 0 &&
						e < s &&
						this._mapData[(i * s + e) * r + t]) ||
						0
				);
			}
			return 0;
		}
		_isHigherTile(t) {
			return 16 & this.flags[t];
		}
		_isTableTile(t) {
			return Tilemap.isTileA2(t) && 128 & this.flags[t];
		}
		_isOverpassPosition(t, e) {
			return !1;
		}
		_sortChildren() {
			this.children.sort(this._compareChildOrder.bind(this));
		}
		_compareChildOrder(t, e) {
			return t.z === e.z
				? t.y === e.y
					? t.spriteId - e.spriteId
					: t.y - e.y
				: t.z - e.z;
		}
		static isVisibleTile(t) {
			return t > 0 && t < this.TILE_ID_MAX;
		}
		static isAutotile(t) {
			return t >= this.TILE_ID_A1;
		}
		static getAutotileKind(t) {
			return Math.floor((t - this.TILE_ID_A1) / 48);
		}
		static getAutotileShape(t) {
			return (t - this.TILE_ID_A1) % 48;
		}
		static makeAutotileId(t, e) {
			return this.TILE_ID_A1 + 48 * t + e;
		}
		static isSameKindTile(t, e) {
			return this.isAutotile(t) && this.isAutotile(e)
				? this.getAutotileKind(t) === this.getAutotileKind(e)
				: t === e;
		}
		static isTileA1(t) {
			return t >= this.TILE_ID_A1 && t < this.TILE_ID_A2;
		}
		static isTileA2(t) {
			return t >= this.TILE_ID_A2 && t < this.TILE_ID_A3;
		}
		static isTileA3(t) {
			return t >= this.TILE_ID_A3 && t < this.TILE_ID_A4;
		}
		static isTileA4(t) {
			return t >= this.TILE_ID_A4 && t < this.TILE_ID_MAX;
		}
		static isTileA5(t) {
			return t >= this.TILE_ID_A5 && t < this.TILE_ID_A1;
		}
		static isWaterTile(t) {
			return !(
				!this.isTileA1(t) ||
				(t >= this.TILE_ID_A1 + 96 && t < this.TILE_ID_A1 + 192)
			);
		}
		static isWaterfallTile(t) {
			return (
				t >= this.TILE_ID_A1 + 192 &&
				t < this.TILE_ID_A2 &&
				this.getAutotileKind(t) % 2 == 1
			);
		}
		static isGroundTile(t) {
			return this.isTileA1(t) || this.isTileA2(t) || this.isTileA5(t);
		}
		static isShadowingTile(t) {
			return this.isTileA3(t) || this.isTileA4(t);
		}
		static isRoofTile(t) {
			return this.isTileA3(t) && this.getAutotileKind(t) % 16 < 8;
		}
		static isWallTopTile(t) {
			return this.isTileA4(t) && this.getAutotileKind(t) % 16 < 8;
		}
		static isWallSideTile(t) {
			return (
				(this.isTileA3(t) || this.isTileA4(t)) &&
				this.getAutotileKind(t) % 16 >= 8
			);
		}
		static isWallTile(t) {
			return this.isWallTopTile(t) || this.isWallSideTile(t);
		}
		static isFloorTypeAutotile(t) {
			return (
				(this.isTileA1(t) && !this.isWaterfallTile(t)) ||
				this.isTileA2(t) ||
				this.isWallTopTile(t)
			);
		}
		static isWallTypeAutotile(t) {
			return this.isRoofTile(t) || this.isWallSideTile(t);
		}
		static isWaterfallTypeAutotile(t) {
			return this.isWaterfallTile(t);
		}
	}
	(Tilemap.TILE_ID_B = 0),
		(Tilemap.TILE_ID_C = 256),
		(Tilemap.TILE_ID_D = 512),
		(Tilemap.TILE_ID_E = 768),
		(Tilemap.TILE_ID_A5 = 1536),
		(Tilemap.TILE_ID_A1 = 2048),
		(Tilemap.TILE_ID_A2 = 2816),
		(Tilemap.TILE_ID_A3 = 4352),
		(Tilemap.TILE_ID_A4 = 5888),
		(Tilemap.TILE_ID_MAX = 8192),
		(Tilemap.FLOOR_AUTOTILE_TABLE = [
			[
				[2, 4],
				[1, 4],
				[2, 3],
				[1, 3],
			],
			[
				[2, 0],
				[1, 4],
				[2, 3],
				[1, 3],
			],
			[
				[2, 4],
				[3, 0],
				[2, 3],
				[1, 3],
			],
			[
				[2, 0],
				[3, 0],
				[2, 3],
				[1, 3],
			],
			[
				[2, 4],
				[1, 4],
				[2, 3],
				[3, 1],
			],
			[
				[2, 0],
				[1, 4],
				[2, 3],
				[3, 1],
			],
			[
				[2, 4],
				[3, 0],
				[2, 3],
				[3, 1],
			],
			[
				[2, 0],
				[3, 0],
				[2, 3],
				[3, 1],
			],
			[
				[2, 4],
				[1, 4],
				[2, 1],
				[1, 3],
			],
			[
				[2, 0],
				[1, 4],
				[2, 1],
				[1, 3],
			],
			[
				[2, 4],
				[3, 0],
				[2, 1],
				[1, 3],
			],
			[
				[2, 0],
				[3, 0],
				[2, 1],
				[1, 3],
			],
			[
				[2, 4],
				[1, 4],
				[2, 1],
				[3, 1],
			],
			[
				[2, 0],
				[1, 4],
				[2, 1],
				[3, 1],
			],
			[
				[2, 4],
				[3, 0],
				[2, 1],
				[3, 1],
			],
			[
				[2, 0],
				[3, 0],
				[2, 1],
				[3, 1],
			],
			[
				[0, 4],
				[1, 4],
				[0, 3],
				[1, 3],
			],
			[
				[0, 4],
				[3, 0],
				[0, 3],
				[1, 3],
			],
			[
				[0, 4],
				[1, 4],
				[0, 3],
				[3, 1],
			],
			[
				[0, 4],
				[3, 0],
				[0, 3],
				[3, 1],
			],
			[
				[2, 2],
				[1, 2],
				[2, 3],
				[1, 3],
			],
			[
				[2, 2],
				[1, 2],
				[2, 3],
				[3, 1],
			],
			[
				[2, 2],
				[1, 2],
				[2, 1],
				[1, 3],
			],
			[
				[2, 2],
				[1, 2],
				[2, 1],
				[3, 1],
			],
			[
				[2, 4],
				[3, 4],
				[2, 3],
				[3, 3],
			],
			[
				[2, 4],
				[3, 4],
				[2, 1],
				[3, 3],
			],
			[
				[2, 0],
				[3, 4],
				[2, 3],
				[3, 3],
			],
			[
				[2, 0],
				[3, 4],
				[2, 1],
				[3, 3],
			],
			[
				[2, 4],
				[1, 4],
				[2, 5],
				[1, 5],
			],
			[
				[2, 0],
				[1, 4],
				[2, 5],
				[1, 5],
			],
			[
				[2, 4],
				[3, 0],
				[2, 5],
				[1, 5],
			],
			[
				[2, 0],
				[3, 0],
				[2, 5],
				[1, 5],
			],
			[
				[0, 4],
				[3, 4],
				[0, 3],
				[3, 3],
			],
			[
				[2, 2],
				[1, 2],
				[2, 5],
				[1, 5],
			],
			[
				[0, 2],
				[1, 2],
				[0, 3],
				[1, 3],
			],
			[
				[0, 2],
				[1, 2],
				[0, 3],
				[3, 1],
			],
			[
				[2, 2],
				[3, 2],
				[2, 3],
				[3, 3],
			],
			[
				[2, 2],
				[3, 2],
				[2, 1],
				[3, 3],
			],
			[
				[2, 4],
				[3, 4],
				[2, 5],
				[3, 5],
			],
			[
				[2, 0],
				[3, 4],
				[2, 5],
				[3, 5],
			],
			[
				[0, 4],
				[1, 4],
				[0, 5],
				[1, 5],
			],
			[
				[0, 4],
				[3, 0],
				[0, 5],
				[1, 5],
			],
			[
				[0, 2],
				[3, 2],
				[0, 3],
				[3, 3],
			],
			[
				[0, 2],
				[1, 2],
				[0, 5],
				[1, 5],
			],
			[
				[0, 4],
				[3, 4],
				[0, 5],
				[3, 5],
			],
			[
				[2, 2],
				[3, 2],
				[2, 5],
				[3, 5],
			],
			[
				[0, 2],
				[3, 2],
				[0, 5],
				[3, 5],
			],
			[
				[0, 0],
				[1, 0],
				[0, 1],
				[1, 1],
			],
		]),
		(Tilemap.WALL_AUTOTILE_TABLE = [
			[
				[2, 2],
				[1, 2],
				[2, 1],
				[1, 1],
			],
			[
				[0, 2],
				[1, 2],
				[0, 1],
				[1, 1],
			],
			[
				[2, 0],
				[1, 0],
				[2, 1],
				[1, 1],
			],
			[
				[0, 0],
				[1, 0],
				[0, 1],
				[1, 1],
			],
			[
				[2, 2],
				[3, 2],
				[2, 1],
				[3, 1],
			],
			[
				[0, 2],
				[3, 2],
				[0, 1],
				[3, 1],
			],
			[
				[2, 0],
				[3, 0],
				[2, 1],
				[3, 1],
			],
			[
				[0, 0],
				[3, 0],
				[0, 1],
				[3, 1],
			],
			[
				[2, 2],
				[1, 2],
				[2, 3],
				[1, 3],
			],
			[
				[0, 2],
				[1, 2],
				[0, 3],
				[1, 3],
			],
			[
				[2, 0],
				[1, 0],
				[2, 3],
				[1, 3],
			],
			[
				[0, 0],
				[1, 0],
				[0, 3],
				[1, 3],
			],
			[
				[2, 2],
				[3, 2],
				[2, 3],
				[3, 3],
			],
			[
				[0, 2],
				[3, 2],
				[0, 3],
				[3, 3],
			],
			[
				[2, 0],
				[3, 0],
				[2, 3],
				[3, 3],
			],
			[
				[0, 0],
				[3, 0],
				[0, 3],
				[3, 3],
			],
		]),
		(Tilemap.WATERFALL_AUTOTILE_TABLE = [
			[
				[2, 0],
				[1, 0],
				[2, 1],
				[1, 1],
			],
			[
				[0, 0],
				[1, 0],
				[0, 1],
				[1, 1],
			],
			[
				[2, 0],
				[3, 0],
				[2, 1],
				[3, 1],
			],
			[
				[0, 0],
				[3, 0],
				[0, 1],
				[3, 1],
			],
		]);
	class ZLayer extends Container$2 {
		constructor(t, e) {
			super(),
				ZLayer.prototype.__init.call(this),
				(this.tilemap = t),
				(this.z = e);
		}
		__init() {
			this._lastAnimationFrame = -1;
		}
		clear() {
			let t = this.children;
			for (let e = 0; e < t.length; e++) t[e].clear();
			this._previousLayers = 0;
		}
		cacheIfDirty(t) {
			let e = this.tilemap,
				i = this.children,
				r = this._previousLayers !== i.length;
			this._previousLayers = i.length;
			let s,
				n = this.canvasBuffer,
				a = this._tempRender;
			if (
				(n ||
					((n = this.canvasBuffer = document.createElement('canvas')),
					t.constructor.registerPlugin('tilemap', CanvasTileRenderer),
					(a = this._tempRender =
						new t.constructor({ width: 100, height: 100, view: n })),
					(a.context = a.rootContext),
					(a.plugins.tilemap.dontUseTransform = !0)),
				(n.width === e._layerWidth && n.height === e._layerHeight) ||
					((n.width = e._layerWidth), (n.height = e._layerHeight), (r = !0)),
				!r)
			)
				for (s = 0; s < i.length; s++)
					if (i[s].isModified(this._lastAnimationFrame !== e.animationFrame)) {
						r = !0;
						break;
					}
			if (((this._lastAnimationFrame = e.animationFrame), r))
				for (
					e._hackRenderer && e._hackRenderer(a),
						a.context.clearRect(0, 0, n.width, n.height),
						s = 0;
					s < i.length;
					s++
				)
					i[s].clearModify(), i[s].renderCanvas(a);
			for (
				this.layerTransform = this.worldTransform, s = 0;
				s < i.length;
				s++
			) {
				this.layerTransform = i[s].worldTransform;
				break;
			}
		}
		renderCanvas(t) {
			this.cacheIfDirty(t);
			let e = this.layerTransform;
			t.context.setTransform(
				e.a,
				e.b,
				e.c,
				e.d,
				e.tx * t.resolution,
				e.ty * t.resolution
			),
				t.context.drawImage(this.canvasBuffer, 0, 0);
		}
	}
	(settings$1.SCALE_MODE = SCALE_MODES$9.NEAREST),
		(settings$1.TEXTILE_UNITS = 4),
		(settings$1.TEXTURES_PER_TILEMAP = 9);
	class ShaderTilemap extends Tilemap {
		constructor(...t) {
			super(...t), (this.roundPixels = !0);
		}
		_hackRenderer(t) {
			let e = this.animationFrame % 4;
			return (
				3 == e && (e = 1),
				(t.plugins.tilemap.tileAnim[0] = e * this._tileWidth),
				(t.plugins.tilemap.tileAnim[1] =
					(this.animationFrame % 3) * this._tileHeight),
				t
			);
		}
		renderCanvas(t) {
			this._hackRenderer(t), Container$2.prototype.renderCanvas.call(this, t);
		}
		render(t) {
			this._hackRenderer(t), Container$2.prototype.render.call(this, t);
		}
		refresh() {
			this._lastBitmapLength !== this.bitmaps.length &&
				((this._lastBitmapLength = this.bitmaps.length), this.refreshTileset()),
				(this._needsRepaint = !0);
		}
		refreshTileset() {
			const t = this.bitmaps.map((t) =>
				t._baseTexture ? new Texture$3(t._baseTexture) : t
			);
			this.lowerLayer.setBitmaps(t), this.upperLayer.setBitmaps(t);
		}
		updateTransform() {
			const t = Math.floor(this.origin.x),
				e = Math.floor(this.origin.y),
				i = Math.floor((t - this._margin) / this._tileWidth),
				r = Math.floor((e - this._margin) / this._tileHeight);
			this._updateLayerPositions(i, r),
				(this._needsRepaint ||
					this._lastStartX !== i ||
					this._lastStartY !== r) &&
					((this._lastStartX = i),
					(this._lastStartY = r),
					this._paintAllTiles(i, r),
					(this._needsRepaint = !1)),
				this._sortChildren(),
				Container$2.prototype.updateTransform.call(this);
		}
		_createLayers() {
			(this._needsRepaint = !0),
				this.lowerZLayer ||
					(this.addChild((this.lowerZLayer = new ZLayer(this, 0))),
					this.addChild((this.upperZLayer = new ZLayer(this, 4))),
					this.lowerZLayer.addChild(
						(this.lowerLayer = new CompositeTilemap(0, []))
					),
					(this.lowerLayer.shadowColor = new Float32Array([0, 0, 0, 0.5])),
					this.upperZLayer.addChild(
						(this.upperLayer = new CompositeTilemap(4, []))
					));
		}
		_updateLayerPositions(t, e) {
			const i = Math.floor(this.origin.x),
				r = Math.floor(this.origin.y);
			(this.lowerZLayer.position.x = t * this._tileWidth - i),
				(this.lowerZLayer.position.y = e * this._tileHeight - r),
				(this.upperZLayer.position.x = t * this._tileWidth - i),
				(this.upperZLayer.position.y = e * this._tileHeight - r);
		}
		_paintAllTiles(t, e) {
			this.lowerZLayer.clear(), this.upperZLayer.clear();
			const i = Math.ceil(this._width / this._tileWidth) + 1,
				r = Math.ceil(this._height / this._tileHeight) + 1;
			for (let s = 0; s < r; s++)
				for (let r = 0; r < i; r++) this._paintTiles(t, e, r, s);
		}
		_paintTiles(t, e, i, r) {
			const s = t + i,
				n = e + r,
				a = i * this._tileWidth,
				o = r * this._tileHeight,
				h = this._readMapData(s, n, 0),
				u = this._readMapData(s, n, 1),
				l = this._readMapData(s, n, 2),
				c = this._readMapData(s, n, 3),
				d = this._readMapData(s, n, 4),
				p = this._readMapData(s, n - 1, 1),
				f = this.lowerLayer.children[0],
				m = this.upperLayer.children[0];
			this._isHigherTile(h)
				? this._drawTile(m, h, a, o)
				: this._drawTile(f, h, a, o),
				this._isHigherTile(u)
					? this._drawTile(m, u, a, o)
					: this._drawTile(f, u, a, o),
				this._drawShadow(f, d, a, o),
				this._isTableTile(p) &&
					!this._isTableTile(u) &&
					(Tilemap.isShadowingTile(h) || this._drawTableEdge(f, p, a, o)),
				this._isOverpassPosition(s, n)
					? (this._drawTile(m, l, a, o), this._drawTile(m, c, a, o))
					: (this._isHigherTile(l)
							? this._drawTile(m, l, a, o)
							: this._drawTile(f, l, a, o),
					  this._isHigherTile(c)
							? this._drawTile(m, c, a, o)
							: this._drawTile(f, c, a, o));
		}
		_drawTile(t, e, i, r) {
			Tilemap.isVisibleTile(e) &&
				(Tilemap.isAutotile(e)
					? this._drawAutotile(t, e, i, r)
					: this._drawNormalTile(t, e, i, r));
		}
		_drawNormalTile(t, e, i, r) {
			let s = 0;
			s = Tilemap.isTileA5(e) ? 4 : 5 + Math.floor(e / 256);
			const n = this._tileWidth,
				a = this._tileHeight,
				o = ((Math.floor(e / 128) % 2) * 8 + (e % 8)) * n,
				h = (Math.floor((e % 256) / 8) % 16) * a;
			t.addRect(s, o, h, i, r, n, a);
		}
		_drawAutotile(t, e, i, r) {
			let s = Tilemap.FLOOR_AUTOTILE_TABLE;
			const n = Tilemap.getAutotileKind(e),
				a = Tilemap.getAutotileShape(e),
				o = n % 8,
				h = Math.floor(n / 8);
			let u = 0,
				l = 0,
				c = 0,
				d = !1,
				p = 0,
				f = 0;
			Tilemap.isTileA1(e)
				? ((c = 0),
				  0 === n
						? ((p = 2), (l = 0))
						: 1 === n
						? ((p = 2), (l = 3))
						: 2 === n
						? ((u = 6), (l = 0))
						: 3 === n
						? ((u = 6), (l = 3))
						: ((u = 8 * Math.floor(o / 4)),
						  (l = 6 * h + (Math.floor(o / 2) % 2) * 3),
						  n % 2 == 0
								? (p = 2)
								: ((u += 6), (s = Tilemap.WATERFALL_AUTOTILE_TABLE), (f = 1))))
				: Tilemap.isTileA2(e)
				? ((c = 1), (u = 2 * o), (l = 3 * (h - 2)), (d = this._isTableTile(e)))
				: Tilemap.isTileA3(e)
				? ((c = 2),
				  (u = 2 * o),
				  (l = 2 * (h - 6)),
				  (s = Tilemap.WALL_AUTOTILE_TABLE))
				: Tilemap.isTileA4(e) &&
				  ((c = 3),
				  (u = 2 * o),
				  (l = Math.floor(2.5 * (h - 10) + (h % 2 == 1 ? 0.5 : 0))),
				  h % 2 == 1 && (s = Tilemap.WALL_AUTOTILE_TABLE));
			const m = s[a],
				_ = this._tileWidth / 2,
				g = this._tileHeight / 2;
			for (let e = 0; e < 4; e++) {
				const s = m[e][0],
					n = m[e][1],
					a = (2 * u + s) * _,
					o = (2 * l + n) * g,
					h = i + (e % 2) * _,
					E = r + Math.floor(e / 2) * g;
				if (!d || (1 !== n && 5 !== n)) t.addRect(c, a, o, h, E, _, g, p, f);
				else {
					let e = s;
					1 === n && (e = (4 - s) % 4);
					const i = (2 * u + e) * _,
						r = (2 * l + 3) * g;
					t.addRect(c, i, r, h, E, _, g, p, f),
						t.addRect(c, a, o, h, E + g / 2, _, g / 2, p, f);
				}
			}
		}
		_drawTableEdge(t, e, i, r) {
			if (Tilemap.isTileA2(e)) {
				const s = Tilemap.FLOOR_AUTOTILE_TABLE,
					n = Tilemap.getAutotileKind(e),
					a = Tilemap.getAutotileShape(e),
					o = 1,
					h = (n % 8) * 2,
					u = 3 * (Math.floor(n / 8) - 2),
					l = s[a],
					c = this._tileWidth / 2,
					d = this._tileHeight / 2;
				for (let e = 0; e < 2; e++) {
					const s = (2 * h + l[2 + e][0]) * c,
						n = (2 * u + l[2 + e][1]) * d + d / 2,
						a = i + (e % 2) * c,
						p = r + Math.floor(e / 2) * d;
					t.addRect(o, s, n, a, p, c, d / 2);
				}
			}
		}
		_drawShadow(t, e, i, r) {}
	}
	class TilingSprite extends TilingSprite$1 {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t) {
			const e = new Texture$3(new BaseTexture$3());
			TilingSprite$1.call(this, e),
				(this._bitmap = null),
				(this._width = 0),
				(this._height = 0),
				(this._frame = new Rectangle()),
				(this.spriteId = Sprite._counter++),
				(this.origin = new Point()),
				(this.bitmap = t);
		}
		_renderCanvas(t) {
			this._bitmap && this._bitmap.touch(),
				this.texture.frame.width > 0 &&
					this.texture.frame.height > 0 &&
					this._renderCanvas_PIXI(t);
		}
		get bitmap() {
			return this._bitmap;
		}
		set bitmap(t) {
			this._bitmap !== t &&
				((this._bitmap = t),
				this._bitmap
					? this._bitmap.addLoadListener(this._onBitmapLoad.bind(this))
					: (this.texture.frame = Rectangle.emptyRectangle));
		}
		get opacity() {
			return 255 * this.alpha;
		}
		set opacity(t) {
			this.alpha = t.clamp(0, 255) / 255;
		}
		update() {
			this.children.forEach((t) => {
				t.update && t.update();
			});
		}
		move(t, e, i, r) {
			(this.x = t || 0),
				(this.y = e || 0),
				(this._width = i || 0),
				(this._height = r || 0);
		}
		setFrame(t, e, i, r) {
			(this._frame.x = t),
				(this._frame.y = e),
				(this._frame.width = i),
				(this._frame.height = r),
				this._refresh();
		}
		updateTransform() {
			(this.tilePosition.x = Math.round(-this.origin.x)),
				(this.tilePosition.y = Math.round(-this.origin.y)),
				this.updateTransformTS();
		}
		_onBitmapLoad() {
			(this.texture.baseTexture = this._bitmap.baseTexture), this._refresh();
		}
		_refresh() {
			const t = this._frame.clone();
			0 === t.width &&
				0 === t.height &&
				this._bitmap &&
				((t.width = this._bitmap.width), (t.height = this._bitmap.height)),
				(this.texture.frame = t),
				this.texture._updateID++,
				(this.tilingTexture = null);
		}
		_render(t) {
			this._bitmap && (this._bitmap.touch(), this._bitmap.checkDirty()),
				this._render_PIXI(t);
		}
	}
	(TilingSprite.prototype._renderCanvas_PIXI =
		TilingSprite$1.prototype._renderCanvas),
		(TilingSprite.prototype._render_PIXI = TilingSprite$1.prototype._render),
		(TilingSprite.prototype.updateTransformTS =
			TilingSprite$1.prototype.updateTransform);
	class ScreenSprite extends Container$2 {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			Container$2.call(this),
				(this._graphics = new Graphics$1()),
				this.addChild(this._graphics),
				(this.opacity = 0),
				(this._red = -1),
				(this._green = -1),
				(this._blue = -1),
				(this._colorText = ''),
				this.setBlack();
		}
		get opacity() {
			return 255 * this.alpha;
		}
		set opacity(t) {
			this.alpha = t.clamp(0, 255) / 255;
		}
		get anchor() {
			return (
				ScreenSprite.warnYep(),
				(this.scale.x = 1),
				(this.scale.y = 1),
				{ x: 0, y: 0 }
			);
		}
		set anchor(t) {
			this.alpha = t.clamp(0, 255) / 255;
		}
		get blendMode() {
			return this._graphics.blendMode;
		}
		set blendMode(t) {
			this._graphics.blendMode = t;
		}
		setBlack() {
			this.setColor(0, 0, 0);
		}
		setWhite() {
			this.setColor(255, 255, 255);
		}
		setColor(t, e, i) {
			if (this._red !== t || this._green !== e || this._blue !== i) {
				(t = Math.round(t || 0).clamp(0, 255)),
					(e = Math.round(e || 0).clamp(0, 255)),
					(i = Math.round(i || 0).clamp(0, 255)),
					(this._red = t),
					(this._green = e),
					(this._blue = i),
					(this._colorText = Utils.rgbToCssColor(t, e, i));
				const r = this._graphics;
				r.clear();
				const s = (t << 16) | (e << 8) | i;
				r.beginFill(s, 1),
					r.drawRect(
						5 * -Graphics.width,
						5 * -Graphics.height,
						10 * Graphics.width,
						10 * Graphics.height
					);
			}
		}
	}
	class WindowSkinCache {
		constructor() {
			throw new Error('This is a static class');
		}
		static setItem(t, e, i) {
			WindowSkinCache._cache[t] || (WindowSkinCache._cache[t] = {}),
				(WindowSkinCache._cache[t][i] = e);
		}
		static getItem(t, e) {
			return (
				!!WindowSkinCache._cache[t] &&
				!!WindowSkinCache._cache[t][e] &&
				WindowSkinCache._cache[t][e]
			);
		}
	}
	WindowSkinCache._cache = {};
	class Window extends Container$2 {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			Container$2.call(this),
				(this._isWindow = !0),
				(this._windowskin = null),
				(this._width = 0),
				(this._height = 0),
				(this._cursorRect = new Rectangle()),
				(this._openness = 255),
				(this._animationCount = 0),
				(this._padding = 18),
				(this._margin = 4),
				(this._colorTone = [0, 0, 0]),
				(this._windowSpriteContainer = null),
				(this._windowBackSprite = null),
				(this._windowCursorSprite = null),
				(this._windowFrameSprite = null),
				(this._windowContentsSprite = null),
				(this._windowArrowSprites = []),
				(this._windowPauseSignSprite = null),
				this._createAllParts(),
				(this.origin = new Point()),
				(this.active = !0),
				(this.downArrowVisible = !1),
				(this.upArrowVisible = !1),
				(this.pause = !1);
		}
		get windowskin() {
			return this._windowskin;
		}
		set windowskin(t) {
			this._windowskin !== t &&
				((this._windowskin = t),
				this._windowskin.addLoadListener(this._onWindowskinLoad.bind(this)));
		}
		get contents() {
			return this._windowContentsSprite.children[0];
		}
		set contents(t) {
			const e = this._windowContentsSprite.children[0];
			e && this._windowContentsSprite.removeChild(e),
				this._windowContentsSprite.addChild(t);
		}
		get width() {
			return this._width;
		}
		set width(t) {
			(this._width = t), this._refreshAllParts();
		}
		get height() {
			return this._height;
		}
		set height(t) {
			(this._height = t), this._refreshAllParts();
		}
		get padding() {
			return this._padding;
		}
		set padding(t) {
			(this._padding = t), this._refreshAllParts();
		}
		get margin() {
			return this._margin;
		}
		set margin(t) {
			(this._margin = t), this._refreshAllParts();
		}
		get opacity() {
			return 255 * this._windowSpriteContainer.alpha;
		}
		set opacity(t) {
			this._windowSpriteContainer.alpha = t.clamp(0, 255) / 255;
		}
		get backOpacity() {
			return 255 * this._windowBackSprite.alpha;
		}
		set backOpacity(t) {
			this._windowBackSprite.alpha = t.clamp(0, 255) / 255;
		}
		get contentsOpacity() {
			return 255 * this._windowContentsSprite.alpha;
		}
		set contentsOpacity(t) {
			this._windowContentsSprite.alpha = t.clamp(0, 255) / 255;
		}
		get openness() {
			return this._openness;
		}
		set openness(t) {
			this._openness !== t &&
				((this._openness = t.clamp(0, 255)),
				(this._windowSpriteContainer.scale.y = this._openness / 255),
				(this._windowSpriteContainer.y =
					(this.height / 2) * (1 - this._openness / 255)));
		}
		update() {
			this.active && this._animationCount++,
				this.children.forEach((t) => {
					t.update && t.update();
				});
		}
		move(t, e, i, r) {
			(this.x = Math.floor(t || 0)),
				(this.y = Math.floor(e || 0)),
				(this._width === i && this._height === r) ||
					((this._width = Math.floor(i || 0)),
					(this._height = Math.floor(r || 0)),
					this._refreshAllParts());
		}
		isOpen() {
			return this._openness >= 255;
		}
		isClosed() {
			return this._openness <= 0;
		}
		setCursorRect(t, e, i, r) {
			const s = Math.floor(t || 0),
				n = Math.floor(e || 0),
				a = Math.floor(i || 0),
				o = Math.floor(r || 0),
				h = this._cursorRect;
			(h.x === s && h.y === n && h.width === a && h.height === o) ||
				((this._cursorRect.x = s),
				(this._cursorRect.y = n),
				(this._cursorRect.width = a),
				(this._cursorRect.height = o),
				this._refreshCursor());
		}
		setTone(t, e, i) {
			const r = this._colorTone;
			(t /= 255) < 0 && (t = 0),
				(e /= 255) < 0 && (e = 0),
				(i /= 255) < 0 && (i = 0),
				(t === r[0] && e === r[1] && i === r[2]) ||
					((this._colorTone = [t, e, i]), this._refreshBack());
		}
		addChildToBack(t) {
			const e = this.children.indexOf(this._windowSpriteContainer);
			return this.addChildAt(t, e + 1);
		}
		updateTransform() {
			this._updateCursor(),
				this._updateArrows(),
				this._updatePauseSign(),
				this._updateContents(),
				super.updateTransform();
		}
		_createAllParts() {
			(this._windowSpriteContainer = new Container$2()),
				(this._windowBackSprite = new BitmapPIXI()),
				(this._windowCursorSprite = new BitmapPIXI()),
				(this._windowFrameSprite = new Container$2()),
				(this._windowContentsSprite = new Sprite()),
				(this._downArrowSprite = new Sprite()),
				(this._upArrowSprite = new Sprite()),
				(this._windowPauseSignSprite = new Sprite()),
				(this._windowBackSprite.alpha = 192 / 255),
				this.addChild(this._windowSpriteContainer),
				this._windowSpriteContainer.addChild(this._windowBackSprite),
				this._windowSpriteContainer.addChild(this._windowFrameSprite),
				this.addChild(this._windowCursorSprite),
				this.addChild(this._windowContentsSprite),
				this.addChild(this._downArrowSprite),
				this.addChild(this._upArrowSprite),
				this.addChild(this._windowPauseSignSprite);
		}
		_onWindowskinLoad() {
			this._refreshAllParts();
		}
		_refreshAllParts() {
			this._refreshBack(),
				this._refreshFrame(),
				this._refreshCursor(),
				this._refreshContents(),
				this._refreshArrows(),
				this._refreshPauseSign();
		}
		_refreshBack() {
			const t = this._margin,
				e = this._width - 2 * t,
				i = this._height - 2 * t,
				r = rgb2hex(this._colorTone);
			if (
				e > 0 &&
				i > 0 &&
				this._windowskin &&
				!this._windowBackSprite._setupComplete
			) {
				const t = 96;
				this._windowBackSprite.blt(this._windowskin, 0, 0, t, t, 0, 0, e, i),
					this._windowBackSprite.addChild(
						this._windowBackSprite.createTilingSprite(
							this._windowskin.baseTexture,
							0,
							t,
							t,
							t,
							e,
							i
						)
					),
					(this._windowBackSprite._setupComplete = !0);
			}
			(this._windowBackSprite.width = e),
				(this._windowBackSprite.height = i),
				(this._windowBackSprite.x = t),
				(this._windowBackSprite.y = t),
				this._windowBackSprite.children.forEach((t) => {
					t && ((t.width = e), (t.height = i), (t.tint = r));
				});
		}
		_refreshFrame() {
			const t = this._width,
				e = this._height,
				i = 24;
			if (
				t > 0 &&
				e > 0 &&
				this._windowskin &&
				!this._windowFrameSprite._setupComplete
			) {
				let r;
				const s = WindowSkinCache.getItem(this._windowskin._url, 'frame');
				if (s) r = s;
				else {
					const s = new BitmapPIXI(),
						n = this._windowskin,
						a = 96,
						o = 96;
					s.blt(n, a + i, 0, a - 48, i, i, 0, t - 48, i),
						s.blt(n, a + i, 0 + o - i, a - 48, i, i, e - i, t - 48, i),
						s.blt(n, a + 0, 24, i, a - 48, 0, i, i, e - 48),
						s.blt(n, a + o - i, 24, i, a - 48, t - i, i, i, e - 48),
						s.blt(n, a + 0, 0, i, i, 0, 0, i, i),
						s.blt(n, a + o - i, 0, i, i, t - i, 0, i, i),
						s.blt(n, a + 0, 0 + o - i, i, i, 0, e - i, i, i),
						s.blt(n, a + o - i, 0 + o - i, i, i, t - i, e - i, i, i),
						(r = Graphics._renderer.generateTexture(s)),
						s.destroy({ children: !0, texture: !0 }),
						WindowSkinCache.setItem(this._windowskin._url, r, 'frame');
				}
				(this._windowFramePlane = new NineSlicePlane(r, 12, 12, 12, 12)),
					this._windowFrameSprite.addChild(this._windowFramePlane),
					(this._windowFrameSprite._setupComplete = !0);
			}
			this._windowFrameSprite._setupComplete &&
				((this._windowFramePlane.width = t),
				(this._windowFramePlane.height = e));
		}
		_refreshCursor() {
			const t = this._padding,
				e = this._cursorRect.x + t - this.origin.x,
				i = this._cursorRect.y + t - this.origin.y,
				r = this._cursorRect.width,
				s = this._cursorRect.height;
			if (
				r > 0 &&
				s > 0 &&
				this._windowskin &&
				!this._windowCursorSprite._setupComplete
			) {
				const t = 96,
					e = 48;
				(this._windowCursorPlane = this._windowCursorSprite.create9Slice(
					this._windowskin.baseTexture,
					t,
					t,
					e,
					e,
					12,
					12,
					12,
					12
				)),
					this._windowCursorSprite.addChild(this._windowCursorPlane),
					(this._windowCursorSprite._setupComplete = !0);
			}
			this._windowCursorPlane &&
				((this._windowCursorPlane.x = e),
				(this._windowCursorPlane.y = i),
				(this._windowCursorPlane.width = r),
				(this._windowCursorPlane.height = s));
		}
		_refreshContents() {
			this._windowContentsSprite.move(this.padding, this.padding),
				this._windowContentsSprite.children.length &&
					this._windowContentsSprite.children[0].clear();
		}
		_refreshArrows() {
			const t = this._width,
				e = this._height;
			(this._downArrowSprite.bitmap = this._windowskin),
				(this._downArrowSprite.anchor.x = 0.5),
				(this._downArrowSprite.anchor.y = 0.5),
				this._downArrowSprite.setFrame(132, 60, 24, 12),
				this._downArrowSprite.move(t / 2, e - 12),
				(this._upArrowSprite.bitmap = this._windowskin),
				(this._upArrowSprite.anchor.x = 0.5),
				(this._upArrowSprite.anchor.y = 0.5),
				this._upArrowSprite.setFrame(132, 24, 24, 12),
				this._upArrowSprite.move(t / 2, 12);
		}
		_refreshPauseSign() {
			(this._windowPauseSignSprite.bitmap = this._windowskin),
				(this._windowPauseSignSprite.anchor.x = 0.5),
				(this._windowPauseSignSprite.anchor.y = 1),
				this._windowPauseSignSprite.move(this._width / 2, this._height),
				this._windowPauseSignSprite.setFrame(144, 96, 24, 24),
				(this._windowPauseSignSprite.alpha = 0);
		}
		_updateCursor() {
			const t = this._animationCount % 40;
			let e = this.contentsOpacity;
			this.active && (e -= t < 20 ? 8 * t : 8 * (40 - t)),
				(this._windowCursorSprite.alpha = e / 255),
				(this._windowCursorSprite.visible = this.isOpen());
		}
		_updateContents() {
			const t = this._width - 2 * this._padding,
				e = this._height - 2 * this._padding;
			t > 0 && e > 0
				? (this._windowContentsSprite.setFrame(
						this.origin.x,
						this.origin.y,
						t,
						e
				  ),
				  (this._windowContentsSprite.visible = this.isOpen()))
				: (this._windowContentsSprite.visible = !1);
		}
		_updateArrows() {
			(this._downArrowSprite.visible = this.isOpen() && this.downArrowVisible),
				(this._upArrowSprite.visible = this.isOpen() && this.upArrowVisible);
		}
		_updatePauseSign() {
			const t = this._windowPauseSignSprite,
				e = Math.floor(this._animationCount / 16) % 2,
				i = Math.floor(this._animationCount / 16 / 2) % 2;
			this.pause
				? t.alpha < 1 && (t.alpha = Math.min(t.alpha + 0.1, 1))
				: (t.alpha = 0),
				t.setFrame(144 + 24 * e, 96 + 24 * i, 24, 24),
				(t.visible = this.isOpen());
		}
	}
	class WindowLayer extends Container$2 {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			Container$2.call(this),
				(this._width = 0),
				(this._height = 0),
				this.on('removed', this.onRemoveAsAChild);
		}
		onRemoveAsAChild() {
			this.removeChildren();
		}
		get width() {
			return this._width;
		}
		set width(t) {
			this._width = t;
		}
		get height() {
			return this._height;
		}
		set height(t) {
			this._height = t;
		}
		move(t, e, i, r) {
			(this.x = t), (this.y = e), (this.width = i), (this.height = r);
		}
		update() {
			this.children.forEach((t) => {
				t.update && t.update();
			});
		}
	}
	(WindowLayer.voidFilter = new filters.AlphaFilter()),
		(WindowLayer.prototype.render = Container$2.prototype.render),
		(WindowLayer.prototype.renderCanvas = Container$2.prototype.renderCanvas);
	class Weather extends Container$2 {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			Container$2.call(this),
				(this._width = Graphics.width),
				(this._height = Graphics.height),
				(this._sprites = []),
				this._createBitmaps(),
				this._createDimmer(),
				(this.type = 'none'),
				(this.power = 0),
				(this.origin = new Point());
		}
		update() {
			this._updateDimmer(), this._updateAllSprites();
		}
		_createBitmaps() {
			(this._rainBitmap = new Bitmap(1, 60)),
				this._rainBitmap.fillAll('white'),
				(this._stormBitmap = new Bitmap(2, 100)),
				this._stormBitmap.fillAll('white'),
				(this._snowBitmap = new Bitmap(9, 9)),
				this._snowBitmap.drawCircle(4, 4, 4, 'white');
		}
		_createDimmer() {
			(this._dimmerSprite = new ScreenSprite()),
				this._dimmerSprite.setColor(80, 80, 80),
				this.addChild(this._dimmerSprite);
		}
		_updateDimmer() {
			this._dimmerSprite.opacity = Math.floor(6 * this.power);
		}
		_updateAllSprites() {
			const t = Math.floor(10 * this.power);
			for (; this._sprites.length < t; ) this._addSprite();
			for (; this._sprites.length > t; ) this._removeSprite();
			this._sprites.forEach(function (t) {
				this._updateSprite(t),
					(t.x = t.ax - this.origin.x),
					(t.y = t.ay - this.origin.y);
			}, this);
		}
		_addSprite() {
			const t = new Sprite(this.viewport);
			(t.opacity = 0), this._sprites.push(t), this.addChild(t);
		}
		_removeSprite() {
			this.removeChild(this._sprites.pop());
		}
		_updateSprite(t) {
			switch (this.type) {
				case 'rain':
					this._updateRainSprite(t);
					break;
				case 'storm':
					this._updateStormSprite(t);
					break;
				case 'snow':
					this._updateSnowSprite(t);
			}
			t.opacity < 40 && this._rebornSprite(t);
		}
		_updateRainSprite(t) {
			(t.bitmap = this._rainBitmap),
				(t.rotation = Math.PI / 16),
				(t.ax -= 6 * Math.sin(t.rotation)),
				(t.ay += 6 * Math.cos(t.rotation)),
				(t.opacity -= 6);
		}
		_updateStormSprite(t) {
			(t.bitmap = this._stormBitmap),
				(t.rotation = Math.PI / 8),
				(t.ax -= 8 * Math.sin(t.rotation)),
				(t.ay += 8 * Math.cos(t.rotation)),
				(t.opacity -= 8);
		}
		_updateSnowSprite(t) {
			(t.bitmap = this._snowBitmap),
				(t.rotation = Math.PI / 16),
				(t.ax -= 3 * Math.sin(t.rotation)),
				(t.ay += 3 * Math.cos(t.rotation)),
				(t.opacity -= 3);
		}
		_rebornSprite(t) {
			(t.ax = Math.randomInt(Graphics.width + 100) - 100 + this.origin.x),
				(t.ay = Math.randomInt(Graphics.height + 200) - 200 + this.origin.y),
				(t.opacity = 160 + Math.randomInt(60));
		}
	}
	class ToneFilter extends filters.ColorMatrixFilter {
		constructor() {
			super();
		}
		adjustHue(t) {
			this.hue(t, !0);
		}
		adjustSaturation(t) {
			(t = (t || 0).clamp(-255, 255) / 255), this.saturate(t, !0);
		}
		adjustTone(t, e, i) {
			if (
				((t = (t || 0).clamp(-255, 255) / 255),
				(e = (e || 0).clamp(-255, 255) / 255),
				(i = (i || 0).clamp(-255, 255) / 255),
				0 !== t || 0 !== e || 0 !== i)
			) {
				const r = [1, 0, 0, t, 0, 0, 1, 0, e, 0, 0, 0, 1, i, 0, 0, 0, 0, 1, 0];
				this._loadMatrix(r, !0);
			}
		}
	}
	class ToneSprite extends Container$2 {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			Container$2.call(this), this.clear();
		}
		clear() {
			(this._red = 0), (this._green = 0), (this._blue = 0), (this._gray = 0);
		}
		setTone(t, e, i, r) {
			(this._red = Math.round(t || 0).clamp(-255, 255)),
				(this._green = Math.round(e || 0).clamp(-255, 255)),
				(this._blue = Math.round(i || 0).clamp(-255, 255)),
				(this._gray = Math.round(r || 0).clamp(0, 255));
		}
		_renderCanvas(t) {
			if (this.visible) {
				const e = t.context,
					i = this.worldTransform,
					r = t.resolution,
					s = Graphics.width,
					n = Graphics.height;
				e.save(),
					e.setTransform(i.a, i.b, i.c, i.d, i.tx * r, i.ty * r),
					Graphics.canUseSaturationBlend() &&
						this._gray > 0 &&
						((e.globalCompositeOperation = 'saturation'),
						(e.globalAlpha = this._gray / 255),
						(e.fillStyle = '#ffffff'),
						e.fillRect(0, 0, s, n)),
					(e.globalAlpha = 1);
				const a = Math.max(0, this._red),
					o = Math.max(0, this._green),
					h = Math.max(0, this._blue);
				if (
					((a || o || h) &&
						((e.globalCompositeOperation = 'lighter'),
						(e.fillStyle = Utils.rgbToCssColor(a, o, h)),
						e.fillRect(0, 0, s, n)),
					Graphics.canUseDifferenceBlend())
				) {
					const t = Math.max(0, -this._red),
						i = Math.max(0, -this._green),
						r = Math.max(0, -this._blue);
					(t || i || r) &&
						((e.globalCompositeOperation = 'difference'),
						(e.fillStyle = '#ffffff'),
						e.fillRect(0, 0, s, n),
						(e.globalCompositeOperation = 'lighter'),
						(e.fillStyle = Utils.rgbToCssColor(t, i, r)),
						e.fillRect(0, 0, s, n),
						(e.globalCompositeOperation = 'difference'),
						(e.fillStyle = '#ffffff'),
						e.fillRect(0, 0, s, n));
				}
				e.restore();
			}
		}
		_render(t) {}
	}
	class Stage extends Container$2 {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			Container$2.call(this), (this.interactive = !1);
		}
	}
	class JsonEx {
		constructor() {
			throw new Error('This is a static class');
		}
		static stringify(t) {
			const e = [];
			JsonEx._id = 1;
			const i = JSON.stringify(this._encode(t, e, 0));
			return this._cleanMetadata(t), this._restoreCircularReference(e), i;
		}
		static parse(t) {
			const e = [],
				i = {},
				r = this._decode(JSON.parse(t), e, i);
			return this._cleanMetadata(r), this._linkCircularReference(r, e, i), r;
		}
		static makeDeepCopy(t) {
			return this.parse(this.stringify(t));
		}
		static _encode(t, e, i = 0) {
			if (++i >= this.maxDepth) throw new Error('Object too deep');
			const r = Object.prototype.toString.call(t);
			if ('[object Object]' === r || '[object Array]' === r) {
				t['@c'] = JsonEx._generateId();
				const r = this._getConstructorName(t);
				'Object' !== r && 'Array' !== r && (t['@'] = r);
				for (let r in t)
					(t.hasOwnProperty && !t.hasOwnProperty(r)) ||
						r.match(/^@./) ||
						(t[r] && 'object' == typeof t[r]
							? t[r]['@c']
								? (e.push([r, t, t[r]]), (t[r] = { '@r': t[r]['@c'] }))
								: ((t[r] = this._encode(t[r], e, i + 1)),
								  t[r] instanceof Array &&
										(e.push([r, t, t[r]]),
										(t[r] = { '@c': t[r]['@c'], '@a': t[r] })))
							: (t[r] = this._encode(t[r], e, i + 1)));
			}
			return i--, t;
		}
		static _decode(t, e, i) {
			const r = Object.prototype.toString.call(t);
			if ('[object Object]' === r || '[object Array]' === r) {
				if (((i[t['@c']] = t), null === t['@']))
					t = this._resetPrototype(t, null);
				else if (t['@']) {
					const e = window[t['@']];
					e && (t = this._resetPrototype(t, e.prototype));
				}
				for (let r in t)
					if (!t.hasOwnProperty || t.hasOwnProperty(r)) {
						if (t[r] && t[r]['@a']) {
							const e = t[r]['@a'];
							(e['@c'] = t[r]['@c']), (t[r] = e);
						}
						t[r] && t[r]['@r'] && e.push([r, t, t[r]['@r']]),
							(t[r] = this._decode(t[r], e, i));
					}
			}
			return t;
		}
		static _generateId() {
			return JsonEx._id++;
		}
		static _restoreCircularReference(t) {
			t.forEach((t) => {
				const e = t[0],
					i = t[1],
					r = t[2];
				i[e] = r;
			});
		}
		static _linkCircularReference(t, e, i) {
			e.forEach((t) => {
				const e = t[0],
					r = t[1],
					s = t[2];
				r[e] = i[s];
			});
		}
		static _cleanMetadata(t) {
			t &&
				(delete t['@'],
				delete t['@c'],
				'object' == typeof t &&
					Object.keys(t).forEach((e) => {
						const i = t[e];
						'object' == typeof i && JsonEx._cleanMetadata(i);
					}));
		}
		static _getConstructorName({ constructor: t }) {
			if (!t) return null;
			let e = t.name;
			return (
				void 0 === e && (e = /^\s*function\s*([A-Za-z0-9_$]*)/.exec(t)[1]), e
			);
		}
		static _resetPrototype(t, e) {
			if (void 0 !== Object.setPrototypeOf && 'object' == typeof e)
				Object.setPrototypeOf(t, e);
			else if ('__proto__' in t) t.__proto__ = e;
			else {
				const i = Object.create(e);
				for (let e in t) t.hasOwnProperty(e) && (i[e] = t[e]);
				t = i;
			}
			return t;
		}
	}
	(JsonEx.maxDepth = 100), (JsonEx._id = 1);
	class StorageManagerShim {
		constructor() {
			throw new Error('This is a static class');
		}
		static _makeRequestData(t, e) {
			return { id: t, webKey: DataManager._globalId, data: e || null };
		}
		static async save(t, e) {
			if (!Utils.isWorker())
				return (await Data_Thread.makeSave('save', this._makeRequestData(t, e)))
					.result;
		}
		static async load(t) {
			if (!Utils.isWorker())
				return (await Data_Thread.loadSave('load', this._makeRequestData(t)))
					.result;
		}
		static async exists(t) {
			if (!Utils.isWorker())
				return (
					await Data_Thread.checkSaveExists('exists', this._makeRequestData(t))
				).result;
		}
		static async remove(t) {
			Utils.isWorker();
		}
		static async backup(t) {
			if (!Utils.isWorker())
				return (
					await Data_Thread.backupSave('backup', this._makeRequestData(t))
				).result;
		}
		static cleanBackup(t) {
			Utils.isWorker();
		}
		static restoreBackup(t) {
			Utils.isWorker();
		}
		static isLocalMode() {
			return !1;
		}
		static backupExists(t) {}
		static saveToLocalFile(t, e) {}
		static loadFromLocalFile(t) {}
		static loadFromLocalBackupFile(t) {}
		static localFileBackupExists(t) {}
		static localFileExists(t) {}
		static removeLocalFile(t) {}
		static saveToWebStorage(t, e) {}
		static loadFromWebStorage(t) {}
		static loadFromWebStorageBackup(t) {}
		static webStorageBackupExists(t) {}
		static webStorageExists(t) {}
		static removeWebStorage(t) {}
		static localFileDirectoryPath() {}
		static localFilePath(t) {}
		static canMakeWwwSaveDirectory() {}
		static webStorageKey(t) {}
	}
	class TextManager {
		constructor() {
			throw new Error('This is a static class');
		}
		static basic(t) {
			return self.$dataSystem.terms.basic[t] || '';
		}
		static param(t) {
			return self.$dataSystem.terms.params[t] || '';
		}
		static command(t) {
			return self.$dataSystem.terms.commands[t] || '';
		}
		static message(t) {
			return self.$dataSystem.terms.messages[t] || '';
		}
		static getter(t, e) {
			return {
				get() {
					return this[t](e);
				},
				configurable: !0,
			};
		}
	}
	Object.defineProperty(TextManager, 'currencyUnit', {
		get: () => self.$dataSystem.currencyUnit,
		configurable: !0,
	}),
		Object.defineProperties(TextManager, {
			level: TextManager.getter('basic', 0),
			levelA: TextManager.getter('basic', 1),
			hp: TextManager.getter('basic', 2),
			hpA: TextManager.getter('basic', 3),
			mp: TextManager.getter('basic', 4),
			mpA: TextManager.getter('basic', 5),
			tp: TextManager.getter('basic', 6),
			tpA: TextManager.getter('basic', 7),
			exp: TextManager.getter('basic', 8),
			expA: TextManager.getter('basic', 9),
			fight: TextManager.getter('command', 0),
			escape: TextManager.getter('command', 1),
			attack: TextManager.getter('command', 2),
			guard: TextManager.getter('command', 3),
			item: TextManager.getter('command', 4),
			skill: TextManager.getter('command', 5),
			equip: TextManager.getter('command', 6),
			status: TextManager.getter('command', 7),
			formation: TextManager.getter('command', 8),
			save: TextManager.getter('command', 9),
			gameEnd: TextManager.getter('command', 10),
			options: TextManager.getter('command', 11),
			weapon: TextManager.getter('command', 12),
			armor: TextManager.getter('command', 13),
			keyItem: TextManager.getter('command', 14),
			equip2: TextManager.getter('command', 15),
			optimize: TextManager.getter('command', 16),
			clear: TextManager.getter('command', 17),
			newGame: TextManager.getter('command', 18),
			continue_: TextManager.getter('command', 19),
			toTitle: TextManager.getter('command', 21),
			cancel: TextManager.getter('command', 22),
			buy: TextManager.getter('command', 24),
			sell: TextManager.getter('command', 25),
			alwaysDash: TextManager.getter('message', 'alwaysDash'),
			commandRemember: TextManager.getter('message', 'commandRemember'),
			bgmVolume: TextManager.getter('message', 'bgmVolume'),
			bgsVolume: TextManager.getter('message', 'bgsVolume'),
			meVolume: TextManager.getter('message', 'meVolume'),
			seVolume: TextManager.getter('message', 'seVolume'),
			possession: TextManager.getter('message', 'possession'),
			expTotal: TextManager.getter('message', 'expTotal'),
			expNext: TextManager.getter('message', 'expNext'),
			saveMessage: TextManager.getter('message', 'saveMessage'),
			loadMessage: TextManager.getter('message', 'loadMessage'),
			file: TextManager.getter('message', 'file'),
			partyName: TextManager.getter('message', 'partyName'),
			emerge: TextManager.getter('message', 'emerge'),
			preemptive: TextManager.getter('message', 'preemptive'),
			surprise: TextManager.getter('message', 'surprise'),
			escapeStart: TextManager.getter('message', 'escapeStart'),
			escapeFailure: TextManager.getter('message', 'escapeFailure'),
			victory: TextManager.getter('message', 'victory'),
			defeat: TextManager.getter('message', 'defeat'),
			obtainExp: TextManager.getter('message', 'obtainExp'),
			obtainGold: TextManager.getter('message', 'obtainGold'),
			obtainItem: TextManager.getter('message', 'obtainItem'),
			levelUp: TextManager.getter('message', 'levelUp'),
			obtainSkill: TextManager.getter('message', 'obtainSkill'),
			useItem: TextManager.getter('message', 'useItem'),
			criticalToEnemy: TextManager.getter('message', 'criticalToEnemy'),
			criticalToActor: TextManager.getter('message', 'criticalToActor'),
			actorDamage: TextManager.getter('message', 'actorDamage'),
			actorRecovery: TextManager.getter('message', 'actorRecovery'),
			actorGain: TextManager.getter('message', 'actorGain'),
			actorLoss: TextManager.getter('message', 'actorLoss'),
			actorDrain: TextManager.getter('message', 'actorDrain'),
			actorNoDamage: TextManager.getter('message', 'actorNoDamage'),
			actorNoHit: TextManager.getter('message', 'actorNoHit'),
			enemyDamage: TextManager.getter('message', 'enemyDamage'),
			enemyRecovery: TextManager.getter('message', 'enemyRecovery'),
			enemyGain: TextManager.getter('message', 'enemyGain'),
			enemyLoss: TextManager.getter('message', 'enemyLoss'),
			enemyDrain: TextManager.getter('message', 'enemyDrain'),
			enemyNoDamage: TextManager.getter('message', 'enemyNoDamage'),
			enemyNoHit: TextManager.getter('message', 'enemyNoHit'),
			evasion: TextManager.getter('message', 'evasion'),
			magicEvasion: TextManager.getter('message', 'magicEvasion'),
			magicReflection: TextManager.getter('message', 'magicReflection'),
			counterAttack: TextManager.getter('message', 'counterAttack'),
			substitute: TextManager.getter('message', 'substitute'),
			buffAdd: TextManager.getter('message', 'buffAdd'),
			debuffAdd: TextManager.getter('message', 'debuffAdd'),
			buffRemove: TextManager.getter('message', 'buffRemove'),
			actionFailure: TextManager.getter('message', 'actionFailure'),
		});
	class SoundManager {
		constructor() {
			throw new Error('This is a static class');
		}
		static preloadImportantSounds() {
			this.loadSystemSound(0),
				this.loadSystemSound(1),
				this.loadSystemSound(2),
				this.loadSystemSound(3);
		}
		static playCursor() {
			this.playSystemSound(0);
		}
		static playOk() {
			this.playSystemSound(1);
		}
		static playCancel() {
			this.playSystemSound(2);
		}
		static playBuzzer() {
			this.playSystemSound(3);
		}
		static playEquip() {
			this.playSystemSound(4);
		}
		static playSave() {
			this.playSystemSound(5);
		}
		static playLoad() {
			this.playSystemSound(6);
		}
		static playBattleStart() {
			this.playSystemSound(7);
		}
		static playEscape() {
			this.playSystemSound(8);
		}
		static playEnemyAttack() {
			this.playSystemSound(9);
		}
		static playEnemyDamage() {
			this.playSystemSound(10);
		}
		static playEnemyCollapse() {
			this.playSystemSound(11);
		}
		static playBossCollapse1() {
			this.playSystemSound(12);
		}
		static playBossCollapse2() {
			this.playSystemSound(13);
		}
		static playActorDamage() {
			this.playSystemSound(14);
		}
		static playActorCollapse() {
			this.playSystemSound(15);
		}
		static playRecovery() {
			this.playSystemSound(16);
		}
		static playMiss() {
			this.playSystemSound(17);
		}
		static playEvasion() {
			this.playSystemSound(18);
		}
		static playMagicEvasion() {
			this.playSystemSound(19);
		}
		static playReflection() {
			this.playSystemSound(20);
		}
		static playShop() {
			this.playSystemSound(21);
		}
		static playUseItem() {
			this.playSystemSound(22);
		}
		static playUseSkill() {
			this.playSystemSound(23);
		}
		static loadSystemSound(t) {
			self.$dataSystem && AudioManager.loadStaticSe(self.$dataSystem.sounds[t]);
		}
		static playSystemSound(t) {
			self.$dataSystem && AudioManager.playStaticSe(self.$dataSystem.sounds[t]);
		}
	}
	class Game_Item {
		constructor(...t) {
			this.initialize(...t);
		}
		initialize(t) {
			(this._dataClass = ''), (this._itemId = 0), t && this.setObject(t);
		}
		isSkill() {
			return 'skill' === this._dataClass;
		}
		isItem() {
			return 'item' === this._dataClass;
		}
		isUsableItem() {
			return this.isSkill() || this.isItem();
		}
		isWeapon() {
			return 'weapon' === this._dataClass;
		}
		isArmor() {
			return 'armor' === this._dataClass;
		}
		isEquipItem() {
			return this.isWeapon() || this.isArmor();
		}
		isNull() {
			return '' === this._dataClass;
		}
		itemId() {
			return this._itemId;
		}
		object() {
			return this.isSkill()
				? self.$dataSkills[this._itemId]
				: this.isItem()
				? self.$dataItems[this._itemId]
				: this.isWeapon()
				? self.$dataWeapons[this._itemId]
				: this.isArmor()
				? self.$dataArmors[this._itemId]
				: null;
		}
		setObject(t) {
			DataManager$1.isSkill(t)
				? (this._dataClass = 'skill')
				: DataManager$1.isItem(t)
				? (this._dataClass = 'item')
				: DataManager$1.isWeapon(t)
				? (this._dataClass = 'weapon')
				: DataManager$1.isArmor(t)
				? (this._dataClass = 'armor')
				: (this._dataClass = ''),
				(this._itemId = t ? t.id : 0);
		}
		setEquip(t, e) {
			(this._dataClass = t ? 'weapon' : 'armor'), (this._itemId = e);
		}
	}
	class Game_Action {
		constructor(...t) {
			this.initialize(...t);
		}
		initialize(t, e) {
			(this._subjectActorId = 0),
				(this._subjectEnemyIndex = -1),
				(this._forcing = e || !1),
				this.setSubject(t),
				this.clear();
		}
		clear() {
			(this._item = new Game_Item()), (this._targetIndex = -1);
		}
		setSubject(t) {
			t.isActor()
				? ((this._subjectActorId = t.actorId()), (this._subjectEnemyIndex = -1))
				: ((this._subjectEnemyIndex = t.index()), (this._subjectActorId = 0));
		}
		subject() {
			return this._subjectActorId > 0
				? self.$gameActors.actor(this._subjectActorId)
				: self.$gameTroop.members()[this._subjectEnemyIndex];
		}
		friendsUnit() {
			return this.subject().friendsUnit();
		}
		opponentsUnit() {
			return this.subject().opponentsUnit();
		}
		setEnemyAction(t) {
			t ? this.setSkill(t.skillId) : this.clear();
		}
		setAttack() {
			this.setSkill(this.subject().attackSkillId());
		}
		setGuard() {
			this.setSkill(this.subject().guardSkillId());
		}
		setSkill(t) {
			this._item.setObject(self.$dataSkills[t]);
		}
		setItem(t) {
			this._item.setObject(self.$dataItems[t]);
		}
		setItemObject(t) {
			this._item.setObject(t);
		}
		setTarget(t) {
			this._targetIndex = t;
		}
		item() {
			return this._item.object();
		}
		isSkill() {
			return this._item.isSkill();
		}
		isItem() {
			return this._item.isItem();
		}
		numRepeats() {
			let t = this.item().repeats;
			return (
				this.isAttack() && (t += this.subject().attackTimesAdd()), Math.floor(t)
			);
		}
		checkItemScope(t) {
			return t.contains(this.item().scope);
		}
		isForOpponent() {
			return this.checkItemScope([1, 2, 3, 4, 5, 6]);
		}
		isForFriend() {
			return this.checkItemScope([7, 8, 9, 10, 11]);
		}
		isForDeadFriend() {
			return this.checkItemScope([9, 10]);
		}
		isForUser() {
			return this.checkItemScope([11]);
		}
		isForOne() {
			return this.checkItemScope([1, 3, 7, 9, 11]);
		}
		isForRandom() {
			return this.checkItemScope([3, 4, 5, 6]);
		}
		isForAll() {
			return this.checkItemScope([2, 8, 10]);
		}
		needsSelection() {
			return this.checkItemScope([1, 7, 9]);
		}
		numTargets() {
			return this.isForRandom() ? this.item().scope - 2 : 0;
		}
		checkDamageType(t) {
			return t.contains(this.item().damage.type);
		}
		isHpEffect() {
			return this.checkDamageType([1, 3, 5]);
		}
		isMpEffect() {
			return this.checkDamageType([2, 4, 6]);
		}
		isDamage() {
			return this.checkDamageType([1, 2]);
		}
		isRecover() {
			return this.checkDamageType([3, 4]);
		}
		isDrain() {
			return this.checkDamageType([5, 6]);
		}
		isHpRecover() {
			return this.checkDamageType([3]);
		}
		isMpRecover() {
			return this.checkDamageType([4]);
		}
		isCertainHit() {
			return this.item().hitType === Game_Action.HITTYPE_CERTAIN;
		}
		isPhysical() {
			return this.item().hitType === Game_Action.HITTYPE_PHYSICAL;
		}
		isMagical() {
			return this.item().hitType === Game_Action.HITTYPE_MAGICAL;
		}
		isAttack() {
			return this.item() === self.$dataSkills[this.subject().attackSkillId()];
		}
		isGuard() {
			return this.item() === self.$dataSkills[this.subject().guardSkillId()];
		}
		isMagicSkill() {
			return (
				!!this.isSkill() &&
				self.$dataSystem.magicSkills.contains(this.item().stypeId)
			);
		}
		decideRandomTarget() {
			let t;
			(t = this.isForDeadFriend()
				? this.friendsUnit().randomDeadTarget()
				: this.isForFriend()
				? this.friendsUnit().randomTarget()
				: this.opponentsUnit().randomTarget()),
				t ? (this._targetIndex = t.index()) : this.clear();
		}
		setConfusion() {
			this.setAttack();
		}
		prepare() {
			this.subject().isConfused() && !this._forcing && this.setConfusion();
		}
		isValid() {
			return (
				(this._forcing && this.item()) || this.subject().canUse(this.item())
			);
		}
		speed() {
			const t = this.subject().agi;
			let e = t + Math.randomInt(Math.floor(5 + t / 4));
			return (
				this.item() && (e += this.item().speed),
				this.isAttack() && (e += this.subject().attackSpeed()),
				e
			);
		}
		makeTargets() {
			let t = [];
			return (
				!this._forcing && this.subject().isConfused()
					? (t = [this.confusionTarget()])
					: this.isForOpponent()
					? (t = this.targetsForOpponents())
					: this.isForFriend() && (t = this.targetsForFriends()),
				this.repeatTargets(t)
			);
		}
		repeatTargets(t) {
			const e = [],
				i = this.numRepeats();
			for (const r of t) if (r) for (let t = 0; t < i; t++) e.push(r);
			return e;
		}
		confusionTarget() {
			switch (this.subject().confusionLevel()) {
				case 1:
					return this.opponentsUnit().randomTarget();
				case 2:
					return 0 === Math.randomInt(2)
						? this.opponentsUnit().randomTarget()
						: this.friendsUnit().randomTarget();
				default:
					return this.friendsUnit().randomTarget();
			}
		}
		targetsForOpponents() {
			let t = [];
			const e = this.opponentsUnit();
			if (this.isForRandom())
				for (let i = 0; i < this.numTargets(); i++) t.push(e.randomTarget());
			else
				this.isForOne()
					? this._targetIndex < 0
						? t.push(e.randomTarget())
						: t.push(e.smoothTarget(this._targetIndex))
					: (t = e.aliveMembers());
			return t;
		}
		targetsForFriends() {
			let t = [];
			const e = this.friendsUnit();
			return this.isForUser()
				? [this.subject()]
				: (this.isForDeadFriend()
						? this.isForOne()
							? t.push(e.smoothDeadTarget(this._targetIndex))
							: (t = e.deadMembers())
						: this.isForOne()
						? this._targetIndex < 0
							? t.push(e.randomTarget())
							: t.push(e.smoothTarget(this._targetIndex))
						: (t = e.aliveMembers()),
				  t);
		}
		evaluate() {
			let t = 0;
			return (
				this.itemTargetCandidates().forEach(function (e) {
					const i = this.evaluateWithTarget(e);
					this.isForAll()
						? (t += i)
						: i > t && ((t = i), (this._targetIndex = e.index()));
				}, this),
				(t *= this.numRepeats()),
				t > 0 && (t += Math.random()),
				t
			);
		}
		itemTargetCandidates() {
			return this.isValid()
				? this.isForOpponent()
					? this.opponentsUnit().aliveMembers()
					: this.isForUser()
					? [this.subject()]
					: this.isForDeadFriend()
					? this.friendsUnit().deadMembers()
					: this.friendsUnit().aliveMembers()
				: [];
		}
		evaluateWithTarget(t) {
			if (this.isHpEffect()) {
				const e = this.makeDamageValue(t, !1);
				return this.isForOpponent()
					? e / Math.max(t.hp, 1)
					: Math.min(-e, t.mhp - t.hp) / t.mhp;
			}
		}
		testApply(t) {
			return (
				this.isForDeadFriend() === t.isDead() &&
				(self.$gameParty.inBattle() ||
					this.isForOpponent() ||
					(this.isHpRecover() && t.hp < t.mhp) ||
					(this.isMpRecover() && t.mp < t.mmp) ||
					this.hasItemAnyValidEffects(t))
			);
		}
		hasItemAnyValidEffects(t) {
			return this.item().effects.some(function (e) {
				return this.testItemEffect(t, e);
			}, this);
		}
		testItemEffect(t, { code: e, value1: i, value2: r, dataId: s }) {
			switch (e) {
				case Game_Action.EFFECT_RECOVER_HP:
					return t.hp < t.mhp || i < 0 || r < 0;
				case Game_Action.EFFECT_RECOVER_MP:
					return t.mp < t.mmp || i < 0 || r < 0;
				case Game_Action.EFFECT_ADD_STATE:
					return !t.isStateAffected(s);
				case Game_Action.EFFECT_REMOVE_STATE:
					return t.isStateAffected(s);
				case Game_Action.EFFECT_ADD_BUFF:
					return !t.isMaxBuffAffected(s);
				case Game_Action.EFFECT_ADD_DEBUFF:
					return !t.isMaxDebuffAffected(s);
				case Game_Action.EFFECT_REMOVE_BUFF:
					return t.isBuffAffected(s);
				case Game_Action.EFFECT_REMOVE_DEBUFF:
					return t.isDebuffAffected(s);
				case Game_Action.EFFECT_LEARN_SKILL:
					return t.isActor() && !t.isLearnedSkill(s);
				default:
					return !0;
			}
		}
		itemCnt(t) {
			return this.isPhysical() && t.canMove() ? t.cnt : 0;
		}
		itemMrf({ mrf: t }) {
			return this.isMagical() ? t : 0;
		}
		itemHit(t) {
			return this.isPhysical()
				? 0.01 * this.item().successRate * this.subject().hit
				: 0.01 * this.item().successRate;
		}
		itemEva({ eva: t, mev: e }) {
			return this.isPhysical() ? t : this.isMagical() ? e : 0;
		}
		itemCri({ cev: t }) {
			return this.item().damage.critical ? this.subject().cri * (1 - t) : 0;
		}
		apply(t) {
			const e = t.result();
			if (
				(this.subject().clearResult(),
				e.clear(),
				(e.used = this.testApply(t)),
				(e.missed = this.processItemHitFormula(e, t)),
				(e.evaded = this.processItemEvaFormula(e, t)),
				(e.physical = this.isPhysical()),
				(e.drain = this.isDrain()),
				e.isHit())
			) {
				if (this.item().damage.type > 0) {
					e.critical = this.processItemCriFormula(e, t);
					const i = this.makeDamageValue(t, e.critical);
					this.executeDamage(t, i),
						this.subject().onApplyDamage(this, t, i),
						t.onReceiveDamage(this, this.subject(), i),
						e.critical &&
							(this.subject().onApplyCritical(this, t, i),
							t.onReceiveCritical(this, this.subject(), i));
				}
				this.item().effects.forEach(function (e) {
					this.applyItemEffect(t, e);
				}, this),
					this.applyItemUserEffect(t);
			} else
				this.subject().onHitAction(this, t),
					t.onEvadeAction(this, this.subject());
		}
		processItemHitFormula(t, e) {
			return t.used && Math.random() >= this.itemHit(e);
		}
		processItemEvaFormula(t, e) {
			return !t.missed && Math.random() < this.itemEva(e);
		}
		processItemCriFormula(t, e) {
			return Math.random() < this.itemCri(e);
		}
		makeDamageValue(t, e) {
			const i = this.item(),
				r = this.evalDamageFormula(t);
			let s = this.processElementalDamage(i, r, t, e);
			return (
				this.isPhysical() && (s = this.processPhysicalDamage(i, s, t, e)),
				this.isMagical() && (s = this.processMagicalDamage(i, s, t, e)),
				r < 0 && (s = this.processRecoveryDamage(i, s, t, e)),
				e && (s = this.processCriticalDamage(i, s, t, e)),
				(s = this.processVarianceDamage(i, s, t, e)),
				(s = this.processGuardDamage(i, s, t, e)),
				(s = this.processDamageEnd(i, s, t, e)),
				s
			);
		}
		processElementalDamage(t, e, i, r) {
			return e * this.calcElementRate(i);
		}
		processPhysicalDamage(t, e, i, r) {
			return e * i.pdr;
		}
		processMagicalDamage(t, e, i, r) {
			return e * i.mdr;
		}
		processRecoveryDamage(t, e, i, r) {
			return e * i.rec;
		}
		processCriticalDamage(t, e, i, r) {
			return this.applyCritical(e);
		}
		processVarianceDamage(t, e, i, r) {
			return this.applyVariance(e, t.damage.variance);
		}
		processGuardDamage(t, e, i, r) {
			return this.applyGuard(e, i);
		}
		processDamageEnd(t, e, i, r) {
			return Math.round(e);
		}
		evalDamageFormula(target) {
			try {
				const item = this.item(),
					a = this.subject(),
					b = target,
					v = self.$gameVariables._data,
					sign = [3, 4].contains(item.damage.type) ? -1 : 1;
				let value = Math.max(eval(item.damage.formula), 0) * sign;
				return isNaN(value) && (value = 0), value;
			} catch (t) {
				return 0;
			}
		}
		calcElementRate(t) {
			return this.item().damage.elementId < 0
				? this.elementsMaxRate(t, this.subject().attackElements())
				: t.elementRate(this.item().damage.elementId);
		}
		elementsMaxRate(t, e) {
			return e.length > 0
				? Math.max.apply(
						null,
						e.map((e) => t.elementRate(e), this)
				  )
				: 1;
		}
		applyCritical(t) {
			return 3 * t;
		}
		applyVariance(t, e) {
			const i = Math.floor(Math.max((Math.abs(t) * e) / 100, 0)),
				r = Math.randomInt(i + 1) + Math.randomInt(i + 1) - i;
			return t >= 0 ? t + r : t - r;
		}
		applyGuard(t, e) {
			return t / (t > 0 && e.isGuard() ? 2 * e.grd : 1);
		}
		executeDamage(t, e) {
			const i = t.result();
			0 === e && (i.critical = !1),
				this.isHpEffect() && this.executeHpDamage(t, e),
				this.isMpEffect() && this.executeMpDamage(t, e);
		}
		executeHpDamage(t, e) {
			this.isDrain() && (e = Math.min(t.hp, e)),
				this.makeSuccess(t),
				t.gainHp(-e),
				e > 0 && t.onDamage(e),
				this.gainDrainedHp(e);
		}
		executeMpDamage(t, e) {
			this.isMpRecover() || (e = Math.min(t.mp, e)),
				0 !== e && this.makeSuccess(t),
				t.gainMp(-e),
				this.gainDrainedMp(e);
		}
		gainDrainedHp(t) {
			if (this.isDrain()) {
				let e = this.subject();
				void 0 !== this._reflectionTarget && (e = this._reflectionTarget),
					e.gainHp(t);
			}
		}
		gainDrainedMp(t) {
			if (this.isDrain()) {
				let e = this.subject();
				void 0 !== this._reflectionTarget && (e = this._reflectionTarget),
					e.gainMp(t);
			}
		}
		applyItemEffect(t, e) {
			switch (e.code) {
				case Game_Action.EFFECT_RECOVER_HP:
					this.itemEffectRecoverHp(t, e);
					break;
				case Game_Action.EFFECT_RECOVER_MP:
					this.itemEffectRecoverMp(t, e);
					break;
				case Game_Action.EFFECT_GAIN_TP:
					this.itemEffectGainTp(t, e);
					break;
				case Game_Action.EFFECT_ADD_STATE:
					this.itemEffectAddState(t, e);
					break;
				case Game_Action.EFFECT_REMOVE_STATE:
					this.itemEffectRemoveState(t, e);
					break;
				case Game_Action.EFFECT_ADD_BUFF:
					this.itemEffectAddBuff(t, e);
					break;
				case Game_Action.EFFECT_ADD_DEBUFF:
					this.itemEffectAddDebuff(t, e);
					break;
				case Game_Action.EFFECT_REMOVE_BUFF:
					this.itemEffectRemoveBuff(t, e);
					break;
				case Game_Action.EFFECT_REMOVE_DEBUFF:
					this.itemEffectRemoveDebuff(t, e);
					break;
				case Game_Action.EFFECT_SPECIAL:
					this.itemEffectSpecial(t, e);
					break;
				case Game_Action.EFFECT_GROW:
					this.itemEffectGrow(t, e);
					break;
				case Game_Action.EFFECT_LEARN_SKILL:
					this.itemEffectLearnSkill(t, e);
					break;
				case Game_Action.EFFECT_COMMON_EVENT:
					this.itemEffectCommonEvent(t, e);
			}
		}
		itemEffectRecoverHp(t, { value1: e, value2: i }) {
			let r = (t.mhp * e + i) * t.rec;
			this.isItem() && (r *= this.subject().pha),
				(r = Math.floor(r)),
				0 !== r && (t.gainHp(r), this.makeSuccess(t));
		}
		itemEffectRecoverMp(t, { value1: e, value2: i }) {
			let r = (t.mmp * e + i) * t.rec;
			this.isItem() && (r *= this.subject().pha),
				(r = Math.floor(r)),
				0 !== r && (t.gainMp(r), this.makeSuccess(t));
		}
		itemEffectGainTp(t, { value1: e }) {
			const i = Math.floor(e);
			0 !== i && (t.gainTp(i), this.makeSuccess(t));
		}
		itemEffectAddState(t, e) {
			0 === e.dataId
				? this.itemEffectAddAttackState(t, e)
				: this.itemEffectAddNormalState(t, e);
		}
		itemEffectAddAttackState(t, { value1: e }) {
			this.subject()
				.attackStates()
				.forEach((i) => {
					let r = e;
					(r *= t.stateRate(i)),
						(r *= this.subject().attackStatesRate(i)),
						(r *= this.lukEffectRate(t)),
						Math.random() < r &&
							(t.addState(i, this.subject()), this.makeSuccess(t));
				}, t);
		}
		itemEffectAddNormalState(t, { value1: e, dataId: i }) {
			let r = e;
			this.isCertainHit() ||
				((r *= t.stateRate(i)), (r *= this.lukEffectRate(t))),
				Math.random() < r &&
					(t.addState(i, this.subject()), this.makeSuccess(t));
		}
		itemEffectRemoveState(t, { value1: e, dataId: i }) {
			const r = e;
			Math.random() < r && (t.removeState(i), this.makeSuccess(t));
		}
		itemEffectAddBuff(t, { dataId: e, value1: i }) {
			t.addBuff(e, i), this.makeSuccess(t);
		}
		itemEffectAddDebuff(t, { dataId: e, value1: i }) {
			const r = t.debuffRate(e) * this.lukEffectRate(t);
			Math.random() < r && (t.addDebuff(e, i), this.makeSuccess(t));
		}
		itemEffectRemoveBuff(t, { dataId: e }) {
			t.isBuffAffected(e) && (t.removeBuff(e), this.makeSuccess(t));
		}
		itemEffectRemoveDebuff(t, { dataId: e }) {
			t.isDebuffAffected(e) && (t.removeBuff(e), this.makeSuccess(t));
		}
		itemEffectSpecial(t, { dataId: e }) {
			e === Game_Action.SPECIAL_EFFECT_ESCAPE &&
				(t.escape(), this.makeSuccess(t));
		}
		itemEffectGrow(t, { dataId: e, value1: i }) {
			t.addParam(e, Math.floor(i)), this.makeSuccess(t);
		}
		itemEffectLearnSkill(t, { dataId: e }) {
			t.isActor() && (t.learnSkill(e), this.makeSuccess(t));
		}
		itemEffectCommonEvent(t, e) {}
		makeSuccess(t) {
			t.result().success = !0;
		}
		applyItemUserEffect(t) {
			const e = Math.floor(this.item().tpGain * this.subject().tcr);
			this.subject().gainSilentTp(e);
		}
		lukEffectRate({ luk: t }) {
			return Math.max(1 + 0.001 * (this.subject().luk - t), 0);
		}
		applyGlobal() {
			this.item().effects.forEach(({ code: t, dataId: e }) => {
				t === Game_Action.EFFECT_COMMON_EVENT &&
					self.$gameTemp.reserveCommonEvent(e);
			}, this);
		}
	}
	(Game_Action.EFFECT_RECOVER_HP = 11),
		(Game_Action.EFFECT_RECOVER_MP = 12),
		(Game_Action.EFFECT_GAIN_TP = 13),
		(Game_Action.EFFECT_ADD_STATE = 21),
		(Game_Action.EFFECT_REMOVE_STATE = 22),
		(Game_Action.EFFECT_ADD_BUFF = 31),
		(Game_Action.EFFECT_ADD_DEBUFF = 32),
		(Game_Action.EFFECT_REMOVE_BUFF = 33),
		(Game_Action.EFFECT_REMOVE_DEBUFF = 34),
		(Game_Action.EFFECT_SPECIAL = 41),
		(Game_Action.EFFECT_GROW = 42),
		(Game_Action.EFFECT_LEARN_SKILL = 43),
		(Game_Action.EFFECT_COMMON_EVENT = 44),
		(Game_Action.SPECIAL_EFFECT_ESCAPE = 0),
		(Game_Action.HITTYPE_CERTAIN = 0),
		(Game_Action.HITTYPE_PHYSICAL = 1),
		(Game_Action.HITTYPE_MAGICAL = 2);
	class Scene_Base extends Stage {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize(),
				(this._active = !1),
				(this._fadeSign = 0),
				(this._fadeDuration = 0),
				(this._fadeSprite = null),
				(this._imageReservationId = Utils.generateRuntimeId());
		}
		attachReservation() {
			ImageManager.setDefaultReservationId(this._imageReservationId);
		}
		detachReservation() {
			ImageManager.releaseReservation(this._imageReservationId);
		}
		create() {}
		isActive() {
			return this._active;
		}
		isReady() {
			return ImageManager.isReady();
		}
		start() {
			this._active = !0;
		}
		update() {
			this.updateFade(), this.updateChildren();
		}
		stop() {
			this._active = !1;
		}
		isBusy() {
			return this._fadeDuration > 0;
		}
		terminate() {}
		createWindowLayer() {
			const t = Graphics.boxWidth,
				e = Graphics.boxHeight,
				i = (Graphics.width - t) / 2,
				r = (Graphics.height - e) / 2;
			(this._windowLayer = new WindowLayer()),
				this._windowLayer.move(i, r, t, e),
				this.addChild(this._windowLayer);
		}
		addWindow(t) {
			this._windowLayer.addChild(t);
		}
		startFadeIn(t, e) {
			this.createFadeSprite(e),
				(this._fadeSign = 1),
				(this._fadeDuration = t || 30),
				(this._fadeSprite.opacity = 255);
		}
		startFadeOut(t, e) {
			this.createFadeSprite(e),
				(this._fadeSign = -1),
				(this._fadeDuration = t || 30),
				(this._fadeSprite.opacity = 0);
		}
		createFadeSprite(t) {
			this._fadeSprite ||
				((this._fadeSprite = new ScreenSprite()),
				this.addChild(this._fadeSprite)),
				t ? this._fadeSprite.setWhite() : this._fadeSprite.setBlack();
		}
		updateFade() {
			if (this._fadeDuration > 0) {
				const t = this._fadeDuration;
				this._fadeSign > 0
					? (this._fadeSprite.opacity -= this._fadeSprite.opacity / t)
					: (this._fadeSprite.opacity += (255 - this._fadeSprite.opacity) / t),
					this._fadeDuration--;
			}
		}
		updateChildren() {
			this.children.forEach((t) => {
				t.update && t.update();
			});
		}
		popScene() {
			SceneManager.pop();
		}
		checkGameover() {
			self.$gameParty.isAllDead() && SceneManager.goto(Scene_Gameover);
		}
		fadeOutAll() {
			const t = this.slowFadeSpeed() / 60;
			AudioManager.fadeOutBgm(t),
				AudioManager.fadeOutBgs(t),
				AudioManager.fadeOutMe(t),
				this.startFadeOut(this.slowFadeSpeed());
		}
		fadeSpeed() {
			return 24;
		}
		slowFadeSpeed() {
			return 2 * this.fadeSpeed();
		}
	}
	class Sprite_Picture extends Sprite {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t) {
			super.initialize(),
				(this._pictureId = t),
				(this._pictureName = ''),
				this.update();
		}
		picture() {
			return self.$gameScreen.picture(this._pictureId);
		}
		update() {
			super.update(),
				this.updateBitmap(),
				this.visible &&
					(this.updateOrigin(),
					this.updatePosition(),
					this.updateScale(),
					this.updateTone(),
					this.updateOther());
		}
		updateBitmap() {
			const t = this.picture();
			if (t) {
				const e = t.name();
				this._pictureName !== e && ((this._pictureName = e), this.loadBitmap()),
					(this.visible = !0);
			} else
				(this._pictureName = ''), (this.bitmap = null), (this.visible = !1);
		}
		updateOrigin() {
			0 === this.picture().origin()
				? ((this.anchor.x = 0), (this.anchor.y = 0))
				: ((this.anchor.x = 0.5), (this.anchor.y = 0.5));
		}
		updatePosition() {
			const t = this.picture();
			(this.x = Math.floor(t.x())), (this.y = Math.floor(t.y()));
		}
		updateScale() {
			const t = this.picture();
			(this.scale.x = t.scaleX() / 100), (this.scale.y = t.scaleY() / 100);
		}
		updateTone() {
			const t = this.picture();
			t.tone() ? this.setColorTone(t.tone()) : this.setColorTone([0, 0, 0, 0]);
		}
		updateOther() {
			const t = this.picture();
			(this.opacity = t.opacity()),
				(this.blendMode = t.blendMode()),
				(this.rotation = (t.angle() * Math.PI) / 180);
		}
		loadBitmap() {
			this.bitmap = ImageManager.loadPicture(this._pictureName);
		}
	}
	class Sprite_Timer extends Sprite {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize(),
				(this._seconds = 0),
				this.createBitmap(),
				this.update();
		}
		createBitmap() {
			(this.bitmap = new Bitmap(96, 48)), (this.bitmap.fontSize = 32);
		}
		update() {
			super.update(),
				this.updateBitmap(),
				this.updatePosition(),
				this.updateVisibility();
		}
		updateBitmap() {
			this._seconds !== self.$gameTimer.seconds() &&
				((this._seconds = self.$gameTimer.seconds()), this.redraw());
		}
		redraw() {
			const t = this.timerText(),
				e = this.bitmap.width,
				i = this.bitmap.height;
			this.bitmap.clear(), this.bitmap.drawText(t, 0, 0, e, i, 'center');
		}
		timerText() {
			const t = Math.floor(this._seconds / 60) % 60,
				e = this._seconds % 60;
			return `${t.padZero(2)}:${e.padZero(2)}`;
		}
		updatePosition() {
			(this.x = Graphics.width - this.bitmap.width), (this.y = 0);
		}
		updateVisibility() {
			this.visible = self.$gameTimer.isWorking();
		}
	}
	class Spriteset_Base extends Sprite {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize(),
				this.setFrame(0, 0, Graphics.width, Graphics.height),
				(this._tone = [0, 0, 0, 0]),
				(this.opaque = !0),
				this.createLowerLayer(),
				this.createToneChanger(),
				this.createUpperLayer(),
				this.update();
		}
		createLowerLayer() {
			this.createBaseSprite();
		}
		createUpperLayer() {
			this.createPictures(), this.createTimer(), this.createScreenSprites();
		}
		update() {
			super.update(),
				this.updateScreenSprites(),
				this.updateToneChanger(),
				this.updatePosition();
		}
		createBaseSprite() {
			(this._baseSprite = new Sprite()),
				this._baseSprite.setFrame(0, 0, this.width, this.height),
				(this._blackScreen = new ScreenSprite()),
				(this._blackScreen.opacity = 255),
				this.addChild(this._baseSprite),
				this._baseSprite.addChild(this._blackScreen);
		}
		createToneChanger() {
			Graphics.isWebGL()
				? this.createWebGLToneChanger()
				: this.createCanvasToneChanger();
		}
		createWebGLToneChanger() {
			const t = Graphics.width + 96,
				e = Graphics.height + 96;
			(this._toneFilter = new ToneFilter()),
				(this._toneFilter.enabled = !1),
				(this._baseSprite.filters = [this._toneFilter]),
				(this._baseSprite.filterArea = new Rectangle(-48, -48, t, e));
		}
		createCanvasToneChanger() {
			(this._toneSprite = new ToneSprite()), this.addChild(this._toneSprite);
		}
		createPictures() {
			const t = Graphics.boxWidth,
				e = Graphics.boxHeight,
				i = (Graphics.width - t) / 2,
				r = (Graphics.height - e) / 2;
			(this._pictureContainer = new Sprite()),
				this._pictureContainer.setFrame(i, r, t, e);
			for (let t = 1; t <= self.$gameScreen.maxPictures(); t++)
				this._pictureContainer.addChild(new Sprite_Picture(t));
			this.addChild(this._pictureContainer);
		}
		createTimer() {
			(this._timerSprite = new Sprite_Timer()),
				this.addChild(this._timerSprite);
		}
		createScreenSprites() {
			(this._flashSprite = new ScreenSprite()),
				(this._fadeSprite = new ScreenSprite()),
				this.addChild(this._flashSprite),
				this.addChild(this._fadeSprite);
		}
		updateScreenSprites() {
			const t = self.$gameScreen.flashColor();
			this._flashSprite.setColor(t[0], t[1], t[2]),
				(this._flashSprite.opacity = t[3]),
				(this._fadeSprite.opacity = 255 - self.$gameScreen.brightness());
		}
		updateToneChanger() {
			const t = self.$gameScreen.tone();
			this._tone.equals(t) ||
				((this._tone = t.clone()),
				Graphics.isWebGL()
					? this.updateWebGLToneChanger()
					: this.updateCanvasToneChanger());
		}
		updateWebGLToneChanger() {
			const t = this._tone;
			this._toneFilter.reset(),
				t[0] || t[1] || t[2] || t[3]
					? ((this._toneFilter.enabled = !0),
					  this._toneFilter.adjustTone(t[0], t[1], t[2]),
					  this._toneFilter.adjustSaturation(-t[3]))
					: (this._toneFilter.enabled = !1);
		}
		updateCanvasToneChanger() {
			const t = this._tone;
			this._toneSprite.setTone(t[0], t[1], t[2], t[3]);
		}
		updatePosition() {
			const t = self.$gameScreen,
				e = t.zoomScale();
			(this.scale.x = e),
				(this.scale.y = e),
				(this.x = Math.round(-t.zoomX() * (e - 1))),
				(this.y = Math.round(-t.zoomY() * (e - 1))),
				(this.x += Math.round(t.shake()));
		}
	}
	class Sprite_Animation extends Sprite {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize(), (this._reduceArtifacts = !0), this.initMembers();
		}
		initMembers() {
			(this._target = null),
				(this._animation = null),
				(this._mirror = !1),
				(this._delay = 0),
				(this._rate = 4),
				(this._duration = 0),
				(this._flashColor = [0, 0, 0, 0]),
				(this._flashDuration = 0),
				(this._screenFlashDuration = 0),
				(this._hidingDuration = 0),
				(this._bitmap1 = null),
				(this._bitmap2 = null),
				(this._cellSprites = []),
				(this._screenFlashSprite = null),
				(this._duplicated = !1),
				(this.z = 8);
		}
		setup(t, e, i, r) {
			(this._target = t),
				(this._animation = e),
				(this._mirror = i),
				(this._delay = r),
				this._animation &&
					(this.remove(),
					this.setupRate(),
					this.setupDuration(),
					this.loadBitmaps(),
					this.createSprites());
		}
		remove() {
			this.parent &&
				this.parent.removeChild(this) &&
				(this._target.setBlendColor([0, 0, 0, 0]), this._target.show());
		}
		setupRate() {
			this._rate = 4;
		}
		setupDuration() {
			this._duration = this._animation.frames.length * this._rate + 1;
		}
		update() {
			super.update(),
				this.updateMain(),
				this.updateFlash(),
				this.updateScreenFlash(),
				this.updateHiding(),
				(Sprite_Animation._checker1 = {}),
				(Sprite_Animation._checker2 = {});
		}
		updateFlash() {
			if (this._flashDuration > 0) {
				const t = this._flashDuration--;
				(this._flashColor[3] *= (t - 1) / t),
					this._target.setBlendColor(this._flashColor);
			}
		}
		updateScreenFlash() {
			if (this._screenFlashDuration > 0) {
				const t = this._screenFlashDuration--;
				this._screenFlashSprite &&
					((this._screenFlashSprite.x = -this.absoluteX()),
					(this._screenFlashSprite.y = -this.absoluteY()),
					(this._screenFlashSprite.opacity *= (t - 1) / t),
					(this._screenFlashSprite.visible = this._screenFlashDuration > 0));
			}
		}
		absoluteX() {
			let t = 0,
				e = this;
			for (; e; ) (t += e.x), (e = e.parent);
			return t;
		}
		absoluteY() {
			let t = 0,
				e = this;
			for (; e; ) (t += e.y), (e = e.parent);
			return t;
		}
		updateHiding() {
			this._hidingDuration > 0 &&
				(this._hidingDuration--,
				0 === this._hidingDuration && this._target.show());
		}
		isPlaying() {
			return this._duration > 0;
		}
		loadBitmaps() {
			const t = this._animation.animation1Name,
				e = this._animation.animation2Name,
				i = this._animation.animation1Hue,
				r = this._animation.animation2Hue;
			(this._bitmap1 = ImageManager.loadAnimation(t, i)),
				(this._bitmap2 = ImageManager.loadAnimation(e, r));
		}
		isReady() {
			return (
				this._bitmap1 &&
				this._bitmap1.isReady() &&
				this._bitmap2 &&
				this._bitmap2.isReady()
			);
		}
		createSprites() {
			Sprite_Animation._checker2[this._animation] ||
				(this.createCellSprites(),
				3 === this._animation.position &&
					(Sprite_Animation._checker2[this._animation] = !0),
				this.createScreenFlashSprite()),
				Sprite_Animation._checker1[this._animation]
					? (this._duplicated = !0)
					: ((this._duplicated = !1),
					  3 === this._animation.position &&
							(Sprite_Animation._checker1[this._animation] = !0));
		}
		createCellSprites() {
			this._cellSprites = [];
			for (let t = 0; t < 16; t++) {
				const t = new Sprite();
				(t.anchor.x = 0.5),
					(t.anchor.y = 0.5),
					this._cellSprites.push(t),
					this.addChild(t);
			}
		}
		createScreenFlashSprite() {
			(this._screenFlashSprite = new ScreenSprite()),
				this.addChild(this._screenFlashSprite);
		}
		updateMain() {
			this.isPlaying() &&
				this.isReady() &&
				(this._delay > 0
					? this._delay--
					: (this._duration--,
					  this.updatePosition(),
					  this._duration % this._rate == 0 && this.updateFrame()));
		}
		updatePosition() {
			if (3 === this._animation.position)
				(this.x = this.parent.width / 2), (this.y = this.parent.height / 2);
			else {
				const t = this._target.parent,
					e = t ? t.parent : null;
				(this.x = this._target.x),
					(this.y = this._target.y),
					this.parent === e && ((this.x += t.x), (this.y += t.y)),
					0 === this._animation.position
						? (this.y -= this._target.height)
						: 1 === this._animation.position &&
						  (this.y -= this._target.height / 2);
			}
		}
		updateFrame() {
			if (this._duration > 0) {
				const t = this.currentFrameIndex();
				this.updateAllCellSprites(this._animation.frames[t]),
					this._animation.timings.forEach(function (e) {
						e.frame === t && this.processTimingData(e);
					}, this);
			}
		}
		currentFrameIndex() {
			return (
				this._animation.frames.length -
				Math.floor((this._duration + this._rate - 1) / this._rate)
			);
		}
		updateAllCellSprites(t) {
			this._cellSprites.forEach((e, i) => {
				i < t.length ? this.updateCellSprite(e, t[i]) : (e.visible = !1);
			});
		}
		updateCellSprite(t, e) {
			const i = e[0];
			if (i >= 0) {
				const r = (i % 5) * 192,
					s = 192 * Math.floor((i % 100) / 5),
					n = this._mirror;
				(t.bitmap = i < 100 ? this._bitmap1 : this._bitmap2),
					t.setFrame(r, s, 192, 192),
					(t.x = e[1]),
					(t.y = e[2]),
					(t.rotation = (e[4] * Math.PI) / 180),
					(t.scale.x = e[3] / 100),
					e[5] && (t.scale.x *= -1),
					n && ((t.x *= -1), (t.rotation *= -1), (t.scale.x *= -1)),
					(t.scale.y = e[3] / 100),
					(t.opacity = e[6]),
					(t.blendMode = e[7]),
					(t.visible = !0);
			} else t.visible = !1;
		}
		processTimingData({
			flashDuration: t,
			flashScope: e,
			flashColor: i,
			se: r,
		}) {
			const s = t * this._rate;
			switch (e) {
				case 1:
					this.startFlash(i, s);
					break;
				case 2:
					this.startScreenFlash(i, s);
					break;
				case 3:
					this.startHiding(s);
			}
			!this._duplicated && r && AudioManager.playSe(r);
		}
		startFlash(t, e) {
			(this._flashColor = t.clone()), (this._flashDuration = e);
		}
		startScreenFlash(t, e) {
			(this._screenFlashDuration = e),
				this._screenFlashSprite &&
					(this._screenFlashSprite.setColor(t[0], t[1], t[2]),
					(this._screenFlashSprite.opacity = t[3]));
		}
		startHiding(t) {
			(this._hidingDuration = t), this._target.hide();
		}
	}
	(Sprite_Animation._checker1 = {}), (Sprite_Animation._checker2 = {});
	class Sprite_Base extends Sprite {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize(),
				(this._animationSprites = []),
				(this._effectTarget = this),
				(this._hiding = !1);
		}
		update() {
			super.update(), this.updateVisibility(), this.updateAnimationSprites();
		}
		hide() {
			(this._hiding = !0), this.updateVisibility();
		}
		show() {
			(this._hiding = !1), this.updateVisibility();
		}
		updateVisibility() {
			this.visible = !this._hiding;
		}
		updateAnimationSprites() {
			if (this._animationSprites.length > 0) {
				const t = this._animationSprites.clone();
				this._animationSprites = [];
				for (const e of t)
					e.isPlaying() ? this._animationSprites.push(e) : e.remove();
			}
		}
		startAnimation(t, e, i) {
			const r = new Sprite_Animation();
			r.setup(this._effectTarget, t, e, i),
				this.parent.addChild(r),
				this._animationSprites.push(r);
		}
		isAnimationPlaying() {
			return this._animationSprites.length > 0;
		}
	}
	class Sprite_Damage extends Sprite {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize(),
				(this._duration = 90),
				(this._flashColor = [0, 0, 0, 0]),
				(this._flashDuration = 0),
				(this._damageBitmap = ImageManager.loadSystem('Damage'));
		}
		setup(t) {
			const e = t.result();
			e.missed || e.evaded
				? this.createMiss()
				: e.hpAffected
				? this.createDigits(0, e.hpDamage)
				: t.isAlive() && 0 !== e.mpDamage && this.createDigits(2, e.mpDamage),
				e.critical && this.setupCriticalEffect();
		}
		setupCriticalEffect() {
			(this._flashColor = [255, 0, 0, 160]), (this._flashDuration = 60);
		}
		digitWidth() {
			return this._damageBitmap ? this._damageBitmap.width / 10 : 0;
		}
		digitHeight() {
			return this._damageBitmap ? this._damageBitmap.height / 5 : 0;
		}
		createMiss() {
			const t = this.digitWidth(),
				e = this.digitHeight(),
				i = this.createChildSprite();
			i.setFrame(0, 4 * e, 4 * t, e), (i.dy = 0);
		}
		createDigits(t, e) {
			const i = Math.abs(e).toString(),
				r = t + (e < 0 ? 1 : 0),
				s = this.digitWidth(),
				n = this.digitHeight();
			for (let t = 0; t < i.length; t++) {
				const e = this.createChildSprite(),
					a = Number(i[t]);
				e.setFrame(a * s, r * n, s, n),
					(e.x = (t - (i.length - 1) / 2) * s),
					(e.dy = -t);
			}
		}
		createChildSprite() {
			const t = new Sprite();
			return (
				(t.bitmap = this._damageBitmap),
				(t.anchor.x = 0.5),
				(t.anchor.y = 1),
				(t.y = -40),
				(t.ry = t.y),
				this.addChild(t),
				t
			);
		}
		update() {
			if ((super.update(), this._duration > 0)) {
				this._duration--;
				for (let t = 0; t < this.children.length; t++)
					this.updateChild(this.children[t]);
			}
			this.updateFlash(), this.updateOpacity();
		}
		updateChild(t) {
			(t.dy += 0.5),
				(t.ry += t.dy),
				t.ry >= 0 && ((t.ry = 0), (t.dy *= -0.6)),
				(t.y = Math.round(t.ry)),
				t.setBlendColor(this._flashColor);
		}
		updateFlash() {
			if (this._flashDuration > 0) {
				const t = this._flashDuration--;
				this._flashColor[3] *= (t - 1) / t;
			}
		}
		updateOpacity() {
			this._duration < 10 && (this.opacity = (255 * this._duration) / 10);
		}
		isPlaying() {
			return this._duration > 0;
		}
	}
	class Sprite_Battler extends Sprite_Base {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t) {
			super.initialize(), this.initMembers(), this.setBattler(t);
		}
		initMembers() {
			(this.anchor.x = 0.5),
				(this.anchor.y = 1),
				(this._battler = null),
				(this._damages = []),
				(this._homeX = 0),
				(this._homeY = 0),
				(this._offsetX = 0),
				(this._offsetY = 0),
				(this._targetOffsetX = NaN),
				(this._targetOffsetY = NaN),
				(this._movementDuration = 0),
				(this._selectionEffectCount = 0);
		}
		setBattler(t) {
			this._battler = t;
		}
		setHome(t, e) {
			(this._homeX = t), (this._homeY = e), this.updatePosition();
		}
		update() {
			super.update(),
				this._battler
					? (this.updateMain(),
					  this.updateAnimation(),
					  this.updateDamagePopup(),
					  this.updateSelectionEffect())
					: (this.bitmap = null);
		}
		updateVisibility() {
			super.updateVisibility(),
				(this._battler && this._battler.isSpriteVisible()) ||
					(this.visible = !1);
		}
		updateMain() {
			this._battler.isSpriteVisible() &&
				(this.updateBitmap(), this.updateFrame()),
				this.updateMove(),
				this.updatePosition();
		}
		updateBitmap() {}
		updateFrame() {}
		updateMove() {
			if (this._movementDuration > 0) {
				const t = this._movementDuration;
				(this._offsetX = (this._offsetX * (t - 1) + this._targetOffsetX) / t),
					(this._offsetY = (this._offsetY * (t - 1) + this._targetOffsetY) / t),
					this._movementDuration--,
					0 === this._movementDuration && this.onMoveEnd();
			}
		}
		updatePosition() {
			(this.x = this._homeX + this._offsetX),
				(this.y = this._homeY + this._offsetY);
		}
		updateAnimation() {
			this.setupAnimation();
		}
		updateDamagePopup() {
			if ((this.setupDamagePopup(), this._damages.length > 0)) {
				for (let t = 0; t < this._damages.length; t++)
					this._damages[t].update();
				this._damages[0].isPlaying() ||
					(this.parent.removeChild(this._damages[0]), this._damages.shift());
			}
		}
		updateSelectionEffect() {
			const t = this._effectTarget;
			this._battler.isSelected()
				? (this._selectionEffectCount++,
				  this._selectionEffectCount % 30 < 15
						? t.setBlendColor([255, 255, 255, 64])
						: t.setBlendColor([0, 0, 0, 0]))
				: this._selectionEffectCount > 0 &&
				  ((this._selectionEffectCount = 0), t.setBlendColor([0, 0, 0, 0]));
		}
		setupAnimation() {
			for (; this._battler.isAnimationRequested(); ) {
				const t = this._battler.shiftAnimation(),
					e = self.$dataAnimations[t.animationId],
					i = t.mirror,
					r = 3 === e.position ? 0 : t.delay;
				this.startAnimation(e, i, r);
				for (const t of this._animationSprites)
					t.visible = this._battler.isSpriteVisible();
			}
		}
		setupDamagePopup() {
			if (this._battler.isDamagePopupRequested()) {
				if (this._battler.isSpriteVisible()) {
					const t = new Sprite_Damage();
					(t.x = this.x + this.damageOffsetX()),
						(t.y = this.y + this.damageOffsetY()),
						t.setup(this._battler),
						this._damages.push(t),
						this.parent.addChild(t);
				}
				this._battler.clearDamagePopup(), this._battler.clearResult();
			}
		}
		damageOffsetX() {
			return 0;
		}
		damageOffsetY() {
			return 0;
		}
		startMove(t, e, i) {
			(this._targetOffsetX === t && this._targetOffsetY === e) ||
				((this._targetOffsetX = t),
				(this._targetOffsetY = e),
				(this._movementDuration = i),
				0 === i && ((this._offsetX = t), (this._offsetY = e)));
		}
		onMoveEnd() {}
		isEffecting() {
			return !1;
		}
		isMoving() {
			return this._movementDuration > 0;
		}
		inHomePosition() {
			return 0 === this._offsetX && 0 === this._offsetY;
		}
	}
	class Sprite_StateIcon extends Sprite {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize(), this.initMembers(), this.loadBitmap();
		}
		initMembers() {
			(this._battler = null),
				(this._iconIndex = 0),
				(this._animationCount = 0),
				(this._animationIndex = 0),
				(this.anchor.x = 0.5),
				(this.anchor.y = 0.5);
		}
		loadBitmap() {
			(this.bitmap = ImageManager.loadSystem('IconSet')),
				this.setFrame(0, 0, 0, 0);
		}
		setup(t) {
			this._battler = t;
		}
		update() {
			super.update(),
				this._animationCount++,
				this._animationCount >= this.animationWait() &&
					(this.updateIcon(), this.updateFrame(), (this._animationCount = 0));
		}
		animationWait() {
			return 40;
		}
		updateIcon() {
			let t = [];
			this._battler &&
				this._battler.isAlive() &&
				(t = this._battler.allIcons()),
				t.length > 0
					? (this._animationIndex++,
					  this._animationIndex >= t.length && (this._animationIndex = 0),
					  (this._iconIndex = t[this._animationIndex]))
					: ((this._animationIndex = 0), (this._iconIndex = 0));
		}
		updateFrame() {
			const t = Sprite_StateIcon._iconWidth,
				e = Sprite_StateIcon._iconHeight,
				i = (this._iconIndex % 16) * t,
				r = Math.floor(this._iconIndex / 16) * e;
			this.setFrame(i, r, t, e);
		}
	}
	(Sprite_StateIcon._iconWidth = 32), (Sprite_StateIcon._iconHeight = 32);
	class Sprite_Enemy extends Sprite_Battler {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t) {
			super.initialize(t);
		}
		initMembers() {
			super.initMembers(),
				(this._enemy = null),
				(this._appeared = !1),
				(this._battlerName = ''),
				(this._battlerHue = 0),
				(this._effectType = null),
				(this._effectDuration = 0),
				(this._shake = 0),
				this.createStateIconSprite();
		}
		createStateIconSprite() {
			(this._stateIconSprite = new Sprite_StateIcon()),
				this.addChild(this._stateIconSprite);
		}
		setBattler(t) {
			super.setBattler(t),
				(this._enemy = t),
				this.setHome(t.screenX(), t.screenY()),
				this._stateIconSprite.setup(t);
		}
		update() {
			super.update(),
				this._enemy && (this.updateEffect(), this.updateStateSprite());
		}
		updateBitmap() {
			super.updateBitmap();
			const t = this._enemy.battlerName(),
				e = this._enemy.battlerHue();
			(this._battlerName === t && this._battlerHue === e) ||
				((this._battlerName = t),
				(this._battlerHue = e),
				this.loadBitmap(t, e),
				this.initVisibility());
		}
		loadBitmap(t, e) {
			self.$gameSystem.isSideView()
				? (this.bitmap = ImageManager.loadSvEnemy(t, e))
				: (this.bitmap = ImageManager.loadEnemy(t, e));
		}
		updateFrame() {
			super.updateFrame();
			let t = this.bitmap.height;
			'bossCollapse' === this._effectType && (t = this._effectDuration),
				this.setFrame(0, 0, this.bitmap.width, t);
		}
		updatePosition() {
			super.updatePosition(), (this.x += this._shake);
		}
		updateStateSprite() {
			(this._stateIconSprite.y = -Math.round(0.9 * (this.bitmap.height + 40))),
				this._stateIconSprite.y < 20 - this.y &&
					(this._stateIconSprite.y = 20 - this.y);
		}
		initVisibility() {
			(this._appeared = this._enemy.isAlive()),
				this._appeared || (this.opacity = 0);
		}
		setupEffect() {
			this._appeared &&
				this._enemy.isEffectRequested() &&
				(this.startEffect(this._enemy.effectType()), this._enemy.clearEffect()),
				!this._appeared && this._enemy.isAlive()
					? this.startEffect('appear')
					: this._appeared &&
					  this._enemy.isHidden() &&
					  this.startEffect('disappear');
		}
		startEffect(t) {
			switch (((this._effectType = t), this._effectType)) {
				case 'appear':
					this.startAppear();
					break;
				case 'disappear':
					this.startDisappear();
					break;
				case 'whiten':
					this.startWhiten();
					break;
				case 'blink':
					this.startBlink();
					break;
				case 'collapse':
					this.startCollapse();
					break;
				case 'bossCollapse':
					this.startBossCollapse();
					break;
				case 'instantCollapse':
					this.startInstantCollapse();
			}
			this.revertToNormal();
		}
		startAppear() {
			(this._effectDuration = 16), (this._appeared = !0);
		}
		startDisappear() {
			(this._effectDuration = 32), (this._appeared = !1);
		}
		startWhiten() {
			this._effectDuration = 16;
		}
		startBlink() {
			this._effectDuration = 20;
		}
		startCollapse() {
			(this._effectDuration = 32), (this._appeared = !1);
		}
		startBossCollapse() {
			(this._effectDuration = this.bitmap.height), (this._appeared = !1);
		}
		startInstantCollapse() {
			(this._effectDuration = 16), (this._appeared = !1);
		}
		updateEffect() {
			if ((this.setupEffect(), this._effectDuration > 0)) {
				switch ((this._effectDuration--, this._effectType)) {
					case 'whiten':
						this.updateWhiten();
						break;
					case 'blink':
						this.updateBlink();
						break;
					case 'appear':
						this.updateAppear();
						break;
					case 'disappear':
						this.updateDisappear();
						break;
					case 'collapse':
						this.updateCollapse();
						break;
					case 'bossCollapse':
						this.updateBossCollapse();
						break;
					case 'instantCollapse':
						this.updateInstantCollapse();
				}
				0 === this._effectDuration && (this._effectType = null);
			}
		}
		isEffecting() {
			return null !== this._effectType;
		}
		revertToNormal() {
			(this._shake = 0),
				(this.blendMode = 0),
				(this.opacity = 255),
				this.setBlendColor([0, 0, 0, 0]);
		}
		updateWhiten() {
			const t = 128 - 10 * (16 - this._effectDuration);
			this.setBlendColor([255, 255, 255, t]);
		}
		updateBlink() {
			this.opacity = this._effectDuration % 10 < 5 ? 255 : 0;
		}
		updateAppear() {
			this.opacity = 16 * (16 - this._effectDuration);
		}
		updateDisappear() {
			this.opacity = 256 - 10 * (32 - this._effectDuration);
		}
		updateCollapse() {
			(this.blendMode = Graphics.BLEND_ADD),
				this.setBlendColor([255, 128, 128, 128]),
				(this.opacity *= this._effectDuration / (this._effectDuration + 1));
		}
		updateBossCollapse() {
			(this._shake = (this._effectDuration % 2) * 4 - 2),
				(this.blendMode = Graphics.BLEND_ADD),
				(this.opacity *= this._effectDuration / (this._effectDuration + 1)),
				this.setBlendColor([255, 255, 255, 255 - this.opacity]),
				this._effectDuration % 20 == 19 && SoundManager.playBossCollapse2();
		}
		updateInstantCollapse() {
			this.opacity = 0;
		}
		damageOffsetX() {
			return 0;
		}
		damageOffsetY() {
			return -8;
		}
	}
	class Sprite_Weapon extends Sprite_Base {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize(), this.initMembers();
		}
		initMembers() {
			(this._weaponImageId = 0),
				(this._animationCount = 0),
				(this._pattern = 0),
				(this.anchor.x = 0.5),
				(this.anchor.y = 1),
				(this.x = -16);
		}
		setup(t) {
			(this._weaponImageId = t),
				(this._animationCount = 0),
				(this._pattern = 0),
				this.loadBitmap(),
				this.updateFrame();
		}
		update() {
			super.update(),
				this._animationCount++,
				this._animationCount >= this.animationWait() &&
					(this.updatePattern(),
					this.updateFrame(),
					(this._animationCount = 0));
		}
		animationWait() {
			return 12;
		}
		updatePattern() {
			this._pattern++, this._pattern >= 3 && (this._weaponImageId = 0);
		}
		loadBitmap() {
			const t = Math.floor((this._weaponImageId - 1) / 12) + 1;
			this.bitmap =
				t >= 1
					? ImageManager.loadSystem(`Weapons${t}`)
					: ImageManager.loadSystem('');
		}
		updateFrame() {
			if (this._weaponImageId > 0) {
				const t = (this._weaponImageId - 1) % 12,
					e = 96,
					i = 64,
					r = (3 * Math.floor(t / 6) + this._pattern) * e,
					s = Math.floor(t % 6) * i;
				this.setFrame(r, s, e, i);
			} else this.setFrame(0, 0, 0, 0);
		}
		isPlaying() {
			return this._weaponImageId > 0;
		}
	}
	class Sprite_StateOverlay extends Sprite_Base {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize(), this.initMembers(), this.loadBitmap();
		}
		initMembers() {
			(this._battler = null),
				(this._overlayIndex = 0),
				(this._animationCount = 0),
				(this._pattern = 0),
				(this.anchor.x = 0.5),
				(this.anchor.y = 1);
		}
		loadBitmap() {
			(this.bitmap = ImageManager.loadSystem('States')),
				this.setFrame(0, 0, 0, 0);
		}
		setup(t) {
			this._battler = t;
		}
		update() {
			super.update(),
				this._animationCount++,
				this._animationCount >= this.animationWait() &&
					(this.updatePattern(),
					this.updateFrame(),
					(this._animationCount = 0));
		}
		animationWait() {
			return 8;
		}
		updatePattern() {
			this._pattern++,
				(this._pattern %= 8),
				this._battler &&
					(this._overlayIndex = this._battler.stateOverlayIndex());
		}
		updateFrame() {
			if (this._overlayIndex > 0) {
				const t = 96,
					e = 96,
					i = this._pattern * t,
					r = (this._overlayIndex - 1) * e;
				this.setFrame(i, r, t, e);
			} else this.setFrame(0, 0, 0, 0);
		}
	}
	class Sprite_Actor extends Sprite_Battler {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t) {
			super.initialize(t), this.moveToStartPosition();
		}
		initMembers() {
			super.initMembers(),
				(this._battlerName = ''),
				(this._motion = null),
				(this._motionCount = 0),
				(this._pattern = 0),
				this.createShadowSprite(),
				this.createWeaponSprite(),
				this.createMainSprite(),
				this.createStateSprite();
		}
		createMainSprite() {
			(this._mainSprite = new Sprite_Base()),
				(this._mainSprite.anchor.x = 0.5),
				(this._mainSprite.anchor.y = 1),
				this.addChild(this._mainSprite),
				(this._effectTarget = this._mainSprite);
		}
		createShadowSprite() {
			(this._shadowSprite = new Sprite()),
				(this._shadowSprite.bitmap = ImageManager.loadSystem('Shadow2')),
				(this._shadowSprite.anchor.x = 0.5),
				(this._shadowSprite.anchor.y = 0.5),
				(this._shadowSprite.y = -2),
				this.addChild(this._shadowSprite);
		}
		createWeaponSprite() {
			(this._weaponSprite = new Sprite_Weapon()),
				this.addChild(this._weaponSprite);
		}
		createStateSprite() {
			(this._stateSprite = new Sprite_StateOverlay()),
				this.addChild(this._stateSprite);
		}
		setBattler(t) {
			super.setBattler(t),
				t !== this._actor &&
					((this._actor = t),
					t && this.setActorHome(t.index()),
					this.startEntryMotion(),
					this._stateSprite.setup(t));
		}
		moveToStartPosition() {
			this.startMove(300, 0, 0);
		}
		setActorHome(t) {
			this.setHome(600 + 32 * t, 280 + 48 * t);
		}
		update() {
			super.update(), this.updateShadow(), this._actor && this.updateMotion();
		}
		updateShadow() {
			this._shadowSprite.visible = !!this._actor;
		}
		updateMain() {
			super.updateMain(),
				this._actor.isSpriteVisible() &&
					!this.isMoving() &&
					this.updateTargetPosition();
		}
		setupMotion() {
			this._actor.isMotionRequested() &&
				(this.startMotion(this._actor.motionType()), this._actor.clearMotion());
		}
		setupWeaponAnimation() {
			this._actor.isWeaponAnimationRequested() &&
				(this._weaponSprite.setup(this._actor.weaponImageId()),
				this._actor.clearWeaponAnimation());
		}
		startMotion(t) {
			const e = Sprite_Actor.MOTIONS[t];
			this._motion !== e &&
				((this._motion = e), (this._motionCount = 0), (this._pattern = 0));
		}
		updateTargetPosition() {
			this._actor.isInputting() || this._actor.isActing()
				? this.stepForward()
				: this._actor.canMove() && BattleManager.isEscaped()
				? this.retreat()
				: this.inHomePosition() || this.stepBack();
		}
		updateBitmap() {
			super.updateBitmap();
			const t = this._actor.battlerName();
			this._battlerName !== t &&
				((this._battlerName = t),
				(this._mainSprite.bitmap = ImageManager.loadSvActor(t)));
		}
		updateFrame() {
			super.updateFrame();
			const t = this._mainSprite.bitmap;
			if (t) {
				const e = this._motion ? this._motion.index : 0,
					i = this._pattern < 3 ? this._pattern : 1,
					r = t.width / 9,
					s = t.height / 6,
					n = 3 * Math.floor(e / 6) + i,
					a = e % 6;
				this._mainSprite.setFrame(n * r, a * s, r, s);
			}
		}
		updateMove() {
			const t = this._mainSprite.bitmap;
			(t && !t.isReady()) || super.updateMove();
		}
		updateMotion() {
			this.setupMotion(),
				this.setupWeaponAnimation(),
				this._actor.isMotionRefreshRequested() &&
					(this.refreshMotion(), this._actor.clearMotion()),
				this.updateMotionCount();
		}
		updateMotionCount() {
			this._motion &&
				++this._motionCount >= this.motionSpeed() &&
				(this._motion.loop
					? (this._pattern = (this._pattern + 1) % 4)
					: this._pattern < 2
					? this._pattern++
					: this.refreshMotion(),
				(this._motionCount = 0));
		}
		motionSpeed() {
			return 12;
		}
		refreshMotion() {
			const t = this._actor,
				e = Sprite_Actor.MOTIONS.guard;
			if (t) {
				if (this._motion === e && !BattleManager.isInputting()) return;
				const i = t.stateMotionIndex();
				t.isInputting() || t.isActing()
					? this.startMotion('walk')
					: 3 === i
					? this.startMotion('dead')
					: 2 === i
					? this.startMotion('sleep')
					: t.isChanting()
					? this.startMotion('chant')
					: t.isGuard() || t.isGuardWaiting()
					? this.startMotion('guard')
					: 1 === i
					? this.startMotion('abnormal')
					: t.isDying()
					? this.startMotion('dying')
					: t.isUndecided()
					? this.startMotion('walk')
					: this.startMotion('wait');
			}
		}
		startEntryMotion() {
			this._actor && this._actor.canMove()
				? (this.startMotion('walk'), this.startMove(0, 0, 30))
				: this.isMoving() || (this.refreshMotion(), this.startMove(0, 0, 0));
		}
		stepForward() {
			this.startMove(-48, 0, 12);
		}
		stepBack() {
			this.startMove(0, 0, 12);
		}
		retreat() {
			this.startMove(300, 0, 30);
		}
		onMoveEnd() {
			super.onMoveEnd(), BattleManager.isBattleEnd() || this.refreshMotion();
		}
		damageOffsetX() {
			return -32;
		}
		damageOffsetY() {
			return 0;
		}
	}
	Sprite_Actor.MOTIONS = {
		walk: { index: 0, loop: !0 },
		wait: { index: 1, loop: !0 },
		chant: { index: 2, loop: !0 },
		guard: { index: 3, loop: !0 },
		damage: { index: 4, loop: !1 },
		evade: { index: 5, loop: !1 },
		thrust: { index: 6, loop: !1 },
		swing: { index: 7, loop: !1 },
		missile: { index: 8, loop: !1 },
		skill: { index: 9, loop: !1 },
		spell: { index: 10, loop: !1 },
		item: { index: 11, loop: !1 },
		escape: { index: 12, loop: !0 },
		victory: { index: 13, loop: !0 },
		dying: { index: 14, loop: !0 },
		abnormal: { index: 15, loop: !0 },
		sleep: { index: 16, loop: !0 },
		dead: { index: 17, loop: !0 },
	};
	class Spriteset_Battle extends Spriteset_Base {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize(), (this._battlebackLocated = !1);
		}
		createLowerLayer() {
			super.createLowerLayer(),
				this.createBackground(),
				this.createBattleField(),
				this.createBattleback(),
				this.createEnemies(),
				this.createActors();
		}
		createBackground() {
			(this._backgroundSprite = new Sprite()),
				(this._backgroundSprite.bitmap = SceneManager.backgroundBitmap()),
				this._baseSprite.addChild(this._backgroundSprite);
		}
		update() {
			super.update(), this.updateActors(), this.updateBattleback();
		}
		createBattleField() {
			const t = Graphics.boxWidth,
				e = Graphics.boxHeight,
				i = (Graphics.width - t) / 2,
				r = (Graphics.height - e) / 2;
			(this._battleField = new Sprite()),
				this._battleField.setFrame(i, r, t, e),
				(this._battleField.x = i),
				(this._battleField.y = r),
				this._baseSprite.addChild(this._battleField);
		}
		createBattleback() {
			const t = -this._battleField.x - 32,
				e = -this._battleField.y - 32,
				i = Graphics.width + 64,
				r = Graphics.height + 64;
			(this._back1Sprite = new TilingSprite()),
				(this._back2Sprite = new TilingSprite()),
				(this._back1Sprite.bitmap = this.battleback1Bitmap()),
				(this._back2Sprite.bitmap = this.battleback2Bitmap()),
				this._back1Sprite.move(t, e, i, r),
				this._back2Sprite.move(t, e, i, r),
				this._battleField.addChild(this._back1Sprite),
				this._battleField.addChild(this._back2Sprite);
		}
		updateBattleback() {
			this._battlebackLocated ||
				(this.locateBattleback(), (this._battlebackLocated = !0));
		}
		locateBattleback() {
			const t = this._battleField.width,
				e = this._battleField.height,
				i = this._back1Sprite,
				r = this._back2Sprite;
			(i.origin.x = i.x + (i.bitmap.width - t) / 2),
				(r.origin.x = i.y + (r.bitmap.width - t) / 2),
				self.$gameSystem.isSideView() &&
					((i.origin.y = i.x + i.bitmap.height - e),
					(r.origin.y = i.y + r.bitmap.height - e));
		}
		battleback1Bitmap() {
			return ImageManager.loadBattleback1(this.battleback1Name());
		}
		battleback2Bitmap() {
			return ImageManager.loadBattleback2(this.battleback2Name());
		}
		battleback1Name() {
			return BattleManager.isBattleTest()
				? self.$dataSystem.battleback1Name
				: self.$gameMap.battleback1Name()
				? self.$gameMap.battleback1Name()
				: self.$gameMap.isOverworld()
				? this.overworldBattleback1Name()
				: '';
		}
		battleback2Name() {
			return BattleManager.isBattleTest()
				? self.$dataSystem.battleback2Name
				: self.$gameMap.battleback2Name()
				? self.$gameMap.battleback2Name()
				: self.$gameMap.isOverworld()
				? this.overworldBattleback2Name()
				: '';
		}
		overworldBattleback1Name() {
			return '' === self.$gameMap.battleback1Name()
				? ''
				: self.$gamePlayer.isInVehicle()
				? this.shipBattleback1Name()
				: this.normalBattleback1Name();
		}
		overworldBattleback2Name() {
			return '' === self.$gameMap.battleback2Name()
				? ''
				: self.$gamePlayer.isInVehicle()
				? this.shipBattleback2Name()
				: this.normalBattleback2Name();
		}
		normalBattleback1Name() {
			return (
				this.terrainBattleback1Name(this.autotileType(1)) ||
				this.terrainBattleback1Name(this.autotileType(0)) ||
				this.defaultBattleback1Name()
			);
		}
		normalBattleback2Name() {
			return (
				this.terrainBattleback2Name(this.autotileType(1)) ||
				this.terrainBattleback2Name(this.autotileType(0)) ||
				this.defaultBattleback2Name()
			);
		}
		terrainBattleback1Name(t) {
			switch (t) {
				case 24:
				case 25:
					return 'Wasteland';
				case 26:
				case 27:
					return 'DirtField';
				case 32:
				case 33:
					return 'Desert';
				case 34:
					return 'Lava1';
				case 35:
					return 'Lava2';
				case 40:
				case 41:
					return 'Snowfield';
				case 42:
					return 'Clouds';
				case 4:
				case 5:
					return 'PoisonSwamp';
				default:
					return null;
			}
		}
		terrainBattleback2Name(t) {
			switch (t) {
				case 20:
				case 21:
					return 'Forest';
				case 22:
				case 30:
				case 38:
					return 'Cliff';
				case 24:
				case 25:
				case 26:
				case 27:
					return 'Wasteland';
				case 32:
				case 33:
					return 'Desert';
				case 34:
				case 35:
					return 'Lava';
				case 40:
				case 41:
					return 'Snowfield';
				case 42:
					return 'Clouds';
				case 4:
				case 5:
					return 'PoisonSwamp';
			}
		}
		defaultBattleback1Name() {
			return 'Grassland';
		}
		defaultBattleback2Name() {
			return 'Grassland';
		}
		shipBattleback1Name() {
			return 'Ship';
		}
		shipBattleback2Name() {
			return 'Ship';
		}
		autotileType(t) {
			return self.$gameMap.autotileType(
				self.$gamePlayer.x,
				self.$gamePlayer.y,
				t
			);
		}
		createEnemies() {
			const t = self.$gameTroop.members(),
				e = [];
			for (let i = 0; i < t.length; i++) e[i] = new Sprite_Enemy(t[i]);
			e.sort(this.compareEnemySprite.bind(this));
			for (let t = 0; t < e.length; t++) this._battleField.addChild(e[t]);
			this._enemySprites = e;
		}
		compareEnemySprite(t, e) {
			return t.y !== e.y ? t.y - e.y : t.spriteId - e.spriteId;
		}
		createActors() {
			this._actorSprites = [];
			for (let t = 0; t < self.$gameParty.maxBattleMembers(); t++)
				(this._actorSprites[t] = new Sprite_Actor()),
					this._battleField.addChild(this._actorSprites[t]);
		}
		updateActors() {
			const t = self.$gameParty.battleMembers();
			for (let e = 0; e < this._actorSprites.length; e++)
				this._actorSprites[e].setBattler(t[e]);
		}
		battlerSprites() {
			return this._enemySprites.concat(this._actorSprites);
		}
		isAnimationPlaying() {
			return this.battlerSprites().some((t) => t.isAnimationPlaying());
		}
		isEffecting() {
			return this.battlerSprites().some((t) => t.isEffecting());
		}
		isAnyoneMoving() {
			return this.battlerSprites().some((t) => t.isMoving());
		}
		isBusy() {
			return this.isAnimationPlaying() || this.isAnyoneMoving();
		}
	}
	class Window_Base extends Window {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e, i, r) {
			super.initialize(),
				this.loadWindowskin(),
				this.move(t, e, i, r),
				this.updatePadding(),
				this.updateBackOpacity(),
				this.updateTone(),
				this.createContents(),
				(this._opening = !1),
				(this._closing = !1),
				(this._dimmerSprite = null);
		}
		lineHeight() {
			return 36;
		}
		standardFontFace() {
			return self.$gameSystem.isChinese()
				? 'SimHei, Heiti TC, sans-serif'
				: self.$gameSystem.isKorean()
				? 'Dotum, AppleGothic, sans-serif'
				: 'GameFont';
		}
		standardFontSize() {
			return 28;
		}
		standardPadding() {
			return 18;
		}
		textPadding() {
			return 6;
		}
		standardBackOpacity() {
			return 192;
		}
		loadWindowskin() {
			this.windowskin = ImageManager.loadSystem('Window');
		}
		updatePadding() {
			this.padding = this.standardPadding();
		}
		updateBackOpacity() {
			this.backOpacity = this.standardBackOpacity();
		}
		contentsWidth() {
			return this.width - 2 * this.standardPadding();
		}
		contentsHeight() {
			return this.height - 2 * this.standardPadding();
		}
		fittingHeight(t) {
			return t * this.lineHeight() + 2 * this.standardPadding();
		}
		updateTone() {
			const t = self.$gameSystem.windowTone();
			this.setTone(t[0], t[1], t[2]);
		}
		createContents() {
			this.contents
				? this.contents.clear()
				: ((this.contents = new BitmapPIXI(
						this.contentsWidth(),
						this.contentsHeight()
				  )),
				  this._windowContentsSprite.addChild(this.contents)),
				this.resetFontSettings();
		}
		resetFontSettings() {
			(this.contents.fontFace = this.standardFontFace()),
				(this.contents.fontSize = this.standardFontSize()),
				this.resetTextColor();
		}
		resetTextColor() {
			this.changeTextColor(this.normalColor());
		}
		update() {
			super.update(),
				this.updateTone(),
				this.updateOpen(),
				this.updateClose(),
				this.updateBackgroundDimmer();
		}
		updateOpen() {
			this._opening &&
				((this.openness += 32), this.isOpen() && (this._opening = !1));
		}
		updateClose() {
			this._closing &&
				((this.openness -= 32), this.isClosed() && (this._closing = !1));
		}
		open() {
			this.isOpen() || (this._opening = !0), (this._closing = !1);
		}
		close() {
			this.isClosed() || (this._closing = !0), (this._opening = !1);
		}
		isOpening() {
			return this._opening;
		}
		isClosing() {
			return this._closing;
		}
		show() {
			this.visible = !0;
		}
		hide() {
			this.visible = !1;
		}
		activate() {
			this.active = !0;
		}
		deactivate() {
			this.active = !1;
		}
		textColor(t) {
			const e = 96 + (t % 8) * 12 + 6,
				i = 144 + 12 * Math.floor(t / 8) + 6;
			return this.windowskin ? this.windowskin.getPixel(e, i) : '0x000000';
		}
		normalColor() {
			return this.textColor(0);
		}
		systemColor() {
			return this.textColor(16);
		}
		crisisColor() {
			return this.textColor(17);
		}
		deathColor() {
			return this.textColor(18);
		}
		gaugeBackColor() {
			return this.textColor(19);
		}
		hpGaugeColor1() {
			return this.textColor(20);
		}
		hpGaugeColor2() {
			return this.textColor(21);
		}
		mpGaugeColor1() {
			return this.textColor(22);
		}
		mpGaugeColor2() {
			return this.textColor(23);
		}
		mpCostColor() {
			return this.textColor(23);
		}
		powerUpColor() {
			return this.textColor(24);
		}
		powerDownColor() {
			return this.textColor(25);
		}
		tpGaugeColor1() {
			return this.textColor(28);
		}
		tpGaugeColor2() {
			return this.textColor(29);
		}
		tpCostColor() {
			return this.textColor(29);
		}
		pendingColor() {
			return this.windowskin.getPixel(120, 120);
		}
		translucentOpacity() {
			return 160;
		}
		changeTextColor(t) {
			this.contents.textColor = t;
		}
		changePaintOpacity(t) {
			this.contents.paintOpacity = t ? 255 : this.translucentOpacity();
		}
		drawText(t, e, i, r, s) {
			this.contents.drawText(t, e, i, r, this.lineHeight(), s);
		}
		textWidth(t) {
			return this.contents.measureTextWidth(t);
		}
		drawTextEx(t, e, i) {
			if (t) {
				const r = { index: 0, x: e, y: i, left: e };
				for (
					r.text = this.convertEscapeCharacters(t),
						r.height = this.calcTextHeight(r, !1),
						this.resetFontSettings();
					r.index < r.text.length;

				)
					this.processCharacter(r);
				return r.x - e;
			}
			return 0;
		}
		convertEscapeCharacters(t) {
			return (t = (t = (t = (t = (t = (t = t.replace(/\\/g, '')).replace(
				/\x1b\x1b/g,
				'\\'
			)).replace(
				/\x1bV\[(\d+)\]/gi,
				function (...t) {
					return self.$gameVariables.value(parseInt(t[1]));
				}.bind(this)
			)).replace(
				/\x1bV\[(\d+)\]/gi,
				function (...t) {
					return self.$gameVariables.value(parseInt(t[1]));
				}.bind(this)
			)).replace(
				/\x1bN\[(\d+)\]/gi,
				function (...t) {
					return this.actorName(parseInt(t[1]));
				}.bind(this)
			)).replace(
				/\x1bP\[(\d+)\]/gi,
				function (...t) {
					return this.partyMemberName(parseInt(t[1]));
				}.bind(this)
			)).replace(/\x1bG/gi, TextManager.currencyUnit);
		}
		actorName(t) {
			const e = t >= 1 ? self.$gameActors.actor(t) : null;
			return e ? e.name() : '';
		}
		partyMemberName(t) {
			const e = t >= 1 ? self.$gameParty.members()[t - 1] : null;
			return e ? e.name() : '';
		}
		processCharacter(t) {
			switch (t.text[t.index]) {
				case '\n':
					this.processNewLine(t);
					break;
				case '\f':
					this.processNewPage(t);
					break;
				case '':
					this.processEscapeCharacter(this.obtainEscapeCode(t), t);
					break;
				default:
					this.processNormalCharacter(t);
			}
		}
		processNormalCharacter(t) {
			const e = t.text[t.index++],
				i = this.textWidth(e);
			this.contents.drawText(e, t.x, t.y, 2 * i, t.height), (t.x += i);
		}
		processNewLine(t) {
			(t.x = t.left),
				(t.y += t.height),
				(t.height = this.calcTextHeight(t, !1)),
				t.index++;
		}
		processNewPage(t) {
			t.index++;
		}
		obtainEscapeCode(t) {
			t.index++;
			const e = /^[\$\.\|\^!><\{\}\\]|^[A-Z]+/i.exec(t.text.slice(t.index));
			return e ? ((t.index += e[0].length), e[0].toUpperCase()) : '';
		}
		obtainEscapeParam(t) {
			const e = /^\[\d+\]/.exec(t.text.slice(t.index));
			return e ? ((t.index += e[0].length), parseInt(e[0].slice(1))) : '';
		}
		processEscapeCharacter(t, e) {
			switch (t) {
				case 'C':
					this.changeTextColor(this.textColor(this.obtainEscapeParam(e)));
					break;
				case 'I':
					this.processDrawIcon(this.obtainEscapeParam(e), e);
					break;
				case '{':
					this.makeFontBigger();
					break;
				case '}':
					this.makeFontSmaller();
			}
		}
		processDrawIcon(t, e) {
			this.drawIcon(t, e.x + 2, e.y + 2), (e.x += Window_Base._iconWidth + 4);
		}
		makeFontBigger() {
			this.contents.fontSize <= 96 && (this.contents.fontSize += 12);
		}
		makeFontSmaller() {
			this.contents.fontSize >= 24 && (this.contents.fontSize -= 12);
		}
		calcTextHeight({ text: t, index: e }, i) {
			const r = this.contents.fontSize;
			let s = 0;
			const n = t.slice(e).split('\n'),
				a = i ? n.length : 1;
			for (let t = 0; t < a; t++) {
				let e = this.contents.fontSize;
				const i = /\x1b[\{\}]/g;
				for (;;) {
					const r = i.exec(n[t]);
					if (!r) break;
					'{' === r[0] && this.makeFontBigger(),
						'}' === r[0] && this.makeFontSmaller(),
						e < this.contents.fontSize && (e = this.contents.fontSize);
				}
				s += e + 8;
			}
			return (this.contents.fontSize = r), s;
		}
		drawIcon(t, e, i) {
			const r = ImageManager.loadSystem('IconSet'),
				s = Window_Base._iconWidth,
				n = Window_Base._iconHeight,
				a = (t % 16) * s,
				o = Math.floor(t / 16) * n;
			this.contents.blt(r, a, o, s, n, e, i);
		}
		drawFace(
			t,
			e,
			i,
			r,
			s = Window_Base._faceWidth,
			n = Window_Base._faceHeight
		) {
			const a = ImageManager.loadFace(t),
				o = Window_Base._faceWidth,
				h = Window_Base._faceHeight,
				u = Math.min(s, o),
				l = Math.min(n, h),
				c = Math.floor(i + Math.max(s - o, 0) / 2),
				d = Math.floor(r + Math.max(n - h, 0) / 2),
				p = (e % 4) * o + (o - u) / 2,
				f = Math.floor(e / 4) * h + (h - l) / 2;
			this.contents.blt(a, p, f, u, l, c, d);
		}
		drawCharacter(t, e, i, r) {
			const s = ImageManager.loadCharacter(t),
				n = ImageManager.isBigCharacter(t),
				a = s.width / (n ? 3 : 12),
				o = s.height / (n ? 4 : 8),
				h = n ? 0 : e,
				u = ((h % 4) * 3 + 1) * a,
				l = 4 * Math.floor(h / 4) * o;
			this.contents.blt(s, u, l, a, o, i - a / 2, r - o);
		}
		drawGauge(t, e, i, r, s, n) {
			const a = Math.floor(i * r),
				o = e + this.lineHeight() - 8;
			this.contents.fillRect(t, o, i, 6, this.gaugeBackColor()),
				this.contents.gradientFillRect(t, o, a, 6, s, n);
		}
		hpColor(t) {
			return t.isDead()
				? this.deathColor()
				: t.isDying()
				? this.crisisColor()
				: this.normalColor();
		}
		mpColor(t) {
			return this.normalColor();
		}
		tpColor(t) {
			return this.normalColor();
		}
		drawActorCharacter(t, e, i) {
			this.drawCharacter(t.characterName(), t.characterIndex(), e, i);
		}
		drawActorFace(t, e, i, r, s) {
			this.drawFace(t.faceName(), t.faceIndex(), e, i, r, s);
		}
		drawActorName(t, e, i, r = 168) {
			this.changeTextColor(this.hpColor(t)), this.drawText(t.name(), e, i, r);
		}
		drawActorClass(t, e, i, r = 168) {
			this.resetTextColor(), this.drawText(t.currentClass().name, e, i, r);
		}
		drawActorNickname(t, e, i, r = 270) {
			this.resetTextColor(), this.drawText(t.nickname(), e, i, r);
		}
		drawActorLevel({ level: t }, e, i) {
			this.changeTextColor(this.systemColor()),
				this.drawText(TextManager.levelA, e, i, 48),
				this.resetTextColor(),
				this.drawText(t, e + 84, i, 36, 'right');
		}
		drawActorIcons(t, e, i, r = 144) {
			const s = t.allIcons().slice(0, Math.floor(r / Window_Base._iconWidth));
			for (let t = 0; t < s.length; t++)
				this.drawIcon(s[t], e + Window_Base._iconWidth * t, i + 2);
		}
		drawCurrentAndMax(t, e, i, r, s, n, a) {
			const o = this.textWidth('HP'),
				h = this.textWidth('0000'),
				u = this.textWidth('/'),
				l = i + s - h,
				c = l - u,
				d = c - h;
			d >= i + o
				? (this.changeTextColor(n),
				  this.drawText(t, d, r, h, 'right'),
				  this.changeTextColor(a),
				  this.drawText('/', c, r, u, 'right'),
				  this.drawText(e, l, r, h, 'right'))
				: (this.changeTextColor(n), this.drawText(t, l, r, h, 'right'));
		}
		drawActorHp(t, e, i, r = 186) {
			const s = this.hpGaugeColor1(),
				n = this.hpGaugeColor2();
			this.drawGauge(e, i, r, t.hpRate(), s, n),
				this.changeTextColor(this.systemColor()),
				this.drawText(TextManager.hpA, e, i, 44),
				this.drawCurrentAndMax(
					t.hp,
					t.mhp,
					e,
					i,
					r,
					this.hpColor(t),
					this.normalColor()
				);
		}
		drawActorMp(t, e, i, r = 186) {
			const s = this.mpGaugeColor1(),
				n = this.mpGaugeColor2();
			this.drawGauge(e, i, r, t.mpRate(), s, n),
				this.changeTextColor(this.systemColor()),
				this.drawText(TextManager.mpA, e, i, 44),
				this.drawCurrentAndMax(
					t.mp,
					t.mmp,
					e,
					i,
					r,
					this.mpColor(t),
					this.normalColor()
				);
		}
		drawActorTp(t, e, i, r = 96) {
			const s = this.tpGaugeColor1(),
				n = this.tpGaugeColor2();
			this.drawGauge(e, i, r, t.tpRate(), s, n),
				this.changeTextColor(this.systemColor()),
				this.drawText(TextManager.tpA, e, i, 44),
				this.changeTextColor(this.tpColor(t)),
				this.drawText(t.tp, e + r - 64, i, 64, 'right');
		}
		drawActorSimpleStatus(t, e, i, r) {
			const s = this.lineHeight(),
				n = e + 180,
				a = Math.min(200, r - 180 - this.textPadding());
			this.drawActorName(t, e, i),
				this.drawActorLevel(t, e, i + 1 * s),
				this.drawActorIcons(t, e, i + 2 * s),
				this.drawActorClass(t, n, i),
				this.drawActorHp(t, n, i + 1 * s, a),
				this.drawActorMp(t, n, i + 2 * s, a);
		}
		drawItemName(t, e, i, r = 312) {
			if (t) {
				const s = Window_Base._iconWidth + 4;
				this.resetTextColor(),
					this.drawIcon(t.iconIndex, e + 2, i + 2),
					this.drawText(t.name, e + s, i, r - s);
			}
		}
		drawCurrencyValue(t, e, i, r, s) {
			const n = Math.min(80, this.textWidth(e));
			this.resetTextColor(),
				this.drawText(t, i, r, s - n - 6, 'right'),
				this.changeTextColor(this.systemColor()),
				this.drawText(e, i + s - n, r, n, 'right');
		}
		paramchangeTextColor(t) {
			return t > 0
				? this.powerUpColor()
				: t < 0
				? this.powerDownColor()
				: this.normalColor();
		}
		setBackgroundType(t) {
			(this.opacity = 0 === t ? 255 : 0),
				1 === t ? this.showBackgroundDimmer() : this.hideBackgroundDimmer();
		}
		showBackgroundDimmer() {
			this._dimmerSprite ||
				((this._dimmerSprite = new Sprite()),
				(this._dimmerSprite.bitmap = new Bitmap(0, 0)),
				this.addChildToBack(this._dimmerSprite));
			const t = this._dimmerSprite.bitmap;
			(t.width === this.width && t.height === this.height) ||
				this.refreshDimmerBitmap(),
				(this._dimmerSprite.visible = !0),
				this.updateBackgroundDimmer();
		}
		hideBackgroundDimmer() {
			this._dimmerSprite && (this._dimmerSprite.visible = !1);
		}
		updateBackgroundDimmer() {
			this._dimmerSprite && (this._dimmerSprite.opacity = this.openness);
		}
		refreshDimmerBitmap() {
			if (this._dimmerSprite) {
				const t = this._dimmerSprite.bitmap,
					e = this.width,
					i = this.height,
					r = this.padding,
					s = this.dimColor1(),
					n = this.dimColor2();
				t.resize(e, i),
					t.gradientFillRect(0, 0, e, r, n, s, !0),
					t.fillRect(0, r, e, i - 2 * r, s),
					t.gradientFillRect(0, i - r, e, r, s, n, !0),
					this._dimmerSprite.setFrame(0, 0, e, i);
			}
		}
		dimColor1() {
			return 'rgba(0, 0, 0, 0.6)';
		}
		dimColor2() {
			return 'rgba(0, 0, 0, 0)';
		}
		canvasToLocalX(t) {
			let e = this;
			for (; e; ) (t -= e.x), (e = e.parent);
			return t;
		}
		canvasToLocalY(t) {
			let e = this;
			for (; e; ) (t -= e.y), (e = e.parent);
			return t;
		}
		reserveFaceImages() {
			self.$gameParty.members().forEach((t) => {
				ImageManager.reserveFace(t.faceName());
			}, this);
		}
	}
	(Window_Base._iconWidth = 32),
		(Window_Base._iconHeight = 32),
		(Window_Base._faceWidth = 144),
		(Window_Base._faceHeight = 144);
	class Window_Help extends Window_Base {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t) {
			const e = Graphics.boxWidth,
				i = this.fittingHeight(t || 2);
			super.initialize(0, 0, e, i), (this._text = '');
		}
		setText(t) {
			this._text !== t && ((this._text = t), this.refresh());
		}
		clear() {
			this.setText('');
		}
		setItem(t) {
			this.setText(t ? t.description : '');
		}
		refresh() {
			this.contents.clear(), this.drawTextEx(this._text, this.textPadding(), 0);
		}
	}
	class Window_Gold extends Window_Base {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e) {
			const i = this.windowWidth(),
				r = this.windowHeight();
			super.initialize(t, e, i, r), this.refresh();
		}
		windowWidth() {
			return 240;
		}
		windowHeight() {
			return this.fittingHeight(1);
		}
		refresh() {
			const t = this.textPadding(),
				e = this.contents.width - 2 * this.textPadding();
			this.contents.clear(),
				this.drawCurrencyValue(this.value(), this.currencyUnit(), t, 0, e);
		}
		value() {
			return self.$gameParty.gold();
		}
		currencyUnit() {
			return TextManager.currencyUnit;
		}
		open() {
			this.refresh(), super.open();
		}
	}
	class Window_Selectable extends Window_Base {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e, i, r) {
			super.initialize(t, e, i, r),
				(this._index = -1),
				(this._cursorFixed = !1),
				(this._cursorAll = !1),
				(this._stayCount = 0),
				(this._helpWindow = null),
				(this._handlers = {}),
				(this._touching = !1),
				(this._scrollX = 0),
				(this._scrollY = 0),
				this.deactivate();
		}
		index() {
			return this._index;
		}
		cursorFixed() {
			return this._cursorFixed;
		}
		setCursorFixed(t) {
			this._cursorFixed = t;
		}
		cursorAll() {
			return this._cursorAll;
		}
		setCursorAll(t) {
			this._cursorAll = t;
		}
		maxCols() {
			return 1;
		}
		maxItems() {
			return 0;
		}
		spacing() {
			return 12;
		}
		itemWidth() {
			return Math.floor(
				(this.width - 2 * this.padding + this.spacing()) / this.maxCols() -
					this.spacing()
			);
		}
		itemHeight() {
			return this.lineHeight();
		}
		maxRows() {
			return Math.max(Math.ceil(this.maxItems() / this.maxCols()), 1);
		}
		activate() {
			super.activate(), this.reselect();
		}
		deactivate() {
			super.deactivate(), this.reselect();
		}
		select(t) {
			(this._index = t),
				(this._stayCount = 0),
				this.ensureCursorVisible(),
				this.updateCursor(),
				this.callUpdateHelp();
		}
		deselect() {
			this.select(-1);
		}
		reselect() {
			this.select(this._index);
		}
		row() {
			return Math.floor(this.index() / this.maxCols());
		}
		topRow() {
			return Math.floor(this._scrollY / this.itemHeight());
		}
		maxTopRow() {
			return Math.max(0, this.maxRows() - this.maxPageRows());
		}
		setTopRow(t) {
			const e = t.clamp(0, this.maxTopRow()) * this.itemHeight();
			this._scrollY !== e &&
				((this._scrollY = e), this.refresh(), this.updateCursor());
		}
		resetScroll() {
			this.setTopRow(0);
		}
		maxPageRows() {
			const t = this.height - 2 * this.padding;
			return Math.floor(t / this.itemHeight());
		}
		maxPageItems() {
			return this.maxPageRows() * this.maxCols();
		}
		isHorizontal() {
			return 1 === this.maxPageRows();
		}
		bottomRow() {
			return Math.max(0, this.topRow() + this.maxPageRows() - 1);
		}
		setBottomRow(t) {
			this.setTopRow(t - (this.maxPageRows() - 1));
		}
		topIndex() {
			return this.topRow() * this.maxCols();
		}
		itemRect(t) {
			const e = new Rectangle(),
				i = this.maxCols();
			return (
				(e.width = this.itemWidth()),
				(e.height = this.itemHeight()),
				(e.x = (t % i) * (e.width + this.spacing()) - this._scrollX),
				(e.y = Math.floor(t / i) * e.height - this._scrollY),
				e
			);
		}
		itemRectForText(t) {
			const e = this.itemRect(t);
			return (
				(e.x += this.textPadding()), (e.width -= 2 * this.textPadding()), e
			);
		}
		setHelpWindow(t) {
			(this._helpWindow = t), this.callUpdateHelp();
		}
		showHelpWindow() {
			this._helpWindow && this._helpWindow.show();
		}
		hideHelpWindow() {
			this._helpWindow && this._helpWindow.hide();
		}
		setHandler(t, e) {
			this._handlers[t] = e;
		}
		isHandled(t) {
			return !!this._handlers[t];
		}
		callHandler(t) {
			this.isHandled(t) && this._handlers[t]();
		}
		isOpenAndActive() {
			return this.isOpen() && this.active;
		}
		isCursorMovable() {
			return (
				this.isOpenAndActive() &&
				!this._cursorFixed &&
				!this._cursorAll &&
				this.maxItems() > 0
			);
		}
		cursorDown(t) {
			const e = this.index(),
				i = this.maxItems(),
				r = this.maxCols();
			(e < i - r || (t && 1 === r)) && this.select((e + r) % i);
		}
		cursorUp(t) {
			const e = this.index(),
				i = this.maxItems(),
				r = this.maxCols();
			(e >= r || (t && 1 === r)) && this.select((e - r + i) % i);
		}
		cursorRight(t) {
			const e = this.index(),
				i = this.maxItems();
			this.maxCols() >= 2 &&
				(e < i - 1 || (t && this.isHorizontal())) &&
				this.select((e + 1) % i);
		}
		cursorLeft(t) {
			const e = this.index(),
				i = this.maxItems();
			this.maxCols() >= 2 &&
				(e > 0 || (t && this.isHorizontal())) &&
				this.select((e - 1 + i) % i);
		}
		cursorPagedown() {
			const t = this.index(),
				e = this.maxItems();
			this.topRow() + this.maxPageRows() < this.maxRows() &&
				(this.setTopRow(this.topRow() + this.maxPageRows()),
				this.select(Math.min(t + this.maxPageItems(), e - 1)));
		}
		cursorPageup() {
			const t = this.index();
			this.topRow() > 0 &&
				(this.setTopRow(this.topRow() - this.maxPageRows()),
				this.select(Math.max(t - this.maxPageItems(), 0)));
		}
		scrollDown() {
			this.topRow() + 1 < this.maxRows() && this.setTopRow(this.topRow() + 1);
		}
		scrollUp() {
			this.topRow() > 0 && this.setTopRow(this.topRow() - 1);
		}
		update() {
			super.update(),
				this.updateArrows(),
				this.processCursorMove(),
				this.processHandling(),
				this.processWheel(),
				this.processTouch(),
				this._stayCount++;
		}
		updateArrows() {
			const t = this.topRow(),
				e = this.maxTopRow();
			(this.downArrowVisible = e > 0 && t < e), (this.upArrowVisible = t > 0);
		}
		processCursorMove() {
			if (this.isCursorMovable()) {
				const t = this.index();
				Input.isRepeated('down') && this.cursorDown(Input.isTriggered('down')),
					Input.isRepeated('up') && this.cursorUp(Input.isTriggered('up')),
					Input.isRepeated('right') &&
						this.cursorRight(Input.isTriggered('right')),
					Input.isRepeated('left') &&
						this.cursorLeft(Input.isTriggered('left')),
					!this.isHandled('pagedown') &&
						Input.isTriggered('pagedown') &&
						this.cursorPagedown(),
					!this.isHandled('pageup') &&
						Input.isTriggered('pageup') &&
						this.cursorPageup(),
					this.index() !== t && SoundManager.playCursor();
			}
		}
		processHandling() {
			this.isOpenAndActive() &&
				(this.isOkEnabled() && this.isOkTriggered()
					? this.processOk()
					: this.isCancelEnabled() && this.isCancelTriggered()
					? this.processCancel()
					: this.isHandled('pagedown') && Input.isTriggered('pagedown')
					? this.processPagedown()
					: this.isHandled('pageup') &&
					  Input.isTriggered('pageup') &&
					  this.processPageup());
		}
		processWheel() {
			if (this.isOpenAndActive()) {
				const t = 20;
				TouchInput.wheelY >= t && this.scrollDown(),
					TouchInput.wheelY <= -t && this.scrollUp();
			}
		}
		processTouch() {
			this.isOpenAndActive()
				? (TouchInput.isTriggered() && this.isTouchedInsideFrame()
						? ((this._touching = !0), this.onTouch(!0))
						: TouchInput.isCancelled() &&
						  this.isCancelEnabled() &&
						  this.processCancel(),
				  this._touching &&
						(TouchInput.isPressed() ? this.onTouch(!1) : (this._touching = !1)))
				: (this._touching = !1);
		}
		isTouchedInsideFrame() {
			const t = this.canvasToLocalX(TouchInput.x),
				e = this.canvasToLocalY(TouchInput.y);
			return t >= 0 && e >= 0 && t < this.width && e < this.height;
		}
		onTouch(t) {
			const e = this.index(),
				i = this.canvasToLocalX(TouchInput.x),
				r = this.canvasToLocalY(TouchInput.y),
				s = this.hitTest(i, r);
			s >= 0
				? s === this.index()
					? t && this.isTouchOkEnabled() && this.processOk()
					: this.isCursorMovable() && this.select(s)
				: this._stayCount >= 10 &&
				  (r < this.padding
						? this.cursorUp()
						: r >= this.height - this.padding && this.cursorDown()),
				this.index() !== e && SoundManager.playCursor();
		}
		hitTest(t, e) {
			if (this.isContentsArea(t, e)) {
				const i = t - this.padding,
					r = e - this.padding,
					s = this.topIndex();
				for (let t = 0; t < this.maxPageItems(); t++) {
					const e = s + t;
					if (e < this.maxItems()) {
						const t = this.itemRect(e),
							s = t.x + t.width,
							n = t.y + t.height;
						if (i >= t.x && r >= t.y && i < s && r < n) return e;
					}
				}
			}
			return -1;
		}
		isContentsArea(t, e) {
			const i = this.padding,
				r = this.padding,
				s = this.width - this.padding,
				n = this.height - this.padding;
			return t >= i && e >= r && t < s && e < n;
		}
		isTouchOkEnabled() {
			return this.isOkEnabled();
		}
		isOkEnabled() {
			return this.isHandled('ok');
		}
		isCancelEnabled() {
			return this.isHandled('cancel');
		}
		isOkTriggered() {
			return Input.isRepeated('ok');
		}
		isCancelTriggered() {
			return Input.isRepeated('cancel');
		}
		processOk() {
			this.isCurrentItemEnabled()
				? (this.playOkSound(),
				  this.updateInputData(),
				  this.deactivate(),
				  this.callOkHandler())
				: this.playBuzzerSound();
		}
		playOkSound() {
			SoundManager.playOk();
		}
		playBuzzerSound() {
			SoundManager.playBuzzer();
		}
		callOkHandler() {
			this.callHandler('ok');
		}
		processCancel() {
			SoundManager.playCancel(),
				this.updateInputData(),
				this.deactivate(),
				this.callCancelHandler();
		}
		callCancelHandler() {
			this.callHandler('cancel');
		}
		processPageup() {
			SoundManager.playCursor(),
				this.updateInputData(),
				this.deactivate(),
				this.callHandler('pageup');
		}
		processPagedown() {
			SoundManager.playCursor(),
				this.updateInputData(),
				this.deactivate(),
				this.callHandler('pagedown');
		}
		updateInputData() {
			Input.update(), TouchInput.update();
		}
		updateCursor() {
			if (this._cursorAll) {
				const t = this.maxRows() * this.itemHeight();
				this.setCursorRect(0, 0, this.contents.width, t), this.setTopRow(0);
			} else if (this.isCursorVisible()) {
				const t = this.itemRect(this.index());
				this.setCursorRect(t.x, t.y, t.width, t.height);
			} else this.setCursorRect(0, 0, 0, 0);
		}
		isCursorVisible() {
			const t = this.row();
			return t >= this.topRow() && t <= this.bottomRow();
		}
		ensureCursorVisible() {
			const t = this.row();
			t < this.topRow()
				? this.setTopRow(t)
				: t > this.bottomRow() && this.setBottomRow(t);
		}
		callUpdateHelp() {
			this.active && this._helpWindow && this.updateHelp();
		}
		updateHelp() {
			this._helpWindow.clear();
		}
		setHelpWindowItem(t) {
			this._helpWindow && this._helpWindow.setItem(t);
		}
		isCurrentItemEnabled() {
			return !0;
		}
		drawAllItems() {
			const t = this.topIndex();
			for (let e = 0; e < this.maxPageItems(); e++) {
				const i = t + e;
				i < this.maxItems() && this.drawItem(i);
			}
		}
		drawItem(t) {}
		clearItem(t) {
			const e = this.itemRect(t);
			this.contents.clearRect(e.x, e.y, e.width, e.height);
		}
		redrawItem(t) {
			t >= 0 && (this.clearItem(t), this.drawItem(t));
		}
		redrawCurrentItem() {
			this.redrawItem(this.index());
		}
		refresh() {
			this.contents && (this.contents.clear(), this.drawAllItems());
		}
	}
	class Window_Command extends Window_Selectable {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e) {
			this.clearCommandList(), this.makeCommandList();
			const i = this.windowWidth(),
				r = this.windowHeight();
			super.initialize(t, e, i, r),
				this.refresh(),
				this.select(0),
				this.activate();
		}
		windowWidth() {
			return 240;
		}
		windowHeight() {
			return this.fittingHeight(this.numVisibleRows());
		}
		numVisibleRows() {
			return Math.ceil(this.maxItems() / this.maxCols());
		}
		maxItems() {
			return this._list.length;
		}
		clearCommandList() {
			this._list = [];
		}
		makeCommandList() {}
		addCommand(t, e, i, r) {
			void 0 === i && (i = !0),
				void 0 === r && (r = null),
				this._list.push({ name: t, symbol: e, enabled: i, ext: r });
		}
		commandName(t) {
			return this._list[t].name;
		}
		commandSymbol(t) {
			return this._list[t].symbol;
		}
		isCommandEnabled(t) {
			return this._list[t].enabled;
		}
		currentData() {
			return this.index() >= 0 ? this._list[this.index()] : null;
		}
		isCurrentItemEnabled() {
			return !!this.currentData() && this.currentData().enabled;
		}
		currentSymbol() {
			return this.currentData() ? this.currentData().symbol : null;
		}
		currentExt() {
			return this.currentData() ? this.currentData().ext : null;
		}
		findSymbol(t) {
			for (let e = 0; e < this._list.length; e++)
				if (this._list[e].symbol === t) return e;
			return -1;
		}
		selectSymbol(t) {
			const e = this.findSymbol(t);
			e >= 0 ? this.select(e) : this.select(0);
		}
		findExt(t) {
			for (let e = 0; e < this._list.length; e++)
				if (this._list[e].ext === t) return e;
			return -1;
		}
		selectExt(t) {
			const e = this.findExt(t);
			e >= 0 ? this.select(e) : this.select(0);
		}
		drawItem(t) {
			const e = this.itemRectForText(t),
				i = this.itemTextAlign();
			this.resetTextColor(),
				this.changePaintOpacity(this.isCommandEnabled(t)),
				this.drawText(this.commandName(t), e.x, e.y, e.width, i);
		}
		itemTextAlign() {
			return 'left';
		}
		isOkEnabled() {
			return !0;
		}
		callOkHandler() {
			const t = this.currentSymbol();
			this.isHandled(t)
				? this.callHandler(t)
				: this.isHandled('ok')
				? super.callOkHandler()
				: this.activate();
		}
		refresh() {
			this.clearCommandList(),
				this.makeCommandList(),
				this.createContents(),
				super.refresh();
		}
	}
	class Window_ChoiceList extends Window_Command {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t) {
			(this._messageWindow = t),
				super.initialize(0, 0),
				(this.openness = 0),
				this.deactivate(),
				(this._background = 0);
		}
		start() {
			this.updatePlacement(),
				this.updateBackground(),
				this.refresh(),
				this.selectDefault(),
				this.open(),
				this.activate();
		}
		selectDefault() {
			this.select(self.$gameMessage.choiceDefaultType());
		}
		updatePlacement() {
			const t = self.$gameMessage.choicePositionType(),
				e = this._messageWindow.y;
			switch (
				((this.width = this.windowWidth()),
				(this.height = this.windowHeight()),
				t)
			) {
				case 0:
					this.x = 0;
					break;
				case 1:
					this.x = (Graphics.boxWidth - this.width) / 2;
					break;
				case 2:
					this.x = Graphics.boxWidth - this.width;
			}
			e >= Graphics.boxHeight / 2
				? (this.y = e - this.height)
				: (this.y = e + this._messageWindow.height);
		}
		updateBackground() {
			(this._background = self.$gameMessage.choiceBackground()),
				this.setBackgroundType(this._background);
		}
		windowWidth() {
			const t = this.maxChoiceWidth() + 2 * this.padding;
			return Math.min(t, Graphics.boxWidth);
		}
		numVisibleRows() {
			const t = this._messageWindow.y,
				e = this._messageWindow.height,
				i = Graphics.boxHeight / 2;
			let r = self.$gameMessage.choices().length,
				s = 8;
			return t < i && t + e > i && (s = 4), r > s && (r = s), r;
		}
		maxChoiceWidth() {
			let t = 96;
			const e = self.$gameMessage.choices();
			for (let i = 0; i < e.length; i++) {
				const r = this.textWidthEx(e[i]) + 2 * this.textPadding();
				t < r && (t = r);
			}
			return t;
		}
		textWidthEx(t) {
			return this.drawTextEx(t, 0, this.contents.height);
		}
		contentsHeight() {
			return this.maxItems() * this.itemHeight();
		}
		makeCommandList() {
			const t = self.$gameMessage.choices();
			for (let e = 0; e < t.length; e++) this.addCommand(t[e], 'choice');
		}
		drawItem(t) {
			const e = this.itemRectForText(t);
			this.drawTextEx(this.commandName(t), e.x, e.y);
		}
		isCancelEnabled() {
			return -1 !== self.$gameMessage.choiceCancelType();
		}
		isOkTriggered() {
			return Input.isTriggered('ok');
		}
		callOkHandler() {
			self.$gameMessage.onChoice(this.index()),
				this._messageWindow.terminateMessage(),
				this.close();
		}
		callCancelHandler() {
			self.$gameMessage.onChoice(self.$gameMessage.choiceCancelType()),
				this._messageWindow.terminateMessage(),
				this.close();
		}
	}
	class Sprite_Button extends Sprite {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize(),
				(this._touching = !1),
				(this._coldFrame = null),
				(this._hotFrame = null),
				(this._clickHandler = null);
		}
		update() {
			super.update(), this.updateFrame(), this.processTouch();
		}
		updateFrame() {
			let t;
			(t = this._touching ? this._hotFrame : this._coldFrame),
				t && this.setFrame(t.x, t.y, t.width, t.height);
		}
		setColdFrame(t, e, i, r) {
			this._coldFrame = new Rectangle(t, e, i, r);
		}
		setHotFrame(t, e, i, r) {
			this._hotFrame = new Rectangle(t, e, i, r);
		}
		setClickHandler(t) {
			this._clickHandler = t;
		}
		callClickHandler() {
			this._clickHandler && this._clickHandler();
		}
		processTouch() {
			this.isActive()
				? (TouchInput.isTriggered() &&
						this.isButtonTouched() &&
						(this._touching = !0),
				  this._touching &&
						((!TouchInput.isReleased() && this.isButtonTouched()) ||
							((this._touching = !1),
							TouchInput.isReleased() && this.callClickHandler())))
				: (this._touching = !1);
		}
		isActive() {
			let t = this;
			for (; t; ) {
				if (!t.visible) return !1;
				t = t.parent;
			}
			return !0;
		}
		isButtonTouched() {
			const t = this.canvasToLocalX(TouchInput.x),
				e = this.canvasToLocalY(TouchInput.y);
			return t >= 0 && e >= 0 && t < this.width && e < this.height;
		}
		canvasToLocalX(t) {
			let e = this;
			for (; e; ) (t -= e.x), (e = e.parent);
			return t;
		}
		canvasToLocalY(t) {
			let e = this;
			for (; e; ) (t -= e.y), (e = e.parent);
			return t;
		}
	}
	class Window_NumberInput extends Window_Selectable {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t) {
			(this._messageWindow = t),
				super.initialize(0, 0, 0, 0),
				(this._number = 0),
				(this._maxDigits = 1),
				(this.openness = 0),
				this.createButtons(),
				this.deactivate();
		}
		start() {
			(this._maxDigits = self.$gameMessage.numInputMaxDigits()),
				(this._number = self.$gameVariables.value(
					self.$gameMessage.numInputVariableId()
				)),
				(this._number = this._number.clamp(
					0,
					Math.pow(10, this._maxDigits) - 1
				)),
				this.updatePlacement(),
				this.placeButtons(),
				this.updateButtonsVisiblity(),
				this.createContents(),
				this.refresh(),
				this.open(),
				this.activate(),
				this.select(0);
		}
		updatePlacement() {
			const t = this._messageWindow.y;
			(this.width = this.windowWidth()),
				(this.height = this.windowHeight()),
				(this.x = (Graphics.boxWidth - this.width) / 2),
				t >= Graphics.boxHeight / 2
					? (this.y = t - this.height - 8)
					: (this.y = t + this._messageWindow.height + 8);
		}
		windowWidth() {
			return this.maxCols() * this.itemWidth() + 2 * this.padding;
		}
		windowHeight() {
			return this.fittingHeight(1);
		}
		maxCols() {
			return this._maxDigits;
		}
		maxItems() {
			return this._maxDigits;
		}
		spacing() {
			return 0;
		}
		itemWidth() {
			return 32;
		}
		createButtons() {
			const t = ImageManager.loadSystem('ButtonSet');
			this._buttons = [];
			for (let e = 0; e < 3; e++) {
				const i = new Sprite_Button(),
					r = 48 * [1, 2, 4][e],
					s = 48 * (2 === e ? 2 : 1);
				(i.bitmap = t),
					i.setColdFrame(r, 0, s, 48),
					i.setHotFrame(r, 48, s, 48),
					(i.visible = !1),
					this._buttons.push(i),
					this.addChild(i);
			}
			this._buttons[0].setClickHandler(this.onButtonDown.bind(this)),
				this._buttons[1].setClickHandler(this.onButtonUp.bind(this)),
				this._buttons[2].setClickHandler(this.onButtonOk.bind(this));
		}
		placeButtons() {
			const t = this._buttons.length;
			let e = -16;
			for (let i = 0; i < t; i++) e += this._buttons[i].width + 16;
			let i = (this.width - e) / 2;
			for (let e = 0; e < t; e++) {
				const t = this._buttons[e];
				(t.x = i), (t.y = this.buttonY()), (i += t.width + 16);
			}
		}
		updateButtonsVisiblity() {
			TouchInput.date > Input.date ? this.showButtons() : this.hideButtons();
		}
		showButtons() {
			for (let t = 0; t < this._buttons.length; t++)
				this._buttons[t].visible = !0;
		}
		hideButtons() {
			for (let t = 0; t < this._buttons.length; t++)
				this._buttons[t].visible = !1;
		}
		buttonY() {
			return this._messageWindow.y >= Graphics.boxHeight / 2
				? 0 - this._buttons[0].height - 8
				: this.height + 8;
		}
		update() {
			super.update(), this.processDigitChange();
		}
		processDigitChange() {
			this.isOpenAndActive() &&
				(Input.isRepeated('up')
					? this.changeDigit(!0)
					: Input.isRepeated('down') && this.changeDigit(!1));
		}
		changeDigit(t) {
			const e = this.index(),
				i = Math.pow(10, this._maxDigits - 1 - e);
			let r = Math.floor(this._number / i) % 10;
			(this._number -= r * i),
				(r = t ? (r + 1) % 10 : (r + 9) % 10),
				(this._number += r * i),
				this.refresh(),
				SoundManager.playCursor();
		}
		isTouchOkEnabled() {
			return !1;
		}
		isOkEnabled() {
			return !0;
		}
		isCancelEnabled() {
			return !1;
		}
		isOkTriggered() {
			return Input.isTriggered('ok');
		}
		processOk() {
			SoundManager.playOk(),
				self.$gameVariables.setValue(
					self.$gameMessage.numInputVariableId(),
					this._number
				),
				this._messageWindow.terminateMessage(),
				this.updateInputData(),
				this.deactivate(),
				this.close();
		}
		drawItem(t) {
			const e = this.itemRect(t),
				i = this._number.padZero(this._maxDigits).slice(t, t + 1);
			this.resetTextColor(), this.drawText(i, e.x, e.y, e.width, 'center');
		}
		onButtonUp() {
			this.changeDigit(!0);
		}
		onButtonDown() {
			this.changeDigit(!1);
		}
		onButtonOk() {
			this.processOk(), this.hideButtons();
		}
	}
	class Window_ItemList extends Window_Selectable {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e, i, r) {
			super.initialize(t, e, i, r),
				(this._category = 'none'),
				(this._data = []);
		}
		setCategory(t) {
			this._category !== t &&
				((this._category = t), this.refresh(), this.resetScroll());
		}
		maxCols() {
			return 2;
		}
		spacing() {
			return 48;
		}
		maxItems() {
			return this._data ? this._data.length : 1;
		}
		item() {
			const t = this.index();
			return this._data && t >= 0 ? this._data[t] : null;
		}
		isCurrentItemEnabled() {
			return this.isEnabled(this.item());
		}
		includes(t) {
			switch (this._category) {
				case 'item':
					return DataManager$1.isItem(t) && 1 === t.itypeId;
				case 'weapon':
					return DataManager$1.isWeapon(t);
				case 'armor':
					return DataManager$1.isArmor(t);
				case 'keyItem':
					return DataManager$1.isItem(t) && 2 === t.itypeId;
				default:
					return !1;
			}
		}
		needsNumber() {
			return !0;
		}
		isEnabled(t) {
			return self.$gameParty.canUse(t);
		}
		makeItemList() {
			(this._data = self.$gameParty.allItems().filter(function (t) {
				return this.includes(t);
			}, this)),
				this.includes(null) && this._data.push(null);
		}
		selectLast() {
			const t = this._data.indexOf(self.$gameParty.lastItem());
			this.select(t >= 0 ? t : 0);
		}
		drawItem(t) {
			const e = this._data[t];
			if (e) {
				const i = this.numberWidth(),
					r = this.itemRect(t);
				(r.width -= this.textPadding()),
					this.changePaintOpacity(this.isEnabled(e)),
					this.drawItemName(e, r.x, r.y, r.width - i),
					this.drawItemNumber(e, r.x, r.y, r.width),
					this.changePaintOpacity(1);
			}
		}
		numberWidth() {
			return this.textWidth('000');
		}
		drawItemNumber(t, e, i, r) {
			this.needsNumber() &&
				(this.drawText(':', e, i, r - this.textWidth('00'), 'right'),
				this.drawText(self.$gameParty.numItems(t), e, i, r, 'right'));
		}
		updateHelp() {
			this.setHelpWindowItem(this.item());
		}
		refresh() {
			this.makeItemList(), this.createContents(), this.drawAllItems();
		}
	}
	class Window_EventItem extends Window_ItemList {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t) {
			this._messageWindow = t;
			const e = Graphics.boxWidth,
				i = this.windowHeight();
			super.initialize(0, 0, e, i),
				(this.openness = 0),
				this.deactivate(),
				this.setHandler('ok', this.onOk.bind(this)),
				this.setHandler('cancel', this.onCancel.bind(this));
		}
		windowHeight() {
			return this.fittingHeight(this.numVisibleRows());
		}
		numVisibleRows() {
			return 4;
		}
		start() {
			this.refresh(),
				this.updatePlacement(),
				this.select(0),
				this.open(),
				this.activate();
		}
		updatePlacement() {
			this._messageWindow.y >= Graphics.boxHeight / 2
				? (this.y = 0)
				: (this.y = Graphics.boxHeight - this.height);
		}
		includes(t) {
			const e = self.$gameMessage.itemChoiceItypeId();
			return DataManager$1.isItem(t) && t.itypeId === e;
		}
		isEnabled(t) {
			return !0;
		}
		onOk() {
			const t = this.item(),
				e = t ? t.id : 0;
			self.$gameVariables.setValue(self.$gameMessage.itemChoiceVariableId(), e),
				this._messageWindow.terminateMessage(),
				this.close();
		}
		onCancel() {
			self.$gameVariables.setValue(self.$gameMessage.itemChoiceVariableId(), 0),
				this._messageWindow.terminateMessage(),
				this.close();
		}
	}
	class Window_Message extends Window_Base {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			const t = this.windowWidth(),
				e = this.windowHeight(),
				i = (Graphics.boxWidth - t) / 2;
			super.initialize(i, 0, t, e),
				(this.openness = 0),
				this.initMembers(),
				this.createSubWindows(),
				this.updatePlacement();
		}
		initMembers() {
			(this._imageReservationId = Utils.generateRuntimeId()),
				(this._background = 0),
				(this._positionType = 2),
				(this._waitCount = 0),
				(this._faceBitmap = null),
				(this._textState = null),
				this.clearFlags();
		}
		subWindows() {
			return [
				this._goldWindow,
				this._choiceWindow,
				this._numberWindow,
				this._itemWindow,
			];
		}
		createSubWindows() {
			(this._goldWindow = new Window_Gold(0, 0)),
				(this._goldWindow.x = Graphics.boxWidth - this._goldWindow.width),
				(this._goldWindow.openness = 0),
				(this._choiceWindow = new Window_ChoiceList(this)),
				(this._numberWindow = new Window_NumberInput(this)),
				(this._itemWindow = new Window_EventItem(this));
		}
		windowWidth() {
			return Graphics.boxWidth;
		}
		windowHeight() {
			return this.fittingHeight(this.numVisibleRows());
		}
		clearFlags() {
			(this._showFast = !1),
				(this._lineShowFast = !1),
				(this._pauseSkip = !1),
				(this._textSpeed = 0),
				(this._textSpeedCount = 0);
		}
		numVisibleRows() {
			return 4;
		}
		update() {
			for (
				this.checkToNotClose(), super.update();
				!this.isOpening() && !this.isClosing();

			) {
				if (this.updateWait()) return;
				if (this.updateLoading()) return;
				if (this.updateInput()) return;
				if (this.updateMessage()) return;
				if (!this.canStart()) return void this.startInput();
				this.startMessage();
			}
		}
		checkToNotClose() {
			this.isClosing() && this.isOpen() && this.doesContinue() && this.open();
		}
		canStart() {
			return self.$gameMessage.hasText() && !self.$gameMessage.scrollMode();
		}
		startMessage() {
			(this._textState = {}),
				(this._textState.index = 0),
				(this._textState.text = this.convertEscapeCharacters(
					self.$gameMessage.allText()
				)),
				this.newPage(this._textState),
				this.updatePlacement(),
				this.updateBackground(),
				this.open();
		}
		updatePlacement() {
			(this._positionType = self.$gameMessage.positionType()),
				(this.y =
					(this._positionType * (Graphics.boxHeight - this.height)) / 2),
				(this._goldWindow.y =
					this.y > 0 ? 0 : Graphics.boxHeight - this._goldWindow.height);
		}
		updateBackground() {
			(this._background = self.$gameMessage.background()),
				this.setBackgroundType(this._background);
		}
		terminateMessage() {
			this.close(), this._goldWindow.close(), self.$gameMessage.clear();
		}
		updateWait() {
			return this._waitCount > 0 && (this._waitCount--, !0);
		}
		updateLoading() {
			return !(
				!this._faceBitmap ||
				(this._faceBitmap.isReady() &&
					(this.drawMessageFace(), (this._faceBitmap = null), 1))
			);
		}
		updateInput() {
			return (
				!!this.isAnySubWindowActive() ||
				(!!this.pause &&
					(this.isTriggered() &&
						(Input.update(),
						(this.pause = !1),
						this._textState || this.terminateMessage()),
					!0))
			);
		}
		isAnySubWindowActive() {
			return (
				this._choiceWindow.active ||
				this._numberWindow.active ||
				this._itemWindow.active
			);
		}
		updateMessage() {
			if (this._textState) {
				for (; !this.isEndOfText(this._textState); ) {
					if (
						(this.needsNewPage(this._textState) &&
							this.newPage(this._textState),
						this.updateShowFast(),
						!this._showFast &&
							!this._lineShowFast &&
							this._textSpeedCount < this._textSpeed)
					) {
						this._textSpeedCount++;
						break;
					}
					if (
						((this._textSpeedCount = 0),
						this.processCharacter(this._textState),
						!this._showFast && !this._lineShowFast && -1 !== this._textSpeed)
					)
						break;
					if (this.pause || this._waitCount > 0) break;
				}
				return this.isEndOfText(this._textState) && this.onEndOfText(), !0;
			}
			return !1;
		}
		onEndOfText() {
			this.startInput() ||
				(this._pauseSkip ? this.terminateMessage() : this.startPause()),
				(this._textState = null);
		}
		startInput() {
			return self.$gameMessage.isChoice()
				? (this._choiceWindow.start(), !0)
				: self.$gameMessage.isNumberInput()
				? (this._numberWindow.start(), !0)
				: !!self.$gameMessage.isItemChoice() && (this._itemWindow.start(), !0);
		}
		isTriggered() {
			return (
				Input.isRepeated('ok') ||
				Input.isRepeated('cancel') ||
				TouchInput.isRepeated()
			);
		}
		doesContinue() {
			return (
				self.$gameMessage.hasText() &&
				!self.$gameMessage.scrollMode() &&
				!this.areSettingsChanged()
			);
		}
		areSettingsChanged() {
			return (
				this._background !== self.$gameMessage.background() ||
				this._positionType !== self.$gameMessage.positionType()
			);
		}
		updateShowFast() {
			this.isTriggered() && (this._showFast = !0);
		}
		newPage(t) {
			this.contents.clear(),
				this.resetFontSettings(),
				this.clearFlags(),
				this.loadMessageFace(),
				(t.x = this.newLineX()),
				(t.y = 0),
				(t.left = this.newLineX()),
				(t.height = this.calcTextHeight(t, !1));
		}
		loadMessageFace() {
			this._faceBitmap = ImageManager.reserveFace(
				self.$gameMessage.faceName(),
				0,
				this._imageReservationId
			);
		}
		drawMessageFace() {
			this.drawFace(
				self.$gameMessage.faceName(),
				self.$gameMessage.faceIndex(),
				0,
				0
			),
				ImageManager.releaseReservation(this._imageReservationId);
		}
		newLineX() {
			return '' === self.$gameMessage.faceName() ? 0 : 168;
		}
		processNewLine(t) {
			(this._lineShowFast = !1),
				super.processNewLine(t),
				this.needsNewPage(t) && this.startPause();
		}
		processNewPage(t) {
			super.processNewPage(t),
				'\n' === t.text[t.index] && t.index++,
				(t.y = this.contents.height),
				this.startPause();
		}
		isEndOfText({ index: t, text: e }) {
			return t >= e.length;
		}
		needsNewPage(t) {
			return !this.isEndOfText(t) && t.y + t.height > this.contents.height;
		}
		processEscapeCharacter(t, e) {
			switch (t) {
				case '$':
					this._goldWindow.open();
					break;
				case '.':
					this.startWait(15);
					break;
				case '|':
					this.startWait(60);
					break;
				case '!':
					this.startPause();
					break;
				case '>':
					this._lineShowFast = !0;
					break;
				case '<':
					this._lineShowFast = !1;
					break;
				case '^':
					this._pauseSkip = !0;
					break;
				case 'S':
					this._textSpeed = this.obtainEscapeParam(e) - 1;
					break;
				default:
					super.processEscapeCharacter(t, e);
			}
		}
		startWait(t) {
			this._waitCount = t;
		}
		startPause() {
			this.startWait(10), (this.pause = !0);
		}
	}
	class Window_ScrollText extends Window_Base {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			const t = Graphics.boxWidth,
				e = Graphics.boxHeight;
			super.initialize(0, 0, t, e),
				(this.opacity = 0),
				this.hide(),
				(this._text = ''),
				(this._allTextHeight = 0);
		}
		update() {
			super.update(),
				self.$gameMessage.scrollMode() &&
					(this._text && this.updateMessage(),
					!this._text && self.$gameMessage.hasText() && this.startMessage());
		}
		startMessage() {
			(this._text = self.$gameMessage.allText()), this.refresh(), this.show();
		}
		refresh() {
			const t = { index: 0 };
			(t.text = this.convertEscapeCharacters(this._text)),
				this.resetFontSettings(),
				(this._allTextHeight = this.calcTextHeight(t, !0)),
				this.createContents(),
				(this.origin.y = -this.height),
				this.drawTextEx(this._text, this.textPadding(), 1);
		}
		contentsHeight() {
			return Math.max(this._allTextHeight, 1);
		}
		updateMessage() {
			(this.origin.y += this.scrollSpeed()),
				this.origin.y >= this.contents.height && this.terminateMessage();
		}
		scrollSpeed() {
			let t = self.$gameMessage.scrollSpeed() / 2;
			return this.isFastForward() && (t *= this.fastForwardRate()), t;
		}
		isFastForward() {
			return (
				!self.$gameMessage.scrollNoFast() &&
				(Input.isPressed('ok') ||
					Input.isPressed('shift') ||
					TouchInput.isPressed())
			);
		}
		fastForwardRate() {
			return 3;
		}
		terminateMessage() {
			(this._text = null), self.$gameMessage.clear(), this.hide();
		}
	}
	class Window_BattleLog extends Window_Selectable {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			const t = this.windowWidth(),
				e = this.windowHeight();
			super.initialize(0, 0, t, e),
				(this.opacity = 0),
				(this._lines = []),
				(this._methods = []),
				(this._waitCount = 0),
				(this._waitMode = ''),
				(this._baseLineStack = []),
				(this._spriteset = null),
				this.createBackBitmap(),
				this.createBackSprite(),
				this.refresh();
		}
		setSpriteset(t) {
			this._spriteset = t;
		}
		windowWidth() {
			return Graphics.boxWidth;
		}
		windowHeight() {
			return this.fittingHeight(this.maxLines());
		}
		maxLines() {
			return 10;
		}
		createBackBitmap() {
			this._backBitmap = new Bitmap(this.width, this.height);
		}
		createBackSprite() {
			(this._backSprite = new Sprite()),
				(this._backSprite.bitmap = this._backBitmap),
				(this._backSprite.y = this.y),
				this.addChildToBack(this._backSprite);
		}
		numLines() {
			return this._lines.length;
		}
		messageSpeed() {
			return 16;
		}
		isBusy() {
			return this._waitCount > 0 || this._waitMode || this._methods.length > 0;
		}
		update() {
			this.updateWait() || this.callNextMethod();
		}
		updateWait() {
			return this.updateWaitCount() || this.updateWaitMode();
		}
		updateWaitCount() {
			return (
				this._waitCount > 0 &&
				((this._waitCount -= this.isFastForward() ? 3 : 1),
				this._waitCount < 0 && (this._waitCount = 0),
				!0)
			);
		}
		updateWaitMode() {
			let t = !1;
			switch (this._waitMode) {
				case 'effect':
					t = this._spriteset.isEffecting();
					break;
				case 'movement':
					t = this._spriteset.isAnyoneMoving();
			}
			return t || (this._waitMode = ''), t;
		}
		setWaitMode(t) {
			this._waitMode = t;
		}
		callNextMethod() {
			if (this._methods.length > 0) {
				const t = this._methods.shift();
				if (!t.name || !this[t.name])
					throw new Error(`Method not found: ${t.name}`);
				this[t.name](...t.params);
			}
		}
		isFastForward() {
			return (
				Input.isLongPressed('ok') ||
				Input.isPressed('shift') ||
				TouchInput.isLongPressed()
			);
		}
		push(t) {
			const e = Array.prototype.slice.call(arguments, 1);
			this._methods.push({ name: t, params: e });
		}
		clear() {
			(this._lines = []), (this._baseLineStack = []), this.refresh();
		}
		wait() {
			this._waitCount = this.messageSpeed();
		}
		waitForEffect() {
			this.setWaitMode('effect');
		}
		waitForMovement() {
			this.setWaitMode('movement');
		}
		addText(t) {
			this._lines.push(t), this.refresh(), this.wait();
		}
		pushBaseLine() {
			this._baseLineStack.push(this._lines.length);
		}
		popBaseLine() {
			const t = this._baseLineStack.pop();
			for (; this._lines.length > t; ) this._lines.pop();
		}
		waitForNewLine() {
			let t = 0;
			this._baseLineStack.length > 0 &&
				(t = this._baseLineStack[this._baseLineStack.length - 1]),
				this._lines.length > t && this.wait();
		}
		popupDamage(t) {
			t.startDamagePopup();
		}
		performActionStart(t, e) {
			t.performActionStart(e);
		}
		performAction(t, e) {
			t.performAction(e);
		}
		performActionEnd(t) {
			t.performActionEnd();
		}
		performDamage(t) {
			t.performDamage();
		}
		performMiss(t) {
			t.performMiss();
		}
		performRecovery(t) {
			t.performRecovery();
		}
		performEvasion(t) {
			t.performEvasion();
		}
		performMagicEvasion(t) {
			t.performMagicEvasion();
		}
		performCounter(t) {
			t.performCounter();
		}
		performReflection(t) {
			t.performReflection();
		}
		performSubstitute(t, e) {
			t.performSubstitute(e);
		}
		performCollapse(t) {
			t.performCollapse();
		}
		showAnimation(t, e, i) {
			i < 0 ? this.showAttackAnimation(t, e) : this.showNormalAnimation(e, i);
		}
		showAttackAnimation(t, e) {
			t.isActor()
				? this.showActorAttackAnimation(t, e)
				: this.showEnemyAttackAnimation(t, e);
		}
		showActorAttackAnimation(t, e) {
			this.showNormalAnimation(e, t.attackAnimationId1(), !1),
				this.showNormalAnimation(e, t.attackAnimationId2(), !0);
		}
		showEnemyAttackAnimation(t, e) {
			SoundManager.playEnemyAttack();
		}
		showNormalAnimation(t, e, i) {
			if (self.$dataAnimations[e]) {
				let r = this.animationBaseDelay();
				const s = this.animationNextDelay();
				t.forEach((t) => {
					t.startAnimation(e, i, r), (r += s);
				});
			}
		}
		animationBaseDelay() {
			return 8;
		}
		animationNextDelay() {
			return 12;
		}
		refresh() {
			this.drawBackground(), this.contents.clear();
			for (let t = 0; t < this._lines.length; t++) this.drawLineText(t);
		}
		drawBackground() {
			const t = this.backRect(),
				e = this.backColor();
			this._backBitmap.clear(),
				(this._backBitmap.paintOpacity = this.backPaintOpacity()),
				this._backBitmap.fillRect(t.x, t.y, t.width, t.height, e),
				(this._backBitmap.paintOpacity = 255);
		}
		backRect() {
			return {
				x: 0,
				y: this.padding,
				width: this.width,
				height: this.numLines() * this.lineHeight(),
			};
		}
		backColor() {
			return '#000000';
		}
		backPaintOpacity() {
			return 64;
		}
		drawLineText(t) {
			const e = this.itemRectForText(t);
			this.contents.clearRect(e.x, e.y, e.width, e.height),
				this.drawTextEx(this._lines[t], e.x, e.y, e.width);
		}
		startTurn() {
			this.push('wait');
		}
		startAction(t, e, i) {
			const r = e.item();
			this.push('performActionStart', t, e),
				this.push('waitForMovement'),
				this.push('performAction', t, e),
				this.push('showAnimation', t, i.clone(), r.animationId),
				this.displayAction(t, r);
		}
		endAction(t) {
			this.push('waitForNewLine'),
				this.push('clear'),
				this.push('performActionEnd', t);
		}
		displayCurrentState(t) {
			const e = t.mostImportantStateText();
			e &&
				(this.push('addText', t.name() + e),
				this.push('wait'),
				this.push('clear'));
		}
		displayRegeneration(t) {
			this.push('popupDamage', t);
		}
		displayAction(t, e) {
			const i = this._methods.length;
			DataManager$1.isSkill(e)
				? (e.message1 &&
						this.push('addText', t.name() + e.message1.format(e.name)),
				  e.message2 && this.push('addText', e.message2.format(e.name)))
				: this.push('addText', TextManager.useItem.format(t.name(), e.name)),
				this._methods.length === i && this.push('wait');
		}
		displayCounter(t) {
			this.push('performCounter', t),
				this.push('addText', TextManager.counterAttack.format(t.name()));
		}
		displayReflection(t) {
			this.push('performReflection', t),
				this.push('addText', TextManager.magicReflection.format(t.name()));
		}
		displaySubstitute(t, e) {
			const i = t.name();
			this.push('performSubstitute', t, e),
				this.push('addText', TextManager.substitute.format(i, e.name()));
		}
		displayActionResults(t, e) {
			e.result().used &&
				(this.push('pushBaseLine'),
				this.displayCritical(e),
				this.push('popupDamage', e),
				this.push('popupDamage', t),
				this.displayDamage(e),
				this.displayAffectedStatus(e),
				this.displayFailure(e),
				this.push('waitForNewLine'),
				this.push('popBaseLine'));
		}
		displayFailure(t) {
			t.result().isHit() &&
				!t.result().success &&
				this.push('addText', TextManager.actionFailure.format(t.name()));
		}
		displayCritical(t) {
			t.result().critical &&
				(t.isActor()
					? this.push('addText', TextManager.criticalToActor)
					: this.push('addText', TextManager.criticalToEnemy));
		}
		displayDamage(t) {
			t.result().missed
				? this.displayMiss(t)
				: t.result().evaded
				? this.displayEvasion(t)
				: (this.displayHpDamage(t),
				  this.displayMpDamage(t),
				  this.displayTpDamage(t));
		}
		displayMiss(t) {
			let e;
			t.result().physical
				? ((e = t.isActor() ? TextManager.actorNoHit : TextManager.enemyNoHit),
				  this.push('performMiss', t))
				: (e = TextManager.actionFailure),
				this.push('addText', e.format(t.name()));
		}
		displayEvasion(t) {
			let e;
			t.result().physical
				? ((e = TextManager.evasion), this.push('performEvasion', t))
				: ((e = TextManager.magicEvasion), this.push('performMagicEvasion', t)),
				this.push('addText', e.format(t.name()));
		}
		displayHpDamage(t) {
			t.result().hpAffected &&
				(t.result().hpDamage > 0 &&
					!t.result().drain &&
					this.push('performDamage', t),
				t.result().hpDamage < 0 && this.push('performRecovery', t),
				this.push('addText', this.makeHpDamageText(t)));
		}
		displayMpDamage(t) {
			t.isAlive() &&
				0 !== t.result().mpDamage &&
				(t.result().mpDamage < 0 && this.push('performRecovery', t),
				this.push('addText', this.makeMpDamageText(t)));
		}
		displayTpDamage(t) {
			t.isAlive() &&
				0 !== t.result().tpDamage &&
				(t.result().tpDamage < 0 && this.push('performRecovery', t),
				this.push('addText', this.makeTpDamageText(t)));
		}
		displayAffectedStatus(t) {
			t.result().isStatusAffected() &&
				(this.push('pushBaseLine'),
				this.displayChangedStates(t),
				this.displayChangedBuffs(t),
				this.push('waitForNewLine'),
				this.push('popBaseLine'));
		}
		displayAutoAffectedStatus(t) {
			t.result().isStatusAffected() &&
				(this.displayAffectedStatus(t, null), this.push('clear'));
		}
		displayChangedStates(t) {
			this.displayAddedStates(t), this.displayRemovedStates(t);
		}
		displayAddedStates(t) {
			t.result()
				.addedStateObjects()
				.forEach(function ({ message1: e, message2: i, id: r }) {
					const s = t.isActor() ? e : i;
					r === t.deathStateId() && this.push('performCollapse', t),
						s &&
							(this.push('popBaseLine'),
							this.push('pushBaseLine'),
							this.push('addText', t.name() + s),
							this.push('waitForEffect'));
				}, this);
		}
		displayRemovedStates(t) {
			t.result()
				.removedStateObjects()
				.forEach(function ({ message4: e }) {
					e &&
						(this.push('popBaseLine'),
						this.push('pushBaseLine'),
						this.push('addText', t.name() + e));
				}, this);
		}
		displayChangedBuffs(t) {
			const e = t.result();
			this.displayBuffs(t, e.addedBuffs, TextManager.buffAdd),
				this.displayBuffs(t, e.addedDebuffs, TextManager.debuffAdd),
				this.displayBuffs(t, e.removedBuffs, TextManager.buffRemove);
		}
		displayBuffs(t, e, i) {
			e.forEach(function (e) {
				this.push('popBaseLine'),
					this.push('pushBaseLine'),
					this.push('addText', i.format(t.name(), TextManager.param(e)));
			}, this);
		}
		makeHpDamageText(t) {
			const e = t.result(),
				i = e.hpDamage,
				r = t.isActor();
			let s;
			return i > 0 && e.drain
				? ((s = r ? TextManager.actorDrain : TextManager.enemyDrain),
				  s.format(t.name(), TextManager.hp, i))
				: i > 0
				? ((s = r ? TextManager.actorDamage : TextManager.enemyDamage),
				  s.format(t.name(), i))
				: i < 0
				? ((s = r ? TextManager.actorRecovery : TextManager.enemyRecovery),
				  s.format(t.name(), TextManager.hp, -i))
				: ((s = r ? TextManager.actorNoDamage : TextManager.enemyNoDamage),
				  s.format(t.name()));
		}
		makeMpDamageText(t) {
			const e = t.result(),
				i = e.mpDamage,
				r = t.isActor();
			let s;
			return i > 0 && e.drain
				? ((s = r ? TextManager.actorDrain : TextManager.enemyDrain),
				  s.format(t.name(), TextManager.mp, i))
				: i > 0
				? ((s = r ? TextManager.actorLoss : TextManager.enemyLoss),
				  s.format(t.name(), TextManager.mp, i))
				: i < 0
				? ((s = r ? TextManager.actorRecovery : TextManager.enemyRecovery),
				  s.format(t.name(), TextManager.mp, -i))
				: '';
		}
		makeTpDamageText(t) {
			const e = t.result().tpDamage,
				i = t.isActor();
			let r;
			return e > 0
				? ((r = i ? TextManager.actorLoss : TextManager.enemyLoss),
				  r.format(t.name(), TextManager.tp, e))
				: e < 0
				? ((r = i ? TextManager.actorGain : TextManager.enemyGain),
				  r.format(t.name(), TextManager.tp, -e))
				: '';
		}
	}
	class Window_PartyCommand extends Window_Command {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			const t = Graphics.boxHeight - this.windowHeight();
			super.initialize(0, t), (this.openness = 0), this.deactivate();
		}
		windowWidth() {
			return 192;
		}
		numVisibleRows() {
			return 4;
		}
		makeCommandList() {
			this.addCommand(TextManager.fight, 'fight'),
				this.addCommand(
					TextManager.escape,
					'escape',
					BattleManager.canEscape()
				);
		}
		setup() {
			this.clearCommandList(),
				this.makeCommandList(),
				this.refresh(),
				this.select(0),
				this.activate(),
				this.open();
		}
	}
	class ConfigManager {
		constructor() {
			throw new Error('This is a static class');
		}
		static async load() {
			let t,
				e = {};
			try {
				t = await StorageManagerShim.load(-1);
			} catch (t) {}
			t && (e = JSON.parse(t)), this.applyData(e);
		}
		static save() {
			StorageManagerShim.save(-1, JSON.stringify(this.makeData()));
		}
		static makeData() {
			const t = {};
			return (
				(t.alwaysDash = this.alwaysDash),
				(t.commandRemember = this.commandRemember),
				(t.bgmVolume = this.bgmVolume),
				(t.bgsVolume = this.bgsVolume),
				(t.meVolume = this.meVolume),
				(t.seVolume = this.seVolume),
				t
			);
		}
		static applyData(t) {
			(this.alwaysDash = this.readFlag(t, 'alwaysDash')),
				(this.commandRemember = this.readFlag(t, 'commandRemember')),
				(this.bgmVolume = this.readVolume(t, 'bgmVolume')),
				(this.bgsVolume = this.readVolume(t, 'bgsVolume')),
				(this.meVolume = this.readVolume(t, 'meVolume')),
				(this.seVolume = this.readVolume(t, 'seVolume'));
		}
		static readFlag(t, e) {
			return !!t[e];
		}
		static readVolume(t, e) {
			const i = t[e];
			return void 0 !== i ? Number(i).clamp(0, 100) : 100;
		}
	}
	(ConfigManager.alwaysDash = !1),
		(ConfigManager.commandRemember = !1),
		Object.defineProperty(ConfigManager, 'bgmVolume', {
			get: () => AudioManager._bgmVolume,
			set(t) {
				AudioManager.bgmVolume = t;
			},
			configurable: !0,
		}),
		Object.defineProperty(ConfigManager, 'bgsVolume', {
			get: () => AudioManager.bgsVolume,
			set(t) {
				AudioManager.bgsVolume = t;
			},
			configurable: !0,
		}),
		Object.defineProperty(ConfigManager, 'meVolume', {
			get: () => AudioManager.meVolume,
			set(t) {
				AudioManager.meVolume = t;
			},
			configurable: !0,
		}),
		Object.defineProperty(ConfigManager, 'seVolume', {
			get: () => AudioManager.seVolume,
			set(t) {
				AudioManager.seVolume = t;
			},
			configurable: !0,
		});
	class Window_ActorCommand extends Window_Command {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			const t = Graphics.boxHeight - this.windowHeight();
			super.initialize(0, t),
				(this.openness = 0),
				this.deactivate(),
				(this._actor = null);
		}
		windowWidth() {
			return 192;
		}
		numVisibleRows() {
			return 4;
		}
		makeCommandList() {
			this._actor &&
				(this.addAttackCommand(),
				this.addSkillCommands(),
				this.addGuardCommand(),
				this.addItemCommand());
		}
		addAttackCommand() {
			this.addCommand(TextManager.attack, 'attack', this._actor.canAttack());
		}
		addSkillCommands() {
			const t = this._actor.addedSkillTypes();
			t.sort((t, e) => t - e),
				t.forEach(function (t) {
					const e = self.$dataSystem.skillTypes[t];
					this.addCommand(e, 'skill', !0, t);
				}, this);
		}
		addGuardCommand() {
			this.addCommand(TextManager.guard, 'guard', this._actor.canGuard());
		}
		addItemCommand() {
			this.addCommand(TextManager.item, 'item');
		}
		setup(t) {
			(this._actor = t),
				this.clearCommandList(),
				this.makeCommandList(),
				this.refresh(),
				this.selectLast(),
				this.activate(),
				this.open();
		}
		processOk() {
			this._actor &&
				(ConfigManager.commandRemember
					? this._actor.setLastCommandSymbol(this.currentSymbol())
					: this._actor.setLastCommandSymbol('')),
				super.processOk();
		}
		selectLast() {
			if ((this.select(0), this._actor && ConfigManager.commandRemember)) {
				const t = this._actor.lastCommandSymbol();
				if ((this.selectSymbol(t), 'skill' === t)) {
					const t = this._actor.lastBattleSkill();
					t && this.selectExt(t.stypeId);
				}
			}
		}
	}
	class Window_BattleStatus extends Window_Selectable {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			const t = this.windowWidth(),
				e = this.windowHeight(),
				i = Graphics.boxWidth - t,
				r = Graphics.boxHeight - e;
			super.initialize(i, r, t, e), this.refresh(), (this.openness = 0);
		}
		windowWidth() {
			return Graphics.boxWidth - 192;
		}
		windowHeight() {
			return this.fittingHeight(this.numVisibleRows());
		}
		numVisibleRows() {
			return 4;
		}
		maxItems() {
			return self.$gameParty.battleMembers().length;
		}
		refresh() {
			this.contents.clear(), this.drawAllItems();
		}
		drawItem(t) {
			const e = self.$gameParty.battleMembers()[t];
			this.drawBasicArea(this.basicAreaRect(t), e),
				this.drawGaugeArea(this.gaugeAreaRect(t), e);
		}
		basicAreaRect(t) {
			const e = this.itemRectForText(t);
			return (e.width -= this.gaugeAreaWidth() + 15), e;
		}
		gaugeAreaRect(t) {
			const e = this.itemRectForText(t);
			return (
				(e.x += e.width - this.gaugeAreaWidth()),
				(e.width = this.gaugeAreaWidth()),
				e
			);
		}
		gaugeAreaWidth() {
			return 330;
		}
		drawBasicArea({ x: t, y: e, width: i }, r) {
			this.drawActorName(r, t + 0, e, 150),
				this.drawActorIcons(r, t + 156, e, i - 156);
		}
		drawGaugeArea(t, e) {
			self.$dataSystem.optDisplayTp
				? this.drawGaugeAreaWithTp(t, e)
				: this.drawGaugeAreaWithoutTp(t, e);
		}
		drawGaugeAreaWithTp({ x: t, y: e }, i) {
			this.drawActorHp(i, t + 0, e, 108),
				this.drawActorMp(i, t + 123, e, 96),
				this.drawActorTp(i, t + 234, e, 96);
		}
		drawGaugeAreaWithoutTp({ x: t, y: e }, i) {
			this.drawActorHp(i, t + 0, e, 201), this.drawActorMp(i, t + 216, e, 114);
		}
	}
	class Window_BattleActor extends Window_BattleStatus {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e) {
			super.initialize(),
				(this.x = t),
				(this.y = e),
				(this.openness = 255),
				this.hide();
		}
		show() {
			this.select(0), super.show();
		}
		hide() {
			super.hide(), self.$gameParty.select(null);
		}
		select(t) {
			super.select(t), self.$gameParty.select(this.actor());
		}
		actor() {
			return self.$gameParty.members()[this.index()];
		}
	}
	class Window_BattleEnemy extends Window_Selectable {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e) {
			this._enemies = [];
			const i = this.windowWidth(),
				r = this.windowHeight();
			super.initialize(t, e, i, r), this.refresh(), this.hide();
		}
		windowWidth() {
			return Graphics.boxWidth - 192;
		}
		windowHeight() {
			return this.fittingHeight(this.numVisibleRows());
		}
		numVisibleRows() {
			return 4;
		}
		maxCols() {
			return 2;
		}
		maxItems() {
			return this._enemies.length;
		}
		enemy() {
			return this._enemies[this.index()];
		}
		enemyIndex() {
			const t = this.enemy();
			return t ? t.index() : -1;
		}
		drawItem(t) {
			this.resetTextColor();
			const e = this._enemies[t].name(),
				i = this.itemRectForText(t);
			this.drawText(e, i.x, i.y, i.width);
		}
		show() {
			this.refresh(), this.select(0), super.show();
		}
		hide() {
			super.hide(), self.$gameTroop.select(null);
		}
		refresh() {
			(this._enemies = self.$gameTroop.aliveMembers()), super.refresh();
		}
		select(t) {
			super.select(t), self.$gameTroop.select(this.enemy());
		}
	}
	class Window_SkillList extends Window_Selectable {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e, i, r) {
			super.initialize(t, e, i, r),
				(this._actor = null),
				(this._stypeId = 0),
				(this._data = []);
		}
		setActor(t) {
			this._actor !== t &&
				((this._actor = t), this.refresh(), this.resetScroll());
		}
		setStypeId(t) {
			this._stypeId !== t &&
				((this._stypeId = t), this.refresh(), this.resetScroll());
		}
		maxCols() {
			return 2;
		}
		spacing() {
			return 48;
		}
		maxItems() {
			return this._data ? this._data.length : 1;
		}
		item() {
			return this._data && this.index() >= 0 ? this._data[this.index()] : null;
		}
		isCurrentItemEnabled() {
			return this.isEnabled(this._data[this.index()]);
		}
		includes(t) {
			return t && t.stypeId === this._stypeId;
		}
		isEnabled(t) {
			return this._actor && this._actor.canUse(t);
		}
		makeItemList() {
			this._actor
				? (this._data = this._actor.skills().filter(function (t) {
						return this.includes(t);
				  }, this))
				: (this._data = []);
		}
		selectLast() {
			let t;
			t = self.$gameParty.inBattle()
				? this._actor.lastBattleSkill()
				: this._actor.lastMenuSkill();
			const e = this._data.indexOf(t);
			this.select(e >= 0 ? e : 0);
		}
		drawItem(t) {
			const e = this._data[t];
			if (e) {
				const i = this.costWidth(),
					r = this.itemRect(t);
				(r.width -= this.textPadding()),
					this.changePaintOpacity(this.isEnabled(e)),
					this.drawItemName(e, r.x, r.y, r.width - i),
					this.drawSkillCost(e, r.x, r.y, r.width),
					this.changePaintOpacity(1);
			}
		}
		costWidth() {
			return this.textWidth('000');
		}
		drawSkillCost(t, e, i, r) {
			this._actor.skillTpCost(t) > 0
				? (this.changeTextColor(this.tpCostColor()),
				  this.drawText(this._actor.skillTpCost(t), e, i, r, 'right'))
				: this._actor.skillMpCost(t) > 0 &&
				  (this.changeTextColor(this.mpCostColor()),
				  this.drawText(this._actor.skillMpCost(t), e, i, r, 'right'));
		}
		updateHelp() {
			this.setHelpWindowItem(this.item());
		}
		refresh() {
			this.makeItemList(), this.createContents(), this.drawAllItems();
		}
	}
	class Window_BattleSkill extends Window_SkillList {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e, i, r) {
			super.initialize(t, e, i, r), this.hide();
		}
		show() {
			this.selectLast(), this.showHelpWindow(), super.show();
		}
		hide() {
			this.hideHelpWindow(), super.hide();
		}
	}
	class Window_BattleItem extends Window_ItemList {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e, i, r) {
			super.initialize(t, e, i, r), this.hide();
		}
		includes(t) {
			return self.$gameParty.canUse(t);
		}
		show() {
			this.selectLast(), this.showHelpWindow(), super.show();
		}
		hide() {
			this.hideHelpWindow(), super.hide();
		}
	}
	class Scene_Battle extends Scene_Base {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize();
		}
		create() {
			super.create(), this.createDisplayObjects();
		}
		start() {
			super.start(),
				this.startFadeIn(this.fadeSpeed(), !1),
				BattleManager.playBattleBgm(),
				BattleManager.startBattle();
		}
		update() {
			const t = this.isActive();
			self.$gameTimer.update(t),
				self.$gameScreen.update(),
				this.updateStatusWindow(),
				this.updateWindowPositions(),
				t && !this.isBusy() && this.updateBattleProcess(),
				super.update();
		}
		updateBattleProcess() {
			(!this.isAnyInputWindowActive() ||
				BattleManager.isAborting() ||
				BattleManager.isBattleEnd()) &&
				(BattleManager.update(), this.changeInputWindow());
		}
		isAnyInputWindowActive() {
			return (
				this._partyCommandWindow.active ||
				this._actorCommandWindow.active ||
				this._skillWindow.active ||
				this._itemWindow.active ||
				this._actorWindow.active ||
				this._enemyWindow.active
			);
		}
		changeInputWindow() {
			BattleManager.isInputting()
				? BattleManager.actor()
					? this.startActorCommandSelection()
					: this.startPartyCommandSelection()
				: this.endCommandSelection();
		}
		stop() {
			super.stop(),
				this.needsSlowFadeOut()
					? this.startFadeOut(this.slowFadeSpeed(), !1)
					: this.startFadeOut(this.fadeSpeed(), !1),
				this._statusWindow.close(),
				this._partyCommandWindow.close(),
				this._actorCommandWindow.close();
		}
		terminate() {
			super.terminate(),
				self.$gameParty.onBattleEnd(),
				self.$gameTroop.onBattleEnd(),
				AudioManager.stopMe(),
				ImageManager.clearRequest();
		}
		needsSlowFadeOut() {
			return (
				SceneManager.isNextScene(Scene_Title) ||
				SceneManager.isNextScene(Scene_Gameover)
			);
		}
		updateStatusWindow() {
			self.$gameMessage.isBusy()
				? (this._statusWindow.close(),
				  this._partyCommandWindow.close(),
				  this._actorCommandWindow.close())
				: this.isActive() &&
				  !this._messageWindow.isClosing() &&
				  this._statusWindow.open();
		}
		updateWindowPositions() {
			let t = 0;
			(t = BattleManager.isInputting()
				? this._partyCommandWindow.width
				: this._partyCommandWindow.width / 2),
				this._statusWindow.x < t &&
					((this._statusWindow.x += 16),
					this._statusWindow.x > t && (this._statusWindow.x = t)),
				this._statusWindow.x > t &&
					((this._statusWindow.x -= 16),
					this._statusWindow.x < t && (this._statusWindow.x = t));
		}
		createDisplayObjects() {
			this.createSpriteset(),
				this.createWindowLayer(),
				this.createAllWindows(),
				BattleManager.setLogWindow(this._logWindow),
				BattleManager.setStatusWindow(this._statusWindow),
				BattleManager.setSpriteset(this._spriteset),
				this._logWindow.setSpriteset(this._spriteset);
		}
		createSpriteset() {
			(this._spriteset = new Spriteset_Battle()),
				this.addChild(this._spriteset);
		}
		createAllWindows() {
			this.createLogWindow(),
				this.createStatusWindow(),
				this.createPartyCommandWindow(),
				this.createActorCommandWindow(),
				this.createHelpWindow(),
				this.createSkillWindow(),
				this.createItemWindow(),
				this.createActorWindow(),
				this.createEnemyWindow(),
				this.createMessageWindow(),
				this.createScrollTextWindow();
		}
		createLogWindow() {
			(this._logWindow = new Window_BattleLog()),
				this.addWindow(this._logWindow);
		}
		createStatusWindow() {
			(this._statusWindow = new Window_BattleStatus()),
				this.addWindow(this._statusWindow);
		}
		createPartyCommandWindow() {
			(this._partyCommandWindow = new Window_PartyCommand()),
				this._partyCommandWindow.setHandler(
					'fight',
					this.commandFight.bind(this)
				),
				this._partyCommandWindow.setHandler(
					'escape',
					this.commandEscape.bind(this)
				),
				this._partyCommandWindow.deselect(),
				this.addWindow(this._partyCommandWindow);
		}
		createActorCommandWindow() {
			(this._actorCommandWindow = new Window_ActorCommand()),
				this._actorCommandWindow.setHandler(
					'attack',
					this.commandAttack.bind(this)
				),
				this._actorCommandWindow.setHandler(
					'skill',
					this.commandSkill.bind(this)
				),
				this._actorCommandWindow.setHandler(
					'guard',
					this.commandGuard.bind(this)
				),
				this._actorCommandWindow.setHandler(
					'item',
					this.commandItem.bind(this)
				),
				this._actorCommandWindow.setHandler(
					'cancel',
					this.selectPreviousCommand.bind(this)
				),
				this.addWindow(this._actorCommandWindow);
		}
		createHelpWindow() {
			(this._helpWindow = new Window_Help()),
				(this._helpWindow.visible = !1),
				this.addWindow(this._helpWindow);
		}
		createSkillWindow() {
			const t = this._helpWindow.y + this._helpWindow.height,
				e = this._statusWindow.y - t;
			(this._skillWindow = new Window_BattleSkill(0, t, Graphics.boxWidth, e)),
				this._skillWindow.setHelpWindow(this._helpWindow),
				this._skillWindow.setHandler('ok', this.onSkillOk.bind(this)),
				this._skillWindow.setHandler('cancel', this.onSkillCancel.bind(this)),
				this.addWindow(this._skillWindow);
		}
		createItemWindow() {
			const t = this._helpWindow.y + this._helpWindow.height,
				e = this._statusWindow.y - t;
			(this._itemWindow = new Window_BattleItem(0, t, Graphics.boxWidth, e)),
				this._itemWindow.setHelpWindow(this._helpWindow),
				this._itemWindow.setHandler('ok', this.onItemOk.bind(this)),
				this._itemWindow.setHandler('cancel', this.onItemCancel.bind(this)),
				this.addWindow(this._itemWindow);
		}
		createActorWindow() {
			(this._actorWindow = new Window_BattleActor(0, this._statusWindow.y)),
				this._actorWindow.setHandler('ok', this.onActorOk.bind(this)),
				this._actorWindow.setHandler('cancel', this.onActorCancel.bind(this)),
				this.addWindow(this._actorWindow);
		}
		createEnemyWindow() {
			(this._enemyWindow = new Window_BattleEnemy(0, this._statusWindow.y)),
				(this._enemyWindow.x = Graphics.boxWidth - this._enemyWindow.width),
				this._enemyWindow.setHandler('ok', this.onEnemyOk.bind(this)),
				this._enemyWindow.setHandler('cancel', this.onEnemyCancel.bind(this)),
				this.addWindow(this._enemyWindow);
		}
		createMessageWindow() {
			(this._messageWindow = new Window_Message()),
				this.addWindow(this._messageWindow),
				this._messageWindow.subWindows().forEach(function (t) {
					this.addWindow(t);
				}, this);
		}
		createScrollTextWindow() {
			(this._scrollTextWindow = new Window_ScrollText()),
				this.addWindow(this._scrollTextWindow);
		}
		refreshStatus() {
			this._statusWindow.refresh();
		}
		startPartyCommandSelection() {
			this.refreshStatus(),
				this._statusWindow.deselect(),
				this._statusWindow.open(),
				this._actorCommandWindow.close(),
				this._partyCommandWindow.setup();
		}
		commandFight() {
			this.selectNextCommand();
		}
		commandEscape() {
			BattleManager.processEscape(), this.changeInputWindow();
		}
		startActorCommandSelection() {
			this._statusWindow.select(BattleManager.actor().index()),
				this._partyCommandWindow.close(),
				this._actorCommandWindow.setup(BattleManager.actor());
		}
		commandAttack() {
			BattleManager.inputtingAction().setAttack(), this.selectEnemySelection();
		}
		commandSkill() {
			this._skillWindow.setActor(BattleManager.actor()),
				this._skillWindow.setStypeId(this._actorCommandWindow.currentExt()),
				this._skillWindow.refresh(),
				this._skillWindow.show(),
				this._skillWindow.activate();
		}
		commandGuard() {
			BattleManager.inputtingAction().setGuard(), this.selectNextCommand();
		}
		commandItem() {
			this._itemWindow.refresh(),
				this._itemWindow.show(),
				this._itemWindow.activate();
		}
		selectNextCommand() {
			BattleManager.selectNextCommand(), this.changeInputWindow();
		}
		selectPreviousCommand() {
			BattleManager.selectPreviousCommand(), this.changeInputWindow();
		}
		selectActorSelection() {
			this._actorWindow.refresh(),
				this._actorWindow.show(),
				this._actorWindow.activate();
		}
		onActorOk() {
			BattleManager.inputtingAction().setTarget(this._actorWindow.index()),
				this._actorWindow.hide(),
				this._skillWindow.hide(),
				this._itemWindow.hide(),
				this.selectNextCommand();
		}
		onActorCancel() {
			switch (
				(this._actorWindow.hide(), this._actorCommandWindow.currentSymbol())
			) {
				case 'skill':
					this._skillWindow.show(), this._skillWindow.activate();
					break;
				case 'item':
					this._itemWindow.show(), this._itemWindow.activate();
			}
		}
		selectEnemySelection() {
			this._enemyWindow.refresh(),
				this._enemyWindow.show(),
				this._enemyWindow.select(0),
				this._enemyWindow.activate();
		}
		onEnemyOk() {
			BattleManager.inputtingAction().setTarget(this._enemyWindow.enemyIndex()),
				this._enemyWindow.hide(),
				this._skillWindow.hide(),
				this._itemWindow.hide(),
				this.selectNextCommand();
		}
		onEnemyCancel() {
			switch (
				(this._enemyWindow.hide(), this._actorCommandWindow.currentSymbol())
			) {
				case 'attack':
					this._actorCommandWindow.activate();
					break;
				case 'skill':
					this._skillWindow.show(), this._skillWindow.activate();
					break;
				case 'item':
					this._itemWindow.show(), this._itemWindow.activate();
			}
		}
		onSkillOk() {
			const t = this._skillWindow.item();
			BattleManager.inputtingAction().setSkill(t.id),
				BattleManager.actor().setLastBattleSkill(t),
				this.onSelectAction();
		}
		onSkillCancel() {
			this._skillWindow.hide(), this._actorCommandWindow.activate();
		}
		onItemOk() {
			const t = this._itemWindow.item();
			BattleManager.inputtingAction().setItem(t.id),
				self.$gameParty.setLastItem(t),
				this.onSelectAction();
		}
		onItemCancel() {
			this._itemWindow.hide(), this._actorCommandWindow.activate();
		}
		onSelectAction() {
			const t = BattleManager.inputtingAction();
			this._skillWindow.hide(),
				this._itemWindow.hide(),
				t.needsSelection()
					? t.isForOpponent()
						? this.selectEnemySelection()
						: this.selectActorSelection()
					: this.selectNextCommand();
		}
		endCommandSelection() {
			this._partyCommandWindow.close(),
				this._actorCommandWindow.close(),
				this._statusWindow.deselect();
		}
	}
	class Scene_MenuBase extends Scene_Base {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize();
		}
		create() {
			super.create(),
				this.createBackground(),
				this.updateActor(),
				this.createWindowLayer();
		}
		actor() {
			return this._actor;
		}
		updateActor() {
			this._actor = self.$gameParty.menuActor();
		}
		createBackground() {
			(this._backgroundSprite = new Sprite()),
				(this._backgroundSprite.bitmap = SceneManager.backgroundBitmap()),
				this.addChild(this._backgroundSprite);
		}
		setBackgroundOpacity(t) {
			this._backgroundSprite.opacity = t;
		}
		createHelpWindow() {
			(this._helpWindow = new Window_Help()), this.addWindow(this._helpWindow);
		}
		nextActor() {
			self.$gameParty.makeMenuActorNext(),
				this.updateActor(),
				this.onActorChange();
		}
		previousActor() {
			self.$gameParty.makeMenuActorPrevious(),
				this.updateActor(),
				this.onActorChange();
		}
		onActorChange() {}
	}
	class Window_MenuCommand extends Window_Command {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e) {
			super.initialize(t, e), this.selectLast();
		}
		static initCommandPosition() {
			this._lastCommandSymbol = null;
		}
		windowWidth() {
			return 240;
		}
		numVisibleRows() {
			return this.maxItems();
		}
		makeCommandList() {
			this.addMainCommands(),
				this.addFormationCommand(),
				this.addOriginalCommands(),
				this.addOptionsCommand(),
				this.addSaveCommand(),
				this.addGameEndCommand();
		}
		addMainCommands() {
			const t = this.areMainCommandsEnabled();
			this.needsCommand('item') && this.addCommand(TextManager.item, 'item', t),
				this.needsCommand('skill') &&
					this.addCommand(TextManager.skill, 'skill', t),
				this.needsCommand('equip') &&
					this.addCommand(TextManager.equip, 'equip', t),
				this.needsCommand('status') &&
					this.addCommand(TextManager.status, 'status', t);
		}
		addFormationCommand() {
			if (this.needsCommand('formation')) {
				const t = this.isFormationEnabled();
				this.addCommand(TextManager.formation, 'formation', t);
			}
		}
		addOriginalCommands() {}
		addOptionsCommand() {
			if (this.needsCommand('options')) {
				const t = this.isOptionsEnabled();
				this.addCommand(TextManager.options, 'options', t);
			}
		}
		addSaveCommand() {
			if (this.needsCommand('save')) {
				const t = this.isSaveEnabled();
				this.addCommand(TextManager.save, 'save', t);
			}
		}
		addGameEndCommand() {
			const t = this.isGameEndEnabled();
			this.addCommand(TextManager.gameEnd, 'gameEnd', t);
		}
		needsCommand(t) {
			const e = self.$dataSystem.menuCommands;
			if (e)
				switch (t) {
					case 'item':
						return e[0];
					case 'skill':
						return e[1];
					case 'equip':
						return e[2];
					case 'status':
						return e[3];
					case 'formation':
						return e[4];
					case 'save':
						return e[5];
				}
			return !0;
		}
		areMainCommandsEnabled() {
			return self.$gameParty.exists();
		}
		isFormationEnabled() {
			return (
				self.$gameParty.size() >= 2 && self.$gameSystem.isFormationEnabled()
			);
		}
		isOptionsEnabled() {
			return !0;
		}
		isSaveEnabled() {
			return !DataManager$1.isEventTest() && self.$gameSystem.isSaveEnabled();
		}
		isGameEndEnabled() {
			return !0;
		}
		processOk() {
			(Window_MenuCommand._lastCommandSymbol = this.currentSymbol()),
				super.processOk();
		}
		selectLast() {
			this.selectSymbol(Window_MenuCommand._lastCommandSymbol);
		}
	}
	Window_MenuCommand._lastCommandSymbol = null;
	class Window_MenuStatus extends Window_Selectable {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e) {
			const i = this.windowWidth(),
				r = this.windowHeight();
			super.initialize(t, e, i, r),
				(this._formationMode = !1),
				(this._pendingIndex = -1),
				this.refresh();
		}
		windowWidth() {
			return Graphics.boxWidth - 240;
		}
		windowHeight() {
			return Graphics.boxHeight;
		}
		maxItems() {
			return self.$gameParty.size();
		}
		itemHeight() {
			const t = this.height - 2 * this.padding;
			return Math.floor(t / this.numVisibleRows());
		}
		numVisibleRows() {
			return 4;
		}
		loadImages() {
			self.$gameParty.members().forEach((t) => {
				ImageManager.reserveFace(t.faceName());
			}, this);
		}
		drawItem(t) {
			this.drawItemBackground(t), this.drawItemImage(t), this.drawItemStatus(t);
		}
		drawItemBackground(t) {
			if (t === this._pendingIndex) {
				const e = this.itemRect(t),
					i = this.pendingColor();
				this.changePaintOpacity(!1),
					this.contents.fillRect(e.x, e.y, e.width, e.height, i),
					this.changePaintOpacity(!0);
			}
		}
		drawItemImage(t) {
			const e = self.$gameParty.members()[t],
				i = this.itemRect(t);
			this.changePaintOpacity(e.isBattleMember()),
				this.drawActorFace(
					e,
					i.x + 1,
					i.y + 1,
					Window_Base._faceWidth,
					Window_Base._faceHeight
				),
				this.changePaintOpacity(!0);
		}
		drawItemStatus(t) {
			const e = self.$gameParty.members()[t],
				i = this.itemRect(t),
				r = i.x + 162,
				s = i.y + i.height / 2 - 1.5 * this.lineHeight(),
				n = i.width - r - this.textPadding();
			this.drawActorSimpleStatus(e, r, s, n);
		}
		processOk() {
			super.processOk(),
				self.$gameParty.setMenuActor(self.$gameParty.members()[this.index()]);
		}
		isCurrentItemEnabled() {
			if (this._formationMode) {
				const t = self.$gameParty.members()[this.index()];
				return t && t.isFormationChangeOk();
			}
			return !0;
		}
		selectLast() {
			this.select(self.$gameParty.menuActor().index() || 0);
		}
		formationMode() {
			return this._formationMode;
		}
		setFormationMode(t) {
			this._formationMode = t;
		}
		pendingIndex() {
			return this._pendingIndex;
		}
		setPendingIndex(t) {
			const e = this._pendingIndex;
			(this._pendingIndex = t),
				this.redrawItem(this._pendingIndex),
				this.redrawItem(e);
		}
	}
	class Window_MenuActor extends Window_MenuStatus {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize(0, 0), this.hide();
		}
		processOk() {
			this.cursorAll() ||
				self.$gameParty.setTargetActor(self.$gameParty.members()[this.index()]),
				this.callOkHandler();
		}
		selectLast() {
			this.select(self.$gameParty.targetActor().index() || 0);
		}
		selectForItem(t) {
			const e = self.$gameParty.menuActor(),
				i = new Game_Action(e);
			i.setItemObject(t),
				this.setCursorFixed(!1),
				this.setCursorAll(!1),
				i.isForUser()
					? DataManager$1.isSkill(t)
						? (this.setCursorFixed(!0), this.select(e.index()))
						: this.selectLast()
					: i.isForAll()
					? (this.setCursorAll(!0), this.select(0))
					: this.selectLast();
		}
	}
	class Scene_ItemBase extends Scene_MenuBase {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize();
		}
		create() {
			super.create();
		}
		createActorWindow() {
			(this._actorWindow = new Window_MenuActor()),
				this._actorWindow.setHandler('ok', this.onActorOk.bind(this)),
				this._actorWindow.setHandler('cancel', this.onActorCancel.bind(this)),
				this.addWindow(this._actorWindow);
		}
		item() {
			return this._itemWindow.item();
		}
		user() {
			return null;
		}
		isCursorLeft() {
			return this._itemWindow.index() % 2 == 0;
		}
		showSubWindow(t) {
			(t.x = this.isCursorLeft() ? Graphics.boxWidth - t.width : 0),
				t.show(),
				t.activate();
		}
		hideSubWindow(t) {
			t.hide(), t.deactivate(), this.activateItemWindow();
		}
		onActorOk() {
			this.canUse() ? this.useItem() : SoundManager.playBuzzer();
		}
		onActorCancel() {
			this.hideSubWindow(this._actorWindow);
		}
		action() {
			const t = new Game_Action(this.user());
			return t.setItemObject(this.item()), t;
		}
		determineItem() {
			this.action().isForFriend()
				? (this.showSubWindow(this._actorWindow),
				  this._actorWindow.selectForItem(this.item()))
				: (this.useItem(), this.activateItemWindow());
		}
		useItem() {
			this.playSeForItem(),
				this.user().useItem(this.item()),
				this.applyItem(),
				this.checkCommonEvent(),
				this.checkGameover(),
				this._actorWindow.refresh();
		}
		activateItemWindow() {
			this._itemWindow.refresh(), this._itemWindow.activate();
		}
		itemTargetActors() {
			const t = this.action();
			return t.isForFriend()
				? t.isForAll()
					? self.$gameParty.members()
					: [self.$gameParty.members()[this._actorWindow.index()]]
				: [];
		}
		canUse() {
			const t = this.user();
			return !!t && t.canUse(this.item()) && this.isItemEffectsValid();
		}
		isItemEffectsValid() {
			const t = this.action();
			return this.itemTargetActors().some((e) => t.testApply(e), this);
		}
		applyItem() {
			const t = this.action();
			this.itemTargetActors().forEach((e) => {
				const i = t.numRepeats();
				for (let r = 0; r < i; r++) t.apply(e);
			}),
				t.applyGlobal();
		}
		checkCommonEvent() {
			self.$gameTemp.isCommonEventReserved() && SceneManager.goto(Scene_Map);
		}
	}
	class Window_HorzCommand extends Window_Command {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e) {
			super.initialize(t, e);
		}
		numVisibleRows() {
			return 1;
		}
		maxCols() {
			return 4;
		}
		itemTextAlign() {
			return 'center';
		}
	}
	class Window_ItemCategory extends Window_HorzCommand {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize(0, 0);
		}
		windowWidth() {
			return Graphics.boxWidth;
		}
		maxCols() {
			return 4;
		}
		update() {
			super.update(),
				this._itemWindow && this._itemWindow.setCategory(this.currentSymbol());
		}
		makeCommandList() {
			this.addCommand(TextManager.item, 'item'),
				this.addCommand(TextManager.weapon, 'weapon'),
				this.addCommand(TextManager.armor, 'armor'),
				this.addCommand(TextManager.keyItem, 'keyItem');
		}
		setItemWindow(t) {
			this._itemWindow = t;
		}
	}
	class Scene_Item extends Scene_ItemBase {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize();
		}
		create() {
			super.create(),
				this.createHelpWindow(),
				this.createCategoryWindow(),
				this.createItemWindow(),
				this.createActorWindow();
		}
		createCategoryWindow() {
			(this._categoryWindow = new Window_ItemCategory()),
				this._categoryWindow.setHelpWindow(this._helpWindow),
				(this._categoryWindow.y = this._helpWindow.height),
				this._categoryWindow.setHandler('ok', this.onCategoryOk.bind(this)),
				this._categoryWindow.setHandler('cancel', this.popScene.bind(this)),
				this.addWindow(this._categoryWindow);
		}
		createItemWindow() {
			const t = this._categoryWindow.y + this._categoryWindow.height,
				e = Graphics.boxHeight - t;
			(this._itemWindow = new Window_ItemList(0, t, Graphics.boxWidth, e)),
				this._itemWindow.setHelpWindow(this._helpWindow),
				this._itemWindow.setHandler('ok', this.onItemOk.bind(this)),
				this._itemWindow.setHandler('cancel', this.onItemCancel.bind(this)),
				this.addWindow(this._itemWindow),
				this._categoryWindow.setItemWindow(this._itemWindow);
		}
		user() {
			const t = self.$gameParty.movableMembers();
			let e = t[0],
				i = 0;
			for (let r = 0; r < t.length; r++)
				t[r].pha > i && ((i = t[r].pha), (e = t[r]));
			return e;
		}
		onCategoryOk() {
			this._itemWindow.activate(), this._itemWindow.selectLast();
		}
		onItemOk() {
			self.$gameParty.setLastItem(this.item()), this.determineItem();
		}
		onItemCancel() {
			this._itemWindow.deselect(), this._categoryWindow.activate();
		}
		playSeForItem() {
			SoundManager.playUseItem();
		}
		useItem() {
			super.useItem(), this._itemWindow.redrawCurrentItem();
		}
	}
	class Window_SkillType extends Window_Command {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e) {
			super.initialize(t, e), (this._actor = null);
		}
		windowWidth() {
			return 240;
		}
		setActor(t) {
			this._actor !== t &&
				((this._actor = t), this.refresh(), this.selectLast());
		}
		numVisibleRows() {
			return 4;
		}
		makeCommandList() {
			if (this._actor) {
				const t = this._actor.addedSkillTypes();
				t.sort((t, e) => t - e),
					t.forEach(function (t) {
						const e = self.$dataSystem.skillTypes[t];
						this.addCommand(e, 'skill', !0, t);
					}, this);
			}
		}
		update() {
			super.update(),
				this._skillWindow && this._skillWindow.setStypeId(this.currentExt());
		}
		setSkillWindow(t) {
			this._skillWindow = t;
		}
		selectLast() {
			const t = this._actor.lastMenuSkill();
			t ? this.selectExt(t.stypeId) : this.select(0);
		}
	}
	class Window_SkillStatus extends Window_Base {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e, i, r) {
			super.initialize(t, e, i, r), (this._actor = null);
		}
		setActor(t) {
			this._actor !== t && ((this._actor = t), this.refresh());
		}
		refresh() {
			if ((this.contents.clear(), this._actor)) {
				const t = this.width - 2 * this.padding,
					e = this.height - 2 * this.padding,
					i = e / 2 - 1.5 * this.lineHeight(),
					r = t - 162 - this.textPadding();
				this.drawActorFace(this._actor, 0, 0, 144, e),
					this.drawActorSimpleStatus(this._actor, 162, i, r);
			}
		}
	}
	class Scene_Skill extends Scene_ItemBase {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize();
		}
		create() {
			super.create(),
				this.createHelpWindow(),
				this.createSkillTypeWindow(),
				this.createStatusWindow(),
				this.createItemWindow(),
				this.createActorWindow();
		}
		start() {
			super.start(), this.refreshActor();
		}
		createSkillTypeWindow() {
			const t = this._helpWindow.height;
			(this._skillTypeWindow = new Window_SkillType(0, t)),
				this._skillTypeWindow.setHelpWindow(this._helpWindow),
				this._skillTypeWindow.setHandler('skill', this.commandSkill.bind(this)),
				this._skillTypeWindow.setHandler('cancel', this.popScene.bind(this)),
				this._skillTypeWindow.setHandler('pagedown', this.nextActor.bind(this)),
				this._skillTypeWindow.setHandler(
					'pageup',
					this.previousActor.bind(this)
				),
				this.addWindow(this._skillTypeWindow);
		}
		createStatusWindow() {
			const t = this._skillTypeWindow.width,
				e = this._helpWindow.height,
				i = Graphics.boxWidth - t,
				r = this._skillTypeWindow.height;
			(this._statusWindow = new Window_SkillStatus(t, e, i, r)),
				this._statusWindow.reserveFaceImages(),
				this.addWindow(this._statusWindow);
		}
		createItemWindow() {
			const t = this._statusWindow.y + this._statusWindow.height,
				e = Graphics.boxWidth,
				i = Graphics.boxHeight - t;
			(this._itemWindow = new Window_SkillList(0, t, e, i)),
				this._itemWindow.setHelpWindow(this._helpWindow),
				this._itemWindow.setHandler('ok', this.onItemOk.bind(this)),
				this._itemWindow.setHandler('cancel', this.onItemCancel.bind(this)),
				this._skillTypeWindow.setSkillWindow(this._itemWindow),
				this.addWindow(this._itemWindow);
		}
		refreshActor() {
			const t = this.actor();
			this._skillTypeWindow.setActor(t),
				this._statusWindow.setActor(t),
				this._itemWindow.setActor(t);
		}
		user() {
			return this.actor();
		}
		commandSkill() {
			this._itemWindow.activate(), this._itemWindow.selectLast();
		}
		onItemOk() {
			this.actor().setLastMenuSkill(this.item()), this.determineItem();
		}
		onItemCancel() {
			this._itemWindow.deselect(), this._skillTypeWindow.activate();
		}
		playSeForItem() {
			SoundManager.playUseSkill();
		}
		useItem() {
			super.useItem(), this._statusWindow.refresh(), this._itemWindow.refresh();
		}
		onActorChange() {
			this.refreshActor(), this._skillTypeWindow.activate();
		}
	}
	class Window_EquipStatus extends Window_Base {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e) {
			const i = this.windowWidth(),
				r = this.windowHeight();
			super.initialize(t, e, i, r),
				(this._actor = null),
				(this._tempActor = null),
				this.refresh();
		}
		windowWidth() {
			return 312;
		}
		windowHeight() {
			return this.fittingHeight(this.numVisibleRows());
		}
		numVisibleRows() {
			return 7;
		}
		setActor(t) {
			this._actor !== t && ((this._actor = t), this.refresh());
		}
		refresh() {
			if ((this.contents.clear(), this._actor)) {
				this.drawActorName(this._actor, this.textPadding(), 0);
				for (let t = 0; t < 6; t++)
					this.drawItem(0, this.lineHeight() * (1 + t), 2 + t);
			}
		}
		setTempActor(t) {
			this._tempActor !== t && ((this._tempActor = t), this.refresh());
		}
		drawItem(t, e, i) {
			this.drawParamName(t + this.textPadding(), e, i),
				this._actor && this.drawCurrentParam(t + 140, e, i),
				this.drawRightArrow(t + 188, e),
				this._tempActor && this.drawNewParam(t + 222, e, i);
		}
		drawParamName(t, e, i) {
			this.changeTextColor(this.systemColor()),
				this.drawText(TextManager.param(i), t, e, 120);
		}
		drawCurrentParam(t, e, i) {
			this.resetTextColor(),
				this.drawText(this._actor.param(i), t, e, 48, 'right');
		}
		drawRightArrow(t, e) {
			this.changeTextColor(this.systemColor()),
				this.drawText('→', t, e, 32, 'center');
		}
		drawNewParam(t, e, i) {
			const r = this._tempActor.param(i),
				s = r - this._actor.param(i);
			this.changeTextColor(this.paramchangeTextColor(s)),
				this.drawText(r, t, e, 48, 'right');
		}
	}
	class Window_EquipCommand extends Window_HorzCommand {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e, i) {
			(this._windowWidth = i), super.initialize(t, e);
		}
		windowWidth() {
			return this._windowWidth;
		}
		maxCols() {
			return 3;
		}
		makeCommandList() {
			this.addCommand(TextManager.equip2, 'equip'),
				this.addCommand(TextManager.optimize, 'optimize'),
				this.addCommand(TextManager.clear, 'clear');
		}
	}
	class Window_EquipSlot extends Window_Selectable {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e, i, r) {
			super.initialize(t, e, i, r), (this._actor = null), this.refresh();
		}
		setActor(t) {
			this._actor !== t && ((this._actor = t), this.refresh());
		}
		update() {
			super.update(),
				this._itemWindow && this._itemWindow.setSlotId(this.index());
		}
		maxItems() {
			return this._actor ? this._actor.equipSlots().length : 0;
		}
		item() {
			return this._actor ? this._actor.equips()[this.index()] : null;
		}
		drawItem(t) {
			if (this._actor) {
				const e = this.itemRectForText(t);
				this.changeTextColor(this.systemColor()),
					this.changePaintOpacity(this.isEnabled(t)),
					this.drawText(this.slotName(t), e.x, e.y, 138, this.lineHeight()),
					this.drawItemName(this._actor.equips()[t], e.x + 138, e.y),
					this.changePaintOpacity(!0);
			}
		}
		slotName(t) {
			const e = this._actor.equipSlots();
			return this._actor ? self.$dataSystem.equipTypes[e[t]] : '';
		}
		isEnabled(t) {
			return !!this._actor && this._actor.isEquipChangeOk(t);
		}
		isCurrentItemEnabled() {
			return this.isEnabled(this.index());
		}
		setStatusWindow(t) {
			(this._statusWindow = t), this.callUpdateHelp();
		}
		setItemWindow(t) {
			this._itemWindow = t;
		}
		updateHelp() {
			super.updateHelp(),
				this.setHelpWindowItem(this.item()),
				this._statusWindow && this._statusWindow.setTempActor(null);
		}
	}
	class Window_EquipItem extends Window_ItemList {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e, i, r) {
			super.initialize(t, e, i, r), (this._actor = null), (this._slotId = 0);
		}
		setActor(t) {
			this._actor !== t &&
				((this._actor = t), this.refresh(), this.resetScroll());
		}
		setSlotId(t) {
			this._slotId !== t &&
				((this._slotId = t), this.refresh(), this.resetScroll());
		}
		includes(t) {
			return (
				null === t ||
				(!(
					this._slotId < 0 ||
					t.etypeId !== this._actor.equipSlots()[this._slotId]
				) &&
					this._actor.canEquip(t))
			);
		}
		isEnabled(t) {
			return !0;
		}
		selectLast() {}
		setStatusWindow(t) {
			(this._statusWindow = t), this.callUpdateHelp();
		}
		updateHelp() {
			if ((super.updateHelp(), this._actor && this._statusWindow)) {
				const t = JsonEx.makeDeepCopy(this._actor);
				t.forceChangeEquip(this._slotId, this.item()),
					this._statusWindow.setTempActor(t);
			}
		}
		playOkSound() {}
	}
	class Scene_Equip extends Scene_MenuBase {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize();
		}
		create() {
			super.create(),
				this.createHelpWindow(),
				this.createStatusWindow(),
				this.createCommandWindow(),
				this.createSlotWindow(),
				this.createItemWindow(),
				this.refreshActor();
		}
		createStatusWindow() {
			(this._statusWindow = new Window_EquipStatus(0, this._helpWindow.height)),
				this.addWindow(this._statusWindow);
		}
		createCommandWindow() {
			const t = this._statusWindow.width,
				e = this._helpWindow.height,
				i = Graphics.boxWidth - this._statusWindow.width;
			(this._commandWindow = new Window_EquipCommand(t, e, i)),
				this._commandWindow.setHelpWindow(this._helpWindow),
				this._commandWindow.setHandler('equip', this.commandEquip.bind(this)),
				this._commandWindow.setHandler(
					'optimize',
					this.commandOptimize.bind(this)
				),
				this._commandWindow.setHandler('clear', this.commandClear.bind(this)),
				this._commandWindow.setHandler('cancel', this.popScene.bind(this)),
				this._commandWindow.setHandler('pagedown', this.nextActor.bind(this)),
				this._commandWindow.setHandler('pageup', this.previousActor.bind(this)),
				this.addWindow(this._commandWindow);
		}
		createSlotWindow() {
			const t = this._statusWindow.width,
				e = this._commandWindow.y + this._commandWindow.height,
				i = Graphics.boxWidth - this._statusWindow.width,
				r = this._statusWindow.height - this._commandWindow.height;
			(this._slotWindow = new Window_EquipSlot(t, e, i, r)),
				this._slotWindow.setHelpWindow(this._helpWindow),
				this._slotWindow.setStatusWindow(this._statusWindow),
				this._slotWindow.setHandler('ok', this.onSlotOk.bind(this)),
				this._slotWindow.setHandler('cancel', this.onSlotCancel.bind(this)),
				this.addWindow(this._slotWindow);
		}
		createItemWindow() {
			const t = this._statusWindow.y + this._statusWindow.height,
				e = Graphics.boxWidth,
				i = Graphics.boxHeight - t;
			(this._itemWindow = new Window_EquipItem(0, t, e, i)),
				this._itemWindow.setHelpWindow(this._helpWindow),
				this._itemWindow.setStatusWindow(this._statusWindow),
				this._itemWindow.setHandler('ok', this.onItemOk.bind(this)),
				this._itemWindow.setHandler('cancel', this.onItemCancel.bind(this)),
				this._slotWindow.setItemWindow(this._itemWindow),
				this.addWindow(this._itemWindow);
		}
		refreshActor() {
			const t = this.actor();
			this._statusWindow.setActor(t),
				this._slotWindow.setActor(t),
				this._itemWindow.setActor(t);
		}
		commandEquip() {
			this._slotWindow.activate(), this._slotWindow.select(0);
		}
		commandOptimize() {
			SoundManager.playEquip(),
				this.actor().optimizeEquipments(),
				this._statusWindow.refresh(),
				this._slotWindow.refresh(),
				this._commandWindow.activate();
		}
		commandClear() {
			SoundManager.playEquip(),
				this.actor().clearEquipments(),
				this._statusWindow.refresh(),
				this._slotWindow.refresh(),
				this._commandWindow.activate();
		}
		onSlotOk() {
			this._itemWindow.activate(), this._itemWindow.select(0);
		}
		onSlotCancel() {
			this._slotWindow.deselect(), this._commandWindow.activate();
		}
		onItemOk() {
			SoundManager.playEquip(),
				this.actor().changeEquip(
					this._slotWindow.index(),
					this._itemWindow.item()
				),
				this._slotWindow.activate(),
				this._slotWindow.refresh(),
				this._itemWindow.deselect(),
				this._itemWindow.refresh(),
				this._statusWindow.refresh();
		}
		onItemCancel() {
			this._slotWindow.activate(), this._itemWindow.deselect();
		}
		onActorChange() {
			this.refreshActor(), this._commandWindow.activate();
		}
	}
	class Window_Status extends Window_Selectable {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			const t = Graphics.boxWidth,
				e = Graphics.boxHeight;
			super.initialize(0, 0, t, e),
				(this._actor = null),
				this.refresh(),
				this.activate();
		}
		setActor(t) {
			this._actor !== t && ((this._actor = t), this.refresh());
		}
		refresh() {
			if ((this.contents.clear(), this._actor)) {
				const t = this.lineHeight();
				this.drawBlock1(0 * t),
					this.drawHorzLine(1 * t),
					this.drawBlock2(2 * t),
					this.drawHorzLine(6 * t),
					this.drawBlock3(7 * t),
					this.drawHorzLine(13 * t),
					this.drawBlock4(14 * t);
			}
		}
		drawBlock1(t) {
			this.drawActorName(this._actor, 6, t),
				this.drawActorClass(this._actor, 192, t),
				this.drawActorNickname(this._actor, 432, t);
		}
		drawBlock2(t) {
			this.drawActorFace(this._actor, 12, t),
				this.drawBasicInfo(204, t),
				this.drawExpInfo(456, t);
		}
		drawBlock3(t) {
			this.drawParameters(48, t), this.drawEquipments(432, t);
		}
		drawBlock4(t) {
			this.drawProfile(6, t);
		}
		drawHorzLine(t) {
			const e = t + this.lineHeight() / 2 - 1;
			(this.contents.paintOpacity = 48),
				this.contents.fillRect(0, e, this.contentsWidth(), 2, this.lineColor()),
				(this.contents.paintOpacity = 255);
		}
		lineColor() {
			return this.normalColor();
		}
		drawBasicInfo(t, e) {
			const i = this.lineHeight();
			this.drawActorLevel(this._actor, t, e + 0 * i),
				this.drawActorIcons(this._actor, t, e + 1 * i),
				this.drawActorHp(this._actor, t, e + 2 * i),
				this.drawActorMp(this._actor, t, e + 3 * i);
		}
		drawParameters(t, e) {
			const i = this.lineHeight();
			for (let r = 0; r < 6; r++) {
				const s = r + 2,
					n = e + i * r;
				this.changeTextColor(this.systemColor()),
					this.drawText(TextManager.param(s), t, n, 160),
					this.resetTextColor(),
					this.drawText(this._actor.param(s), t + 160, n, 60, 'right');
			}
		}
		drawExpInfo(t, e) {
			const i = this.lineHeight(),
				r = TextManager.expTotal.format(TextManager.exp),
				s = TextManager.expNext.format(TextManager.level);
			let n = this._actor.currentExp(),
				a = this._actor.nextRequiredExp();
			this._actor.isMaxLevel() && ((n = '-------'), (a = '-------')),
				this.changeTextColor(this.systemColor()),
				this.drawText(r, t, e + 0 * i, 270),
				this.drawText(s, t, e + 2 * i, 270),
				this.resetTextColor(),
				this.drawText(n, t, e + 1 * i, 270, 'right'),
				this.drawText(a, t, e + 3 * i, 270, 'right');
		}
		drawEquipments(t, e) {
			const i = this._actor.equips(),
				r = Math.min(i.length, this.maxEquipmentLines());
			for (let s = 0; s < r; s++)
				this.drawItemName(i[s], t, e + this.lineHeight() * s);
		}
		drawProfile(t, e) {
			this.drawTextEx(this._actor.profile(), t, e);
		}
		maxEquipmentLines() {
			return 6;
		}
	}
	class Scene_Status extends Scene_MenuBase {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize();
		}
		create() {
			super.create(),
				(this._statusWindow = new Window_Status()),
				this._statusWindow.setHandler('cancel', this.popScene.bind(this)),
				this._statusWindow.setHandler('pagedown', this.nextActor.bind(this)),
				this._statusWindow.setHandler('pageup', this.previousActor.bind(this)),
				this._statusWindow.reserveFaceImages(),
				this.addWindow(this._statusWindow);
		}
		start() {
			super.start(), this.refreshActor();
		}
		refreshActor() {
			const t = this.actor();
			this._statusWindow.setActor(t);
		}
		onActorChange() {
			this.refreshActor(), this._statusWindow.activate();
		}
	}
	class Window_Options extends Window_Command {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize(0, 0), this.updatePlacement();
		}
		windowWidth() {
			return 400;
		}
		windowHeight() {
			return this.fittingHeight(Math.min(this.numVisibleRows(), 12));
		}
		updatePlacement() {
			(this.x = (Graphics.boxWidth - this.width) / 2),
				(this.y = (Graphics.boxHeight - this.height) / 2);
		}
		makeCommandList() {
			this.addGeneralOptions(), this.addVolumeOptions();
		}
		addGeneralOptions() {
			this.addCommand(TextManager.alwaysDash, 'alwaysDash'),
				this.addCommand(TextManager.commandRemember, 'commandRemember');
		}
		addVolumeOptions() {
			this.addCommand(TextManager.bgmVolume, 'bgmVolume'),
				this.addCommand(TextManager.bgsVolume, 'bgsVolume'),
				this.addCommand(TextManager.meVolume, 'meVolume'),
				this.addCommand(TextManager.seVolume, 'seVolume');
		}
		drawItem(t) {
			const e = this.itemRectForText(t),
				i = this.statusWidth(),
				r = e.width - i;
			this.resetTextColor(),
				this.changePaintOpacity(this.isCommandEnabled(t)),
				this.drawText(this.commandName(t), e.x, e.y, r, 'left'),
				this.drawText(this.statusText(t), e.x + r, e.y, i, 'right');
		}
		statusWidth() {
			return 120;
		}
		statusText(t) {
			const e = this.commandSymbol(t),
				i = this.getConfigValue(e);
			return this.isVolumeSymbol(e)
				? this.volumeStatusText(i)
				: this.booleanStatusText(i);
		}
		isVolumeSymbol(t) {
			return t.contains('Volume');
		}
		booleanStatusText(t) {
			return t ? 'ON' : 'OFF';
		}
		volumeStatusText(t) {
			return `${t}%`;
		}
		processOk() {
			const t = this.index(),
				e = this.commandSymbol(t);
			let i = this.getConfigValue(e);
			this.isVolumeSymbol(e)
				? ((i += this.volumeOffset()),
				  i > 100 && (i = 0),
				  (i = i.clamp(0, 100)),
				  this.changeValue(e, i))
				: this.changeValue(e, !i);
		}
		cursorRight(t) {
			const e = this.index(),
				i = this.commandSymbol(e);
			let r = this.getConfigValue(i);
			this.isVolumeSymbol(i)
				? ((r += this.volumeOffset()),
				  (r = r.clamp(0, 100)),
				  this.changeValue(i, r))
				: this.changeValue(i, !0);
		}
		cursorLeft(t) {
			const e = this.index(),
				i = this.commandSymbol(e);
			let r = this.getConfigValue(i);
			this.isVolumeSymbol(i)
				? ((r -= this.volumeOffset()),
				  (r = r.clamp(0, 100)),
				  this.changeValue(i, r))
				: this.changeValue(i, !1);
		}
		volumeOffset() {
			return 20;
		}
		changeValue(t, e) {
			this.getConfigValue(t) !== e &&
				(this.setConfigValue(t, e),
				this.redrawItem(this.findSymbol(t)),
				SoundManager.playCursor());
		}
		getConfigValue(t) {
			return ConfigManager[t];
		}
		setConfigValue(t, e) {
			ConfigManager[t] = e;
		}
	}
	class Scene_Options extends Scene_MenuBase {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize();
		}
		create() {
			super.create(), this.createOptionsWindow();
		}
		terminate() {
			super.terminate(), ConfigManager.save();
		}
		createOptionsWindow() {
			(this._optionsWindow = new Window_Options()),
				this._optionsWindow.setHandler('cancel', this.popScene.bind(this)),
				this.addWindow(this._optionsWindow);
		}
	}
	class Window_SavefileList extends Window_Selectable {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e, i, r) {
			super.initialize(t, e, i, r), this.activate(), (this._mode = null);
		}
		setMode(t) {
			this._mode = t;
		}
		maxItems() {
			return DataManager$1.maxSavefiles();
		}
		maxVisibleItems() {
			return 5;
		}
		itemHeight() {
			const t = this.height - 2 * this.padding;
			return Math.floor(t / this.maxVisibleItems());
		}
		drawItem(t) {
			const e = t + 1,
				i = DataManager$1.isThisGameFile(e),
				r = DataManager$1.loadSavefileInfo(e),
				s = this.itemRectForText(t);
			this.resetTextColor(),
				'load' === this._mode && this.changePaintOpacity(i),
				this.drawFileId(e, s.x, s.y),
				r &&
					(this.changePaintOpacity(i),
					this.drawContents(r, s, i),
					this.changePaintOpacity(!0));
		}
		drawFileId(t, e, i) {
			DataManager$1.isAutoSaveFileId(t)
				? ('save' === this._mode && this.changePaintOpacity(!1),
				  this.drawText(`${TextManager.file} ${t}(Auto)`, e, i, 180))
				: this.drawText(`${TextManager.file} ${t}`, e, i, 180);
		}
		drawContents(t, { y: e, height: i, width: r, x: s }, n) {
			const a = e + i;
			r >= 420 &&
				(this.drawGameTitle(t, s + 192, e, r - 192),
				n && this.drawPartyCharacters(t, s + 220, a - 4));
			const o = this.lineHeight(),
				h = a - o;
			h >= o && this.drawPlaytime(t, s, h, r);
		}
		drawGameTitle({ title: t }, e, i, r) {
			t && this.drawText(t, e, i, r);
		}
		drawPartyCharacters({ characters: t }, e, i) {
			t &&
				t.forEach((t, r) => {
					this.drawCharacter(t[0], t[1], e + 48 * r, i);
				});
		}
		drawPlaytime({ playtime: t }, e, i, r) {
			t && this.drawText(t, e, i, r, 'right');
		}
		playOkSound() {}
	}
	class Scene_File extends Scene_MenuBase {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize();
		}
		create() {
			super.create(),
				DataManager$1.loadAllSavefileImages(),
				this.createHelpWindow(),
				this.createListWindow();
		}
		start() {
			super.start(), this._listWindow.refresh();
		}
		savefileId() {
			return this._listWindow.index() + 1;
		}
		createHelpWindow() {
			(this._helpWindow = new Window_Help(1)),
				this._helpWindow.setText(this.helpWindowText()),
				this.addWindow(this._helpWindow);
		}
		createListWindow() {
			const t = this._helpWindow.height,
				e = Graphics.boxWidth,
				i = Graphics.boxHeight - t;
			(this._listWindow = new Window_SavefileList(0, t, e, i)),
				this._listWindow.setHandler('ok', this.onSavefileOk.bind(this)),
				this._listWindow.setHandler('cancel', this.popScene.bind(this)),
				this._listWindow.select(this.firstSavefileIndex()),
				this._listWindow.setTopRow(this.firstSavefileIndex() - 2),
				this._listWindow.setMode(this.mode()),
				this._listWindow.refresh(),
				this.addWindow(this._listWindow);
		}
		mode() {
			return null;
		}
		activateListWindow() {
			this._listWindow.activate();
		}
		helpWindowText() {
			return '';
		}
		firstSavefileIndex() {
			return 0;
		}
		onSavefileOk() {}
	}
	class Scene_Save extends Scene_File {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize();
		}
		mode() {
			return 'save';
		}
		helpWindowText() {
			return TextManager.saveMessage;
		}
		firstSavefileIndex() {
			return DataManager$1.lastAccessedSavefileId() - 1;
		}
		onSavefileOk() {
			DataManager$1.isAutoSaveFileId(this.savefileId())
				? this.onSaveFailure()
				: (super.onSavefileOk(),
				  self.$gameSystem.onBeforeSave(),
				  DataManager$1.saveGame(this.savefileId())
						? this.onSaveSuccess()
						: this.onSaveFailure());
		}
		onSaveSuccess() {
			SoundManager.playSave(),
				StorageManagerShim.cleanBackup(this.savefileId()),
				this.popScene();
		}
		onSaveFailure() {
			SoundManager.playBuzzer(), this.activateListWindow();
		}
	}
	class Window_GameEnd extends Window_Command {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize(0, 0),
				this.updatePlacement(),
				(this.openness = 0),
				this.open();
		}
		windowWidth() {
			return 240;
		}
		updatePlacement() {
			(this.x = (Graphics.boxWidth - this.width) / 2),
				(this.y = (Graphics.boxHeight - this.height) / 2);
		}
		makeCommandList() {
			this.addCommand(TextManager.toTitle, 'toTitle'),
				this.addCommand(TextManager.cancel, 'cancel');
		}
	}
	class Scene_GameEnd extends Scene_MenuBase {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize();
		}
		create() {
			super.create(), this.createCommandWindow();
		}
		stop() {
			super.stop(), this._commandWindow.close();
		}
		createBackground() {
			super.createBackground(), this.setBackgroundOpacity(128);
		}
		createCommandWindow() {
			(this._commandWindow = new Window_GameEnd()),
				this._commandWindow.setHandler(
					'toTitle',
					this.commandToTitle.bind(this)
				),
				this._commandWindow.setHandler('cancel', this.popScene.bind(this)),
				this.addWindow(this._commandWindow);
		}
		commandToTitle() {
			this.fadeOutAll(), SceneManager.goto(Scene_Title);
		}
	}
	class Scene_Menu extends Scene_MenuBase {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize();
		}
		create() {
			super.create(),
				this.createCommandWindow(),
				this.createGoldWindow(),
				this.createStatusWindow();
		}
		start() {
			super.start(), this._statusWindow.refresh();
		}
		createCommandWindow() {
			(this._commandWindow = new Window_MenuCommand(0, 0)),
				this._commandWindow.setHandler('item', this.commandItem.bind(this)),
				this._commandWindow.setHandler(
					'skill',
					this.commandPersonal.bind(this)
				),
				this._commandWindow.setHandler(
					'equip',
					this.commandPersonal.bind(this)
				),
				this._commandWindow.setHandler(
					'status',
					this.commandPersonal.bind(this)
				),
				this._commandWindow.setHandler(
					'formation',
					this.commandFormation.bind(this)
				),
				this._commandWindow.setHandler(
					'options',
					this.commandOptions.bind(this)
				),
				this._commandWindow.setHandler('save', this.commandSave.bind(this)),
				this._commandWindow.setHandler(
					'gameEnd',
					this.commandGameEnd.bind(this)
				),
				this._commandWindow.setHandler('cancel', this.popScene.bind(this)),
				this.addWindow(this._commandWindow);
		}
		createGoldWindow() {
			(this._goldWindow = new Window_Gold(0, 0)),
				(this._goldWindow.y = Graphics.boxHeight - this._goldWindow.height),
				this.addWindow(this._goldWindow);
		}
		createStatusWindow() {
			(this._statusWindow = new Window_MenuStatus(
				this._commandWindow.width,
				0
			)),
				this._statusWindow.reserveFaceImages(),
				this.addWindow(this._statusWindow);
		}
		commandItem() {
			SceneManager.push(Scene_Item);
		}
		commandPersonal() {
			this._statusWindow.setFormationMode(!1),
				this._statusWindow.selectLast(),
				this._statusWindow.activate(),
				this._statusWindow.setHandler('ok', this.onPersonalOk.bind(this)),
				this._statusWindow.setHandler(
					'cancel',
					this.onPersonalCancel.bind(this)
				);
		}
		commandFormation() {
			this._statusWindow.setFormationMode(!0),
				this._statusWindow.selectLast(),
				this._statusWindow.activate(),
				this._statusWindow.setHandler('ok', this.onFormationOk.bind(this)),
				this._statusWindow.setHandler(
					'cancel',
					this.onFormationCancel.bind(this)
				);
		}
		commandOptions() {
			SceneManager.push(Scene_Options);
		}
		commandSave() {
			SceneManager.push(Scene_Save);
		}
		commandGameEnd() {
			SceneManager.push(Scene_GameEnd);
		}
		onPersonalOk() {
			switch (this._commandWindow.currentSymbol()) {
				case 'skill':
					SceneManager.push(Scene_Skill);
					break;
				case 'equip':
					SceneManager.push(Scene_Equip);
					break;
				case 'status':
					SceneManager.push(Scene_Status);
			}
		}
		onPersonalCancel() {
			this._statusWindow.deselect(), this._commandWindow.activate();
		}
		onFormationOk() {
			const t = this._statusWindow.index(),
				e = this._statusWindow.pendingIndex();
			e >= 0
				? (self.$gameParty.swapOrder(t, e),
				  this._statusWindow.setPendingIndex(-1),
				  this._statusWindow.redrawItem(t))
				: this._statusWindow.setPendingIndex(t),
				this._statusWindow.activate();
		}
		onFormationCancel() {
			this._statusWindow.pendingIndex() >= 0
				? (this._statusWindow.setPendingIndex(-1),
				  this._statusWindow.activate())
				: (this._statusWindow.deselect(), this._commandWindow.activate());
		}
	}
	class Scene_Load extends Scene_File {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize(), (this._loadSuccess = !1);
		}
		terminate() {
			super.terminate(), this._loadSuccess && self.$gameSystem.onAfterLoad();
		}
		mode() {
			return 'load';
		}
		helpWindowText() {
			return TextManager.loadMessage;
		}
		firstSavefileIndex() {
			return DataManager$1.latestSavefileId() - 1;
		}
		async onSavefileOk() {
			super.onSavefileOk(),
				(await DataManager$1.loadGame(this.savefileId()))
					? this.onLoadSuccess()
					: this.onLoadFailure();
		}
		onLoadSuccess() {
			SoundManager.playLoad(),
				this.fadeOutAll(),
				this.reloadMapIfUpdated(),
				SceneManager.goto(Scene_Map),
				(this._loadSuccess = !0);
		}
		onLoadFailure() {
			SoundManager.playBuzzer(), this.activateListWindow();
		}
		reloadMapIfUpdated() {
			self.$gameSystem.versionId() !== self.$dataSystem.versionId &&
				(self.$gamePlayer.reserveTransfer(
					self.$gameMap.mapId(),
					self.$gamePlayer.x,
					self.$gamePlayer.y
				),
				self.$gamePlayer.requestMapReload());
		}
	}
	class Window_DebugRange extends Window_Selectable {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e) {
			(this._maxSwitches = Math.ceil(
				(self.$dataSystem.switches.length - 1) / 10
			)),
				(this._maxVariables = Math.ceil(
					(self.$dataSystem.variables.length - 1) / 10
				));
			const i = this.windowWidth(),
				r = this.windowHeight();
			super.initialize(t, e, i, r),
				this.refresh(),
				this.setTopRow(Window_DebugRange.lastTopRow),
				this.select(Window_DebugRange.lastIndex),
				this.activate();
		}
		windowWidth() {
			return 246;
		}
		windowHeight() {
			return Graphics.boxHeight;
		}
		maxItems() {
			return this._maxSwitches + this._maxVariables;
		}
		update() {
			super.update(),
				this._editWindow &&
					(this._editWindow.setMode(this.mode()),
					this._editWindow.setTopId(this.topId()));
		}
		mode() {
			return this.index() < this._maxSwitches ? 'switch' : 'variable';
		}
		topId() {
			const t = this.index();
			return t < this._maxSwitches
				? 10 * t + 1
				: 10 * (t - this._maxSwitches) + 1;
		}
		refresh() {
			this.createContents(), this.drawAllItems();
		}
		drawItem(t) {
			const e = this.itemRectForText(t);
			let i, r;
			t < this._maxSwitches
				? ((i = 10 * t + 1), (r = 'S'))
				: ((i = 10 * (t - this._maxSwitches) + 1), (r = 'V'));
			const s = i + 9;
			(r += ` [${i.padZero(4)}-${s.padZero(4)}]`),
				this.drawText(r, e.x, e.y, e.width);
		}
		isCancelTriggered() {
			return (
				Window_Selectable.prototype.isCancelTriggered() ||
				Input.isTriggered('debug')
			);
		}
		processCancel() {
			super.processCancel(),
				(Window_DebugRange.lastTopRow = this.topRow()),
				(Window_DebugRange.lastIndex = this.index());
		}
		setEditWindow(t) {
			this._editWindow = t;
		}
	}
	(Window_DebugRange.lastTopRow = 0), (Window_DebugRange.lastIndex = 0);
	class Window_DebugEdit extends Window_Selectable {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e, i) {
			const r = this.fittingHeight(10);
			super.initialize(t, e, i, r),
				(this._mode = 'switch'),
				(this._topId = 1),
				this.refresh();
		}
		maxItems() {
			return 10;
		}
		refresh() {
			this.contents.clear(), this.drawAllItems();
		}
		drawItem(t) {
			const e = this._topId + t,
				i = `${e.padZero(4)}:`,
				r = this.textWidth(i),
				s = this.textWidth('-00000000'),
				n = this.itemName(e),
				a = this.itemStatus(e),
				o = this.itemRectForText(t);
			this.resetTextColor(),
				this.drawText(i, o.x, o.y, o.width),
				(o.x += r),
				(o.width -= r + s),
				this.drawText(n, o.x, o.y, o.width),
				this.drawText(a, o.x + o.width, o.y, s, 'right');
		}
		itemName(t) {
			return 'switch' === this._mode
				? self.$dataSystem.switches[t]
				: self.$dataSystem.variables[t];
		}
		itemStatus(t) {
			return 'switch' === this._mode
				? self.$gameSwitches.value(t)
					? '[ON]'
					: '[OFF]'
				: String(self.$gameVariables.value(t));
		}
		setMode(t) {
			this._mode !== t && ((this._mode = t), this.refresh());
		}
		setTopId(t) {
			this._topId !== t && ((this._topId = t), this.refresh());
		}
		currentId() {
			return this._topId + this.index();
		}
		update() {
			super.update(),
				this.active &&
					('switch' === this._mode
						? this.updateSwitch()
						: this.updateVariable());
		}
		updateSwitch() {
			if (Input.isRepeated('ok')) {
				const t = this.currentId();
				SoundManager.playCursor(),
					self.$gameSwitches.setValue(t, !self.$gameSwitches.value(t)),
					this.redrawCurrentItem();
			}
		}
		updateVariable() {
			const t = this.currentId();
			let e = self.$gameVariables.value(t);
			'number' == typeof e &&
				(Input.isRepeated('right') && e++,
				Input.isRepeated('left') && e--,
				Input.isRepeated('pagedown') && (e += 10),
				Input.isRepeated('pageup') && (e -= 10),
				self.$gameVariables.value(t) !== e &&
					(self.$gameVariables.setValue(t, e),
					SoundManager.playCursor(),
					this.redrawCurrentItem()));
		}
	}
	class Scene_Debug extends Scene_MenuBase {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize();
		}
		create() {
			super.create(),
				this.createRangeWindow(),
				this.createEditWindow(),
				this.createDebugHelpWindow();
		}
		createRangeWindow() {
			(this._rangeWindow = new Window_DebugRange(0, 0)),
				this._rangeWindow.setHandler('ok', this.onRangeOk.bind(this)),
				this._rangeWindow.setHandler('cancel', this.popScene.bind(this)),
				this.addWindow(this._rangeWindow);
		}
		createEditWindow() {
			const t = this._rangeWindow.width,
				e = Graphics.boxWidth - t;
			(this._editWindow = new Window_DebugEdit(t, 0, e)),
				this._editWindow.setHandler('cancel', this.onEditCancel.bind(this)),
				this._rangeWindow.setEditWindow(this._editWindow),
				this.addWindow(this._editWindow);
		}
		createDebugHelpWindow() {
			const t = this._editWindow.x,
				e = this._editWindow.height,
				i = this._editWindow.width,
				r = Graphics.boxHeight - e;
			(this._debugHelpWindow = new Window_Base(t, e, i, r)),
				this.addWindow(this._debugHelpWindow);
		}
		onRangeOk() {
			this._editWindow.activate(),
				this._editWindow.select(0),
				this.refreshHelpWindow();
		}
		onEditCancel() {
			this._rangeWindow.activate(),
				this._editWindow.deselect(),
				this.refreshHelpWindow();
		}
		refreshHelpWindow() {
			this._debugHelpWindow.contents.clear(),
				this._editWindow.active &&
					this._debugHelpWindow.drawTextEx(this.helpText(), 4, 0);
		}
		helpText() {
			return 'switch' === this._rangeWindow.mode()
				? 'Enter : ON / OFF'
				: 'Left     :  -1\nRight    :  +1\nPageup   : -10\nPagedown : +10';
		}
	}
	class Window_MapName extends Window_Base {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			const t = this.windowWidth(),
				e = this.windowHeight();
			super.initialize(0, 0, t, e),
				(this.opacity = 0),
				(this.contentsOpacity = 0),
				(this._showCount = 0),
				this.refresh();
		}
		windowWidth() {
			return 360;
		}
		windowHeight() {
			return this.fittingHeight(1);
		}
		update() {
			super.update(),
				this._showCount > 0 && self.$gameMap.isNameDisplayEnabled()
					? (this.updateFadeIn(), this._showCount--)
					: this.updateFadeOut();
		}
		updateFadeIn() {
			this.contentsOpacity += 16;
		}
		updateFadeOut() {
			this.contentsOpacity -= 16;
		}
		open() {
			this.refresh(), (this._showCount = 150);
		}
		close() {
			this._showCount = 0;
		}
		refresh() {
			if ((this.contents.clear(), self.$gameMap.displayName())) {
				const t = this.contentsWidth();
				this.drawBackground(0, 0, t, this.lineHeight()),
					this.drawText(self.$gameMap.displayName(), 0, 0, t, 'center');
			}
		}
		drawBackground(t, e, i, r) {
			const s = this.dimColor1(),
				n = this.dimColor2();
			this.contents.gradientFillRect(t, e, i / 2, r, n, s),
				this.contents.gradientFillRect(t + i / 2, e, i / 2, r, s, n);
		}
	}
	class Sprite_Balloon extends Sprite_Base {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize(), this.initMembers(), this.loadBitmap();
		}
		initMembers() {
			(this._balloonId = 0),
				(this._duration = 0),
				(this.anchor.x = 0.5),
				(this.anchor.y = 1),
				(this.z = 7);
		}
		loadBitmap() {
			(this.bitmap = ImageManager.loadSystem('Balloon')),
				this.setFrame(0, 0, 0, 0);
		}
		setup(t) {
			(this._balloonId = t),
				(this._duration = 8 * this.speed() + this.waitTime());
		}
		update() {
			super.update(),
				this._duration > 0 &&
					(this._duration--, this._duration > 0 && this.updateFrame());
		}
		updateFrame() {
			const t = 48 * this.frameIndex(),
				e = 48 * (this._balloonId - 1);
			this.setFrame(t, e, 48, 48);
		}
		speed() {
			return 8;
		}
		waitTime() {
			return 12;
		}
		frameIndex() {
			const t = (this._duration - this.waitTime()) / this.speed();
			return 7 - Math.max(Math.floor(t), 0);
		}
		isPlaying() {
			return this._duration > 0;
		}
	}
	class Sprite_Character extends Sprite_Base {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t) {
			super.initialize(), this.initMembers(), this.setCharacter(t);
		}
		initMembers() {
			(this.anchor.x = 0.5),
				(this.anchor.y = 1),
				(this._character = null),
				(this._balloonDuration = 0),
				(this._tilesetId = 0),
				(this._upperBody = null),
				(this._lowerBody = null);
		}
		setCharacter(t) {
			this._character = t;
		}
		update() {
			super.update(),
				this.updateBitmap(),
				this.updateFrame(),
				this.updatePosition(),
				this.updateAnimation(),
				this.updateBalloon(),
				this.updateOther();
		}
		updateVisibility() {
			super.updateVisibility(),
				this._character.isTransparent() && (this.visible = !1);
		}
		isTile() {
			return this._character.tileId > 0;
		}
		tilesetBitmap(t) {
			const e = self.$gameMap.tileset(),
				i = 5 + Math.floor(t / 256);
			return ImageManager.loadTileset(e.tilesetNames[i]);
		}
		updateBitmap() {
			this.isImageChanged() &&
				((this._tilesetId = self.$gameMap.tilesetId()),
				(this._tileId = this._character.tileId()),
				(this._characterName = this._character.characterName()),
				(this._characterIndex = this._character.characterIndex()),
				this._tileId > 0 ? this.setTileBitmap() : this.setCharacterBitmap());
		}
		isImageChanged() {
			return (
				this._tilesetId !== self.$gameMap.tilesetId() ||
				this._tileId !== this._character.tileId() ||
				this._characterName !== this._character.characterName() ||
				this._characterIndex !== this._character.characterIndex()
			);
		}
		setTileBitmap() {
			this.bitmap = this.tilesetBitmap(this._tileId);
		}
		setCharacterBitmap() {
			(this.bitmap = ImageManager.loadCharacter(this._characterName)),
				(this._isBigCharacter = ImageManager.isBigCharacter(
					this._characterName
				));
		}
		updateFrame() {
			this._tileId > 0 ? this.updateTileFrame() : this.updateCharacterFrame();
		}
		updateTileFrame() {
			const t = this.patternWidth(),
				e = this.patternHeight(),
				i = ((Math.floor(this._tileId / 128) % 2) * 8 + (this._tileId % 8)) * t,
				r = (Math.floor((this._tileId % 256) / 8) % 16) * e;
			this.setFrame(i, r, t, e);
		}
		updateCharacterFrame() {
			const t = this.patternWidth(),
				e = this.patternHeight(),
				i = (this.characterBlockX() + this.characterPatternX()) * t,
				r = (this.characterBlockY() + this.characterPatternY()) * e;
			if ((this.updateHalfBodySprites(), this._bushDepth > 0)) {
				const s = this._bushDepth;
				this._upperBody.setFrame(i, r, t, e - s),
					this._lowerBody.setFrame(i, r + e - s, t, s),
					this.setFrame(i, r, 0, e);
			} else this.setFrame(i, r, t, e);
		}
		characterBlockX() {
			return this._isBigCharacter
				? 0
				: (this._character.characterIndex() % 4) * 3;
		}
		characterBlockY() {
			if (this._isBigCharacter) return 0;
			{
				const t = this._character.characterIndex();
				return 4 * Math.floor(t / 4);
			}
		}
		characterPatternX() {
			return this._character.pattern();
		}
		characterPatternY() {
			return (this._character.direction() - 2) / 2;
		}
		patternWidth() {
			return this._tileId > 0
				? self.$gameMap.tileWidth()
				: this._isBigCharacter
				? this.bitmap.width / 3
				: this.bitmap.width / 12;
		}
		patternHeight() {
			return this._tileId > 0
				? self.$gameMap.tileHeight()
				: this._isBigCharacter
				? this.bitmap.height / 4
				: this.bitmap.height / 8;
		}
		updateHalfBodySprites() {
			this._bushDepth > 0
				? (this.createHalfBodySprites(),
				  (this._upperBody.bitmap = this.bitmap),
				  (this._upperBody.visible = !0),
				  (this._upperBody.y = -this._bushDepth),
				  (this._lowerBody.bitmap = this.bitmap),
				  (this._lowerBody.visible = !0),
				  this._upperBody.setBlendColor(this.getBlendColor()),
				  this._lowerBody.setBlendColor(this.getBlendColor()),
				  this._upperBody.setColorTone(this.getColorTone()),
				  this._lowerBody.setColorTone(this.getColorTone()))
				: this._upperBody &&
				  ((this._upperBody.visible = !1), (this._lowerBody.visible = !1));
		}
		createHalfBodySprites() {
			this._upperBody ||
				((this._upperBody = new Sprite()),
				(this._upperBody.anchor.x = 0.5),
				(this._upperBody.anchor.y = 1),
				this.addChild(this._upperBody)),
				this._lowerBody ||
					((this._lowerBody = new Sprite()),
					(this._lowerBody.anchor.x = 0.5),
					(this._lowerBody.anchor.y = 1),
					(this._lowerBody.opacity = 128),
					this.addChild(this._lowerBody));
		}
		updatePosition() {
			(this.x = this._character.screenX()),
				(this.y = this._character.screenY()),
				(this.z = this._character.screenZ());
		}
		updateAnimation() {
			this.setupAnimation(),
				this.isAnimationPlaying() || this._character.endAnimation(),
				this.isBalloonPlaying() || this._character.endBalloon();
		}
		updateOther() {
			(this.opacity = this._character.opacity()),
				(this.blendMode = this._character.blendMode()),
				(this._bushDepth = this._character.bushDepth());
		}
		setupAnimation() {
			if (this._character.animationId() > 0) {
				const t = self.$dataAnimations[this._character.animationId()];
				this.startAnimation(t, !1, 0), this._character.startAnimation();
			}
		}
		setupBalloon() {
			this._character.balloonId() > 0 &&
				(this.startBalloon(), this._character.startBalloon());
		}
		startBalloon() {
			this._balloonSprite || (this._balloonSprite = new Sprite_Balloon()),
				this._balloonSprite.setup(this._character.balloonId()),
				this.parent.addChild(this._balloonSprite);
		}
		updateBalloon() {
			this.setupBalloon(),
				this._balloonSprite &&
					((this._balloonSprite.x = this.x),
					(this._balloonSprite.y = this.y - this.height),
					this._balloonSprite.isPlaying() || this.endBalloon());
		}
		endBalloon() {
			this._balloonSprite &&
				(this.parent.removeChild(this._balloonSprite),
				(this._balloonSprite = null));
		}
		isBalloonPlaying() {
			return !!this._balloonSprite;
		}
	}
	class Sprite_Destination extends Sprite {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize(), this.createBitmap(), (this._frameCount = 0);
		}
		update() {
			super.update(),
				self.$gameTemp.isDestinationValid()
					? (this.updatePosition(), this.updateAnimation(), (this.visible = !0))
					: ((this._frameCount = 0), (this.visible = !1));
		}
		createBitmap() {
			const t = self.$gameMap.tileWidth(),
				e = self.$gameMap.tileHeight();
			(this.bitmap = new Bitmap(t, e)),
				this.bitmap.fillAll('white'),
				(this.anchor.x = 0.5),
				(this.anchor.y = 0.5),
				(this.blendMode = Graphics.BLEND_ADD);
		}
		updatePosition() {
			const t = self.$gameMap.tileWidth(),
				e = self.$gameMap.tileHeight(),
				i = self.$gameTemp.destinationX(),
				r = self.$gameTemp.destinationY();
			(this.x = (self.$gameMap.adjustX(i) + 0.5) * t),
				(this.y = (self.$gameMap.adjustY(r) + 0.5) * e);
		}
		updateAnimation() {
			this._frameCount++,
				(this._frameCount %= 20),
				(this.opacity = 6 * (20 - this._frameCount)),
				(this.scale.x = 1 + this._frameCount / 20),
				(this.scale.y = this.scale.x);
		}
	}
	class Spriteset_Map extends Spriteset_Base {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize(), (this._tilesetReady = !1);
		}
		createLowerLayer() {
			super.createLowerLayer(),
				this.createParallax(),
				this.createTilemap(),
				this.createCharacters(),
				this.createShadow(),
				this.createDestination(),
				this.createWeather();
		}
		update() {
			super.update(),
				this.updateTileset(),
				this.updateParallax(),
				this.updateTilemap(),
				this.updateShadow(),
				this.updateWeather();
		}
		hideCharacters() {
			for (const t of this._characterSprites) t.isTile() || t.hide();
		}
		createParallax() {
			(this._parallax = new TilingSprite()),
				this._parallax.move(0, 0, Graphics.width, Graphics.height),
				this._baseSprite.addChild(this._parallax);
		}
		createTilemap() {
			Graphics.isWebGL()
				? (this._tilemap = new ShaderTilemap())
				: (this._tilemap = new Tilemap()),
				(this._tilemap.tileWidth = self.$gameMap.tileWidth()),
				(this._tilemap.tileHeight = self.$gameMap.tileHeight()),
				this._tilemap.setData(
					self.$gameMap.width(),
					self.$gameMap.height(),
					self.$gameMap.data()
				),
				(this._tilemap.horizontalWrap = self.$gameMap.isLoopHorizontal()),
				(this._tilemap.verticalWrap = self.$gameMap.isLoopVertical()),
				this.loadTileset(),
				this._baseSprite.addChild(this._tilemap);
		}
		loadTileset() {
			if (((this._tileset = self.$gameMap.tileset()), this._tileset)) {
				const t = this._tileset.tilesetNames;
				for (let e = 0; e < t.length; e++)
					this._tilemap.bitmaps[e] = ImageManager.loadTileset(t[e]);
				const e = self.$gameMap.tilesetFlags();
				this._tilemap.refreshTileset(),
					this._tilemap.flags.equals(e) || this._tilemap.refresh(),
					(this._tilemap.flags = e);
			}
		}
		createCharacters() {
			(this._characterSprites = []),
				self.$gameMap.events().forEach(function (t) {
					this._characterSprites.push(new Sprite_Character(t));
				}, this),
				self.$gameMap.vehicles().forEach(function (t) {
					this._characterSprites.push(new Sprite_Character(t));
				}, this),
				self.$gamePlayer.followers().reverseEach(function (t) {
					this._characterSprites.push(new Sprite_Character(t));
				}, this),
				this._characterSprites.push(new Sprite_Character(self.$gamePlayer));
			for (let t = 0; t < this._characterSprites.length; t++)
				this._tilemap.addChild(this._characterSprites[t]);
		}
		createShadow() {
			(this._shadowSprite = new Sprite()),
				(this._shadowSprite.bitmap = ImageManager.loadSystem('Shadow1')),
				(this._shadowSprite.anchor.x = 0.5),
				(this._shadowSprite.anchor.y = 1),
				(this._shadowSprite.z = 6),
				this._tilemap.addChild(this._shadowSprite);
		}
		createDestination() {
			(this._destinationSprite = new Sprite_Destination()),
				(this._destinationSprite.z = 9),
				this._tilemap.addChild(this._destinationSprite);
		}
		createWeather() {
			(this._weather = new Weather()), this.addChild(this._weather);
		}
		updateTileset() {
			this._tileset !== self.$gameMap.tileset() && this.loadTileset();
		}
		_canvasReAddParallax() {
			const t = this._baseSprite.children.indexOf(this._parallax);
			this._baseSprite.removeChild(this._parallax),
				(this._parallax = new TilingSprite()),
				this._parallax.move(0, 0, Graphics.width, Graphics.height),
				(this._parallax.bitmap = ImageManager.loadParallax(this._parallaxName)),
				this._baseSprite.addChildAt(this._parallax, t);
		}
		updateParallax() {
			this._parallaxName !== self.$gameMap.parallaxName() &&
				((this._parallaxName = self.$gameMap.parallaxName()),
				this._parallax.bitmap && 1 != Graphics.isWebGL()
					? this._canvasReAddParallax()
					: (this._parallax.bitmap = ImageManager.loadParallax(
							this._parallaxName
					  ))),
				this._parallax.bitmap &&
					((this._parallax.origin.x = self.$gameMap.parallaxOx()),
					(this._parallax.origin.y = self.$gameMap.parallaxOy()));
		}
		updateTilemap() {
			(this._tilemap.origin.x =
				self.$gameMap.displayX() * self.$gameMap.tileWidth()),
				(this._tilemap.origin.y =
					self.$gameMap.displayY() * self.$gameMap.tileHeight()),
				this._tilemap.bitmaps &&
					!this._tilesetReady &&
					this._tilemap.bitmaps.every((t) => t.isRequestReady()) &&
					(this._tilemap.refreshTileset(), (this._tilesetReady = !0));
		}
		updateShadow() {
			const t = self.$gameMap.airship();
			(this._shadowSprite.x = t.shadowX()),
				(this._shadowSprite.y = t.shadowY()),
				(this._shadowSprite.opacity = t.shadowOpacity());
		}
		updateWeather() {
			(this._weather.type = self.$gameScreen.weatherType()),
				(this._weather.power = self.$gameScreen.weatherPower()),
				(this._weather.origin.x =
					self.$gameMap.displayX() * self.$gameMap.tileWidth()),
				(this._weather.origin.y =
					self.$gameMap.displayY() * self.$gameMap.tileHeight());
		}
	}
	class Scene_Map extends Scene_Base {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize(),
				(this._waitCount = 0),
				(this._encounterEffectDuration = 0),
				(this._mapLoaded = !1),
				(this._touchCount = 0);
		}
		create() {
			super.create(), (this._transfer = self.$gamePlayer.isTransferring());
			const t = this._transfer
				? self.$gamePlayer.newMapId()
				: self.$gameMap.mapId();
			DataManager$1.loadMapData(t);
		}
		isReady() {
			return (
				!this._mapLoaded &&
					DataManager$1.isMapLoaded() &&
					(this.onMapLoaded(), (this._mapLoaded = !0)),
				this._mapLoaded && Scene_Base.prototype.isReady.call(this)
			);
		}
		onMapLoaded() {
			this._transfer && self.$gamePlayer.performTransfer(),
				this.createDisplayObjects();
		}
		start() {
			super.start(),
				SceneManager.clearStack(),
				this._transfer
					? (this.fadeInForTransfer(),
					  this._mapNameWindow.open(),
					  self.$gameMap.autoplay())
					: this.needsFadeIn() && this.startFadeIn(this.fadeSpeed(), !1),
				(this.menuCalling = !1);
		}
		update() {
			this.updateDestination(),
				this.updateMainMultiply(),
				this.isSceneChangeOk()
					? this.updateScene()
					: SceneManager.isNextScene(Scene_Battle) &&
					  this.updateEncounterEffect(),
				this.updateWaitCount(),
				super.update();
		}
		updateMainMultiply() {
			this.updateMain(),
				this.isFastForward() &&
					(this.isMapTouchOk() || this.updateDestination(), this.updateMain());
		}
		updateMain() {
			const t = this.isActive();
			self.$gameMap.update(t),
				self.$gamePlayer.update(t),
				self.$gameTimer.update(t),
				self.$gameScreen.update();
		}
		isFastForward() {
			return (
				self.$gameMap.isEventRunning() &&
				!SceneManager.isSceneChanging() &&
				(Input.isLongPressed('ok') || TouchInput.isLongPressed())
			);
		}
		stop() {
			super.stop(),
				self.$gamePlayer.straighten(),
				this._mapNameWindow.close(),
				this.needsSlowFadeOut()
					? this.startFadeOut(this.slowFadeSpeed(), !1)
					: SceneManager.isNextScene(Scene_Map)
					? this.fadeOutForTransfer()
					: SceneManager.isNextScene(Scene_Battle) && this.launchBattle();
		}
		isBusy() {
			return (
				(this._messageWindow && this._messageWindow.isClosing()) ||
				this._waitCount > 0 ||
				this._encounterEffectDuration > 0 ||
				Scene_Base.prototype.isBusy.call(this)
			);
		}
		terminate() {
			super.terminate(),
				SceneManager.isNextScene(Scene_Battle)
					? ImageManager.clearRequest()
					: (this._spriteset.update(),
					  this._mapNameWindow.hide(),
					  SceneManager.snapForBackground()),
				SceneManager.isNextScene(Scene_Map) && ImageManager.clearRequest(),
				self.$gameScreen.clearZoom(),
				this.removeChild(this._fadeSprite),
				this.removeChild(this._mapNameWindow),
				this.removeChild(this._windowLayer),
				this.removeChild(this._spriteset);
		}
		needsFadeIn() {
			return (
				SceneManager.isPreviousScene(Scene_Battle) ||
				SceneManager.isPreviousScene(Scene_Load)
			);
		}
		needsSlowFadeOut() {
			return (
				SceneManager.isNextScene(Scene_Title) ||
				SceneManager.isNextScene(Scene_Gameover)
			);
		}
		updateWaitCount() {
			return this._waitCount > 0 && (this._waitCount--, !0);
		}
		updateDestination() {
			this.isMapTouchOk()
				? this.processMapTouch()
				: (self.$gameTemp.clearDestination(), (this._touchCount = 0));
		}
		isMapTouchOk() {
			return this.isActive() && self.$gamePlayer.canMove();
		}
		processMapTouch() {
			if (TouchInput.isTriggered() || this._touchCount > 0)
				if (TouchInput.isPressed()) {
					if (0 === this._touchCount || this._touchCount >= 15) {
						const t = self.$gameMap.canvasToMapX(TouchInput.x),
							e = self.$gameMap.canvasToMapY(TouchInput.y);
						self.$gameTemp.setDestination(t, e);
					}
					this._touchCount++;
				} else this._touchCount = 0;
		}
		isSceneChangeOk() {
			return this.isActive() && !self.$gameMessage.isBusy();
		}
		updateScene() {
			this.checkGameover(),
				SceneManager.isSceneChanging() || this.updateTransferPlayer(),
				SceneManager.isSceneChanging() || this.updateEncounter(),
				SceneManager.isSceneChanging() || this.updateCallMenu(),
				SceneManager.isSceneChanging() || this.updateCallDebug();
		}
		createDisplayObjects() {
			this.createSpriteset(),
				this.createMapNameWindow(),
				this.createWindowLayer(),
				this.createAllWindows();
		}
		createSpriteset() {
			(this._spriteset = new Spriteset_Map()), this.addChild(this._spriteset);
		}
		createAllWindows() {
			this.createMessageWindow(), this.createScrollTextWindow();
		}
		createMapNameWindow() {
			(this._mapNameWindow = new Window_MapName()),
				this.addChild(this._mapNameWindow);
		}
		createMessageWindow() {
			(this._messageWindow = new Window_Message()),
				this.addWindow(this._messageWindow),
				this._messageWindow.subWindows().forEach(function (t) {
					this.addWindow(t);
				}, this);
		}
		createScrollTextWindow() {
			(this._scrollTextWindow = new Window_ScrollText()),
				this.addWindow(this._scrollTextWindow);
		}
		updateTransferPlayer() {
			self.$gamePlayer.isTransferring() && SceneManager.goto(Scene_Map);
		}
		updateEncounter() {
			self.$gamePlayer.executeEncounter() && SceneManager.push(Scene_Battle);
		}
		updateCallMenu() {
			this.isMenuEnabled()
				? (this.isMenuCalled() && (this.menuCalling = !0),
				  this.menuCalling && !self.$gamePlayer.isMoving() && this.callMenu())
				: (this.menuCalling = !1);
		}
		isMenuEnabled() {
			return (
				self.$gameSystem.isMenuEnabled() && !self.$gameMap.isEventRunning()
			);
		}
		isMenuCalled() {
			return Input.isTriggered('menu') || TouchInput.isCancelled();
		}
		callMenu() {
			SoundManager.playOk(),
				SceneManager.push(Scene_Menu),
				Window_MenuCommand.initCommandPosition(),
				self.$gameTemp.clearDestination(),
				this._mapNameWindow.hide(),
				(this._waitCount = 2);
		}
		updateCallDebug() {
			this.isDebugCalled() && SceneManager.push(Scene_Debug);
		}
		isDebugCalled() {
			return Input.isTriggered('debug') && self.$gameTemp.isPlaytest();
		}
		fadeInForTransfer() {
			const t = self.$gamePlayer.fadeType();
			switch (t) {
				case 0:
				case 1:
					this.startFadeIn(this.fadeSpeed(), 1 === t);
			}
		}
		fadeOutForTransfer() {
			const t = self.$gamePlayer.fadeType();
			switch (t) {
				case 0:
				case 1:
					this.startFadeOut(this.fadeSpeed(), 1 === t);
			}
		}
		launchBattle() {
			BattleManager.saveBgmAndBgs(),
				this.stopAudioOnBattleStart(),
				SoundManager.playBattleStart(),
				this.startEncounterEffect(),
				this._mapNameWindow.hide();
		}
		stopAudioOnBattleStart() {
			AudioManager.isCurrentBgm(self.$gameSystem.battleBgm()) ||
				AudioManager.stopBgm(),
				AudioManager.stopBgs(),
				AudioManager.stopMe(),
				AudioManager.stopSe();
		}
		startEncounterEffect() {
			this._spriteset.hideCharacters(),
				(this._encounterEffectDuration = this.encounterEffectSpeed());
		}
		updateEncounterEffect() {
			if (this._encounterEffectDuration > 0) {
				this._encounterEffectDuration--;
				const t = this.encounterEffectSpeed(),
					e = t - this._encounterEffectDuration,
					i = e / t,
					r = (20 * (i - 1) * i + 5) * i + 1,
					s = self.$gamePlayer.screenX(),
					n = self.$gamePlayer.screenY() - 24;
				2 === e &&
					(self.$gameScreen.setZoom(s, n, 1),
					this.snapForBattleBackground(),
					this.startFlashForEncounter(t / 2)),
					self.$gameScreen.setZoom(s, n, r),
					e === Math.floor(t / 6) && this.startFlashForEncounter(t / 2),
					e === Math.floor(t / 2) &&
						(BattleManager.playBattleBgm(),
						this.startFadeOut(this.fadeSpeed()));
			}
		}
		snapForBattleBackground() {
			(this._windowLayer.visible = !1),
				SceneManager.snapForBackground(),
				(this._windowLayer.visible = !0);
		}
		startFlashForEncounter(t) {
			self.$gameScreen.startFlash([255, 255, 255, 255], t);
		}
		encounterEffectSpeed() {
			return 60;
		}
	}
	class Window_TitleCommand extends Window_Command {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize(0, 0),
				this.updatePlacement(),
				(this.openness = 0),
				this.selectLast();
		}
		static initCommandPosition() {
			this._lastCommandSymbol = null;
		}
		windowWidth() {
			return 240;
		}
		updatePlacement() {
			(this.x = (Graphics.boxWidth - this.width) / 2),
				(this.y = Graphics.boxHeight - this.height - 96);
		}
		makeCommandList() {
			this.addCommand(TextManager.newGame, 'newGame'),
				this.addCommand(
					TextManager.continue_,
					'continue',
					this.isContinueEnabled()
				),
				this.addCommand(TextManager.options, 'options');
		}
		isContinueEnabled() {
			return DataManager$1.isAnySavefileExists();
		}
		processOk() {
			(Window_TitleCommand._lastCommandSymbol = this.currentSymbol()),
				super.processOk();
		}
		selectLast() {
			Window_TitleCommand._lastCommandSymbol
				? this.selectSymbol(Window_TitleCommand._lastCommandSymbol)
				: this.isContinueEnabled() && this.selectSymbol('continue');
		}
	}
	Window_TitleCommand._lastCommandSymbol = null;
	class Scene_Title extends Scene_Base {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize();
		}
		create() {
			super.create(),
				this.createBackground(),
				this.createForeground(),
				this.createWindowLayer(),
				this.createCommandWindow();
		}
		start() {
			super.start(),
				SceneManager.clearStack(),
				this.centerSprite(this._backSprite1),
				this.centerSprite(this._backSprite2),
				this.playTitleMusic(),
				this.startFadeIn(this.fadeSpeed(), !1);
		}
		update() {
			this.isBusy() || this._commandWindow.open(), super.update();
		}
		isBusy() {
			return (
				this._commandWindow.isClosing() ||
				Scene_Base.prototype.isBusy.call(this)
			);
		}
		terminate() {
			super.terminate(), SceneManager.snapForBackground();
		}
		createBackground() {
			(this._backSprite1 = new Sprite(
				ImageManager.loadTitle1(self.$dataSystem.title1Name)
			)),
				(this._backSprite2 = new Sprite(
					ImageManager.loadTitle2(self.$dataSystem.title2Name)
				)),
				this.addChild(this._backSprite1),
				this.addChild(this._backSprite2);
		}
		createForeground() {
			(this._gameTitleSprite = new Sprite(
				new Bitmap(Graphics.width, Graphics.height)
			)),
				this.addChild(this._gameTitleSprite),
				self.$dataSystem.optDrawTitle && this.drawGameTitle();
		}
		drawGameTitle() {
			const t = Graphics.height / 4,
				e = Graphics.width - 40,
				i = self.$dataSystem.gameTitle;
			(this._gameTitleSprite.bitmap.outlineColor = 'black'),
				(this._gameTitleSprite.bitmap.outlineWidth = 8),
				(this._gameTitleSprite.bitmap.fontSize = 72),
				this._gameTitleSprite.bitmap.drawText(i, 20, t, e, 48, 'center');
		}
		centerSprite(t) {
			(t.x = Graphics.width / 2),
				(t.y = Graphics.height / 2),
				(t.anchor.x = 0.5),
				(t.anchor.y = 0.5);
		}
		createCommandWindow() {
			(this._commandWindow = new Window_TitleCommand()),
				this._commandWindow.setHandler(
					'newGame',
					this.commandNewGame.bind(this)
				),
				this._commandWindow.setHandler(
					'continue',
					this.commandContinue.bind(this)
				),
				this._commandWindow.setHandler(
					'options',
					this.commandOptions.bind(this)
				),
				this.addWindow(this._commandWindow);
		}
		commandNewGame() {
			DataManager$1.setupNewGame(),
				this._commandWindow.close(),
				this.fadeOutAll(),
				SceneManager.goto(Scene_Map);
		}
		commandContinue() {
			this._commandWindow.close(), SceneManager.push(Scene_Load);
		}
		commandOptions() {
			this._commandWindow.close(), SceneManager.push(Scene_Options);
		}
		playTitleMusic() {
			AudioManager.playBgm(self.$dataSystem.titleBgm),
				AudioManager.stopBgs(),
				AudioManager.stopMe();
		}
	}
	class Scene_Gameover extends Scene_Base {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize();
		}
		create() {
			super.create(), this.playGameoverMusic(), this.createBackground();
		}
		start() {
			super.start(), this.startFadeIn(this.slowFadeSpeed(), !1);
		}
		update() {
			this.isActive() &&
				!this.isBusy() &&
				this.isTriggered() &&
				this.gotoTitle(),
				super.update();
		}
		stop() {
			super.stop(), this.fadeOutAll();
		}
		terminate() {
			super.terminate(), AudioManager.stopAll();
		}
		playGameoverMusic() {
			AudioManager.stopBgm(),
				AudioManager.stopBgs(),
				AudioManager.playMe(self.$dataSystem.gameoverMe);
		}
		createBackground() {
			(this._backSprite = new Sprite()),
				(this._backSprite.bitmap = ImageManager.loadSystem('GameOver')),
				this.addChild(this._backSprite);
		}
		isTriggered() {
			return Input.isTriggered('ok') || TouchInput.isTriggered();
		}
		gotoTitle() {
			SceneManager.goto(Scene_Title);
		}
	}
	class BattleManager {
		constructor() {
			throw new Error('This is a static class');
		}
		static setup(t, e, i) {
			this.initMembers(),
				(this._canEscape = e),
				(this._canLose = i),
				self.$gameTroop.setup(t),
				self.$gameScreen.onBattleStart(),
				this.makeEscapeRatio();
		}
		static initMembers() {
			(this._phase = 'init'),
				(this._canEscape = !1),
				(this._canLose = !1),
				(this._battleTest = !1),
				(this._eventCallback = null),
				(this._preemptive = !1),
				(this._surprise = !1),
				(this._actorIndex = -1),
				(this._actionForcedBattler = null),
				(this._mapBgm = null),
				(this._mapBgs = null),
				(this._actionBattlers = []),
				(this._subject = null),
				(this._action = null),
				(this._targets = []),
				(this._logWindow = null),
				(this._statusWindow = null),
				(this._spriteset = null),
				(this._escapeRatio = 0),
				(this._escaped = !1),
				(this._rewards = {}),
				(this._turnForced = !1);
		}
		static isBattleTest() {
			return this._battleTest;
		}
		static setBattleTest(t) {
			this._battleTest = t;
		}
		static setEventCallback(t) {
			this._eventCallback = t;
		}
		static setLogWindow(t) {
			this._logWindow = t;
		}
		static setStatusWindow(t) {
			this._statusWindow = t;
		}
		static setSpriteset(t) {
			this._spriteset = t;
		}
		static onEncounter() {
			(this._preemptive = Math.random() < this.ratePreemptive()),
				(this._surprise =
					Math.random() < this.rateSurprise() && !this._preemptive);
		}
		static saveBgmAndBgs() {
			(this._mapBgm = AudioManager.saveBgm()),
				(this._mapBgs = AudioManager.saveBgs());
		}
		static replayBgmAndBgs() {
			this._mapBgm
				? AudioManager.replayBgm(this._mapBgm)
				: AudioManager.stopBgm(),
				this._mapBgs && AudioManager.replayBgs(this._mapBgs);
		}
		static makeEscapeRatio() {
			this._escapeRatio =
				(0.5 * self.$gameParty.agility()) / self.$gameTroop.agility();
		}
		static update() {
			if (!this.isBusy() && !this.updateEvent())
				switch (this._phase) {
					case 'start':
						this.startInput();
						break;
					case 'turn':
						this.updateTurn();
						break;
					case 'action':
						this.updateAction();
						break;
					case 'turnEnd':
						this.updateTurnEnd();
						break;
					case 'battleEnd':
						this.updateBattleEnd();
				}
		}
		static updateEvent() {
			switch (this._phase) {
				case 'start':
				case 'turn':
				case 'turnEnd':
					return this.isActionForced()
						? (this.processForcedAction(), !0)
						: this.updateEventMain();
			}
			return this.checkAbort();
		}
		static updateEventMain() {
			return (
				self.$gameTroop.updateInterpreter(),
				self.$gameParty.requestMotionRefresh(),
				!!(
					self.$gameTroop.isEventRunning() ||
					this.checkBattleEnd() ||
					(self.$gameTroop.setupBattleEvent(),
					self.$gameTroop.isEventRunning() || SceneManager.isSceneChanging())
				)
			);
		}
		static isBusy() {
			return (
				self.$gameMessage.isBusy() ||
				this._spriteset.isBusy() ||
				this._logWindow.isBusy()
			);
		}
		static isInputting() {
			return 'input' === this._phase;
		}
		static isInTurn() {
			return 'turn' === this._phase;
		}
		static isTurnEnd() {
			return 'turnEnd' === this._phase;
		}
		static isAborting() {
			return 'aborting' === this._phase;
		}
		static isBattleEnd() {
			return 'battleEnd' === this._phase;
		}
		static canEscape() {
			return this._canEscape;
		}
		static canLose() {
			return this._canLose;
		}
		static isEscaped() {
			return this._escaped;
		}
		static actor() {
			return this._actorIndex >= 0
				? self.$gameParty.members()[this._actorIndex]
				: null;
		}
		static clearActor() {
			this.changeActor(-1, '');
		}
		static changeActor(t, e) {
			const i = this.actor();
			this._actorIndex = t;
			const r = this.actor();
			i && i.setActionState(e), r && r.setActionState('inputting');
		}
		static startBattle() {
			(this._phase = 'start'),
				self.$gameSystem.onBattleStart(),
				self.$gameParty.onBattleStart(),
				self.$gameTroop.onBattleStart(),
				this.displayStartMessages();
		}
		static displayStartMessages() {
			self.$gameTroop.enemyNames().forEach((t) => {
				self.$gameMessage.add(TextManager.emerge.format(t));
			}),
				this._preemptive
					? self.$gameMessage.add(
							TextManager.preemptive.format(self.$gameParty.name())
					  )
					: this._surprise &&
					  self.$gameMessage.add(
							TextManager.surprise.format(self.$gameParty.name())
					  );
		}
		static startInput() {
			(this._phase = 'input'),
				self.$gameParty.makeActions(),
				self.$gameTroop.makeActions(),
				this.clearActor(),
				(!this._surprise && self.$gameParty.canInput()) || this.startTurn();
		}
		static inputtingAction() {
			const t = this.actor();
			return t ? t.inputtingAction() : null;
		}
		static selectNextCommand() {
			do {
				const t = this.actor();
				if (
					(!t || !t.selectNextCommand()) &&
					(this.changeActor(this._actorIndex + 1, 'waiting'),
					this._actorIndex >= self.$gameParty.size())
				) {
					this.startTurn();
					break;
				}
			} while (!this.actor().canInput());
		}
		static selectPreviousCommand() {
			do {
				const t = this.actor();
				if (
					(!t || !t.selectPreviousCommand()) &&
					(this.changeActor(this._actorIndex - 1, 'undecided'),
					this._actorIndex < 0)
				)
					return;
			} while (!this.actor().canInput());
		}
		static refreshStatus() {
			this._statusWindow.refresh();
		}
		static startTurn() {
			(this._phase = 'turn'),
				this.clearActor(),
				self.$gameTroop.increaseTurn(),
				this.makeActionOrders(),
				self.$gameParty.requestMotionRefresh(),
				this._logWindow.startTurn();
		}
		static updateTurn() {
			self.$gameParty.requestMotionRefresh(),
				this._subject || (this._subject = this.getNextSubject()),
				this._subject ? this.processTurn() : this.endTurn();
		}
		static processTurn() {
			const t = this._subject,
				e = t.currentAction();
			e
				? (e.prepare(),
				  e.isValid() && this.startAction(),
				  t.removeCurrentAction())
				: (t.onAllActionsEnd(),
				  this.refreshStatus(),
				  this._logWindow.displayAutoAffectedStatus(t),
				  this._logWindow.displayCurrentState(t),
				  this._logWindow.displayRegeneration(t),
				  (this._subject = this.getNextSubject()));
		}
		static endTurn() {
			(this._phase = 'turnEnd'),
				(this._preemptive = !1),
				(this._surprise = !1),
				this.allBattleMembers().forEach(function (t) {
					t.onTurnEnd(),
						this.refreshStatus(),
						this._logWindow.displayAutoAffectedStatus(t),
						this._logWindow.displayRegeneration(t);
				}, this),
				this.isForcedTurn() && (this._turnForced = !1);
		}
		static isForcedTurn() {
			return this._turnForced;
		}
		static updateTurnEnd() {
			this.startInput();
		}
		static getNextSubject() {
			for (;;) {
				const t = this._actionBattlers.shift();
				if (!t) return null;
				if (t.isBattleMember() && t.isAlive()) return t;
			}
		}
		static makeActionOrders() {
			let t = [];
			this._surprise || (t = t.concat(self.$gameParty.members())),
				this._preemptive || (t = t.concat(self.$gameTroop.members())),
				t.forEach((t) => {
					t.makeSpeed();
				}),
				t.sort((t, e) => e.speed() - t.speed()),
				(this._actionBattlers = t);
		}
		static startAction() {
			const t = this._subject,
				e = t.currentAction(),
				i = e.makeTargets();
			(this._phase = 'action'),
				(this._action = e),
				(this._targets = i),
				t.useItem(e.item()),
				this._action.applyGlobal(),
				this.refreshStatus(),
				this._logWindow.startAction(t, e, i);
		}
		static updateAction() {
			const t = this._targets.shift();
			t ? this.invokeAction(this._subject, t) : this.endAction();
		}
		static endAction() {
			this._logWindow.endAction(this._subject), (this._phase = 'turn');
		}
		static invokeAction(t, e) {
			this._logWindow.push('pushBaseLine'),
				Math.random() < this._action.itemCnt(e)
					? this.invokeCounterAttack(t, e)
					: Math.random() < this._action.itemMrf(e)
					? this.invokeMagicReflection(t, e)
					: this.invokeNormalAction(t, e),
				t.setLastTarget(e),
				this._logWindow.push('popBaseLine'),
				this.refreshStatus();
		}
		static invokeNormalAction(t, e) {
			const i = this.applySubstitute(e);
			this._action.apply(i), this._logWindow.displayActionResults(t, i);
		}
		static invokeCounterAttack(t, e) {
			const i = new Game_Action(e);
			i.setAttack(),
				i.apply(t),
				this._logWindow.displayCounter(e),
				this._logWindow.displayActionResults(e, t);
		}
		static invokeMagicReflection(t, e) {
			(this._action._reflectionTarget = e),
				this._logWindow.displayReflection(e),
				this._action.apply(t),
				this._logWindow.displayActionResults(e, t);
		}
		static applySubstitute(t) {
			if (this.checkSubstitute(t)) {
				const e = t.friendsUnit().substituteBattler();
				if (e && t !== e) return this._logWindow.displaySubstitute(e, t), e;
			}
			return t;
		}
		static checkSubstitute(t) {
			return t.isDying() && !this._action.isCertainHit();
		}
		static isActionForced() {
			return !!this._actionForcedBattler;
		}
		static forceAction(t) {
			this._actionForcedBattler = t;
			const e = this._actionBattlers.indexOf(t);
			e >= 0 && this._actionBattlers.splice(e, 1);
		}
		static processForcedAction() {
			this._actionForcedBattler &&
				((this._turnForced = !0),
				(this._subject = this._actionForcedBattler),
				(this._actionForcedBattler = null),
				this.startAction(),
				this._subject.removeCurrentAction());
		}
		static abort() {
			this._phase = 'aborting';
		}
		static checkBattleEnd() {
			if (this._phase) {
				if (this.checkAbort()) return !0;
				if (self.$gameParty.isAllDead()) return this.processDefeat(), !0;
				if (self.$gameTroop.isAllDead()) return this.processVictory(), !0;
			}
			return !1;
		}
		static checkAbort() {
			return (
				(self.$gameParty.isEmpty() || this.isAborting()) &&
					(SoundManager.playEscape(),
					(this._escaped = !0),
					this.processAbort()),
				!1
			);
		}
		static processVictory() {
			self.$gameParty.removeBattleStates(),
				self.$gameParty.performVictory(),
				this.playVictoryMe(),
				this.replayBgmAndBgs(),
				this.makeRewards(),
				this.displayVictoryMessage(),
				this.displayRewards(),
				this.gainRewards(),
				this.endBattle(0);
		}
		static processEscape() {
			self.$gameParty.performEscape(), SoundManager.playEscape();
			const t = this.processEscapeFormula();
			return (
				t
					? (this.displayEscapeSuccessMessage(),
					  (this._escaped = !0),
					  this.processAbort())
					: (this.displayEscapeFailureMessage(),
					  (this._escapeRatio += 0.1),
					  self.$gameParty.clearActions(),
					  this.startTurn()),
				t
			);
		}
		static processEscapeFormula() {
			return !!this._preemptive || Math.random() < this._escapeRatio;
		}
		static processAbort() {
			self.$gameParty.removeBattleStates(),
				this.replayBgmAndBgs(),
				this.endBattle(1);
		}
		static processDefeat() {
			this.displayDefeatMessage(),
				this.playDefeatMe(),
				this._canLose ? this.replayBgmAndBgs() : AudioManager.stopBgm(),
				this.endBattle(2);
		}
		static endBattle(t) {
			(this._phase = 'battleEnd'),
				this._eventCallback && this._eventCallback(t),
				0 === t
					? self.$gameSystem.onBattleWin()
					: this._escaped && self.$gameSystem.onBattleEscape();
		}
		static updateBattleEnd() {
			this.isBattleTest()
				? (AudioManager.stopBgm(), SceneManager.exit())
				: !this._escaped && self.$gameParty.isAllDead()
				? this._canLose
					? (self.$gameParty.reviveBattleMembers(), SceneManager.pop())
					: SceneManager.goto(Scene_Gameover)
				: SceneManager.pop(),
				(this._phase = null);
		}
		static makeRewards() {
			(this._rewards = {}),
				(this._rewards.gold = self.$gameTroop.goldTotal()),
				(this._rewards.exp = self.$gameTroop.expTotal()),
				(this._rewards.items = self.$gameTroop.makeDropItems());
		}
		static displayRewards() {
			this.displayExp(), this.displayGold(), this.displayDropItems();
		}
		static displayExp() {
			const t = this._rewards.exp;
			if (t > 0) {
				const e = TextManager.obtainExp.format(t, TextManager.exp);
				self.$gameMessage.add(`\\.${e}`);
			}
		}
		static displayGold() {
			const t = this._rewards.gold;
			t > 0 && self.$gameMessage.add(`\\.${TextManager.obtainGold.format(t)}`);
		}
		static displayDropItems() {
			const t = this._rewards.items;
			t.length > 0 &&
				(self.$gameMessage.newPage(),
				t.forEach(({ name: t }) => {
					self.$gameMessage.add(TextManager.obtainItem.format(t));
				}));
		}
		static gainRewards() {
			this.gainExp(), this.gainGold(), this.gainDropItems();
		}
		static gainExp() {
			const t = this._rewards.exp;
			self.$gameParty.allMembers().forEach((e) => {
				e.gainExp(t);
			});
		}
		static gainGold() {
			self.$gameParty.gainGold(this._rewards.gold);
		}
		static gainDropItems() {
			this._rewards.items.forEach((t) => {
				self.$gameParty.gainItem(t, 1);
			});
		}
		static ratePreemptive() {
			return self.$gameParty.ratePreemptive(self.$gameTroop.agility());
		}
		static rateSurprise() {
			return self.$gameParty.rateSurprise(self.$gameTroop.agility());
		}
		static playBattleBgm() {
			AudioManager.playBgm(self.$gameSystem.battleBgm()),
				AudioManager.stopBgs();
		}
		static playVictoryMe() {
			AudioManager.playMe(self.$gameSystem.victoryMe());
		}
		static playDefeatMe() {
			AudioManager.playMe(self.$gameSystem.defeatMe());
		}
		static allBattleMembers() {
			return self.$gameParty.members().concat(self.$gameTroop.members());
		}
		static displayVictoryMessage() {
			self.$gameMessage.add(TextManager.victory.format(self.$gameParty.name()));
		}
		static displayDefeatMessage() {
			self.$gameMessage.add(TextManager.defeat.format(self.$gameParty.name()));
		}
		static displayEscapeSuccessMessage() {
			self.$gameMessage.add(
				TextManager.escapeStart.format(self.$gameParty.name())
			);
		}
		static displayEscapeFailureMessage() {
			self.$gameMessage.add(
				TextManager.escapeStart.format(self.$gameParty.name())
			),
				self.$gameMessage.add(`\\.${TextManager.escapeFailure}`);
		}
	}
	class Scene_Boot extends Scene_Base {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize(), (this._startDate = Date.now());
		}
		async create() {
			super.create(),
				DataManager$1.loadDatabase(),
				await ConfigManager.load(),
				this.loadSystemWindowImage(),
				DataManager$1.loadGlobalInfoAsync();
		}
		loadSystemWindowImage() {
			ImageManager.reserveSystem('Window');
		}
		isReady() {
			return (
				!!Scene_Base.prototype.isReady.call(this) &&
				DataManager$1._globalInfo &&
				DataManager$1.isDatabaseLoaded() &&
				this.isGameFontLoaded()
			);
		}
		isGameFontLoaded() {
			if (Graphics.isFontLoaded('GameFont')) return !0;
			if (
				!Graphics.canUseCssFontLoading() &&
				Date.now() - this._startDate >= 6e4
			)
				throw new Error('Failed to load GameFont');
		}
		start() {
			super.start(),
				SoundManager.preloadImportantSounds(),
				DataManager$1.isBattleTest()
					? (DataManager$1.setupBattleTest(), SceneManager.goto(Scene_Battle))
					: DataManager$1.isEventTest()
					? (DataManager$1.setupEventTest(), SceneManager.goto(Scene_Map))
					: (this.checkPlayerLocation(),
					  DataManager$1.setupNewGame(),
					  SceneManager.goto(Scene_Title),
					  Window_TitleCommand.initCommandPosition()),
				this.updateDocumentTitle();
		}
		updateDocumentTitle() {
			document.title = self.$dataSystem.gameTitle;
		}
		checkPlayerLocation() {
			if (0 === self.$dataSystem.startMapId)
				throw new Error("Player's starting position is not set");
		}
		static loadSystemImages() {
			ImageManager.reserveSystem('IconSet'),
				ImageManager.reserveSystem('Balloon'),
				ImageManager.reserveSystem('Shadow1'),
				ImageManager.reserveSystem('Shadow2'),
				ImageManager.reserveSystem('Damage'),
				ImageManager.reserveSystem('States'),
				ImageManager.reserveSystem('Weapons1'),
				ImageManager.reserveSystem('Weapons2'),
				ImageManager.reserveSystem('Weapons3'),
				ImageManager.reserveSystem('ButtonSet');
		}
	}
	class Game_Temp {
		constructor(...t) {
			this.initialize(...t);
		}
		initialize() {
			(this._isPlaytest = Utils.isOptionValid('test')),
				(this._commonEventId = 0),
				(this._destinationX = null),
				(this._destinationY = null);
		}
		isPlaytest() {
			return this._isPlaytest;
		}
		reserveCommonEvent(t) {
			this._commonEventId = t;
		}
		clearCommonEvent() {
			this._commonEventId = 0;
		}
		isCommonEventReserved() {
			return this._commonEventId > 0;
		}
		reservedCommonEvent() {
			return self.$dataCommonEvents[this._commonEventId];
		}
		reservedCommonEventId() {
			return this._commonEventId;
		}
		setDestination(t, e) {
			(this._destinationX = t), (this._destinationY = e);
		}
		clearDestination() {
			(this._destinationX = null), (this._destinationY = null);
		}
		isDestinationValid() {
			return null !== this._destinationX;
		}
		destinationX() {
			return this._destinationX;
		}
		destinationY() {
			return this._destinationY;
		}
	}
	class Game_System {
		constructor(...t) {
			this.initialize(...t);
		}
		initialize() {
			(this._saveEnabled = !0),
				(this._menuEnabled = !0),
				(this._encounterEnabled = !0),
				(this._formationEnabled = !0),
				(this._battleCount = 0),
				(this._winCount = 0),
				(this._escapeCount = 0),
				(this._saveCount = 0),
				(this._versionId = 0),
				(this._framesOnSave = 0),
				(this._sceneFramesOnSave = 0),
				(this._bgmOnSave = null),
				(this._bgsOnSave = null),
				(this._windowTone = null),
				(this._battleBgm = null),
				(this._victoryMe = null),
				(this._defeatMe = null),
				(this._savedBgm = null),
				(this._walkingBgm = null);
		}
		isJapanese() {
			return self.$dataSystem.locale.match(/^ja/);
		}
		isChinese() {
			return self.$dataSystem.locale.match(/^zh/);
		}
		isKorean() {
			return self.$dataSystem.locale.match(/^ko/);
		}
		isCJK() {
			return self.$dataSystem.locale.match(/^(ja|zh|ko)/);
		}
		isRussian() {
			return self.$dataSystem.locale.match(/^ru/);
		}
		isSideView() {
			return self.$dataSystem.optSideView;
		}
		isSaveEnabled() {
			return this._saveEnabled;
		}
		disableSave() {
			this._saveEnabled = !1;
		}
		enableSave() {
			this._saveEnabled = !0;
		}
		isMenuEnabled() {
			return this._menuEnabled;
		}
		disableMenu() {
			this._menuEnabled = !1;
		}
		enableMenu() {
			this._menuEnabled = !0;
		}
		isEncounterEnabled() {
			return this._encounterEnabled;
		}
		disableEncounter() {
			this._encounterEnabled = !1;
		}
		enableEncounter() {
			this._encounterEnabled = !0;
		}
		isFormationEnabled() {
			return this._formationEnabled;
		}
		disableFormation() {
			this._formationEnabled = !1;
		}
		enableFormation() {
			this._formationEnabled = !0;
		}
		battleCount() {
			return this._battleCount;
		}
		winCount() {
			return this._winCount;
		}
		escapeCount() {
			return this._escapeCount;
		}
		saveCount() {
			return this._saveCount;
		}
		versionId() {
			return this._versionId;
		}
		windowTone() {
			return this._windowTone || self.$dataSystem.windowTone;
		}
		setWindowTone(t) {
			this._windowTone = t;
		}
		battleBgm() {
			return this._battleBgm || self.$dataSystem.battleBgm;
		}
		setBattleBgm(t) {
			this._battleBgm = t;
		}
		victoryMe() {
			return this._victoryMe || self.$dataSystem.victoryMe;
		}
		setVictoryMe(t) {
			this._victoryMe = t;
		}
		defeatMe() {
			return this._defeatMe || self.$dataSystem.defeatMe;
		}
		setDefeatMe(t) {
			this._defeatMe = t;
		}
		onBattleStart() {
			this._battleCount++;
		}
		onBattleWin() {
			this._winCount++;
		}
		onBattleEscape() {
			this._escapeCount++;
		}
		onBeforeSave() {
			this._saveCount++,
				(this._versionId = self.$dataSystem.versionId),
				(this._framesOnSave = Graphics.frameCount),
				(this._sceneFramesOnSave = SceneManager.frameCount()),
				(this._bgmOnSave = AudioManager.saveBgm()),
				(this._bgsOnSave = AudioManager.saveBgs());
		}
		onAfterLoad() {
			(Graphics.frameCount = this._framesOnSave),
				SceneManager.setFrameCount(
					this._sceneFramesOnSave || this._framesOnSave
				),
				AudioManager.playBgm(this._bgmOnSave),
				AudioManager.playBgs(this._bgsOnSave);
		}
		playtime() {
			return Math.floor(SceneManager.frameCount() / 60);
		}
		playtimeText() {
			const t = Math.floor(this.playtime() / 60 / 60),
				e = Math.floor(this.playtime() / 60) % 60,
				i = this.playtime() % 60;
			return `${t.padZero(2)}:${e.padZero(2)}:${i.padZero(2)}`;
		}
		saveBgm() {
			this._savedBgm = AudioManager.saveBgm();
		}
		replayBgm() {
			this._savedBgm && AudioManager.replayBgm(this._savedBgm);
		}
		saveWalkingBgm() {
			this._walkingBgm = AudioManager.saveBgm();
		}
		replayWalkingBgm() {
			this._walkingBgm && AudioManager.playBgm(this._walkingBgm);
		}
		saveWalkingBgm2() {
			this._walkingBgm = self.$dataMap.bgm;
		}
	}
	class Game_Picture {
		constructor(...t) {
			this.initialize(...t);
		}
		initialize() {
			this.initBasic(), this.initTarget(), this.initTone(), this.initRotation();
		}
		name() {
			return this._name;
		}
		origin() {
			return this._origin;
		}
		x() {
			return this._x;
		}
		y() {
			return this._y;
		}
		scaleX() {
			return this._scaleX;
		}
		scaleY() {
			return this._scaleY;
		}
		opacity() {
			return this._opacity;
		}
		blendMode() {
			return this._blendMode;
		}
		tone() {
			return this._tone;
		}
		angle() {
			return this._angle;
		}
		initBasic() {
			(this._name = ''),
				(this._origin = 0),
				(this._x = 0),
				(this._y = 0),
				(this._scaleX = 100),
				(this._scaleY = 100),
				(this._opacity = 255),
				(this._blendMode = 0);
		}
		initTarget() {
			(this._targetX = this._x),
				(this._targetY = this._y),
				(this._targetScaleX = this._scaleX),
				(this._targetScaleY = this._scaleY),
				(this._targetOpacity = this._opacity),
				(this._duration = 0);
		}
		initTone() {
			(this._tone = null), (this._toneTarget = null), (this._toneDuration = 0);
		}
		initRotation() {
			(this._angle = 0), (this._rotationSpeed = 0);
		}
		show(t, e, i, r, s, n, a, o) {
			(this._name = t),
				(this._origin = e),
				(this._x = i),
				(this._y = r),
				(this._scaleX = s),
				(this._scaleY = n),
				(this._opacity = a),
				(this._blendMode = o),
				this.initTarget(),
				this.initTone(),
				this.initRotation();
		}
		move(t, e, i, r, s, n, a, o) {
			(this._origin = t),
				(this._targetX = e),
				(this._targetY = i),
				(this._targetScaleX = r),
				(this._targetScaleY = s),
				(this._targetOpacity = n),
				(this._blendMode = a),
				(this._duration = o);
		}
		rotate(t) {
			this._rotationSpeed = t;
		}
		tint(t, e) {
			this._tone || (this._tone = [0, 0, 0, 0]),
				(this._toneTarget = t.clone()),
				(this._toneDuration = e),
				0 === this._toneDuration && (this._tone = this._toneTarget.clone());
		}
		erase() {
			(this._name = ''),
				(this._origin = 0),
				this.initTarget(),
				this.initTone(),
				this.initRotation();
		}
		update() {
			this.updateMove(), this.updateTone(), this.updateRotation();
		}
		updateMove() {
			if (this._duration > 0) {
				const t = this._duration;
				(this._x = (this._x * (t - 1) + this._targetX) / t),
					(this._y = (this._y * (t - 1) + this._targetY) / t),
					(this._scaleX = (this._scaleX * (t - 1) + this._targetScaleX) / t),
					(this._scaleY = (this._scaleY * (t - 1) + this._targetScaleY) / t),
					(this._opacity = (this._opacity * (t - 1) + this._targetOpacity) / t),
					this._duration--;
			}
		}
		updateTone() {
			if (this._toneDuration > 0) {
				const t = this._toneDuration;
				for (let e = 0; e < 4; e++)
					this._tone[e] = (this._tone[e] * (t - 1) + this._toneTarget[e]) / t;
				this._toneDuration--;
			}
		}
		updateRotation() {
			0 !== this._rotationSpeed && (this._angle += this._rotationSpeed / 2);
		}
	}
	class Game_Screen {
		constructor(...t) {
			this.initialize(...t);
		}
		initialize() {
			this.clear();
		}
		clear() {
			this.clearFade(),
				this.clearTone(),
				this.clearFlash(),
				this.clearShake(),
				this.clearZoom(),
				this.clearWeather(),
				this.clearPictures();
		}
		onBattleStart() {
			this.clearFade(),
				this.clearFlash(),
				this.clearShake(),
				this.clearZoom(),
				this.eraseBattlePictures();
		}
		brightness() {
			return this._brightness;
		}
		tone() {
			return this._tone;
		}
		flashColor() {
			return this._flashColor;
		}
		shake() {
			return this._shake;
		}
		zoomX() {
			return this._zoomX;
		}
		zoomY() {
			return this._zoomY;
		}
		zoomScale() {
			return this._zoomScale;
		}
		weatherType() {
			return this._weatherType;
		}
		weatherPower() {
			return this._weatherPower;
		}
		picture(t) {
			const e = this.realPictureId(t);
			return this._pictures[e];
		}
		realPictureId(t) {
			return self.$gameParty.inBattle() ? t + this.maxPictures() : t;
		}
		clearFade() {
			(this._brightness = 255),
				(this._fadeOutDuration = 0),
				(this._fadeInDuration = 0);
		}
		clearTone() {
			(this._tone = [0, 0, 0, 0]),
				(this._toneTarget = [0, 0, 0, 0]),
				(this._toneDuration = 0);
		}
		clearFlash() {
			(this._flashColor = [0, 0, 0, 0]), (this._flashDuration = 0);
		}
		clearShake() {
			(this._shakePower = 0),
				(this._shakeSpeed = 0),
				(this._shakeDuration = 0),
				(this._shakeDirection = 1),
				(this._shake = 0);
		}
		clearZoom() {
			(this._zoomX = 0),
				(this._zoomY = 0),
				(this._zoomScale = 1),
				(this._zoomScaleTarget = 1),
				(this._zoomDuration = 0);
		}
		clearWeather() {
			(this._weatherType = 'none'),
				(this._weatherPower = 0),
				(this._weatherPowerTarget = 0),
				(this._weatherDuration = 0);
		}
		clearPictures() {
			this._pictures = [];
		}
		eraseBattlePictures() {
			this._pictures = this._pictures.slice(0, this.maxPictures() + 1);
		}
		maxPictures() {
			return 100;
		}
		startFadeOut(t) {
			(this._fadeOutDuration = t), (this._fadeInDuration = 0);
		}
		startFadeIn(t) {
			(this._fadeInDuration = t), (this._fadeOutDuration = 0);
		}
		startTint(t, e) {
			(this._toneTarget = t.clone()),
				(this._toneDuration = e),
				0 === this._toneDuration && (this._tone = this._toneTarget.clone());
		}
		startFlash(t, e) {
			(this._flashColor = t.clone()), (this._flashDuration = e);
		}
		startShake(t, e, i) {
			(this._shakePower = t), (this._shakeSpeed = e), (this._shakeDuration = i);
		}
		startZoom(t, e, i, r) {
			(this._zoomX = t),
				(this._zoomY = e),
				(this._zoomScaleTarget = i),
				(this._zoomDuration = r);
		}
		setZoom(t, e, i) {
			(this._zoomX = t), (this._zoomY = e), (this._zoomScale = i);
		}
		changeWeather(t, e, i) {
			('none' === t && 0 !== i) || (this._weatherType = t),
				(this._weatherPowerTarget = 'none' === t ? 0 : e),
				(this._weatherDuration = i),
				0 === i && (this._weatherPower = this._weatherPowerTarget);
		}
		update() {
			this.updateFadeOut(),
				this.updateFadeIn(),
				this.updateTone(),
				this.updateFlash(),
				this.updateShake(),
				this.updateZoom(),
				this.updateWeather(),
				this.updatePictures();
		}
		updateFadeOut() {
			if (this._fadeOutDuration > 0) {
				const t = this._fadeOutDuration;
				(this._brightness = (this._brightness * (t - 1)) / t),
					this._fadeOutDuration--;
			}
		}
		updateFadeIn() {
			if (this._fadeInDuration > 0) {
				const t = this._fadeInDuration;
				(this._brightness = (this._brightness * (t - 1) + 255) / t),
					this._fadeInDuration--;
			}
		}
		updateTone() {
			if (this._toneDuration > 0) {
				const t = this._toneDuration;
				for (let e = 0; e < 4; e++)
					this._tone[e] = (this._tone[e] * (t - 1) + this._toneTarget[e]) / t;
				this._toneDuration--;
			}
		}
		updateFlash() {
			if (this._flashDuration > 0) {
				const t = this._flashDuration;
				(this._flashColor[3] *= (t - 1) / t), this._flashDuration--;
			}
		}
		updateShake() {
			if (this._shakeDuration > 0 || 0 !== this._shake) {
				const t =
					(this._shakePower * this._shakeSpeed * this._shakeDirection) / 10;
				this._shakeDuration <= 1 && this._shake * (this._shake + t) < 0
					? (this._shake = 0)
					: (this._shake += t),
					this._shake > 2 * this._shakePower && (this._shakeDirection = -1),
					this._shake < 2 * -this._shakePower && (this._shakeDirection = 1),
					this._shakeDuration--;
			}
		}
		updateZoom() {
			if (this._zoomDuration > 0) {
				const t = this._zoomDuration,
					e = this._zoomScaleTarget;
				(this._zoomScale = (this._zoomScale * (t - 1) + e) / t),
					this._zoomDuration--;
			}
		}
		updateWeather() {
			if (this._weatherDuration > 0) {
				const t = this._weatherDuration,
					e = this._weatherPowerTarget;
				(this._weatherPower = (this._weatherPower * (t - 1) + e) / t),
					this._weatherDuration--,
					0 === this._weatherDuration &&
						0 === this._weatherPowerTarget &&
						(this._weatherType = 'none');
			}
		}
		updatePictures() {
			this._pictures.forEach((t) => {
				t && t.update();
			});
		}
		startFlashForDamage() {
			this.startFlash([255, 0, 0, 128], 8);
		}
		showPicture(t, e, i, r, s, n, a, o, h) {
			const u = this.realPictureId(t),
				l = new Game_Picture();
			l.show(e, i, r, s, n, a, o, h), (this._pictures[u] = l);
		}
		movePicture(t, e, i, r, s, n, a, o, h) {
			const u = this.picture(t);
			u && u.move(e, i, r, s, n, a, o, h);
		}
		rotatePicture(t, e) {
			const i = this.picture(t);
			i && i.rotate(e);
		}
		tintPicture(t, e, i) {
			const r = this.picture(t);
			r && r.tint(e, i);
		}
		erasePicture(t) {
			const e = this.realPictureId(t);
			this._pictures[e] = null;
		}
	}
	class Game_Timer {
		constructor(...t) {
			this.initialize(...t);
		}
		initialize() {
			(this._frames = 0), (this._working = !1);
		}
		update(t) {
			t &&
				this._working &&
				this._frames > 0 &&
				(this._frames--, 0 === this._frames && this.onExpire());
		}
		start(t) {
			(this._frames = t), (this._working = !0);
		}
		stop() {
			this._working = !1;
		}
		isWorking() {
			return this._working;
		}
		seconds() {
			return Math.floor(this._frames / 60);
		}
		onExpire() {
			BattleManager.abort();
		}
	}
	class Game_Message {
		constructor(...t) {
			this.initialize(...t);
		}
		initialize() {
			this.clear();
		}
		clear() {
			(this._texts = []),
				(this._choices = []),
				(this._faceName = ''),
				(this._faceIndex = 0),
				(this._background = 0),
				(this._positionType = 2),
				(this._choiceDefaultType = 0),
				(this._choiceCancelType = 0),
				(this._choiceBackground = 0),
				(this._choicePositionType = 2),
				(this._numInputVariableId = 0),
				(this._numInputMaxDigits = 0),
				(this._itemChoiceVariableId = 0),
				(this._itemChoiceItypeId = 0),
				(this._scrollMode = !1),
				(this._scrollSpeed = 2),
				(this._scrollNoFast = !1),
				(this._choiceCallback = null);
		}
		choices() {
			return this._choices;
		}
		faceName() {
			return this._faceName;
		}
		faceIndex() {
			return this._faceIndex;
		}
		background() {
			return this._background;
		}
		positionType() {
			return this._positionType;
		}
		choiceDefaultType() {
			return this._choiceDefaultType;
		}
		choiceCancelType() {
			return this._choiceCancelType;
		}
		choiceBackground() {
			return this._choiceBackground;
		}
		choicePositionType() {
			return this._choicePositionType;
		}
		numInputVariableId() {
			return this._numInputVariableId;
		}
		numInputMaxDigits() {
			return this._numInputMaxDigits;
		}
		itemChoiceVariableId() {
			return this._itemChoiceVariableId;
		}
		itemChoiceItypeId() {
			return this._itemChoiceItypeId;
		}
		scrollMode() {
			return this._scrollMode;
		}
		scrollSpeed() {
			return this._scrollSpeed;
		}
		scrollNoFast() {
			return this._scrollNoFast;
		}
		add(t) {
			this._texts.push(t);
		}
		setFaceImage(t, e) {
			(this._faceName = t), (this._faceIndex = e);
		}
		setBackground(t) {
			this._background = t;
		}
		setPositionType(t) {
			this._positionType = t;
		}
		setChoices(t, e, i) {
			(this._choices = t),
				(this._choiceDefaultType = e),
				(this._choiceCancelType = i);
		}
		setChoiceBackground(t) {
			this._choiceBackground = t;
		}
		setChoicePositionType(t) {
			this._choicePositionType = t;
		}
		setNumberInput(t, e) {
			(this._numInputVariableId = t), (this._numInputMaxDigits = e);
		}
		setItemChoice(t, e) {
			(this._itemChoiceVariableId = t), (this._itemChoiceItypeId = e);
		}
		setScroll(t, e) {
			(this._scrollMode = !0),
				(this._scrollSpeed = t),
				(this._scrollNoFast = e);
		}
		setChoiceCallback(t) {
			this._choiceCallback = t;
		}
		onChoice(t) {
			this._choiceCallback &&
				(this._choiceCallback(t), (this._choiceCallback = null));
		}
		hasText() {
			return this._texts.length > 0;
		}
		isChoice() {
			return this._choices.length > 0;
		}
		isNumberInput() {
			return this._numInputVariableId > 0;
		}
		isItemChoice() {
			return this._itemChoiceVariableId > 0;
		}
		isBusy() {
			return (
				this.hasText() ||
				this.isChoice() ||
				this.isNumberInput() ||
				this.isItemChoice()
			);
		}
		newPage() {
			this._texts.length > 0 && (this._texts[this._texts.length - 1] += '\f');
		}
		allText() {
			return this._texts.join('\n');
		}
	}
	class Game_Switches {
		constructor(...t) {
			this.initialize(...t);
		}
		initialize() {
			this.clear();
		}
		clear() {
			this._data = [];
		}
		value(t) {
			return !!this._data[t];
		}
		setValue(t, e) {
			t > 0 &&
				t < self.$dataSystem.switches.length &&
				((this._data[t] = e), this.onChange());
		}
		onChange() {
			self.$gameMap.requestRefresh();
		}
	}
	class Game_Variables {
		constructor(...t) {
			this.initialize(...t);
		}
		initialize() {
			this.clear();
		}
		clear() {
			this._data = [];
		}
		value(t) {
			return this._data[t] || 0;
		}
		setValue(t, e) {
			t > 0 &&
				t < self.$dataSystem.variables.length &&
				('number' == typeof e && (e = Math.floor(e)),
				(this._data[t] = e),
				this.onChange());
		}
		onChange() {
			self.$gameMap.requestRefresh();
		}
	}
	class Game_SelfSwitches {
		constructor(...t) {
			this.initialize(...t);
		}
		initialize() {
			this.clear();
		}
		clear() {
			this._data = {};
		}
		value(t) {
			return !!this._data[t];
		}
		setValue(t, e) {
			e ? (this._data[t] = !0) : delete this._data[t], this.onChange();
		}
		onChange() {
			self.$gameMap.requestRefresh();
		}
	}
	class Game_BattlerBase {
		constructor(...t) {
			this.initialize(...t);
		}
		initialize() {
			this.initMembers();
		}
		initMembers() {
			(this._hp = 1),
				(this._mp = 0),
				(this._tp = 0),
				(this._hidden = !1),
				this.clearParamPlus(),
				this.clearStates(),
				this.clearBuffs();
		}
		clearParamPlus() {
			this._paramPlus = [0, 0, 0, 0, 0, 0, 0, 0];
		}
		clearStates() {
			(this._states = []), (this._stateTurns = {});
		}
		eraseState(t) {
			const e = this._states.indexOf(t);
			e >= 0 && this._states.splice(e, 1), delete this._stateTurns[t];
		}
		isStateAffected(t) {
			return this._states.contains(t);
		}
		isDeathStateAffected() {
			return this.isStateAffected(this.deathStateId());
		}
		deathStateId() {
			return 1;
		}
		resetStateCounts(t) {
			const e = self.$dataStates[t],
				i = 1 + Math.max(e.maxTurns - e.minTurns, 0);
			this._stateTurns[t] = e.minTurns + Math.randomInt(i);
		}
		isStateExpired(t) {
			return 0 === this._stateTurns[t];
		}
		updateStateTurns() {
			this._states.forEach(function (t) {
				this._stateTurns[t] > 0 && this._stateTurns[t]--;
			}, this);
		}
		clearBuffs() {
			(this._buffs = [0, 0, 0, 0, 0, 0, 0, 0]),
				(this._buffTurns = [0, 0, 0, 0, 0, 0, 0, 0]);
		}
		eraseBuff(t) {
			(this._buffs[t] = 0), (this._buffTurns[t] = 0);
		}
		buffLength() {
			return this._buffs.length;
		}
		buff(t) {
			return this._buffs[t];
		}
		isBuffAffected(t) {
			return this._buffs[t] > 0;
		}
		isDebuffAffected(t) {
			return this._buffs[t] < 0;
		}
		isBuffOrDebuffAffected(t) {
			return 0 !== this._buffs[t];
		}
		isMaxBuffAffected(t) {
			return 2 === this._buffs[t];
		}
		isMaxDebuffAffected(t) {
			return -2 === this._buffs[t];
		}
		increaseBuff(t) {
			this.isMaxBuffAffected(t) || this._buffs[t]++;
		}
		decreaseBuff(t) {
			this.isMaxDebuffAffected(t) || this._buffs[t]--;
		}
		overwriteBuffTurns(t, e) {
			this._buffTurns[t] < e && (this._buffTurns[t] = e);
		}
		isBuffExpired(t) {
			return 0 === this._buffTurns[t];
		}
		updateBuffTurns() {
			for (let t = 0; t < this._buffTurns.length; t++)
				this._buffTurns[t] > 0 && this._buffTurns[t]--;
		}
		die() {
			(this._hp = 0), this.clearStates(), this.clearBuffs();
		}
		revive() {
			0 === this._hp && (this._hp = 1);
		}
		states() {
			return this._states.map((t) => self.$dataStates[t]);
		}
		stateIcons() {
			return this.states()
				.map(({ iconIndex: t }) => t)
				.filter((t) => t > 0);
		}
		buffIcons() {
			const t = [];
			for (let e = 0; e < this._buffs.length; e++)
				0 !== this._buffs[e] && t.push(this.buffIconIndex(this._buffs[e], e));
			return t;
		}
		buffIconIndex(t, e) {
			return t > 0
				? Game_BattlerBase.ICON_BUFF_START + 8 * (t - 1) + e
				: t < 0
				? Game_BattlerBase.ICON_DEBUFF_START + 8 * (-t - 1) + e
				: 0;
		}
		allIcons() {
			return this.stateIcons().concat(this.buffIcons());
		}
		traitObjects() {
			return this.states();
		}
		allTraits() {
			return this.traitObjects().reduce((t, { traits: e }) => t.concat(e), []);
		}
		traits(t) {
			return this.allTraits().filter((e) => e.code === t);
		}
		traitsWithId(t, e) {
			return this.allTraits().filter((i) => i.code === t && i.dataId === e);
		}
		traitsPi(t, e) {
			return this.traitsWithId(t, e).reduce((t, { value: e }) => t * e, 1);
		}
		traitsSum(t, e) {
			return this.traitsWithId(t, e).reduce((t, { value: e }) => t + e, 0);
		}
		traitsSumAll(t) {
			return this.traits(t).reduce((t, { value: e }) => t + e, 0);
		}
		traitsSet(t) {
			return this.traits(t).reduce((t, { dataId: e }) => t.concat(e), []);
		}
		paramBase(t) {
			return 0;
		}
		paramPlus(t) {
			return this._paramPlus[t];
		}
		paramMin(t) {
			return 1 === t ? 0 : 1;
		}
		paramMax(t) {
			return 0 === t ? 999999 : 1 === t ? 9999 : 999;
		}
		paramRate(t) {
			return this.traitsPi(Game_BattlerBase.TRAIT_PARAM, t);
		}
		paramBuffRate(t) {
			return 0.25 * this._buffs[t] + 1;
		}
		param(t) {
			let e = this.paramBase(t) + this.paramPlus(t);
			e *= this.paramRate(t) * this.paramBuffRate(t);
			const i = this.paramMax(t),
				r = this.paramMin(t);
			return Math.round(e.clamp(r, i));
		}
		xparam(t) {
			return this.traitsSum(Game_BattlerBase.TRAIT_XPARAM, t);
		}
		sparam(t) {
			return this.traitsPi(Game_BattlerBase.TRAIT_SPARAM, t);
		}
		elementRate(t) {
			return this.traitsPi(Game_BattlerBase.TRAIT_ELEMENT_RATE, t);
		}
		debuffRate(t) {
			return this.traitsPi(Game_BattlerBase.TRAIT_DEBUFF_RATE, t);
		}
		stateRate(t) {
			return this.traitsPi(Game_BattlerBase.TRAIT_STATE_RATE, t);
		}
		stateResistSet() {
			return this.traitsSet(Game_BattlerBase.TRAIT_STATE_RESIST);
		}
		isStateResist(t) {
			return this.stateResistSet().contains(t);
		}
		attackElements() {
			return this.traitsSet(Game_BattlerBase.TRAIT_ATTACK_ELEMENT);
		}
		attackStates() {
			return this.traitsSet(Game_BattlerBase.TRAIT_ATTACK_STATE);
		}
		attackStatesRate(t) {
			return this.traitsSum(Game_BattlerBase.TRAIT_ATTACK_STATE, t);
		}
		attackSpeed() {
			return this.traitsSumAll(Game_BattlerBase.TRAIT_ATTACK_SPEED);
		}
		attackTimesAdd() {
			return Math.max(
				this.traitsSumAll(Game_BattlerBase.TRAIT_ATTACK_TIMES),
				0
			);
		}
		addedSkillTypes() {
			return this.traitsSet(Game_BattlerBase.TRAIT_STYPE_ADD);
		}
		isSkillTypeSealed(t) {
			return this.traitsSet(Game_BattlerBase.TRAIT_STYPE_SEAL).contains(t);
		}
		addedSkills() {
			return this.traitsSet(Game_BattlerBase.TRAIT_SKILL_ADD);
		}
		isSkillSealed(t) {
			return this.traitsSet(Game_BattlerBase.TRAIT_SKILL_SEAL).contains(t);
		}
		isEquipWtypeOk(t) {
			return this.traitsSet(Game_BattlerBase.TRAIT_EQUIP_WTYPE).contains(t);
		}
		isEquipAtypeOk(t) {
			return this.traitsSet(Game_BattlerBase.TRAIT_EQUIP_ATYPE).contains(t);
		}
		isEquipTypeLocked(t) {
			return this.traitsSet(Game_BattlerBase.TRAIT_EQUIP_LOCK).contains(t);
		}
		isEquipTypeSealed(t) {
			return this.traitsSet(Game_BattlerBase.TRAIT_EQUIP_SEAL).contains(t);
		}
		slotType() {
			const t = this.traitsSet(Game_BattlerBase.TRAIT_SLOT_TYPE);
			return t.length > 0 ? Math.max.apply(null, t) : 0;
		}
		isDualWield() {
			return 1 === this.slotType();
		}
		actionPlusSet() {
			return this.traits(Game_BattlerBase.TRAIT_ACTION_PLUS).map(
				({ value: t }) => t
			);
		}
		specialFlag(t) {
			return this.traits(Game_BattlerBase.TRAIT_SPECIAL_FLAG).some(
				({ dataId: e }) => e === t
			);
		}
		collapseType() {
			const t = this.traitsSet(Game_BattlerBase.TRAIT_COLLAPSE_TYPE);
			return t.length > 0 ? Math.max.apply(null, t) : 0;
		}
		partyAbility(t) {
			return this.traits(Game_BattlerBase.TRAIT_PARTY_ABILITY).some(
				({ dataId: e }) => e === t
			);
		}
		isAutoBattle() {
			return this.specialFlag(Game_BattlerBase.FLAG_ID_AUTO_BATTLE);
		}
		isGuard() {
			return this.specialFlag(Game_BattlerBase.FLAG_ID_GUARD) && this.canMove();
		}
		isSubstitute() {
			return (
				this.specialFlag(Game_BattlerBase.FLAG_ID_SUBSTITUTE) && this.canMove()
			);
		}
		isPreserveTp() {
			return this.specialFlag(Game_BattlerBase.FLAG_ID_PRESERVE_TP);
		}
		addParam(t, e) {
			(this._paramPlus[t] += e), this.refresh();
		}
		setHp(t) {
			(this._hp = t), this.refresh();
		}
		setMp(t) {
			(this._mp = t), this.refresh();
		}
		setTp(t) {
			(this._tp = t), this.refresh();
		}
		maxTp() {
			return 100;
		}
		refresh() {
			this.stateResistSet().forEach(function (t) {
				this.eraseState(t);
			}, this),
				(this._hp = this._hp.clamp(0, this.mhp)),
				(this._mp = this._mp.clamp(0, this.mmp)),
				(this._tp = this._tp.clamp(0, this.maxTp()));
		}
		recoverAll() {
			this.clearStates(), (this._hp = this.mhp), (this._mp = this.mmp);
		}
		hpRate() {
			return this.hp / this.mhp;
		}
		mpRate() {
			return this.mmp > 0 ? this.mp / this.mmp : 0;
		}
		tpRate() {
			return this.tp / this.maxTp();
		}
		hide() {
			this._hidden = !0;
		}
		appear() {
			this._hidden = !1;
		}
		isHidden() {
			return this._hidden;
		}
		isAppeared() {
			return !this.isHidden();
		}
		isDead() {
			return this.isAppeared() && this.isDeathStateAffected();
		}
		isAlive() {
			return this.isAppeared() && !this.isDeathStateAffected();
		}
		isDying() {
			return this.isAlive() && this._hp < this.mhp / 4;
		}
		isRestricted() {
			return this.isAppeared() && this.restriction() > 0;
		}
		canInput() {
			return this.isAppeared() && !this.isRestricted() && !this.isAutoBattle();
		}
		canMove() {
			return this.isAppeared() && this.restriction() < 4;
		}
		isConfused() {
			return (
				this.isAppeared() && this.restriction() >= 1 && this.restriction() <= 3
			);
		}
		confusionLevel() {
			return this.isConfused() ? this.restriction() : 0;
		}
		isActor() {
			return !1;
		}
		isEnemy() {
			return !1;
		}
		sortStates() {
			this._states.sort((t, e) => {
				const i = self.$dataStates[t].priority,
					r = self.$dataStates[e].priority;
				return i !== r ? r - i : t - e;
			});
		}
		restriction() {
			return Math.max.apply(
				null,
				this.states()
					.map(({ restriction: t }) => t)
					.concat(0)
			);
		}
		addNewState(t, e) {
			t === this.deathStateId() && this.die();
			const i = this.isRestricted();
			this._states.push(t),
				this.sortStates(),
				!i && this.isRestricted() && this.onRestrict();
		}
		onRestrict() {}
		mostImportantStateText() {
			const t = this.states();
			for (let e = 0; e < t.length; e++)
				if (t[e].message3) return t[e].message3;
			return '';
		}
		stateMotionIndex() {
			const t = this.states();
			return t.length > 0 ? t[0].motion : 0;
		}
		stateOverlayIndex() {
			const t = this.states();
			return t.length > 0 ? t[0].overlay : 0;
		}
		isSkillWtypeOk(t) {
			return !0;
		}
		skillMpCost({ mpCost: t }) {
			return Math.floor(t * this.mcr);
		}
		skillTpCost({ tpCost: t }) {
			return t;
		}
		canPaySkillCost(t) {
			return this._tp >= this.skillTpCost(t) && this._mp >= this.skillMpCost(t);
		}
		paySkillCost(t) {
			(this._mp -= this.skillMpCost(t)), (this._tp -= this.skillTpCost(t));
		}
		isOccasionOk({ occasion: t }) {
			return self.$gameParty.inBattle()
				? 0 === t || 1 === t
				: 0 === t || 2 === t;
		}
		meetsUsableItemConditions(t) {
			return this.canMove() && this.isOccasionOk(t);
		}
		meetsSkillConditions(t) {
			return (
				this.meetsUsableItemConditions(t) &&
				this.isSkillWtypeOk(t) &&
				this.canPaySkillCost(t) &&
				!this.isSkillSealed(t.id) &&
				!this.isSkillTypeSealed(t.stypeId)
			);
		}
		meetsItemConditions(t) {
			return this.meetsUsableItemConditions(t) && self.$gameParty.hasItem(t);
		}
		canUse(t) {
			return (
				!!t &&
				(DataManager$1.isSkill(t)
					? this.meetsSkillConditions(t)
					: !!DataManager$1.isItem(t) && this.meetsItemConditions(t))
			);
		}
		canEquip(t) {
			return (
				!!t &&
				(DataManager$1.isWeapon(t)
					? this.canEquipWeapon(t)
					: !!DataManager$1.isArmor(t) && this.canEquipArmor(t))
			);
		}
		canEquipWeapon({ wtypeId: t, etypeId: e }) {
			return this.isEquipWtypeOk(t) && !this.isEquipTypeSealed(e);
		}
		canEquipArmor({ atypeId: t, etypeId: e }) {
			return this.isEquipAtypeOk(t) && !this.isEquipTypeSealed(e);
		}
		attackSkillId() {
			return 1;
		}
		guardSkillId() {
			return 2;
		}
		canAttack() {
			return this.canUse(self.$dataSkills[this.attackSkillId()]);
		}
		canGuard() {
			return this.canUse(self.$dataSkills[this.guardSkillId()]);
		}
	}
	(Game_BattlerBase.TRAIT_ELEMENT_RATE = 11),
		(Game_BattlerBase.TRAIT_DEBUFF_RATE = 12),
		(Game_BattlerBase.TRAIT_STATE_RATE = 13),
		(Game_BattlerBase.TRAIT_STATE_RESIST = 14),
		(Game_BattlerBase.TRAIT_PARAM = 21),
		(Game_BattlerBase.TRAIT_XPARAM = 22),
		(Game_BattlerBase.TRAIT_SPARAM = 23),
		(Game_BattlerBase.TRAIT_ATTACK_ELEMENT = 31),
		(Game_BattlerBase.TRAIT_ATTACK_STATE = 32),
		(Game_BattlerBase.TRAIT_ATTACK_SPEED = 33),
		(Game_BattlerBase.TRAIT_ATTACK_TIMES = 34),
		(Game_BattlerBase.TRAIT_STYPE_ADD = 41),
		(Game_BattlerBase.TRAIT_STYPE_SEAL = 42),
		(Game_BattlerBase.TRAIT_SKILL_ADD = 43),
		(Game_BattlerBase.TRAIT_SKILL_SEAL = 44),
		(Game_BattlerBase.TRAIT_EQUIP_WTYPE = 51),
		(Game_BattlerBase.TRAIT_EQUIP_ATYPE = 52),
		(Game_BattlerBase.TRAIT_EQUIP_LOCK = 53),
		(Game_BattlerBase.TRAIT_EQUIP_SEAL = 54),
		(Game_BattlerBase.TRAIT_SLOT_TYPE = 55),
		(Game_BattlerBase.TRAIT_ACTION_PLUS = 61),
		(Game_BattlerBase.TRAIT_SPECIAL_FLAG = 62),
		(Game_BattlerBase.TRAIT_COLLAPSE_TYPE = 63),
		(Game_BattlerBase.TRAIT_PARTY_ABILITY = 64),
		(Game_BattlerBase.FLAG_ID_AUTO_BATTLE = 0),
		(Game_BattlerBase.FLAG_ID_GUARD = 1),
		(Game_BattlerBase.FLAG_ID_SUBSTITUTE = 2),
		(Game_BattlerBase.FLAG_ID_PRESERVE_TP = 3),
		(Game_BattlerBase.ICON_BUFF_START = 32),
		(Game_BattlerBase.ICON_DEBUFF_START = 48),
		Object.defineProperties(Game_BattlerBase.prototype, {
			hp: {
				get() {
					return this._hp;
				},
				configurable: !0,
			},
			mp: {
				get() {
					return this._mp;
				},
				configurable: !0,
			},
			tp: {
				get() {
					return this._tp;
				},
				configurable: !0,
			},
			mhp: {
				get() {
					return this.param(0);
				},
				configurable: !0,
			},
			mmp: {
				get() {
					return this.param(1);
				},
				configurable: !0,
			},
			atk: {
				get() {
					return this.param(2);
				},
				configurable: !0,
			},
			def: {
				get() {
					return this.param(3);
				},
				configurable: !0,
			},
			mat: {
				get() {
					return this.param(4);
				},
				configurable: !0,
			},
			mdf: {
				get() {
					return this.param(5);
				},
				configurable: !0,
			},
			agi: {
				get() {
					return this.param(6);
				},
				configurable: !0,
			},
			luk: {
				get() {
					return this.param(7);
				},
				configurable: !0,
			},
			hit: {
				get() {
					return this.xparam(0);
				},
				configurable: !0,
			},
			eva: {
				get() {
					return this.xparam(1);
				},
				configurable: !0,
			},
			cri: {
				get() {
					return this.xparam(2);
				},
				configurable: !0,
			},
			cev: {
				get() {
					return this.xparam(3);
				},
				configurable: !0,
			},
			mev: {
				get() {
					return this.xparam(4);
				},
				configurable: !0,
			},
			mrf: {
				get() {
					return this.xparam(5);
				},
				configurable: !0,
			},
			cnt: {
				get() {
					return this.xparam(6);
				},
				configurable: !0,
			},
			hrg: {
				get() {
					return this.xparam(7);
				},
				configurable: !0,
			},
			mrg: {
				get() {
					return this.xparam(8);
				},
				configurable: !0,
			},
			trg: {
				get() {
					return this.xparam(9);
				},
				configurable: !0,
			},
			tgr: {
				get() {
					return this.sparam(0);
				},
				configurable: !0,
			},
			grd: {
				get() {
					return this.sparam(1);
				},
				configurable: !0,
			},
			rec: {
				get() {
					return this.sparam(2);
				},
				configurable: !0,
			},
			pha: {
				get() {
					return this.sparam(3);
				},
				configurable: !0,
			},
			mcr: {
				get() {
					return this.sparam(4);
				},
				configurable: !0,
			},
			tcr: {
				get() {
					return this.sparam(5);
				},
				configurable: !0,
			},
			pdr: {
				get() {
					return this.sparam(6);
				},
				configurable: !0,
			},
			mdr: {
				get() {
					return this.sparam(7);
				},
				configurable: !0,
			},
			fdr: {
				get() {
					return this.sparam(8);
				},
				configurable: !0,
			},
			exr: {
				get() {
					return this.sparam(9);
				},
				configurable: !0,
			},
		});
	class Game_ActionResult {
		constructor(...t) {
			this.initialize(...t);
		}
		initialize() {
			this.clear();
		}
		clear() {
			(this.used = !1),
				(this.missed = !1),
				(this.evaded = !1),
				(this.physical = !1),
				(this.drain = !1),
				(this.critical = !1),
				(this.success = !1),
				(this.hpAffected = !1),
				(this.hpDamage = 0),
				(this.mpDamage = 0),
				(this.tpDamage = 0),
				(this.addedStates = []),
				(this.removedStates = []),
				(this.addedBuffs = []),
				(this.addedDebuffs = []),
				(this.removedBuffs = []);
		}
		addedStateObjects() {
			return this.addedStates.map((t) => self.$dataStates[t]);
		}
		removedStateObjects() {
			return this.removedStates.map((t) => self.$dataStates[t]);
		}
		isStatusAffected() {
			return (
				this.addedStates.length > 0 ||
				this.removedStates.length > 0 ||
				this.addedBuffs.length > 0 ||
				this.addedDebuffs.length > 0 ||
				this.removedBuffs.length > 0
			);
		}
		isHit() {
			return this.used && !this.missed && !this.evaded;
		}
		isStateAdded(t) {
			return this.addedStates.contains(t);
		}
		pushAddedState(t) {
			this.isStateAdded(t) || this.addedStates.push(t);
		}
		isStateRemoved(t) {
			return this.removedStates.contains(t);
		}
		pushRemovedState(t) {
			this.isStateRemoved(t) || this.removedStates.push(t);
		}
		isBuffAdded(t) {
			return this.addedBuffs.contains(t);
		}
		pushAddedBuff(t) {
			this.isBuffAdded(t) || this.addedBuffs.push(t);
		}
		isDebuffAdded(t) {
			return this.addedDebuffs.contains(t);
		}
		pushAddedDebuff(t) {
			this.isDebuffAdded(t) || this.addedDebuffs.push(t);
		}
		isBuffRemoved(t) {
			return this.removedBuffs.contains(t);
		}
		pushRemovedBuff(t) {
			this.isBuffRemoved(t) || this.removedBuffs.push(t);
		}
	}
	class Game_Battler extends Game_BattlerBase {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize();
		}
		initMembers() {
			super.initMembers(),
				(this._actions = []),
				(this._speed = 0),
				(this._result = new Game_ActionResult()),
				(this._actionState = ''),
				(this._lastTargetIndex = 0),
				(this._animations = []),
				(this._damagePopup = !1),
				(this._effectType = null),
				(this._motionType = null),
				(this._weaponImageId = 0),
				(this._motionRefresh = !1),
				(this._selected = !1);
		}
		clearAnimations() {
			this._animations = [];
		}
		clearDamagePopup() {
			this._damagePopup = !1;
		}
		clearWeaponAnimation() {
			this._weaponImageId = 0;
		}
		clearEffect() {
			this._effectType = null;
		}
		clearMotion() {
			(this._motionType = null), (this._motionRefresh = !1);
		}
		requestEffect(t) {
			this._effectType = t;
		}
		requestMotion(t) {
			this._motionType = t;
		}
		requestMotionRefresh() {
			this._motionRefresh = !0;
		}
		select() {
			this._selected = !0;
		}
		deselect() {
			this._selected = !1;
		}
		isAnimationRequested() {
			return this._animations.length > 0;
		}
		isDamagePopupRequested() {
			return this._damagePopup;
		}
		isEffectRequested() {
			return !!this._effectType;
		}
		isMotionRequested() {
			return !!this._motionType;
		}
		isWeaponAnimationRequested() {
			return this._weaponImageId > 0;
		}
		isMotionRefreshRequested() {
			return this._motionRefresh;
		}
		isSelected() {
			return this._selected;
		}
		effectType() {
			return this._effectType;
		}
		motionType() {
			return this._motionType;
		}
		weaponImageId() {
			return this._weaponImageId;
		}
		shiftAnimation() {
			return this._animations.shift();
		}
		startAnimation(t, e, i) {
			const r = { animationId: t, mirror: e, delay: i };
			this._animations.push(r);
		}
		startDamagePopup() {
			this._damagePopup = !0;
		}
		startWeaponAnimation(t) {
			this._weaponImageId = t;
		}
		action(t) {
			return this._actions[t];
		}
		setAction(t, e) {
			this._actions[t] = e;
		}
		numActions() {
			return this._actions.length;
		}
		clearActions() {
			this._actions = [];
		}
		result() {
			return this._result;
		}
		clearResult() {
			this._result.clear();
		}
		refresh() {
			super.refresh(),
				0 === this.hp
					? this.addState(this.deathStateId())
					: this.removeState(this.deathStateId());
		}
		onApplyDamage(t, e, i) {}
		onReceiveDamage(t, e, i) {}
		onHitAction(t, e) {}
		onEvadeAction(t, e) {}
		onApplyCritical(t, e, i) {}
		onReceiveCritical(t, e, i) {}
		addState(t, e) {
			this.isStateAddable(t)
				? (this.isStateAffected(t) || (this.addNewState(t, e), this.refresh()),
				  e && e.onApplyStateSuccess(t, this),
				  this.resetStateCounts(t),
				  this._result.pushAddedState(t))
				: e && e.onApplyStateFailure(t, this);
		}
		onApplyStateSuccess(t, e) {}
		onApplyStateFailure(t, e) {}
		isStateAddable(t) {
			return (
				this.isAlive() &&
				self.$dataStates[t] &&
				!this.isStateResist(t) &&
				!this._result.isStateRemoved(t) &&
				!this.isStateRestrict(t)
			);
		}
		isStateRestrict(t) {
			return self.$dataStates[t].removeByRestriction && this.isRestricted();
		}
		onRestrict() {
			super.onRestrict(),
				this.clearActions(),
				this.states().forEach(function ({ removeByRestriction: t, id: e }) {
					t && this.removeState(e);
				}, this);
		}
		removeState(t) {
			this.isStateAffected(t) &&
				(t === this.deathStateId() && this.revive(),
				this.eraseState(t),
				this.refresh(),
				this._result.pushRemovedState(t));
		}
		escape() {
			self.$gameParty.inBattle() && this.hide(),
				this.clearActions(),
				this.clearStates(),
				SoundManager.playEscape();
		}
		addBuff(t, e) {
			this.isAlive() &&
				(this.increaseBuff(t),
				this.isBuffAffected(t) && this.overwriteBuffTurns(t, e),
				this._result.pushAddedBuff(t),
				this.refresh());
		}
		addDebuff(t, e) {
			this.isAlive() &&
				(this.decreaseBuff(t),
				this.isDebuffAffected(t) && this.overwriteBuffTurns(t, e),
				this._result.pushAddedDebuff(t),
				this.refresh());
		}
		removeBuff(t) {
			this.isAlive() &&
				this.isBuffOrDebuffAffected(t) &&
				(this.eraseBuff(t), this._result.pushRemovedBuff(t), this.refresh());
		}
		removeBattleStates() {
			this.states().forEach(function ({ removeAtBattleEnd: t, id: e }) {
				t && this.removeState(e);
			}, this);
		}
		removeAllBuffs() {
			for (let t = 0; t < this.buffLength(); t++) this.removeBuff(t);
		}
		removeStatesAuto(t) {
			this.states().forEach(function ({ id: e, autoRemovalTiming: i }) {
				this.isStateExpired(e) && i === t && this.removeState(e);
			}, this);
		}
		removeBuffsAuto() {
			for (let t = 0; t < this.buffLength(); t++)
				this.isBuffExpired(t) && this.removeBuff(t);
		}
		removeStatesByDamage() {
			this.states().forEach(function ({
				removeByDamage: t,
				chanceByDamage: e,
				id: i,
			}) {
				t && Math.randomInt(100) < e && this.removeState(i);
			},
			this);
		}
		makeActionTimes() {
			return this.actionPlusSet().reduce(
				(t, e) => (Math.random() < e ? t + 1 : t),
				1
			);
		}
		makeActions() {
			if ((this.clearActions(), this.canMove())) {
				const t = this.makeActionTimes();
				this._actions = [];
				for (let e = 0; e < t; e++) this._actions.push(new Game_Action(this));
			}
		}
		speed() {
			return this._speed;
		}
		makeSpeed() {
			this._speed =
				Math.min.apply(
					null,
					this._actions.map((t) => t.speed())
				) || 0;
		}
		currentAction() {
			return this._actions[0];
		}
		removeCurrentAction() {
			this._actions.shift();
		}
		setLastTarget(t) {
			this._lastTargetIndex = t ? t.index() : 0;
		}
		forceAction(t, e) {
			this.clearActions();
			const i = new Game_Action(this, !0);
			i.setSkill(t),
				-2 === e
					? i.setTarget(this._lastTargetIndex)
					: -1 === e
					? i.decideRandomTarget()
					: i.setTarget(e),
				this._actions.push(i);
		}
		useItem(t) {
			DataManager$1.isSkill(t)
				? this.paySkillCost(t)
				: DataManager$1.isItem(t) && this.consumeItem(t);
		}
		consumeItem(t) {
			self.$gameParty.consumeItem(t);
		}
		gainHp(t) {
			(this._result.hpDamage = -t),
				(this._result.hpAffected = !0),
				this.setHp(this.hp + t);
		}
		gainMp(t) {
			(this._result.mpDamage = -t), this.setMp(this.mp + t);
		}
		gainTp(t) {
			(this._result.tpDamage = -t), this.setTp(this.tp + t);
		}
		gainSilentTp(t) {
			this.setTp(this.tp + t);
		}
		initTp() {
			this.setTp(Math.randomInt(25));
		}
		clearTp() {
			this.setTp(0);
		}
		chargeTpByDamage(t) {
			const e = Math.floor(50 * t * this.tcr);
			this.gainSilentTp(e);
		}
		regenerateHp() {
			let t = Math.floor(this.mhp * this.hrg);
			(t = Math.max(t, -this.maxSlipDamage())), 0 !== t && this.gainHp(t);
		}
		maxSlipDamage() {
			return self.$dataSystem.optSlipDeath ? this.hp : Math.max(this.hp - 1, 0);
		}
		regenerateMp() {
			const t = Math.floor(this.mmp * this.mrg);
			0 !== t && this.gainMp(t);
		}
		regenerateTp() {
			const t = Math.floor(100 * this.trg);
			this.gainSilentTp(t);
		}
		regenerateAll() {
			this.isAlive() &&
				(this.regenerateHp(), this.regenerateMp(), this.regenerateTp());
		}
		onBattleStart() {
			this.setActionState('undecided'),
				this.clearMotion(),
				this.isPreserveTp() || this.initTp();
		}
		onAllActionsEnd() {
			this.clearResult(), this.removeStatesAuto(1), this.removeBuffsAuto();
		}
		onTurnEnd() {
			this.clearResult(),
				this.regenerateAll(),
				BattleManager.isForcedTurn() ||
					(this.updateStateTurns(), this.updateBuffTurns()),
				this.removeStatesAuto(2);
		}
		onBattleEnd() {
			this.clearResult(),
				this.removeBattleStates(),
				this.removeAllBuffs(),
				this.clearActions(),
				this.isPreserveTp() || this.clearTp(),
				this.appear();
		}
		onDamage(t) {
			this.removeStatesByDamage(), this.chargeTpByDamage(t / this.mhp);
		}
		setActionState(t) {
			(this._actionState = t), this.requestMotionRefresh();
		}
		isUndecided() {
			return 'undecided' === this._actionState;
		}
		isInputting() {
			return 'inputting' === this._actionState;
		}
		isWaiting() {
			return 'waiting' === this._actionState;
		}
		isActing() {
			return 'acting' === this._actionState;
		}
		isChanting() {
			return !!this.isWaiting() && this._actions.some((t) => t.isMagicSkill());
		}
		isGuardWaiting() {
			return !!this.isWaiting() && this._actions.some((t) => t.isGuard());
		}
		performActionStart(t) {
			t.isGuard() || this.setActionState('acting');
		}
		performAction(t) {}
		performActionEnd() {
			this.setActionState('done');
		}
		performDamage() {}
		performMiss() {
			SoundManager.playMiss();
		}
		performRecovery() {
			SoundManager.playRecovery();
		}
		performEvasion() {
			SoundManager.playEvasion();
		}
		performMagicEvasion() {
			SoundManager.playMagicEvasion();
		}
		performCounter() {
			SoundManager.playEvasion();
		}
		performReflection() {
			SoundManager.playReflection();
		}
		performSubstitute(t) {}
		performCollapse() {}
	}
	class Game_Actor extends Game_Battler {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		get level() {
			return this._level;
		}
		initialize(t) {
			super.initialize(), this.setup(t);
		}
		initMembers() {
			super.initMembers(),
				(this._actorId = 0),
				(this._name = ''),
				(this._nickname = ''),
				(this._classId = 0),
				(this._level = 0),
				(this._characterName = ''),
				(this._characterIndex = 0),
				(this._faceName = ''),
				(this._faceIndex = 0),
				(this._battlerName = ''),
				(this._exp = {}),
				(this._skills = []),
				(this._equips = []),
				(this._actionInputIndex = 0),
				(this._lastMenuSkill = new Game_Item()),
				(this._lastBattleSkill = new Game_Item()),
				(this._lastCommandSymbol = '');
		}
		setup(t) {
			const e = self.$dataActors[t];
			(this._actorId = t),
				(this._name = e.name),
				(this._nickname = e.nickname),
				(this._profile = e.profile),
				(this._classId = e.classId),
				(this._level = e.initialLevel),
				this.initImages(),
				this.initExp(),
				this.initSkills(),
				this.initEquips(e.equips),
				this.clearParamPlus(),
				this.recoverAll();
		}
		actorId() {
			return this._actorId;
		}
		actor() {
			return self.$dataActors[this._actorId];
		}
		name() {
			return this._name;
		}
		setName(t) {
			this._name = t;
		}
		nickname() {
			return this._nickname;
		}
		setNickname(t) {
			this._nickname = t;
		}
		profile() {
			return this._profile;
		}
		setProfile(t) {
			this._profile = t;
		}
		characterName() {
			return this._characterName;
		}
		characterIndex() {
			return this._characterIndex;
		}
		faceName() {
			return this._faceName;
		}
		faceIndex() {
			return this._faceIndex;
		}
		battlerName() {
			return this._battlerName;
		}
		clearStates() {
			super.clearStates(), (this._stateSteps = {});
		}
		eraseState(t) {
			super.eraseState(t), delete this._stateSteps[t];
		}
		resetStateCounts(t) {
			super.resetStateCounts(t),
				(this._stateSteps[t] = self.$dataStates[t].stepsToRemove);
		}
		initImages() {
			const t = this.actor();
			(this._characterName = t.characterName),
				(this._characterIndex = t.characterIndex),
				(this._faceName = t.faceName),
				(this._faceIndex = t.faceIndex),
				(this._battlerName = t.battlerName);
		}
		expForLevel(t) {
			const e = this.currentClass(),
				i = e.expParams[0],
				r = e.expParams[1],
				s = e.expParams[2],
				n = e.expParams[3];
			return Math.round(
				(i * Math.pow(t - 1, 0.9 + s / 250) * t * (t + 1)) /
					(6 + Math.pow(t, 2) / 50 / n) +
					(t - 1) * r
			);
		}
		initExp() {
			this._exp[this._classId] = this.currentLevelExp();
		}
		currentExp() {
			return this._exp[this._classId];
		}
		currentLevelExp() {
			return this.expForLevel(this._level);
		}
		nextLevelExp() {
			return this.expForLevel(this._level + 1);
		}
		nextRequiredExp() {
			return this.nextLevelExp() - this.currentExp();
		}
		maxLevel() {
			return this.actor().maxLevel;
		}
		isMaxLevel() {
			return this._level >= this.maxLevel();
		}
		initSkills() {
			(this._skills = []),
				this.currentClass().learnings.forEach(function ({
					level: t,
					skillId: e,
				}) {
					t <= this._level && this.learnSkill(e);
				},
				this);
		}
		initEquips(t) {
			const e = this.equipSlots(),
				i = e.length;
			this._equips = [];
			for (let t = 0; t < i; t++) this._equips[t] = new Game_Item();
			for (let r = 0; r < t.length; r++)
				r < i && this._equips[r].setEquip(1 === e[r], t[r]);
			this.releaseUnequippableItems(!0), this.refresh();
		}
		equipSlots() {
			const t = [];
			for (let e = 1; e < self.$dataSystem.equipTypes.length; e++) t.push(e);
			return t.length >= 2 && this.isDualWield() && (t[1] = 1), t;
		}
		equips() {
			return this._equips.map((t) => t.object());
		}
		weapons() {
			return this.equips().filter((t) => t && DataManager$1.isWeapon(t));
		}
		armors() {
			return this.equips().filter((t) => t && DataManager$1.isArmor(t));
		}
		hasWeapon(t) {
			return this.weapons().contains(t);
		}
		hasArmor(t) {
			return this.armors().contains(t);
		}
		isEquipChangeOk(t) {
			return (
				!this.isEquipTypeLocked(this.equipSlots()[t]) &&
				!this.isEquipTypeSealed(this.equipSlots()[t])
			);
		}
		changeEquip(t, e) {
			!this.tradeItemWithParty(e, this.equips()[t]) ||
				(e && this.equipSlots()[t] !== e.etypeId) ||
				(this._equips[t].setObject(e), this.refresh());
		}
		forceChangeEquip(t, e) {
			this._equips[t].setObject(e),
				this.releaseUnequippableItems(!0),
				this.refresh();
		}
		tradeItemWithParty(t, e) {
			return !(
				(t && !self.$gameParty.hasItem(t)) ||
				(self.$gameParty.gainItem(e, 1), self.$gameParty.loseItem(t, 1), 0)
			);
		}
		changeEquipById(t, e) {
			const i = t - 1;
			1 === this.equipSlots()[i]
				? this.changeEquip(i, self.$dataWeapons[e])
				: this.changeEquip(i, self.$dataArmors[e]);
		}
		isEquipped(t) {
			return this.equips().contains(t);
		}
		discardEquip(t) {
			const e = this.equips().indexOf(t);
			e >= 0 && this._equips[e].setObject(null);
		}
		releaseUnequippableItems(t) {
			for (;;) {
				const e = this.equipSlots(),
					i = this.equips();
				let r = !1;
				if (
					(i.forEach((i, s) => {
						!i ||
							(this.canEquip(i) && i.etypeId === e[s]) ||
							(t || this.tradeItemWithParty(null, i),
							this._equips[s].setObject(null),
							(r = !0));
					}),
					!r)
				)
					break;
			}
		}
		clearEquipments() {
			const t = this.equipSlots().length;
			for (let e = 0; e < t; e++)
				this.isEquipChangeOk(e) && this.changeEquip(e, null);
		}
		optimizeEquipments() {
			const t = this.equipSlots().length;
			this.clearEquipments();
			for (let e = 0; e < t; e++)
				this.isEquipChangeOk(e) && this.changeEquip(e, this.bestEquipItem(e));
		}
		bestEquipItem(t) {
			const e = this.equipSlots()[t],
				i = self.$gameParty.equipItems().filter(function (t) {
					return t.etypeId === e && this.canEquip(t);
				}, this);
			let r = null,
				s = -1e3;
			for (let t = 0; t < i.length; t++) {
				const e = this.calcEquipItemPerformance(i[t]);
				e > s && ((s = e), (r = i[t]));
			}
			return r;
		}
		calcEquipItemPerformance({ params: t }) {
			return t.reduce((t, e) => t + e);
		}
		isSkillWtypeOk({ requiredWtypeId1: t, requiredWtypeId2: e }) {
			const i = t,
				r = e;
			return !!(
				(0 === i && 0 === r) ||
				(i > 0 && this.isWtypeEquipped(i)) ||
				(r > 0 && this.isWtypeEquipped(r))
			);
		}
		isWtypeEquipped(t) {
			return this.weapons().some((e) => e.wtypeId === t);
		}
		refresh() {
			this.releaseUnequippableItems(!1), super.refresh();
		}
		isActor() {
			return !0;
		}
		friendsUnit() {
			return self.$gameParty;
		}
		opponentsUnit() {
			return self.$gameTroop;
		}
		index() {
			return self.$gameParty.members().indexOf(this);
		}
		isBattleMember() {
			return self.$gameParty.battleMembers().contains(this);
		}
		isFormationChangeOk() {
			return !0;
		}
		currentClass() {
			return self.$dataClasses[this._classId];
		}
		isClass(t) {
			return t && this._classId === t.id;
		}
		skills() {
			const t = [];
			return (
				this._skills.concat(this.addedSkills()).forEach((e) => {
					t.contains(self.$dataSkills[e]) || t.push(self.$dataSkills[e]);
				}),
				t
			);
		}
		usableSkills() {
			return this.skills().filter(function (t) {
				return this.canUse(t);
			}, this);
		}
		traitObjects() {
			let t = Game_Battler.prototype.traitObjects.call(this);
			t = t.concat([this.actor(), this.currentClass()]);
			const e = this.equips();
			for (const i of e) i && t.push(i);
			return t;
		}
		attackElements() {
			const t = Game_Battler.prototype.attackElements.call(this);
			return (
				this.hasNoWeapons() &&
					!t.contains(this.bareHandsElementId()) &&
					t.push(this.bareHandsElementId()),
				t
			);
		}
		hasNoWeapons() {
			return 0 === this.weapons().length;
		}
		bareHandsElementId() {
			return 1;
		}
		paramMax(t) {
			return 0 === t ? 9999 : Game_Battler.prototype.paramMax.call(this, t);
		}
		paramBase(t) {
			return this.currentClass().params[t][this._level];
		}
		paramPlus(t) {
			let e = Game_Battler.prototype.paramPlus.call(this, t);
			const i = this.equips();
			for (const r of i) r && (e += r.params[t]);
			return e;
		}
		attackAnimationId1() {
			if (this.hasNoWeapons()) return this.bareHandsAnimationId();
			{
				const t = this.weapons();
				return t[0] ? t[0].animationId : 0;
			}
		}
		attackAnimationId2() {
			const t = this.weapons();
			return t[1] ? t[1].animationId : 0;
		}
		bareHandsAnimationId() {
			return 1;
		}
		changeExp(t, e) {
			this._exp[this._classId] = Math.max(t, 0);
			const i = this._level,
				r = this.skills();
			for (; !this.isMaxLevel() && this.currentExp() >= this.nextLevelExp(); )
				this.levelUp();
			for (; this.currentExp() < this.currentLevelExp(); ) this.levelDown();
			e && this._level > i && this.displayLevelUp(this.findNewSkills(r)),
				this.refresh();
		}
		levelUp() {
			this._level++,
				this.currentClass().learnings.forEach(function ({
					level: t,
					skillId: e,
				}) {
					t === this._level && this.learnSkill(e);
				},
				this);
		}
		levelDown() {
			this._level--;
		}
		findNewSkills(t) {
			const e = this.skills();
			for (let i = 0; i < t.length; i++) {
				const r = e.indexOf(t[i]);
				r >= 0 && e.splice(r, 1);
			}
			return e;
		}
		displayLevelUp(t) {
			const e = TextManager.levelUp.format(
				this._name,
				TextManager.level,
				this._level
			);
			self.$gameMessage.newPage(),
				self.$gameMessage.add(e),
				t.forEach(({ name: t }) => {
					self.$gameMessage.add(TextManager.obtainSkill.format(t));
				});
		}
		gainExp(t) {
			const e = this.currentExp() + Math.round(t * this.finalExpRate());
			this.changeExp(e, this.shouldDisplayLevelUp());
		}
		finalExpRate() {
			return (
				this.exr * (this.isBattleMember() ? 1 : this.benchMembersExpRate())
			);
		}
		benchMembersExpRate() {
			return self.$dataSystem.optExtraExp ? 1 : 0;
		}
		shouldDisplayLevelUp() {
			return !0;
		}
		changeLevel(t, e) {
			(t = t.clamp(1, this.maxLevel())), this.changeExp(this.expForLevel(t), e);
		}
		learnSkill(t) {
			this.isLearnedSkill(t) ||
				(this._skills.push(t), this._skills.sort((t, e) => t - e));
		}
		forgetSkill(t) {
			const e = this._skills.indexOf(t);
			e >= 0 && this._skills.splice(e, 1);
		}
		isLearnedSkill(t) {
			return this._skills.contains(t);
		}
		hasSkill(t) {
			return this.skills().contains(self.$dataSkills[t]);
		}
		changeClass(t, e) {
			e && (this._exp[t] = this.currentExp()),
				(this._classId = t),
				this.changeExp(this._exp[this._classId] || 0, !1),
				this.refresh();
		}
		setCharacterImage(t, e) {
			(this._characterName = t), (this._characterIndex = e);
		}
		setFaceImage(t, e) {
			(this._faceName = t), (this._faceIndex = e);
		}
		setBattlerImage(t) {
			this._battlerName = t;
		}
		isSpriteVisible() {
			return self.$gameSystem.isSideView();
		}
		startAnimation(t, e, i) {
			(e = !e), super.startAnimation(t, e, i);
		}
		performActionStart(t) {
			super.performActionStart(t);
		}
		performAction(t) {
			super.performAction(t),
				t.isAttack()
					? this.performAttack()
					: t.isGuard()
					? this.requestMotion('guard')
					: t.isMagicSkill()
					? this.requestMotion('spell')
					: t.isSkill()
					? this.requestMotion('skill')
					: t.isItem() && this.requestMotion('item');
		}
		performActionEnd() {
			super.performActionEnd();
		}
		performAttack() {
			const t = this.weapons(),
				e = t[0] ? t[0].wtypeId : 0,
				i = self.$dataSystem.attackMotions[e];
			i &&
				(0 === i.type
					? this.requestMotion('thrust')
					: 1 === i.type
					? this.requestMotion('swing')
					: 2 === i.type && this.requestMotion('missile'),
				this.startWeaponAnimation(i.weaponImageId));
		}
		performDamage() {
			super.performDamage(),
				this.isSpriteVisible()
					? this.requestMotion('damage')
					: self.$gameScreen.startShake(5, 5, 10),
				SoundManager.playActorDamage();
		}
		performEvasion() {
			super.performEvasion(), this.requestMotion('evade');
		}
		performMagicEvasion() {
			super.performMagicEvasion(), this.requestMotion('evade');
		}
		performCounter() {
			super.performCounter(), this.performAttack();
		}
		performCollapse() {
			super.performCollapse(),
				self.$gameParty.inBattle() && SoundManager.playActorCollapse();
		}
		performVictory() {
			this.canMove() && this.requestMotion('victory');
		}
		performEscape() {
			this.canMove() && this.requestMotion('escape');
		}
		makeActionList() {
			const t = [];
			let e = new Game_Action(this);
			return (
				e.setAttack(),
				t.push(e),
				this.usableSkills().forEach(function ({ id: i }) {
					(e = new Game_Action(this)), e.setSkill(i), t.push(e);
				}, this),
				t
			);
		}
		makeAutoBattleActions() {
			for (let t = 0; t < this.numActions(); t++) {
				const e = this.makeActionList();
				let i = Number.MIN_VALUE;
				for (let r = 0; r < e.length; r++) {
					const s = e[r].evaluate();
					s > i && ((i = s), this.setAction(t, e[r]));
				}
			}
			this.setActionState('waiting');
		}
		makeConfusionActions() {
			for (let t = 0; t < this.numActions(); t++) this.action(t).setConfusion();
			this.setActionState('waiting');
		}
		makeActions() {
			super.makeActions(),
				this.numActions() > 0
					? this.setActionState('undecided')
					: this.setActionState('waiting'),
				this.isAutoBattle()
					? this.makeAutoBattleActions()
					: this.isConfused() && this.makeConfusionActions();
		}
		onPlayerWalk() {
			this.clearResult(),
				this.checkFloorEffect(),
				self.$gamePlayer.isNormal() &&
					(this.turnEndOnMap(),
					this.states().forEach(function (t) {
						this.updateStateSteps(t);
					}, this),
					this.showAddedStates(),
					this.showRemovedStates());
		}
		updateStateSteps({ removeByWalking: t, id: e }) {
			t &&
				this._stateSteps[e] > 0 &&
				0 == --this._stateSteps[e] &&
				this.removeState(e);
		}
		showAddedStates() {
			this.result()
				.addedStateObjects()
				.forEach(function ({ message1: t }) {
					t && self.$gameMessage.add(this._name + t);
				}, this);
		}
		showRemovedStates() {
			this.result()
				.removedStateObjects()
				.forEach(function ({ message4: t }) {
					t && self.$gameMessage.add(this._name + t);
				}, this);
		}
		stepsForTurn() {
			return 20;
		}
		turnEndOnMap() {
			self.$gameParty.steps() % this.stepsForTurn() == 0 &&
				(this.onTurnEnd(),
				this.result().hpDamage > 0 && this.performMapDamage());
		}
		checkFloorEffect() {
			self.$gamePlayer.isOnDamageFloor() && this.executeFloorDamage();
		}
		executeFloorDamage() {
			let t = Math.floor(this.basicFloorDamage() * this.fdr);
			(t = Math.min(t, this.maxFloorDamage())),
				this.gainHp(-t),
				t > 0 && this.performMapDamage();
		}
		basicFloorDamage() {
			return 10;
		}
		maxFloorDamage() {
			return self.$dataSystem.optFloorDeath
				? this.hp
				: Math.max(this.hp - 1, 0);
		}
		performMapDamage() {
			self.$gameParty.inBattle() || self.$gameScreen.startFlashForDamage();
		}
		clearActions() {
			super.clearActions(), (this._actionInputIndex = 0);
		}
		inputtingAction() {
			return this.action(this._actionInputIndex);
		}
		selectNextCommand() {
			return (
				this._actionInputIndex < this.numActions() - 1 &&
				(this._actionInputIndex++, !0)
			);
		}
		selectPreviousCommand() {
			return this._actionInputIndex > 0 && (this._actionInputIndex--, !0);
		}
		lastMenuSkill() {
			return this._lastMenuSkill.object();
		}
		setLastMenuSkill(t) {
			this._lastMenuSkill.setObject(t);
		}
		lastBattleSkill() {
			return this._lastBattleSkill.object();
		}
		setLastBattleSkill(t) {
			this._lastBattleSkill.setObject(t);
		}
		lastCommandSymbol() {
			return this._lastCommandSymbol;
		}
		setLastCommandSymbol(t) {
			this._lastCommandSymbol = t;
		}
		testEscape({ effects: t }) {
			return t.some((t, e, i) => t && t.code === Game_Action.EFFECT_SPECIAL);
		}
		meetsUsableItemConditions(t) {
			return (
				!(
					self.$gameParty.inBattle() &&
					!BattleManager.canEscape() &&
					this.testEscape(t)
				) && Game_BattlerBase.prototype.meetsUsableItemConditions.call(this, t)
			);
		}
	}
	class Game_Actors {
		constructor(...t) {
			this.initialize(...t);
		}
		initialize() {
			this._data = [];
		}
		actor(t) {
			return self.$dataActors[t]
				? (this._data[t] || (this._data[t] = new Game_Actor(t)), this._data[t])
				: null;
		}
	}
	class Game_Unit {
		constructor(...t) {
			this.initialize(...t);
		}
		initialize() {
			this._inBattle = !1;
		}
		inBattle() {
			return this._inBattle;
		}
		members() {
			return [];
		}
		aliveMembers() {
			return this.members().filter((t) => t.isAlive());
		}
		deadMembers() {
			return this.members().filter((t) => t.isDead());
		}
		movableMembers() {
			return this.members().filter((t) => t.canMove());
		}
		clearActions() {
			return this.members().forEach((t) => t.clearActions());
		}
		agility() {
			const t = this.members();
			return 0 === t.length
				? 1
				: t.reduce((t, { agi: e }) => t + e, 0) / t.length;
		}
		tgrSum() {
			return this.aliveMembers().reduce((t, { tgr: e }) => t + e, 0);
		}
		randomTarget() {
			let t = Math.random() * this.tgrSum(),
				e = null;
			return (
				this.aliveMembers().forEach((i) => {
					(t -= i.tgr), t <= 0 && !e && (e = i);
				}),
				e
			);
		}
		randomDeadTarget() {
			const t = this.deadMembers();
			return 0 === t.length ? null : t[Math.floor(Math.random() * t.length)];
		}
		smoothTarget(t) {
			t < 0 && (t = 0);
			const e = this.members()[t];
			return e && e.isAlive() ? e : this.aliveMembers()[0];
		}
		smoothDeadTarget(t) {
			t < 0 && (t = 0);
			const e = this.members()[t];
			return e && e.isDead() ? e : this.deadMembers()[0];
		}
		clearResults() {
			this.members().forEach((t) => {
				t.clearResult();
			});
		}
		onBattleStart() {
			this.members().forEach((t) => {
				t.onBattleStart();
			}),
				(this._inBattle = !0);
		}
		onBattleEnd() {
			(this._inBattle = !1),
				this.members().forEach((t) => {
					t.onBattleEnd();
				});
		}
		makeActions() {
			this.members().forEach((t) => {
				t.makeActions();
			});
		}
		select(t) {
			this.members().forEach((e) => {
				e === t ? e.select() : e.deselect();
			});
		}
		isAllDead() {
			return 0 === this.aliveMembers().length;
		}
		substituteBattler() {
			const t = this.members();
			for (let e = 0; e < t.length; e++) if (t[e].isSubstitute()) return t[e];
		}
	}
	class Game_Party extends Game_Unit {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize(),
				(this._gold = 0),
				(this._steps = 0),
				(this._lastItem = new Game_Item()),
				(this._menuActorId = 0),
				(this._targetActorId = 0),
				(this._actors = []),
				this.initAllItems();
		}
		initAllItems() {
			(this._items = {}), (this._weapons = {}), (this._armors = {});
		}
		exists() {
			return this._actors.length > 0;
		}
		size() {
			return this.members().length;
		}
		isEmpty() {
			return 0 === this.size();
		}
		members() {
			return this.inBattle() ? this.battleMembers() : this.allMembers();
		}
		allMembers() {
			return this._actors.map((t) => self.$gameActors.actor(t));
		}
		battleMembers() {
			return this.allMembers()
				.slice(0, this.maxBattleMembers())
				.filter((t) => t.isAppeared());
		}
		maxBattleMembers() {
			return 4;
		}
		leader() {
			return this.battleMembers()[0];
		}
		reviveBattleMembers() {
			this.battleMembers().forEach((t) => {
				t.isDead() && t.setHp(1);
			});
		}
		items() {
			const t = [];
			for (let e in this._items) t.push(self.$dataItems[e]);
			return t;
		}
		weapons() {
			const t = [];
			for (let e in this._weapons) t.push(self.$dataWeapons[e]);
			return t;
		}
		armors() {
			const t = [];
			for (let e in this._armors) t.push(self.$dataArmors[e]);
			return t;
		}
		equipItems() {
			return this.weapons().concat(this.armors());
		}
		allItems() {
			return this.items().concat(this.equipItems());
		}
		itemContainer(t) {
			return t
				? DataManager$1.isItem(t)
					? this._items
					: DataManager$1.isWeapon(t)
					? this._weapons
					: DataManager$1.isArmor(t)
					? this._armors
					: null
				: null;
		}
		setupStartingMembers() {
			(this._actors = []),
				self.$dataSystem.partyMembers.forEach(function (t) {
					self.$gameActors.actor(t) && this._actors.push(t);
				}, this);
		}
		name() {
			const t = this.battleMembers().length;
			return 0 === t
				? ''
				: 1 === t
				? this.leader().name()
				: TextManager.partyName.format(this.leader().name());
		}
		setupBattleTest() {
			this.setupBattleTestMembers(), this.setupBattleTestItems();
		}
		setupBattleTestMembers() {
			self.$dataSystem.testBattlers.forEach(function ({
				actorId: t,
				level: e,
				equips: i,
			}) {
				const r = self.$gameActors.actor(t);
				r &&
					(r.changeLevel(e, !1),
					r.initEquips(i),
					r.recoverAll(),
					this.addActor(t));
			},
			this);
		}
		setupBattleTestItems() {
			self.$dataItems.forEach(function (t) {
				t && t.name.length > 0 && this.gainItem(t, this.maxItems(t));
			}, this);
		}
		highestLevel() {
			return Math.max.apply(
				null,
				this.members().map(({ level: t }) => t)
			);
		}
		addActor(t) {
			this._actors.contains(t) ||
				(this._actors.push(t),
				self.$gamePlayer.refresh(),
				self.$gameMap.requestRefresh());
		}
		removeActor(t) {
			this._actors.contains(t) &&
				(this._actors.splice(this._actors.indexOf(t), 1),
				self.$gamePlayer.refresh(),
				self.$gameMap.requestRefresh());
		}
		gold() {
			return this._gold;
		}
		gainGold(t) {
			this._gold = (this._gold + t).clamp(0, this.maxGold());
		}
		loseGold(t) {
			this.gainGold(-t);
		}
		maxGold() {
			return 99999999;
		}
		steps() {
			return this._steps;
		}
		increaseSteps() {
			this._steps++;
		}
		numItems(t) {
			const e = this.itemContainer(t);
			return (e && e[t.id]) || 0;
		}
		maxItems(t) {
			return 99;
		}
		hasMaxItems(t) {
			return this.numItems(t) >= this.maxItems(t);
		}
		hasItem(t, e) {
			return (
				void 0 === e && (e = !1),
				this.numItems(t) > 0 || !(!e || !this.isAnyMemberEquipped(t))
			);
		}
		isAnyMemberEquipped(t) {
			return this.members().some((e) => e.equips().contains(t));
		}
		gainItem(t, e, i) {
			const r = this.itemContainer(t);
			if (r) {
				const s = this.numItems(t) + e;
				(r[t.id] = s.clamp(0, this.maxItems(t))),
					0 === r[t.id] && delete r[t.id],
					i && s < 0 && this.discardMembersEquip(t, -s),
					self.$gameMap.requestRefresh();
			}
		}
		discardMembersEquip(t, e) {
			let i = e;
			this.members().forEach((e) => {
				for (; i > 0 && e.isEquipped(t); ) e.discardEquip(t), i--;
			});
		}
		loseItem(t, e, i) {
			this.gainItem(t, -e, i);
		}
		consumeItem(t) {
			DataManager$1.isItem(t) && t.consumable && this.loseItem(t, 1);
		}
		canUse(t) {
			return this.members().some((e) => e.canUse(t));
		}
		canInput() {
			return this.members().some((t) => t.canInput());
		}
		isAllDead() {
			return (
				!!Game_Unit.prototype.isAllDead.call(this) &&
				(this.inBattle() || !this.isEmpty())
			);
		}
		onPlayerWalk() {
			this.members().forEach((t) => t.onPlayerWalk());
		}
		menuActor() {
			let t = self.$gameActors.actor(this._menuActorId);
			return this.members().contains(t) || (t = this.members()[0]), t;
		}
		setMenuActor(t) {
			this._menuActorId = t.actorId();
		}
		makeMenuActorNext() {
			let t = this.members().indexOf(this.menuActor());
			t >= 0
				? ((t = (t + 1) % this.members().length),
				  this.setMenuActor(this.members()[t]))
				: this.setMenuActor(this.members()[0]);
		}
		makeMenuActorPrevious() {
			let t = this.members().indexOf(this.menuActor());
			t >= 0
				? ((t = (t + this.members().length - 1) % this.members().length),
				  this.setMenuActor(this.members()[t]))
				: this.setMenuActor(this.members()[0]);
		}
		targetActor() {
			let t = self.$gameActors.actor(this._targetActorId);
			return this.members().contains(t) || (t = this.members()[0]), t;
		}
		setTargetActor(t) {
			this._targetActorId = t.actorId();
		}
		lastItem() {
			return this._lastItem.object();
		}
		setLastItem(t) {
			this._lastItem.setObject(t);
		}
		swapOrder(t, e) {
			const i = this._actors[t];
			(this._actors[t] = this._actors[e]),
				(this._actors[e] = i),
				self.$gamePlayer.refresh();
		}
		charactersForSavefile() {
			return this.battleMembers().map((t) => [
				t.characterName(),
				t.characterIndex(),
			]);
		}
		facesForSavefile() {
			return this.battleMembers().map((t) => [t.faceName(), t.faceIndex()]);
		}
		partyAbility(t) {
			return this.battleMembers().some((e) => e.partyAbility(t));
		}
		hasEncounterHalf() {
			return this.partyAbility(Game_Party.ABILITY_ENCOUNTER_HALF);
		}
		hasEncounterNone() {
			return this.partyAbility(Game_Party.ABILITY_ENCOUNTER_NONE);
		}
		hasCancelSurprise() {
			return this.partyAbility(Game_Party.ABILITY_CANCEL_SURPRISE);
		}
		hasRaisePreemptive() {
			return this.partyAbility(Game_Party.ABILITY_RAISE_PREEMPTIVE);
		}
		hasGoldDouble() {
			return this.partyAbility(Game_Party.ABILITY_GOLD_DOUBLE);
		}
		hasDropItemDouble() {
			return this.partyAbility(Game_Party.ABILITY_DROP_ITEM_DOUBLE);
		}
		ratePreemptive(t) {
			let e = this.agility() >= t ? 0.05 : 0.03;
			return this.hasRaisePreemptive() && (e *= 4), e;
		}
		rateSurprise(t) {
			let e = this.agility() >= t ? 0.03 : 0.05;
			return this.hasCancelSurprise() && (e = 0), e;
		}
		performVictory() {
			this.members().forEach((t) => {
				t.performVictory();
			});
		}
		performEscape() {
			this.members().forEach((t) => {
				t.performEscape();
			});
		}
		removeBattleStates() {
			this.members().forEach((t) => {
				t.removeBattleStates();
			});
		}
		requestMotionRefresh() {
			this.members().forEach((t) => {
				t.requestMotionRefresh();
			});
		}
	}
	(Game_Party.ABILITY_ENCOUNTER_HALF = 0),
		(Game_Party.ABILITY_ENCOUNTER_NONE = 1),
		(Game_Party.ABILITY_CANCEL_SURPRISE = 2),
		(Game_Party.ABILITY_RAISE_PREEMPTIVE = 3),
		(Game_Party.ABILITY_GOLD_DOUBLE = 4),
		(Game_Party.ABILITY_DROP_ITEM_DOUBLE = 5);
	class Game_Enemy extends Game_Battler {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e, i) {
			super.initialize(), this.setup(t, e, i);
		}
		initMembers() {
			super.initMembers(),
				(this._enemyId = 0),
				(this._letter = ''),
				(this._plural = !1),
				(this._screenX = 0),
				(this._screenY = 0);
		}
		setup(t, e, i) {
			(this._enemyId = t),
				(this._screenX = e),
				(this._screenY = i),
				this.recoverAll();
		}
		isEnemy() {
			return !0;
		}
		friendsUnit() {
			return self.$gameTroop;
		}
		opponentsUnit() {
			return self.$gameParty;
		}
		index() {
			return self.$gameTroop.members().indexOf(this);
		}
		isBattleMember() {
			return this.index() >= 0;
		}
		enemyId() {
			return this._enemyId;
		}
		enemy() {
			return self.$dataEnemies[this._enemyId];
		}
		traitObjects() {
			return Game_Battler.prototype.traitObjects
				.call(this)
				.concat(this.enemy());
		}
		paramBase(t) {
			return this.enemy().params[t];
		}
		exp() {
			return this.enemy().exp;
		}
		gold() {
			return this.enemy().gold;
		}
		makeDropItems() {
			return this.enemy().dropItems.reduce(
				(t, { kind: e, denominator: i, dataId: r }) =>
					e > 0 && Math.random() * i < this.dropItemRate()
						? t.concat(this.itemObject(e, r))
						: t,
				[]
			);
		}
		dropItemRate() {
			return self.$gameParty.hasDropItemDouble() ? 2 : 1;
		}
		itemObject(t, e) {
			return 1 === t
				? self.$dataItems[e]
				: 2 === t
				? self.$dataWeapons[e]
				: 3 === t
				? self.$dataArmors[e]
				: null;
		}
		isSpriteVisible() {
			return !0;
		}
		screenX() {
			return this._screenX;
		}
		screenY() {
			return this._screenY;
		}
		battlerName() {
			return this.enemy().battlerName;
		}
		battlerHue() {
			return this.enemy().battlerHue;
		}
		originalName() {
			return this.enemy().name;
		}
		name() {
			return this.originalName() + (this._plural ? this._letter : '');
		}
		isLetterEmpty() {
			return '' === this._letter;
		}
		setLetter(t) {
			this._letter = t;
		}
		setPlural(t) {
			this._plural = t;
		}
		performActionStart(t) {
			super.performActionStart(t), this.requestEffect('whiten');
		}
		performAction(t) {
			super.performAction(t);
		}
		performActionEnd() {
			super.performActionEnd();
		}
		performDamage() {
			super.performDamage(),
				SoundManager.playEnemyDamage(),
				this.requestEffect('blink');
		}
		performCollapse() {
			switch ((super.performCollapse(), this.collapseType())) {
				case 0:
					this.requestEffect('collapse'), SoundManager.playEnemyCollapse();
					break;
				case 1:
					this.requestEffect('bossCollapse'), SoundManager.playBossCollapse1();
					break;
				case 2:
					this.requestEffect('instantCollapse');
			}
		}
		transform(t) {
			const e = this.originalName();
			(this._enemyId = t),
				this.originalName() !== e && ((this._letter = ''), (this._plural = !1)),
				this.refresh(),
				this.numActions() > 0 && this.makeActions();
		}
		meetsCondition({
			conditionParam1: t,
			conditionParam2: e,
			conditionType: i,
		}) {
			const r = t,
				s = e;
			switch (i) {
				case 1:
					return this.meetsTurnCondition(r, s);
				case 2:
					return this.meetsHpCondition(r, s);
				case 3:
					return this.meetsMpCondition(r, s);
				case 4:
					return this.meetsStateCondition(r);
				case 5:
					return this.meetsPartyLevelCondition(r);
				case 6:
					return this.meetsSwitchCondition(r);
				default:
					return !0;
			}
		}
		meetsTurnCondition(t, e) {
			const i = self.$gameTroop.turnCount();
			return 0 === e ? i === t : i > 0 && i >= t && i % e == t % e;
		}
		meetsHpCondition(t, e) {
			return this.hpRate() >= t && this.hpRate() <= e;
		}
		meetsMpCondition(t, e) {
			return this.mpRate() >= t && this.mpRate() <= e;
		}
		meetsStateCondition(t) {
			return this.isStateAffected(t);
		}
		meetsPartyLevelCondition(t) {
			return self.$gameParty.highestLevel() >= t;
		}
		meetsSwitchCondition(t) {
			return self.$gameSwitches.value(t);
		}
		isActionValid(t) {
			return this.meetsCondition(t) && this.canUse(self.$dataSkills[t.skillId]);
		}
		selectAction(t, e) {
			const i = t.reduce((t, { rating: i }) => t + i - e, 0);
			if (!(i > 0)) return null;
			{
				let r = Math.randomInt(i);
				for (const i of t) if (((r -= i.rating - e), r < 0)) return i;
			}
		}
		selectAllActions(t) {
			const e =
				Math.max.apply(
					null,
					t.map(({ rating: t }) => t)
				) - 3;
			t = t.filter(({ rating: t }) => t > e);
			for (let i = 0; i < this.numActions(); i++)
				this.action(i).setEnemyAction(this.selectAction(t, e));
		}
		makeActions() {
			if ((super.makeActions(), this.numActions() > 0)) {
				const t = this.enemy().actions.filter(function (t) {
					return this.isActionValid(t);
				}, this);
				t.length > 0 && this.selectAllActions(t);
			}
			this.setActionState('waiting');
		}
	}
	class Game_CharacterBase {
		constructor(...t) {
			this.initialize(...t);
		}
		initialize() {
			this.initMembers();
		}
		initMembers() {
			(this._x = 0),
				(this._y = 0),
				(this._realX = 0),
				(this._realY = 0),
				(this._moveSpeed = 4),
				(this._moveFrequency = 6),
				(this._opacity = 255),
				(this._blendMode = 0),
				(this._direction = 2),
				(this._pattern = 1),
				(this._priorityType = 1),
				(this._tileId = 0),
				(this._characterName = ''),
				(this._characterIndex = 0),
				(this._isObjectCharacter = !1),
				(this._walkAnime = !0),
				(this._stepAnime = !1),
				(this._directionFix = !1),
				(this._through = !1),
				(this._transparent = !1),
				(this._bushDepth = 0),
				(this._animationId = 0),
				(this._balloonId = 0),
				(this._animationPlaying = !1),
				(this._balloonPlaying = !1),
				(this._animationCount = 0),
				(this._stopCount = 0),
				(this._jumpCount = 0),
				(this._jumpPeak = 0),
				(this._movementSuccess = !0);
		}
		pos(t, e) {
			return this._x === t && this._y === e;
		}
		posNt(t, e) {
			return this.pos(t, e) && !this.isThrough();
		}
		moveSpeed() {
			return this._moveSpeed;
		}
		setMoveSpeed(t) {
			this._moveSpeed = t;
		}
		moveFrequency() {
			return this._moveFrequency;
		}
		setMoveFrequency(t) {
			this._moveFrequency = t;
		}
		opacity() {
			return this._opacity;
		}
		setOpacity(t) {
			this._opacity = t;
		}
		blendMode() {
			return this._blendMode;
		}
		setBlendMode(t) {
			this._blendMode = t;
		}
		isNormalPriority() {
			return 1 === this._priorityType;
		}
		setPriorityType(t) {
			this._priorityType = t;
		}
		isMoving() {
			return this._realX !== this._x || this._realY !== this._y;
		}
		isJumping() {
			return this._jumpCount > 0;
		}
		jumpHeight() {
			return (
				(this._jumpPeak * this._jumpPeak -
					Math.pow(Math.abs(this._jumpCount - this._jumpPeak), 2)) /
				2
			);
		}
		isStopping() {
			return !this.isMoving() && !this.isJumping();
		}
		checkStop(t) {
			return this._stopCount > t;
		}
		resetStopCount() {
			this._stopCount = 0;
		}
		realMoveSpeed() {
			return this._moveSpeed + (this.isDashing() ? 1 : 0);
		}
		distancePerFrame() {
			return Math.pow(2, this.realMoveSpeed()) / 256;
		}
		isDashing() {
			return !1;
		}
		isDebugThrough() {
			return !1;
		}
		straighten() {
			(this.hasWalkAnime() || this.hasStepAnime()) && (this._pattern = 1),
				(this._animationCount = 0);
		}
		reverseDir(t) {
			return 10 - t;
		}
		canPass(t, e, i) {
			const r = self.$gameMap.roundXWithDirection(t, i),
				s = self.$gameMap.roundYWithDirection(e, i);
			return !(
				!self.$gameMap.isValid(r, s) ||
				(!this.isThrough() &&
					!this.isDebugThrough() &&
					(!this.isMapPassable(t, e, i) || this.isCollidedWithCharacters(r, s)))
			);
		}
		canPassDiagonally(t, e, i, r) {
			const s = self.$gameMap.roundXWithDirection(t, i),
				n = self.$gameMap.roundYWithDirection(e, r);
			return (
				!(!this.canPass(t, e, r) || !this.canPass(t, n, i)) ||
				!(!this.canPass(t, e, i) || !this.canPass(s, e, r))
			);
		}
		isMapPassable(t, e, i) {
			const r = self.$gameMap.roundXWithDirection(t, i),
				s = self.$gameMap.roundYWithDirection(e, i),
				n = this.reverseDir(i);
			return (
				self.$gameMap.isPassable(t, e, i) && self.$gameMap.isPassable(r, s, n)
			);
		}
		isCollidedWithCharacters(t, e) {
			return (
				this.isCollidedWithEvents(t, e) || this.isCollidedWithVehicles(t, e)
			);
		}
		isCollidedWithEvents(t, e) {
			return self.$gameMap.eventsXyNt(t, e).some((t) => t.isNormalPriority());
		}
		isCollidedWithVehicles(t, e) {
			return (
				self.$gameMap.boat().posNt(t, e) || self.$gameMap.ship().posNt(t, e)
			);
		}
		setPosition(t, e) {
			(this._x = Math.round(t)),
				(this._y = Math.round(e)),
				(this._realX = t),
				(this._realY = e);
		}
		copyPosition(t) {
			(this._x = t._x),
				(this._y = t._y),
				(this._realX = t._realX),
				(this._realY = t._realY),
				(this._direction = t._direction);
		}
		locate(t, e) {
			this.setPosition(t, e), this.straighten(), this.refreshBushDepth();
		}
		direction() {
			return this._direction;
		}
		setDirection(t) {
			!this.isDirectionFixed() && t && (this._direction = t),
				this.resetStopCount();
		}
		isTile() {
			return this._tileId > 0 && 0 === this._priorityType;
		}
		isObjectCharacter() {
			return this._isObjectCharacter;
		}
		shiftY() {
			return this.isObjectCharacter() ? 0 : 6;
		}
		scrolledX() {
			return self.$gameMap.adjustX(this._realX);
		}
		scrolledY() {
			return self.$gameMap.adjustY(this._realY);
		}
		screenX() {
			const t = self.$gameMap.tileWidth();
			return Math.round(this.scrolledX() * t + t / 2);
		}
		screenY() {
			const t = self.$gameMap.tileHeight();
			return Math.round(
				this.scrolledY() * t + t - this.shiftY() - this.jumpHeight()
			);
		}
		screenZ() {
			return 2 * this._priorityType + 1;
		}
		isNearTheScreen() {
			const t = Graphics.width,
				e = Graphics.height,
				i = self.$gameMap.tileWidth(),
				r = self.$gameMap.tileHeight(),
				s = this.scrolledX() * i + i / 2 - t / 2,
				n = this.scrolledY() * r + r / 2 - e / 2;
			return s >= -t && s <= t && n >= -e && n <= e;
		}
		update() {
			this.isStopping() && this.updateStop(),
				this.isJumping()
					? this.updateJump()
					: this.isMoving() && this.updateMove(),
				this.updateAnimation();
		}
		updateStop() {
			this._stopCount++;
		}
		updateJump() {
			this._jumpCount--,
				(this._realX =
					(this._realX * this._jumpCount + this._x) / (this._jumpCount + 1)),
				(this._realY =
					(this._realY * this._jumpCount + this._y) / (this._jumpCount + 1)),
				this.refreshBushDepth(),
				0 === this._jumpCount &&
					((this._realX = this._x = self.$gameMap.roundX(this._x)),
					(this._realY = this._y = self.$gameMap.roundY(this._y)));
		}
		updateMove() {
			this._x < this._realX &&
				(this._realX = Math.max(
					this._realX - this.distancePerFrame(),
					this._x
				)),
				this._x > this._realX &&
					(this._realX = Math.min(
						this._realX + this.distancePerFrame(),
						this._x
					)),
				this._y < this._realY &&
					(this._realY = Math.max(
						this._realY - this.distancePerFrame(),
						this._y
					)),
				this._y > this._realY &&
					(this._realY = Math.min(
						this._realY + this.distancePerFrame(),
						this._y
					)),
				this.isMoving() || this.refreshBushDepth();
		}
		updateAnimation() {
			this.updateAnimationCount(),
				this._animationCount >= this.animationWait() &&
					(this.updatePattern(), (this._animationCount = 0));
		}
		animationWait() {
			return 3 * (9 - this.realMoveSpeed());
		}
		updateAnimationCount() {
			this.isMoving() && this.hasWalkAnime()
				? (this._animationCount += 1.5)
				: (!this.hasStepAnime() && this.isOriginalPattern()) ||
				  this._animationCount++;
		}
		updatePattern() {
			!this.hasStepAnime() && this._stopCount > 0
				? this.resetPattern()
				: (this._pattern = (this._pattern + 1) % this.maxPattern());
		}
		maxPattern() {
			return 4;
		}
		pattern() {
			return this._pattern < 3 ? this._pattern : 1;
		}
		setPattern(t) {
			this._pattern = t;
		}
		isOriginalPattern() {
			return 1 === this.pattern();
		}
		resetPattern() {
			this.setPattern(1);
		}
		refreshBushDepth() {
			this.isNormalPriority() &&
			!this.isObjectCharacter() &&
			this.isOnBush() &&
			!this.isJumping()
				? this.isMoving() || (this._bushDepth = 12)
				: (this._bushDepth = 0);
		}
		isOnLadder() {
			return self.$gameMap.isLadder(this._x, this._y);
		}
		isOnBush() {
			return self.$gameMap.isBush(this._x, this._y);
		}
		terrainTag() {
			return self.$gameMap.terrainTag(this._x, this._y);
		}
		regionId() {
			return self.$gameMap.regionId(this._x, this._y);
		}
		increaseSteps() {
			this.isOnLadder() && this.setDirection(8),
				this.resetStopCount(),
				this.refreshBushDepth();
		}
		tileId() {
			return this._tileId;
		}
		characterName() {
			return this._characterName;
		}
		characterIndex() {
			return this._characterIndex;
		}
		setImage(t, e) {
			(this._tileId = 0),
				(this._characterName = t),
				(this._characterIndex = e),
				(this._isObjectCharacter = ImageManager.isObjectCharacter(t));
		}
		setTileImage(t) {
			(this._tileId = t),
				(this._characterName = ''),
				(this._characterIndex = 0),
				(this._isObjectCharacter = !0);
		}
		checkEventTriggerTouchFront(t) {
			const e = self.$gameMap.roundXWithDirection(this._x, t),
				i = self.$gameMap.roundYWithDirection(this._y, t);
			this.checkEventTriggerTouch(e, i);
		}
		checkEventTriggerTouch(t, e) {
			return !1;
		}
		isMovementSucceeded(t, e) {
			return this._movementSuccess;
		}
		setMovementSuccess(t) {
			this._movementSuccess = t;
		}
		moveStraight(t) {
			this.setMovementSuccess(this.canPass(this._x, this._y, t)),
				this.isMovementSucceeded()
					? (this.setDirection(t),
					  (this._x = self.$gameMap.roundXWithDirection(this._x, t)),
					  (this._y = self.$gameMap.roundYWithDirection(this._y, t)),
					  (this._realX = self.$gameMap.xWithDirection(
							this._x,
							this.reverseDir(t)
					  )),
					  (this._realY = self.$gameMap.yWithDirection(
							this._y,
							this.reverseDir(t)
					  )),
					  this.increaseSteps())
					: (this.setDirection(t), this.checkEventTriggerTouchFront(t));
		}
		moveDiagonally(t, e) {
			this.setMovementSuccess(this.canPassDiagonally(this._x, this._y, t, e)),
				this.isMovementSucceeded() &&
					((this._x = self.$gameMap.roundXWithDirection(this._x, t)),
					(this._y = self.$gameMap.roundYWithDirection(this._y, e)),
					(this._realX = self.$gameMap.xWithDirection(
						this._x,
						this.reverseDir(t)
					)),
					(this._realY = self.$gameMap.yWithDirection(
						this._y,
						this.reverseDir(e)
					)),
					this.increaseSteps()),
				this._direction === this.reverseDir(t) && this.setDirection(t),
				this._direction === this.reverseDir(e) && this.setDirection(e);
		}
		jump(t, e) {
			Math.abs(t) > Math.abs(e)
				? 0 !== t && this.setDirection(t < 0 ? 4 : 6)
				: 0 !== e && this.setDirection(e < 0 ? 8 : 2),
				(this._x += t),
				(this._y += e);
			const i = Math.round(Math.sqrt(t * t + e * e));
			(this._jumpPeak = 10 + i - this._moveSpeed),
				(this._jumpCount = 2 * this._jumpPeak),
				this.resetStopCount(),
				this.straighten();
		}
		hasWalkAnime() {
			return this._walkAnime;
		}
		setWalkAnime(t) {
			this._walkAnime = t;
		}
		hasStepAnime() {
			return this._stepAnime;
		}
		setStepAnime(t) {
			this._stepAnime = t;
		}
		isDirectionFixed() {
			return this._directionFix;
		}
		setDirectionFix(t) {
			this._directionFix = t;
		}
		isThrough() {
			return this._through;
		}
		setThrough(t) {
			this._through = t;
		}
		isTransparent() {
			return this._transparent;
		}
		bushDepth() {
			return this._bushDepth;
		}
		setTransparent(t) {
			this._transparent = t;
		}
		requestAnimation(t) {
			this._animationId = t;
		}
		requestBalloon(t) {
			this._balloonId = t;
		}
		animationId() {
			return this._animationId;
		}
		balloonId() {
			return this._balloonId;
		}
		startAnimation() {
			(this._animationId = 0), (this._animationPlaying = !0);
		}
		startBalloon() {
			(this._balloonId = 0), (this._balloonPlaying = !0);
		}
		isAnimationPlaying() {
			return this._animationId > 0 || this._animationPlaying;
		}
		isBalloonPlaying() {
			return this._balloonId > 0 || this._balloonPlaying;
		}
		endAnimation() {
			this._animationPlaying = !1;
		}
		endBalloon() {
			this._balloonPlaying = !1;
		}
	}
	Object.defineProperties(Game_CharacterBase.prototype, {
		x: {
			get() {
				return this._x;
			},
			configurable: !0,
		},
		y: {
			get() {
				return this._y;
			},
			configurable: !0,
		},
	});
	class Game_Character extends Game_CharacterBase {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize();
		}
		initMembers() {
			super.initMembers(),
				(this._moveRouteForcing = !1),
				(this._moveRoute = null),
				(this._moveRouteIndex = 0),
				(this._originalMoveRoute = null),
				(this._originalMoveRouteIndex = 0),
				(this._waitCount = 0),
				(this._callerEventInfo = null);
		}
		memorizeMoveRoute() {
			(this._originalMoveRoute = this._moveRoute),
				(this._originalMoveRouteIndex = this._moveRouteIndex);
		}
		restoreMoveRoute() {
			(this._moveRoute = this._originalMoveRoute),
				(this._moveRouteIndex = this._originalMoveRouteIndex - 1),
				(this._originalMoveRoute = null),
				(this._callerEventInfo = null);
		}
		isMoveRouteForcing() {
			return this._moveRouteForcing;
		}
		setMoveRoute(t) {
			(this._moveRoute = t),
				(this._moveRouteIndex = 0),
				(this._moveRouteForcing = !1);
		}
		forceMoveRoute(t) {
			this._originalMoveRoute || this.memorizeMoveRoute(),
				(this._moveRoute = t),
				(this._moveRouteIndex = 0),
				(this._moveRouteForcing = !0),
				(this._waitCount = 0);
		}
		setCallerEventInfo(t) {
			this._callerEventInfo = t;
		}
		updateStop() {
			super.updateStop(), this._moveRouteForcing && this.updateRoutineMove();
		}
		updateRoutineMove() {
			if (this._waitCount > 0) this._waitCount--;
			else {
				this.setMovementSuccess(!0);
				const t = this._moveRoute.list[this._moveRouteIndex];
				t && (this.processMoveCommand(t), this.advanceMoveRouteIndex());
			}
		}
		processMoveCommand(command) {
			const gc = Game_Character,
				params = command.parameters;
			switch (command.code) {
				case gc.ROUTE_END:
					this.processRouteEnd();
					break;
				case gc.ROUTE_MOVE_DOWN:
					this.moveStraight(2);
					break;
				case gc.ROUTE_MOVE_LEFT:
					this.moveStraight(4);
					break;
				case gc.ROUTE_MOVE_RIGHT:
					this.moveStraight(6);
					break;
				case gc.ROUTE_MOVE_UP:
					this.moveStraight(8);
					break;
				case gc.ROUTE_MOVE_LOWER_L:
					this.moveDiagonally(4, 2);
					break;
				case gc.ROUTE_MOVE_LOWER_R:
					this.moveDiagonally(6, 2);
					break;
				case gc.ROUTE_MOVE_UPPER_L:
					this.moveDiagonally(4, 8);
					break;
				case gc.ROUTE_MOVE_UPPER_R:
					this.moveDiagonally(6, 8);
					break;
				case gc.ROUTE_MOVE_RANDOM:
					this.moveRandom();
					break;
				case gc.ROUTE_MOVE_TOWARD:
					this.moveTowardPlayer();
					break;
				case gc.ROUTE_MOVE_AWAY:
					this.moveAwayFromPlayer();
					break;
				case gc.ROUTE_MOVE_FORWARD:
					this.moveForward();
					break;
				case gc.ROUTE_MOVE_BACKWARD:
					this.moveBackward();
					break;
				case gc.ROUTE_JUMP:
					this.jump(params[0], params[1]);
					break;
				case gc.ROUTE_WAIT:
					this._waitCount = params[0] - 1;
					break;
				case gc.ROUTE_TURN_DOWN:
					this.setDirection(2);
					break;
				case gc.ROUTE_TURN_LEFT:
					this.setDirection(4);
					break;
				case gc.ROUTE_TURN_RIGHT:
					this.setDirection(6);
					break;
				case gc.ROUTE_TURN_UP:
					this.setDirection(8);
					break;
				case gc.ROUTE_TURN_90D_R:
					this.turnRight90();
					break;
				case gc.ROUTE_TURN_90D_L:
					this.turnLeft90();
					break;
				case gc.ROUTE_TURN_180D:
					this.turn180();
					break;
				case gc.ROUTE_TURN_90D_R_L:
					this.turnRightOrLeft90();
					break;
				case gc.ROUTE_TURN_RANDOM:
					this.turnRandom();
					break;
				case gc.ROUTE_TURN_TOWARD:
					this.turnTowardPlayer();
					break;
				case gc.ROUTE_TURN_AWAY:
					this.turnAwayFromPlayer();
					break;
				case gc.ROUTE_SWITCH_ON:
					self.$gameSwitches.setValue(params[0], !0);
					break;
				case gc.ROUTE_SWITCH_OFF:
					self.$gameSwitches.setValue(params[0], !1);
					break;
				case gc.ROUTE_CHANGE_SPEED:
					this.setMoveSpeed(params[0]);
					break;
				case gc.ROUTE_CHANGE_FREQ:
					this.setMoveFrequency(params[0]);
					break;
				case gc.ROUTE_WALK_ANIME_ON:
					this.setWalkAnime(!0);
					break;
				case gc.ROUTE_WALK_ANIME_OFF:
					this.setWalkAnime(!1);
					break;
				case gc.ROUTE_STEP_ANIME_ON:
					this.setStepAnime(!0);
					break;
				case gc.ROUTE_STEP_ANIME_OFF:
					this.setStepAnime(!1);
					break;
				case gc.ROUTE_DIR_FIX_ON:
					this.setDirectionFix(!0);
					break;
				case gc.ROUTE_DIR_FIX_OFF:
					this.setDirectionFix(!1);
					break;
				case gc.ROUTE_THROUGH_ON:
					this.setThrough(!0);
					break;
				case gc.ROUTE_THROUGH_OFF:
					this.setThrough(!1);
					break;
				case gc.ROUTE_TRANSPARENT_ON:
					this.setTransparent(!0);
					break;
				case gc.ROUTE_TRANSPARENT_OFF:
					this.setTransparent(!1);
					break;
				case gc.ROUTE_CHANGE_IMAGE:
					this.setImage(params[0], params[1]);
					break;
				case gc.ROUTE_CHANGE_OPACITY:
					this.setOpacity(params[0]);
					break;
				case gc.ROUTE_CHANGE_BLEND_MODE:
					this.setBlendMode(params[0]);
					break;
				case gc.ROUTE_PLAY_SE:
					AudioManager.playSe(params[0]);
					break;
				case gc.ROUTE_SCRIPT:
					try {
						eval(params[0]);
					} catch (t) {
						if (this._callerEventInfo) {
							for (let e in this._callerEventInfo)
								t[e] = this._callerEventInfo[e];
							(t.line += this._moveRouteIndex + 1),
								(t.eventCommand = 'set_route_script'),
								(t.content = command.parameters[0]);
						} else
							(t.eventType = 'map_event'),
								(t.mapId = this._mapId),
								(t.mapEventId = this._eventId),
								(t.page = this._pageIndex + 1),
								(t.line = this._moveRouteIndex + 1),
								(t.eventCommand = 'auto_route_script'),
								(t.content = command.parameters[0]);
						throw t;
					}
			}
		}
		deltaXFrom(t) {
			return self.$gameMap.deltaX(this.x, t);
		}
		deltaYFrom(t) {
			return self.$gameMap.deltaY(this.y, t);
		}
		moveRandom() {
			const t = 2 + 2 * Math.randomInt(4);
			this.canPass(this.x, this.y, t) && this.moveStraight(t);
		}
		moveTowardCharacter({ x: t, y: e }) {
			const i = this.deltaXFrom(t),
				r = this.deltaYFrom(e);
			Math.abs(i) > Math.abs(r)
				? (this.moveStraight(i > 0 ? 4 : 6),
				  this.isMovementSucceeded() ||
						0 === r ||
						this.moveStraight(r > 0 ? 8 : 2))
				: 0 !== r &&
				  (this.moveStraight(r > 0 ? 8 : 2),
				  this.isMovementSucceeded() ||
						0 === i ||
						this.moveStraight(i > 0 ? 4 : 6));
		}
		moveAwayFromCharacter({ x: t, y: e }) {
			const i = this.deltaXFrom(t),
				r = this.deltaYFrom(e);
			Math.abs(i) > Math.abs(r)
				? (this.moveStraight(i > 0 ? 6 : 4),
				  this.isMovementSucceeded() ||
						0 === r ||
						this.moveStraight(r > 0 ? 2 : 8))
				: 0 !== r &&
				  (this.moveStraight(r > 0 ? 2 : 8),
				  this.isMovementSucceeded() ||
						0 === i ||
						this.moveStraight(i > 0 ? 6 : 4));
		}
		turnTowardCharacter({ x: t, y: e }) {
			const i = this.deltaXFrom(t),
				r = this.deltaYFrom(e);
			Math.abs(i) > Math.abs(r)
				? this.setDirection(i > 0 ? 4 : 6)
				: 0 !== r && this.setDirection(r > 0 ? 8 : 2);
		}
		turnAwayFromCharacter({ x: t, y: e }) {
			const i = this.deltaXFrom(t),
				r = this.deltaYFrom(e);
			Math.abs(i) > Math.abs(r)
				? this.setDirection(i > 0 ? 6 : 4)
				: 0 !== r && this.setDirection(r > 0 ? 2 : 8);
		}
		turnTowardPlayer() {
			this.turnTowardCharacter(self.$gamePlayer);
		}
		turnAwayFromPlayer() {
			this.turnAwayFromCharacter(self.$gamePlayer);
		}
		moveTowardPlayer() {
			this.moveTowardCharacter(self.$gamePlayer);
		}
		moveAwayFromPlayer() {
			this.moveAwayFromCharacter(self.$gamePlayer);
		}
		moveForward() {
			this.moveStraight(this.direction());
		}
		moveBackward() {
			const t = this.isDirectionFixed();
			this.setDirectionFix(!0),
				this.moveStraight(this.reverseDir(this.direction())),
				this.setDirectionFix(t);
		}
		processRouteEnd() {
			this._moveRoute.repeat
				? (this._moveRouteIndex = -1)
				: this._moveRouteForcing &&
				  ((this._moveRouteForcing = !1), this.restoreMoveRoute());
		}
		advanceMoveRouteIndex() {
			const t = this._moveRoute;
			if (t && (this.isMovementSucceeded() || t.skippable)) {
				const e = t.list.length - 1;
				this._moveRouteIndex++,
					t.repeat && this._moveRouteIndex >= e && (this._moveRouteIndex = 0);
			}
		}
		turnRight90() {
			switch (this.direction()) {
				case 2:
					this.setDirection(4);
					break;
				case 4:
					this.setDirection(8);
					break;
				case 6:
					this.setDirection(2);
					break;
				case 8:
					this.setDirection(6);
			}
		}
		turnLeft90() {
			switch (this.direction()) {
				case 2:
					this.setDirection(6);
					break;
				case 4:
					this.setDirection(2);
					break;
				case 6:
					this.setDirection(8);
					break;
				case 8:
					this.setDirection(4);
			}
		}
		turn180() {
			this.setDirection(this.reverseDir(this.direction()));
		}
		turnRightOrLeft90() {
			switch (Math.randomInt(2)) {
				case 0:
					this.turnRight90();
					break;
				case 1:
					this.turnLeft90();
			}
		}
		turnRandom() {
			this.setDirection(2 + 2 * Math.randomInt(4));
		}
		swap(t) {
			const e = t.x,
				i = t.y;
			t.locate(this.x, this.y), this.locate(e, i);
		}
		findDirectionTo(t, e) {
			const i = this.searchLimit(),
				r = self.$gameMap.width(),
				s = [],
				n = [],
				a = [],
				o = {};
			let h = o;
			if (this.x === t && this.y === e) return 0;
			for (
				o.parent = null,
					o.x = this.x,
					o.y = this.y,
					o.g = 0,
					o.f = self.$gameMap.distance(o.x, o.y, t, e),
					s.push(o),
					n.push(o.y * r + o.x);
				s.length > 0;

			) {
				let o = 0;
				for (let t = 0; t < s.length; t++) s[t].f < s[o].f && (o = t);
				const u = s[o],
					l = u.x,
					c = u.y,
					d = c * r + l,
					p = u.g;
				if (
					(s.splice(o, 1),
					n.splice(n.indexOf(d), 1),
					a.push(d),
					u.x === t && u.y === e)
				) {
					h = u;
					break;
				}
				if (!(p >= i))
					for (let i = 0; i < 4; i++) {
						const o = 2 + 2 * i,
							d = self.$gameMap.roundXWithDirection(l, o),
							f = self.$gameMap.roundYWithDirection(c, o),
							m = f * r + d;
						if (a.contains(m)) continue;
						if (!this.canPass(l, c, o)) continue;
						const _ = p + 1,
							g = n.indexOf(m);
						if (g < 0 || _ < s[g].g) {
							let i;
							g >= 0 ? (i = s[g]) : ((i = {}), s.push(i), n.push(m)),
								(i.parent = u),
								(i.x = d),
								(i.y = f),
								(i.g = _),
								(i.f = _ + self.$gameMap.distance(d, f, t, e)),
								(!h || i.f - i.g < h.f - h.g) && (h = i);
						}
					}
			}
			let u = h;
			for (; u.parent && u.parent !== o; ) u = u.parent;
			const l = self.$gameMap.deltaX(u.x, o.x),
				c = self.$gameMap.deltaY(u.y, o.y);
			if (c > 0) return 2;
			if (l < 0) return 4;
			if (l > 0) return 6;
			if (c < 0) return 8;
			const d = this.deltaXFrom(t),
				p = this.deltaYFrom(e);
			return Math.abs(d) > Math.abs(p)
				? d > 0
					? 4
					: 6
				: 0 !== p
				? p > 0
					? 8
					: 2
				: 0;
		}
		searchLimit() {
			return 12;
		}
	}
	(Game_Character.ROUTE_END = 0),
		(Game_Character.ROUTE_MOVE_DOWN = 1),
		(Game_Character.ROUTE_MOVE_LEFT = 2),
		(Game_Character.ROUTE_MOVE_RIGHT = 3),
		(Game_Character.ROUTE_MOVE_UP = 4),
		(Game_Character.ROUTE_MOVE_LOWER_L = 5),
		(Game_Character.ROUTE_MOVE_LOWER_R = 6),
		(Game_Character.ROUTE_MOVE_UPPER_L = 7),
		(Game_Character.ROUTE_MOVE_UPPER_R = 8),
		(Game_Character.ROUTE_MOVE_RANDOM = 9),
		(Game_Character.ROUTE_MOVE_TOWARD = 10),
		(Game_Character.ROUTE_MOVE_AWAY = 11),
		(Game_Character.ROUTE_MOVE_FORWARD = 12),
		(Game_Character.ROUTE_MOVE_BACKWARD = 13),
		(Game_Character.ROUTE_JUMP = 14),
		(Game_Character.ROUTE_WAIT = 15),
		(Game_Character.ROUTE_TURN_DOWN = 16),
		(Game_Character.ROUTE_TURN_LEFT = 17),
		(Game_Character.ROUTE_TURN_RIGHT = 18),
		(Game_Character.ROUTE_TURN_UP = 19),
		(Game_Character.ROUTE_TURN_90D_R = 20),
		(Game_Character.ROUTE_TURN_90D_L = 21),
		(Game_Character.ROUTE_TURN_180D = 22),
		(Game_Character.ROUTE_TURN_90D_R_L = 23),
		(Game_Character.ROUTE_TURN_RANDOM = 24),
		(Game_Character.ROUTE_TURN_TOWARD = 25),
		(Game_Character.ROUTE_TURN_AWAY = 26),
		(Game_Character.ROUTE_SWITCH_ON = 27),
		(Game_Character.ROUTE_SWITCH_OFF = 28),
		(Game_Character.ROUTE_CHANGE_SPEED = 29),
		(Game_Character.ROUTE_CHANGE_FREQ = 30),
		(Game_Character.ROUTE_WALK_ANIME_ON = 31),
		(Game_Character.ROUTE_WALK_ANIME_OFF = 32),
		(Game_Character.ROUTE_STEP_ANIME_ON = 33),
		(Game_Character.ROUTE_STEP_ANIME_OFF = 34),
		(Game_Character.ROUTE_DIR_FIX_ON = 35),
		(Game_Character.ROUTE_DIR_FIX_OFF = 36),
		(Game_Character.ROUTE_THROUGH_ON = 37),
		(Game_Character.ROUTE_THROUGH_OFF = 38),
		(Game_Character.ROUTE_TRANSPARENT_ON = 39),
		(Game_Character.ROUTE_TRANSPARENT_OFF = 40),
		(Game_Character.ROUTE_CHANGE_IMAGE = 41),
		(Game_Character.ROUTE_CHANGE_OPACITY = 42),
		(Game_Character.ROUTE_CHANGE_BLEND_MODE = 43),
		(Game_Character.ROUTE_PLAY_SE = 44),
		(Game_Character.ROUTE_SCRIPT = 45);
	class Window_ShopCommand extends Window_HorzCommand {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e) {
			(this._windowWidth = t), (this._purchaseOnly = e), super.initialize(0, 0);
		}
		windowWidth() {
			return this._windowWidth;
		}
		maxCols() {
			return 3;
		}
		makeCommandList() {
			this.addCommand(TextManager.buy, 'buy'),
				this.addCommand(TextManager.sell, 'sell', !this._purchaseOnly),
				this.addCommand(TextManager.cancel, 'cancel');
		}
	}
	class Window_ShopBuy extends Window_Selectable {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e, i, r) {
			const s = this.windowWidth();
			super.initialize(t, e, s, i),
				(this._shopGoods = r),
				(this._money = 0),
				this.refresh(),
				this.select(0);
		}
		windowWidth() {
			return 456;
		}
		maxItems() {
			return this._data ? this._data.length : 1;
		}
		item() {
			return this._data[this.index()];
		}
		setMoney(t) {
			(this._money = t), this.refresh();
		}
		isCurrentItemEnabled() {
			return this.isEnabled(this._data[this.index()]);
		}
		price(t) {
			return this._price[this._data.indexOf(t)] || 0;
		}
		isEnabled(t) {
			return (
				t && this.price(t) <= this._money && !self.$gameParty.hasMaxItems(t)
			);
		}
		refresh() {
			this.makeItemList(), this.createContents(), this.drawAllItems();
		}
		makeItemList() {
			(this._data = []),
				(this._price = []),
				this._shopGoods.forEach(function (t) {
					let e = null;
					switch (t[0]) {
						case 0:
							e = self.$dataItems[t[1]];
							break;
						case 1:
							e = self.$dataWeapons[t[1]];
							break;
						case 2:
							e = self.$dataArmors[t[1]];
					}
					e &&
						(this._data.push(e), this._price.push(0 === t[2] ? e.price : t[3]));
				}, this);
		}
		drawItem(t) {
			const e = this._data[t],
				i = this.itemRect(t);
			(i.width -= this.textPadding()),
				this.changePaintOpacity(this.isEnabled(e)),
				this.drawItemName(e, i.x, i.y, i.width - 96),
				this.drawText(this.price(e), i.x + i.width - 96, i.y, 96, 'right'),
				this.changePaintOpacity(!0);
		}
		setStatusWindow(t) {
			(this._statusWindow = t), this.callUpdateHelp();
		}
		updateHelp() {
			this.setHelpWindowItem(this.item()),
				this._statusWindow && this._statusWindow.setItem(this.item());
		}
	}
	class Window_ShopSell extends Window_ItemList {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e, i, r) {
			super.initialize(t, e, i, r);
		}
		isEnabled(t) {
			return t && t.price > 0;
		}
	}
	class Window_ShopNumber extends Window_Selectable {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e, i) {
			const r = this.windowWidth();
			super.initialize(t, e, r, i),
				(this._item = null),
				(this._max = 1),
				(this._price = 0),
				(this._number = 1),
				(this._currencyUnit = TextManager.currencyUnit),
				this.createButtons();
		}
		windowWidth() {
			return 456;
		}
		number() {
			return this._number;
		}
		setup(t, e, i) {
			(this._item = t),
				(this._max = Math.floor(e)),
				(this._price = i),
				(this._number = 1),
				this.placeButtons(),
				this.updateButtonsVisiblity(),
				this.refresh();
		}
		setCurrencyUnit(t) {
			(this._currencyUnit = t), this.refresh();
		}
		createButtons() {
			const t = ImageManager.loadSystem('ButtonSet');
			this._buttons = [];
			for (let e = 0; e < 5; e++) {
				const i = new Sprite_Button(),
					r = 48 * e,
					s = 48 * (4 === e ? 2 : 1);
				(i.bitmap = t),
					i.setColdFrame(r, 0, s, 48),
					i.setHotFrame(r, 48, s, 48),
					(i.visible = !1),
					this._buttons.push(i),
					this.addChild(i);
			}
			this._buttons[0].setClickHandler(this.onButtonDown2.bind(this)),
				this._buttons[1].setClickHandler(this.onButtonDown.bind(this)),
				this._buttons[2].setClickHandler(this.onButtonUp.bind(this)),
				this._buttons[3].setClickHandler(this.onButtonUp2.bind(this)),
				this._buttons[4].setClickHandler(this.onButtonOk.bind(this));
		}
		placeButtons() {
			const t = this._buttons.length;
			let e = -16;
			for (let i = 0; i < t; i++) e += this._buttons[i].width + 16;
			let i = (this.width - e) / 2;
			for (let e = 0; e < t; e++) {
				const t = this._buttons[e];
				(t.x = i), (t.y = this.buttonY()), (i += t.width + 16);
			}
		}
		updateButtonsVisiblity() {
			TouchInput.date > Input.date ? this.showButtons() : this.hideButtons();
		}
		showButtons() {
			for (let t = 0; t < this._buttons.length; t++)
				this._buttons[t].visible = !0;
		}
		hideButtons() {
			for (let t = 0; t < this._buttons.length; t++)
				this._buttons[t].visible = !1;
		}
		refresh() {
			this.contents.clear(),
				this.drawItemName(this._item, 0, this.itemY()),
				this.drawMultiplicationSign(),
				this.drawNumber(),
				this.drawTotalPrice();
		}
		drawMultiplicationSign() {
			const t = this.textWidth('×'),
				e = this.cursorX() - 2 * t,
				i = this.itemY();
			this.resetTextColor(), this.drawText('×', e, i, t);
		}
		drawNumber() {
			const t = this.cursorX(),
				e = this.itemY(),
				i = this.cursorWidth() - this.textPadding();
			this.resetTextColor(), this.drawText(this._number, t, e, i, 'right');
		}
		drawTotalPrice() {
			const t = this._price * this._number,
				e = this.contentsWidth() - this.textPadding();
			this.drawCurrencyValue(t, this._currencyUnit, 0, this.priceY(), e);
		}
		itemY() {
			return Math.round(this.contentsHeight() / 2 - 1.5 * this.lineHeight());
		}
		priceY() {
			return Math.round(this.contentsHeight() / 2 + this.lineHeight() / 2);
		}
		buttonY() {
			return Math.round(this.priceY() + 2.5 * this.lineHeight());
		}
		cursorWidth() {
			const t = this.textWidth('0');
			return this.maxDigits() * t + 2 * this.textPadding();
		}
		cursorX() {
			return this.contentsWidth() - this.cursorWidth() - this.textPadding();
		}
		maxDigits() {
			return 2;
		}
		update() {
			super.update(), this.processNumberChange();
		}
		isOkTriggered() {
			return Input.isTriggered('ok');
		}
		playOkSound() {}
		processNumberChange() {
			this.isOpenAndActive() &&
				(Input.isRepeated('right') && this.changeNumber(1),
				Input.isRepeated('left') && this.changeNumber(-1),
				Input.isRepeated('up') && this.changeNumber(10),
				Input.isRepeated('down') && this.changeNumber(-10));
		}
		changeNumber(t) {
			const e = this._number;
			(this._number = (this._number + t).clamp(1, this._max)),
				this._number !== e && (SoundManager.playCursor(), this.refresh());
		}
		updateCursor() {
			this.setCursorRect(
				this.cursorX(),
				this.itemY(),
				this.cursorWidth(),
				this.lineHeight()
			);
		}
		onButtonUp() {
			this.changeNumber(1);
		}
		onButtonUp2() {
			this.changeNumber(10);
		}
		onButtonDown() {
			this.changeNumber(-1);
		}
		onButtonDown2() {
			this.changeNumber(-10);
		}
		onButtonOk() {
			this.processOk();
		}
	}
	class Window_ShopStatus extends Window_Base {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e, i, r) {
			super.initialize(t, e, i, r),
				(this._item = null),
				(this._pageIndex = 0),
				this.refresh();
		}
		refresh() {
			if ((this.contents.clear(), this._item)) {
				const t = this.textPadding();
				this.drawPossession(t, 0),
					this.isEquipItem() && this.drawEquipInfo(t, 2 * this.lineHeight());
			}
		}
		setItem(t) {
			(this._item = t), this.refresh();
		}
		isEquipItem() {
			return (
				DataManager$1.isWeapon(this._item) || DataManager$1.isArmor(this._item)
			);
		}
		drawPossession(t, e) {
			const i = this.contents.width - this.textPadding() - t,
				r = this.textWidth('0000');
			this.changeTextColor(this.systemColor()),
				this.drawText(TextManager.possession, t, e, i - r),
				this.resetTextColor(),
				this.drawText(self.$gameParty.numItems(this._item), t, e, i, 'right');
		}
		drawEquipInfo(t, e) {
			const i = this.statusMembers();
			for (let r = 0; r < i.length; r++)
				this.drawActorEquipInfo(t, e + this.lineHeight() * (2.4 * r), i[r]);
		}
		statusMembers() {
			const t = this._pageIndex * this.pageSize(),
				e = t + this.pageSize();
			return self.$gameParty.members().slice(t, e);
		}
		pageSize() {
			return 4;
		}
		maxPages() {
			return Math.floor(
				(self.$gameParty.size() + this.pageSize() - 1) / this.pageSize()
			);
		}
		drawActorEquipInfo(t, e, i) {
			const r = i.canEquip(this._item);
			this.changePaintOpacity(r),
				this.resetTextColor(),
				this.drawText(i.name(), t, e, 168);
			const s = this.currentEquippedItem(i, this._item.etypeId);
			r && this.drawActorParamChange(t, e, i, s),
				this.drawItemName(s, t, e + this.lineHeight()),
				this.changePaintOpacity(!0);
		}
		drawActorParamChange(t, e, i, r) {
			const s = this.contents.width - this.textPadding() - t,
				n = this.paramId(),
				a = this._item.params[n] - (r ? r.params[n] : 0);
			this.changeTextColor(this.paramchangeTextColor(a)),
				this.drawText((a > 0 ? '+' : '') + a, t, e, s, 'right');
		}
		paramId() {
			return DataManager$1.isWeapon(this._item) ? 2 : 3;
		}
		currentEquippedItem(t, e) {
			const i = [],
				r = t.equips(),
				s = t.equipSlots();
			for (let t = 0; t < s.length; t++) s[t] === e && i.push(r[t]);
			const n = this.paramId();
			let a = Number.MAX_VALUE,
				o = null;
			for (let t = 0; t < i.length; t++)
				i[t] && i[t].params[n] < a && ((a = i[t].params[n]), (o = i[t]));
			return o;
		}
		update() {
			super.update(), this.updatePage();
		}
		updatePage() {
			this.isPageChangeEnabled() &&
				this.isPageChangeRequested() &&
				this.changePage();
		}
		isPageChangeEnabled() {
			return this.visible && this.maxPages() >= 2;
		}
		isPageChangeRequested() {
			return (
				!!Input.isTriggered('shift') ||
				!(!TouchInput.isTriggered() || !this.isTouchedInsideFrame())
			);
		}
		isTouchedInsideFrame() {
			const t = this.canvasToLocalX(TouchInput.x),
				e = this.canvasToLocalY(TouchInput.y);
			return t >= 0 && e >= 0 && t < this.width && e < this.height;
		}
		changePage() {
			(this._pageIndex = (this._pageIndex + 1) % this.maxPages()),
				this.refresh(),
				SoundManager.playCursor();
		}
	}
	class Scene_Shop extends Scene_MenuBase {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize();
		}
		prepare(t, e) {
			(this._goods = t), (this._purchaseOnly = e), (this._item = null);
		}
		create() {
			super.create(),
				this.createHelpWindow(),
				this.createGoldWindow(),
				this.createCommandWindow(),
				this.createDummyWindow(),
				this.createNumberWindow(),
				this.createStatusWindow(),
				this.createBuyWindow(),
				this.createCategoryWindow(),
				this.createSellWindow();
		}
		createGoldWindow() {
			(this._goldWindow = new Window_Gold(0, this._helpWindow.height)),
				(this._goldWindow.x = Graphics.boxWidth - this._goldWindow.width),
				this.addWindow(this._goldWindow);
		}
		createCommandWindow() {
			(this._commandWindow = new Window_ShopCommand(
				this._goldWindow.x,
				this._purchaseOnly
			)),
				(this._commandWindow.y = this._helpWindow.height),
				this._commandWindow.setHandler('buy', this.commandBuy.bind(this)),
				this._commandWindow.setHandler('sell', this.commandSell.bind(this)),
				this._commandWindow.setHandler('cancel', this.popScene.bind(this)),
				this.addWindow(this._commandWindow);
		}
		createDummyWindow() {
			const t = this._commandWindow.y + this._commandWindow.height,
				e = Graphics.boxHeight - t;
			(this._dummyWindow = new Window_Base(0, t, Graphics.boxWidth, e)),
				this.addWindow(this._dummyWindow);
		}
		createNumberWindow() {
			const t = this._dummyWindow.y,
				e = this._dummyWindow.height;
			(this._numberWindow = new Window_ShopNumber(0, t, e)),
				this._numberWindow.hide(),
				this._numberWindow.setHandler('ok', this.onNumberOk.bind(this)),
				this._numberWindow.setHandler('cancel', this.onNumberCancel.bind(this)),
				this.addWindow(this._numberWindow);
		}
		createStatusWindow() {
			const t = this._numberWindow.width,
				e = this._dummyWindow.y,
				i = Graphics.boxWidth - t,
				r = this._dummyWindow.height;
			(this._statusWindow = new Window_ShopStatus(t, e, i, r)),
				this._statusWindow.hide(),
				this.addWindow(this._statusWindow);
		}
		createBuyWindow() {
			const t = this._dummyWindow.y,
				e = this._dummyWindow.height;
			(this._buyWindow = new Window_ShopBuy(0, t, e, this._goods)),
				this._buyWindow.setHelpWindow(this._helpWindow),
				this._buyWindow.setStatusWindow(this._statusWindow),
				this._buyWindow.hide(),
				this._buyWindow.setHandler('ok', this.onBuyOk.bind(this)),
				this._buyWindow.setHandler('cancel', this.onBuyCancel.bind(this)),
				this.addWindow(this._buyWindow);
		}
		createCategoryWindow() {
			(this._categoryWindow = new Window_ItemCategory()),
				this._categoryWindow.setHelpWindow(this._helpWindow),
				(this._categoryWindow.y = this._dummyWindow.y),
				this._categoryWindow.hide(),
				this._categoryWindow.deactivate(),
				this._categoryWindow.setHandler('ok', this.onCategoryOk.bind(this)),
				this._categoryWindow.setHandler(
					'cancel',
					this.onCategoryCancel.bind(this)
				),
				this.addWindow(this._categoryWindow);
		}
		createSellWindow() {
			const t = this._categoryWindow.y + this._categoryWindow.height,
				e = Graphics.boxHeight - t;
			(this._sellWindow = new Window_ShopSell(0, t, Graphics.boxWidth, e)),
				this._sellWindow.setHelpWindow(this._helpWindow),
				this._sellWindow.hide(),
				this._sellWindow.setHandler('ok', this.onSellOk.bind(this)),
				this._sellWindow.setHandler('cancel', this.onSellCancel.bind(this)),
				this._categoryWindow.setItemWindow(this._sellWindow),
				this.addWindow(this._sellWindow);
		}
		activateBuyWindow() {
			this._buyWindow.setMoney(this.money()),
				this._buyWindow.show(),
				this._buyWindow.activate(),
				this._statusWindow.show();
		}
		activateSellWindow() {
			this._categoryWindow.show(),
				this._sellWindow.refresh(),
				this._sellWindow.show(),
				this._sellWindow.activate(),
				this._statusWindow.hide();
		}
		commandBuy() {
			this._dummyWindow.hide(), this.activateBuyWindow();
		}
		commandSell() {
			this._dummyWindow.hide(),
				this._categoryWindow.show(),
				this._categoryWindow.activate(),
				this._sellWindow.show(),
				this._sellWindow.deselect(),
				this._sellWindow.refresh();
		}
		onBuyOk() {
			(this._item = this._buyWindow.item()),
				this._buyWindow.hide(),
				this._numberWindow.setup(this._item, this.maxBuy(), this.buyingPrice()),
				this._numberWindow.setCurrencyUnit(this.currencyUnit()),
				this._numberWindow.show(),
				this._numberWindow.activate();
		}
		onBuyCancel() {
			this._commandWindow.activate(),
				this._dummyWindow.show(),
				this._buyWindow.hide(),
				this._statusWindow.hide(),
				this._statusWindow.setItem(null),
				this._helpWindow.clear();
		}
		onCategoryOk() {
			this.activateSellWindow(), this._sellWindow.select(0);
		}
		onCategoryCancel() {
			this._commandWindow.activate(),
				this._dummyWindow.show(),
				this._categoryWindow.hide(),
				this._sellWindow.hide();
		}
		onSellOk() {
			(this._item = this._sellWindow.item()),
				this._categoryWindow.hide(),
				this._sellWindow.hide(),
				this._numberWindow.setup(
					this._item,
					this.maxSell(),
					this.sellingPrice()
				),
				this._numberWindow.setCurrencyUnit(this.currencyUnit()),
				this._numberWindow.show(),
				this._numberWindow.activate(),
				this._statusWindow.setItem(this._item),
				this._statusWindow.show();
		}
		onSellCancel() {
			this._sellWindow.deselect(),
				this._categoryWindow.activate(),
				this._statusWindow.setItem(null),
				this._helpWindow.clear();
		}
		onNumberOk() {
			switch ((SoundManager.playShop(), this._commandWindow.currentSymbol())) {
				case 'buy':
					this.doBuy(this._numberWindow.number());
					break;
				case 'sell':
					this.doSell(this._numberWindow.number());
			}
			this.endNumberInput(),
				this._goldWindow.refresh(),
				this._statusWindow.refresh();
		}
		onNumberCancel() {
			SoundManager.playCancel(), this.endNumberInput();
		}
		doBuy(t) {
			self.$gameParty.loseGold(t * this.buyingPrice()),
				self.$gameParty.gainItem(this._item, t);
		}
		doSell(t) {
			self.$gameParty.gainGold(t * this.sellingPrice()),
				self.$gameParty.loseItem(this._item, t);
		}
		endNumberInput() {
			switch (
				(this._numberWindow.hide(), this._commandWindow.currentSymbol())
			) {
				case 'buy':
					this.activateBuyWindow();
					break;
				case 'sell':
					this.activateSellWindow();
			}
		}
		maxBuy() {
			const t =
					self.$gameParty.maxItems(this._item) -
					self.$gameParty.numItems(this._item),
				e = this.buyingPrice();
			return e > 0 ? Math.min(t, Math.floor(this.money() / e)) : t;
		}
		maxSell() {
			return self.$gameParty.numItems(this._item);
		}
		money() {
			return this._goldWindow.value();
		}
		currencyUnit() {
			return this._goldWindow.currencyUnit();
		}
		buyingPrice() {
			return this._buyWindow.price(this._item);
		}
		sellingPrice() {
			return Math.floor(this._item.price / 2);
		}
	}
	class Window_NameEdit extends Window_Base {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e) {
			const i = this.windowWidth(),
				r = this.windowHeight(),
				s = (Graphics.boxWidth - i) / 2,
				n = (Graphics.boxHeight - (r + this.fittingHeight(9) + 8)) / 2;
			super.initialize(s, n, i, r),
				(this._actor = t),
				(this._name = t.name().slice(0, this._maxLength)),
				(this._index = this._name.length),
				(this._maxLength = e),
				(this._defaultName = this._name),
				this.deactivate(),
				this.refresh(),
				ImageManager.reserveFace(t.faceName());
		}
		windowWidth() {
			return 480;
		}
		windowHeight() {
			return this.fittingHeight(4);
		}
		name() {
			return this._name;
		}
		restoreDefault() {
			return (
				(this._name = this._defaultName),
				(this._index = this._name.length),
				this.refresh(),
				this._name.length > 0
			);
		}
		add(t) {
			return (
				this._index < this._maxLength &&
				((this._name += t), this._index++, this.refresh(), !0)
			);
		}
		back() {
			return (
				this._index > 0 &&
				(this._index--,
				(this._name = this._name.slice(0, this._index)),
				this.refresh(),
				!0)
			);
		}
		faceWidth() {
			return 144;
		}
		charWidth() {
			const t = self.$gameSystem.isJapanese() ? 'Ａ' : 'A';
			return this.textWidth(t);
		}
		left() {
			const t = (this.contentsWidth() + this.faceWidth()) / 2,
				e = (this._maxLength + 1) * this.charWidth();
			return Math.min(t - e / 2, this.contentsWidth() - e);
		}
		itemRect(t) {
			return {
				x: this.left() + t * this.charWidth(),
				y: 54,
				width: this.charWidth(),
				height: this.lineHeight(),
			};
		}
		underlineRect(t) {
			const e = this.itemRect(t);
			return e.x++, (e.y += e.height - 4), (e.width -= 2), (e.height = 2), e;
		}
		underlineColor() {
			return this.normalColor();
		}
		drawUnderline(t) {
			const e = this.underlineRect(t),
				i = this.underlineColor();
			(this.contents.paintOpacity = 48),
				this.contents.fillRect(e.x, e.y, e.width, e.height, i),
				(this.contents.paintOpacity = 255);
		}
		drawChar(t) {
			const e = this.itemRect(t);
			this.resetTextColor(), this.drawText(this._name[t] || '', e.x, e.y);
		}
		refresh() {
			this.contents.clear(), this.drawActorFace(this._actor, 0, 0);
			for (let t = 0; t < this._maxLength; t++) this.drawUnderline(t);
			for (let t = 0; t < this._name.length; t++) this.drawChar(t);
			const t = this.itemRect(this._index);
			this.setCursorRect(t.x, t.y, t.width, t.height);
		}
	}
	class Window_NameInput extends Window_Selectable {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t) {
			const e = t.x,
				i = t.y + t.height + 8,
				r = t.width,
				s = this.windowHeight();
			super.initialize(e, i, r, s),
				(this._editWindow = t),
				(this._page = 0),
				(this._index = 0),
				this.refresh(),
				this.updateCursor(),
				this.activate();
		}
		windowHeight() {
			return this.fittingHeight(9);
		}
		table() {
			return self.$gameSystem.isJapanese()
				? [
						Window_NameInput.JAPAN1,
						Window_NameInput.JAPAN2,
						Window_NameInput.JAPAN3,
				  ]
				: self.$gameSystem.isRussian()
				? [Window_NameInput.RUSSIA]
				: [Window_NameInput.LATIN1, Window_NameInput.LATIN2];
		}
		maxCols() {
			return 10;
		}
		maxItems() {
			return 90;
		}
		character() {
			return this._index < 88 ? this.table()[this._page][this._index] : '';
		}
		isPageChange() {
			return 88 === this._index;
		}
		isOk() {
			return 89 === this._index;
		}
		itemRect(t) {
			return {
				x: (t % 10) * 42 + 24 * Math.floor((t % 10) / 5),
				y: Math.floor(t / 10) * this.lineHeight(),
				width: 42,
				height: this.lineHeight(),
			};
		}
		refresh() {
			const t = this.table();
			this.contents.clear(), this.resetTextColor();
			for (let e = 0; e < 90; e++) {
				const i = this.itemRect(e);
				(i.x += 3),
					(i.width -= 6),
					this.drawText(t[this._page][e], i.x, i.y, i.width, 'center');
			}
		}
		updateCursor() {
			const t = this.itemRect(this._index);
			this.setCursorRect(t.x, t.y, t.width, t.height);
		}
		isCursorMovable() {
			return this.active;
		}
		cursorDown(t) {
			(this._index < 80 || t) && (this._index = (this._index + 10) % 90);
		}
		cursorUp(t) {
			(this._index >= 10 || t) && (this._index = (this._index + 80) % 90);
		}
		cursorRight(t) {
			this._index % 10 < 9 ? this._index++ : t && (this._index -= 9);
		}
		cursorLeft(t) {
			this._index % 10 > 0 ? this._index-- : t && (this._index += 9);
		}
		cursorPagedown() {
			(this._page = (this._page + 1) % this.table().length), this.refresh();
		}
		cursorPageup() {
			(this._page =
				(this._page + this.table().length - 1) % this.table().length),
				this.refresh();
		}
		processCursorMove() {
			const t = this._page;
			super.processCursorMove(),
				this.updateCursor(),
				this._page !== t && SoundManager.playCursor();
		}
		processHandling() {
			this.isOpen() &&
				this.active &&
				(Input.isTriggered('shift') && this.processJump(),
				Input.isRepeated('cancel') && this.processBack(),
				Input.isRepeated('ok') && this.processOk());
		}
		isCancelEnabled() {
			return !0;
		}
		processCancel() {
			this.processBack();
		}
		processJump() {
			89 !== this._index && ((this._index = 89), SoundManager.playCursor());
		}
		processBack() {
			this._editWindow.back() && SoundManager.playCancel();
		}
		processOk() {
			this.character()
				? this.onNameAdd()
				: this.isPageChange()
				? (SoundManager.playOk(), this.cursorPagedown())
				: this.isOk() && this.onNameOk();
		}
		onNameAdd() {
			this._editWindow.add(this.character())
				? SoundManager.playOk()
				: SoundManager.playBuzzer();
		}
		onNameOk() {
			'' === this._editWindow.name()
				? this._editWindow.restoreDefault()
					? SoundManager.playOk()
					: SoundManager.playBuzzer()
				: (SoundManager.playOk(), this.callOkHandler());
		}
	}
	(Window_NameInput.LATIN1 = [
		'A',
		'B',
		'C',
		'D',
		'E',
		'a',
		'b',
		'c',
		'd',
		'e',
		'F',
		'G',
		'H',
		'I',
		'J',
		'f',
		'g',
		'h',
		'i',
		'j',
		'K',
		'L',
		'M',
		'N',
		'O',
		'k',
		'l',
		'm',
		'n',
		'o',
		'P',
		'Q',
		'R',
		'S',
		'T',
		'p',
		'q',
		'r',
		's',
		't',
		'U',
		'V',
		'W',
		'X',
		'Y',
		'u',
		'v',
		'w',
		'x',
		'y',
		'Z',
		'[',
		']',
		'^',
		'_',
		'z',
		'{',
		'}',
		'|',
		'~',
		'0',
		'1',
		'2',
		'3',
		'4',
		'!',
		'#',
		'$',
		'%',
		'&',
		'5',
		'6',
		'7',
		'8',
		'9',
		'(',
		')',
		'*',
		'+',
		'-',
		'/',
		'=',
		'@',
		'<',
		'>',
		':',
		';',
		' ',
		'Page',
		'OK',
	]),
		(Window_NameInput.LATIN2 = [
			'Á',
			'É',
			'Í',
			'Ó',
			'Ú',
			'á',
			'é',
			'í',
			'ó',
			'ú',
			'À',
			'È',
			'Ì',
			'Ò',
			'Ù',
			'à',
			'è',
			'ì',
			'ò',
			'ù',
			'Â',
			'Ê',
			'Î',
			'Ô',
			'Û',
			'â',
			'ê',
			'î',
			'ô',
			'û',
			'Ä',
			'Ë',
			'Ï',
			'Ö',
			'Ü',
			'ä',
			'ë',
			'ï',
			'ö',
			'ü',
			'Ā',
			'Ē',
			'Ī',
			'Ō',
			'Ū',
			'ā',
			'ē',
			'ī',
			'ō',
			'ū',
			'Ã',
			'Å',
			'Æ',
			'Ç',
			'Ð',
			'ã',
			'å',
			'æ',
			'ç',
			'ð',
			'Ñ',
			'Õ',
			'Ø',
			'Š',
			'Ŵ',
			'ñ',
			'õ',
			'ø',
			'š',
			'ŵ',
			'Ý',
			'Ŷ',
			'Ÿ',
			'Ž',
			'Þ',
			'ý',
			'ÿ',
			'ŷ',
			'ž',
			'þ',
			'Ĳ',
			'Œ',
			'ĳ',
			'œ',
			'ß',
			'«',
			'»',
			' ',
			'Page',
			'OK',
		]),
		(Window_NameInput.RUSSIA = [
			'А',
			'Б',
			'В',
			'Г',
			'Д',
			'а',
			'б',
			'в',
			'г',
			'д',
			'Е',
			'Ё',
			'Ж',
			'З',
			'И',
			'е',
			'ё',
			'ж',
			'з',
			'и',
			'Й',
			'К',
			'Л',
			'М',
			'Н',
			'й',
			'к',
			'л',
			'м',
			'н',
			'О',
			'П',
			'Р',
			'С',
			'Т',
			'о',
			'п',
			'р',
			'с',
			'т',
			'У',
			'Ф',
			'Х',
			'Ц',
			'Ч',
			'у',
			'ф',
			'х',
			'ц',
			'ч',
			'Ш',
			'Щ',
			'Ъ',
			'Ы',
			'Ь',
			'ш',
			'щ',
			'ъ',
			'ы',
			'ь',
			'Э',
			'Ю',
			'Я',
			'^',
			'_',
			'э',
			'ю',
			'я',
			'%',
			'&',
			'0',
			'1',
			'2',
			'3',
			'4',
			'(',
			')',
			'*',
			'+',
			'-',
			'5',
			'6',
			'7',
			'8',
			'9',
			':',
			';',
			' ',
			'',
			'OK',
		]),
		(Window_NameInput.JAPAN1 = [
			'あ',
			'い',
			'う',
			'え',
			'お',
			'が',
			'ぎ',
			'ぐ',
			'げ',
			'ご',
			'か',
			'き',
			'く',
			'け',
			'こ',
			'ざ',
			'じ',
			'ず',
			'ぜ',
			'ぞ',
			'さ',
			'し',
			'す',
			'せ',
			'そ',
			'だ',
			'ぢ',
			'づ',
			'で',
			'ど',
			'た',
			'ち',
			'つ',
			'て',
			'と',
			'ば',
			'び',
			'ぶ',
			'べ',
			'ぼ',
			'な',
			'に',
			'ぬ',
			'ね',
			'の',
			'ぱ',
			'ぴ',
			'ぷ',
			'ぺ',
			'ぽ',
			'は',
			'ひ',
			'ふ',
			'へ',
			'ほ',
			'ぁ',
			'ぃ',
			'ぅ',
			'ぇ',
			'ぉ',
			'ま',
			'み',
			'む',
			'め',
			'も',
			'っ',
			'ゃ',
			'ゅ',
			'ょ',
			'ゎ',
			'や',
			'ゆ',
			'よ',
			'わ',
			'ん',
			'ー',
			'～',
			'・',
			'＝',
			'☆',
			'ら',
			'り',
			'る',
			'れ',
			'ろ',
			'ゔ',
			'を',
			'　',
			'カナ',
			'決定',
		]),
		(Window_NameInput.JAPAN2 = [
			'ア',
			'イ',
			'ウ',
			'エ',
			'オ',
			'ガ',
			'ギ',
			'グ',
			'ゲ',
			'ゴ',
			'カ',
			'キ',
			'ク',
			'ケ',
			'コ',
			'ザ',
			'ジ',
			'ズ',
			'ゼ',
			'ゾ',
			'サ',
			'シ',
			'ス',
			'セ',
			'ソ',
			'ダ',
			'ヂ',
			'ヅ',
			'デ',
			'ド',
			'タ',
			'チ',
			'ツ',
			'テ',
			'ト',
			'バ',
			'ビ',
			'ブ',
			'ベ',
			'ボ',
			'ナ',
			'ニ',
			'ヌ',
			'ネ',
			'ノ',
			'パ',
			'ピ',
			'プ',
			'ペ',
			'ポ',
			'ハ',
			'ヒ',
			'フ',
			'ヘ',
			'ホ',
			'ァ',
			'ィ',
			'ゥ',
			'ェ',
			'ォ',
			'マ',
			'ミ',
			'ム',
			'メ',
			'モ',
			'ッ',
			'ャ',
			'ュ',
			'ョ',
			'ヮ',
			'ヤ',
			'ユ',
			'ヨ',
			'ワ',
			'ン',
			'ー',
			'～',
			'・',
			'＝',
			'☆',
			'ラ',
			'リ',
			'ル',
			'レ',
			'ロ',
			'ヴ',
			'ヲ',
			'　',
			'英数',
			'決定',
		]),
		(Window_NameInput.JAPAN3 = [
			'Ａ',
			'Ｂ',
			'Ｃ',
			'Ｄ',
			'Ｅ',
			'ａ',
			'ｂ',
			'ｃ',
			'ｄ',
			'ｅ',
			'Ｆ',
			'Ｇ',
			'Ｈ',
			'Ｉ',
			'Ｊ',
			'ｆ',
			'ｇ',
			'ｈ',
			'ｉ',
			'ｊ',
			'Ｋ',
			'Ｌ',
			'Ｍ',
			'Ｎ',
			'Ｏ',
			'ｋ',
			'ｌ',
			'ｍ',
			'ｎ',
			'ｏ',
			'Ｐ',
			'Ｑ',
			'Ｒ',
			'Ｓ',
			'Ｔ',
			'ｐ',
			'ｑ',
			'ｒ',
			'ｓ',
			'ｔ',
			'Ｕ',
			'Ｖ',
			'Ｗ',
			'Ｘ',
			'Ｙ',
			'ｕ',
			'ｖ',
			'ｗ',
			'ｘ',
			'ｙ',
			'Ｚ',
			'［',
			'］',
			'＾',
			'＿',
			'ｚ',
			'｛',
			'｝',
			'｜',
			'～',
			'０',
			'１',
			'２',
			'３',
			'４',
			'！',
			'＃',
			'＄',
			'％',
			'＆',
			'５',
			'６',
			'７',
			'８',
			'９',
			'（',
			'）',
			'＊',
			'＋',
			'－',
			'／',
			'＝',
			'＠',
			'＜',
			'＞',
			'：',
			'；',
			'　',
			'かな',
			'決定',
		]);
	class Scene_Name extends Scene_MenuBase {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize();
		}
		prepare(t, e) {
			(this._actorId = t), (this._maxLength = e);
		}
		create() {
			super.create(),
				(this._actor = self.$gameActors.actor(this._actorId)),
				this.createEditWindow(),
				this.createInputWindow();
		}
		start() {
			super.start(), this._editWindow.refresh();
		}
		createEditWindow() {
			(this._editWindow = new Window_NameEdit(this._actor, this._maxLength)),
				this.addWindow(this._editWindow);
		}
		createInputWindow() {
			(this._inputWindow = new Window_NameInput(this._editWindow)),
				this._inputWindow.setHandler('ok', this.onInputOk.bind(this)),
				this.addWindow(this._inputWindow);
		}
		onInputOk() {
			this._actor.setName(this._editWindow.name()), this.popScene();
		}
	}
	class Game_Interpreter {
		constructor(...t) {
			this.initialize(...t);
		}
		initialize(t) {
			(this._depth = t || 0),
				this.checkOverflow(),
				this.clear(),
				(this._branch = {}),
				(this._params = []),
				(this._indent = 0),
				(this._frameCount = 0),
				(this._freezeChecker = 0);
		}
		checkOverflow() {
			if (this._depth >= 100)
				throw new Error('Common event calls exceeded the limit');
		}
		clear() {
			(this._mapId = 0),
				(this._eventId = 0),
				(this._list = null),
				(this._index = 0),
				(this._waitCount = 0),
				(this._waitMode = ''),
				(this._comments = ''),
				(this._eventInfo = null),
				(this._character = null),
				(this._childInterpreter = null);
		}
		setup(t, e) {
			this.clear(),
				(this._mapId = self.$gameMap.mapId()),
				(this._eventId = e || 0),
				(this._list = t),
				Game_Interpreter.requestImages(t);
		}
		eventId() {
			return this._eventId;
		}
		isOnCurrentMap() {
			return this._mapId === self.$gameMap.mapId();
		}
		setEventInfo(t) {
			this._eventInfo = t;
		}
		setupReservedCommonEvent() {
			return (
				!!self.$gameTemp.isCommonEventReserved() &&
				(this.setup(self.$gameTemp.reservedCommonEvent().list),
				this.setEventInfo({
					eventType: 'common_event',
					commonEventId: self.$gameTemp.reservedCommonEventId(),
				}),
				self.$gameTemp.clearCommonEvent(),
				!0)
			);
		}
		isRunning() {
			return !!this._list;
		}
		update() {
			for (
				;
				this.isRunning() &&
				!this.updateChild() &&
				!this.updateWait() &&
				!SceneManager.isSceneChanging() &&
				this.executeCommand() &&
				!this.checkFreeze();

			);
		}
		updateChild() {
			if (this._childInterpreter) {
				if (
					(this._childInterpreter.update(), this._childInterpreter.isRunning())
				)
					return !0;
				this._childInterpreter = null;
			}
			return !1;
		}
		updateWait() {
			return this.updateWaitCount() || this.updateWaitMode();
		}
		updateWaitCount() {
			return this._waitCount > 0 && (this._waitCount--, !0);
		}
		updateWaitMode() {
			let t = !1;
			switch (this._waitMode) {
				case 'message':
					t = self.$gameMessage.isBusy();
					break;
				case 'transfer':
					t = self.$gamePlayer.isTransferring();
					break;
				case 'scroll':
					t = self.$gameMap.isScrolling();
					break;
				case 'route':
					t = this._character.isMoveRouteForcing();
					break;
				case 'animation':
					t = this._character.isAnimationPlaying();
					break;
				case 'balloon':
					t = this._character.isBalloonPlaying();
					break;
				case 'gather':
					t = self.$gamePlayer.areFollowersGathering();
					break;
				case 'action':
					t = BattleManager.isActionForced();
					break;
				case 'video':
					t = Graphics.isVideoPlaying();
					break;
				case 'image':
					t = !ImageManager.isReady();
			}
			return t || (this._waitMode = ''), t;
		}
		setWaitMode(t) {
			this._waitMode = t;
		}
		wait(t) {
			this._waitCount = t;
		}
		fadeSpeed() {
			return 24;
		}
		executeCommand() {
			const t = this.currentCommand();
			if (t) {
				(this._params = t.parameters), (this._indent = t.indent);
				const e = `command${t.code}`;
				if ('function' == typeof this[e])
					try {
						if (!this[e]()) return !1;
					} catch (t) {
						for (let e in this._eventInfo) t[e] = this._eventInfo[e];
						throw (
							((t.eventCommand = t.eventCommand || 'other'),
							(t.line = t.line || this._index + 1),
							t)
						);
					}
				this._index++;
			} else this.terminate();
			return !0;
		}
		checkFreeze() {
			return (
				this._frameCount !== Graphics.frameCount &&
					((this._frameCount = Graphics.frameCount), (this._freezeChecker = 0)),
				this._freezeChecker++ >= 1e5
			);
		}
		terminate() {
			(this._list = null), (this._comments = '');
		}
		skipBranch() {
			for (; this._list[this._index + 1].indent > this._indent; ) this._index++;
		}
		currentCommand() {
			return this._list[this._index];
		}
		nextEventCode() {
			const t = this._list[this._index + 1];
			return t ? t.code : 0;
		}
		iterateActorId(t, e) {
			if (0 === t) self.$gameParty.members().forEach(e);
			else {
				const i = self.$gameActors.actor(t);
				i && e(i);
			}
		}
		iterateActorEx(t, e, i) {
			0 === t
				? this.iterateActorId(e, i)
				: this.iterateActorId(self.$gameVariables.value(e), i);
		}
		iterateActorIndex(t, e) {
			if (t < 0) self.$gameParty.members().forEach(e);
			else {
				const i = self.$gameParty.members()[t];
				i && e(i);
			}
		}
		iterateEnemyIndex(t, e) {
			if (t < 0) self.$gameTroop.members().forEach(e);
			else {
				const i = self.$gameTroop.members()[t];
				i && e(i);
			}
		}
		iterateBattler(t, e, i) {
			self.$gameParty.inBattle() &&
				(0 === t ? this.iterateEnemyIndex(e, i) : this.iterateActorId(e, i));
		}
		character(t) {
			return self.$gameParty.inBattle()
				? null
				: t < 0
				? self.$gamePlayer
				: this.isOnCurrentMap()
				? self.$gameMap.event(t > 0 ? t : this._eventId)
				: null;
		}
		operateValue(t, e, i) {
			const r = 0 === e ? i : self.$gameVariables.value(i);
			return 0 === t ? r : -r;
		}
		changeHp(t, e, i) {
			t.isAlive() &&
				(!i && t.hp <= -e && (e = 1 - t.hp),
				t.gainHp(e),
				t.isDead() && t.performCollapse());
		}
		command101() {
			if (!self.$gameMessage.isBusy()) {
				for (
					self.$gameMessage.setFaceImage(this._params[0], this._params[1]),
						self.$gameMessage.setBackground(this._params[2]),
						self.$gameMessage.setPositionType(this._params[3]);
					401 === this.nextEventCode();

				)
					this._index++,
						self.$gameMessage.add(this.currentCommand().parameters[0]);
				switch (this.nextEventCode()) {
					case 102:
						this._index++, this.setupChoices(this.currentCommand().parameters);
						break;
					case 103:
						this._index++, this.setupNumInput(this.currentCommand().parameters);
						break;
					case 104:
						this._index++,
							this.setupItemChoice(this.currentCommand().parameters);
				}
				this._index++, this.setWaitMode('message');
			}
			return !1;
		}
		command102() {
			return (
				self.$gameMessage.isBusy() ||
					(this.setupChoices(this._params),
					this._index++,
					this.setWaitMode('message')),
				!1
			);
		}
		setupChoices(t) {
			const e = t[0].clone();
			let i = t[1];
			const r = t.length > 2 ? t[2] : 0,
				s = t.length > 3 ? t[3] : 2,
				n = t.length > 4 ? t[4] : 0;
			i >= e.length && (i = -2),
				self.$gameMessage.setChoices(e, r, i),
				self.$gameMessage.setChoiceBackground(n),
				self.$gameMessage.setChoicePositionType(s),
				self.$gameMessage.setChoiceCallback((t) => {
					this._branch[this._indent] = t;
				});
		}
		command402() {
			return (
				this._branch[this._indent] !== this._params[0] && this.skipBranch(), !0
			);
		}
		command403() {
			return this._branch[this._indent] >= 0 && this.skipBranch(), !0;
		}
		command103() {
			return (
				self.$gameMessage.isBusy() ||
					(this.setupNumInput(this._params),
					this._index++,
					this.setWaitMode('message')),
				!1
			);
		}
		setupNumInput(t) {
			self.$gameMessage.setNumberInput(t[0], t[1]);
		}
		command104() {
			return (
				self.$gameMessage.isBusy() ||
					(this.setupItemChoice(this._params),
					this._index++,
					this.setWaitMode('message')),
				!1
			);
		}
		setupItemChoice(t) {
			self.$gameMessage.setItemChoice(t[0], t[1] || 2);
		}
		command105() {
			if (!self.$gameMessage.isBusy()) {
				for (
					self.$gameMessage.setScroll(this._params[0], this._params[1]);
					405 === this.nextEventCode();

				)
					this._index++,
						self.$gameMessage.add(this.currentCommand().parameters[0]);
				this._index++, this.setWaitMode('message');
			}
			return !1;
		}
		command108() {
			for (this._comments = [this._params[0]]; 408 === this.nextEventCode(); )
				this._index++, this._comments.push(this.currentCommand().parameters[0]);
			return !0;
		}
		command111() {
			let result = !1;
			switch (this._params[0]) {
				case 0:
					result =
						self.$gameSwitches.value(this._params[1]) ===
						(0 === this._params[2]);
					break;
				case 1:
					const value1 = self.$gameVariables.value(this._params[1]);
					let value2;
					switch (
						((value2 =
							0 === this._params[2]
								? this._params[3]
								: self.$gameVariables.value(this._params[3])),
						this._params[4])
					) {
						case 0:
							result = value1 === value2;
							break;
						case 1:
							result = value1 >= value2;
							break;
						case 2:
							result = value1 <= value2;
							break;
						case 3:
							result = value1 > value2;
							break;
						case 4:
							result = value1 < value2;
							break;
						case 5:
							result = value1 !== value2;
					}
					break;
				case 2:
					if (this._eventId > 0) {
						const t = [this._mapId, this._eventId, this._params[1]];
						result =
							self.$gameSelfSwitches.value(t) === (0 === this._params[2]);
					}
					break;
				case 3:
					self.$gameTimer.isWorking() &&
						(result =
							0 === this._params[2]
								? self.$gameTimer.seconds() >= this._params[1]
								: self.$gameTimer.seconds() <= this._params[1]);
					break;
				case 4:
					const actor = self.$gameActors.actor(this._params[1]);
					if (actor) {
						const t = this._params[3];
						switch (this._params[2]) {
							case 0:
								result = self.$gameParty.members().contains(actor);
								break;
							case 1:
								result = actor.name() === t;
								break;
							case 2:
								result = actor.isClass(self.$dataClasses[t]);
								break;
							case 3:
								result = actor.hasSkill(t);
								break;
							case 4:
								result = actor.hasWeapon(self.$dataWeapons[t]);
								break;
							case 5:
								result = actor.hasArmor(self.$dataArmors[t]);
								break;
							case 6:
								result = actor.isStateAffected(t);
						}
					}
					break;
				case 5:
					const enemy = self.$gameTroop.members()[this._params[1]];
					if (enemy)
						switch (this._params[2]) {
							case 0:
								result = enemy.isAlive();
								break;
							case 1:
								result = enemy.isStateAffected(this._params[3]);
						}
					break;
				case 6:
					const character = this.character(this._params[1]);
					character && (result = character.direction() === this._params[2]);
					break;
				case 7:
					switch (this._params[2]) {
						case 0:
							result = self.$gameParty.gold() >= this._params[1];
							break;
						case 1:
							result = self.$gameParty.gold() <= this._params[1];
							break;
						case 2:
							result = self.$gameParty.gold() < this._params[1];
					}
					break;
				case 8:
					result = self.$gameParty.hasItem(self.$dataItems[this._params[1]]);
					break;
				case 9:
					result = self.$gameParty.hasItem(
						self.$dataWeapons[this._params[1]],
						this._params[2]
					);
					break;
				case 10:
					result = self.$gameParty.hasItem(
						self.$dataArmors[this._params[1]],
						this._params[2]
					);
					break;
				case 11:
					result = Input.isPressed(this._params[1]);
					break;
				case 12:
					try {
						result = !!eval(this._params[1]);
					} catch (t) {
						throw (
							((t.eventCommand = 'conditional_branch_script'),
							(t.content = this._params[1]),
							t)
						);
					}
					break;
				case 13:
					result =
						self.$gamePlayer.vehicle() ===
						self.$gameMap.vehicle(this._params[1]);
			}
			return (
				(this._branch[this._indent] = result),
				!1 === this._branch[this._indent] && this.skipBranch(),
				!0
			);
		}
		command411() {
			return !1 !== this._branch[this._indent] && this.skipBranch(), !0;
		}
		command112() {
			return !0;
		}
		command413() {
			do {
				this._index--;
			} while (this.currentCommand().indent !== this._indent);
			return !0;
		}
		command113() {
			let t = 0;
			for (; this._index < this._list.length - 1; ) {
				this._index++;
				const e = this.currentCommand();
				if ((112 === e.code && t++, 413 === e.code)) {
					if (!(t > 0)) break;
					t--;
				}
			}
			return !0;
		}
		command115() {
			return (this._index = this._list.length), !0;
		}
		command117() {
			const t = self.$dataCommonEvents[this._params[0]];
			if (t) {
				const e = this.isOnCurrentMap() ? this._eventId : 0;
				this.setupChild(t.list, e);
			}
			return !0;
		}
		setupChild(t, e) {
			(this._childInterpreter = new Game_Interpreter(this._depth + 1)),
				this._childInterpreter.setup(t, e),
				this._childInterpreter.setEventInfo({
					eventType: 'common_event',
					commonEventId: this._params[0],
				});
		}
		command118() {
			return !0;
		}
		command119() {
			const t = this._params[0];
			for (let e = 0; e < this._list.length; e++) {
				const i = this._list[e];
				if (118 === i.code && i.parameters[0] === t) return void this.jumpTo(e);
			}
			return !0;
		}
		jumpTo(t) {
			const e = this._index,
				i = Math.min(t, e),
				r = Math.max(t, e);
			let s = this._indent;
			for (let t = i; t <= r; t++) {
				const e = this._list[t].indent;
				e !== s && ((this._branch[s] = null), (s = e));
			}
			this._index = t;
		}
		command121() {
			for (let t = this._params[0]; t <= this._params[1]; t++)
				self.$gameSwitches.setValue(t, 0 === this._params[2]);
			return !0;
		}
		command122() {
			let value = 0;
			switch (this._params[3]) {
				case 0:
					value = this._params[4];
					break;
				case 1:
					value = self.$gameVariables.value(this._params[4]);
					break;
				case 2:
					value = this._params[5] - this._params[4] + 1;
					for (let t = this._params[0]; t <= this._params[1]; t++)
						this.operateVariable(
							t,
							this._params[2],
							this._params[4] + Math.randomInt(value)
						);
					return !0;
				case 3:
					value = this.gameDataOperand(
						this._params[4],
						this._params[5],
						this._params[6]
					);
					break;
				case 4:
					try {
						value = eval(this._params[4]);
					} catch (t) {
						throw (
							((t.eventCommand = 'control_variables'),
							(t.content = this._params[4]),
							t)
						);
					}
			}
			for (let t = this._params[0]; t <= this._params[1]; t++)
				this.operateVariable(t, this._params[2], value);
			return !0;
		}
		gameDataOperand(t, e, i) {
			switch (t) {
				case 0:
					return self.$gameParty.numItems(self.$dataItems[e]);
				case 1:
					return self.$gameParty.numItems(self.$dataWeapons[e]);
				case 2:
					return self.$gameParty.numItems(self.$dataArmors[e]);
				case 3:
					const t = self.$gameActors.actor(e);
					if (t)
						switch (i) {
							case 0:
								return t.level;
							case 1:
								return t.currentExp();
							case 2:
								return t.hp;
							case 3:
								return t.mp;
							default:
								if (i >= 4 && i <= 11) return t.param(i - 4);
						}
					break;
				case 4:
					const r = self.$gameTroop.members()[e];
					if (r)
						switch (i) {
							case 0:
								return r.hp;
							case 1:
								return r.mp;
							default:
								if (i >= 2 && i <= 9) return r.param(i - 2);
						}
					break;
				case 5:
					const s = this.character(e);
					if (s)
						switch (i) {
							case 0:
								return s.x;
							case 1:
								return s.y;
							case 2:
								return s.direction();
							case 3:
								return s.screenX();
							case 4:
								return s.screenY();
						}
					break;
				case 6:
					const n = self.$gameParty.members()[e];
					return n ? n.actorId() : 0;
				case 7:
					switch (e) {
						case 0:
							return self.$gameMap.mapId();
						case 1:
							return self.$gameParty.size();
						case 2:
							return self.$gameParty.gold();
						case 3:
							return self.$gameParty.steps();
						case 4:
							return self.$gameSystem.playtime();
						case 5:
							return self.$gameTimer.seconds();
						case 6:
							return self.$gameSystem.saveCount();
						case 7:
							return self.$gameSystem.battleCount();
						case 8:
							return self.$gameSystem.winCount();
						case 9:
							return self.$gameSystem.escapeCount();
					}
			}
			return 0;
		}
		operateVariable(t, e, i) {
			try {
				let r = self.$gameVariables.value(t);
				switch (e) {
					case 0:
						self.$gameVariables.setValue(t, (r = i));
						break;
					case 1:
						self.$gameVariables.setValue(t, r + i);
						break;
					case 2:
						self.$gameVariables.setValue(t, r - i);
						break;
					case 3:
						self.$gameVariables.setValue(t, r * i);
						break;
					case 4:
						self.$gameVariables.setValue(t, r / i);
						break;
					case 5:
						self.$gameVariables.setValue(t, r % i);
				}
			} catch (e) {
				self.$gameVariables.setValue(t, 0);
			}
		}
		command123() {
			if (this._eventId > 0) {
				const t = [this._mapId, this._eventId, this._params[0]];
				self.$gameSelfSwitches.setValue(t, 0 === this._params[1]);
			}
			return !0;
		}
		command124() {
			return (
				0 === this._params[0]
					? self.$gameTimer.start(60 * this._params[1])
					: self.$gameTimer.stop(),
				!0
			);
		}
		command125() {
			const t = this.operateValue(
				this._params[0],
				this._params[1],
				this._params[2]
			);
			return self.$gameParty.gainGold(t), !0;
		}
		command126() {
			const t = this.operateValue(
				this._params[1],
				this._params[2],
				this._params[3]
			);
			return self.$gameParty.gainItem(self.$dataItems[this._params[0]], t), !0;
		}
		command127() {
			const t = this.operateValue(
				this._params[1],
				this._params[2],
				this._params[3]
			);
			return (
				self.$gameParty.gainItem(
					self.$dataWeapons[this._params[0]],
					t,
					this._params[4]
				),
				!0
			);
		}
		command128() {
			const t = this.operateValue(
				this._params[1],
				this._params[2],
				this._params[3]
			);
			return (
				self.$gameParty.gainItem(
					self.$dataArmors[this._params[0]],
					t,
					this._params[4]
				),
				!0
			);
		}
		command129() {
			return (
				self.$gameActors.actor(this._params[0]) &&
					(0 === this._params[1]
						? (this._params[2] &&
								self.$gameActors.actor(this._params[0]).setup(this._params[0]),
						  self.$gameParty.addActor(this._params[0]))
						: self.$gameParty.removeActor(this._params[0])),
				!0
			);
		}
		command132() {
			return self.$gameSystem.setBattleBgm(this._params[0]), !0;
		}
		command133() {
			return self.$gameSystem.setVictoryMe(this._params[0]), !0;
		}
		command134() {
			return (
				0 === this._params[0]
					? self.$gameSystem.disableSave()
					: self.$gameSystem.enableSave(),
				!0
			);
		}
		command135() {
			return (
				0 === this._params[0]
					? self.$gameSystem.disableMenu()
					: self.$gameSystem.enableMenu(),
				!0
			);
		}
		command136() {
			return (
				0 === this._params[0]
					? self.$gameSystem.disableEncounter()
					: self.$gameSystem.enableEncounter(),
				self.$gamePlayer.makeEncounterCount(),
				!0
			);
		}
		command137() {
			return (
				0 === this._params[0]
					? self.$gameSystem.disableFormation()
					: self.$gameSystem.enableFormation(),
				!0
			);
		}
		command138() {
			return self.$gameSystem.setWindowTone(this._params[0]), !0;
		}
		command139() {
			return self.$gameSystem.setDefeatMe(this._params[0]), !0;
		}
		command140() {
			const t = self.$gameMap.vehicle(this._params[0]);
			return t && t.setBgm(this._params[1]), !0;
		}
		command201() {
			if (!self.$gameParty.inBattle() && !self.$gameMessage.isBusy()) {
				let t, e, i;
				0 === this._params[0]
					? ((t = this._params[1]),
					  (e = this._params[2]),
					  (i = this._params[3]))
					: ((t = self.$gameVariables.value(this._params[1])),
					  (e = self.$gameVariables.value(this._params[2])),
					  (i = self.$gameVariables.value(this._params[3]))),
					self.$gamePlayer.reserveTransfer(
						t,
						e,
						i,
						this._params[4],
						this._params[5]
					),
					this.setWaitMode('transfer'),
					this._index++;
			}
			return !1;
		}
		command202() {
			let t, e, i;
			0 === this._params[1]
				? ((t = this._params[2]), (e = this._params[3]), (i = this._params[4]))
				: ((t = self.$gameVariables.value(this._params[2])),
				  (e = self.$gameVariables.value(this._params[3])),
				  (i = self.$gameVariables.value(this._params[4])));
			const r = self.$gameMap.vehicle(this._params[0]);
			return r && r.setLocation(t, e, i), !0;
		}
		command203() {
			const t = this.character(this._params[0]);
			if (t) {
				if (0 === this._params[1]) t.locate(this._params[2], this._params[3]);
				else if (1 === this._params[1]) {
					const e = self.$gameVariables.value(this._params[2]),
						i = self.$gameVariables.value(this._params[3]);
					t.locate(e, i);
				} else {
					const e = this.character(this._params[2]);
					e && t.swap(e);
				}
				this._params[4] > 0 && t.setDirection(this._params[4]);
			}
			return !0;
		}
		command204() {
			if (!self.$gameParty.inBattle()) {
				if (self.$gameMap.isScrolling()) return this.setWaitMode('scroll'), !1;
				self.$gameMap.startScroll(
					this._params[0],
					this._params[1],
					this._params[2]
				);
			}
			return !0;
		}
		command205() {
			if (
				(self.$gameMap.refreshIfNeeded(),
				(this._character = this.character(this._params[0])),
				this._character)
			) {
				this._character.forceMoveRoute(this._params[1]);
				const t = JsonEx.makeDeepCopy(this._eventInfo);
				(t.line = this._index + 1),
					this._character.setCallerEventInfo(t),
					this._params[1].wait && this.setWaitMode('route');
			}
			return !0;
		}
		command206() {
			return self.$gamePlayer.getOnOffVehicle(), !0;
		}
		command211() {
			return self.$gamePlayer.setTransparent(0 === this._params[0]), !0;
		}
		command212() {
			return (
				(this._character = this.character(this._params[0])),
				this._character &&
					(this._character.requestAnimation(this._params[1]),
					this._params[2] && this.setWaitMode('animation')),
				!0
			);
		}
		command213() {
			return (
				(this._character = this.character(this._params[0])),
				this._character &&
					(this._character.requestBalloon(this._params[1]),
					this._params[2] && this.setWaitMode('balloon')),
				!0
			);
		}
		command214() {
			return (
				this.isOnCurrentMap() &&
					this._eventId > 0 &&
					self.$gameMap.eraseEvent(this._eventId),
				!0
			);
		}
		command216() {
			return (
				0 === this._params[0]
					? self.$gamePlayer.showFollowers()
					: self.$gamePlayer.hideFollowers(),
				self.$gamePlayer.refresh(),
				!0
			);
		}
		command217() {
			return (
				self.$gameParty.inBattle() ||
					(self.$gamePlayer.gatherFollowers(), this.setWaitMode('gather')),
				!0
			);
		}
		command221() {
			return (
				self.$gameMessage.isBusy() ||
					(self.$gameScreen.startFadeOut(this.fadeSpeed()),
					this.wait(this.fadeSpeed()),
					this._index++),
				!1
			);
		}
		command222() {
			return (
				self.$gameMessage.isBusy() ||
					(self.$gameScreen.startFadeIn(this.fadeSpeed()),
					this.wait(this.fadeSpeed()),
					this._index++),
				!1
			);
		}
		command223() {
			return (
				self.$gameScreen.startTint(this._params[0], this._params[1]),
				this._params[2] && this.wait(this._params[1]),
				!0
			);
		}
		command224() {
			return (
				self.$gameScreen.startFlash(this._params[0], this._params[1]),
				this._params[2] && this.wait(this._params[1]),
				!0
			);
		}
		command225() {
			return (
				self.$gameScreen.startShake(
					this._params[0],
					this._params[1],
					this._params[2]
				),
				this._params[3] && this.wait(this._params[2]),
				!0
			);
		}
		command230() {
			return this.wait(this._params[0]), !0;
		}
		command231() {
			let t, e;
			return (
				0 === this._params[3]
					? ((t = this._params[4]), (e = this._params[5]))
					: ((t = self.$gameVariables.value(this._params[4])),
					  (e = self.$gameVariables.value(this._params[5]))),
				self.$gameScreen.showPicture(
					this._params[0],
					this._params[1],
					this._params[2],
					t,
					e,
					this._params[6],
					this._params[7],
					this._params[8],
					this._params[9]
				),
				!0
			);
		}
		command232() {
			let t, e;
			return (
				0 === this._params[3]
					? ((t = this._params[4]), (e = this._params[5]))
					: ((t = self.$gameVariables.value(this._params[4])),
					  (e = self.$gameVariables.value(this._params[5]))),
				self.$gameScreen.movePicture(
					this._params[0],
					this._params[2],
					t,
					e,
					this._params[6],
					this._params[7],
					this._params[8],
					this._params[9],
					this._params[10]
				),
				this._params[11] && this.wait(this._params[10]),
				!0
			);
		}
		command233() {
			return (
				self.$gameScreen.rotatePicture(this._params[0], this._params[1]), !0
			);
		}
		command234() {
			return (
				self.$gameScreen.tintPicture(
					this._params[0],
					this._params[1],
					this._params[2]
				),
				this._params[3] && this.wait(this._params[2]),
				!0
			);
		}
		command235() {
			return self.$gameScreen.erasePicture(this._params[0]), !0;
		}
		command236() {
			return (
				self.$gameParty.inBattle() ||
					(self.$gameScreen.changeWeather(
						this._params[0],
						this._params[1],
						this._params[2]
					),
					this._params[3] && this.wait(this._params[2])),
				!0
			);
		}
		command241() {
			return AudioManager.playBgm(this._params[0]), !0;
		}
		command242() {
			return AudioManager.fadeOutBgm(this._params[0]), !0;
		}
		command243() {
			return self.$gameSystem.saveBgm(), !0;
		}
		command244() {
			return self.$gameSystem.replayBgm(), !0;
		}
		command245() {
			return AudioManager.playBgs(this._params[0]), !0;
		}
		command246() {
			return AudioManager.fadeOutBgs(this._params[0]), !0;
		}
		command249() {
			return AudioManager.playMe(this._params[0]), !0;
		}
		command250() {
			return AudioManager.playSe(this._params[0]), !0;
		}
		command251() {
			return AudioManager.stopSe(), !0;
		}
		command261() {
			if (!self.$gameMessage.isBusy()) {
				const t = this._params[0];
				if (t.length > 0) {
					const e = this.videoFileExt();
					Graphics.playVideo(`movies/${t}${e}`), this.setWaitMode('video');
				}
				this._index++;
			}
			return !1;
		}
		videoFileExt() {
			return Graphics.canPlayVideoType('video/webm') && !Utils.isMobileDevice()
				? '.webm'
				: '.mp4';
		}
		command281() {
			return (
				0 === this._params[0]
					? self.$gameMap.enableNameDisplay()
					: self.$gameMap.disableNameDisplay(),
				!0
			);
		}
		command282() {
			const t = self.$dataTilesets[this._params[0]];
			return (
				this._imageReservationId ||
					(this._imageReservationId = Utils.generateRuntimeId()),
				!!t.tilesetNames
					.map(function (t) {
						return ImageManager.reserveTileset(t, 0, this._imageReservationId);
					}, this)
					.every((t) => t.isReady()) &&
					(self.$gameMap.changeTileset(this._params[0]),
					ImageManager.releaseReservation(this._imageReservationId),
					(this._imageReservationId = null),
					!0)
			);
		}
		command283() {
			return (
				self.$gameMap.changeBattleback(this._params[0], this._params[1]), !0
			);
		}
		command284() {
			return (
				self.$gameMap.changeParallax(
					this._params[0],
					this._params[1],
					this._params[2],
					this._params[3],
					this._params[4]
				),
				!0
			);
		}
		command285() {
			let t, e, i;
			switch (
				(0 === this._params[2]
					? ((t = this._params[3]), (e = this._params[4]))
					: ((t = self.$gameVariables.value(this._params[3])),
					  (e = self.$gameVariables.value(this._params[4]))),
				this._params[1])
			) {
				case 0:
					i = self.$gameMap.terrainTag(t, e);
					break;
				case 1:
					i = self.$gameMap.eventIdXy(t, e);
					break;
				case 2:
				case 3:
				case 4:
				case 5:
					i = self.$gameMap.tileId(t, e, this._params[1] - 2);
					break;
				default:
					i = self.$gameMap.regionId(t, e);
			}
			return self.$gameVariables.setValue(this._params[0], i), !0;
		}
		command301() {
			if (!self.$gameParty.inBattle()) {
				let t;
				(t =
					0 === this._params[0]
						? this._params[1]
						: 1 === this._params[0]
						? self.$gameVariables.value(this._params[1])
						: self.$gamePlayer.makeEncounterTroopId()),
					self.$dataTroops[t] &&
						(BattleManager.setup(t, this._params[2], this._params[3]),
						BattleManager.setEventCallback((t) => {
							this._branch[this._indent] = t;
						}),
						self.$gamePlayer.makeEncounterCount(),
						SceneManager.push(Scene_Battle));
			}
			return !0;
		}
		command601() {
			return 0 !== this._branch[this._indent] && this.skipBranch(), !0;
		}
		command602() {
			return 1 !== this._branch[this._indent] && this.skipBranch(), !0;
		}
		command603() {
			return 2 !== this._branch[this._indent] && this.skipBranch(), !0;
		}
		command302() {
			if (!self.$gameParty.inBattle()) {
				const t = [this._params];
				for (; 605 === this.nextEventCode(); )
					this._index++, t.push(this.currentCommand().parameters);
				SceneManager.push(Scene_Shop),
					SceneManager.prepareNextScene(t, this._params[4]);
			}
			return !0;
		}
		command303() {
			return (
				self.$gameParty.inBattle() ||
					(self.$dataActors[this._params[0]] &&
						(SceneManager.push(Scene_Name),
						SceneManager.prepareNextScene(this._params[0], this._params[1]))),
				!0
			);
		}
		command311() {
			const t = this.operateValue(
				this._params[2],
				this._params[3],
				this._params[4]
			);
			return (
				this.iterateActorEx(this._params[0], this._params[1], (e) => {
					this.changeHp(e, t, this._params[5]);
				}),
				!0
			);
		}
		command312() {
			const t = this.operateValue(
				this._params[2],
				this._params[3],
				this._params[4]
			);
			return (
				this.iterateActorEx(this._params[0], this._params[1], (e) => {
					e.gainMp(t);
				}),
				!0
			);
		}
		command326() {
			const t = this.operateValue(
				this._params[2],
				this._params[3],
				this._params[4]
			);
			return (
				this.iterateActorEx(this._params[0], this._params[1], (e) => {
					e.gainTp(t);
				}),
				!0
			);
		}
		command313() {
			return (
				this.iterateActorEx(this._params[0], this._params[1], (t) => {
					const e = t.isDead();
					0 === this._params[2]
						? t.addState(this._params[3])
						: t.removeState(this._params[3]),
						t.isDead() && !e && t.performCollapse(),
						t.clearResult();
				}),
				!0
			);
		}
		command314() {
			return (
				this.iterateActorEx(this._params[0], this._params[1], (t) => {
					t.recoverAll();
				}),
				!0
			);
		}
		command315() {
			const t = this.operateValue(
				this._params[2],
				this._params[3],
				this._params[4]
			);
			return (
				this.iterateActorEx(this._params[0], this._params[1], (e) => {
					e.changeExp(e.currentExp() + t, this._params[5]);
				}),
				!0
			);
		}
		command316() {
			const t = this.operateValue(
				this._params[2],
				this._params[3],
				this._params[4]
			);
			return (
				this.iterateActorEx(this._params[0], this._params[1], (e) => {
					e.changeLevel(e.level + t, this._params[5]);
				}),
				!0
			);
		}
		command317() {
			const t = this.operateValue(
				this._params[3],
				this._params[4],
				this._params[5]
			);
			return (
				this.iterateActorEx(this._params[0], this._params[1], (e) => {
					e.addParam(this._params[2], t);
				}),
				!0
			);
		}
		command318() {
			return (
				this.iterateActorEx(this._params[0], this._params[1], (t) => {
					0 === this._params[2]
						? t.learnSkill(this._params[3])
						: t.forgetSkill(this._params[3]);
				}),
				!0
			);
		}
		command319() {
			const t = self.$gameActors.actor(this._params[0]);
			return t && t.changeEquipById(this._params[1], this._params[2]), !0;
		}
		command320() {
			const t = self.$gameActors.actor(this._params[0]);
			return t && t.setName(this._params[1]), !0;
		}
		command321() {
			const t = self.$gameActors.actor(this._params[0]);
			return (
				t &&
					self.$dataClasses[this._params[1]] &&
					t.changeClass(this._params[1], this._params[2]),
				!0
			);
		}
		command322() {
			const t = self.$gameActors.actor(this._params[0]);
			return (
				t &&
					(t.setCharacterImage(this._params[1], this._params[2]),
					t.setFaceImage(this._params[3], this._params[4]),
					t.setBattlerImage(this._params[5])),
				self.$gamePlayer.refresh(),
				!0
			);
		}
		command323() {
			const t = self.$gameMap.vehicle(this._params[0]);
			return t && t.setImage(this._params[1], this._params[2]), !0;
		}
		command324() {
			const t = self.$gameActors.actor(this._params[0]);
			return t && t.setNickname(this._params[1]), !0;
		}
		command325() {
			const t = self.$gameActors.actor(this._params[0]);
			return t && t.setProfile(this._params[1]), !0;
		}
		command331() {
			const t = this.operateValue(
				this._params[1],
				this._params[2],
				this._params[3]
			);
			return (
				this.iterateEnemyIndex(this._params[0], (e) => {
					this.changeHp(e, t, this._params[4]);
				}),
				!0
			);
		}
		command332() {
			const t = this.operateValue(
				this._params[1],
				this._params[2],
				this._params[3]
			);
			return (
				this.iterateEnemyIndex(this._params[0], (e) => {
					e.gainMp(t);
				}),
				!0
			);
		}
		command342() {
			const t = this.operateValue(
				this._params[1],
				this._params[2],
				this._params[3]
			);
			return (
				this.iterateEnemyIndex(this._params[0], (e) => {
					e.gainTp(t);
				}),
				!0
			);
		}
		command333() {
			return (
				this.iterateEnemyIndex(this._params[0], (t) => {
					const e = t.isDead();
					0 === this._params[1]
						? t.addState(this._params[2])
						: t.removeState(this._params[2]),
						t.isDead() && !e && t.performCollapse(),
						t.clearResult();
				}),
				!0
			);
		}
		command334() {
			return (
				this.iterateEnemyIndex(this._params[0], (t) => {
					t.recoverAll();
				}),
				!0
			);
		}
		command335() {
			return (
				this.iterateEnemyIndex(this._params[0], (t) => {
					t.appear(), self.$gameTroop.makeUniqueNames();
				}),
				!0
			);
		}
		command336() {
			return (
				this.iterateEnemyIndex(this._params[0], (t) => {
					t.transform(this._params[1]), self.$gameTroop.makeUniqueNames();
				}),
				!0
			);
		}
		command337() {
			return (
				1 == this._params[2]
					? this.iterateEnemyIndex(-1, (t) => {
							t.isAlive() && t.startAnimation(this._params[1], !1, 0);
					  })
					: this.iterateEnemyIndex(this._params[0], (t) => {
							t.isAlive() && t.startAnimation(this._params[1], !1, 0);
					  }),
				!0
			);
		}
		command339() {
			return (
				this.iterateBattler(this._params[0], this._params[1], (t) => {
					t.isDeathStateAffected() ||
						(t.forceAction(this._params[2], this._params[3]),
						BattleManager.forceAction(t),
						this.setWaitMode('action'));
				}),
				!0
			);
		}
		command340() {
			return BattleManager.abort(), !0;
		}
		command351() {
			return (
				self.$gameParty.inBattle() ||
					(SceneManager.push(Scene_Menu),
					Window_MenuCommand.initCommandPosition()),
				!0
			);
		}
		command352() {
			return self.$gameParty.inBattle() || SceneManager.push(Scene_Save), !0;
		}
		command353() {
			return SceneManager.goto(Scene_Gameover), !0;
		}
		command354() {
			return SceneManager.goto(Scene_Title), !0;
		}
		command355() {
			const startLine = this._index + 1;
			let script = `${this.currentCommand().parameters[0]}\n`;
			for (; 655 === this.nextEventCode(); )
				this._index++, (script += `${this.currentCommand().parameters[0]}\n`);
			const endLine = this._index + 1;
			try {
				eval(script);
			} catch (t) {
				throw (
					((t.line = `${startLine}-${endLine}`),
					(t.eventCommand = 'script'),
					(t.content = script),
					t)
				);
			}
			return !0;
		}
		command356() {
			const t = this._params[0].split(' '),
				e = t.shift();
			try {
				this.pluginCommand(e, t);
			} catch (t) {
				throw (
					((t.eventCommand = 'plugin_command'),
					(t.content = this._params[0]),
					t)
				);
			}
			return !0;
		}
		pluginCommand(t, e) {}
		static requestImagesByPluginCommand(t, e) {}
		static requestImagesForCommand({ parameters: t, code: e }) {
			const i = t;
			switch (e) {
				case 101:
					ImageManager.requestFace(i[0]);
					break;
				case 129:
					const t = self.$gameActors.actor(i[0]);
					if (t && 0 === i[1]) {
						const e = t.characterName();
						ImageManager.requestCharacter(e);
					}
					break;
				case 205:
					i[1] &&
						i[1].list.forEach(({ parameters: t, code: e }) => {
							const i = t;
							e === Game_Character.ROUTE_CHANGE_IMAGE &&
								ImageManager.requestCharacter(i[0]);
						});
					break;
				case 212:
				case 337:
					if (i[1]) {
						const t = self.$dataAnimations[i[1]],
							e = t.animation1Name,
							r = t.animation2Name,
							s = t.animation1Hue,
							n = t.animation2Hue;
						ImageManager.requestAnimation(e, s),
							ImageManager.requestAnimation(r, n);
					}
					break;
				case 216:
					0 === i[0] &&
						self.$gamePlayer.followers().forEach((t) => {
							const e = t.characterName();
							ImageManager.requestCharacter(e);
						});
					break;
				case 231:
					ImageManager.requestPicture(i[1]);
					break;
				case 282:
					self.$dataTilesets[i[0]].tilesetNames.forEach((t) => {
						ImageManager.requestTileset(t);
					});
					break;
				case 283:
					self.$gameParty.inBattle() &&
						(ImageManager.requestBattleback1(i[0]),
						ImageManager.requestBattleback2(i[1]));
					break;
				case 284:
					self.$gameParty.inBattle() || ImageManager.requestParallax(i[0]);
					break;
				case 322:
					ImageManager.requestCharacter(i[1]),
						ImageManager.requestFace(i[3]),
						ImageManager.requestSvActor(i[5]);
					break;
				case 323:
					self.$gameMap.vehicle(i[0]) && ImageManager.requestCharacter(i[1]);
					break;
				case 336:
					const e = self.$dataEnemies[i[1]],
						r = e.battlerName,
						s = e.battlerHue;
					self.$gameSystem.isSideView()
						? ImageManager.requestSvEnemy(r, s)
						: ImageManager.requestEnemy(r, s);
					break;
				case 356:
					const n = i[0].split(' '),
						a = n.shift();
					Game_Interpreter.requestImagesByPluginCommand(a, n);
			}
		}
		static requestImagesByChildEvent({ parameters: t }, e) {
			const i = t,
				r = self.$dataCommonEvents[i[0]];
			r &&
				(e || (e = []),
				e.contains(i[0]) ||
					(e.push(i[0]), Game_Interpreter.requestImages(r.list, e)));
		}
		static requestImages(t, e) {
			if (!t) return;
			const i = t.length;
			for (let r = 0; r < i; r += 1) {
				const i = t[r];
				117 === i.code
					? Game_Interpreter.requestImagesByChildEvent(i, e)
					: Game_Interpreter.requestImagesForCommand(i);
			}
		}
	}
	class Game_Troop extends Game_Unit {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize(),
				(this._interpreter = new Game_Interpreter()),
				this.clear();
		}
		isEventRunning() {
			return this._interpreter.isRunning();
		}
		updateInterpreter() {
			this._interpreter.update();
		}
		turnCount() {
			return this._turnCount;
		}
		members() {
			return this._enemies;
		}
		clear() {
			this._interpreter.clear(),
				(this._troopId = 0),
				(this._eventFlags = {}),
				(this._enemies = []),
				(this._turnCount = 0),
				(this._namesCount = {});
		}
		troop() {
			return self.$dataTroops[this._troopId];
		}
		setup(t) {
			this.clear(),
				(this._troopId = t),
				(this._enemies = []),
				this.troop().members.forEach(function (t) {
					if (self.$dataEnemies[t.enemyId]) {
						const e = t.enemyId,
							i = t.x,
							r = t.y,
							s = new Game_Enemy(e, i, r);
						t.hidden && s.hide(), this._enemies.push(s);
					}
				}, this),
				this.makeUniqueNames();
		}
		makeUniqueNames() {
			const t = this.letterTable();
			this.members().forEach(function (e) {
				if (e.isAlive() && e.isLetterEmpty()) {
					const i = e.originalName(),
						r = this._namesCount[i] || 0;
					e.setLetter(t[r % t.length]), (this._namesCount[i] = r + 1);
				}
			}, this),
				this.members().forEach(function (t) {
					const e = t.originalName();
					this._namesCount[e] >= 2 && t.setPlural(!0);
				}, this);
		}
		letterTable() {
			return self.$gameSystem.isCJK()
				? Game_Troop.LETTER_TABLE_FULL
				: Game_Troop.LETTER_TABLE_HALF;
		}
		enemyNames() {
			const t = [];
			return (
				this.members().forEach((e) => {
					const i = e.originalName();
					e.isAlive() && !t.contains(i) && t.push(i);
				}),
				t
			);
		}
		meetsConditions({ conditions: t }) {
			const e = t;
			if (
				!(
					e.turnEnding ||
					e.turnValid ||
					e.enemyValid ||
					e.actorValid ||
					e.switchValid
				)
			)
				return !1;
			if (e.turnEnding && !BattleManager.isTurnEnd()) return !1;
			if (e.turnValid) {
				const t = this._turnCount,
					i = e.turnA,
					r = e.turnB;
				if (0 === r && t !== i) return !1;
				if (r > 0 && (t < 1 || t < i || t % r != i % r)) return !1;
			}
			if (e.enemyValid) {
				const t = self.$gameTroop.members()[e.enemyIndex];
				if (!t || 100 * t.hpRate() > e.enemyHp) return !1;
			}
			if (e.actorValid) {
				const t = self.$gameActors.actor(e.actorId);
				if (!t || 100 * t.hpRate() > e.actorHp) return !1;
			}
			return !(e.switchValid && !self.$gameSwitches.value(e.switchId));
		}
		setupBattleEvent() {
			if (!this._interpreter.isRunning()) {
				if (this._interpreter.setupReservedCommonEvent()) return;
				const t = this.troop().pages;
				for (let e = 0; e < t.length; e++) {
					const i = t[e];
					if (this.meetsConditions(i) && !this._eventFlags[e]) {
						this._interpreter.setup(i.list),
							this._interpreter.setEventInfo({
								eventType: 'battle_event',
								troopId: this._troopId,
								page: e + 1,
							}),
							i.span <= 1 && (this._eventFlags[e] = !0);
						break;
					}
				}
			}
		}
		increaseTurn() {
			this.troop().pages.forEach(({ span: t }, e) => {
				1 === t && (this._eventFlags[e] = !1);
			}),
				this._turnCount++;
		}
		expTotal() {
			return this.deadMembers().reduce((t, e) => t + e.exp(), 0);
		}
		goldTotal() {
			return (
				this.deadMembers().reduce((t, e) => t + e.gold(), 0) * this.goldRate()
			);
		}
		goldRate() {
			return self.$gameParty.hasGoldDouble() ? 2 : 1;
		}
		makeDropItems() {
			return this.deadMembers().reduce(
				(t, e) => t.concat(e.makeDropItems()),
				[]
			);
		}
	}
	(Game_Troop.LETTER_TABLE_HALF = [
		' A',
		' B',
		' C',
		' D',
		' E',
		' F',
		' G',
		' H',
		' I',
		' J',
		' K',
		' L',
		' M',
		' N',
		' O',
		' P',
		' Q',
		' R',
		' S',
		' T',
		' U',
		' V',
		' W',
		' X',
		' Y',
		' Z',
	]),
		(Game_Troop.LETTER_TABLE_FULL = [
			'Ａ',
			'Ｂ',
			'Ｃ',
			'Ｄ',
			'Ｅ',
			'Ｆ',
			'Ｇ',
			'Ｈ',
			'Ｉ',
			'Ｊ',
			'Ｋ',
			'Ｌ',
			'Ｍ',
			'Ｎ',
			'Ｏ',
			'Ｐ',
			'Ｑ',
			'Ｒ',
			'Ｓ',
			'Ｔ',
			'Ｕ',
			'Ｖ',
			'Ｗ',
			'Ｘ',
			'Ｙ',
			'Ｚ',
		]);
	class Game_CommonEvent {
		constructor(...t) {
			this.initialize(...t);
		}
		initialize(t) {
			(this._commonEventId = t), this.refresh();
		}
		event() {
			return self.$dataCommonEvents[this._commonEventId];
		}
		list() {
			return this.event().list;
		}
		refresh() {
			this.isActive()
				? this._interpreter || (this._interpreter = new Game_Interpreter())
				: (this._interpreter = null);
		}
		isActive() {
			const t = this.event();
			return 2 === t.trigger && self.$gameSwitches.value(t.switchId);
		}
		update() {
			this._interpreter &&
				(this._interpreter.isRunning() ||
					(this._interpreter.setup(this.list()),
					this._interpreter.setEventInfo({
						eventType: 'common_event',
						commonEventId: this._commonEventId,
					})),
				this._interpreter.update());
		}
	}
	class Game_Vehicle extends Game_Character {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t) {
			super.initialize(),
				(this._type = t),
				this.resetDirection(),
				this.initMoveSpeed(),
				this.loadSystemSettings();
		}
		initMembers() {
			super.initMembers(),
				(this._type = ''),
				(this._mapId = 0),
				(this._altitude = 0),
				(this._driving = !1),
				(this._bgm = null);
		}
		isBoat() {
			return 'boat' === this._type;
		}
		isShip() {
			return 'ship' === this._type;
		}
		isAirship() {
			return 'airship' === this._type;
		}
		resetDirection() {
			this.setDirection(4);
		}
		initMoveSpeed() {
			this.isBoat()
				? this.setMoveSpeed(4)
				: this.isShip()
				? this.setMoveSpeed(5)
				: this.isAirship() && this.setMoveSpeed(6);
		}
		vehicle() {
			return this.isBoat()
				? self.$dataSystem.boat
				: this.isShip()
				? self.$dataSystem.ship
				: this.isAirship()
				? self.$dataSystem.airship
				: null;
		}
		loadSystemSettings() {
			const t = this.vehicle();
			(this._mapId = t.startMapId),
				this.setPosition(t.startX, t.startY),
				this.setImage(t.characterName, t.characterIndex);
		}
		refresh() {
			this._driving
				? ((this._mapId = self.$gameMap.mapId()), this.syncWithPlayer())
				: this._mapId === self.$gameMap.mapId() && this.locate(this.x, this.y),
				this.isAirship()
					? this.setPriorityType(this._driving ? 2 : 0)
					: this.setPriorityType(1),
				this.setWalkAnime(this._driving),
				this.setStepAnime(this._driving),
				this.setTransparent(this._mapId !== self.$gameMap.mapId());
		}
		setLocation(t, e, i) {
			(this._mapId = t), this.setPosition(e, i), this.refresh();
		}
		pos(t, e) {
			return (
				this._mapId === self.$gameMap.mapId() &&
				Game_Character.prototype.pos.call(this, t, e)
			);
		}
		isMapPassable(t, e, i) {
			const r = self.$gameMap.roundXWithDirection(t, i),
				s = self.$gameMap.roundYWithDirection(e, i);
			return this.isBoat()
				? self.$gameMap.isBoatPassable(r, s)
				: this.isShip()
				? self.$gameMap.isShipPassable(r, s)
				: !!this.isAirship();
		}
		getOn() {
			(this._driving = !0),
				this.setWalkAnime(!0),
				this.setStepAnime(!0),
				self.$gameSystem.saveWalkingBgm(),
				this.playBgm();
		}
		getOff() {
			(this._driving = !1),
				this.setWalkAnime(!1),
				this.setStepAnime(!1),
				this.resetDirection(),
				self.$gameSystem.replayWalkingBgm();
		}
		setBgm(t) {
			this._bgm = t;
		}
		playBgm() {
			AudioManager.playBgm(this._bgm || this.vehicle().bgm);
		}
		syncWithPlayer() {
			this.copyPosition(self.$gamePlayer), this.refreshBushDepth();
		}
		screenY() {
			return Game_Character.prototype.screenY.call(this) - this._altitude;
		}
		shadowX() {
			return this.screenX();
		}
		shadowY() {
			return this.screenY() + this._altitude;
		}
		shadowOpacity() {
			return (255 * this._altitude) / this.maxAltitude();
		}
		canMove() {
			return !this.isAirship() || this.isHighest();
		}
		update() {
			super.update(), this.isAirship() && this.updateAirship();
		}
		updateAirship() {
			this.updateAirshipAltitude(),
				this.setStepAnime(this.isHighest()),
				this.setPriorityType(this.isLowest() ? 0 : 2);
		}
		updateAirshipAltitude() {
			this._driving && !this.isHighest() && this._altitude++,
				this._driving || this.isLowest() || this._altitude--;
		}
		maxAltitude() {
			return 48;
		}
		isLowest() {
			return this._altitude <= 0;
		}
		isHighest() {
			return this._altitude >= this.maxAltitude();
		}
		isTakeoffOk() {
			return self.$gamePlayer.areFollowersGathered();
		}
		isLandOk(t, e, i) {
			if (this.isAirship()) {
				if (!self.$gameMap.isAirshipLandOk(t, e)) return !1;
				if (self.$gameMap.eventsXy(t, e).length > 0) return !1;
			} else {
				const r = self.$gameMap.roundXWithDirection(t, i),
					s = self.$gameMap.roundYWithDirection(e, i);
				if (!self.$gameMap.isValid(r, s)) return !1;
				if (!self.$gameMap.isPassable(r, s, this.reverseDir(i))) return !1;
				if (this.isCollidedWithCharacters(r, s)) return !1;
			}
			return !0;
		}
	}
	class Game_Event extends Game_Character {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t, e) {
			super.initialize(),
				(this._mapId = t),
				(this._eventId = e),
				this.locate(this.event().x, this.event().y),
				this.refresh();
		}
		initMembers() {
			super.initMembers(),
				(this._moveType = 0),
				(this._trigger = 0),
				(this._starting = !1),
				(this._erased = !1),
				(this._pageIndex = -2),
				(this._originalPattern = 1),
				(this._originalDirection = 2),
				(this._prelockDirection = 0),
				(this._locked = !1);
		}
		eventId() {
			return this._eventId;
		}
		event() {
			return self.$dataMap.events[this._eventId];
		}
		page() {
			return this.event().pages[this._pageIndex];
		}
		list() {
			return this.page().list;
		}
		isCollidedWithCharacters(t, e) {
			return (
				Game_Character.prototype.isCollidedWithCharacters.call(this, t, e) ||
				this.isCollidedWithPlayerCharacters(t, e)
			);
		}
		isCollidedWithEvents(t, e) {
			return self.$gameMap.eventsXyNt(t, e).length > 0;
		}
		isCollidedWithPlayerCharacters(t, e) {
			return this.isNormalPriority() && self.$gamePlayer.isCollided(t, e);
		}
		lock() {
			this._locked ||
				((this._prelockDirection = this.direction()),
				this.turnTowardPlayer(),
				(this._locked = !0));
		}
		unlock() {
			this._locked &&
				((this._locked = !1), this.setDirection(this._prelockDirection));
		}
		updateStop() {
			this._locked && this.resetStopCount(),
				super.updateStop(),
				this.isMoveRouteForcing() || this.updateSelfMovement();
		}
		updateSelfMovement() {
			if (
				!this._locked &&
				this.isNearTheScreen() &&
				this.checkStop(this.stopCountThreshold())
			)
				switch (this._moveType) {
					case 1:
						this.moveTypeRandom();
						break;
					case 2:
						this.moveTypeTowardPlayer();
						break;
					case 3:
						this.moveTypeCustom();
				}
		}
		stopCountThreshold() {
			return 30 * (5 - this.moveFrequency());
		}
		moveTypeRandom() {
			switch (Math.randomInt(6)) {
				case 0:
				case 1:
					this.moveRandom();
					break;
				case 2:
				case 3:
				case 4:
					this.moveForward();
					break;
				case 5:
					this.resetStopCount();
			}
		}
		moveTypeTowardPlayer() {
			if (this.isNearThePlayer())
				switch (Math.randomInt(6)) {
					case 0:
					case 1:
					case 2:
					case 3:
						this.moveTowardPlayer();
						break;
					case 4:
						this.moveRandom();
						break;
					case 5:
						this.moveForward();
				}
			else this.moveRandom();
		}
		isNearThePlayer() {
			return (
				Math.abs(this.deltaXFrom(self.$gamePlayer.x)) +
					Math.abs(this.deltaYFrom(self.$gamePlayer.y)) <
				20
			);
		}
		moveTypeCustom() {
			this.updateRoutineMove();
		}
		isStarting() {
			return this._starting;
		}
		clearStartingFlag() {
			this._starting = !1;
		}
		isTriggerIn(t) {
			return t.contains(this._trigger);
		}
		start() {
			const t = this.list();
			t &&
				t.length > 1 &&
				((this._starting = !0), this.isTriggerIn([0, 1, 2]) && this.lock());
		}
		erase() {
			(this._erased = !0), this.refresh();
		}
		refresh() {
			const t = this._erased ? -1 : this.findProperPageIndex();
			this._pageIndex !== t && ((this._pageIndex = t), this.setupPage());
		}
		findProperPageIndex() {
			const t = this.event().pages;
			for (let e = t.length - 1; e >= 0; e--) {
				const i = t[e];
				if (this.meetsConditions(i)) return e;
			}
			return -1;
		}
		meetsConditions({ conditions: t }) {
			const e = t;
			if (e.switch1Valid && !self.$gameSwitches.value(e.switch1Id)) return !1;
			if (e.switch2Valid && !self.$gameSwitches.value(e.switch2Id)) return !1;
			if (
				e.variableValid &&
				self.$gameVariables.value(e.variableId) < e.variableValue
			)
				return !1;
			if (e.selfSwitchValid) {
				const t = [this._mapId, this._eventId, e.selfSwitchCh];
				if (!0 !== self.$gameSelfSwitches.value(t)) return !1;
			}
			if (e.itemValid) {
				const t = self.$dataItems[e.itemId];
				if (!self.$gameParty.hasItem(t)) return !1;
			}
			if (e.actorValid) {
				const t = self.$gameActors.actor(e.actorId);
				if (!self.$gameParty.members().contains(t)) return !1;
			}
			return !0;
		}
		setupPage() {
			this._pageIndex >= 0
				? this.setupPageSettings()
				: this.clearPageSettings(),
				this.refreshBushDepth(),
				this.clearStartingFlag(),
				this.checkEventTriggerAuto();
		}
		clearPageSettings() {
			this.setImage('', 0),
				(this._moveType = 0),
				(this._trigger = null),
				(this._interpreter = null),
				this.setThrough(!0);
		}
		setupPageSettings() {
			const t = this.page(),
				e = t.image;
			e.tileId > 0
				? this.setTileImage(e.tileId)
				: this.setImage(e.characterName, e.characterIndex),
				this._originalDirection !== e.direction &&
					((this._originalDirection = e.direction),
					(this._prelockDirection = 0),
					this.setDirectionFix(!1),
					this.setDirection(e.direction)),
				this._originalPattern !== e.pattern &&
					((this._originalPattern = e.pattern), this.setPattern(e.pattern)),
				this.setMoveSpeed(t.moveSpeed),
				this.setMoveFrequency(t.moveFrequency),
				this.setPriorityType(t.priorityType),
				this.setWalkAnime(t.walkAnime),
				this.setStepAnime(t.stepAnime),
				this.setDirectionFix(t.directionFix),
				this.setThrough(t.through),
				this.setMoveRoute(t.moveRoute),
				(this._moveType = t.moveType),
				(this._trigger = t.trigger),
				4 === this._trigger
					? (this._interpreter = new Game_Interpreter())
					: (this._interpreter = null);
		}
		isOriginalPattern() {
			return this.pattern() === this._originalPattern;
		}
		resetPattern() {
			this.setPattern(this._originalPattern);
		}
		checkEventTriggerTouch(t, e) {
			self.$gameMap.isEventRunning() ||
				(2 === this._trigger &&
					self.$gamePlayer.pos(t, e) &&
					!this.isJumping() &&
					this.isNormalPriority() &&
					this.start());
		}
		checkEventTriggerAuto() {
			3 === this._trigger && this.start();
		}
		update() {
			super.update(), this.checkEventTriggerAuto(), this.updateParallel();
		}
		updateParallel() {
			this._interpreter &&
				(this._interpreter.isRunning() ||
					(this._interpreter.setup(this.list(), this._eventId),
					this._interpreter.setEventInfo(this.getEventInfo())),
				this._interpreter.update());
		}
		locate(t, e) {
			super.locate(t, e), (this._prelockDirection = 0);
		}
		forceMoveRoute(t) {
			super.forceMoveRoute(t), (this._prelockDirection = 0);
		}
		getEventInfo() {
			return {
				eventType: 'map_event',
				mapId: this._mapId,
				mapEventId: this._eventId,
				page: this._pageIndex + 1,
			};
		}
	}
	class Game_Map {
		constructor(...t) {
			this.initialize(...t);
		}
		initialize() {
			(this._interpreter = new Game_Interpreter()),
				(this._mapId = 0),
				(this._tilesetId = 0),
				(this._events = []),
				(this._commonEvents = []),
				(this._vehicles = []),
				(this._displayX = 0),
				(this._displayY = 0),
				(this._nameDisplay = !0),
				(this._scrollDirection = 2),
				(this._scrollRest = 0),
				(this._scrollSpeed = 4),
				(this._parallaxName = ''),
				(this._parallaxZero = !1),
				(this._parallaxLoopX = !1),
				(this._parallaxLoopY = !1),
				(this._parallaxSx = 0),
				(this._parallaxSy = 0),
				(this._parallaxX = 0),
				(this._parallaxY = 0),
				(this._battleback1Name = null),
				(this._battleback2Name = null),
				this.createVehicles();
		}
		setup(t) {
			if (!self.$dataMap) throw new Error('The map data is not available');
			(this._mapId = t),
				(this._tilesetId = self.$dataMap.tilesetId),
				(this._displayX = 0),
				(this._displayY = 0),
				this.refereshVehicles(),
				this.setupEvents(),
				this.setupScroll(),
				this.setupParallax(),
				this.setupBattleback(),
				(this._needsRefresh = !1);
		}
		isEventRunning() {
			return this._interpreter.isRunning() || this.isAnyEventStarting();
		}
		tileWidth() {
			return 48;
		}
		tileHeight() {
			return 48;
		}
		mapId() {
			return this._mapId;
		}
		tilesetId() {
			return this._tilesetId;
		}
		displayX() {
			return this._displayX;
		}
		displayY() {
			return this._displayY;
		}
		parallaxName() {
			return this._parallaxName;
		}
		battleback1Name() {
			return this._battleback1Name;
		}
		battleback2Name() {
			return this._battleback2Name;
		}
		requestRefresh(t) {
			this._needsRefresh = !0;
		}
		isNameDisplayEnabled() {
			return this._nameDisplay;
		}
		disableNameDisplay() {
			this._nameDisplay = !1;
		}
		enableNameDisplay() {
			this._nameDisplay = !0;
		}
		createVehicles() {
			(this._vehicles = []),
				(this._vehicles[0] = new Game_Vehicle('boat')),
				(this._vehicles[1] = new Game_Vehicle('ship')),
				(this._vehicles[2] = new Game_Vehicle('airship'));
		}
		refereshVehicles() {
			this._vehicles.forEach((t) => {
				t.refresh();
			});
		}
		vehicles() {
			return this._vehicles;
		}
		vehicle(t) {
			return 0 === t || 'boat' === t
				? this.boat()
				: 1 === t || 'ship' === t
				? this.ship()
				: 2 === t || 'airship' === t
				? this.airship()
				: null;
		}
		boat() {
			return this._vehicles[0];
		}
		ship() {
			return this._vehicles[1];
		}
		airship() {
			return this._vehicles[2];
		}
		setupEvents() {
			this._events = [];
			for (let t = 0; t < self.$dataMap.events.length; t++)
				self.$dataMap.events[t] &&
					(this._events[t] = new Game_Event(this._mapId, t));
			(this._commonEvents = this.parallelCommonEvents().map(
				({ id: t }) => new Game_CommonEvent(t)
			)),
				this.refreshTileEvents();
		}
		events() {
			return this._events.filter((t) => !!t);
		}
		event(t) {
			return this._events[t];
		}
		eraseEvent(t) {
			this._events[t].erase();
		}
		parallelCommonEvents() {
			return self.$dataCommonEvents.filter((t) => t && 2 === t.trigger);
		}
		setupScroll() {
			(this._scrollDirection = 2),
				(this._scrollRest = 0),
				(this._scrollSpeed = 4);
		}
		setupParallax() {
			(this._parallaxName = self.$dataMap.parallaxName || ''),
				(this._parallaxZero = ImageManager.isZeroParallax(this._parallaxName)),
				(this._parallaxLoopX = self.$dataMap.parallaxLoopX),
				(this._parallaxLoopY = self.$dataMap.parallaxLoopY),
				(this._parallaxSx = self.$dataMap.parallaxSx),
				(this._parallaxSy = self.$dataMap.parallaxSy),
				(this._parallaxX = 0),
				(this._parallaxY = 0);
		}
		setupBattleback() {
			self.$dataMap.specifyBattleback
				? ((this._battleback1Name = self.$dataMap.battleback1Name),
				  (this._battleback2Name = self.$dataMap.battleback2Name))
				: ((this._battleback1Name = null), (this._battleback2Name = null));
		}
		setDisplayPos(t, e) {
			if (this.isLoopHorizontal())
				(this._displayX = t.mod(this.width())), (this._parallaxX = t);
			else {
				const e = this.width() - this.screenTileX();
				(this._displayX = e < 0 ? e / 2 : t.clamp(0, e)),
					(this._parallaxX = this._displayX);
			}
			if (this.isLoopVertical())
				(this._displayY = e.mod(this.height())), (this._parallaxY = e);
			else {
				const t = this.height() - this.screenTileY();
				(this._displayY = t < 0 ? t / 2 : e.clamp(0, t)),
					(this._parallaxY = this._displayY);
			}
		}
		parallaxOx() {
			return this._parallaxZero
				? this._parallaxX * this.tileWidth()
				: this._parallaxLoopX
				? (this._parallaxX * this.tileWidth()) / 2
				: 0;
		}
		parallaxOy() {
			return this._parallaxZero
				? this._parallaxY * this.tileHeight()
				: this._parallaxLoopY
				? (this._parallaxY * this.tileHeight()) / 2
				: 0;
		}
		tileset() {
			return self.$dataTilesets[this._tilesetId];
		}
		tilesetFlags() {
			const t = this.tileset();
			return t ? t.flags : [];
		}
		displayName() {
			return self.$dataMap.displayName;
		}
		width() {
			return self.$dataMap.width;
		}
		height() {
			return self.$dataMap.height;
		}
		data() {
			return self.$dataMap.data;
		}
		isLoopHorizontal() {
			return 2 === self.$dataMap.scrollType || 3 === self.$dataMap.scrollType;
		}
		isLoopVertical() {
			return 1 === self.$dataMap.scrollType || 3 === self.$dataMap.scrollType;
		}
		isDashDisabled() {
			return self.$dataMap.disableDashing;
		}
		encounterList() {
			return self.$dataMap.encounterList;
		}
		encounterStep() {
			return self.$dataMap.encounterStep;
		}
		isOverworld() {
			return this.tileset() && 0 === this.tileset().mode;
		}
		screenTileX() {
			return Graphics.width / this.tileWidth();
		}
		screenTileY() {
			return Graphics.height / this.tileHeight();
		}
		adjustX(t) {
			return this.isLoopHorizontal() &&
				t < this._displayX - (this.width() - this.screenTileX()) / 2
				? t - this._displayX + self.$dataMap.width
				: t - this._displayX;
		}
		adjustY(t) {
			return this.isLoopVertical() &&
				t < this._displayY - (this.height() - this.screenTileY()) / 2
				? t - this._displayY + self.$dataMap.height
				: t - this._displayY;
		}
		roundX(t) {
			return this.isLoopHorizontal() ? t.mod(this.width()) : t;
		}
		roundY(t) {
			return this.isLoopVertical() ? t.mod(this.height()) : t;
		}
		xWithDirection(t, e) {
			return t + (6 === e ? 1 : 4 === e ? -1 : 0);
		}
		yWithDirection(t, e) {
			return t + (2 === e ? 1 : 8 === e ? -1 : 0);
		}
		roundXWithDirection(t, e) {
			return this.roundX(t + (6 === e ? 1 : 4 === e ? -1 : 0));
		}
		roundYWithDirection(t, e) {
			return this.roundY(t + (2 === e ? 1 : 8 === e ? -1 : 0));
		}
		deltaX(t, e) {
			let i = t - e;
			return (
				this.isLoopHorizontal() &&
					Math.abs(i) > this.width() / 2 &&
					(i < 0 ? (i += this.width()) : (i -= this.width())),
				i
			);
		}
		deltaY(t, e) {
			let i = t - e;
			return (
				this.isLoopVertical() &&
					Math.abs(i) > this.height() / 2 &&
					(i < 0 ? (i += this.height()) : (i -= this.height())),
				i
			);
		}
		distance(t, e, i, r) {
			return Math.abs(this.deltaX(t, i)) + Math.abs(this.deltaY(e, r));
		}
		canvasToMapX(t) {
			const e = this.tileWidth(),
				i = this._displayX * e,
				r = Math.floor((i + t) / e);
			return this.roundX(r);
		}
		canvasToMapY(t) {
			const e = this.tileHeight(),
				i = this._displayY * e,
				r = Math.floor((i + t) / e);
			return this.roundY(r);
		}
		autoplay() {
			self.$dataMap.autoplayBgm &&
				(self.$gamePlayer.isInVehicle()
					? self.$gameSystem.saveWalkingBgm2()
					: AudioManager.playBgm(self.$dataMap.bgm)),
				self.$dataMap.autoplayBgs && AudioManager.playBgs(self.$dataMap.bgs);
		}
		refreshIfNeeded() {
			this._needsRefresh && this.refresh();
		}
		refresh() {
			this.events().forEach((t) => {
				t.refresh();
			}),
				this._commonEvents.forEach((t) => {
					t.refresh();
				}),
				this.refreshTileEvents(),
				(this._needsRefresh = !1);
		}
		refreshTileEvents() {
			this.tileEvents = this.events().filter((t) => t.isTile());
		}
		eventsXy(t, e) {
			return this.events().filter((i) => i.pos(t, e));
		}
		eventsXyNt(t, e) {
			return this.events().filter((i) => i.posNt(t, e));
		}
		tileEventsXy(t, e) {
			return this.tileEvents.filter((i) => i.posNt(t, e));
		}
		eventIdXy(t, e) {
			const i = this.eventsXy(t, e);
			return 0 === i.length ? 0 : i[0].eventId();
		}
		scrollDown(t) {
			if (this.isLoopVertical())
				(this._displayY += t),
					(this._displayY %= self.$dataMap.height),
					this._parallaxLoopY && (this._parallaxY += t);
			else if (this.height() >= this.screenTileY()) {
				const e = this._displayY;
				(this._displayY = Math.min(
					this._displayY + t,
					this.height() - this.screenTileY()
				)),
					(this._parallaxY += this._displayY - e);
			}
		}
		scrollLeft(t) {
			if (this.isLoopHorizontal())
				(this._displayX += self.$dataMap.width - t),
					(this._displayX %= self.$dataMap.width),
					this._parallaxLoopX && (this._parallaxX -= t);
			else if (this.width() >= this.screenTileX()) {
				const e = this._displayX;
				(this._displayX = Math.max(this._displayX - t, 0)),
					(this._parallaxX += this._displayX - e);
			}
		}
		scrollRight(t) {
			if (this.isLoopHorizontal())
				(this._displayX += t),
					(this._displayX %= self.$dataMap.width),
					this._parallaxLoopX && (this._parallaxX += t);
			else if (this.width() >= this.screenTileX()) {
				const e = this._displayX;
				(this._displayX = Math.min(
					this._displayX + t,
					this.width() - this.screenTileX()
				)),
					(this._parallaxX += this._displayX - e);
			}
		}
		scrollUp(t) {
			if (this.isLoopVertical())
				(this._displayY += self.$dataMap.height - t),
					(this._displayY %= self.$dataMap.height),
					this._parallaxLoopY && (this._parallaxY -= t);
			else if (this.height() >= this.screenTileY()) {
				const e = this._displayY;
				(this._displayY = Math.max(this._displayY - t, 0)),
					(this._parallaxY += this._displayY - e);
			}
		}
		isValid(t, e) {
			return t >= 0 && t < this.width() && e >= 0 && e < this.height();
		}
		checkPassage(t, e, i) {
			const r = this.tilesetFlags(),
				s = this.allTiles(t, e);
			for (let t = 0; t < s.length; t++) {
				const e = r[s[t]];
				if (0 == (16 & e)) {
					if (0 == (e & i)) return !0;
					if ((e & i) === i) return !1;
				}
			}
			return !1;
		}
		tileId(t, e, i) {
			const r = self.$dataMap.width,
				s = self.$dataMap.height;
			return self.$dataMap.data[(i * s + e) * r + t] || 0;
		}
		layeredTiles(t, e) {
			const i = [];
			for (let r = 0; r < 4; r++) i.push(this.tileId(t, e, 3 - r));
			return i;
		}
		allTiles(t, e) {
			return this.tileEventsXy(t, e)
				.map((t) => t.tileId())
				.concat(this.layeredTiles(t, e));
		}
		autotileType(t, e, i) {
			const r = this.tileId(t, e, i);
			return r >= 2048 ? Math.floor((r - 2048) / 48) : -1;
		}
		isPassable(t, e, i) {
			return this.checkPassage(t, e, (1 << (i / 2 - 1)) & 15);
		}
		isBoatPassable(t, e) {
			return this.checkPassage(t, e, 512);
		}
		isShipPassable(t, e) {
			return this.checkPassage(t, e, 1024);
		}
		isAirshipLandOk(t, e) {
			return this.checkPassage(t, e, 2048) && this.checkPassage(t, e, 15);
		}
		checkLayeredTilesFlags(t, e, i) {
			const r = this.tilesetFlags();
			return this.layeredTiles(t, e).some((t) => 0 != (r[t] & i));
		}
		isLadder(t, e) {
			return this.isValid(t, e) && this.checkLayeredTilesFlags(t, e, 32);
		}
		isBush(t, e) {
			return this.isValid(t, e) && this.checkLayeredTilesFlags(t, e, 64);
		}
		isCounter(t, e) {
			return this.isValid(t, e) && this.checkLayeredTilesFlags(t, e, 128);
		}
		isDamageFloor(t, e) {
			return this.isValid(t, e) && this.checkLayeredTilesFlags(t, e, 256);
		}
		terrainTag(t, e) {
			if (this.isValid(t, e)) {
				const i = this.tilesetFlags(),
					r = this.layeredTiles(t, e);
				for (let t = 0; t < r.length; t++) {
					const e = i[r[t]] >> 12;
					if (e > 0) return e;
				}
			}
			return 0;
		}
		regionId(t, e) {
			return this.isValid(t, e) ? this.tileId(t, e, 5) : 0;
		}
		startScroll(t, e, i) {
			(this._scrollDirection = t),
				(this._scrollRest = e),
				(this._scrollSpeed = i);
		}
		isScrolling() {
			return this._scrollRest > 0;
		}
		update(t) {
			this.refreshIfNeeded(),
				t && this.updateInterpreter(),
				this.updateScroll(),
				this.updateEvents(),
				this.updateVehicles(),
				this.updateParallax();
		}
		updateScroll() {
			if (this.isScrolling()) {
				const t = this._displayX,
					e = this._displayY;
				this.doScroll(this._scrollDirection, this.scrollDistance()),
					this._displayX === t && this._displayY === e
						? (this._scrollRest = 0)
						: (this._scrollRest -= this.scrollDistance());
			}
		}
		scrollDistance() {
			return Math.pow(2, this._scrollSpeed) / 256;
		}
		doScroll(t, e) {
			switch (t) {
				case 2:
					this.scrollDown(e);
					break;
				case 4:
					this.scrollLeft(e);
					break;
				case 6:
					this.scrollRight(e);
					break;
				case 8:
					this.scrollUp(e);
			}
		}
		updateEvents() {
			this.events().forEach((t) => {
				t.update();
			}),
				this._commonEvents.forEach((t) => {
					t.update();
				});
		}
		updateVehicles() {
			this._vehicles.forEach((t) => {
				t.update();
			});
		}
		updateParallax() {
			this._parallaxLoopX &&
				(this._parallaxX += this._parallaxSx / this.tileWidth() / 2),
				this._parallaxLoopY &&
					(this._parallaxY += this._parallaxSy / this.tileHeight() / 2);
		}
		changeTileset(t) {
			(this._tilesetId = t), this.refresh();
		}
		changeBattleback(t, e) {
			(this._battleback1Name = t), (this._battleback2Name = e);
		}
		changeParallax(t, e, i, r, s) {
			(this._parallaxName = t),
				(this._parallaxZero = ImageManager.isZeroParallax(this._parallaxName)),
				this._parallaxLoopX && !e && (this._parallaxX = 0),
				this._parallaxLoopY && !i && (this._parallaxY = 0),
				(this._parallaxLoopX = e),
				(this._parallaxLoopY = i),
				(this._parallaxSx = r),
				(this._parallaxSy = s);
		}
		updateInterpreter() {
			for (;;) {
				if ((this._interpreter.update(), this._interpreter.isRunning())) return;
				if (
					(this._interpreter.eventId() > 0 &&
						(this.unlockEvent(this._interpreter.eventId()),
						this._interpreter.clear()),
					!this.setupStartingEvent())
				)
					return;
			}
		}
		unlockEvent(t) {
			this._events[t] && this._events[t].unlock();
		}
		setupStartingEvent() {
			return (
				this.refreshIfNeeded(),
				!!(
					this._interpreter.setupReservedCommonEvent() ||
					this.setupTestEvent() ||
					this.setupStartingMapEvent() ||
					this.setupAutorunCommonEvent()
				)
			);
		}
		setupTestEvent() {
			return (
				!!self.$testEvent &&
				(this._interpreter.setup(self.$testEvent, 0),
				this._interpreter.setEventInfo({ eventType: 'test_event' }),
				(self.$testEvent = null),
				!0)
			);
		}
		setupStartingMapEvent() {
			const t = this.events();
			for (const e of t)
				if (e.isStarting())
					return (
						e.clearStartingFlag(),
						this._interpreter.setup(e.list(), e.eventId()),
						this._interpreter.setEventInfo(e.getEventInfo()),
						!0
					);
			return !1;
		}
		setupAutorunCommonEvent() {
			for (let t = 0; t < self.$dataCommonEvents.length; t++) {
				const e = self.$dataCommonEvents[t];
				if (e && 1 === e.trigger && self.$gameSwitches.value(e.switchId))
					return (
						this._interpreter.setup(e.list),
						this._interpreter.setEventInfo({
							eventType: 'common_event',
							commonEventId: t,
						}),
						!0
					);
			}
			return !1;
		}
		isAnyEventStarting() {
			return this.events().some((t) => t.isStarting());
		}
	}
	class Game_Follower extends Game_Character {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize(t) {
			super.initialize(),
				(this._memberIndex = t),
				this.setTransparent(self.$dataSystem.optTransparent),
				this.setThrough(!0);
		}
		refresh() {
			const t = this.isVisible() ? this.actor().characterName() : '',
				e = this.isVisible() ? this.actor().characterIndex() : 0;
			this.setImage(t, e);
		}
		actor() {
			return self.$gameParty.battleMembers()[this._memberIndex];
		}
		isVisible() {
			return this.actor() && self.$gamePlayer.followers().isVisible();
		}
		update() {
			super.update(),
				this.setMoveSpeed(self.$gamePlayer.realMoveSpeed()),
				this.setOpacity(self.$gamePlayer.opacity()),
				this.setBlendMode(self.$gamePlayer.blendMode()),
				this.setWalkAnime(self.$gamePlayer.hasWalkAnime()),
				this.setStepAnime(self.$gamePlayer.hasStepAnime()),
				this.setDirectionFix(self.$gamePlayer.isDirectionFixed()),
				this.setTransparent(self.$gamePlayer.isTransparent());
		}
		chaseCharacter({ x: t, y: e }) {
			const i = this.deltaXFrom(t),
				r = this.deltaYFrom(e);
			0 !== i && 0 !== r
				? this.moveDiagonally(i > 0 ? 4 : 6, r > 0 ? 8 : 2)
				: 0 !== i
				? this.moveStraight(i > 0 ? 4 : 6)
				: 0 !== r && this.moveStraight(r > 0 ? 8 : 2),
				this.setMoveSpeed(self.$gamePlayer.realMoveSpeed());
		}
	}
	class Game_Followers {
		constructor(...t) {
			this.initialize(...t);
		}
		initialize() {
			(this._visible = self.$dataSystem.optFollowers),
				(this._gathering = !1),
				(this._data = []);
			for (let t = 1; t < self.$gameParty.maxBattleMembers(); t++)
				this._data.push(new Game_Follower(t));
		}
		isVisible() {
			return this._visible;
		}
		show() {
			this._visible = !0;
		}
		hide() {
			this._visible = !1;
		}
		follower(t) {
			return this._data[t];
		}
		forEach(t, e) {
			this._data.forEach(t, e);
		}
		reverseEach(t, e) {
			this._data.reverse(), this._data.forEach(t, e), this._data.reverse();
		}
		refresh() {
			this.forEach((t) => t.refresh(), this);
		}
		update() {
			this.areGathering() &&
				(this.areMoving() || this.updateMove(),
				this.areGathered() && (this._gathering = !1)),
				this.forEach((t) => {
					t.update();
				}, this);
		}
		updateMove() {
			for (let t = this._data.length - 1; t >= 0; t--) {
				const e = t > 0 ? this._data[t - 1] : self.$gamePlayer;
				this._data[t].chaseCharacter(e);
			}
		}
		jumpAll() {
			if (self.$gamePlayer.isJumping())
				for (const t of this._data) {
					const e = self.$gamePlayer.deltaXFrom(t.x),
						i = self.$gamePlayer.deltaYFrom(t.y);
					t.jump(e, i);
				}
		}
		synchronize(t, e, i) {
			this.forEach((r) => {
				r.locate(t, e), r.setDirection(i);
			}, this);
		}
		gather() {
			this._gathering = !0;
		}
		areGathering() {
			return this._gathering;
		}
		visibleFollowers() {
			return this._data.filter((t) => t.isVisible(), this);
		}
		areMoving() {
			return this.visibleFollowers().some((t) => t.isMoving(), this);
		}
		areGathered() {
			return this.visibleFollowers().every(
				(t) => !t.isMoving() && t.pos(self.$gamePlayer.x, self.$gamePlayer.y),
				this
			);
		}
		isSomeoneCollided(t, e) {
			return this.visibleFollowers().some((i) => i.pos(t, e), this);
		}
	}
	class Game_Player extends Game_Character {
		constructor(...t) {
			super(...t), this.initialize(...t);
		}
		initialize() {
			super.initialize(), this.setTransparent(self.$dataSystem.optTransparent);
		}
		initMembers() {
			super.initMembers(),
				(this._vehicleType = 'walk'),
				(this._vehicleGettingOn = !1),
				(this._vehicleGettingOff = !1),
				(this._dashing = !1),
				(this._needsMapReload = !1),
				(this._transferring = !1),
				(this._newMapId = 0),
				(this._newX = 0),
				(this._newY = 0),
				(this._newDirection = 0),
				(this._fadeType = 0),
				(this._followers = new Game_Followers()),
				(this._encounterCount = 0);
		}
		clearTransferInfo() {
			(this._transferring = !1),
				(this._newMapId = 0),
				(this._newX = 0),
				(this._newY = 0),
				(this._newDirection = 0);
		}
		followers() {
			return this._followers;
		}
		refresh() {
			const t = self.$gameParty.leader(),
				e = t ? t.characterName() : '',
				i = t ? t.characterIndex() : 0;
			this.setImage(e, i), this._followers.refresh();
		}
		isStopping() {
			return (
				!this._vehicleGettingOn &&
				!this._vehicleGettingOff &&
				Game_Character.prototype.isStopping.call(this)
			);
		}
		reserveTransfer(t, e, i, r, s) {
			(this._transferring = !0),
				(this._newMapId = t),
				(this._newX = e),
				(this._newY = i),
				(this._newDirection = r),
				(this._fadeType = s);
		}
		requestMapReload() {
			this._needsMapReload = !0;
		}
		isTransferring() {
			return this._transferring;
		}
		newMapId() {
			return this._newMapId;
		}
		fadeType() {
			return this._fadeType;
		}
		performTransfer() {
			this.isTransferring() &&
				(this.setDirection(this._newDirection),
				(this._newMapId !== self.$gameMap.mapId() || this._needsMapReload) &&
					(self.$gameMap.setup(this._newMapId), (this._needsMapReload = !1)),
				this.locate(this._newX, this._newY),
				this.refresh(),
				DataManager$1.autoSaveGame(),
				this.clearTransferInfo());
		}
		isMapPassable(t, e, i) {
			const r = this.vehicle();
			return r
				? r.isMapPassable(t, e, i)
				: Game_Character.prototype.isMapPassable.call(this, t, e, i);
		}
		vehicle() {
			return self.$gameMap.vehicle(this._vehicleType);
		}
		isInBoat() {
			return 'boat' === this._vehicleType;
		}
		isInShip() {
			return 'ship' === this._vehicleType;
		}
		isInAirship() {
			return 'airship' === this._vehicleType;
		}
		isInVehicle() {
			return this.isInBoat() || this.isInShip() || this.isInAirship();
		}
		isNormal() {
			return 'walk' === this._vehicleType && !this.isMoveRouteForcing();
		}
		isDashing() {
			return this._dashing;
		}
		isDebugThrough() {
			return Input.isPressed('control') && self.$gameTemp.isPlaytest();
		}
		isCollided(t, e) {
			return (
				!this.isThrough() &&
				(this.pos(t, e) || this._followers.isSomeoneCollided(t, e))
			);
		}
		centerX() {
			return (Graphics.width / self.$gameMap.tileWidth() - 1) / 2;
		}
		centerY() {
			return (Graphics.height / self.$gameMap.tileHeight() - 1) / 2;
		}
		center(t, e) {
			return self.$gameMap.setDisplayPos(
				t - this.centerX(),
				e - this.centerY()
			);
		}
		locate(t, e) {
			super.locate(t, e),
				this.center(t, e),
				this.makeEncounterCount(),
				this.isInVehicle() && this.vehicle().refresh(),
				this._followers.synchronize(t, e, this.direction());
		}
		increaseSteps() {
			super.increaseSteps(), this.isNormal() && self.$gameParty.increaseSteps();
		}
		makeEncounterCount() {
			const t = self.$gameMap.encounterStep();
			this._encounterCount = Math.randomInt(t) + Math.randomInt(t) + 1;
		}
		makeEncounterTroopId() {
			const t = [];
			let e = 0;
			if (
				(self.$gameMap.encounterList().forEach(function (i) {
					this.meetsEncounterConditions(i) && (t.push(i), (e += i.weight));
				}, this),
				e > 0)
			) {
				let i = Math.randomInt(e);
				for (let e = 0; e < t.length; e++)
					if (((i -= t[e].weight), i < 0)) return t[e].troopId;
			}
			return 0;
		}
		meetsEncounterConditions({ regionSet: t }) {
			return 0 === t.length || t.contains(this.regionId());
		}
		executeEncounter() {
			if (!self.$gameMap.isEventRunning() && this._encounterCount <= 0) {
				this.makeEncounterCount();
				const t = this.makeEncounterTroopId();
				return (
					!!self.$dataTroops[t] &&
					(BattleManager.setup(t, !0, !1), BattleManager.onEncounter(), !0)
				);
			}
			return !1;
		}
		startMapEvent(t, e, i, r) {
			self.$gameMap.isEventRunning() ||
				self.$gameMap.eventsXy(t, e).forEach((t) => {
					t.isTriggerIn(i) && t.isNormalPriority() === r && t.start();
				});
		}
		moveByInput() {
			if (!this.isMoving() && this.canMove()) {
				let t = this.getInputDirection();
				if (t > 0) self.$gameTemp.clearDestination();
				else if (self.$gameTemp.isDestinationValid()) {
					const e = self.$gameTemp.destinationX(),
						i = self.$gameTemp.destinationY();
					t = this.findDirectionTo(e, i);
				}
				t > 0 && this.executeMove(t);
			}
		}
		canMove() {
			return !(
				self.$gameMap.isEventRunning() ||
				self.$gameMessage.isBusy() ||
				this.isMoveRouteForcing() ||
				this.areFollowersGathering() ||
				this._vehicleGettingOn ||
				this._vehicleGettingOff ||
				(this.isInVehicle() && !this.vehicle().canMove())
			);
		}
		getInputDirection() {
			return Input.dir4;
		}
		executeMove(t) {
			this.moveStraight(t);
		}
		update(t) {
			const e = this.scrolledX(),
				i = this.scrolledY(),
				r = this.isMoving();
			this.updateDashing(),
				t && this.moveByInput(),
				super.update(),
				this.updateScroll(e, i),
				this.updateVehicle(),
				this.isMoving() || this.updateNonmoving(r),
				this._followers.update();
		}
		updateDashing() {
			this.isMoving() ||
				(!this.canMove() || this.isInVehicle() || self.$gameMap.isDashDisabled()
					? (this._dashing = !1)
					: (this._dashing =
							this.isDashButtonPressed() ||
							self.$gameTemp.isDestinationValid()));
		}
		isDashButtonPressed() {
			const t = Input.isPressed('shift');
			return ConfigManager.alwaysDash ? !t : t;
		}
		updateScroll(t, e) {
			const i = t,
				r = e,
				s = this.scrolledX(),
				n = this.scrolledY();
			n > r && n > this.centerY() && self.$gameMap.scrollDown(n - r),
				s < i && s < this.centerX() && self.$gameMap.scrollLeft(i - s),
				s > i && s > this.centerX() && self.$gameMap.scrollRight(s - i),
				n < r && n < this.centerY() && self.$gameMap.scrollUp(r - n);
		}
		updateVehicle() {
			this.isInVehicle() &&
				!this.areFollowersGathering() &&
				(this._vehicleGettingOn
					? this.updateVehicleGetOn()
					: this._vehicleGettingOff
					? this.updateVehicleGetOff()
					: this.vehicle().syncWithPlayer());
		}
		updateVehicleGetOn() {
			this.areFollowersGathering() ||
				this.isMoving() ||
				(this.setDirection(this.vehicle().direction()),
				this.setMoveSpeed(this.vehicle().moveSpeed()),
				(this._vehicleGettingOn = !1),
				this.setTransparent(!0),
				this.isInAirship() && this.setThrough(!0),
				this.vehicle().getOn());
		}
		updateVehicleGetOff() {
			!this.areFollowersGathering() &&
				this.vehicle().isLowest() &&
				((this._vehicleGettingOff = !1),
				(this._vehicleType = 'walk'),
				this.setTransparent(!1));
		}
		updateNonmoving(t) {
			if (!self.$gameMap.isEventRunning()) {
				if (
					t &&
					(self.$gameParty.onPlayerWalk(),
					this.checkEventTriggerHere([1, 2]),
					self.$gameMap.setupStartingEvent())
				)
					return;
				if (this.triggerAction()) return;
				t ? this.updateEncounterCount() : self.$gameTemp.clearDestination();
			}
		}
		triggerAction() {
			if (this.canMove()) {
				if (this.triggerButtonAction()) return !0;
				if (this.triggerTouchAction()) return !0;
			}
			return !1;
		}
		triggerButtonAction() {
			if (Input.isTriggered('ok')) {
				if (this.getOnOffVehicle()) return !0;
				if (
					(this.checkEventTriggerHere([0]), self.$gameMap.setupStartingEvent())
				)
					return !0;
				if (
					(this.checkEventTriggerThere([0, 1, 2]),
					self.$gameMap.setupStartingEvent())
				)
					return !0;
			}
			return !1;
		}
		triggerTouchAction() {
			if (self.$gameTemp.isDestinationValid()) {
				const t = this.direction(),
					e = this.x,
					i = this.y,
					r = self.$gameMap.roundXWithDirection(e, t),
					s = self.$gameMap.roundYWithDirection(i, t),
					n = self.$gameMap.roundXWithDirection(r, t),
					a = self.$gameMap.roundYWithDirection(s, t),
					o = self.$gameTemp.destinationX(),
					h = self.$gameTemp.destinationY();
				if (o === e && h === i) return this.triggerTouchActionD1(e, i);
				if (o === r && h === s) return this.triggerTouchActionD2(r, s);
				if (o === n && h === a) return this.triggerTouchActionD3(r, s);
			}
			return !1;
		}
		triggerTouchActionD1(t, e) {
			return (
				!!(
					self.$gameMap.airship().pos(t, e) &&
					TouchInput.isTriggered() &&
					this.getOnOffVehicle()
				) ||
				(this.checkEventTriggerHere([0]), self.$gameMap.setupStartingEvent())
			);
		}
		triggerTouchActionD2(t, e) {
			return (
				!(
					(!self.$gameMap.boat().pos(t, e) &&
						!self.$gameMap.ship().pos(t, e)) ||
					!TouchInput.isTriggered() ||
					!this.getOnVehicle()
				) ||
				!(
					(!this.isInBoat() && !this.isInShip()) ||
					!TouchInput.isTriggered() ||
					!this.getOffVehicle()
				) ||
				(this.checkEventTriggerThere([0, 1, 2]),
				self.$gameMap.setupStartingEvent())
			);
		}
		triggerTouchActionD3(t, e) {
			return (
				self.$gameMap.isCounter(t, e) && this.checkEventTriggerThere([0, 1, 2]),
				self.$gameMap.setupStartingEvent()
			);
		}
		updateEncounterCount() {
			this.canEncounter() &&
				(this._encounterCount -= this.encounterProgressValue());
		}
		canEncounter() {
			return (
				!self.$gameParty.hasEncounterNone() &&
				self.$gameSystem.isEncounterEnabled() &&
				!this.isInAirship() &&
				!this.isMoveRouteForcing() &&
				!this.isDebugThrough()
			);
		}
		encounterProgressValue() {
			let t = self.$gameMap.isBush(this.x, this.y) ? 2 : 1;
			return (
				self.$gameParty.hasEncounterHalf() && (t *= 0.5),
				this.isInShip() && (t *= 0.5),
				t
			);
		}
		checkEventTriggerHere(t) {
			this.canStartLocalEvents() && this.startMapEvent(this.x, this.y, t, !1);
		}
		checkEventTriggerThere(t) {
			if (this.canStartLocalEvents()) {
				const e = this.direction(),
					i = this.x,
					r = this.y,
					s = self.$gameMap.roundXWithDirection(i, e),
					n = self.$gameMap.roundYWithDirection(r, e);
				if (
					(this.startMapEvent(s, n, t, !0),
					!self.$gameMap.isAnyEventStarting() && self.$gameMap.isCounter(s, n))
				) {
					const i = self.$gameMap.roundXWithDirection(s, e),
						r = self.$gameMap.roundYWithDirection(n, e);
					this.startMapEvent(i, r, t, !0);
				}
			}
		}
		checkEventTriggerTouch(t, e) {
			this.canStartLocalEvents() && this.startMapEvent(t, e, [1, 2], !0);
		}
		canStartLocalEvents() {
			return !this.isInAirship();
		}
		getOnOffVehicle() {
			return this.isInVehicle() ? this.getOffVehicle() : this.getOnVehicle();
		}
		getOnVehicle() {
			const t = this.direction(),
				e = this.x,
				i = this.y,
				r = self.$gameMap.roundXWithDirection(e, t),
				s = self.$gameMap.roundYWithDirection(i, t);
			return (
				self.$gameMap.airship().pos(e, i)
					? (this._vehicleType = 'airship')
					: self.$gameMap.ship().pos(r, s)
					? (this._vehicleType = 'ship')
					: self.$gameMap.boat().pos(r, s) && (this._vehicleType = 'boat'),
				this.isInVehicle() &&
					((this._vehicleGettingOn = !0),
					this.isInAirship() || this.forceMoveForward(),
					this.gatherFollowers()),
				this._vehicleGettingOn
			);
		}
		getOffVehicle() {
			return (
				this.vehicle().isLandOk(this.x, this.y, this.direction()) &&
					(this.isInAirship() && this.setDirection(2),
					this._followers.synchronize(this.x, this.y, this.direction()),
					this.vehicle().getOff(),
					this.isInAirship() ||
						(this.forceMoveForward(), this.setTransparent(!1)),
					(this._vehicleGettingOff = !0),
					this.setMoveSpeed(4),
					this.setThrough(!1),
					this.makeEncounterCount(),
					this.gatherFollowers()),
				this._vehicleGettingOff
			);
		}
		forceMoveForward() {
			this.setThrough(!0), this.moveForward(), this.setThrough(!1);
		}
		isOnDamageFloor() {
			return self.$gameMap.isDamageFloor(this.x, this.y) && !this.isInAirship();
		}
		moveStraight(t) {
			this.canPass(this.x, this.y, t) && this._followers.updateMove(),
				super.moveStraight(t);
		}
		moveDiagonally(t, e) {
			this.canPassDiagonally(this.x, this.y, t, e) &&
				this._followers.updateMove(),
				super.moveDiagonally(t, e);
		}
		jump(t, e) {
			super.jump(t, e), this._followers.jumpAll();
		}
		showFollowers() {
			this._followers.show();
		}
		hideFollowers() {
			this._followers.hide();
		}
		gatherFollowers() {
			this._followers.gather();
		}
		areFollowersGathering() {
			return this._followers.areGathering();
		}
		areFollowersGathered() {
			return this._followers.areGathered();
		}
	}
	class DataManager$1 {
		constructor() {
			throw new Error('This is a static class');
		}
		static loadDatabase() {
			const t = this.isBattleTest() || this.isEventTest() ? 'Test_' : '';
			for (let e = 0; e < this._databaseFiles.length; e++) {
				const i = this._databaseFiles[e].name,
					r = this._databaseFiles[e].src;
				this.loadDataFile(i, t + r);
			}
			this.isEventTest() && this.loadDataFile('$testEvent', `${t}Event.json`);
		}
		static loadDataFile(t, e) {
			const i = new XMLHttpRequest(),
				r = `data/${e}`;
			i.open('GET', r),
				i.overrideMimeType('application/json'),
				(i.onload = () => {
					i.status < 400 &&
						((window[t] = JSON.parse(i.responseText)),
						DataManager$1.onLoad(window[t]));
				}),
				(i.onerror =
					this._mapLoader ||
					(() => {
						DataManager$1._errorUrl = DataManager$1._errorUrl || r;
					})),
				(window[t] = null),
				i.send();
		}
		static isDatabaseLoaded() {
			this.checkError();
			for (let t = 0; t < this._databaseFiles.length; t++)
				if (!window[this._databaseFiles[t].name]) return !1;
			return !0;
		}
		static loadMapData(t) {
			if (t > 0) {
				const e = 'Map%1.json'.format(t.padZero(3));
				(this._mapLoader = ResourceHandler.createLoader(
					`data/${e}`,
					this.loadDataFile.bind(this, '$dataMap', e)
				)),
					this.loadDataFile('$dataMap', e);
			} else this.makeEmptyMap();
		}
		static isMapLoaded() {
			return this.checkError(), !!self.$dataMap;
		}
		static onLoad(t) {
			let e;
			if (
				(t === self.$dataMap
					? (this.extractMetadata(t), (e = t.events))
					: (e = t),
				Array.isArray(e))
			)
				for (const t of e) t && void 0 !== t.note && this.extractMetadata(t);
			t === self.$dataSystem &&
				((Decrypter.hasEncryptedImages = !!t.hasEncryptedImages),
				(Decrypter.hasEncryptedAudio = !!t.hasEncryptedAudio),
				Scene_Boot.loadSystemImages());
		}
		static setupNewGame() {
			this.createGameObjects(),
				this.selectSavefileForNewGame(),
				self.$gameParty.setupStartingMembers(),
				self.$gamePlayer.reserveTransfer(
					self.$dataSystem.startMapId,
					self.$dataSystem.startX,
					self.$dataSystem.startY
				),
				(Graphics.frameCount = 0),
				SceneManager.resetFrameCount();
		}
		static setupBattleTest() {
			this.createGameObjects(),
				self.$gameParty.setupBattleTest(),
				BattleManager.setup(self.$dataSystem.testTroopId, !0, !1),
				BattleManager.setBattleTest(!0),
				BattleManager.playBattleBgm();
		}
		static setupEventTest() {
			this.createGameObjects(),
				this.selectSavefileForNewGame(),
				self.$gameParty.setupStartingMembers(),
				self.$gamePlayer.reserveTransfer(-1, 8, 6),
				self.$gamePlayer.setTransparent(!1);
		}
		static loadGlobalInfo() {
			return this._globalInfo
				? this._globalInfo
				: (this.loadGlobalInfoAsync(), null);
		}
		static async loadGlobalInfoAsync() {
			let t;
			try {
				t = await StorageManagerShim.load(0);
			} catch (t) {
				return [];
			}
			if (t) {
				this._globalInfo = JSON.parse(t);
				for (let t = 1; t <= this.maxSavefiles(); t++)
					(await StorageManagerShim.exists(t)) || delete this._globalInfo[t];
			} else this._globalInfo = [];
		}
		static saveGlobalInfo(t) {
			(this._globalInfo = t), StorageManagerShim.save(0, JSON.stringify(t));
		}
		static isThisGameFile(t) {
			const e = this.loadGlobalInfo();
			return !(!e || !e[t]);
		}
		static isAnySavefileExists() {
			const t = this.loadGlobalInfo();
			if (t)
				for (let e = 1; e < t.length; e++)
					if (this.isThisGameFile(e)) return !0;
			return !1;
		}
		static latestSavefileId() {
			const t = this.loadGlobalInfo();
			let e = 1,
				i = 0;
			if (t)
				for (let r = 1; r < t.length; r++)
					this.isThisGameFile(r) &&
						t[r].timestamp > i &&
						((i = t[r].timestamp), (e = r));
			return e;
		}
		static loadAllSavefileImages() {
			const t = this.loadGlobalInfo();
			if (t)
				for (let e = 1; e < t.length; e++)
					if (this.isThisGameFile(e)) {
						const i = t[e];
						this.loadSavefileImages(i);
					}
		}
		static async saveGame(t) {
			try {
				return (
					await StorageManagerShim.backup(t),
					await this.saveGameWithoutRescue(t)
				);
			} catch (t) {
				return !1;
			}
		}
		static async loadGame(t) {
			try {
				return await this.loadGameWithoutRescue(t);
			} catch (t) {
				return !1;
			}
		}
		static loadSavefileInfo(t) {
			const e = this.loadGlobalInfo();
			return e && e[t] ? e[t] : null;
		}
		static lastAccessedSavefileId() {
			return this._lastAccessedId;
		}
		static async saveGameWithoutRescue(t) {
			const e = JsonEx.stringify(this.makeSaveContents());
			e.length, await StorageManagerShim.save(t, e), (this._lastAccessedId = t);
			const i = this.loadGlobalInfo() || [];
			return (i[t] = this.makeSavefileInfo()), await this.saveGlobalInfo(i), !0;
		}
		static async loadGameWithoutRescue(t) {
			if (this.isThisGameFile(t)) {
				const e = await StorageManagerShim.load(t);
				return (
					this.createGameObjects(),
					this.extractSaveContents(JsonEx.parse(e)),
					(this._lastAccessedId = t),
					!0
				);
			}
			return !1;
		}
		static selectSavefileForNewGame() {
			const t = this.loadGlobalInfo();
			if (((this._lastAccessedId = 1), t)) {
				const e = Math.max(0, t.length - 1);
				if (e < this.maxSavefiles()) this._lastAccessedId = e + 1;
				else {
					let e = Number.MAX_VALUE;
					for (let i = 1; i < t.length; i++) {
						if (!t[i]) {
							this._lastAccessedId = i;
							break;
						}
						t[i].timestamp < e &&
							((e = t[i].timestamp), (this._lastAccessedId = i));
					}
				}
			}
		}
		static makeSavefileInfo() {
			const t = {};
			return (
				(t.globalId = this._globalId),
				(t.title = self.$dataSystem.gameTitle),
				(t.characters = self.$gameParty.charactersForSavefile()),
				(t.faces = self.$gameParty.facesForSavefile()),
				(t.playtime = self.$gameSystem.playtimeText()),
				(t.timestamp = Date.now()),
				t
			);
		}
		static setAutoSaveFileId(t) {
			this._autoSaveFileId = t;
		}
		static isAutoSaveFileId(t) {
			return 0 !== this._autoSaveFileId && this._autoSaveFileId === t;
		}
		static autoSaveGame() {
			0 !== this._autoSaveFileId &&
				!this.isEventTest() &&
				self.$gameSystem.isSaveEnabled() &&
				(self.$gameSystem.onBeforeSave(),
				this.saveGame(this._autoSaveFileId) &&
					StorageManagerShim.cleanBackup(this._autoSaveFileId));
		}
		static makeEmptyMap() {
			(self.$dataMap = {}),
				(self.$dataMap.data = []),
				(self.$dataMap.events = []),
				(self.$dataMap.width = 100),
				(self.$dataMap.height = 100),
				(self.$dataMap.scrollType = 3);
		}
		static extractMetadata(t) {
			const e = /<([^<>:]+)(:?)([^>]*)>/g;
			for (t.meta = {}; ; ) {
				const i = e.exec(t.note);
				if (!i) break;
				':' === i[2] ? (t.meta[i[1]] = i[3]) : (t.meta[i[1]] = !0);
			}
		}
		static checkError() {
			if (DataManager$1._errorUrl)
				throw new Error(`Failed to load: ${DataManager$1._errorUrl}`);
		}
		static isBattleTest() {
			return Utils.isOptionValid('btest');
		}
		static isEventTest() {
			return Utils.isOptionValid('etest');
		}
		static isSkill(t) {
			return t && self.$dataSkills.contains(t);
		}
		static isItem(t) {
			return t && self.$dataItems.contains(t);
		}
		static isWeapon(t) {
			return t && self.$dataWeapons.contains(t);
		}
		static isArmor(t) {
			return t && self.$dataArmors.contains(t);
		}
		static createGameObjects() {
			(self.$gameTemp = new Game_Temp()),
				(self.$gameSystem = new Game_System()),
				(self.$gameScreen = new Game_Screen()),
				(self.$gameTimer = new Game_Timer()),
				(self.$gameMessage = new Game_Message()),
				(self.$gameSwitches = new Game_Switches()),
				(self.$gameVariables = new Game_Variables()),
				(self.$gameSelfSwitches = new Game_SelfSwitches()),
				(self.$gameActors = new Game_Actors()),
				(self.$gameParty = new Game_Party()),
				(self.$gameTroop = new Game_Troop()),
				(self.$gameMap = new Game_Map()),
				(self.$gamePlayer = new Game_Player());
		}
		static loadSavefileImages({ characters: t, faces: e }) {
			if (t)
				for (let e = 0; e < t.length; e++)
					ImageManager.reserveCharacter(t[e][0]);
			if (e)
				for (let t = 0; t < e.length; t++) ImageManager.reserveFace(e[t][0]);
		}
		static maxSavefiles() {
			return 20;
		}
		static makeSaveContents() {
			const t = {};
			return (
				(t.system = self.$gameSystem),
				(t.screen = self.$gameScreen),
				(t.timer = self.$gameTimer),
				(t.switches = self.$gameSwitches),
				(t.variables = self.$gameVariables),
				(t.selfSwitches = self.$gameSelfSwitches),
				(t.actors = self.$gameActors),
				(t.party = self.$gameParty),
				(t.map = self.$gameMap),
				(t.player = self.$gamePlayer),
				t
			);
		}
		static extractSaveContents(t) {
			(self.$gameSystem = t.system),
				(self.$gameScreen = t.screen),
				(self.$gameTimer = t.timer),
				(self.$gameSwitches = t.switches),
				(self.$gameVariables = t.variables),
				(self.$gameSelfSwitches = t.selfSwitches),
				(self.$gameActors = t.actors),
				(self.$gameParty = t.party),
				(self.$gameMap = t.map),
				(self.$gamePlayer = t.player);
		}
	}
	(DataManager$1._globalId = 'RPGMV'),
		(DataManager$1._lastAccessedId = 1),
		(DataManager$1._errorUrl = null),
		(DataManager$1._autoSaveFileId = 0),
		(DataManager$1._databaseFiles = [
			{ name: '$dataActors', src: 'Actors.json' },
			{ name: '$dataClasses', src: 'Classes.json' },
			{ name: '$dataSkills', src: 'Skills.json' },
			{ name: '$dataItems', src: 'Items.json' },
			{ name: '$dataWeapons', src: 'Weapons.json' },
			{ name: '$dataArmors', src: 'Armors.json' },
			{ name: '$dataEnemies', src: 'Enemies.json' },
			{ name: '$dataTroops', src: 'Troops.json' },
			{ name: '$dataStates', src: 'States.json' },
			{ name: '$dataAnimations', src: 'Animations.json' },
			{ name: '$dataTilesets', src: 'Tilesets.json' },
			{ name: '$dataCommonEvents', src: 'CommonEvents.json' },
			{ name: '$dataSystem', src: 'System.json' },
			{ name: '$dataMapInfos', src: 'MapInfos.json' },
		]);
	let $dataActors = null,
		$dataClasses = null,
		$dataSkills = null,
		$dataItems = null,
		$dataWeapons = null,
		$dataArmors = null,
		$dataEnemies = null,
		$dataTroops = null,
		$dataStates = null,
		$dataAnimations = null,
		$dataTilesets = null,
		$dataCommonEvents = null,
		$dataSystem = null,
		$dataMapInfos = null,
		$dataMap = null,
		$gameTemp = null,
		$gameSystem = null,
		$gameScreen = null,
		$gameTimer = null,
		$gameMessage = null,
		$gameSwitches = null,
		$gameVariables = null,
		$gameSelfSwitches = null,
		$gameActors = null,
		$gameParty = null,
		$gameTroop = null,
		$gameMap = null,
		$gamePlayer = null,
		$testEvent = null;
	class Render_Thread {
		constructor() {
			throw new Error('This is a static class');
		}
		static _setupPixiSettings() {
			(settings$4.SCALE_MODE = SCALE_MODES$9.NEAREST),
				(settings$4.ROUND_PIXELS = !0),
				(settings$4.GC_MAX_IDLE = 600),
				(settings$4.MIPMAP_TEXTURES = MIPMAP_MODES$9.OFF),
				(settings$4.RESOLUTION = window.devicePixelRatio),
				Utils.isMobileSafari() &&
					(settings$4.PRECISION_FRAGMENT = PRECISION$9.HIGH);
		}
		static _setupGlobals() {
			(self.$dataActors = $dataActors),
				(self.$dataClasses = $dataClasses),
				(self.$dataSkills = $dataSkills),
				(self.$dataItems = $dataItems),
				(self.$dataWeapons = $dataWeapons),
				(self.$dataArmors = $dataArmors),
				(self.$dataEnemies = $dataEnemies),
				(self.$dataTroops = $dataTroops),
				(self.$dataStates = $dataStates),
				(self.$dataAnimations = $dataAnimations),
				(self.$dataTilesets = $dataTilesets),
				(self.$dataCommonEvents = $dataCommonEvents),
				(self.$dataSystem = $dataSystem),
				(self.$dataMapInfos = $dataMapInfos),
				(self.$dataMap = $dataMap),
				(self.$gameTemp = $gameTemp),
				(self.$gameSystem = $gameSystem),
				(self.$gameScreen = $gameScreen),
				(self.$gameTimer = $gameTimer),
				(self.$gameMessage = $gameMessage),
				(self.$gameSwitches = $gameSwitches),
				(self.$gameVariables = $gameVariables),
				(self.$gameSelfSwitches = $gameSelfSwitches),
				(self.$gameActors = $gameActors),
				(self.$gameParty = $gameParty),
				(self.$gameTroop = $gameTroop),
				(self.$gameMap = $gameMap),
				(self.$gamePlayer = $gamePlayer),
				(self.$testEvent = $testEvent),
				(self.Game_Temp = Game_Temp),
				(self.Game_System = Game_System),
				(self.Game_Timer = Game_Timer),
				(self.Game_Message = Game_Message),
				(self.Game_Switches = Game_Switches),
				(self.Game_Variables = Game_Variables),
				(self.Game_SelfSwitches = Game_SelfSwitches),
				(self.Game_Screen = Game_Screen),
				(self.Game_Picture = Game_Picture),
				(self.Game_Item = Game_Item),
				(self.Game_Action = Game_Action),
				(self.Game_ActionResult = Game_ActionResult),
				(self.Game_BattlerBase = Game_BattlerBase),
				(self.Game_Battler = Game_Battler),
				(self.Game_Actor = Game_Actor),
				(self.Game_Enemy = Game_Enemy),
				(self.Game_Actors = Game_Actors),
				(self.Game_Unit = Game_Unit),
				(self.Game_Party = Game_Party),
				(self.Game_Troop = Game_Troop),
				(self.Game_Map = Game_Map),
				(self.Game_CommonEvent = Game_CommonEvent),
				(self.Game_CharacterBase = Game_CharacterBase),
				(self.Game_Character = Game_Character),
				(self.Game_Player = Game_Player),
				(self.Game_Follower = Game_Follower),
				(self.Game_Followers = Game_Followers),
				(self.Game_Vehicle = Game_Vehicle),
				(self.Game_Event = Game_Event),
				(self.Game_Interpreter = Game_Interpreter),
				(self.Scene_Base = Scene_Base),
				(self.Scene_Boot = Scene_Boot),
				(self.Scene_Title = Scene_Title),
				(self.Scene_Map = Scene_Map),
				(self.Scene_MenuBase = Scene_MenuBase),
				(self.Scene_Menu = Scene_Menu),
				(self.Scene_ItemBase = Scene_ItemBase),
				(self.Scene_Item = Scene_Item),
				(self.Scene_Skill = Scene_Skill),
				(self.Scene_Equip = Scene_Equip),
				(self.Scene_Status = Scene_Status),
				(self.Scene_Options = Scene_Options),
				(self.Scene_File = Scene_File),
				(self.Scene_Save = Scene_Save),
				(self.Scene_Load = Scene_Load),
				(self.Scene_GameEnd = Scene_GameEnd),
				(self.Scene_Shop = Scene_Shop),
				(self.Scene_Name = Scene_Name),
				(self.Scene_Debug = Scene_Debug),
				(self.Scene_Battle = Scene_Battle),
				(self.Scene_Gameover = Scene_Gameover),
				(self.Sprite_Base = Sprite_Base),
				(self.Sprite_Button = Sprite_Button),
				(self.Sprite_Character = Sprite_Character),
				(self.Sprite_Battler = Sprite_Battler),
				(self.Sprite_Actor = Sprite_Actor),
				(self.Sprite_Enemy = Sprite_Enemy),
				(self.Sprite_Animation = Sprite_Animation),
				(self.Sprite_Damage = Sprite_Damage),
				(self.Sprite_StateIcon = Sprite_StateIcon),
				(self.Sprite_StateOverlay = Sprite_StateOverlay),
				(self.Sprite_Weapon = Sprite_Weapon),
				(self.Sprite_Balloon = Sprite_Balloon),
				(self.Sprite_Picture = Sprite_Picture),
				(self.Sprite_Timer = Sprite_Timer),
				(self.Sprite_Destination = Sprite_Destination),
				(self.Spriteset_Base = Spriteset_Base),
				(self.Spriteset_Map = Spriteset_Map),
				(self.Spriteset_Battle = Spriteset_Battle),
				(self.Window_Base = Window_Base),
				(self.Window_Selectable = Window_Selectable),
				(self.Window_Command = Window_Command),
				(self.Window_HorzCommand = Window_HorzCommand),
				(self.Window_Help = Window_Help),
				(self.Window_Gold = Window_Gold),
				(self.Window_MenuCommand = Window_MenuCommand),
				(self.Window_MenuStatus = Window_MenuStatus),
				(self.Window_MenuActor = Window_MenuActor),
				(self.Window_ItemCategory = Window_ItemCategory),
				(self.Window_ItemList = Window_ItemList),
				(self.Window_SkillType = Window_SkillType),
				(self.Window_SkillStatus = Window_SkillStatus),
				(self.Window_SkillList = Window_SkillList),
				(self.Window_EquipStatus = Window_EquipStatus),
				(self.Window_EquipCommand = Window_EquipCommand),
				(self.Window_EquipSlot = Window_EquipSlot),
				(self.Window_EquipItem = Window_EquipItem),
				(self.Window_Status = Window_Status),
				(self.Window_Options = Window_Options),
				(self.Window_SavefileList = Window_SavefileList),
				(self.Window_ShopCommand = Window_ShopCommand),
				(self.Window_ShopBuy = Window_ShopBuy),
				(self.Window_ShopSell = Window_ShopSell),
				(self.Window_ShopNumber = Window_ShopNumber),
				(self.Window_ShopStatus = Window_ShopStatus),
				(self.Window_NameEdit = Window_NameEdit),
				(self.Window_NameInput = Window_NameInput),
				(self.Window_ChoiceList = Window_ChoiceList),
				(self.Window_NumberInput = Window_NumberInput),
				(self.Window_EventItem = Window_EventItem),
				(self.Window_Message = Window_Message),
				(self.Window_ScrollText = Window_ScrollText),
				(self.Window_MapName = Window_MapName),
				(self.Window_BattleLog = Window_BattleLog),
				(self.Window_PartyCommand = Window_PartyCommand),
				(self.Window_ActorCommand = Window_ActorCommand),
				(self.Window_BattleStatus = Window_BattleStatus),
				(self.Window_BattleActor = Window_BattleActor),
				(self.Window_BattleEnemy = Window_BattleEnemy),
				(self.Window_BattleSkill = Window_BattleSkill),
				(self.Window_BattleItem = Window_BattleItem),
				(self.Window_TitleCommand = Window_TitleCommand),
				(self.Window_GameEnd = Window_GameEnd),
				(self.Window_DebugRange = Window_DebugRange),
				(self.Window_DebugEdit = Window_DebugEdit),
				(self.ProgressWatcher = ProgressWatcher),
				(self.Utils = Utils),
				(self.CacheEntry = CacheEntry),
				(self.CacheMap = CacheMap),
				(self.ImageCache = ImageCache),
				(self.RequestQueue = RequestQueue),
				(self.Point = Point),
				(self.Rectangle = Rectangle),
				(self.Bitmap = Bitmap),
				(self.BitmapPIXI = BitmapPIXI),
				(self.Graphics = Graphics),
				(self.Input = Input),
				(self.TouchInput = TouchInput),
				(self.Sprite = Sprite),
				(self.Tilemap = Tilemap),
				(self.ShaderTilemap = ShaderTilemap),
				(self.TilingSprite = TilingSprite),
				(self.ScreenSprite = ScreenSprite),
				(self.WindowSkinCache = WindowSkinCache),
				(self.Window = Window),
				(self.WindowLayer = WindowLayer),
				(self.Weather = Weather),
				(self.ToneFilter = ToneFilter),
				(self.ToneSprite = ToneSprite),
				(self.Stage = Stage),
				(self.WebAudio = WebAudio),
				(self.JsonEx = JsonEx),
				(self.Decrypter = Decrypter),
				(self.ResourceHandler = ResourceHandler),
				(self.DataManager = DataManager$1),
				(self.ConfigManager = ConfigManager),
				(self.StorageManager = StorageManagerShim),
				(self.ImageManager = ImageManager),
				(self.AudioManager = AudioManager),
				(self.SoundManager = SoundManager),
				(self.TextManager = TextManager),
				(self.SceneManager = SceneManager),
				(self.BattleManager = BattleManager),
				(self.PluginManager = PluginManager);
		}
		static async updateData(t, e) {
			'plugins' === t
				? (self.$plugins = e.data)
				: 'window' === t &&
				  Object.entries(e.data).forEach(([t, e]) => (self.window[t] = e));
		}
		static async receiveEvent(t, e) {}
		static async start() {
			this._setupGlobals(),
				this._setupPixiSettings(),
				PluginManager.setup($plugins),
				Utils.isWorker() || 'complete' === document.readyState
					? SceneManager.run(Scene_Boot)
					: window.addEventListener('load', () => SceneManager.run(Scene_Boot));
		}
	}
	Utils.isWorker() ? expose(Render_Thread) : Render_Thread.start();
})();
